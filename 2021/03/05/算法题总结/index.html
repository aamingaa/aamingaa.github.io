<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] mid3.无重复字符的最长子串1set+双指针i，j 当j不包含时候，添加并计算max，否则，左边界右移动  15.三数之和排序，for里面套一个双指针while，注意去重 12345678910111213141516while()&amp;#123;		if(cur&#x3D;&#x3D;0)           &amp;#123;             ...              wh">
<meta property="og:type" content="article">
<meta property="og:title" content="算法题总结">
<meta property="og:url" content="http://aamingaa.github.io/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[TOC] mid3.无重复字符的最长子串1set+双指针i，j 当j不包含时候，添加并计算max，否则，左边界右移动  15.三数之和排序，for里面套一个双指针while，注意去重 12345678910111213141516while()&amp;#123;		if(cur&#x3D;&#x3D;0)           &amp;#123;             ...              wh">
<meta property="og:image" content="http://aamingaa.github.io/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210305092007327.png">
<meta property="og:image" content="http://aamingaa.github.io/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210305093152907.png">
<meta property="og:image" content="http://aamingaa.github.io/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210305093719625.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/oD5ruyVxxVGRJ4bSda4dThHBeSbNib3NpjEWPqmIgHluopXk7FBTby4zWaLlggUwIicicCaPHz4ISHSrWGZuibUhxQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png">
<meta property="og:image" content="http://aamingaa.github.io/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210307115017107.png">
<meta property="og:image" content="http://aamingaa.github.io/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210308095816745.png">
<meta property="og:image" content="http://aamingaa.github.io/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210308100250659.png">
<meta property="og:image" content="http://aamingaa.github.io/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210309125320229.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg">
<meta property="article:published_time" content="2021-03-04T16:41:02.000Z">
<meta property="article:modified_time" content="2021-03-11T02:22:59.473Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://aamingaa.github.io/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210305092007327.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://aamingaa.github.io/2021/03/05/算法题总结/"/>





  <title>算法题总结 | Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aamingaa.github.io/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法题总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-05T00:41:02+08:00">
                2021-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  23.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  110
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="mid"><a href="#mid" class="headerlink" title="mid"></a>mid</h3><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set+双指针i，j 当j不包含时候，添加并计算max，否则，左边界右移动</span><br></pre></td></tr></table></figure>

<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h4><p>排序，for里面套一个双指针while，注意去重</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while()</span><br><span class="line">&#123;		if(cur&#x3D;&#x3D;0)</span><br><span class="line">           &#123;</span><br><span class="line">             ...</span><br><span class="line">              while(start&lt;end &amp;&amp; nums[start]&#x3D;&#x3D;nums[start+1])</span><br><span class="line">              &#123;</span><br><span class="line">                  start++;</span><br><span class="line">              &#125;</span><br><span class="line">               while(start&lt;end &amp;&amp; nums[end]&#x3D;&#x3D;nums[end-1])</span><br><span class="line">              &#123;</span><br><span class="line">                  end--;</span><br><span class="line">              &#125;</span><br><span class="line">              start++;</span><br><span class="line">              end--;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="146-LRU缓存"><a href="#146-LRU缓存" class="headerlink" title="146.LRU缓存"></a>146.LRU缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一个HashMap&lt;Integer,Node&gt; map    </span><br><span class="line">Node&lt;key,value&gt;  </span><br><span class="line">removeNode(Node n) </span><br><span class="line">insertToHead(Node n)</span><br><span class="line">put()</span><br><span class="line">&#123;</span><br><span class="line"> if(map.size()&#x3D;&#x3D;capacity)&#123;</span><br><span class="line">  map.remove();</span><br><span class="line">  removeNode();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103.二叉树的锯齿形层序遍历"></a>103.二叉树的锯齿形层序遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(0,node.val)</span><br></pre></td></tr></table></figure>

<h4 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">快排</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line"> int index&#x3D;partition(arr,l,r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(preorder[ps]!&#x3D;inorder[is+index]) index++;</span><br></pre></td></tr></table></figure>

<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(i&#x3D;&#x3D;size-1) res.add(node.val);</span><br></pre></td></tr></table></figure>

<h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (l &lt;&#x3D; r &amp;&amp; u &lt;&#x3D; d)&#123;</span><br><span class="line">            for (int i &#x3D; l; i &lt;&#x3D; r; i++) &#123;</span><br><span class="line">                list.add(matrix[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            u++;</span><br><span class="line">            ......</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(nums[mid]&lt;nums[right])</span><br><span class="line">      &#123;</span><br><span class="line">         if(target&lt;&#x3D;nums[right] &amp;&amp; target&gt;nums[mid])</span><br><span class="line">         &#123;</span><br><span class="line">            left&#x3D;mid+1; </span><br><span class="line">         &#125;</span><br><span class="line">         else </span><br><span class="line">            right&#x3D;mid-1; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(left!&#x3D;null &amp;&amp; right&#x3D;&#x3D;null)</span><br><span class="line">    &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(left&#x3D;&#x3D;null &amp;&amp; right!&#x3D;null)</span><br><span class="line">    &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(left!&#x3D;null &amp;&amp; right!&#x3D;null)</span><br><span class="line">      return root;</span><br></pre></td></tr></table></figure>

<h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h4><p>从后往前找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1,1,5]</span><br><span class="line"></span><br><span class="line">[1,5,1]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while(i&gt;&#x3D;0 &amp;&amp; nums[i]&gt;&#x3D;nums[i+1])</span><br><span class="line">  &#123;</span><br><span class="line">      i--;</span><br><span class="line">  &#125;</span><br><span class="line">  if(i&gt;&#x3D;0)</span><br><span class="line">  &#123;</span><br><span class="line">      int j&#x3D;nums.length-1;</span><br><span class="line">      while(j&gt;i &amp;&amp; nums[j] &lt;&#x3D; nums[i])</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="排序奇升偶降链表"><a href="#排序奇升偶降链表" class="headerlink" title="排序奇升偶降链表"></a>排序奇升偶降链表</h4><ol>
<li><p>按奇偶位置拆分链表，得1-&gt;3-&gt;5-&gt;7-&gt;NULL和8-&gt;6-&gt;4-&gt;2-&gt;NULL</p>
</li>
<li><p>反转偶链表，得1-&gt;3-&gt;5-&gt;7-&gt;NULL和2-&gt;4-&gt;6-&gt;8-&gt;NULL</p>
</li>
<li><p>合并两个有序链表，得1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL</p>
</li>
</ol>
<h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode next &#x3D; head.next;</span><br><span class="line">head.next &#x3D; swapPairs(next.next);</span><br><span class="line">next.next &#x3D; head;</span><br></pre></td></tr></table></figure>

<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean validate(TreeNode node, long min, long max) &#123;</span><br><span class="line">       if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       if (node.val &lt;&#x3D; min || node.val &gt;&#x3D; max) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return  validate(node.left, min, node.val) &amp;&amp; validate(node.right, node.val, max);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="958-二叉树的完全性检验"><a href="#958-二叉树的完全性检验" class="headerlink" title="958. 二叉树的完全性检验"></a>958. 二叉树的完全性检验</h4><p>广度进行遍历，设一个前驱指针prev，判断prev==null &amp;&amp; node！=null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (prev &#x3D;&#x3D; null &amp;&amp; node !&#x3D; null)</span><br><span class="line">                return false;</span><br><span class="line">            if (node !&#x3D; null) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            prev &#x3D; node;</span><br></pre></td></tr></table></figure>

<h4 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h4><p>回溯</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(char[][] board,int n,int m,int i,int j,char[] cs,int index)</span><br><span class="line"></span><br><span class="line">boolean flag&#x3D;helper(board,n,m,i+1,j,cs,index+1)||helper(board,n,m,i-1,j,cs,index+1)||helper(board,n,m,i,j+1,cs,index+1)||helper(board,n,m,i,j-1,cs,index+1);</span><br></pre></td></tr></table></figure>

<h4 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a>143. 重排链表</h4><p>给定一个单链表 <em>L</em>：<em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n ，<br>将其重新排列后变为： <em>L</em>0→<em>L<strong>n<em>→</em>L<em>1→</em>L</strong>n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p>
<p>快慢指针找中点，反转，链表合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode slow&#x3D;head,fast&#x3D;head.next;</span><br><span class="line">reverse()</span><br><span class="line">merge</span><br></pre></td></tr></table></figure>

<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h4><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int start &#x3D; i; start &lt; candidates.length; start++)</span><br></pre></td></tr></table></figure>

<h4 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a>518. 零钱兑换 II</h4><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
<p>示例 1:</p>
<p>输入: amount = 5, coins = [1, 2, 5]<br>输出: 4<br>解释: 有四种方式可以凑成总金额:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int dp[][] &#x3D; new int[n+1][amount+1];</span><br><span class="line">       dp[0][0] &#x3D; 1;&#x2F;&#x2F;                   前n个，凑成值为amount</span><br><span class="line">       ...</span><br><span class="line">dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">if(j &gt;&#x3D; coins[i-1]) dp[i][j] +&#x3D; dp[i][j-coins[i-1]];</span><br></pre></td></tr></table></figure>

<h4 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a>162. 寻找峰值</h4><p>峰值元素是指其值大于左右相邻值的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(nums[mid]&gt;&#x3D;nums[mid+1])</span><br><span class="line">&#123;</span><br><span class="line">	right&#x3D;mid; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h4><p>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> int left&#x3D;intervals[i][0];</span><br><span class="line">    right&#x3D;intervals[i][1];</span><br><span class="line">    while(i&lt;intervals.length-1 &amp;&amp; right&gt;&#x3D;intervals[i+1][0])</span><br><span class="line">    &#123;</span><br><span class="line">    right&#x3D;Math.max(right,intervals[i+1][1]);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">return arr.toArray(new int[arr.size()][2]);</span><br></pre></td></tr></table></figure>

<h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h4><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。 </p>
<ul>
<li>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</li>
</ul>
<p>快慢指针找中心点</p>
<p>归并排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode l1&#x3D;mergeSort(head);</span><br><span class="line">   ListNode l2&#x3D;mergeSort(slow);</span><br><span class="line">   return mergeSort(l1,l2);</span><br></pre></td></tr></table></figure>

<h4 id="470-用-Rand7-实现-Rand10"><a href="#470-用-Rand7-实现-Rand10" class="headerlink" title="470. 用 Rand7() 实现 Rand10()"></a>470. 用 Rand7() 实现 Rand10()</h4><p>(rand_X() - 1) × Y + rand_Y() ==&gt; 可以等概率的生成[1, X * Y]范围的随机数</p>
<p>即实现了 rand_XY()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(true) &#123;</span><br><span class="line">            int num &#x3D; (rand7() - 1) * 7 + rand7(); &#x2F;&#x2F; 等概率生成[1,49]范围的随机数</span><br><span class="line">            if(num &lt;&#x3D; 40) return num % 10 + 1; &#x2F;&#x2F; 拒绝采样，并返回[1,10]范围的随机数</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a>662. 二叉树最大宽度</h4><p><img src="/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210305092007327.png" alt="image-20210305092007327"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Node,Integer&gt;</span><br><span class="line">while(!q.isEmpty())</span><br><span class="line">&#123;</span><br><span class="line">  max&#x3D;Math.max(max,map.get(queue.peekLast())-map.get(queue.peekFirst())+1);</span><br><span class="line">  ..</span><br><span class="line">  if(temp.left!&#x3D;null)</span><br><span class="line">  &#123;</span><br><span class="line">  queue.add(temp.left);</span><br><span class="line">  map.put(temp.left,map.get(temp)*2);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="木头切割问题"><a href="#木头切割问题" class="headerlink" title="木头切割问题"></a>木头切割问题</h4><p>给定长度为n的数组，每个元素代表一个木头的长度，木头可以任意截断，从这堆木头中截出至少k个相同长度为m的木块。已知k，求max(m)。</p>
<p>输入两行，第一行n, k，第二行为数组序列。输出最大值。</p>
<p><img src="/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210305093152907.png" alt="image-20210305093152907"></p>
<p>暴力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while (1 &lt;&#x3D; maxV)</span><br><span class="line">&#123;</span><br><span class="line">    int cnt &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i ++ ) cnt +&#x3D; a[i] &#x2F; m;</span><br><span class="line">    if (cnt &gt;&#x3D; k) res &#x3D; max(res, cnt);  &#x2F;&#x2F; 如果当前可以截出来超过k段，就更新结果</span><br><span class="line">    m ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>二分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 100010;</span><br><span class="line">int a[N];</span><br><span class="line">int n, k;</span><br><span class="line"></span><br><span class="line">int check(int mid)</span><br><span class="line">&#123;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i ++ ) res +&#x3D; a[i] &#x2F; mid;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    int l &#x3D; 1, r &#x3D; -1;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        r &#x3D; max(r, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid &#x3D; l + r + 1 &gt;&gt; 1;</span><br><span class="line">        if (check(mid) &gt;&#x3D; k) l &#x3D; mid;</span><br><span class="line">        else r &#x3D; mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="圆环回原点问题"><a href="#圆环回原点问题" class="headerlink" title="圆环回原点问题"></a>圆环回原点问题</h4><p><img src="/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210305093719625.png" alt="image-20210305093719625"></p>
<p>走n步到0的方案数=走n-1步到1的方案数+走n-1步到9的方案数。</p>
<p>因此，若设dp[i][j]为从0点出发走i步到j点的方案数，则递推式为：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/oD5ruyVxxVGRJ4bSda4dThHBeSbNib3NpjEWPqmIgHluopXk7FBTby4zWaLlggUwIicicCaPHz4ISHSrWGZuibUhxQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>ps:公式之所以取余是因为j-1或j+1可能会超过圆环0~9的范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def backToOrigin(self,n):</span><br><span class="line">        #点的个数为10</span><br><span class="line">        length &#x3D; 10</span><br><span class="line">        dp &#x3D; [[0 for i in range(length)] for j in range(n+1)]</span><br><span class="line">        dp[0][0] &#x3D; 1</span><br><span class="line">        for i in range(1,n+1):</span><br><span class="line">            for j in range(length):</span><br><span class="line">                #dp[i][j]表示从0出发，走i步到j的方案数</span><br><span class="line">                dp[i][j] &#x3D; dp[i-1][(j-1+length)%length] + dp[i-1][(j+1)%length]</span><br><span class="line">        return dp[n][0]</span><br></pre></td></tr></table></figure>

<h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h4><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;amount+1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[0][i]&#x3D;0x3f3f3f3f;</span><br><span class="line">    &#125;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;coins.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;amount+1;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(j&gt;&#x3D;coins[i-1]) f[i][j]&#x3D;Math.min(f[i-1][j],f[i][j-coins[i-1]]+1);</span><br><span class="line">            else&#123;</span><br><span class="line">                f[i][j]&#x3D;f[i-1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h4><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>先全部压入栈里面，不行就弹出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(!stack.isEmpty() &amp;&amp; T[stack.peek()]&lt;T[i])</span><br><span class="line">      &#123;</span><br><span class="line">        int temp&#x3D;stack.pop();</span><br><span class="line">        res[temp]&#x3D; i-temp;</span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(i);</span><br></pre></td></tr></table></figure>

<h4 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a>560. 和为K的子数组</h4><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<p>输入:nums = [1,1,1], k = 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</p>
<h4 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h4><p>双指针整体反转+局部反转+去除空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while(r&lt;&#x3D;cs.length)</span><br><span class="line">    &#123;</span><br><span class="line">        if(r&#x3D;&#x3D;cs.length || cs[r]&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(cs,l,r-1);</span><br><span class="line">            l&#x3D;r+1;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;         </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    while(j&lt;n)&#123;</span><br><span class="line">           while(j&lt;n&amp;&amp;ch[j]&#x3D;&#x3D;&#39; &#39;)j++;&#x2F;&#x2F;找到第一个不为空格的首字母的位置；</span><br><span class="line">           while(j&lt;n&amp;&amp;ch[j]!&#x3D;&#39; &#39;)ch[i++]&#x3D;ch[j++];&#x2F;&#x2F;将不为空格的字母前移，消除空格；</span><br><span class="line">           while(j&lt;n&amp;&amp;ch[j]&#x3D;&#x3D;&#39; &#39;)j++;&#x2F;&#x2F;之后又遇到一个空格;</span><br><span class="line">           if(j&lt;n) ch[i++] &#x3D; &#39; &#39;;&#x2F;&#x2F;保留一个空格</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="670-最大交换"><a href="#670-最大交换" class="headerlink" title="670. 最大交换"></a>670. 最大交换</h4><p>先排序，然后设置diff，从后向前找到第一个不相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (oldNum[i] !&#x3D; orderNum[orderNum.length - 1 - i])         </span><br><span class="line"> for (int i &#x3D; oldNum.length - 1; i &gt;&#x3D; diff; i--) &#123;</span><br><span class="line"> ...</span><br><span class="line">            if (oldNum[i] &#x3D;&#x3D; orderNum[orderNum.length - 1 - diff])</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h4 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a>91. 解码方法</h4><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”111” 可以将 “1” 中的每个 “1” 映射为 “A” ，从而得到 “AAA” ，或者可以将 “11” 和 “1”（分别为 “K” 和 “A” ）映射为 “KA” 。注意，”06” 不能映射为 “F” ，因为 “6” 和 “06” 不同。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] dp&#x3D;new int[length+1];</span><br><span class="line">dp[0]&#x3D;1;</span><br><span class="line">for(int i&#x3D;0;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    dp[i+1]&#x3D;s.charAt(i)&#x3D;&#x3D;&#39;0&#39;?0:dp[i];</span><br><span class="line">    if(i&gt;0 &amp;&amp; (s.charAt(i-1)&#x3D;&#x3D;&#39;1&#39;||(s.charAt(i-1)&#x3D;&#x3D;&#39;2&#39; &amp;&amp; s.charAt(i)&lt;&#x3D;&#39;6&#39; </span><br><span class="line">    )))</span><br><span class="line">    dp[i+1]+&#x3D;dp[i-1];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h4><p>输入:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]</p>
<p>如果剩余量小于0，比如要前面的都失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">run+&#x3D;(gas[i]-cost[i]);</span><br><span class="line">   rest+&#x3D;(gas[i]-cost[i]);</span><br><span class="line">   if(run&lt;0)</span><br><span class="line">   &#123;</span><br><span class="line">   start&#x3D;i+1;</span><br><span class="line">   run&#x3D;0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a>138. 复制带随机指针的链表</h4><p>三次O(n)</p>
<p>第一次新增节点</p>
<p>第二次随即指针</p>
<p>第三次拆分</p>
<p>注意拆分最后一步  cur.next=null;</p>
<h4 id="36进制加法"><a href="#36进制加法" class="headerlink" title="36进制加法"></a>36进制加法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">char getChar(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if (n &lt;&#x3D; 9)</span><br><span class="line">        return n + &#39;0&#39;;</span><br><span class="line">    else</span><br><span class="line">        return n - 10 + &#39;a&#39;;</span><br><span class="line">&#125;</span><br><span class="line">int getInt(char ch)</span><br><span class="line">&#123;</span><br><span class="line">    if (&#39;0&#39; &lt;&#x3D; ch &amp;&amp; ch &lt;&#x3D; &#39;9&#39;)</span><br><span class="line">        return ch - &#39;0&#39;;</span><br><span class="line">    else</span><br><span class="line">        return ch - &#39;a&#39; + 10;</span><br><span class="line">&#125;</span><br><span class="line">string add36Strings(string num1, string num2)</span><br><span class="line">&#123;</span><br><span class="line">    int carry &#x3D; 0;</span><br><span class="line">    int i &#x3D; num1.size() - 1, j &#x3D; num2.size() - 1;</span><br><span class="line">    int x, y;</span><br><span class="line">    string res;</span><br><span class="line">    while (i &gt;&#x3D; 0 || j &gt;&#x3D; 0 || carry)</span><br><span class="line">    &#123;</span><br><span class="line">        x &#x3D; i &gt;&#x3D; 0 ? getInt(num1[i]) : 0;</span><br><span class="line">        y &#x3D; j &gt;&#x3D; 0 ? getInt(num2[j]) : 0;</span><br><span class="line">        int temp &#x3D; x + y + carry;</span><br><span class="line">        res +&#x3D; getChar(temp % 36);</span><br><span class="line">        carry &#x3D; temp &#x2F; 36;</span><br><span class="line">        i--, j--;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));</span><br></pre></td></tr></table></figure>

<h4 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a>93. 复原 IP 地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for(int a&#x3D;1;a&lt;4;a++)</span><br><span class="line">       for(int b&#x3D;1;b&lt;4;b++)</span><br><span class="line">        for(int c&#x3D;1;c&lt;4;c++)</span><br><span class="line">         for(int d&#x3D;1;d&lt;4;d++)</span><br><span class="line">          &#123;</span><br><span class="line">           if(a+b+c+d&#x3D;&#x3D;s.length())</span><br><span class="line">           &#123;</span><br><span class="line">           int n1&#x3D;Integer.parseInt(s.substring(0,a));</span><br><span class="line">           int n2&#x3D;Integer.parseInt(s.substring(a,a+b));</span><br><span class="line">           int n3&#x3D;Integer.parseInt(s.substring(a+b,a+b+c));</span><br><span class="line">           int n4&#x3D;Integer.parseInt(s.substring(a+b+c));</span><br></pre></td></tr></table></figure>

<h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(text1.charAt(i-1)&#x3D;&#x3D;text2.charAt(j-1))</span><br><span class="line"> &#123;</span><br><span class="line">              dp[i][j]&#x3D;dp[i-1][j-1]+1;</span><br><span class="line">  &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;x&#96;</span><br><span class="line">        dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="560-和为K的子数组-1"><a href="#560-和为K的子数组-1" class="headerlink" title="560.和为K的子数组"></a>560.和为K的子数组</h4><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<p><strong>示例 1 :</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum +&#x3D; nums[i];</span><br><span class="line">if(map.containsKey(sum-k))</span><br><span class="line">&#123;</span><br><span class="line">    ret +&#x3D; map.get(sum-k); </span><br><span class="line">    System.out.println(&quot; sum  : &quot;+String.valueOf(sum)+&quot; ret: &quot;+ret+&quot; &quot;+map.get(sum-k)); </span><br><span class="line">&#125;               </span><br><span class="line">map.put(sum, map.getOrDefault(sum, 0)+1);</span><br></pre></td></tr></table></figure>

<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h4><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum +&#x3D; nums[j];</span><br><span class="line">while (sum &gt;&#x3D; s) &#123;</span><br><span class="line">    len &#x3D; len &#x3D;&#x3D; 0 ? j - i + 1 : Math.min(len, j - i + 1);</span><br><span class="line">    sum -&#x3D; nums[i++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a>974. 和可被 K 整除的子数组</h4><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p>
<p>示例：</p>
<p>输入：A = [4,5,0,-2,-3,1], K = 5<br>输出：7<br>解释：<br>有 7 个子数组满足其元素之和可被 K = 5 整除：<br>[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</p>
<p>为了可以处理数组一开始就能被k整除，需要设置 modK[0]=1;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modK[0]&#x3D;1;</span><br><span class="line">...</span><br><span class="line">sum&#x3D; ((sum+tmp)%K+K)%K;</span><br><span class="line">        cnt+&#x3D; modK[sum];</span><br><span class="line">        modK[sum]++;</span><br></pre></td></tr></table></figure>

<h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h4><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。</p>
<p>示例 1：</p>
<p>输入：nums = [1,3,4,2,2]<br>输出：2</p>
<p>快慢指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        fast&#x3D;nums[nums[fast]];</span><br><span class="line">        slow&#x3D;nums[slow];</span><br><span class="line">        if(fast&#x3D;&#x3D;slow)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fast&#x3D;0;</span><br><span class="line">    while(fast!&#x3D;slow)</span><br><span class="line">    &#123;</span><br><span class="line">        fast&#x3D;nums[fast];</span><br><span class="line">        slow&#x3D;nums[slow];</span><br><span class="line">    &#125;</span><br><span class="line">    return fast;</span><br></pre></td></tr></table></figure>

<h4 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a>210. 课程表 II</h4><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>示例 1:</p>
<p>输入: 2, [[1,0]]<br>输出: [0,1]<br>解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</p>
<p>先构造一个图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] lists &#x3D; new ArrayList[numCourses];</span><br></pre></td></tr></table></figure>

<p>//记录某个节点的入度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] points &#x3D; new int[numCourses];</span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">points[p[0]]++;</span><br><span class="line">if(lists[p[1]] &#x3D;&#x3D; null)&#123;</span><br><span class="line">lists[p[1]] &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">lists[p[1]].add(p[0]);</span><br></pre></td></tr></table></figure>

<p>所以入度为0加入到队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; numCourses; i++)&#123;</span><br><span class="line">           &#x2F;&#x2F;入度为 0，添加到队列中</span><br><span class="line">           if(points[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">               queue.add(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>依次对指向的结点度减一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list &#x3D; lists[p];</span><br></pre></td></tr></table></figure>

<h4 id="528-按权重随机选择"><a href="#528-按权重随机选择" class="headerlink" title="528. 按权重随机选择"></a>528. 按权重随机选择</h4><p>给定一个正整数数组 w ，其中 w[i] 代表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。</p>
<p>例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。</p>
<p>也就是说，选取下标 i 的概率为 w[i] / sum(w) 。</p>
<p>先构造前缀，再二分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;产生随机数</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        int randomNum &#x3D; random.nextInt(arr[arr.length - 1]) + 1;</span><br><span class="line">        &#x2F;&#x2F;二分查找随机数所在的区间</span><br><span class="line">        int left &#x3D; 0, right &#x3D; arr.length - 1;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int mid &#x3D; left + ((right - left) &gt;&gt; 1);</span><br><span class="line">            if (arr[mid] &#x3D;&#x3D; randomNum) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (arr[mid] &gt; randomNum) &#123;</span><br><span class="line">                right &#x3D; mid;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left &#x3D; mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h4><p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">输出: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while(head!&#x3D;null &amp;&amp; head.next!&#x3D;null)</span><br><span class="line">  &#123;</span><br><span class="line">      if(head.val&#x3D;&#x3D;head.next.val)</span><br><span class="line">      &#123;</span><br><span class="line">          while(head.next!&#x3D;null &amp;&amp; head.next!&#x3D;null &amp;&amp; head.val&#x3D;&#x3D;head.next.val)</span><br><span class="line">          &#123;</span><br><span class="line">           . .. . .. . .</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       else&#123;</span><br><span class="line">       </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(s.length()&#x3D;&#x3D;0 || s&#x3D;&#x3D;null) return 0;</span><br><span class="line">s&#x3D;s.trim();</span><br><span class="line">if(s.length()&#x3D;&#x3D;0 || s&#x3D;&#x3D;null) return 0;</span><br><span class="line">...</span><br><span class="line">long a&#x3D;0;</span><br><span class="line">for&#123;</span><br><span class="line">if(!(c&gt;&#x3D;&#39;0&#39; &amp;&amp; c&lt;&#x3D;&#39;9&#39;))</span><br><span class="line">&#123;</span><br><span class="line">return flag?(int)a:(int)-a;</span><br><span class="line">&#125;</span><br><span class="line">a&#x3D;a*10+c-&#39;0&#39;;</span><br><span class="line">if(a&gt;Integer.MAX_VALUE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(n&#x3D;&#x3D;0) return 1; </span><br><span class="line">    if(n&lt;0 &amp;&amp; n%2&#x3D;&#x3D;-1) return 1&#x2F;myPow(x,-(n+1))*1&#x2F;x;</span><br><span class="line">    double half&#x3D;myPow(x,n&#x2F;2);</span><br><span class="line">    if(n%2&#x3D;&#x3D;1) return half*half*x;</span><br><span class="line">    return half*half;</span><br></pre></td></tr></table></figure>

<h4 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147. 对链表进行插入排序"></a>147. 对链表进行插入排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(head!&#x3D;null &amp;&amp; head.next!&#x3D;null)</span><br><span class="line">    &#123;</span><br><span class="line">        if(head.val&#x3D;&#x3D;head.next.val)</span><br><span class="line">        &#123;</span><br><span class="line">            head&#x3D;head.next;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a>264. 丑数 II</h4><p>编写一个程序，找出第 n 个丑数。</p>
<p>丑数就是质因数只包含 2, 3, 5 的正整数。</p>
<p>示例:</p>
<p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p>
<p>三指针+三因子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">   int temp&#x3D;Math.min(fac2*ugly[idx2],Math.min(fac3*ugly[idx3],fac5*ugly[idx5]));</span><br><span class="line">   if(temp&#x3D;&#x3D;fac2*ugly[idx2])</span><br><span class="line">   ...</span><br><span class="line">   ugly[i]&#x3D;temp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a>402. 移掉K位数字</h4><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<p>num 的长度小于 10002 且 ≥ k。<br>num 不会包含任何前导零。<br>示例 1 :</p>
<p>输入: num = “1432219”, k = 3<br>输出: “1219”<br>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</p>
<p>删掉高峰点，每次从头开始寻找高峰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">           int idx &#x3D; 0;</span><br><span class="line">           for (int j &#x3D; 1; j &lt; s.length() &amp;&amp; s.charAt(j) &gt;&#x3D; s.charAt(j - 1); j++) idx &#x3D; j;</span><br><span class="line">           System.out.println(idx+&quot; &quot;+s.charAt(idx));</span><br><span class="line">           s.deleteCharAt(idx);</span><br><span class="line">           while (s.length() &gt; 1 &amp;&amp; s.charAt(0) &#x3D;&#x3D; &#39;0&#39;) s.deleteCharAt(0);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表</h4><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p>
<p>你应当 保留 两个分区中每个节点的初始相对位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode newTemp&#x3D;partition(head.next,x);</span><br></pre></td></tr></table></figure>

<h4 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a>71. 简化路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (item.isEmpty() || item.equals(&quot;.&quot;)) continue;</span><br><span class="line">       if (item.equals(&quot;..&quot;)) &#123;</span><br><span class="line">           if (!stack.empty()) stack.pop();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           stack.push(item);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h4><p>回溯</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void backtrack(List&lt;String&gt; res,int left,int right,String ans,int n)</span><br><span class="line"></span><br><span class="line">if(left&gt;&#x3D;right)</span><br><span class="line">        &#123;</span><br><span class="line">            String str&#x3D;new String(ans);</span><br><span class="line">            backtrack(res,left+1,right,str+&quot;(&quot;,n);</span><br><span class="line">            backtrack(res,left,right+1,str+&quot;)&quot;,n);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h4><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(i&gt;&#x3D;j*j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]&#x3D;Math.min(dp[i],dp[i-j*j]+1);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h4><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict*，判定 *s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p><strong>说明：</strong></p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>

<p>双指针+memo数组记录前n个是否匹配上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(memo[j] &amp;&amp; wordDict.contains(s.substring(j,i)))</span><br><span class="line">            &#123;</span><br><span class="line">                memo[i]&#x3D;true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h4><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>

<p>动态规划，从数组尾部向前遍历，两个for</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(s.charAt(i)&#x3D;&#x3D;s.charAt(j)&amp;&amp; (j-i&lt;&#x3D;2 || dp[i+1][j-1]&#x3D;&#x3D;true) )</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]&#x3D;true;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h4 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h4><p>难度中等805</p>
<p>给定一个包含红色、白色和蓝色，一共 <code>n</code> 个元素的数组，<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>三指针，current,left,right进行遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(nums[current]&#x3D;&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">  swap(nums,left,current);</span><br><span class="line">  current++;</span><br><span class="line">  left++;  </span><br><span class="line">&#125;</span><br><span class="line">else if(nums[current]&#x3D;&#x3D;1)</span><br><span class="line">&#123;</span><br><span class="line">   current++; </span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h4><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure>

<p>用一个StringBuilder sb记录先前的字符串，两个栈一个数字栈，一个字符串栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for(char c : s.toCharArray())&#123;</span><br><span class="line">            if(&#39;0&#39; &lt;&#x3D; c &amp;&amp; &#39;9&#39; &gt;&#x3D; c)&#123;</span><br><span class="line">                mul &#x3D; mul * 10 + (c - &#39;0&#39;);</span><br><span class="line">            &#125;else if(c &#x3D;&#x3D; &#39;[&#39;)&#123;</span><br><span class="line">                &#x2F;&#x2F;遇到左括号，保存前面的值。</span><br><span class="line">                strStack.push(sb);</span><br><span class="line">                numStack.push(mul);</span><br><span class="line">                sb &#x3D; new StringBuilder();</span><br><span class="line">                mul &#x3D; 0;</span><br><span class="line">            &#125;else if(c &#x3D;&#x3D; &#39;]&#39;)&#123;</span><br><span class="line">                &#x2F;&#x2F;出栈</span><br><span class="line">                int cnt &#x3D; numStack.pop();</span><br><span class="line">                StringBuilder tmp &#x3D; sb;</span><br><span class="line">                sb &#x3D; strStack.pop();</span><br><span class="line">                for(int i &#x3D; 0; i &lt; cnt; i++)&#123;</span><br><span class="line">                    sb.append(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a>1438. 绝对差不超过限制的最长连续子数组</h4><p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code> <em>。</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; minQueue &#x3D; new PriorityQueue&lt;&gt;(Comparator.naturalOrder());</span><br><span class="line">...</span><br><span class="line"> maxQueue.remove((Integer) nums[left]);</span><br></pre></td></tr></table></figure>

<h4 id="807-保持城市天际线"><a href="#807-保持城市天际线" class="headerlink" title="807. 保持城市天际线"></a>807. 保持城市天际线</h4><p>最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。 请看下面的例子。</p>
<p>两次两个for，取行和列最大值</p>
<h4 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h4><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<p>两个for，数组长度为num1.length+num2.length,低位为 num[i+j+1]高位 num[i+j]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D; n1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">            for(int j &#x3D; n2; j &gt;&#x3D; 0; --j) &#123;</span><br><span class="line">                int bitmul &#x3D; (num1.charAt(i)-&#39;0&#39;) * (num2.charAt(j)-&#39;0&#39;);      </span><br><span class="line">                bitmul +&#x3D; mul[i+j+1]; &#x2F;&#x2F; 先加低位判断是否有新的进位</span><br><span class="line">                </span><br><span class="line">                mul[i+j] +&#x3D; bitmul &#x2F; 10;</span><br><span class="line">                mul[i+j+1] &#x3D; bitmul % 10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a>496. 下一个更大元素 I</h4><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p>请你找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p>
<p>先用HashMap，遍历nums2.</p>
<h4 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a>503. 下一个更大元素 II</h4><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p>扩容数组，进行循环判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; n*2; i++)&#123;</span><br><span class="line">            int num &#x3D; nums[i % n];</span><br><span class="line">            while(!stack.isEmpty() &amp;&amp; num &gt; nums[stack.peek()])&#123;</span><br><span class="line">                res[stack.pop()] &#x3D; num;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i &lt; n) stack.add(i);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="951-翻转等价二叉树"><a href="#951-翻转等价二叉树" class="headerlink" title="951. 翻转等价二叉树"></a>951. 翻转等价二叉树</h4><p>我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (root1 &#x3D;&#x3D; null || root2 &#x3D;&#x3D; null || root1.val !&#x3D; root2.val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return (flipEquiv(root1.left, root2.left) &amp;&amp; flipEquiv(root1.right, root2.right)) ||</span><br><span class="line">                (flipEquiv(root1.left, root2.right) &amp;&amp; flipEquiv(root1.right, root2.left));</span><br></pre></td></tr></table></figure>

<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a>701. 二叉搜索树中的插入操作</h4><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>用一个parent记录父结点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(p !&#x3D; null)&#123;</span><br><span class="line">     parent &#x3D; p;</span><br><span class="line">     p &#x3D; p.val &lt; val ? p.right : p.left;</span><br><span class="line"> &#125;</span><br><span class="line"> if(parent.val &lt; val)&#123;</span><br><span class="line">     parent.right &#x3D; new TreeNode(val);</span><br></pre></td></tr></table></figure>

<h4 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h4><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>

<p>小于0就进行交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(nums[i] &lt; 0)&#123;          &#x2F;&#x2F; 3 2 -1 -1</span><br><span class="line">                                   &#x2F;&#x2F;   3 6 -2  6</span><br><span class="line">             int tmp &#x3D; imax;      &#x2F;&#x2F;    3 2 -6  2</span><br><span class="line">             imax &#x3D; imin;</span><br><span class="line">             imin &#x3D; tmp;</span><br><span class="line">           &#125;</span><br><span class="line">           imax &#x3D; Math.max(imax*nums[i], nums[i]);</span><br><span class="line">           imin &#x3D; Math.min(imin*nums[i], nums[i]);</span><br></pre></td></tr></table></figure>

<h4 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525. 连续数组"></a>525. 连续数组</h4><p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。</p>
<p>把0变为-1，前缀和+Map进行存储</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sum +&#x3D; nums[i];</span><br><span class="line">    if (sum &#x3D;&#x3D; 0 &amp;&amp; i &gt; res) &#123;</span><br><span class="line">    res &#x3D; i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (map.containsKey(sum)) &#123;</span><br><span class="line">    res &#x3D; Math.max(i - map.get(sum), res);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    map.put(sum, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="468-验证IP地址"><a href="#468-验证IP地址" class="headerlink" title="468. 验证IP地址"></a>468. 验证IP地址</h4><p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。</p>
<ul>
<li>如果是有效的 IPv4 地址，返回 <code>&quot;IPv4&quot;</code> ；</li>
<li>如果是有效的 IPv6 地址，返回 <code>&quot;IPv6&quot;</code> ；</li>
<li>如果不是上述类型的 IP 地址，返回 <code>&quot;Neither&quot;</code> 。</li>
</ul>
<p>对.进行split，要用IP.split(“\.”); split完后判断String[]的长度，是否为4或8</p>
<p>IPV4: 对每个数字字符串，判断是否为数字，然后累加，判断是否大于255</p>
<p>IPV6 :  if (!((c &gt;= ‘a’ &amp;&amp; c &lt;= ‘f’) || (c &gt;= ‘A’ &amp;&amp; c &lt;= ‘F’) || (c &gt;= ‘0’ &amp;&amp; c &lt;= ‘9’)))</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for (String string : strings) &#123;</span><br><span class="line">           if (string.length() &#x3D;&#x3D; 0 || (string.charAt(0) &#x3D;&#x3D; &#39;0&#39; &amp;&amp; string.length() !&#x3D; 1)) &#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">           int num &#x3D; 0;</span><br><span class="line">           for (int i &#x3D; 0; i &lt; string.length(); i++) &#123;</span><br><span class="line">               char c &#x3D; string.charAt(i);</span><br><span class="line">               if (!(c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;)) &#123;</span><br><span class="line">                   return false;</span><br><span class="line">               &#125;</span><br><span class="line">               num &#x3D; num * 10 + c - &#39;0&#39;;</span><br><span class="line">               if (num &gt; 255) &#123;</span><br><span class="line">                   return false;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a>260. 只出现一次的数字 III</h4><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p> 全部异或取结果为K，开一个res数组,res[2] if(num&amp;k)==0 res[1]^=num</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nt k&#x3D;s &amp; (-s);</span><br><span class="line">    int[] res&#x3D;new int[2];</span><br><span class="line">    for(int num:nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if((num &amp;k)&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            res[1]^&#x3D;num;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">         &#123;</span><br><span class="line">             res[0]^&#x3D;num;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h4><p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for(Integer key:map.keySet())</span><br><span class="line">    &#123;</span><br><span class="line">      if(pq.size()&lt;k)</span><br><span class="line">      &#123;</span><br><span class="line">        pq.add(key);  </span><br><span class="line">      &#125;</span><br><span class="line">      else if (map.get(key)&gt;map.get(pq.peek()))</span><br><span class="line">     &#123;</span><br><span class="line">       pq.remove();</span><br><span class="line">       pq.add(key); </span><br><span class="line">     &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="842-将数组拆分成斐波那契序列"><a href="#842-将数组拆分成斐波那契序列" class="headerlink" title="842. 将数组拆分成斐波那契序列"></a>842. 将数组拆分成斐波那契序列</h4><p>给定一个数字字符串 <code>S</code>，比如 <code>S = &quot;123456579&quot;</code>，我们可以将它分成斐波那契式的序列 <code>[123, 456, 579]</code>。</p>
<p>采用dfs，首先考虑一个idx和一个存储先前字符串的idx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean dfs(String s,int idx,LinkedList&lt;Integer&gt; res)</span><br><span class="line">    &#123;</span><br><span class="line">       if(idx&#x3D;&#x3D;s.length())</span><br><span class="line">       &#123;</span><br><span class="line">           return res.size()&gt;2;</span><br><span class="line">       &#125;</span><br><span class="line">       for(int i&#x3D;idx+1;i&lt;&#x3D;s.length();i++)</span><br><span class="line">       &#123;</span><br><span class="line">          String temp&#x3D;s.substring(idx,i);</span><br><span class="line">          if(s.charAt(idx)&#x3D;&#x3D;&#39;0&#39; &amp;&amp; i&gt;idx+1 || Long.valueOf(temp)&gt;Integer.MAX_VALUE)</span><br><span class="line">          &#123;</span><br><span class="line">              break;</span><br><span class="line">          &#125; </span><br><span class="line">          int str&#x3D;Integer.valueOf(temp);</span><br><span class="line">          int one&#x3D;res.size()&gt;&#x3D;2?res.get(res.size()-2):-1;</span><br><span class="line">          int two&#x3D;res.size()&gt;&#x3D;2?res.get(res.size()-1):-1;</span><br><span class="line">          res.add(str);</span><br><span class="line">          if((one&#x3D;&#x3D;-1 || two&#x3D;&#x3D;-1 || one+two&#x3D;&#x3D;str) &amp;&amp; dfs(s,i,res))</span><br><span class="line">          &#123;</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">          res.remove(res.size()-1);</span><br><span class="line">       &#125;</span><br><span class="line">       return false; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a>179. 最大数</h4><p>给定一组非负整数 nums，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。</p>
<p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p>示例 1：</p>
<p>输入：nums = [10,2]<br>输出：”210”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; cmp&#x3D;new Comparator&lt;String&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        public int compare(String str1,String str2)</span><br><span class="line">        &#123;</span><br><span class="line">           String s1&#x3D;str1+str2;</span><br><span class="line">           String s2&#x3D;str2+str1;</span><br><span class="line">           return s2.compareTo(s1);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>动态规划</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i]&#x3D;Math.max(dp[i-1],dp[i-2]+nums[i]);</span><br></pre></td></tr></table></figure>

<h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a>213. 打家劫舍 II</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (len &lt;&#x3D; 2) return len &#x3D;&#x3D; 0 ? 0 : len &#x3D;&#x3D; 1 ? nums[0] : Math.max(nums[0], nums[1]);</span><br><span class="line">       int[] dp1 &#x3D; new int[len - 1];</span><br><span class="line">       int[] dp2 &#x3D; new int[len - 1];</span><br><span class="line">       dp1[0] &#x3D; nums[0];</span><br><span class="line">       dp1[1] &#x3D; Math.max(nums[0], nums[1]);</span><br><span class="line">       dp2[0] &#x3D; nums[1];</span><br><span class="line">       dp2[1] &#x3D; Math.max(nums[2], nums[1]);</span><br><span class="line">       for (int i &#x3D; 2; i &lt; len - 1; i++) &#123;</span><br><span class="line">           dp1[i] &#x3D; Math.max(dp1[i - 1], dp1[i - 2] + nums[i]);</span><br><span class="line">           dp2[i] &#x3D; Math.max(dp2[i - 1], dp2[i - 2] + nums[i + 1]);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="609-在系统中查找重复文件"><a href="#609-在系统中查找重复文件" class="headerlink" title="609. 在系统中查找重复文件"></a>609. 在系统中查找重复文件</h4><p>给定一个目录信息列表，包括目录路径，以及该目录中的所有包含内容的文件，您需要找到文件系统中的所有重复文件组的路径。一组重复的文件至少包括<strong>二个</strong>具有完全相同内容的文件。</p>
<h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h4><p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(s.charAt(i) &#x3D;&#x3D; s.charAt(j))&#123;</span><br><span class="line">dp[i][j] &#x3D; dp[i+1][j-1] + 2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;表明这时dp[i][j]只需取两者之间的最大值即可</span><br><span class="line">else&#123;</span><br><span class="line">dp[i][j] &#x3D; Math.max(dp[i+1][j],dp[i][j-1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h4><p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>注意:</strong></p>
<ol>
<li>每个数组中的元素不会超过 100</li>
<li>数组的大小不会超过 200</li>
</ol>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(j-nums[i-1]&lt;0) dp[i][j]&#x3D;dp[i-1][j];</span><br><span class="line">else&#123;</span><br><span class="line"> dp[i][j]&#x3D;dp[i-1][j]||dp[i-1][j-nums[i-1]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">boolean[] dp&#x3D;new boolean[target+1];</span><br><span class="line">     dp[0]&#x3D;true;</span><br><span class="line">     for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         int num&#x3D;nums[i];</span><br><span class="line">         for(int j&#x3D;target;j&gt;&#x3D;num;j--)</span><br><span class="line">         &#123;</span><br><span class="line">             dp[j]&#x3D;dp[j] || dp[j-num];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h4><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits &#x3D; &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>

<p>设置一个idx往后遍历，对每一个idx取出Map的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String value &#x3D; map.get(digits.charAt(index));</span><br><span class="line"> for (int j &#x3D; 0; j &lt; value.length(); j++) &#123;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; drill down</span><br><span class="line">     backTrack(list, digits, map, index + 1, sb.append(value.charAt(j)));</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; reverse states</span><br><span class="line">     sb.deleteCharAt(sb.length() - 1);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h4><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; map &#x3D; new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">遍历数组，然后Sort一下，存入map</span><br></pre></td></tr></table></figure>

<h4 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a>334. 递增的三元子序列</h4><p>给你一个整数数组 <code>nums</code> ，判断这个数组中是否存在长度为 <code>3</code> 的递增子序列。</p>
<p>如果存在这样的三元组下标 <code>(i, j, k)</code> 且满足 <code>i &lt; j &lt; k</code> ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (nums[i] &lt;&#x3D; first) &#123;</span><br><span class="line">    first &#x3D; nums[i];</span><br><span class="line">    &#125; else if (nums[i] &lt;&#x3D; second) &#123;</span><br><span class="line">    second &#x3D; nums[i];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a>208. 实现 Trie (前缀树)</h4><p>实现一个 Trie (前缀树)，包含 <code>insert</code>, <code>search</code>, 和 <code>startsWith</code> 这三个操作。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 true</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>你可以假设所有的输入都是由小写字母 <code>a-z</code> 构成的。</li>
<li>保证所有输入均为非空字符串。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private class TrieNode&#123;</span><br><span class="line">        private boolean isEnd;</span><br><span class="line">        private TrieNode[] next;</span><br><span class="line">        public TrieNode()</span><br><span class="line">        &#123;</span><br><span class="line">           this.isEnd&#x3D;false;</span><br><span class="line">           this.next&#x3D;new TrieNode[26]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#x2F;** Inserts a word into the trie. *&#x2F;</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">     TrieNode cur&#x3D;root;</span><br><span class="line">     for(int i&#x3D;0;i&lt;word.length();i++)</span><br><span class="line">     &#123;</span><br><span class="line">         int c&#x3D;word.charAt(i)-&#39;a&#39;;</span><br><span class="line">         if(cur.next[c]&#x3D;&#x3D;null)</span><br><span class="line">         &#123;</span><br><span class="line">             cur.next[c]&#x3D;new TrieNode();</span><br><span class="line">         &#125;</span><br><span class="line">         cur&#x3D;cur.next[c];</span><br><span class="line">     &#125;</span><br><span class="line">     cur.isEnd&#x3D;true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns if the word is in the trie. *&#x2F;</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        TrieNode cur &#x3D; root;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">			int ch &#x3D;  word.charAt(i) - &#39;a&#39;;</span><br><span class="line">			if (cur.next[ch] &#x3D;&#x3D; null)</span><br><span class="line">				return false;</span><br><span class="line">			cur &#x3D; cur.next[ch];</span><br><span class="line">		&#125;</span><br><span class="line">		return cur.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns if there is any word in the trie that starts with the given prefix. *&#x2F;</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        TrieNode cur &#x3D; root;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">			int ch &#x3D; prefix.charAt(i) - &#39;a&#39;;</span><br><span class="line">			if (cur.next[ch] &#x3D;&#x3D; null)</span><br><span class="line">				return false;</span><br><span class="line">			cur &#x3D; cur.next[ch];</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="498. 对角线遍历"></a>498. 对角线遍历</h4><p>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</p>
<p> <img src="/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210307115017107.png" alt="image-20210307115017107"></p>
<p>定义r和c，初始为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if ((r + c) % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            if (c &#x3D;&#x3D; col - 1) &#123;</span><br><span class="line">                &#x2F;&#x2F; 往下移动一格准备向下遍历</span><br><span class="line">                r++;</span><br><span class="line">            &#125; else if (r &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 往右移动一格准备向下遍历</span><br><span class="line">                c++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 往上移动</span><br><span class="line">                r--;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h4><p>给你一个长度为 <em>n</em> 的整数数组 <code>nums</code>，其中 <em>n</em> &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<p>双指针，两次遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;nums.length-1;i&gt;&#x3D;0;i--)</span><br><span class="line">   &#123;</span><br><span class="line">       output[i]*&#x3D;right;</span><br><span class="line">       right*&#x3D;nums[i];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h4><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;nums.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i&gt;right) return false;</span><br><span class="line">        right&#x3D;Math.max(right,nums[i]+i);</span><br><span class="line">        if(right&gt;&#x3D;nums.length-1)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>

<h4 id="80-删除排序数组中的重复项-II"><a href="#80-删除排序数组中的重复项-II" class="headerlink" title="80. 删除排序数组中的重复项 II"></a>80. 删除排序数组中的重复项 II</h4><p>难度中等373</p>
<p>给定一个增序排列数组 <code>nums</code> ，你需要在 <strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a></strong>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a> 修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<ul>
<li><code>len</code>表示的是删除重复元素后新序列的长度，同时也表示新元素进入新序列的索引；</li>
<li><code>i</code>就是循环变量，用于遍历整个旧序列；</li>
<li><code>if (len &lt; 2) nums[len++] = nums[i];</code>的意思就是如果新序列的长度小于2（即新序列中不会存在两个相同的元素，这时候<code>i</code>位置所在元素不会和新序列中的元素相同），直接将新元素加入到新序列中，并更新新序列的长度；</li>
<li><code>if (nums[i] != nums[len-2]) nums[len++] = nums[i];</code>的意思就是如果新元素加入后不会和前两个元素构成3个相同的元素（<code>nums[len-2]</code>就是直接取新序列中倒数第二个元素，如果该元素和新元素相同，说明加入后会构成3个相同的元素，显然是不符合题意的），就将新元素加入到新序列中，并更新新序列的长度；</li>
<li>题意只要求将新序列紧挨在一起就行，多出的长度将不参与评测；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">      int len &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (len &lt; 2 || nums[i] !&#x3D; nums[len-2])</span><br><span class="line">                nums[len++] &#x3D; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h4><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int j &#x3D; 1; j &lt; nums.length; j++) &#123;</span><br><span class="line">        while(j&lt;nums.length &amp;&amp; nums[j]&#x3D;&#x3D;nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;1 1 2 3</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        if(j&lt;nums.length)  nums[++i]&#x3D;nums[j];        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="767-重构字符串"><a href="#767-重构字符串" class="headerlink" title="767. 重构字符串"></a>767. 重构字符串</h4><p>给定一个字符串<code>S</code>，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p>
<p>若可行，输出任意可行的结果。若不可行，返回空字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: S &#x3D; &quot;aab&quot;</span><br><span class="line">输出: &quot;aba&quot;</span><br></pre></td></tr></table></figure>

<p>构造优先队列PriorityQueue<Character> pq=new PriorityQueue&lt;&gt;((a,b)-&gt;cnt[b-‘a’]-cnt[a-‘a’]);</Character></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(cnt[i]!&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">	pq.add((char)(i+&#39;a&#39;));</span><br><span class="line">&#125;</span><br><span class="line"> while(pq.size()&gt;&#x3D;2)</span><br></pre></td></tr></table></figure>

<h4 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a>523. 连续的子数组和</h4><p>给定一个包含 <strong>非负数</strong> 的数组和一个目标 <strong>整数</strong> k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 <strong>k</strong> 的倍数，即总和为 n<em>k，其中 n 也是一个*</em>整数**。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[23,2,4,6,7], k &#x3D; 6</span><br><span class="line">输出：True</span><br><span class="line">解释：[2,4] 是一个大小为 2 的子数组，并且和为 6。</span><br></pre></td></tr></table></figure>

<p>map.put(0,-1)是为了避免数组前几位mod为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map.put(0, -1);</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">for(int i &#x3D; 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">    sum +&#x3D; nums[i];</span><br><span class="line">    int mod &#x3D; sum % k;</span><br><span class="line">    System.out.println(sum+&quot; &quot;+mod+&quot; &quot;);</span><br><span class="line">    if(map.containsKey(mod)) &#123;</span><br><span class="line">        if(i-map.get(mod) &gt; 1)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#x2F;&#x2F; 不存在再更新</span><br><span class="line">        map.put(mod, i); &#x2F;&#x2F; 0 0</span><br></pre></td></tr></table></figure>

<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h4><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;dp[n]&#x3D;dp[0]*dp[n-1-0]+dp[1]*dp[n-1-1]</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;&#x3D;i-1;j++)</span><br><span class="line">        dp[i]+&#x3D;dp[j]*dp[i-1-j];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a>376. 摆动序列</h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为<strong>摆动序列。</strong>第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反, <code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int wiggleMaxLength(int[] nums) &#123;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int up &#x3D; 1;</span><br><span class="line">        int down &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; nums[i - 1]) &#123;</span><br><span class="line">                up &#x3D; down + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] &lt; nums[i - 1]) &#123;</span><br><span class="line">                down &#x3D; up + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1498-满足条件的子序列数目"><a href="#1498-满足条件的子序列数目" class="headerlink" title="1498. 满足条件的子序列数目"></a>1498. 满足条件的子序列数目</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>请你统计并返回 <code>nums</code> 中能满足其最小元素与最大元素的 <strong>和</strong> 小于或等于 <code>target</code> 的 <strong>非空</strong> 子序列的数目。</p>
<p>由于答案可能很大，请将结果对 10^9 + 7 取余后返回。</p>
<p>排序+双指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">           pow[i]&#x3D;pow[i-1]*2%mod;</span><br><span class="line">       &#125;</span><br><span class="line">       int left&#x3D;0,right&#x3D;n-1;</span><br><span class="line">       while(left&lt;&#x3D;right)&#123;</span><br><span class="line">           if(nums[left]+nums[right]&lt;&#x3D;target)&#123;</span><br><span class="line">               res+&#x3D;pow[right-left];</span><br><span class="line">               res%&#x3D;mod;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">               right--;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="863-二叉树中所有距离为-K-的结点"><a href="#863-二叉树中所有距离为-K-的结点" class="headerlink" title="863. 二叉树中所有距离为 K 的结点"></a>863. 二叉树中所有距离为 K 的结点</h4><p>给定一个二叉树（具有根结点 <code>root</code>）， 一个目标结点 <code>target</code> ，和一个整数值 <code>K</code> 。</p>
<p>返回到目标结点 <code>target</code> 距离为 <code>K</code> 的所有结点的值的列表。 答案可以以任何顺序返回。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], target &#x3D; 5, K &#x3D; 2</span><br><span class="line">输出：[7,4,1]</span><br><span class="line">解释：</span><br><span class="line">所求结点为与目标结点（值为 5）距离为 2 的结点，</span><br><span class="line">值分别为 7，4，以及 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意，输入的 &quot;root&quot; 和 &quot;target&quot; 实际上是树上的结点。</span><br><span class="line">上面的输入仅仅是对这些对象进行了序列化描述。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph &#x3D; new ArrayList[1000];</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 1000; i++)&#123;</span><br><span class="line">            graph[i] &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        buildGraph(graph, root);</span><br><span class="line">        Queue&lt;Integer[]&gt; queue &#x3D; new LinkedList&lt;Integer[]&gt;();</span><br><span class="line">        boolean[] vis &#x3D; new boolean[1000];</span><br><span class="line">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">        queue.add(new Integer[]&#123;target.val,0&#125;);</span><br><span class="line">        vis[target.val] &#x3D; true;</span><br><span class="line">        while(queue.peek() !&#x3D; null)&#123;</span><br><span class="line">            Integer[] arr &#x3D; queue.poll();</span><br><span class="line">            if(arr[1] &#x3D;&#x3D; K)&#123;</span><br><span class="line">                res.add(arr[0]);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int child : graph[arr[0]])&#123;</span><br><span class="line">                if(!vis[child])&#123;</span><br><span class="line">                    queue.add(new Integer[]&#123;child, arr[1] + 1&#125;);</span><br><span class="line">                    vis[child] &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void buildGraph(List&lt;Integer&gt;[] graph, TreeNode node)&#123;</span><br><span class="line">        if(node &#x3D;&#x3D; null) return;</span><br><span class="line">        if(node.left !&#x3D; null)&#123;</span><br><span class="line">            graph[node.val].add(node.left.val);</span><br><span class="line">            graph[node.left.val].add(node.val);</span><br><span class="line">            buildGraph(graph, node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.right !&#x3D; null)&#123;</span><br><span class="line">            graph[node.val].add(node.right.val);</span><br><span class="line">            graph[node.right.val].add(node.val);</span><br><span class="line">            buildGraph(graph, node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="45-跳跃游戏-II-1"><a href="#45-跳跃游戏-II-1" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>

<p>我来大概解释一下吧，献丑了，鉴于题目已经给了前提，那就是肯定能到达最后一个元素，那么只要考虑每一跳所能达到的最远位置就行了，也就是每次都选择最远可达的点，reach是当前需要进行跳跃的右界限，nextReach是下一次跳跃的右界限，nextReach的值一直动态更新，以保证每次跳跃都是最远的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int jump(int[] nums) &#123;</span><br><span class="line">        if(nums.length &#x3D;&#x3D; 1) return 0;</span><br><span class="line">        int reach &#x3D; 0;</span><br><span class="line">        int nextreach &#x3D; nums[0];</span><br><span class="line">        int step &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nextreach &#x3D; Math.max(i+nums[i],nextreach);</span><br><span class="line">            if(nextreach &gt;&#x3D; nums.length-1) return (step+1);</span><br><span class="line">            if(i &#x3D;&#x3D; reach)&#123;</span><br><span class="line">                step++;</span><br><span class="line">                reach &#x3D; nextreach;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h4><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while(l&lt;&#x3D;r)</span><br><span class="line">   &#123;</span><br><span class="line">       if(nums[l]*nums[l]&lt;nums[r]*nums[r])</span><br><span class="line">       &#123;</span><br><span class="line">          arr[idx--]&#x3D;nums[r]*nums[r];</span><br><span class="line">          r--;</span><br><span class="line">       &#125;</span><br><span class="line">       else&#123;</span><br><span class="line">           arr[idx--]&#x3D;nums[l]*nums[l];</span><br><span class="line">           l++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a>680. 验证回文字符串 Ⅱ</h4><p>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s.charAt(i)!&#x3D;s.charAt(j))</span><br><span class="line">        &#123;</span><br><span class="line">            return isValid(s,i+1,j) || isValid(s,i,j-1);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h4><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;strs[0].length();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        char c&#x3D;strs[0].charAt(i);</span><br><span class="line">        for(int j&#x3D;1;j&lt;strs.length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">          if(i&#x3D;&#x3D;strs[j].length() || c!&#x3D;strs[j].charAt(i))</span><br><span class="line">          &#123;</span><br><span class="line">            return strs[0].substring(0,i);</span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h4><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;nums.length;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         if(nums[i]!&#x3D;0)</span><br><span class="line">         &#123;</span><br><span class="line">             nums[index++]&#x3D;nums[i];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h4><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<p>开一个new int[26]的数组 ，接下来一个+，一个-</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D; 0; i&lt; s.length(); i++) &#123;</span><br><span class="line">            alpha[s.charAt(i) - &#39;a&#39;] ++;</span><br><span class="line">            alpha[t.charAt(i) - &#39;a&#39;] --;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a>572. 另一个树的子树</h4><p>给定两个非空二叉树 <strong>s</strong> 和 <strong>t</strong>，检验 <strong>s</strong> 中是否包含和 <strong>t</strong> 具有相同结构和节点值的子树。<strong>s</strong> 的一个子树包括 <strong>s</strong> 的一个节点和这个节点的所有子孙。<strong>s</strong> 也可以看做它自身的一棵子树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSame(TreeNode s,TreeNode t)</span><br><span class="line">   &#123;</span><br><span class="line">    if(s&#x3D;&#x3D;null &amp;&amp; t&#x3D;&#x3D;null) return true;</span><br><span class="line">    if(s&#x3D;&#x3D;null || t&#x3D;&#x3D;null) return false;</span><br><span class="line">    if(s.val&#x3D;&#x3D;t.val)</span><br><span class="line">    &#123;</span><br><span class="line">       return isSame(s.left,t.left) &amp;&amp; isSame(s.right,t.right); </span><br><span class="line">    &#125;</span><br><span class="line">    return false;   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="26-删除排序数组中的重复项-1"><a href="#26-删除排序数组中的重复项-1" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h4><p>给定一个排序数组，你需要在<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地</a></strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int j &#x3D; 1; j &lt; nums.length; j++) &#123;</span><br><span class="line">        while(j&lt;nums.length &amp;&amp; nums[j]&#x3D;&#x3D;nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;1 1 2 3</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        if(j&lt;nums.length)  nums[++i]&#x3D;nums[j];        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a>190. 颠倒二进制位</h4><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;32;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int bit&#x3D;n&amp;1;</span><br><span class="line">        n&#x3D;n&gt;&gt;&gt;1;</span><br><span class="line">        res&#x3D;(res&lt;&lt;1)^bit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a>459. 重复的子字符串</h4><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return (s+s).substring(1,s.length()*2-1).indexOf(s)!&#x3D;-1;</span><br></pre></td></tr></table></figure>

<h4 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h4><p>给你一个 32 位的有符号整数 <code>x</code> ，返回 <code>x</code> 中每位上的数字反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p>
<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while(x!&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        int pop&#x3D;x%10;</span><br><span class="line">        if(res&gt;Integer.MAX_VALUE&#x2F;10 || (res&#x3D;&#x3D;Integer.MAX_VALUE&#x2F;10 &amp;&amp; pop&gt;7))</span><br><span class="line">        return 0;</span><br><span class="line">        if(res&lt;Integer.MIN_VALUE&#x2F;10 || (res&#x3D;&#x3D;Integer.MIN_VALUE&#x2F;10 &amp;&amp; pop&lt;-8))</span><br><span class="line">        return 0;</span><br><span class="line">        res&#x3D;res*10+pop;</span><br><span class="line">        x&#x2F;&#x3D;10;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h4><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;2;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         if(!isPrime[i])</span><br><span class="line">         &#123;</span><br><span class="line">          count++;</span><br><span class="line">          for(int j&#x3D;2*i;j&lt;n;j+&#x3D;i)</span><br><span class="line">          &#123;</span><br><span class="line">              isPrime[j]&#x3D;true;</span><br><span class="line">          &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h4><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p>「快乐数」定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果 <strong>可以变为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是快乐数就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean isHappy(int n) &#123;</span><br><span class="line">      int sum, count &#x3D; 0;</span><br><span class="line">        while (n !&#x3D; 1 &amp;&amp; count &lt; 500)</span><br><span class="line">        &#123;</span><br><span class="line">            sum &#x3D; 0;</span><br><span class="line">            while (n!&#x3D;0)</span><br><span class="line">            &#123;</span><br><span class="line">                sum +&#x3D; (n % 10) * (n % 10);</span><br><span class="line">                n &#x2F;&#x3D; 10;</span><br><span class="line">            &#125;</span><br><span class="line">            n &#x3D; sum;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return n &#x3D;&#x3D; 1;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h4><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void helper(TreeNode root,int count)</span><br><span class="line">     &#123;</span><br><span class="line">         if(root&#x3D;&#x3D;null) return;</span><br><span class="line">         if(root.left&#x3D;&#x3D;null &amp;&amp; root.right&#x3D;&#x3D;null)</span><br><span class="line">         &#123;</span><br><span class="line">             res&#x3D;Math.min(res,count);</span><br><span class="line">         &#125;</span><br><span class="line">         helper(root.left,count+1);</span><br><span class="line">         helper(root.right,count+1);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h4 id="922-按奇偶排序数组-II"><a href="#922-按奇偶排序数组-II" class="headerlink" title="922. 按奇偶排序数组 II"></a>922. 按奇偶排序数组 II</h4><p>给定一个非负整数数组 <code>A</code>， A 中一半整数是奇数，一半整数是偶数。</p>
<p>对数组进行排序，以便当 <code>A[i]</code> 为奇数时，<code>i</code> 也是奇数；当 <code>A[i]</code> 为偶数时， <code>i</code> 也是偶数。</p>
<p>你可以返回任何满足上述条件的数组作为答案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortArrayByParityII(int[] A) &#123;</span><br><span class="line">        int j &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; A.length - 1; i &#x3D; i + 2) &#123;</span><br><span class="line">            if ((A[i] &amp; 1) !&#x3D; 0) &#123;</span><br><span class="line">                while ((A[j] &amp; 1) !&#x3D; 0) &#123;</span><br><span class="line">                    j &#x3D; j + 2;</span><br><span class="line">                &#125;</span><br><span class="line">                int tmp &#x3D; A[i];</span><br><span class="line">                A[i] &#x3D; A[j];</span><br><span class="line">                A[j] &#x3D; tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while(x&gt;0)</span><br><span class="line">     &#123;</span><br><span class="line">         int left&#x3D;x&#x2F;div;</span><br><span class="line">         int right&#x3D;x%10;</span><br><span class="line">         if(left!&#x3D;right)</span><br><span class="line">         &#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">         x&#x3D; (x%div)&#x2F;10;</span><br><span class="line">         div&#x2F;&#x3D;100;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1299-将每个元素替换为右侧最大元素"><a href="#1299-将每个元素替换为右侧最大元素" class="headerlink" title="1299. 将每个元素替换为右侧最大元素"></a>1299. 将每个元素替换为右侧最大元素</h4><p>给你一个数组 <code>arr</code> ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 <code>-1</code> 替换。</p>
<p>完成所有替换操作后，请你返回这个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; arr.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">           int temp &#x3D; arr[i];</span><br><span class="line">           arr[i] &#x3D; max;</span><br><span class="line">           if (temp &gt; max) &#123;</span><br><span class="line">               max &#x3D; temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h4><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[0][0]&#x3D;0;           &#x2F;&#x2F; 不持有</span><br><span class="line">     dp[0][1]&#x3D;-prices[0]; &#x2F;&#x2F; 持有   </span><br><span class="line">     for(int i&#x3D;1;i&lt;prices.length;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         dp[i][0]&#x3D;Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);</span><br><span class="line">         dp[i][1]&#x3D;Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h4 id="405-数字转换为十六进制数"><a href="#405-数字转换为十六进制数" class="headerlink" title="405. 数字转换为十六进制数"></a>405. 数字转换为十六进制数</h4><p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 <a href="https://baike.baidu.com/item/补码/6854613?fr=aladdin" target="_blank" rel="noopener">补码运算</a> 方法。</p>
<p><strong>注意:</strong></p>
<ol>
<li>十六进制中所有字母(<code>a-f</code>)都必须是小写。</li>
<li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符<code>&#39;0&#39;</code>来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 </li>
<li>给定的数确保在32位有符号整数范围内。</li>
<li><strong>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</strong></li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;1a&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char[] hex&#x3D;&quot;0123456789abcdef&quot;.toCharArray();</span><br><span class="line">     StringBuilder sb&#x3D;new StringBuilder();</span><br><span class="line">     while(num!&#x3D;0)</span><br><span class="line">     &#123;</span><br><span class="line">         int temp&#x3D;num &amp; 0xf;</span><br><span class="line">         sb.append(hex[temp]);</span><br><span class="line">         num&gt;&gt;&gt;&#x3D;4;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h4 id="836-矩形重叠"><a href="#836-矩形重叠" class="headerlink" title="836. 矩形重叠"></a>836. 矩形重叠</h4><p>矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。</p>
<p>如果相交的面积为 <strong>正</strong> ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p>
<p>给出两个矩形 <code>rec1</code> 和 <code>rec2</code> 。如果它们重叠，返回 <code>true</code>；否则，返回 <code>false</code> 。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 &#x3D; [0,0,2,2], rec2 &#x3D; [1,1,3,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(rec2[1] &gt;&#x3D; rec1[3] || rec1[1] &gt;&#x3D; rec2[3])&#123;</span><br><span class="line">        return false;</span><br><span class="line">        &#125;</span><br><span class="line">System.out.println(&quot;hello&quot;);</span><br><span class="line">if(rec1[0] &gt;&#x3D; rec2[2] || rec1[2] &lt;&#x3D; rec2[0])&#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"> return true;</span><br></pre></td></tr></table></figure>



<h3 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h3><h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h4><p>难度简单80收藏分享切换为英文接收动态反馈</p>
<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while (P1 &gt;&#x3D; 0 &amp;&amp; P2 &gt; P1) &#123;</span><br><span class="line">        char c &#x3D; str.charAt(P1--);</span><br><span class="line">        if (c &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">            str.setCharAt(P2--, &#39;0&#39;);</span><br><span class="line">            str.setCharAt(P2--, &#39;2&#39;);</span><br><span class="line">            str.setCharAt(P2--, &#39;%&#39;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            str.setCharAt(P2--, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12. 矩阵中的路径"></a>12. 矩阵中的路径</h4><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”<strong>b</strong>“,”c”,”e”],<br>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],<br>[“a”,”d”,”<strong>e</strong>“,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vis[i][j]&#x3D;1;</span><br><span class="line">      </span><br><span class="line">      boolean ans&#x3D; false;</span><br><span class="line">      ans&#x3D;</span><br><span class="line">      dfs(i+1,j,board,word,index+1) || </span><br><span class="line">      dfs(i-1,j,board,word,index+1) ||</span><br><span class="line">      dfs(i,j+1,board,word,index+1) || </span><br><span class="line">      dfs(i,j-1,board,word,index+1);</span><br><span class="line">      </span><br><span class="line">      vis[i][j]&#x3D;0;</span><br></pre></td></tr></table></figure>

<h4 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13. 机器人的运动范围"></a>13. 机器人的运动范围</h4><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int dfs(int m,int n,int k,int x,int y)</span><br><span class="line">    &#123;</span><br><span class="line">      if(!check(m,n,k,x,y) || vis[x][y]&#x3D;&#x3D;1)</span><br><span class="line">      &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      vis[x][y]&#x3D;1;</span><br><span class="line">      return 1+dfs(m,n,k,x+1,y)+dfs(m,n,k,x-1,y)+dfs(m,n,k,x,y+1)+dfs(m,n,k,x,y-1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15. 二进制中1的个数"></a>15. 二进制中1的个数</h4><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(n!&#x3D;0)</span><br><span class="line">   &#123;</span><br><span class="line">       if((n &amp; 1)&#x3D;&#x3D;1) cnt++;</span><br><span class="line">       n&#x3D;n&gt;&gt;&gt;1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;nums.length;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         if(nums[i]%2&#x3D;&#x3D;1)</span><br><span class="line">         &#123;</span><br><span class="line">             swap(nums,i,p);</span><br><span class="line">             p++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a>24. 反转链表</h4><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(head!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            next&#x3D;head.next;</span><br><span class="line">            head.next&#x3D;pre;</span><br><span class="line">            pre&#x3D;head;</span><br><span class="line">            head&#x3D;next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a>26. 树的子结构</h4><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p><img src="/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210308095816745.png" alt="image-20210308095816745"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean dfs(TreeNode t1,TreeNode t2)</span><br><span class="line">    &#123;</span><br><span class="line">      if(t2&#x3D;&#x3D;null) return true;</span><br><span class="line">      if(t1&#x3D;&#x3D;null) return false;</span><br><span class="line">      if(t1.val!&#x3D;t2.val) return false;</span><br><span class="line">      return dfs(t1.left,t2.left) &amp;&amp; dfs(t1.right,t2.right); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28. 对称的二叉树"></a>28. 对称的二叉树</h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p><img src="/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210308100250659.png" alt="image-20210308100250659"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TreeNode t1&#x3D;q.poll();</span><br><span class="line">        TreeNode t2&#x3D;q.poll();</span><br><span class="line">        if(t1&#x3D;&#x3D;null &amp;&amp; t2&#x3D;&#x3D;null) continue;</span><br><span class="line">        if(t1&#x3D;&#x3D;null || t2&#x3D;&#x3D;null || t1.val!&#x3D;t2.val) return false;</span><br><span class="line">        q.add(t1.left);</span><br><span class="line">        q.add(t2.right);</span><br><span class="line">        q.add(t1.right);</span><br><span class="line">        q.add(t2.left);</span><br></pre></td></tr></table></figure>





<h4 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31.栈的压入、弹出序列"></a>31.栈的压入、弹出序列</h4><p>示例 1：</p>
<p>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;pushed.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      stack.push(pushed[i]);</span><br><span class="line">      while(!stack.isEmpty() &amp;&amp; stack.peek()&#x3D;&#x3D;popped[idx])</span><br><span class="line">      &#123;</span><br><span class="line">          stack.pop();</span><br><span class="line">          idx++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30. 包含min函数的栈"></a>30. 包含min函数的栈</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void push(int x) &#123;</span><br><span class="line">    if(x&lt;&#x3D;min)</span><br><span class="line">    &#123;</span><br><span class="line">        stack.push(min);</span><br><span class="line">        min&#x3D;x;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pop() &#123;</span><br><span class="line">    if(stack.pop()&#x3D;&#x3D;min)</span><br><span class="line">    &#123;</span><br><span class="line">        min&#x3D;stack.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03. 数组中重复的数字"></a>03. 数组中重复的数字</h4><p>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;nums.length;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         while(nums[i]!&#x3D;i)</span><br><span class="line">         &#123;</span><br><span class="line">             if(nums[i]&#x3D;&#x3D;nums[nums[i]])</span><br><span class="line">             &#123;</span><br><span class="line">                 return nums[i];</span><br><span class="line">             &#125;</span><br><span class="line">             int tmp&#x3D;nums[i];</span><br><span class="line">             nums[i]&#x3D;nums[tmp];</span><br><span class="line">             nums[tmp]&#x3D;tmp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h4 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h4><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] dp&#x3D;new int[n+1];</span><br><span class="line">    dp[1]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]&#x3D;Math.max(dp[i],Math.max(dp[j],j)*(i-j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(n&gt;&#x3D;5)</span><br><span class="line">     &#123;</span><br><span class="line">        n-&#x3D;3;</span><br><span class="line">        cnt*&#x3D;3;</span><br><span class="line">        cnt%&#x3D;1000000007;</span><br><span class="line">     &#125;</span><br><span class="line">     return (int)(cnt*n%1000000007);</span><br></pre></td></tr></table></figure>

<h4 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33. 二叉搜索树的后序遍历序列"></a>33. 二叉搜索树的后序遍历序列</h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int rootValue&#x3D;num[right];</span><br><span class="line">int k&#x3D;left;</span><br><span class="line">while(k&lt;right &amp;&amp; num[k]&lt;rootValue)</span><br><span class="line">&#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i&#x3D;k;i&lt;right;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(num[i]&lt;rootValue) return false;</span><br><span class="line">&#125;</span><br><span class="line">return helper(num,left,k-1) &amp;&amp; helper(num,k,right-1);</span><br></pre></td></tr></table></figure>

<h4 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46. 把数字翻译成字符串"></a>46. 把数字翻译成字符串</h4><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(str.charAt(i-2) !&#x3D; &#39;0&#39; &amp;&amp;</span><br><span class="line">    str.substring(i-2,i).compareTo(&quot;25&quot;) &lt;&#x3D; 0)            &#123;</span><br><span class="line">    dp[i] &#x3D; dp[i-1] + dp[i-2];  </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    &#x2F;&#x2F;如果不能组成,就单独为1个数字,和前面方法数相等</span><br><span class="line">    dp[i] &#x3D; dp[i-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37. 序列化二叉树"></a>37. 序列化二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public String serialize(TreeNode root) &#123;</span><br><span class="line">     if(root&#x3D;&#x3D;null) return &quot;&quot;;</span><br><span class="line">     StringBuilder sb&#x3D;new StringBuilder();</span><br><span class="line">     LinkedList&lt;TreeNode&gt; q&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">     q.add(root);</span><br><span class="line">     while(!q.isEmpty())</span><br><span class="line">     &#123;</span><br><span class="line">         TreeNode tmp&#x3D;q.poll();</span><br><span class="line">         if(tmp&#x3D;&#x3D;null)</span><br><span class="line">         &#123;</span><br><span class="line">             sb.append(&quot;n &quot;);</span><br><span class="line">             continue;</span><br><span class="line">         &#125;</span><br><span class="line">         sb.append(tmp.val+&quot; &quot;);</span><br><span class="line">         q.add(tmp.left);</span><br><span class="line">         q.add(tmp.right);        </span><br><span class="line">     &#125;</span><br><span class="line">     return sb.toString(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Decodes your encoded data to tree.</span><br><span class="line">    public TreeNode deserialize(String data) &#123;</span><br><span class="line">    if(data&#x3D;&#x3D;&quot;&quot;) return null;</span><br><span class="line">    String[] values&#x3D;data.split(&quot; &quot;);</span><br><span class="line">    TreeNode root&#x3D;new TreeNode(Integer.parseInt(values[0]));</span><br><span class="line">    LinkedList&lt;TreeNode&gt; q&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    for(int i&#x3D;1;i&lt;values.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       TreeNode node&#x3D;q.poll();</span><br><span class="line">       if(!values[i].equals(&quot;n&quot;))</span><br><span class="line">       &#123;</span><br><span class="line">          TreeNode left&#x3D;new TreeNode(Integer.parseInt(values[i]));          node.left&#x3D;left;</span><br><span class="line">          q.add(left);  </span><br><span class="line">       &#125;</span><br><span class="line">       if(!values[++i].equals(&quot;n&quot;))</span><br><span class="line">       &#123;</span><br><span class="line">          TreeNode right&#x3D;new TreeNode(Integer.parseInt(values[i]));          node.right&#x3D;right;</span><br><span class="line">          q.add(right);  </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41. 数据流中的中位数"></a>41. 数据流中的中位数</h4><p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构</p>
<p>用大顶堆+小顶堆方法，可以看作大顶堆是普通班，小顶堆是实验班。数量上时刻保持 小顶-大顶&lt;=1（两堆相等或者小顶比大顶多一个）。</p>
<p>新学生先入普通班（大顶堆），此时可能会失去平衡了，于是取大顶堆的第一个（班里最好的学生）加入实验班（小顶堆），判断若数量过多（不是等于或多一个），取第一个（实验班里最差的学生）到普通班（大顶堆）里。 取中位数的时候，若两堆数量相等，则各取堆顶取平均，若小顶比大顶多一，则多的那一个就是中位数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MedianFinder &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; left;&#x2F;&#x2F;大顶</span><br><span class="line">    PriorityQueue&lt;Integer&gt; right;&#x2F;&#x2F;小顶</span><br><span class="line">    public MedianFinder() &#123;</span><br><span class="line">        left&#x3D;new PriorityQueue&lt;&gt;((n1,n2)-&gt;n2-n1);</span><br><span class="line">        right&#x3D;new PriorityQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    public void addNum(int num) &#123;</span><br><span class="line">        left.add(num);</span><br><span class="line">        right.add(left.poll());</span><br><span class="line">        if(left.size()+1&lt;right.size())</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    public double findMedian() &#123;</span><br><span class="line">        if(right.size()&gt;left.size())return right.peek();</span><br><span class="line">        return (double)(left.peek()+right.peek())&#x2F;2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a>51. 数组中的逆序对</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void merge(int[] nums,int l,int r)</span><br><span class="line"> public void merge(int[] nums,int l,int mid,int r)</span><br><span class="line"> if(nums[i]&gt;nums[j])</span><br><span class="line"> &#123;</span><br><span class="line"> sum+&#x3D;mid-i+1;</span><br><span class="line"> temp[idx++]&#x3D;nums[j++];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="53-II-0～n-1中缺失的数字"><a href="#53-II-0～n-1中缺失的数字" class="headerlink" title="53 - II. 0～n-1中缺失的数字"></a>53 - II. 0～n-1中缺失的数字</h4><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(nums[mid]&gt;mid)</span><br><span class="line">       &#123;</span><br><span class="line">           right&#x3D;mid;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       return left &#x3D;&#x3D; nums.length - 1 &amp;&amp; nums[left] &#x3D;&#x3D; left ? left + 1 : left;</span><br></pre></td></tr></table></figure>

<h4 id="68-I-二叉搜索树的最近公共祖先"><a href="#68-I-二叉搜索树的最近公共祖先" class="headerlink" title="68 - I. 二叉搜索树的最近公共祖先"></a>68 - I. 二叉搜索树的最近公共祖先</h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">            return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">            return lowestCommonAncestor(root.right, p, q);</span><br></pre></td></tr></table></figure>

<h4 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61. 扑克牌中的顺子"></a>61. 扑克牌中的顺子</h4><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; repeat &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">if(num &#x3D;&#x3D; 0) continue; &#x2F;&#x2F; 跳过大小王</span><br><span class="line">max &#x3D; Math.max(max, num); &#x2F;&#x2F; 最大牌</span><br><span class="line">min &#x3D; Math.min(min, num); &#x2F;&#x2F; 最小牌</span><br><span class="line">if(repeat.contains(num)) return false; &#x2F;&#x2F; 若有重复，提前返回 false</span><br><span class="line">repeat.add(num); &#x2F;&#x2F; 添加此牌至 Set</span><br></pre></td></tr></table></figure>

<h4 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h4><p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中<em>，</em>使 <code>nums1</code> 成为一个有序数组。</p>
<p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code> 。你可以假设 <code>nums1</code> 的空间大小等于 <code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        int i&#x3D;m-1,j&#x3D;n-1,p&#x3D;m+n-1;&#x2F;&#x2F;从后往前，最大的放在num1的最后面</span><br><span class="line">        while(i&gt;&#x3D;0&amp;&amp;j&gt;&#x3D;0)&#123;</span><br><span class="line">            if(nums1[i]&gt;nums2[j]) nums1[p--]&#x3D;nums1[i--];</span><br><span class="line">            else nums1[p--]&#x3D;nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        while(j&gt;&#x3D;0) nums1[p--]&#x3D;nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a>69. x 的平方根</h4><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int mid&#x3D;left+(right-left+1)&#x2F;2;</span><br><span class="line">     if(mid&gt;x&#x2F;mid)</span><br><span class="line">     &#123;</span><br><span class="line">         right&#x3D;mid-1;</span><br><span class="line">     &#125;</span><br><span class="line">     else&#123;</span><br><span class="line">         left&#x3D;mid;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h4 id="56-II-数组中数字出现的次数-II"><a href="#56-II-数组中数字出现的次数-II" class="headerlink" title="56 - II. 数组中数字出现的次数 II"></a>56 - II. 数组中数字出现的次数 II</h4><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;32;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        for(int j&#x3D;0;j&lt;nums.length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">         if(((nums[j]&gt;&gt;&gt;i)&amp;1)&#x3D;&#x3D;1)</span><br><span class="line">         &#123;</span><br><span class="line">             count++;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count%3!&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            ans&#x3D;ans|(1&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="53-II-0～n-1中缺失的数字-1"><a href="#53-II-0～n-1中缺失的数字-1" class="headerlink" title="53 - II. 0～n-1中缺失的数字"></a>53 - II. 0～n-1中缺失的数字</h4><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 0 2 3</span><br><span class="line">        &#x2F;&#x2F; 0 1 3</span><br><span class="line">        int mid&#x3D;left+(right-left)&#x2F;2;</span><br><span class="line">        if(nums[mid]&gt;mid)</span><br><span class="line">        &#123;</span><br><span class="line">            right&#x3D;mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            left&#x3D;mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="57-II-和为s的连续正数序列"><a href="#57-II-和为s的连续正数序列" class="headerlink" title="57 - II. 和为s的连续正数序列"></a>57 - II. 和为s的连续正数序列</h4><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure>

<h4 id="59-II-队列的最大值"><a href="#59-II-队列的最大值" class="headerlink" title="59 - II. 队列的最大值"></a>59 - II. 队列的最大值</h4><p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void push_back(int value) &#123;</span><br><span class="line">       queue.add(value);</span><br><span class="line">       while(max.size()!&#x3D;0&amp;&amp;max.getLast()&lt;value)&#123;&#x2F;&#x2F;注意：这里第二个判断条件不能带等号，即max中对于当前queue中的具有相同值的元素会全部存储，而不是存储最近的那个。</span><br><span class="line">           max.removeLast();</span><br><span class="line">       &#125;</span><br><span class="line">       max.add(value);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public int pop_front() &#123;</span><br><span class="line">       if(max.size()!&#x3D;0&amp;&amp;queue.peek().equals(max.getFirst()))&#x2F;&#x2F;Integer类型的值的比较不能直接使用&#x3D;&#x3D;</span><br><span class="line">           max.removeFirst();</span><br><span class="line">       return queue.size()&#x3D;&#x3D;0?-1:queue.poll();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65. 不用加减乘除做加法"></a>65. 不用加减乘除做加法</h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    public int add(int a, int b) &#123;&#x2F;&#x2F; 假如 b是进位  a是非进位和</span><br><span class="line">        if(b&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return a; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int c &#x3D; (a&amp;b)&lt;&lt;1; &#x2F;&#x2F; 进位赋值给c，准备下一次递归使用</span><br><span class="line">        int d &#x3D; a^b; &#x2F;&#x2F; 非进位和赋值给d ，准备下一次递归使用</span><br><span class="line">        return add(d,c);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="64-求1-2-…-n"><a href="#64-求1-2-…-n" class="headerlink" title="64. 求1+2+…+n"></a>64. 求1+2+…+n</h4><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public int sumNums(int n) &#123;</span><br><span class="line">    boolean x&#x3D;n&gt;1 &amp;&amp; sumNums(n-1)&#x3D;&#x3D;0;</span><br><span class="line">    res+&#x3D;n;</span><br><span class="line">    return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="59-I-滑动窗口的最大值"><a href="#59-I-滑动窗口的最大值" class="headerlink" title="59 - I. 滑动窗口的最大值"></a>59 - I. 滑动窗口的最大值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;num.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">       while(!q.isEmpty() &amp;&amp; num[q.peekLast()]&lt;num[i] )</span><br><span class="line">       &#123;</span><br><span class="line">          q.pollLast(); </span><br><span class="line">       &#125;</span><br><span class="line">          q.addLast(i);</span><br><span class="line">          if(i-q.peekFirst()&gt;&#x3D;size)</span><br><span class="line">          &#123;</span><br><span class="line">              q.pollFirst();</span><br><span class="line">          &#125;</span><br><span class="line">          if(i&gt;&#x3D;size-1)</span><br><span class="line">          &#123;</span><br><span class="line">              res.add(num[q.peekFirst()]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62. 圆圈中最后剩下的数字"></a>62. 圆圈中最后剩下的数字</h4><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/javajie-jue-yue-se-fu-huan-wen-ti-gao-su-ni-wei-sh/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/javajie-jue-yue-se-fu-huan-wen-ti-gao-su-ni-wei-sh/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int ans&#x3D;0;</span><br><span class="line">    &#x2F;&#x2F; 0 1 2 3 4</span><br><span class="line">    &#x2F;&#x2F; 0 1 3 4</span><br><span class="line">    &#x2F;&#x2F; 1 4</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans&#x3D;(ans+m)%i;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br></pre></td></tr></table></figure>

<h4 id="57-II-和为s的连续正数序列-1"><a href="#57-II-和为s的连续正数序列-1" class="headerlink" title="57 - II. 和为s的连续正数序列"></a>57 - II. 和为s的连续正数序列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">while(i&lt;&#x3D;target&#x2F;2)</span><br><span class="line">   &#123;</span><br><span class="line">       if(sum&lt;target)</span><br><span class="line">       &#123;</span><br><span class="line">           sum+&#x3D;j;</span><br><span class="line">           j++;</span><br><span class="line">       &#125;</span><br><span class="line">       else if(sum&gt;target)</span><br><span class="line">       &#123;</span><br><span class="line">           sum-&#x3D;i;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       else&#123;</span><br><span class="line">           int[] arr&#x3D;new int[j-i];</span><br><span class="line">           for(int k&#x3D;0;k&lt;arr.length;k++)</span><br><span class="line">           &#123;</span><br><span class="line">               arr[k]&#x3D;i+k;</span><br><span class="line">           &#125;</span><br><span class="line">           res.add(arr);</span><br><span class="line">           sum-&#x3D;i;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17. 打印从1到最大的n位数"></a>17. 打印从1到最大的n位数</h4><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void print1ToMaxOfNDigits(char[] number, int digit) &#123;</span><br><span class="line">        if (digit &#x3D;&#x3D; number.length) &#123;</span><br><span class="line">            printNumber(number);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            number[digit] &#x3D; (char) (i + &#39;0&#39;);</span><br><span class="line">            print1ToMaxOfNDigits(number, digit + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void printNumber(char[] number) &#123;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        while (index &lt; number.length &amp;&amp; number[index] &#x3D;&#x3D; &#39;0&#39;)</span><br><span class="line">            index++;</span><br><span class="line">        int cnt&#x3D;0;</span><br><span class="line">        while (index &lt; number.length)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt&#x3D;cnt*10+number[index]-&#39;0&#39;;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(cnt);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Hot100"><a href="#Hot100" class="headerlink" title="Hot100"></a>Hot100</h3><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int ret&#x3D;target-nums[i];</span><br><span class="line">if(map.containsKey(ret) &amp;&amp; map.get(ret)!&#x3D;i)</span><br><span class="line">&#123;</span><br><span class="line">	return new int[]&#123;res,i&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h4><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(stack.isEmpty())</span><br><span class="line">       &#123;</span><br><span class="line">         stack.push(c);  </span><br><span class="line">       &#125;</span><br><span class="line">       else if(isSym(stack.peek(),c))</span><br><span class="line">       &#123;</span><br><span class="line">          stack.pop(); </span><br><span class="line">       &#125;</span><br><span class="line">       else</span><br><span class="line">       &#123;</span><br><span class="line">          stack.push(c); </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h4><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">while(l&lt;r)</span><br><span class="line">      &#123;</span><br><span class="line">          int mid&#x3D;l+(r-l)&#x2F;2;</span><br><span class="line">          if(nums[mid]&gt;&#x3D;target)</span><br><span class="line">          &#123;</span><br><span class="line">              r&#x3D;mid;</span><br><span class="line">          &#125;</span><br><span class="line">          else&#123;</span><br><span class="line">              l&#x3D;mid+1;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">while(l&lt;r)</span><br><span class="line">      &#123;</span><br><span class="line">      int mid&#x3D;(l+r+1)&#x2F;2;</span><br><span class="line">      if(nums[mid]&gt;target)</span><br><span class="line">      &#123;</span><br><span class="line">      r&#x3D;mid-1;</span><br><span class="line">      &#125;</span><br><span class="line">      else&#123;</span><br><span class="line">       l&#x3D;mid;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(nums[begin]!&#x3D;target || nums[end]!&#x3D;target)</span><br><span class="line">      &#123;</span><br><span class="line">      return new int[]&#123;-1,-1&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      return new int[]&#123;begin,end&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="136-只出现一次的数字38"><a href="#136-只出现一次的数字38" class="headerlink" title="136. 只出现一次的数字38"></a>136. 只出现一次的数字38</h4><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans&#x3D;ans^nums[i];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode left&#x3D;invertTree(root.left);</span><br><span class="line">      TreeNode right&#x3D;invertTree(root.right);</span><br><span class="line">      TreeNode temp&#x3D;root.right;</span><br><span class="line">      root.right&#x3D;root.left;</span><br><span class="line">      root.left&#x3D;temp;</span><br><span class="line">      return root;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while (!queue.isEmpty())&#123;</span><br><span class="line">               TreeNode node &#x3D; queue.poll();</span><br><span class="line">               TreeNode rightTree &#x3D; node.right;</span><br><span class="line">               node.right &#x3D; node.left;</span><br><span class="line">               node.left &#x3D; rightTree;</span><br><span class="line">               if (node.left !&#x3D; null)&#123;</span><br><span class="line">                   queue.offer(node.left);</span><br><span class="line">               &#125;</span><br><span class="line">               if (node.right !&#x3D; null)&#123;</span><br><span class="line">                   queue.offer(node.right);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<h4 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a>494. 目标和</h4><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 <code>+</code> 和 <code>-</code>。对于数组中的任意一个整数，你都可以从 <code>+</code> 或 <code>-</code>中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 目标和不可能大于总和</span><br><span class="line">      if (S &gt; sum) &#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      sum &#x3D; (sum + S) &gt;&gt; 1;</span><br><span class="line">      int len &#x3D; nums.length;</span><br><span class="line">      int[][] dp &#x3D; new int[len + 1][sum + 1];</span><br><span class="line">      dp[0][0] &#x3D; 1;</span><br><span class="line">      </span><br><span class="line">      for (int i &#x3D; 1; i &lt;&#x3D; len; i++) &#123;</span><br><span class="line">          for (int j &#x3D; 0; j &lt;&#x3D; sum; j++) &#123;</span><br><span class="line">              &#x2F;&#x2F; 装不下（不选当前元素）</span><br><span class="line">              if (j - nums[i - 1] &lt; 0) &#123;</span><br><span class="line">                  dp[i][j] &#x3D; dp[i - 1][j];</span><br><span class="line">              &#x2F;&#x2F; 可装可不装（当前元素可选可不选）</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  dp[i][j] &#x3D; dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a>543. 二叉树的直径</h4><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p><strong>示例 :</strong><br>给定二叉树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int depth(TreeNode root)</span><br><span class="line">   &#123;</span><br><span class="line">      if(root&#x3D;&#x3D;null) return 0;</span><br><span class="line">      int left&#x3D;depth(root.left);</span><br><span class="line">      int right&#x3D;depth(root.right);</span><br><span class="line">      if(left+right&gt;max) max&#x3D;left+right;</span><br><span class="line">      return Math.max(left,right)+1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="322-零钱兑换-1"><a href="#322-零钱兑换-1" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h4><p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;&#x3D;coins.length;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       for(int j&#x3D;1;j&lt;amount+1;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           if(j&gt;&#x3D;coins[i-1]) f[i][j]&#x3D;Math.min(f[i-1][j],f[i][j-coins[i-1]]+1);</span><br><span class="line">           else&#123;</span><br><span class="line">               f[i][j]&#x3D;f[i-1][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a>338. 比特位计数</h4><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>

<ul>
<li>方法一：i &amp; (i - 1)可以去掉i最右边的一个1（如果有），因此 i &amp; (i - 1）是比 i 小的，而且i &amp; (i - 1)的1的个数已经在前面算过了，所以i的1的个数就是 i &amp; (i - 1)的1的个数加上1</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span>[] countBits(<span class="built_in">int</span> num) &#123;</span><br><span class="line">    <span class="built_in">int</span>[] res = new <span class="built_in">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i&lt;= num;i++)&#123;  <span class="comment">//注意要从1开始，0不满足</span></span><br><span class="line">        res[i] = res[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h4><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则<strong>不为</strong> NULL 的节点将直接作为新二叉树的节点。</p>
<p><img src="/2021/03/05/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210309125320229.png" alt="image-20210309125320229"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;两棵树的节点同时出队</span><br><span class="line">            TreeNode node1 &#x3D; queue.poll();</span><br><span class="line">            TreeNode node2 &#x3D; queue.poll();</span><br><span class="line">            &#x2F;&#x2F;把这两个节点的值相加，然后合并到第1棵树的节点上</span><br><span class="line">            node1.val +&#x3D; node2.val;</span><br><span class="line">            if (node1.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果node1左子节点为空，我们直接让node2的</span><br><span class="line">                &#x2F;&#x2F;左子结点成为node1的左子结点，</span><br><span class="line">                node1.left &#x3D; node2.left;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;执行到这一步，说明node1的左子节点不为空，</span><br><span class="line">                &#x2F;&#x2F;如果node2的左子节点为空就不需要合并了，</span><br><span class="line">                &#x2F;&#x2F;只有node2的左子节点不为空的时候才需要合并</span><br><span class="line">                if (node2.left !&#x3D; null) &#123;</span><br><span class="line">                    queue.add(node1.left);</span><br><span class="line">                    queue.add(node2.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;原理同上，上面判断的是左子节点，这里判断的是右子节点</span><br><span class="line">            if (node1.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                node1.right &#x3D; node2.right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (node2.right !&#x3D; null) &#123;</span><br><span class="line">                    queue.add(node1.right);</span><br><span class="line">                    queue.add(node2.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode mergeTrees_1(TreeNode t1, TreeNode t2) &#123;</span><br><span class="line">        if (t1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return t2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (t2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return t1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 先合并根节点</span><br><span class="line">        t1.val +&#x3D; t2.val;</span><br><span class="line">        &#x2F;&#x2F; 再递归合并左右子树</span><br><span class="line">        t1.left &#x3D; mergeTrees(t1.left, t2.left);</span><br><span class="line">        t1.right &#x3D; mergeTrees(t1.right, t2.right);</span><br><span class="line">        return t1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 不修改原二叉树的解法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;</span><br><span class="line">        if (t1 &#x3D;&#x3D; null &amp;&amp; t2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 先合并根节点</span><br><span class="line">        TreeNode root &#x3D; new TreeNode((t1 &#x3D;&#x3D; null ? 0 : t1.val) + (t2 &#x3D;&#x3D; null ? 0 : t2.val));</span><br><span class="line">        &#x2F;&#x2F; 再递归合并左右子树</span><br><span class="line">        root.left &#x3D; mergeTrees(t1 &#x3D;&#x3D; null ? null : t1.left, t2 &#x3D;&#x3D; null ? null : t2.left);</span><br><span class="line">        root.right &#x3D; mergeTrees(t1 &#x3D;&#x3D; null ? null : t1.right, t2 &#x3D;&#x3D; null ? null : t2.right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h4><p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为<em>O(n)</em>的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>





<h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h4><p>给定一个字符串 <strong>s</strong> 和一个非空字符串 <strong>p</strong>，找到 <strong>s</strong> 中所有是 <strong>p</strong> 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 <strong>s</strong> 和 <strong>p</strong> 的长度都不超过 20100。</p>
<p><strong>说明：</strong></p>
<ul>
<li>字母异位词指字母相同，但排列不同的字符串。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<p><strong>示例 1:</strong></p>
<h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a>538. 把二叉搜索树转换为累加树</h4><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   int num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;遍历右子树</span><br><span class="line">            convertBST(root.right);</span><br><span class="line">            &#x2F;&#x2F;遍历顶点</span><br><span class="line">            root.val &#x3D; root.val + num;</span><br><span class="line">            num &#x3D; root.val;</span><br><span class="line">            &#x2F;&#x2F;遍历左子树</span><br><span class="line">            convertBST(root.left);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Hard"><a href="#Hard" class="headerlink" title="Hard"></a>Hard</h3><h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h4><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int left&#x3D;(n+m+1)&#x2F;2;</span><br><span class="line">int right&#x3D;(n+m+2)&#x2F;2;</span><br><span class="line">public int helper(int[] nums1,int s1,int[] nums2,int s2,int total)</span><br><span class="line">    &#123;</span><br><span class="line">      if(s1&gt;&#x3D;nums1.length)</span><br><span class="line">      &#123;</span><br><span class="line">          return nums2[s2+total-1];</span><br><span class="line">      &#125;</span><br><span class="line">      if(s2&gt;&#x3D;nums2.length)</span><br><span class="line">      &#123;</span><br><span class="line">          return nums1[s1+total-1];</span><br><span class="line">      &#125;      </span><br><span class="line">      if(total&#x3D;&#x3D;1)</span><br><span class="line">      &#123;</span><br><span class="line">          return Math.min(nums1[s1],nums2[s2]);</span><br><span class="line">      &#125;</span><br><span class="line">      int mid1&#x3D;(s1+total&#x2F;2-1&lt;nums1.length?nums1[s1+total&#x2F;2-1]:Integer.MAX_VALUE);</span><br><span class="line">      int mid2&#x3D;(s2+total&#x2F;2-1&lt;nums2.length?nums2[s2+total&#x2F;2-1]:Integer.MAX_VALUE);</span><br><span class="line">      if(mid1&lt;mid2)</span><br><span class="line">      &#123;</span><br><span class="line">          return helper(nums1,s1+total&#x2F;2,nums2,s2,total-total&#x2F;2);</span><br><span class="line">      &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">          return helper(nums1,s1,nums2,s2+total&#x2F;2,total-total&#x2F;2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h4><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>双指针双max,一个left，一个right，一个left_max，一个right_max</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while (left &lt; right) &#123;</span><br><span class="line">       if (height[left] &lt; height[right]) &#123;</span><br><span class="line">           if (height[left] &gt;&#x3D; left_max) &#123;</span><br><span class="line">               left_max &#x3D; height[left];</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               ans +&#x3D; (left_max - height[left]);</span><br><span class="line">           &#125;</span><br><span class="line">           ++left;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (height[right] &gt;&#x3D; right_max) &#123;</span><br><span class="line">               right_max &#x3D; height[right];</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               ans +&#x3D; (right_max - height[right]);</span><br><span class="line">           &#125;</span><br><span class="line">           --right;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h4><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;n1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;n2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(word1.charAt(i)&#x3D;&#x3D;word2.charAt(j))</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i+1][j+1]&#x3D;dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                dp[i+1][j+1]&#x3D;Math.min(Math.min(dp[i+1][j],dp[i][j+1]),dp[i][j])+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="76-最小覆盖子串5"><a href="#76-最小覆盖子串5" class="headerlink" title="76. 最小覆盖子串5"></a>76. 最小覆盖子串5</h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure>

<p>先开need窗口记录t，当满足</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (needs[ch] &gt; 0 &amp;&amp; needs[ch] &gt;&#x3D; window[ch]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>说明此时还是需要的，接下来移动到不满足为主，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;移动到不满足条件为止</span><br><span class="line">            while (count &#x3D;&#x3D; t.length()) &#123;</span><br><span class="line">                ch &#x3D; s.charAt(left);</span><br><span class="line">                if (needs[ch] &gt; 0 &amp;&amp; needs[ch] &#x3D;&#x3D; window[ch]) &#123; </span><br><span class="line">                   &#x2F;&#x2F; System.out.println(needs[ch]+&quot; &quot;+ch);</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                if (right - left + 1 &lt; minLength) &#123;</span><br><span class="line">                    minLength &#x3D; right - left + 1;</span><br><span class="line">                    res &#x3D; s.substring(left, right + 1);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                window[ch]--;</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br></pre></td></tr></table></figure>

<h4 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h4><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(!set.contains(num-1))</span><br><span class="line">       &#123;</span><br><span class="line">           int cur&#x3D;num;</span><br><span class="line">           int count&#x3D;1;</span><br><span class="line">           while(set.contains(cur+1))</span><br><span class="line">           &#123;</span><br><span class="line">               cur++;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">           max&#x3D;Math.max(max,count);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a>124. 二叉树中的最大路径和</h4><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int leftMax &#x3D; Math.max(0, dfs(root.left));</span><br><span class="line">       &#x2F;&#x2F;计算右边分支最大值，右边分支如果为负数还不如不选择</span><br><span class="line">       int rightMax &#x3D; Math.max(0, dfs(root.right));</span><br><span class="line">       &#x2F;&#x2F;left-&gt;root-&gt;right 作为路径与已经计算过历史最大值做比较</span><br><span class="line">       max &#x3D; Math.max(max, root.val + leftMax + rightMax);</span><br></pre></td></tr></table></figure>

<h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h4><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D; 0;i &lt; nums.length;i++)&#123;</span><br><span class="line">           &#x2F;&#x2F; 保证从大到小 如果前面数小则需要依次弹出，直至满足要求</span><br><span class="line">           while(!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt; nums[i])&#123;</span><br><span class="line">               queue.pollLast();</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; 添加当前值对应的数组下标</span><br><span class="line">           queue.addLast(i);</span><br><span class="line">           &#x2F;&#x2F; 判断当前队列中队首的值是否有效</span><br><span class="line">           if(0 &lt; i-k-queue.peek()+1)&#123;</span><br><span class="line">               queue.poll();   </span><br><span class="line">           &#125; </span><br><span class="line">           &#x2F;&#x2F; 当窗口长度为k时 保存当前窗口中最大值</span><br><span class="line">           if(i+1 &gt;&#x3D; k)&#123;</span><br><span class="line">               result[i+1-k] &#x3D; nums[queue.peek()];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h4><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if(s.charAt(i)&#x3D;&#x3D;&#39;)&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                if(s.charAt(i-1)&#x3D;&#x3D;&#39;(&#39;)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]&#x3D;(i&gt;&#x3D;2?dp[i-2]:0)+2;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    if(s.charAt(i-1)&#x3D;&#x3D;&#39;)&#39;&amp;&amp; i-dp[i-1]&gt;0 &amp;&amp;s.charAt(i-dp[i-1]-1)&#x3D;&#x3D;&#39;(&#39;)</span><br><span class="line">                    &#123;</span><br><span class="line">                      dp[i]&#x3D;dp[i-1]+((i-dp[i-1]-2)&gt;&#x3D;0?dp[i-dp[i-1]-2]:0)+2;  </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans&#x3D;Math.max(maxans,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="862-和至少为-K-的最短子数组"><a href="#862-和至少为-K-的最短子数组" class="headerlink" title="862. 和至少为 K 的最短子数组"></a>862. 和至少为 K 的最短子数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; A.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; A.length + 1; j++) &#123;</span><br><span class="line">                if ((preSum[j] - preSum[i]) &gt;&#x3D; K) &#123;</span><br><span class="line">                    if ((j - i) &lt; minLen) &#123;</span><br><span class="line">                        minLen &#x3D; j - i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a>329. 矩阵中的最长递增路径</h4><p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int longestIncreasingPath(int[][] matrix) &#123;</span><br><span class="line">    if(matrix.length &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    int m &#x3D; matrix.length, n &#x3D; matrix[0].length;</span><br><span class="line">    int[][] cache &#x3D; new int[m][n];</span><br><span class="line">    int max &#x3D; 1;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            int len &#x3D; dfs(matrix, i, j, m, n, cache);</span><br><span class="line">            max &#x3D; Math.max(max, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int dfs(int[][] matrix, int i, int j, int m, int n, int[][] cache) &#123;</span><br><span class="line">    if(cache[i][j] !&#x3D; 0) return cache[i][j];</span><br><span class="line">    int max &#x3D; 1;</span><br><span class="line">    for(int[] dir: dirs) &#123;</span><br><span class="line">        int x &#x3D; i + dir[0], y &#x3D; j + dir[1];</span><br><span class="line">        if(x &lt; 0 || x &gt;&#x3D; m || y &lt; 0 || y &gt;&#x3D; n || matrix[x][y] &lt;&#x3D; matrix[i][j]) continue;</span><br><span class="line">        int len &#x3D; 1 + dfs(matrix, x, y, m, n, cache);</span><br><span class="line">        max &#x3D; Math.max(max, len);</span><br><span class="line">    &#125;</span><br><span class="line">    cache[i][j] &#x3D; max;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a>44. 通配符匹配</h4><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;?&#39; 可以匹配任何单个字符。</span><br><span class="line">&#39;*&#39; 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></figure>

<p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p>
<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dp[0][0] &#x3D; true;</span><br><span class="line">        for (int j &#x3D; 1; j &lt; p.length() + 1; j++) &#123;</span><br><span class="line">            if (p.charAt(j - 1) &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">                dp[0][j] &#x3D; dp[0][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; s.length() + 1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt; p.length() + 1; j++) &#123;</span><br><span class="line">                if (s.charAt(i - 1) &#x3D;&#x3D; p.charAt(j - 1) || p.charAt(j - 1) &#x3D;&#x3D; &#39;?&#39;) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j - 1];</span><br><span class="line">                &#125; else if (p.charAt(j - 1) &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i][j - 1] || dp[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a>99. 恢复二叉搜索树</h4><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
<p><strong>进阶：</strong>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,3,null,null,2]</span><br><span class="line">输出：[3,1,null,null,2]</span><br><span class="line">解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void recoverTree(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">        in_order(root);</span><br><span class="line">        int tmp &#x3D; firstNode.val;</span><br><span class="line">        firstNode.val &#x3D; secondNode.val;</span><br><span class="line">        secondNode.val &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;  3 2 1  -&gt;  1 2 3</span><br><span class="line">    private void in_order(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return;</span><br><span class="line">        in_order(root.left);</span><br><span class="line">        if (firstNode &#x3D;&#x3D; null &amp;&amp; preNode.val &gt; root.val) firstNode &#x3D; preNode;</span><br><span class="line">        if (firstNode !&#x3D; null &amp;&amp; preNode.val &gt; root.val) secondNode &#x3D; root;</span><br><span class="line">        preNode &#x3D; root;</span><br><span class="line">        in_order(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h4><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<ul>
<li><code>&#39;.&#39;</code> 匹配任意单个字符</li>
<li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aa&quot; p &#x3D; &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;n2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i&gt;0 &amp;&amp; p.charAt(i)&#x3D;&#x3D;&#39;*&#39;  &amp;&amp;dp[0][i-1]&#x3D;&#x3D;true)</span><br><span class="line">        &#123;</span><br><span class="line">          dp[0][i+1]&#x3D;true;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;n2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">         if(p.charAt(j)&#x3D;&#x3D;s.charAt(i) || p.charAt(j)&#x3D;&#x3D;&#39;.&#39;)</span><br><span class="line">         &#123;</span><br><span class="line">             dp[i+1][j+1]&#x3D;dp[i][j];</span><br><span class="line">         &#125;</span><br><span class="line">         else&#123;</span><br><span class="line">             if(j&gt;0 &amp;&amp; p.charAt(j)&#x3D;&#x3D;&#39;*&#39;)</span><br><span class="line">             &#123;</span><br><span class="line">                 if(p.charAt(j-1)!&#x3D;&#39;.&#39; &amp;&amp; p.charAt(j-1)!&#x3D;s.charAt(i))</span><br><span class="line">                 &#123;</span><br><span class="line">                     dp[i+1][j+1]&#x3D;dp[i+1][j-1];</span><br><span class="line">                 &#125;</span><br><span class="line">                 else&#123;</span><br><span class="line">                   dp[i+1][j+1]&#x3D;dp[i+1][j]||dp[i+1][j-1] || dp[i][j+1];</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="440-字典序的第K小数字"><a href="#440-字典序的第K小数字" class="headerlink" title="440. 字典序的第K小数字"></a>440. 字典序的第K小数字</h4><p>难度困难194</p>
<p>给定整数 <code>n</code> 和 <code>k</code>，找到 <code>1</code> 到 <code>n</code> 中字典序第 <code>k</code> 小的数字。</p>
<p>注意：1 ≤ k ≤ n ≤ 109。</p>
<p><strong>示例 :</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">n: 13   k: 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public int findKthNumber(int n, int k) &#123;</span><br><span class="line">      int cur&#x3D;1;</span><br><span class="line">      int prefix&#x3D;1;</span><br><span class="line">      while(cur&lt;k)</span><br><span class="line">      &#123;</span><br><span class="line">          int tmp&#x3D;count(prefix,n);</span><br><span class="line">          if(tmp+cur&gt;k)</span><br><span class="line">          &#123;</span><br><span class="line">              prefix*&#x3D;10;</span><br><span class="line">              cur++;</span><br><span class="line">          &#125;</span><br><span class="line">          else&#123;</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private int count(int prefix,int n)</span><br><span class="line">    &#123;</span><br><span class="line">        long cur&#x3D;prefix;</span><br><span class="line">        long next&#x3D;prefix+1;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">        while(cur&lt;&#x3D;n)</span><br><span class="line">        &#123;</span><br><span class="line">            count+&#x3D;Math.min(n+1,next)-cur;</span><br><span class="line">            cur*&#x3D;10;</span><br><span class="line">            next*&#x3D;10; </span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/02/27/FLink%E6%B6%88%E8%B4%B9%E5%BB%B6%E8%BF%9F/" rel="next" title="FLink消费延迟">
                <i class="fa fa-chevron-left"></i> FLink消费延迟
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/09/Spring%E7%9A%84IOC%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" rel="prev" title="Spring的IOC的底层原理">
                Spring的IOC的底层原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="vcomments"></div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avator.png"
                alt="John Doe" />
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=442319&auto=1&height=66"></iframe>

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">257</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            


            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            


          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#mid"><span class="nav-number">1.</span> <span class="nav-text">mid</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-无重复字符的最长子串"><span class="nav-number">1.1.</span> <span class="nav-text">3.无重复字符的最长子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-三数之和"><span class="nav-number">1.2.</span> <span class="nav-text">15.三数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#146-LRU缓存"><span class="nav-number">1.3.</span> <span class="nav-text">146.LRU缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#103-二叉树的锯齿形层序遍历"><span class="nav-number">1.4.</span> <span class="nav-text">103.二叉树的锯齿形层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#215-数组中的第K个最大元素"><span class="nav-number">1.5.</span> <span class="nav-text">215. 数组中的第K个最大元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#105-从前序与中序遍历序列构造二叉树"><span class="nav-number">1.6.</span> <span class="nav-text">105.从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#199-二叉树的右视图"><span class="nav-number">1.7.</span> <span class="nav-text">199. 二叉树的右视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#54-螺旋矩阵"><span class="nav-number">1.8.</span> <span class="nav-text">54. 螺旋矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-搜索旋转排序数组"><span class="nav-number">1.9.</span> <span class="nav-text">33. 搜索旋转排序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#236-二叉树的最近公共祖先"><span class="nav-number">1.10.</span> <span class="nav-text">236. 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31-下一个排列"><span class="nav-number">1.11.</span> <span class="nav-text">31. 下一个排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序奇升偶降链表"><span class="nav-number">1.12.</span> <span class="nav-text">排序奇升偶降链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-两两交换链表中的节点"><span class="nav-number">1.13.</span> <span class="nav-text">24. 两两交换链表中的节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#98-验证二叉搜索树"><span class="nav-number">1.14.</span> <span class="nav-text">98. 验证二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#958-二叉树的完全性检验"><span class="nav-number">1.15.</span> <span class="nav-text">958. 二叉树的完全性检验</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#79-单词搜索"><span class="nav-number">1.16.</span> <span class="nav-text">79. 单词搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#143-重排链表"><span class="nav-number">1.17.</span> <span class="nav-text">143. 重排链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39-组合总和"><span class="nav-number">1.18.</span> <span class="nav-text">39. 组合总和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#518-零钱兑换-II"><span class="nav-number">1.19.</span> <span class="nav-text">518. 零钱兑换 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#162-寻找峰值"><span class="nav-number">1.20.</span> <span class="nav-text">162. 寻找峰值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#56-合并区间"><span class="nav-number">1.21.</span> <span class="nav-text">56. 合并区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#148-排序链表"><span class="nav-number">1.22.</span> <span class="nav-text">148. 排序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#470-用-Rand7-实现-Rand10"><span class="nav-number">1.23.</span> <span class="nav-text">470. 用 Rand7() 实现 Rand10()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#662-二叉树最大宽度"><span class="nav-number">1.24.</span> <span class="nav-text">662. 二叉树最大宽度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#木头切割问题"><span class="nav-number">1.25.</span> <span class="nav-text">木头切割问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#圆环回原点问题"><span class="nav-number">1.26.</span> <span class="nav-text">圆环回原点问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#322-零钱兑换"><span class="nav-number">1.27.</span> <span class="nav-text">322. 零钱兑换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#739-每日温度"><span class="nav-number">1.28.</span> <span class="nav-text">739. 每日温度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#560-和为K的子数组"><span class="nav-number">1.29.</span> <span class="nav-text">560. 和为K的子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#151-翻转字符串里的单词"><span class="nav-number">1.30.</span> <span class="nav-text">151. 翻转字符串里的单词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#670-最大交换"><span class="nav-number">1.31.</span> <span class="nav-text">670. 最大交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#91-解码方法"><span class="nav-number">1.32.</span> <span class="nav-text">91. 解码方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#134-加油站"><span class="nav-number">1.33.</span> <span class="nav-text">134. 加油站</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#138-复制带随机指针的链表"><span class="nav-number">1.34.</span> <span class="nav-text">138. 复制带随机指针的链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36进制加法"><span class="nav-number">1.35.</span> <span class="nav-text">36进制加法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#221-最大正方形"><span class="nav-number">1.36.</span> <span class="nav-text">221. 最大正方形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#93-复原-IP-地址"><span class="nav-number">1.37.</span> <span class="nav-text">93. 复原 IP 地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1143-最长公共子序列"><span class="nav-number">1.38.</span> <span class="nav-text">1143. 最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#560-和为K的子数组-1"><span class="nav-number">1.39.</span> <span class="nav-text">560.和为K的子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#209-长度最小的子数组"><span class="nav-number">1.40.</span> <span class="nav-text">209. 长度最小的子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#974-和可被-K-整除的子数组"><span class="nav-number">1.41.</span> <span class="nav-text">974. 和可被 K 整除的子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#287-寻找重复数"><span class="nav-number">1.42.</span> <span class="nav-text">287. 寻找重复数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#210-课程表-II"><span class="nav-number">1.43.</span> <span class="nav-text">210. 课程表 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#528-按权重随机选择"><span class="nav-number">1.44.</span> <span class="nav-text">528. 按权重随机选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#82-删除排序链表中的重复元素-II"><span class="nav-number">1.45.</span> <span class="nav-text">82. 删除排序链表中的重复元素 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-字符串转换整数-atoi"><span class="nav-number">1.46.</span> <span class="nav-text">8. 字符串转换整数 (atoi)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#50-Pow-x-n"><span class="nav-number">1.47.</span> <span class="nav-text">50. Pow(x, n)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#147-对链表进行插入排序"><span class="nav-number">1.48.</span> <span class="nav-text">147. 对链表进行插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#264-丑数-II"><span class="nav-number">1.49.</span> <span class="nav-text">264. 丑数 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#402-移掉K位数字"><span class="nav-number">1.50.</span> <span class="nav-text">402. 移掉K位数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#86-分隔链表"><span class="nav-number">1.51.</span> <span class="nav-text">86. 分隔链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#71-简化路径"><span class="nav-number">1.52.</span> <span class="nav-text">71. 简化路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-括号生成"><span class="nav-number">1.53.</span> <span class="nav-text">22. 括号生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#279-完全平方数"><span class="nav-number">1.54.</span> <span class="nav-text">279. 完全平方数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#139-单词拆分"><span class="nav-number">1.55.</span> <span class="nav-text">139. 单词拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#647-回文子串"><span class="nav-number">1.56.</span> <span class="nav-text">647. 回文子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#75-颜色分类"><span class="nav-number">1.57.</span> <span class="nav-text">75. 颜色分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#394-字符串解码"><span class="nav-number">1.58.</span> <span class="nav-text">394. 字符串解码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1438-绝对差不超过限制的最长连续子数组"><span class="nav-number">1.59.</span> <span class="nav-text">1438. 绝对差不超过限制的最长连续子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#807-保持城市天际线"><span class="nav-number">1.60.</span> <span class="nav-text">807. 保持城市天际线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#43-字符串相乘"><span class="nav-number">1.61.</span> <span class="nav-text">43. 字符串相乘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#496-下一个更大元素-I"><span class="nav-number">1.62.</span> <span class="nav-text">496. 下一个更大元素 I</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#503-下一个更大元素-II"><span class="nav-number">1.63.</span> <span class="nav-text">503. 下一个更大元素 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#951-翻转等价二叉树"><span class="nav-number">1.64.</span> <span class="nav-text">951. 翻转等价二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#701-二叉搜索树中的插入操作"><span class="nav-number">1.65.</span> <span class="nav-text">701. 二叉搜索树中的插入操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#152-乘积最大子数组"><span class="nav-number">1.66.</span> <span class="nav-text">152. 乘积最大子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#525-连续数组"><span class="nav-number">1.67.</span> <span class="nav-text">525. 连续数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#468-验证IP地址"><span class="nav-number">1.68.</span> <span class="nav-text">468. 验证IP地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#260-只出现一次的数字-III"><span class="nav-number">1.69.</span> <span class="nav-text">260. 只出现一次的数字 III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#347-前-K-个高频元素"><span class="nav-number">1.70.</span> <span class="nav-text">347. 前 K 个高频元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#842-将数组拆分成斐波那契序列"><span class="nav-number">1.71.</span> <span class="nav-text">842. 将数组拆分成斐波那契序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#179-最大数"><span class="nav-number">1.72.</span> <span class="nav-text">179. 最大数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#198-打家劫舍"><span class="nav-number">1.73.</span> <span class="nav-text">198. 打家劫舍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#213-打家劫舍-II"><span class="nav-number">1.74.</span> <span class="nav-text">213. 打家劫舍 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#609-在系统中查找重复文件"><span class="nav-number">1.75.</span> <span class="nav-text">609. 在系统中查找重复文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#516-最长回文子序列"><span class="nav-number">1.76.</span> <span class="nav-text">516. 最长回文子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#416-分割等和子集"><span class="nav-number">1.77.</span> <span class="nav-text">416. 分割等和子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-电话号码的字母组合"><span class="nav-number">1.78.</span> <span class="nav-text">17. 电话号码的字母组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#49-字母异位词分组"><span class="nav-number">1.79.</span> <span class="nav-text">49. 字母异位词分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#334-递增的三元子序列"><span class="nav-number">1.80.</span> <span class="nav-text">334. 递增的三元子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#208-实现-Trie-前缀树"><span class="nav-number">1.81.</span> <span class="nav-text">208. 实现 Trie (前缀树)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#498-对角线遍历"><span class="nav-number">1.82.</span> <span class="nav-text">498. 对角线遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#238-除自身以外数组的乘积"><span class="nav-number">1.83.</span> <span class="nav-text">238. 除自身以外数组的乘积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#55-跳跃游戏"><span class="nav-number">1.84.</span> <span class="nav-text">55. 跳跃游戏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#45-跳跃游戏-II"><span class="nav-number">1.85.</span> <span class="nav-text">45. 跳跃游戏 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#80-删除排序数组中的重复项-II"><span class="nav-number">1.86.</span> <span class="nav-text">80. 删除排序数组中的重复项 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-删除排序数组中的重复项"><span class="nav-number">1.87.</span> <span class="nav-text">26. 删除排序数组中的重复项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#767-重构字符串"><span class="nav-number">1.88.</span> <span class="nav-text">767. 重构字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#523-连续的子数组和"><span class="nav-number">1.89.</span> <span class="nav-text">523. 连续的子数组和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#96-不同的二叉搜索树"><span class="nav-number">1.90.</span> <span class="nav-text">96. 不同的二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#376-摆动序列"><span class="nav-number">1.91.</span> <span class="nav-text">376. 摆动序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1498-满足条件的子序列数目"><span class="nav-number">1.92.</span> <span class="nav-text">1498. 满足条件的子序列数目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#863-二叉树中所有距离为-K-的结点"><span class="nav-number">1.93.</span> <span class="nav-text">863. 二叉树中所有距离为 K 的结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#45-跳跃游戏-II-1"><span class="nav-number">1.94.</span> <span class="nav-text">45. 跳跃游戏 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#977-有序数组的平方"><span class="nav-number">1.95.</span> <span class="nav-text">977. 有序数组的平方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#680-验证回文字符串-Ⅱ"><span class="nav-number">1.96.</span> <span class="nav-text">680. 验证回文字符串 Ⅱ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-最长公共前缀"><span class="nav-number">1.97.</span> <span class="nav-text">14. 最长公共前缀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#283-移动零"><span class="nav-number">1.98.</span> <span class="nav-text">283. 移动零</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#242-有效的字母异位词"><span class="nav-number">1.99.</span> <span class="nav-text">242. 有效的字母异位词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#572-另一个树的子树"><span class="nav-number">1.100.</span> <span class="nav-text">572. 另一个树的子树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-删除排序数组中的重复项-1"><span class="nav-number">1.101.</span> <span class="nav-text">26. 删除排序数组中的重复项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#190-颠倒二进制位"><span class="nav-number">1.102.</span> <span class="nav-text">190. 颠倒二进制位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#459-重复的子字符串"><span class="nav-number">1.103.</span> <span class="nav-text">459. 重复的子字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-整数反转"><span class="nav-number">1.104.</span> <span class="nav-text">7. 整数反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#204-计数质数"><span class="nav-number">1.105.</span> <span class="nav-text">204. 计数质数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#202-快乐数"><span class="nav-number">1.106.</span> <span class="nav-text">202. 快乐数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#111-二叉树的最小深度"><span class="nav-number">1.107.</span> <span class="nav-text">111. 二叉树的最小深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#922-按奇偶排序数组-II"><span class="nav-number">1.108.</span> <span class="nav-text">922. 按奇偶排序数组 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-回文数"><span class="nav-number">1.109.</span> <span class="nav-text">9. 回文数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1299-将每个元素替换为右侧最大元素"><span class="nav-number">1.110.</span> <span class="nav-text">1299. 将每个元素替换为右侧最大元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#122-买卖股票的最佳时机-II"><span class="nav-number">1.111.</span> <span class="nav-text">122. 买卖股票的最佳时机 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#405-数字转换为十六进制数"><span class="nav-number">1.112.</span> <span class="nav-text">405. 数字转换为十六进制数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#836-矩形重叠"><span class="nav-number">1.113.</span> <span class="nav-text">836. 矩形重叠</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指offer"><span class="nav-number">2.</span> <span class="nav-text">剑指offer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#剑指-Offer-05-替换空格"><span class="nav-number">2.1.</span> <span class="nav-text">剑指 Offer 05. 替换空格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-矩阵中的路径"><span class="nav-number">2.2.</span> <span class="nav-text">12. 矩阵中的路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-机器人的运动范围"><span class="nav-number">2.3.</span> <span class="nav-text">13. 机器人的运动范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-二进制中1的个数"><span class="nav-number">2.4.</span> <span class="nav-text">15. 二进制中1的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-调整数组顺序使奇数位于偶数前面"><span class="nav-number">2.5.</span> <span class="nav-text">21. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-反转链表"><span class="nav-number">2.6.</span> <span class="nav-text">24. 反转链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-树的子结构"><span class="nav-number">2.7.</span> <span class="nav-text">26. 树的子结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-对称的二叉树"><span class="nav-number">2.8.</span> <span class="nav-text">28. 对称的二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31-栈的压入、弹出序列"><span class="nav-number">2.9.</span> <span class="nav-text">31.栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30-包含min函数的栈"><span class="nav-number">2.10.</span> <span class="nav-text">30. 包含min函数的栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#03-数组中重复的数字"><span class="nav-number">2.11.</span> <span class="nav-text">03. 数组中重复的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#剪绳子"><span class="nav-number">2.12.</span> <span class="nav-text">剪绳子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-二叉搜索树的后序遍历序列"><span class="nav-number">2.13.</span> <span class="nav-text">33. 二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46-把数字翻译成字符串"><span class="nav-number">2.14.</span> <span class="nav-text">46. 把数字翻译成字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#37-序列化二叉树"><span class="nav-number">2.15.</span> <span class="nav-text">37. 序列化二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#41-数据流中的中位数"><span class="nav-number">2.16.</span> <span class="nav-text">41. 数据流中的中位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#51-数组中的逆序对"><span class="nav-number">2.17.</span> <span class="nav-text">51. 数组中的逆序对</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53-II-0～n-1中缺失的数字"><span class="nav-number">2.18.</span> <span class="nav-text">53 - II. 0～n-1中缺失的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#68-I-二叉搜索树的最近公共祖先"><span class="nav-number">2.19.</span> <span class="nav-text">68 - I. 二叉搜索树的最近公共祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#61-扑克牌中的顺子"><span class="nav-number">2.20.</span> <span class="nav-text">61. 扑克牌中的顺子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#88-合并两个有序数组"><span class="nav-number">2.21.</span> <span class="nav-text">88. 合并两个有序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#69-x-的平方根"><span class="nav-number">2.22.</span> <span class="nav-text">69. x 的平方根</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#56-II-数组中数字出现的次数-II"><span class="nav-number">2.23.</span> <span class="nav-text">56 - II. 数组中数字出现的次数 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53-II-0～n-1中缺失的数字-1"><span class="nav-number">2.24.</span> <span class="nav-text">53 - II. 0～n-1中缺失的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#57-II-和为s的连续正数序列"><span class="nav-number">2.25.</span> <span class="nav-text">57 - II. 和为s的连续正数序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#59-II-队列的最大值"><span class="nav-number">2.26.</span> <span class="nav-text">59 - II. 队列的最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#65-不用加减乘除做加法"><span class="nav-number">2.27.</span> <span class="nav-text">65. 不用加减乘除做加法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64-求1-2-…-n"><span class="nav-number">2.28.</span> <span class="nav-text">64. 求1+2+…+n</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#59-I-滑动窗口的最大值"><span class="nav-number">2.29.</span> <span class="nav-text">59 - I. 滑动窗口的最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#62-圆圈中最后剩下的数字"><span class="nav-number">2.30.</span> <span class="nav-text">62. 圆圈中最后剩下的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#57-II-和为s的连续正数序列-1"><span class="nav-number">2.31.</span> <span class="nav-text">57 - II. 和为s的连续正数序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-打印从1到最大的n位数"><span class="nav-number">2.32.</span> <span class="nav-text">17. 打印从1到最大的n位数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hot100"><span class="nav-number">3.</span> <span class="nav-text">Hot100</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-两数之和"><span class="nav-number">3.1.</span> <span class="nav-text">1. 两数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-有效的括号"><span class="nav-number">3.2.</span> <span class="nav-text">20. 有效的括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-在排序数组中查找元素的第一个和最后一个位置"><span class="nav-number">3.3.</span> <span class="nav-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#136-只出现一次的数字38"><span class="nav-number">3.4.</span> <span class="nav-text">136. 只出现一次的数字38</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#226-翻转二叉树"><span class="nav-number">3.5.</span> <span class="nav-text">226. 翻转二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#494-目标和"><span class="nav-number">3.6.</span> <span class="nav-text">494. 目标和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#543-二叉树的直径"><span class="nav-number">3.7.</span> <span class="nav-text">543. 二叉树的直径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#322-零钱兑换-1"><span class="nav-number">3.8.</span> <span class="nav-text">322. 零钱兑换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#338-比特位计数"><span class="nav-number">3.9.</span> <span class="nav-text">338. 比特位计数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#617-合并二叉树"><span class="nav-number">3.10.</span> <span class="nav-text">617. 合并二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#448-找到所有数组中消失的数字"><span class="nav-number">3.11.</span> <span class="nav-text">448. 找到所有数组中消失的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#438-找到字符串中所有字母异位词"><span class="nav-number">3.12.</span> <span class="nav-text">438. 找到字符串中所有字母异位词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#538-把二叉搜索树转换为累加树"><span class="nav-number">3.13.</span> <span class="nav-text">538. 把二叉搜索树转换为累加树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hard"><span class="nav-number">4.</span> <span class="nav-text">Hard</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-寻找两个正序数组的中位数"><span class="nav-number">4.1.</span> <span class="nav-text">4. 寻找两个正序数组的中位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#42-接雨水"><span class="nav-number">4.2.</span> <span class="nav-text">42. 接雨水</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#72-编辑距离"><span class="nav-number">4.3.</span> <span class="nav-text">72. 编辑距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#76-最小覆盖子串5"><span class="nav-number">4.4.</span> <span class="nav-text">76. 最小覆盖子串5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#128-最长连续序列"><span class="nav-number">4.5.</span> <span class="nav-text">128. 最长连续序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#124-二叉树中的最大路径和"><span class="nav-number">4.6.</span> <span class="nav-text">124. 二叉树中的最大路径和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#239-滑动窗口最大值"><span class="nav-number">4.7.</span> <span class="nav-text">239. 滑动窗口最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-最长有效括号"><span class="nav-number">4.8.</span> <span class="nav-text">32. 最长有效括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#862-和至少为-K-的最短子数组"><span class="nav-number">4.9.</span> <span class="nav-text">862. 和至少为 K 的最短子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#329-矩阵中的最长递增路径"><span class="nav-number">4.10.</span> <span class="nav-text">329. 矩阵中的最长递增路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#44-通配符匹配"><span class="nav-number">4.11.</span> <span class="nav-text">44. 通配符匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#99-恢复二叉搜索树"><span class="nav-number">4.12.</span> <span class="nav-text">99. 恢复二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-正则表达式匹配"><span class="nav-number">4.13.</span> <span class="nav-text">10. 正则表达式匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#440-字典序的第K小数字"><span class="nav-number">4.14.</span> <span class="nav-text">440. 字典序的第K小数字</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>
-->




    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共506.2k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  






  
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine@1.1.4/dist/Valine.min.js"></script>
  <script type="text/javascript">
    new Valine({
        av: AV,
        el: '#vcomments' ,
        verify: false,
        notify: false,
        app_id: 'poAXA1bCt4bcaGmuoHBrU52s-gzGzoHsz',
        app_key: 'ARaHT9OThVx8QqybEjteIed2',
        placeholder: 'Comment input placeholder'
    });
  </script>




  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "./public/search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  





<script type="text/javascript"
color="0,0,255" opacity='0.7' zIndex="-2" count="30" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<script type="text/javascript" src="/js/src/clicklove.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
