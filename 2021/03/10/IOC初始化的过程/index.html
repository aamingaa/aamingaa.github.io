<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] 1.IOC的理解如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：  谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IoC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象 控制什么：控制对象。 为何是反转：没有 IoC 的时候我们都是在自己对象中">
<meta property="og:type" content="article">
<meta property="og:title" content="IOC初始化的过程">
<meta property="og:url" content="http://aamingaa.github.io/2021/03/10/IOC%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[TOC] 1.IOC的理解如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：  谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IoC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象 控制什么：控制对象。 为何是反转：没有 IoC 的时候我们都是在自己对象中">
<meta property="og:image" content="http://static.iocoder.cn/143162657d5f8c7cb7712d0996bf2a38">
<meta property="og:image" content="http://static.iocoder.cn/2446cc9fba90605b691ea250cf340ebb">
<meta property="og:image" content="http://static.iocoder.cn/08e5f8a505505def17e84becd4f0dbf9">
<meta property="og:image" content="http://static.iocoder.cn/8f77d23019c10f4ac026968ce19067ef">
<meta property="og:image" content="http://static.iocoder.cn/4dba22abb6ce4bc1a7721afb2cb53567">
<meta property="og:image" content="http://static.iocoder.cn/882e730ac463e3007c5f3c5cde8380bc">
<meta property="og:image" content="http://static.iocoder.cn/741da1d13906154d36f02fa5113432fd">
<meta property="og:image" content="http://aamingaa.github.io/2021/03/10/IOC%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220716173642850.png">
<meta property="article:published_time" content="2021-03-09T17:07:37.000Z">
<meta property="article:modified_time" content="2022-07-17T15:38:27.347Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://static.iocoder.cn/143162657d5f8c7cb7712d0996bf2a38">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://aamingaa.github.io/2021/03/10/IOC初始化的过程/"/>





  <title>IOC初始化的过程 | Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aamingaa.github.io/2021/03/10/IOC%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">IOC初始化的过程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-10T01:07:37+08:00">
                2021-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  64
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h2 id="1-IOC的理解"><a href="#1-IOC的理解" class="headerlink" title="1.IOC的理解"></a>1.IOC的理解</h2><p>如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：</p>
<ol>
<li><strong>谁控制谁</strong>：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IoC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象</li>
<li><strong>控制什么</strong>：控制对象。</li>
<li><strong>为何是反转</strong>：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li>
<li><strong>哪些方面反转了</strong>：所依赖对象的获取被反转了。</li>
</ol>
<p>在没有引入 IoC 的时候，被注入的对象直接依赖于被依赖的对象，有了 IoC 后，两者及其他们的关系都是通过 Ioc Service Provider 来统一管理维护的。被注入的对象需要什么，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IoC Service Provider 为被注入对象服务的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">HelloWorld obj &#x3D; (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br></pre></td></tr></table></figure>

<p><code>org.springframework.context.ApplicationContext</code> ，这个就是大名鼎鼎的 Spring 容器，它叫做应用上下文，与我们应用息息相关。它继承 BeanFactory ，所以它是 BeanFactory 的扩展升级版，如果BeanFactory 是屌丝的话，那么 ApplicationContext 则是名副其实的高富帅。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有：</p>
<p>IoC 咋一看还是挺简单的，无非就是将配置文件（暂且认为是 xml 文件）进行解析（分析 xml 谁不会啊），然后放到一个 Map 里面就差不多了，初看有道理，其实要面临的问题还是有很多的，下面就劳烦各位看客跟着 LZ 博客来一步一步揭开 Spring IoC 的神秘面纱。</p>
<h2 id="2-统一资源加载策略"><a href="#2-统一资源加载策略" class="headerlink" title="2.统一资源加载策略"></a>2.统一资源加载策略</h2><p><img src="http://static.iocoder.cn/143162657d5f8c7cb7712d0996bf2a38" alt="img"></p>
<ul>
<li>FileSystemResource ：对 <code>java.io.File</code> 类型资源的封装，只要是跟 File 打交道的，基本上与 FileSystemResource 也可以打交道。支持文件和 URL 的形式，实现 WritableResource 接口，且从 Spring Framework 5.0 开始，FileSystemResource 使用 NIO2 API进行读/写交互。</li>
<li>ByteArrayResource ：对字节数组提供的数据的封装。如果通过 InputStream 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 ByteArrayInputStream。</li>
<li>UrlResource ：对 <code>java.net.URL</code>类型资源的封装。内部委派 URL 进行具体的资源操作。</li>
<li>ClassPathResource ：class path 类型资源的实现。使用给定的 ClassLoader 或者给定的 Class 来加载资源。</li>
<li>InputStreamResource ：将给定的 InputStream 作为一种资源的 Resource 的实现类。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractResource implements Resource &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean exists() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">		  &#x2F;&#x2F; 基于 File 进行判断</span><br><span class="line">			return getFile().exists();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IOException ex) &#123;</span><br><span class="line">			&#x2F;&#x2F; Fall back to stream existence: can we open the stream?</span><br><span class="line">			&#x2F;&#x2F; 基于 InputStream 进行判断</span><br><span class="line">			try &#123;</span><br><span class="line">				InputStream is &#x3D; getInputStream();</span><br><span class="line">				is.close();</span><br><span class="line">				return true;</span><br><span class="line">			&#125; catch (Throwable isEx) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 直接返回true，表示可读</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean isReadable() &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.iocoder.cn/2446cc9fba90605b691ea250cf340ebb" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface ResourceLoader &#123;</span><br><span class="line"></span><br><span class="line">	String CLASSPATH_URL_PREFIX &#x3D; ResourceUtils.CLASSPATH_URL_PREFIX; &#x2F;&#x2F; CLASSPATH URL 前缀。默认为：&quot;classpath:&quot;</span><br><span class="line"></span><br><span class="line">	Resource getResource(String location);</span><br><span class="line"></span><br><span class="line">	ClassLoader getClassLoader();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getResource(String location) 支持以下模式的资源加载：</p>
<ul>
<li><ul>
<li>URL位置资源，如 “file:C:/test.dat” 。</li>
<li>ClassPath位置资源，如 “classpath:test.dat 。</li>
<li>相对路径资源，如 “WEB-INF/test.dat” ，此时返回的Resource 实例，根据实现不同而不同。</li>
</ul>
</li>
<li>getClassLoader()方法的主要实现是在其子类 DefaultResourceLoader 中实现，具体过程我们在分析 DefaultResourceLoader 时做详细说明。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; DefaultResourceLoader.java</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Resource getResource(String location) &#123;</span><br><span class="line">    Assert.notNull(location, &quot;Location must not be null&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 首先，通过 ProtocolResolver 来加载资源</span><br><span class="line">    for (ProtocolResolver protocolResolver : this.protocolResolvers) &#123;</span><br><span class="line">        Resource resource &#x3D; protocolResolver.resolve(location, this);</span><br><span class="line">        if (resource !&#x3D; null) &#123;</span><br><span class="line">            return resource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 其次，以 &#x2F; 开头，返回 ClassPathContextResource 类型的资源</span><br><span class="line">    if (location.startsWith(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">        return getResourceByPath(location);</span><br><span class="line">    &#x2F;&#x2F; 再次，以 classpath: 开头，返回 ClassPathResource 类型的资源</span><br><span class="line">    &#125; else if (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">    &#x2F;&#x2F; 然后，根据是否为文件 URL ，是则返回 FileUrlResource 类型的资源，否则返回 UrlResource 类型的资源</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Try to parse the location as a URL...</span><br><span class="line">            URL url &#x3D; new URL(location);</span><br><span class="line">            return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));</span><br><span class="line">        &#125; catch (MalformedURLException ex) &#123;</span><br><span class="line">            &#x2F;&#x2F; 最后，返回 ClassPathContextResource 类型的资源</span><br><span class="line">            &#x2F;&#x2F; No URL -&gt; resolve as resource path.</span><br><span class="line">            return getResourceByPath(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-加载-BeanDefinition"><a href="#3-加载-BeanDefinition" class="headerlink" title="3.加载 BeanDefinition"></a>3.加载 BeanDefinition</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource resource &#x3D; new ClassPathResource(&quot;bean.xml&quot;); &#x2F;&#x2F; &lt;1&gt;</span><br><span class="line">DefaultListableBeanFactory factory &#x3D; new DefaultListableBeanFactory(); &#x2F;&#x2F; &lt;2&gt;</span><br><span class="line">XmlBeanDefinitionReader reader &#x3D; new XmlBeanDefinitionReader(factory); &#x2F;&#x2F; &lt;3&gt;</span><br><span class="line">reader.loadBeanDefinitions(resource); &#x2F;&#x2F; &lt;4&gt;</span><br></pre></td></tr></table></figure>

<p>这段代码是 Spring 中编程式使用 IoC 容器，通过这四段简单的代码，我们可以初步判断 IoC 容器的使用过程。</p>
<ol>
<li>获取资源</li>
<li>获取 BeanFactory</li>
<li>根据新建的 BeanFactory 创建一个 BeanDefinitionReader 对象，该 Reader 对象为资源的<strong>解析器</strong></li>
<li>装载资源</li>
</ol>
<p>整个过程就分为三个步骤：资源定位、装载、注册，如下：</p>
<ul>
<li><p><strong>资源定位</strong>。我们一般用外部资源来描述 Bean 对象，所以在初始化 IoC 容器的第一步就是需要定位这个外部资源。在上一篇博客（<a href="http://svip.iocoder.cn/Spring/IoC-load-Resource" target="_blank" rel="noopener">《【死磕 Spring】—— IoC 之 Spring 统一资源加载策略》</a>）已经详细说明了资源加载的过程。</p>
</li>
<li><p><strong>装载</strong>。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IoC 容器的内部数据结构：BeanDefinition 。</p>
<ul>
<li>在 IoC 容器内部维护着一个 BeanDefinition Map 的数据结构</li>
<li>在配置文件中每一个 <code>&lt;bean&gt;</code> 都对应着一个 BeanDefinition 对象。</li>
</ul>
</li>
<li><p><strong>注册</strong>。向 IoC 容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistry 接口来实现的。在 IoC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IoC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。</p>
<ul>
<li>在这里需要注意的一点是这个过程并没有完成依赖注入（Bean 创建），Bean 创建是发生在应用第一次调用 <code>#getBean(...)</code> 方法，向容器索要 Bean 时。</li>
<li>当然我们可以通过设置预处理，即对某个 Bean 设置 <code>lazyinit = false</code> 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。</li>
</ul>
<p>简单的说，上面步骤的结果是，XML Resource =&gt; XML Document =&gt; Bean Definition 。</p>
</li>
</ul>
<h3 id="3-1loadBeanDefinitions"><a href="#3-1loadBeanDefinitions" class="headerlink" title="3.1loadBeanDefinitions"></a>3.1loadBeanDefinitions</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; XmlBeanDefinitionReader.java</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从指定的 xml 文件加载 Bean Definition ，这里会先对 Resource 资源封装成 <code>org.springframework.core.io.support.EncodedResource</code> 对象。这里为什么需要将 Resource 封装成 EncodedResource 呢？主要是为了对 Resource 进行编码，保证内容读取的正确性。</li>
<li>然后，再调用 <code>#loadBeanDefinitions(EncodedResource encodedResource)</code> 方法，执行真正的逻辑实现。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 当前线程，正在加载的 EncodedResource 集合。</span><br><span class="line"> *&#x2F;</span><br><span class="line">private final ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded &#x3D; new NamedThreadLocal&lt;&gt;(&quot;XML bean definition resources currently being loaded&quot;);</span><br><span class="line"></span><br><span class="line">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);</span><br><span class="line">	if (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(&quot;Loading XML bean definitions from &quot; + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; &lt;1&gt; 获取已经加载过的资源</span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources &#x3D; this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">	if (currentResources &#x3D;&#x3D; null) &#123;</span><br><span class="line">		currentResources &#x3D; new HashSet&lt;&gt;(4);</span><br><span class="line">		this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">	&#125;</span><br><span class="line">	if (!currentResources.add(encodedResource)) &#123; &#x2F;&#x2F; 将当前资源加入记录中。如果已存在，抛出异常</span><br><span class="line">		throw new BeanDefinitionStoreException(&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F; &lt;2&gt; 从 EncodedResource 获取封装的 Resource ，并从 Resource 中获取其中的 InputStream</span><br><span class="line">		InputStream inputStream &#x3D; encodedResource.getResource().getInputStream();</span><br><span class="line">		try &#123;</span><br><span class="line">			InputSource inputSource &#x3D; new InputSource(inputStream);</span><br><span class="line">			if (encodedResource.getEncoding() !&#x3D; null) &#123; &#x2F;&#x2F; 设置编码</span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; 核心逻辑部分，执行加载 BeanDefinition</span><br><span class="line">			return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		&#x2F;&#x2F; 从缓存中剔除该资源 &lt;3&gt;</span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		if (currentResources.isEmpty()) &#123;</span><br><span class="line">			this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>&lt;1&gt;处，通过resourcesCurrentlyBeingLoaded.get()代码，来获取已经加载过的资源，然后将encodedResource加入其中，如果esourcesCurrentlyBeingLoaded  中已经存在该资源，则抛出 BeanDefinitionStoreException 异常。</p>
<ul>
<li>为什么需要这么做呢？答案在 <code>&quot;Detected cyclic loading&quot;</code> ，避免一个 EncodedResource 在加载时，还没加载完成，又加载自身，从而导致<strong>死循环</strong>。</li>
<li>也因此，在 <code>&lt;3&gt;</code> 处，当一个 EncodedResource 加载完成后，需要从缓存中剔除。</li>
</ul>
</li>
<li><p><code>&lt;2&gt;</code> 处理，从 <code>encodedResource</code> 获取封装的 Resource 资源，并从 Resource 中获取相应的 InputStream ，然后将 InputStream 封装为 InputSource ，最后调用 <code>#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法，执行加载 Bean Definition 的真正逻辑。</p>
</li>
</ul>
<h3 id="3-2-doLoadBeanDefinitions"><a href="#3-2-doLoadBeanDefinitions" class="headerlink" title="3.2 doLoadBeanDefinitions"></a>3.2 doLoadBeanDefinitions</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Actually load bean definitions from the specified XML file.</span><br><span class="line"> * @param inputSource the SAX InputSource to read from</span><br><span class="line"> * @param resource the resource descriptor for the XML file</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> * @see #doLoadDocument</span><br><span class="line"> * @see #registerBeanDefinitions</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F; &lt;1&gt; 获取 XML Document 实例</span><br><span class="line">		Document doc &#x3D; doLoadDocument(inputSource, resource);</span><br><span class="line">		&#x2F;&#x2F; &lt;2&gt; 根据 Document 实例，注册 Bean 信息</span><br><span class="line">		int count &#x3D; registerBeanDefinitions(doc, resource);</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource);</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125; catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125; catch (SAXParseException ex) &#123;</span><br><span class="line">		throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);</span><br><span class="line">	&#125; catch (SAXException ex) &#123;</span><br><span class="line">		throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);</span><br><span class="line">	&#125; catch (ParserConfigurationException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Parser configuration exception parsing XML from &quot; + resource, ex);</span><br><span class="line">	&#125; catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;IOException parsing XML document from &quot; + resource, ex);</span><br><span class="line">	&#125; catch (Throwable ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Unexpected exception parsing XML document from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>&lt;1&gt;</code> 处，调用 <code>#doLoadDocument(InputSource inputSource, Resource resource)</code> 方法，根据 xml 文件，获取 Document 实例。</li>
<li>在 <code>&lt;2&gt;</code> 处，调用 <code>#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，根据获取的 Document 实例，注册 Bean 信息。</li>
</ul>
<h4 id="3-2-1-doLoadDocument"><a href="#3-2-1-doLoadDocument" class="headerlink" title="3.2.1 doLoadDocument"></a>3.2.1 doLoadDocument</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 获取 XML Document 实例</span><br><span class="line"> *</span><br><span class="line"> * Actually load the specified document using the configured DocumentLoader.</span><br><span class="line"> * @param inputSource the SAX InputSource to read from</span><br><span class="line"> * @param resource the resource descriptor for the XML file</span><br><span class="line"> * @return the DOM Document</span><br><span class="line"> * @throws Exception when thrown from the DocumentLoader</span><br><span class="line"> * @see #setDocumentLoader</span><br><span class="line"> * @see DocumentLoader#loadDocument</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception &#123;</span><br><span class="line">	return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,</span><br><span class="line">			getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用 <code>#getValidationModeForResource(Resource resource)</code> 方法，获取指定资源（xml）的<strong>验证模式</strong>。详细解析，见 <a href="http://svip.iocoder.cn/Spring/IoC-Validation-Mode-For-Resource" target="_blank" rel="noopener">《【死磕 Spring】—— IoC 之获取验证模型》</a> 。</li>
<li>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。详细解析，见 <a href="http://svip.iocoder.cn/Spring/IoC-load-Document" target="_blank" rel="noopener">《【死磕 Spring】—— IoC 之获取 Document 对象》</a> </li>
</ol>
<h4 id="3-2-2-registerBeanDefinitions"><a href="#3-2-2-registerBeanDefinitions" class="headerlink" title="3.2.2 registerBeanDefinitions"></a>3.2.2 registerBeanDefinitions</h4><p>该方法的详细解析，见 <a href="http://svip.iocoder.cn/Spring/IoC-register-BeanDefinitions" target="_blank" rel="noopener">《【死磕 Spring】—— IoC 之注册 BeanDefinition》</a> 。</p>
<h2 id="4-获取验证模型"><a href="#4-获取验证模型" class="headerlink" title="4.获取验证模型"></a>4.获取验证模型</h2><p><code>#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法中，中主要是做三件事情：</p>
<ol>
<li>调用 <code>#getValidationModeForResource(Resource resource)</code> 方法，获取指定资源（xml）的<strong>验证模式</strong>。</li>
<li>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver,ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。</li>
<li>调用 <code>#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，根据获取的 Document 实例，注册 Bean 信息。</li>
</ol>
<p>DTD(Document Type Definition)，即文档类型定义，为 XML 文件的验证机制，属于 XML 文件中组成的一部分。</p>
<h3 id="1-getValidationModeForResource"><a href="#1-getValidationModeForResource" class="headerlink" title="1. getValidationModeForResource"></a>1. getValidationModeForResource</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; XmlBeanDefinitionReader.java</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 禁用验证模式</span><br><span class="line">public static final int VALIDATION_NONE &#x3D; XmlValidationModeDetector.VALIDATION_NONE;</span><br><span class="line">&#x2F;&#x2F; 自动获取验证模式</span><br><span class="line">public static final int VALIDATION_AUTO &#x3D; XmlValidationModeDetector.VALIDATION_AUTO;</span><br><span class="line">&#x2F;&#x2F; DTD 验证模式</span><br><span class="line">public static final int VALIDATION_DTD &#x3D; XmlValidationModeDetector.VALIDATION_DTD;</span><br><span class="line">&#x2F;&#x2F; XSD 验证模式</span><br><span class="line">public static final int VALIDATION_XSD &#x3D; XmlValidationModeDetector.VALIDATION_XSD;</span><br><span class="line">	</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 验证模式。默认为自动模式。</span><br><span class="line"> *&#x2F;</span><br><span class="line">private int validationMode &#x3D; VALIDATION_AUTO;</span><br><span class="line">	</span><br><span class="line">protected int getValidationModeForResource(Resource resource) &#123;</span><br><span class="line">	&#x2F;&#x2F; &lt;1&gt; 获取指定的验证模式</span><br><span class="line">	int validationModeToUse &#x3D; getValidationMode();</span><br><span class="line">	&#x2F;&#x2F; 首先，如果手动指定，则直接返回</span><br><span class="line">	if (validationModeToUse !&#x3D; VALIDATION_AUTO) &#123;</span><br><span class="line">		return validationModeToUse;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 其次，自动获取验证模式</span><br><span class="line">	int detectedMode &#x3D; detectValidationMode(resource);</span><br><span class="line">	if (detectedMode !&#x3D; VALIDATION_AUTO) &#123;</span><br><span class="line">		return detectedMode;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 最后，使用 VALIDATION_XSD 做为默认</span><br><span class="line">	&#x2F;&#x2F; Hmm, we didn&#39;t get a clear indication... Let&#39;s assume XSD,</span><br><span class="line">	&#x2F;&#x2F; since apparently no DTD declaration has been found up until</span><br><span class="line">	&#x2F;&#x2F; detection stopped (before finding the document&#39;s root tag).</span><br><span class="line">	return VALIDATION_XSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;1&gt;</code> 处，调用 <code>#getValidationMode()</code> 方法，获取指定的验证模式( <code>validationMode</code> )。如果有手动指定，则直接返回。</p>
</li>
<li><p><code>&lt;2&gt;</code> 处，调用 <code>#detectValidationMode(Resource resource)</code> 方法，自动获取验证模式。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * XML 验证模式探测器</span><br><span class="line"> *&#x2F;</span><br><span class="line"> ...</span><br><span class="line">	&#x2F;&#x2F; &lt;x&gt; 获取相应的验证模式</span><br><span class="line">	try &#123;</span><br><span class="line">		return this.validationModeDetector.detectValidationMode(inputStream);</span><br><span class="line">	&#125; catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(&quot;Unable to determine validation mode for [&quot; +</span><br><span class="line">				resource + &quot;]: an error occurred whilst reading from the InputStream.&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>核心在于 <code>&lt;x&gt;</code> 处，调用 <code>XmlValidationModeDetector#detectValidationMode(InputStream inputStream)</code> 方法，获取相应的验证模式。详细解析，见 <a href="http://svip.iocoder.cn/Spring/IoC-Validation-Mode-For-Resource/#" target="_blank" rel="noopener">「2. XmlValidationModeDetector」</a> 中。</li>
</ul>
</li>
<li><p><code>&lt;3&gt;</code> 处，使用 <code>VALIDATION_XSD</code> 做为默认。</p>
</li>
</ul>
<h3 id="2-XmlValidationModeDetector"><a href="#2-XmlValidationModeDetector" class="headerlink" title="2. XmlValidationModeDetector"></a>2. XmlValidationModeDetector</h3><p><code>org.springframework.util.xml.XmlValidationModeDetector</code> ，XML 验证模式探测器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public int detectValidationMode(InputStream inputStream) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; Peek into the file to look for DOCTYPE.</span><br><span class="line">    BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 是否为 DTD 校验模式。默认为，非 DTD 模式，即 XSD 模式</span><br><span class="line">        boolean isDtdValidated &#x3D; false;</span><br><span class="line">        String content;</span><br><span class="line">        &#x2F;&#x2F; &lt;0&gt; 循环，逐行读取 XML 文件的内容</span><br><span class="line">        while ((content &#x3D; reader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            content &#x3D; consumeCommentTokens(content);</span><br><span class="line">            &#x2F;&#x2F; 跳过，如果是注释，或者</span><br><span class="line">            if (this.inComment || !StringUtils.hasText(content)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; &lt;1&gt; 包含 DOCTYPE 为 DTD 模式</span><br><span class="line">            if (hasDoctype(content)) &#123;</span><br><span class="line">                isDtdValidated &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; &lt;2&gt;  hasOpeningTag 方法会校验，如果这一行有 &lt; ，并且 &lt; 后面跟着的是字母，则返回 true 。</span><br><span class="line">            if (hasOpeningTag(content)) &#123;</span><br><span class="line">                &#x2F;&#x2F; End of meaningful data...</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 返回 VALIDATION_DTD or VALIDATION_XSD 模式</span><br><span class="line">        return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);</span><br><span class="line">    &#125; catch (CharConversionException ex) &#123;</span><br><span class="line">           </span><br><span class="line">        &#x2F;&#x2F; &lt;3&gt; 返回 VALIDATION_AUTO 模式</span><br><span class="line">        &#x2F;&#x2F; Choked on some character encoding...</span><br><span class="line">        &#x2F;&#x2F; Leave the decision up to the caller.</span><br><span class="line">        return VALIDATION_AUTO;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;0</code>&gt; 处，从代码中看，主要是通过读取 XML 文件的内容，来进行自动判断。</p>
</li>
<li><p><code>&lt;1&gt;</code> 处，调用 <code>#hasDoctype(String content)</code> 方法，判断内容中如果包含有 <code>&quot;DOCTYPE</code>“ ，则为 DTD 验证模式。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The token in a XML document that declares the DTD to use for validation</span><br><span class="line"> * and thus that DTD validation is being used.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final String DOCTYPE &#x3D; &quot;DOCTYPE&quot;;</span><br><span class="line"></span><br><span class="line">private boolean hasDoctype(String content) &#123;</span><br><span class="line">	return content.contains(DOCTYPE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;2&gt;</code> 处，调用 <code>#hasOpeningTag(String content)</code> 方法，判断如果这一行包含 <code>&lt;</code> ，并且 <code>&lt;</code> 紧跟着的是字幕，则为 XSD 验证模式。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Does the supplied content contain an XML opening tag. If the parse state is currently</span><br><span class="line"> * in an XML comment then this method always returns false. It is expected that all comment</span><br><span class="line"> * tokens will have consumed for the supplied content before passing the remainder to this method.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private boolean hasOpeningTag(String content) &#123;</span><br><span class="line">	if (this.inComment) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	int openTagIndex &#x3D; content.indexOf(&#39;&lt;&#39;);</span><br><span class="line">	return (openTagIndex &gt; -1 &#x2F;&#x2F; &lt; 存在</span><br><span class="line">            &amp;&amp; (content.length() &gt; openTagIndex + 1) &#x2F;&#x2F; &lt; 后面还有内容</span><br><span class="line">            &amp;&amp; Character.isLetter(content.charAt(openTagIndex + 1))); &#x2F;&#x2F; &lt; 后面的内容是字幕</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;3&gt;</code> 处，如果发生 CharConversionException 异常，则为 <code>VALIDATION_AUTO</code> 模式。</p>
</li>
<li><p>关于 <code>#consumeCommentTokens(String content)</code> 方法，代码比较复杂。感兴趣的胖友可以看看。代码如下：</p>
</li>
</ul>
<h2 id="5-获取document对象"><a href="#5-获取document对象" class="headerlink" title="5.获取document对象"></a>5.获取document对象</h2><p>在 <code>XmlBeanDefinitionReader#doLoadDocument(InputSource inputSource, Resource resource)</code> 方法，中做了两件事情：</p>
<ul>
<li><p>调用#getValidationModeForResource(Resource resource)方法，获取指定资源（xml）的验证模式</p>
<ul>
<li>上篇博客，我们已经详细解析。</li>
</ul>
</li>
<li><p>调用DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)方法，获取 XML Document 实例。</p>
</li>
</ul>
<h3 id="1-DocumentLoader"><a href="#1-DocumentLoader" class="headerlink" title="1. DocumentLoader"></a>1. DocumentLoader</h3><p>获取 Document 的策略，由接口 <code>org.springframework.beans.factory.xml.DocumentLoader</code> 定义。代码如下：</p>
<blockquote>
<p>FROM 《Spring 源码深度解析》P16 页</p>
<p>定义从资源文件加载到转换为 Document 的功能。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface DocumentLoader &#123;</span><br><span class="line"></span><br><span class="line">	Document loadDocument(</span><br><span class="line">			InputSource inputSource, EntityResolver entityResolver,</span><br><span class="line">			ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</span><br><span class="line">			throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>inputSource</code> 方法参数，加载 Document 的 Resource 资源。</li>
<li><code>entityResolver</code> 方法参数，解析文件的解析器。</li>
<li><code>errorHandler</code> 方法参数，处理加载 Document 对象的过程的错误。</li>
<li><code>validationMode</code> 方法参数，验证模式。</li>
<li><code>namespaceAware</code> 方法参数，命名空间支持。如果要提供对 XML 名称空间的支持，则需要值为 <code>true</code> 。</li>
</ul>
<h4 id="1-1-DefaultDocumentLoader"><a href="#1-1-DefaultDocumentLoader" class="headerlink" title="1.1 DefaultDocumentLoader"></a>1.1 DefaultDocumentLoader</h4><p>该方法由 DocumentLoader 的默认实现类 <code>org.springframework.beans.factory.xml.DefaultDocumentLoader</code> 实现。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load the &#123;@link Document&#125; at the supplied &#123;@link InputSource&#125; using the standard JAXP-configured</span><br><span class="line"> * XML parser.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,</span><br><span class="line">		ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception &#123;</span><br><span class="line">	&#x2F;&#x2F; &lt;1&gt; 创建 DocumentBuilderFactory</span><br><span class="line">	DocumentBuilderFactory factory &#x3D; createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">	if (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; &lt;2&gt; 创建 DocumentBuilder</span><br><span class="line">	DocumentBuilder builder &#x3D; createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">	&#x2F;&#x2F; &lt;3&gt; 解析 XML InputSource 返回 Document 对象</span><br><span class="line">	return builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先，调用 #<code>createDocumentBuilderFactory(...)</code> 方法，创建 <code>javax.xml.parsers.DocumentBuilderFactory</code> 对象。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * JAXP attribute used to configure the schema language for validation.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final String SCHEMA_LANGUAGE_ATTRIBUTE &#x3D; &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;jaxp&#x2F;properties&#x2F;schemaLanguage&quot;;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * JAXP attribute value indicating the XSD schema language.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final String XSD_SCHEMA_LANGUAGE &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema&quot;;</span><br><span class="line">protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)</span><br><span class="line">        throws ParserConfigurationException &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建 DocumentBuilderFactory</span><br><span class="line">    DocumentBuilderFactory factory &#x3D; DocumentBuilderFactory.newInstance();</span><br><span class="line">    factory.setNamespaceAware(namespaceAware); &#x2F;&#x2F; 设置命名空间支持</span><br><span class="line">    if (validationMode !&#x3D; XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">        factory.setValidating(true); &#x2F;&#x2F; 开启校验</span><br><span class="line">        &#x2F;&#x2F; XSD 模式下，设置 factory 的属性</span><br><span class="line">        if (validationMode &#x3D;&#x3D; XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">            &#x2F;&#x2F; Enforce namespace aware for XSD...</span><br><span class="line">            factory.setNamespaceAware(true); &#x2F;&#x2F; XSD 模式下，强制设置命名空间支持</span><br><span class="line">            &#x2F;&#x2F; 设置 SCHEMA_LANGUAGE_ATTRIBUTE</span><br><span class="line">            try &#123;</span><br><span class="line">                factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">            &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">                ParserConfigurationException pcex &#x3D; new ParserConfigurationException(</span><br><span class="line">                        &quot;Unable to validate using XSD: Your JAXP provider [&quot; + factory +</span><br><span class="line">                        &quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot; +</span><br><span class="line">                        &quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;);</span><br><span class="line">                pcex.initCause(ex);</span><br><span class="line">                throw pcex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，调用 <code>#createDocumentBuilder(DocumentBuilderFactory factory, EntityResolver entityResolver,ErrorHandler errorHandler)</code> 方法，创建 <code>javax.xml.parsers.DocumentBuilder</code> 对象。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory,</span><br><span class="line">		@Nullable EntityResolver entityResolver, @Nullable ErrorHandler errorHandler)</span><br><span class="line">		throws ParserConfigurationException &#123;</span><br><span class="line">	&#x2F;&#x2F; 创建 DocumentBuilder 对象</span><br><span class="line">	DocumentBuilder docBuilder &#x3D; factory.newDocumentBuilder();</span><br><span class="line">	&#x2F;&#x2F; &lt;x&gt; 设置 EntityResolver 属性</span><br><span class="line">	if (entityResolver !&#x3D; null) &#123;</span><br><span class="line">		docBuilder.setEntityResolver(entityResolver);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 设置 ErrorHandler 属性</span><br><span class="line">	if (errorHandler !&#x3D; null) &#123;</span><br><span class="line">		docBuilder.setErrorHandler(errorHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	return docBuilder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>&lt;x&gt;</code> 处，设置 DocumentBuilder 的 <strong>EntityResolver</strong> 属性。关于它，在 <a href="http://svip.iocoder.cn/Spring/IoC-load-Document/#" target="_blank" rel="noopener">「2. EntityResolver」</a> 会详细解析。</li>
</ul>
</li>
<li><p>最后，调用 <code>DocumentBuilder#parse(InputSource)</code> 方法，解析 InputSource ，返回 Document 对象。</p>
</li>
</ul>
<h3 id="2-EntityResolver"><a href="#2-EntityResolver" class="headerlink" title="2. EntityResolver"></a>2. EntityResolver</h3><p>也就是说,对于解析一个xml,sax<br>首先会读取该xml文档上的声明,根据声明去寻找相应的dtd定义,以便对文档的进行验证,<br>默认的寻找规则,(即:通过网络,实现上就是声明DTD的地址URI地址来下载DTD声明),<br>并进行认证,下载的过程是一个漫长的过程,而且当网络不可用时,这里会报错,就是因为相应的dtd没找到,</p>
<p>通过 <code>DocumentLoader#loadDocument(...)</code> 方法来获取 Document 对象时，有一个方法参数 <code>entityResolver</code> 。该参数是通过 <code>XmlBeanDefinitionReader#getEntityResolver()</code> 方法来获取的。代码如下：</p>
<blockquote>
<p><code>#getEntityResolver()</code> 方法，返回指定的解析器，如果没有指定，则构造一个未指定的默认解析器。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; XmlBeanDefinitionReader.java</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * EntityResolver 解析器</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">private EntityResolver entityResolver;</span><br><span class="line"></span><br><span class="line">protected EntityResolver getEntityResolver() &#123;</span><br><span class="line">	if (this.entityResolver &#x3D;&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F; Determine default EntityResolver to use.</span><br><span class="line">		ResourceLoader resourceLoader &#x3D; getResourceLoader();</span><br><span class="line">		if (resourceLoader !&#x3D; null) &#123;</span><br><span class="line">			this.entityResolver &#x3D; new ResourceEntityResolver(resourceLoader);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			this.entityResolver &#x3D; new DelegatingEntityResolver(getBeanClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return this.entityResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 ResourceLoader 不为 <code>null</code>，则根据指定的 ResourceLoader 创建一个 ResourceEntityResolver 对象。</li>
<li>如果 ResourceLoader 为 <code>null</code> ，则创建 一个 DelegatingEntityResolver 对象。该 Resolver 委托给默认的 BeansDtdResolver 和 PluggableSchemaResolver 。</li>
</ul>
<h4 id="2-1-子类"><a href="#2-1-子类" class="headerlink" title="2.1 子类"></a>2.1 子类</h4><p>上面的方法，一共涉及<strong>四个</strong> EntityResolver 的子类：</p>
<ul>
<li><p><code>org.springframework.beans.factory.xm.BeansDtdResolver</code> ：实现 EntityResolver 接口，Spring Bean dtd 解码器，用来从 classpath 或者 jar 文件中加载 dtd 。部分代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static final String DTD_EXTENSION &#x3D; &quot;.dtd&quot;;</span><br><span class="line"></span><br><span class="line">private static final String DTD_NAME &#x3D; &quot;spring-beans&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>org.springframework.beans.factory.xml.PluggableSchemaResolver</code> ，实现 EntityResolver 接口，读取 classpath 下的所有 <code>&quot;META-INF/spring.schemas&quot;</code> 成一个 namespaceURI 与 Schema 文件地址的 map 。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The location of the file that defines schema mappings.</span><br><span class="line"> * Can be present in multiple JAR files.</span><br><span class="line"> *</span><br><span class="line"> * 默认 &#123;@link #schemaMappingsLocation&#125; 地址</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static final String DEFAULT_SCHEMA_MAPPINGS_LOCATION &#x3D; &quot;META-INF&#x2F;spring.schemas&quot;;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">private final ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Schema 文件地址</span><br><span class="line"> *&#x2F;</span><br><span class="line">private final String schemaMappingsLocation;</span><br><span class="line"></span><br><span class="line">&#x2F;** Stores the mapping of schema URL -&gt; local schema path. *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">private volatile Map&lt;String, String&gt; schemaMappings; &#x2F;&#x2F; namespaceURI 与 Schema 文件地址的映射集合</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>org.springframework.beans.factory.xml.DelegatingEntityResolver</code> ：实现 EntityResolver 接口，分别代理 dtd 的 BeansDtdResolver 和 xml schemas 的 PluggableSchemaResolver 。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Suffix for DTD files. *&#x2F;</span><br><span class="line">public static final String DTD_SUFFIX &#x3D; &quot;.dtd&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;** Suffix for schema definition files. *&#x2F;</span><br><span class="line">public static final String XSD_SUFFIX &#x3D; &quot;.xsd&quot;;</span><br><span class="line"></span><br><span class="line">private final EntityResolver dtdResolver;</span><br><span class="line"></span><br><span class="line">private final EntityResolver schemaResolver;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 默认</span><br><span class="line">public DelegatingEntityResolver(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">	this.dtdResolver &#x3D; new BeansDtdResolver();</span><br><span class="line">	this.schemaResolver &#x3D; new PluggableSchemaResolver(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自定义</span><br><span class="line">public DelegatingEntityResolver(EntityResolver dtdResolver, EntityResolver schemaResolver) &#123;</span><br><span class="line">	Assert.notNull(dtdResolver, &quot;&#39;dtdResolver&#39; is required&quot;);</span><br><span class="line">	Assert.notNull(schemaResolver, &quot;&#39;schemaResolver&#39; is required&quot;);</span><br><span class="line">	this.dtdResolver &#x3D; dtdResolver;</span><br><span class="line">	this.schemaResolver &#x3D; schemaResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>org.springframework.beans.factory.xml.ResourceEntityResolver</code> ：继承自 DelegatingEntityResolver 类，通过 ResourceLoader 来解析实体的引用。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">public ResourceEntityResolver(ResourceLoader resourceLoader) &#123;</span><br><span class="line">	super(resourceLoader.getClassLoader());</span><br><span class="line">	this.resourceLoader &#x3D; resourceLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-2-作用"><a href="#2-2-作用" class="headerlink" title="2.2 作用"></a>2.2 作用</h4><blockquote>
<p>EntityResolver 的作用就是，通过实现它，应用可以自定义如何<strong>寻找</strong>【验证文件】的逻辑。</p>
</blockquote>
<hr>
<blockquote>
<p>FROM 《Spring 源码深度解析》</p>
<p>在 loadDocument 方法中涉及一个参数 EntityResolver ，何为EntityResolver？官网这样解释：如果 SAX 应用程序需要实现自定义处理外部实体，则必须实现此接口并使用 setEntityResolver 方法向SAX 驱动器注册一个实例。也就是说，对于解析一个XML，SAX 首先读取该 XML 文档上的声明，根据声明去寻找相应的 DTD 定义，以便对文档进行一个验证。默认的寻找规则，即通过网络（实现上就是声明的DTD的URI地址）来下载相应的DTD声明，并进行认证。下载的过程是一个漫长的过程，而且当网络中断或不可用时，这里会报错，就是因为相应的DTD声明没有被找到的原因。</p>
<p>EntityResolver 的作用是项目本身就可以提供一个如何寻找 DTD 声明的方法，即由程序来实现寻找 DTD 声明的过程，比如我们将 DTD 文件放到项目中某处，在实现时直接将此文档读取并返回给 SAX 即可。这样就避免了通过网络来寻找相应的声明。</p>
</blockquote>
<p><code>org.xml.sax.EntityResolver</code> 接口，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface EntityResolver &#123;</span><br><span class="line"></span><br><span class="line">    public abstract InputSource resolveEntity (String publicId, String systemId)</span><br><span class="line">        throws SAXException, IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口方法接收两个参数 <code>publicId</code> 和 <code>systemId</code> ，并返回 InputSource 对象。两个参数声明如下：</p>
<ul>
<li><code>publicId</code> ：被引用的外部实体的公共标识符，如果没有提供，则返回 <code>null</code> 。</li>
<li><code>systemId</code> ：被引用的外部实体的系统标识符。</li>
</ul>
<p>这两个参数的实际内容和具体的验证模式的关系如下：</p>
<ul>
<li>XSD 验证模式<ul>
<li>publicId：null</li>
<li>systemId：<a href="http://www.springframework.org/schema/beans/spring-beans.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/beans/spring-beans.xsd</a></li>
<li><a href="http://static.iocoder.cn/08e5f8a505505def17e84becd4f0dbf9" target="_blank" rel="noopener"><img src="http://static.iocoder.cn/08e5f8a505505def17e84becd4f0dbf9" alt="XSD 验证模式"></a>XSD 验证模式</li>
</ul>
</li>
<li>DTD 验证模式<ul>
<li>publicId：-//SPRING//DTD BEAN 2.0//EN</li>
<li>systemId：<a href="http://www.springframework.org/dtd/spring-beans.dtd" target="_blank" rel="noopener">http://www.springframework.org/dtd/spring-beans.dtd</a></li>
<li><a href="http://static.iocoder.cn/8f77d23019c10f4ac026968ce19067ef" target="_blank" rel="noopener"><img src="http://static.iocoder.cn/8f77d23019c10f4ac026968ce19067ef" alt="DTD 验证模式"></a>DTD 验证模式</li>
</ul>
</li>
</ul>
<h4 id="2-3-DelegatingEntityResolver"><a href="#2-3-DelegatingEntityResolver" class="headerlink" title="2.3 DelegatingEntityResolver"></a>2.3 DelegatingEntityResolver</h4><p>我们知道在 Spring 中使用 DelegatingEntityResolver 为 EntityResolver 的实现类。<code>#resolveEntity(String publicId, String systemId)</code> 方法，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public InputSource resolveEntity(String publicId, @Nullable String systemId) throws SAXException, IOException &#123;</span><br><span class="line">	if (systemId !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F; DTD 模式</span><br><span class="line">		if (systemId.endsWith(DTD_SUFFIX)) &#123;</span><br><span class="line">			return this.dtdResolver.resolveEntity(publicId, systemId);</span><br><span class="line">		&#x2F;&#x2F; XSD 模式</span><br><span class="line">		&#125; else if (systemId.endsWith(XSD_SUFFIX)) &#123;</span><br><span class="line">			return this.schemaResolver.resolveEntity(publicId, systemId);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是 DTD 验证模式，则使用 BeansDtdResolver 来进行解析</li>
<li>如果是 XSD 验证模式，则使用 PluggableSchemaResolver 来进行解析。</li>
</ul>
<h4 id="2-4-BeansDtdResolver"><a href="#2-4-BeansDtdResolver" class="headerlink" title="2.4 BeansDtdResolver"></a>2.4 BeansDtdResolver</h4><p>BeansDtdResolver 的解析过程，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * DTD 文件的后缀</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final String DTD_EXTENSION &#x3D; &quot;.dtd&quot;;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Spring Bean DTD 的文件名</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final String DTD_NAME &#x3D; &quot;spring-beans&quot;;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public InputSource resolveEntity(String publicId, @Nullable String systemId) throws IOException &#123;</span><br><span class="line">    if (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(&quot;Trying to resolve XML entity with public ID [&quot; + publicId +</span><br><span class="line">                &quot;] and system ID [&quot; + systemId + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 必须以 .dtd 结尾</span><br><span class="line">    if (systemId !&#x3D; null &amp;&amp; systemId.endsWith(DTD_EXTENSION)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取最后一个 &#x2F; 的位置</span><br><span class="line">        int lastPathSeparator &#x3D; systemId.lastIndexOf(&#39;&#x2F;&#39;);</span><br><span class="line">        &#x2F;&#x2F; 获取 spring-beans 的位置</span><br><span class="line">        int dtdNameStart &#x3D; systemId.indexOf(DTD_NAME, lastPathSeparator);</span><br><span class="line">        if (dtdNameStart !&#x3D; -1) &#123; &#x2F;&#x2F; 找到</span><br><span class="line">            String dtdFile &#x3D; DTD_NAME + DTD_EXTENSION;</span><br><span class="line">            if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(&quot;Trying to locate [&quot; + dtdFile + &quot;] in Spring jar on classpath&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 创建 ClassPathResource 对象</span><br><span class="line">                Resource resource &#x3D; new ClassPathResource(dtdFile, getClass());</span><br><span class="line">                &#x2F;&#x2F; 创建 InputSource 对象，并设置 publicId、systemId 属性</span><br><span class="line">                InputSource source &#x3D; new InputSource(resource.getInputStream());</span><br><span class="line">                source.setPublicId(publicId);</span><br><span class="line">                source.setSystemId(systemId);</span><br><span class="line">                if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(&quot;Found beans DTD [&quot; + systemId + &quot;] in classpath: &quot; + dtdFile);</span><br><span class="line">                &#125;</span><br><span class="line">                return source;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IOException ex) &#123;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Could not resolve beans DTD [&quot; + systemId + &quot;]: not found in classpath&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用默认行为，从网络上下载</span><br><span class="line">    &#x2F;&#x2F; Use the default behavior -&gt; download from website or wherever.</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以看到，加载 DTD 类型的 <code>BeansDtdResolver#resolveEntity(...)</code> 过程，只是对 <code>systemId</code> 进行了简单的校验（从最后一个 / 开始，内容中是否包含 <code>spring-beans</code>），然后构造一个 InputSource 对象，并设置 <code>publicId</code>、<code>systemId</code> 属性，然后返回。</p>
<h4 id="2-5-PluggableSchemaResolver"><a href="#2-5-PluggableSchemaResolver" class="headerlink" title="2.5 PluggableSchemaResolver"></a>2.5 PluggableSchemaResolver</h4><p>PluggableSchemaResolver 的解析过程，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">private final ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Schema 文件地址</span><br><span class="line"> *&#x2F;</span><br><span class="line">private final String schemaMappingsLocation;</span><br><span class="line"></span><br><span class="line">&#x2F;** Stores the mapping of schema URL -&gt; local schema path. *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">private volatile Map&lt;String, String&gt; schemaMappings; &#x2F;&#x2F; namespaceURI 与 Schema 文件地址的映射集合</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public InputSource resolveEntity(String publicId, @Nullable String systemId) throws IOException &#123;</span><br><span class="line">    if (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(&quot;Trying to resolve XML entity with public id [&quot; + publicId +</span><br><span class="line">                &quot;] and system id [&quot; + systemId + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (systemId !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获得 Resource 所在位置</span><br><span class="line">        String resourceLocation &#x3D; getSchemaMappings().get(systemId);</span><br><span class="line">        if (resourceLocation !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建 ClassPathResource</span><br><span class="line">            Resource resource &#x3D; new ClassPathResource(resourceLocation, this.classLoader);</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 创建 InputSource 对象，并设置 publicId、systemId 属性</span><br><span class="line">                InputSource source &#x3D; new InputSource(resource.getInputStream());</span><br><span class="line">                source.setPublicId(publicId);</span><br><span class="line">                source.setSystemId(systemId);</span><br><span class="line">                if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(&quot;Found XML schema [&quot; + systemId + &quot;] in classpath: &quot; + resourceLocation);</span><br><span class="line">                &#125;</span><br><span class="line">                return source;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (FileNotFoundException ex) &#123;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Could not find XML schema [&quot; + systemId + &quot;]: &quot; + resource, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先调用 <code>#getSchemaMappings()</code> 方法，获取一个映射表(systemId 与其在本地的对照关系)。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, String&gt; getSchemaMappings() &#123;</span><br><span class="line">    Map&lt;String, String&gt; schemaMappings &#x3D; this.schemaMappings;</span><br><span class="line">    &#x2F;&#x2F; 双重检查锁，实现 schemaMappings 单例</span><br><span class="line">    if (schemaMappings &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            schemaMappings &#x3D; this.schemaMappings;</span><br><span class="line">            if (schemaMappings &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(&quot;Loading schema mappings from [&quot; + this.schemaMappingsLocation + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 以 Properties 的方式，读取 schemaMappingsLocation</span><br><span class="line">                    Properties mappings &#x3D; PropertiesLoaderUtils.loadAllProperties(this.schemaMappingsLocation, this.classLoader);</span><br><span class="line">                    if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(&quot;Loaded schema mappings: &quot; + mappings);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 将 mappings 初始化到 schemaMappings 中</span><br><span class="line">                    schemaMappings &#x3D; new ConcurrentHashMap&lt;&gt;(mappings.size());</span><br><span class="line">                    CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);</span><br><span class="line">                    this.schemaMappings &#x3D; schemaMappings;</span><br><span class="line">                &#125; catch (IOException ex) &#123;</span><br><span class="line">                    throw new IllegalStateException(</span><br><span class="line">                            &quot;Unable to load schema mappings from location [&quot; + this.schemaMappingsLocation + &quot;]&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return schemaMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>映射表如下（<strong>部分</strong>）:<a href="http://static.iocoder.cn/4dba22abb6ce4bc1a7721afb2cb53567" target="_blank" rel="noopener"><img src="http://static.iocoder.cn/4dba22abb6ce4bc1a7721afb2cb53567" alt="映射表"></a>映射表</li>
</ul>
</li>
<li><p>然后，根据传入的 <code>systemId</code> 获取该 <code>systemId</code> 在本地的路径 <code>resourceLocation</code> 。</p>
</li>
<li><p>最后，根据 <code>resourceLocation</code> ，构造 InputSource 对象。</p>
</li>
</ul>
<h4 id="2-6-ResourceEntityResolver"><a href="#2-6-ResourceEntityResolver" class="headerlink" title="2.6 ResourceEntityResolver"></a>2.6 ResourceEntityResolver</h4><p>ResourceEntityResolver 的解析过程，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private final ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public InputSource resolveEntity(String publicId, @Nullable String systemId) throws SAXException, IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用父类的方法，进行解析</span><br><span class="line">    InputSource source &#x3D; super.resolveEntity(publicId, systemId);</span><br><span class="line">    &#x2F;&#x2F; 解析失败，resourceLoader 进行解析</span><br><span class="line">    if (source &#x3D;&#x3D; null &amp;&amp; systemId !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获得 resourcePath ，即 Resource 资源地址</span><br><span class="line">        String resourcePath &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String decodedSystemId &#x3D; URLDecoder.decode(systemId, &quot;UTF-8&quot;); &#x2F;&#x2F; 使用 UTF-8 ，解码 systemId</span><br><span class="line">            String givenUrl &#x3D; new URL(decodedSystemId).toString(); &#x2F;&#x2F; 转换成 URL 字符串</span><br><span class="line">            &#x2F;&#x2F; 解析文件资源的相对路径（相对于系统根路径）</span><br><span class="line">            String systemRootUrl &#x3D; new File(&quot;&quot;).toURI().toURL().toString();</span><br><span class="line">            &#x2F;&#x2F; Try relative to resource base if currently in system root.</span><br><span class="line">            if (givenUrl.startsWith(systemRootUrl)) &#123;</span><br><span class="line">                resourcePath &#x3D; givenUrl.substring(systemRootUrl.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            &#x2F;&#x2F; Typically a MalformedURLException or AccessControlException.</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] against system root URL&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; No URL (or no resolvable URL) -&gt; try relative to resource base.</span><br><span class="line">            resourcePath &#x3D; systemId;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resourcePath !&#x3D; null) &#123;</span><br><span class="line">            if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(&quot;Trying to locate XML entity [&quot; + systemId + &quot;] as resource [&quot; + resourcePath + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 获得 Resource 资源</span><br><span class="line">            Resource resource &#x3D; this.resourceLoader.getResource(resourcePath);</span><br><span class="line">            &#x2F;&#x2F; 创建 InputSource 对象</span><br><span class="line">            source &#x3D; new InputSource(resource.getInputStream());</span><br><span class="line">            &#x2F;&#x2F; 设置 publicId 和 systemId 属性</span><br><span class="line">            source.setPublicId(publicId);</span><br><span class="line">            source.setSystemId(systemId);</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Found XML entity [&quot; + systemId + &quot;]: &quot; + resource);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，调用<strong>父类</strong>的方法，进行解析。</li>
<li>如果失败，使用 <code>resourceLoader</code> ，尝试读取 <code>systemId</code> 对应的 Resource 资源。</li>
</ul>
<h4 id="2-7-自定义-EntityResolver"><a href="#2-7-自定义-EntityResolver" class="headerlink" title="2.7 自定义 EntityResolver"></a>2.7 自定义 EntityResolver</h4><blockquote>
<p>老艿艿：本小节，为<strong>选读</strong>内容。</p>
</blockquote>
<p><code>#getEntityResolver()</code> 方法返回 EntityResolver 对象。那么怎么进行自定义 EntityResolver 呢?</p>
<blockquote>
<p>If a SAX application needs to implement customized handling for external entities, it must implement this interface and register an instance with the SAX driver using the setEntityResolver method.</p>
<p>就是说：如果 SAX 应用程序需要实现自定义处理外部实体，则必须实现此接口，并使用 <code>#setEntityResolver(EntityResolver entityResolver)</code> 方法，向 SAX 驱动器注册一个 EntityResolver 实例。</p>
</blockquote>
<p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyResolver implements EntityResolver &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public InputSource resolveEntity(String publicId, String systemId) &#123;</span><br><span class="line">        if (systemId.equals(&quot;http:&#x2F;&#x2F;www.myhost.com&#x2F;today&quot;)) &#123;</span><br><span class="line">            MyReader reader &#x3D; new MyReader();</span><br><span class="line">            return new InputSource(reader);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; use the default behaviour</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先将 <code>&quot;spring-student.xml&quot;</code> 文件中的 XSD 声明的地址改掉，如下：</p>
<p><a href="http://static.iocoder.cn/882e730ac463e3007c5f3c5cde8380bc" target="_blank" rel="noopener"><img src="http://static.iocoder.cn/882e730ac463e3007c5f3c5cde8380bc" alt="spring-student.xml"></a>spring-student.xml</p>
<p>如果我们再次运行，则会报如下错误：</p>
<p><a href="http://static.iocoder.cn/741da1d13906154d36f02fa5113432fd" target="_blank" rel="noopener"><img src="http://static.iocoder.cn/741da1d13906154d36f02fa5113432fd" alt="报错"></a>报错</p>
<p>从上面的错误可以看到，是在进行文档验证时，无法根据声明找到 XSD 验证文件而导致无法进行 XML 文件验证。在 <a href="http://svip.iocoder.cn/Spring/IoC-Validation-Mode-For-Resource" target="_blank" rel="noopener">《【死磕 Spring】—— IoC 之获取验证模型》</a> 中讲到，如果要解析一个 XML 文件，SAX 首先会读取该 XML 文档上的声明，然后根据声明去寻找相应的 DTD 定义，以便对文档进行验证。<strong>默认的加载规则是通过网络方式下载验证文件</strong>，而在实际生产环境中我们会遇到网络中断或者不可用状态，那么就应用就会因为无法下载验证文件而报错。</p>
<h2 id="6-注册-BeanDefinitions"><a href="#6-注册-BeanDefinitions" class="headerlink" title="6.注册 BeanDefinitions"></a>6.注册 BeanDefinitions</h2><p>获取 XML Document 对象后，会根据该对象和 Resource 资源对象调用 <code>XmlBeanDefinitionReader#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，开始注册 BeanDefinitions 之旅。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; AbstractBeanDefinitionReader.java</span><br><span class="line">private final BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; XmlBeanDefinitionReader.java</span><br><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	&#x2F;&#x2F; &lt;1&gt; 创建 BeanDefinitionDocumentReader 对象</span><br><span class="line">	BeanDefinitionDocumentReader documentReader &#x3D; createBeanDefinitionDocumentReader();</span><br><span class="line">	&#x2F;&#x2F; &lt;2&gt; 获取已注册的 BeanDefinition 数量</span><br><span class="line">	int countBefore &#x3D; getRegistry().getBeanDefinitionCount();</span><br><span class="line">	&#x2F;&#x2F; &lt;3&gt; 创建 XmlReaderContext 对象</span><br><span class="line">	&#x2F;&#x2F; &lt;4&gt; 注册 BeanDefinition</span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	&#x2F;&#x2F; 计算新注册的 BeanDefinition 数量</span><br><span class="line">	return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1&gt;</code> 处，调用 <code>#createBeanDefinitionDocumentReader()</code> 方法，实例化 BeanDefinitionDocumentReader 对象。</li>
</ul>
<blockquote>
<p>FROM 《Spring 源码深度解析》P16 页</p>
<p>定义读取 Document 并注册 BeanDefinition 功能</p>
</blockquote>
<ul>
<li><code>&lt;2&gt;</code> 处，调用 <code>BeanDefinitionRegistry#getBeanDefinitionCount()</code> 方法，获取<strong>已注册</strong>的 BeanDefinition 数量。</li>
<li><code>&lt;3&gt;</code> 处，调用 <code>#createReaderContext(Resource resource)</code> 方法，创建 XmlReaderContext 对象。</li>
<li><code>&lt;4&gt;</code> 处，调用 <code>BeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code> 方法，读取 XML 元素，注册 BeanDefinition 们。</li>
<li><code>&lt;5&gt;</code> 处，计<strong>算新注册</strong>的 BeanDefinition 数量。</li>
</ul>
<h3 id="1-createBeanDefinitionDocumentReader"><a href="#1-createBeanDefinitionDocumentReader" class="headerlink" title="1. createBeanDefinitionDocumentReader"></a>1. createBeanDefinitionDocumentReader</h3><p><code>#createBeanDefinitionDocumentReader()</code>，实例化 BeanDefinitionDocumentReader 对象。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * documentReader 的类</span><br><span class="line"> *</span><br><span class="line"> * @see #createBeanDefinitionDocumentReader() </span><br><span class="line"> *&#x2F;</span><br><span class="line">private Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass &#x3D; DefaultBeanDefinitionDocumentReader.class;</span><br><span class="line"></span><br><span class="line">protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() &#123;</span><br><span class="line">	return BeanUtils.instantiateClass(this.documentReaderClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>documentReaderClass</code> 的默认值为 <code>DefaultBeanDefinitionDocumentReader.class</code> 。关于它，我们在后续的文章，详细解析。</li>
</ul>
<h3 id="2-registerBeanDefinitions"><a href="#2-registerBeanDefinitions" class="headerlink" title="2. registerBeanDefinitions"></a>2. registerBeanDefinitions</h3><p><code>BeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code> 方法，注册 BeanDefinition ，在接口 BeanDefinitionDocumentReader 中定义。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinitionDocumentReader &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Read bean definitions from the given DOM document and</span><br><span class="line">	 * register them with the registry in the given reader context.</span><br><span class="line">	 * @param doc the DOM document</span><br><span class="line">	 * @param readerContext the current context of the reader</span><br><span class="line">	 * (includes the target registry and the resource being parsed)</span><br><span class="line">	 * @throws BeanDefinitionStoreException in case of parsing errors</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</span><br><span class="line">			throws BeanDefinitionStoreException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从给定的 Document 对象中解析定义的 BeanDefinition 并将他们注册到注册表中</strong>。方法接收两个参数：</p>
<ul>
<li><code>doc</code> 方法参数：待解析的 Document 对象。</li>
<li><code>readerContext</code> 方法，解析器的当前上下文，包括目标注册表和被解析的资源。它是根据 Resource 来创建的，见 <a href="http://svip.iocoder.cn/Spring/IoC-register-BeanDefinitions/#" target="_blank" rel="noopener">「3. createReaderContext」</a> 。</li>
</ul>
<h4 id="2-1-DefaultBeanDefinitionDocumentReader"><a href="#2-1-DefaultBeanDefinitionDocumentReader" class="headerlink" title="2.1 DefaultBeanDefinitionDocumentReader"></a>2.1 DefaultBeanDefinitionDocumentReader</h4><p>BeanDefinitionDocumentReader 有且只有一个默认实现类 DefaultBeanDefinitionDocumentReader 。它对 <code>#registerBeanDefinitions(...)</code> 方法的实现代码如下：</p>
<p>DefaultBeanDefinitionDocumentReader 对该方法提供了实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">private XmlReaderContext readerContext;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">private BeanDefinitionParserDelegate delegate;</span><br><span class="line">    </span><br><span class="line">&#x2F;**</span><br><span class="line"> * This implementation parses bean definitions according to the &quot;spring-beans&quot; XSD</span><br><span class="line"> * (or DTD, historically).</span><br><span class="line"> * &lt;p&gt;Opens a DOM Document; then initializes the default settings</span><br><span class="line"> * specified at the &#123;@code &lt;beans&#x2F;&gt;&#125; level; then parses the contained bean definitions.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class="line">    this.readerContext &#x3D; readerContext;</span><br><span class="line">    &#x2F;&#x2F; 获得 XML Document Root Element</span><br><span class="line">    &#x2F;&#x2F; 执行注册 BeanDefinition</span><br><span class="line">    doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Register each bean definition within the given root &#123;@code &lt;beans&#x2F;&gt;&#125; element.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)  &#x2F;&#x2F; for Environment.acceptsProfiles(String...)</span><br><span class="line">protected void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class="line">    &#x2F;&#x2F; Any nested &lt;beans&gt; elements will cause recursion in this method. In</span><br><span class="line">    &#x2F;&#x2F; order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span><br><span class="line">    &#x2F;&#x2F; keep track of the current (parent) delegate, which may be null. Create</span><br><span class="line">    &#x2F;&#x2F; the new (child) delegate with a reference to the parent for fallback purposes,</span><br><span class="line">    &#x2F;&#x2F; then ultimately reset this.delegate back to its original (parent) reference.</span><br><span class="line">    &#x2F;&#x2F; this behavior emulates a stack of delegates without actually necessitating one.</span><br><span class="line">    &#x2F;&#x2F; 记录老的 BeanDefinitionParserDelegate 对象</span><br><span class="line">    BeanDefinitionParserDelegate parent &#x3D; this.delegate;</span><br><span class="line">    &#x2F;&#x2F; &lt;1&gt; 创建 BeanDefinitionParserDelegate 对象，并进行设置到 delegate</span><br><span class="line">    this.delegate &#x3D; createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    &#x2F;&#x2F; &lt;2&gt; 检查 &lt;beans &#x2F;&gt; 根标签的命名空间是否为空，或者是 http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    if (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        &#x2F;&#x2F; &lt;2.1&gt; 处理 profile 属性。可参见《Spring3自定义环境配置 &lt;beans profile&#x3D;&quot;&quot;&gt;》http:&#x2F;&#x2F;nassir.iteye.com&#x2F;blog&#x2F;1535799</span><br><span class="line">        String profileSpec &#x3D; root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        if (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            &#x2F;&#x2F; &lt;2.2&gt; 使用分隔符切分，可能有多个 profile 。</span><br><span class="line">            String[] specifiedProfiles &#x3D; StringUtils.tokenizeToStringArray(</span><br><span class="line">                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            &#x2F;&#x2F; &lt;2.3&gt; 如果所有 profile 都无效，则不进行注册</span><br><span class="line">            &#x2F;&#x2F; We cannot use Profiles.of(...) since profile expressions are not supported</span><br><span class="line">            &#x2F;&#x2F; in XML config. See SPR-12458 for details.</span><br><span class="line">            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +</span><br><span class="line">                            &quot;] not matching: &quot; + getReaderContext().getResource());</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &lt;3&gt; 解析前处理</span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    &#x2F;&#x2F; &lt;4&gt; 解析</span><br><span class="line">    parseBeanDefinitions(root, this.delegate);</span><br><span class="line">    &#x2F;&#x2F; &lt;5&gt; 解析后处理</span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置 delegate 回老的 BeanDefinitionParserDelegate 对象</span><br><span class="line">    this.delegate &#x3D; parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;1&gt;</code> 处，创建 BeanDefinitionParserDelegate 对象，并进行设置到 <code>delegate</code> 。BeanDefinitionParserDelegate 是一个重要的类，它负责<strong>解析 BeanDefinition</strong>。代码如下：</p>
<blockquote>
<p>FROM 《Spring 源码深度解析》P16</p>
<p>定义解析 XML Element 的各种方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected BeanDefinitionParserDelegate createDelegate(</span><br><span class="line">        XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建 BeanDefinitionParserDelegate 对象</span><br><span class="line">    BeanDefinitionParserDelegate delegate &#x3D; new BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">    &#x2F;&#x2F; 初始化默认</span><br><span class="line">    delegate.initDefaults(root, parentDelegate);</span><br><span class="line">    return delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;2&gt;</code> 处，检查 <code>&lt;beans /&gt;</code> <strong>根</strong>标签的命名空间是否为空，或者是 <a href="http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a> 。</p>
<ul>
<li><code>&lt;2.1&gt;</code> 处，判断是否 <code>&lt;beans /&gt;</code> 上配置了 <code>profile</code> 属性。不了解这块的胖友，可以看下 <a href="http://nassir.iteye.com/blog/1535799" target="_blank" rel="noopener">《《Spring3自定义环境配置 》》</a> 。</li>
<li><code>&lt;2.2&gt;</code> 处，使用分隔符切分，可能有<strong>多个</strong> profile 。</li>
<li><code>&lt;2.3&gt;</code> 处，判断，如果所有 profile 都无效，则 <code>return</code> 不进行注册。</li>
</ul>
</li>
<li><p><code>&lt;4&gt;</code> 处，调用 <code>#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code> 方法，进行解析逻辑。详细解析，见 <a href="http://svip.iocoder.cn/Spring/IoC-register-BeanDefinitions/#" target="_blank" rel="noopener">「3.1 parseBeanDefinitions」</a> 。</p>
</li>
<li><p><code>&lt;3&gt;</code> / <code>&lt;5&gt;</code> 处，解析<strong>前后</strong>的处理，目前这两个方法都是空实现，交由子类来实现。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void preProcessXml(Element root) &#123;&#125;</span><br><span class="line"></span><br><span class="line">protected void postProcessXml(Element root) &#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2-1-1-parseBeanDefinitions"><a href="#2-1-1-parseBeanDefinitions" class="headerlink" title="2.1.1 parseBeanDefinitions"></a>2.1.1 parseBeanDefinitions</h5><p><code>#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code> 方法，进行解析逻辑。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Parse the elements at the root level in the document:</span><br><span class="line"> * &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;.</span><br><span class="line"> * @param root the DOM root element of the document</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">    &#x2F;&#x2F; &lt;1&gt; 如果根节点使用默认命名空间，执行默认解析</span><br><span class="line">    if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 遍历子节点</span><br><span class="line">        NodeList nl &#x3D; root.getChildNodes();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node &#x3D; nl.item(i);</span><br><span class="line">            if (node instanceof Element) &#123;</span><br><span class="line">                Element ele &#x3D; (Element) node;</span><br><span class="line">                &#x2F;&#x2F; &lt;1&gt; 如果该节点使用默认命名空间，执行默认解析</span><br><span class="line">                if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#x2F;&#x2F; 如果该节点非默认命名空间，执行自定义解析</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#x2F;&#x2F; &lt;2&gt; 如果根节点非默认命名空间，执行自定义解析</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Spring 有</p>
<p>两种</p>
</li>
</ul>
<p>  Bean 声明方式：</p>
<ul>
<li>配置文件式声明：<code>&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.StudentService&quot; /&gt;</code> 。对应 <code>&lt;1&gt;</code> 处。</li>
<li>自定义注解方式：<code>&lt;tx:annotation-driven&gt;</code> 。对应 <code>&lt;2&gt;</code> 处。</li>
</ul>
<ul>
<li><p><code>&lt;1&gt;</code> 处，如果<strong>根</strong>节点或<strong>子</strong>节点<strong>使用</strong>默认命名空间，调用 <code>#parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)</code> 方法，执行默认解析。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; &#x2F;&#x2F; import</span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; &#x2F;&#x2F; alias</span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; &#x2F;&#x2F; bean</span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; &#x2F;&#x2F; beans</span><br><span class="line">		&#x2F;&#x2F; recurse</span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>详细的解析，见后续文章。</li>
</ul>
</li>
<li><p><code>&lt;2&gt;</code> 处，如果<strong>根</strong>节点或<strong>子</strong>节点<strong>不使用</strong>默认命名空间，调用 <code>BeanDefinitionParserDelegate#parseCustomElement(Element ele)</code> 方法，执行<strong>自定义</strong>解析。详细的解析，见后续文章。</p>
</li>
</ul>
<h3 id="3-createReaderContext"><a href="#3-createReaderContext" class="headerlink" title="3. createReaderContext"></a>3. createReaderContext</h3><p><code>#createReaderContext(Resource resource)</code> 方法，创建 XmlReaderContext 对象。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private ProblemReporter problemReporter &#x3D; new FailFastProblemReporter();</span><br><span class="line"></span><br><span class="line">private ReaderEventListener eventListener &#x3D; new EmptyReaderEventListener();</span><br><span class="line"></span><br><span class="line">private SourceExtractor sourceExtractor &#x3D; new NullSourceExtractor();</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">private NamespaceHandlerResolver namespaceHandlerResolver;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Create the &#123;@link XmlReaderContext&#125; to pass over to the document reader.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public XmlReaderContext createReaderContext(Resource resource) &#123;</span><br><span class="line">	return new XmlReaderContext(resource, this.problemReporter, this.eventListener,</span><br><span class="line">			this.sourceExtractor, this, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 XmlReaderContext 的详细解析，见后续文章。</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>至此，<code>XmlBeanDefinitionReader#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法中，做的三件事情已经全部分析完毕，下面将对 <strong>BeanDefinition 的解析过程</strong>做详细分析说明。</p>
<p>另外，<code>XmlBeanDefinitionReader#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法，整体时序图如下：</p>
<p><img src="/2021/03/10/IOC%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220716173642850.png" alt="image-20220716173642850"></p>
<h2 id="7-解析-import-标签"><a href="#7-解析-import-标签" class="headerlink" title="7.解析 import 标签"></a>7.解析 import 标签</h2><p>在博客 <a href="http://svip.iocoder.cn/Spring/IoC-register-BeanDefinitions" target="_blank" rel="noopener">【死磕 Spring】—— IoC 之注册 BeanDefinitions</a> 中分析到，Spring 中有两种解析 Bean 的方式：</p>
<ul>
<li>如果根节点或者子节点采用默认命名空间的话，则调用 <code>#parseDefaultElement(...)</code> 方法，进行<strong>默认</strong>标签解析</li>
<li>否则，调用 <code>BeanDefinitionParserDelegate#parseCustomElement(...)</code> 方法，进行<strong>自定义</strong>解析。</li>
</ul>
<p>所以，以下博客就这两个方法进行详细分析说明。而本文，先从<strong>默认标签</strong>解析过程开始。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; DefaultBeanDefinitionDocumentReader.java</span><br><span class="line"></span><br><span class="line">public static final String IMPORT_ELEMENT &#x3D; &quot;import&quot;;</span><br><span class="line">public static final String ALIAS_ATTRIBUTE &#x3D; &quot;alias&quot;;</span><br><span class="line">public static final String BEAN_ELEMENT &#x3D; BeanDefinitionParserDelegate.BEAN_ELEMENT;</span><br><span class="line">public static final String NESTED_BEANS_ELEMENT &#x3D; &quot;beans&quot;;</span><br><span class="line"></span><br><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; &#x2F;&#x2F; import</span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; &#x2F;&#x2F; alias</span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; &#x2F;&#x2F; bean</span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; &#x2F;&#x2F; beans</span><br><span class="line">		&#x2F;&#x2F; recurse</span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的功能一目了然，分别是对四种不同的标签进行解析，分别是 <code>import</code>、<code>alias</code>、<code>bean</code>、<code>beans</code> 。咱门从第一个标签 <code>import</code> 开始。</p>
<h3 id="1-import-示例"><a href="#1-import-示例" class="headerlink" title="1. import 示例"></a>1. import 示例</h3><p>经历过 Spring 配置文件的小伙伴都知道，如果工程比较大，配置文件的维护会让人觉得恐怖，文件太多了，想象将所有的配置都放在一个 <code>spring.xml</code> 配置文件中，哪种后怕感是不是很明显？</p>
<p>所有针对这种情况 Spring 提供了一个分模块的思路，利用 <code>import</code> 标签，例如我们可以构造一个这样的 <code>spring.xml</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;import resource&#x3D;&quot;spring-student.xml&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;import resource&#x3D;&quot;spring-student-dtd.xml&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p><code>spring.xml</code> 配置文件中，使用 <code>import</code> 标签的方式导入其他模块的配置文件。</p>
<ul>
<li>如果有配置需要修改直接修改相应配置文件即可。</li>
<li>若有新的模块需要引入直接增加 <code>import</code> 即可。</li>
</ul>
<p>这样大大简化了配置后期维护的复杂度，同时也易于管理。</p>
<h3 id="2-importBeanDefinitionResource"><a href="#2-importBeanDefinitionResource" class="headerlink" title="2. importBeanDefinitionResource"></a>2. importBeanDefinitionResource</h3><p>Spring 使用 <code>#importBeanDefinitionResource(Element ele)</code> 方法，完成对 <code>import</code> 标签的解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; DefaultBeanDefinitionDocumentReader.java</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Parse an &quot;import&quot; element and load the bean definitions</span><br><span class="line"> * from the given resource into the bean factory.</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void importBeanDefinitionResource(Element ele) &#123;</span><br><span class="line">    &#x2F;&#x2F; &lt;1&gt; 获取 resource 的属性值</span><br><span class="line">    String location &#x3D; ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">    &#x2F;&#x2F; 为空，直接退出</span><br><span class="line">    if (!StringUtils.hasText(location)) &#123;</span><br><span class="line">        getReaderContext().error(&quot;Resource location must not be empty&quot;, ele); &#x2F;&#x2F; 使用 problemReporter 报错</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &lt;2&gt; 解析系统属性，格式如 ：&quot;$&#123;user.dir&#125;&quot;</span><br><span class="line">    &#x2F;&#x2F; Resolve system properties: e.g. &quot;$&#123;user.dir&#125;&quot;</span><br><span class="line">    location &#x3D; getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实际 Resource 集合，即 import 的地址，有哪些 Resource 资源</span><br><span class="line">    Set&lt;Resource&gt; actualResources &#x3D; new LinkedHashSet&lt;&gt;(4);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &lt;3&gt; 判断 location 是相对路径还是绝对路径</span><br><span class="line">    &#x2F;&#x2F; Discover whether the location is an absolute or relative URI</span><br><span class="line">    boolean absoluteLocation &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">        absoluteLocation &#x3D; ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">    &#125; catch (URISyntaxException ex) &#123;</span><br><span class="line">        &#x2F;&#x2F; cannot convert to an URI, considering the location relative</span><br><span class="line">        &#x2F;&#x2F; unless it is the well-known Spring prefix &quot;classpath*:&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Absolute or relative?</span><br><span class="line">    &#x2F;&#x2F; &lt;4&gt; 绝对路径</span><br><span class="line">    if (absoluteLocation) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 添加配置文件地址的 Resource 到 actualResources 中，并加载相应的 BeanDefinition 们</span><br><span class="line">            int importCount &#x3D; getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line">            if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from URL location [&quot; + location + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(</span><br><span class="line">                    &quot;Failed to import bean definitions from URL location [&quot; + location + &quot;]&quot;, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#x2F;&#x2F; &lt;5&gt; 相对路径</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; No URL -&gt; considering resource location as relative to the current file.</span><br><span class="line">        try &#123;</span><br><span class="line">            int importCount;</span><br><span class="line">            &#x2F;&#x2F; 创建相对地址的 Resource</span><br><span class="line">            Resource relativeResource &#x3D; getReaderContext().getResource().createRelative(location);</span><br><span class="line">            &#x2F;&#x2F; 存在</span><br><span class="line">            if (relativeResource.exists()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 加载 relativeResource 中的 BeanDefinition 们</span><br><span class="line">                importCount &#x3D; getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">                &#x2F;&#x2F; 添加到 actualResources 中</span><br><span class="line">                actualResources.add(relativeResource);</span><br><span class="line">            &#x2F;&#x2F; 不存在</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 获得根路径地址</span><br><span class="line">                String baseLocation &#x3D; getReaderContext().getResource().getURL().toString();</span><br><span class="line">                &#x2F;&#x2F; 添加配置文件地址的 Resource 到 actualResources 中，并加载相应的 BeanDefinition 们</span><br><span class="line">                importCount &#x3D; getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">                        StringUtils.applyRelativePath(baseLocation, location) &#x2F;* 计算绝对路径 *&#x2F;, actualResources);</span><br><span class="line">            &#125;</span><br><span class="line">            if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from relative location [&quot; + location + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, ex);</span><br><span class="line">        &#125; catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(</span><br><span class="line">                    &quot;Failed to import bean definitions from relative location [&quot; + location + &quot;]&quot;, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; &lt;6&gt; 解析成功后，进行监听器激活处理</span><br><span class="line">    Resource[] actResArray &#x3D; actualResources.toArray(new Resource[0]);</span><br><span class="line">    getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析 <code>import</code> 标签的过程较为清晰，整个过程如下：</p>
<ul>
<li><pre><code>&lt;1&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">处，获取</span><br></pre></td></tr></table></figure>
source
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  属性的值，该值表示资源的路径。</span><br><span class="line"></span><br><span class="line">  - &#96;&lt;2&gt;&#96; 处，解析路径中的系统属性，如 &#96;&quot;$&#123;user.dir&#125;&quot;&#96; 。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
&lt;3&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">处，判断资源路径</span><br></pre></td></tr></table></figure>
location
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  是绝对路径还是相对路径。详细解析，见</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  「2.1 判断路径」</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  。</span><br><span class="line"></span><br><span class="line">  - &#96;&lt;4&gt;&#96; 处，如果是绝对路径，则调递归调用 Bean 的解析过程，进行另一次的解析。详细解析，见 [「2.2 处理绝对路径」](http:&#x2F;&#x2F;svip.iocoder.cn&#x2F;Spring&#x2F;IoC-parse-BeanDefinitions-for-import&#x2F;#) 。</span><br><span class="line">  - &#96;&lt;5&gt;&#96; 处，如果是相对路径，则先计算出绝对路径得到 Resource，然后进行解析。详细解析，见 [「2.3 处理相对路径」](http:&#x2F;&#x2F;svip.iocoder.cn&#x2F;Spring&#x2F;IoC-parse-BeanDefinitions-for-import&#x2F;#) 。</span><br><span class="line"></span><br><span class="line">- &#96;&lt;6&gt;&#96; 处，通知监听器，完成解析。</span><br><span class="line"></span><br><span class="line">#### 2.1 判断路径</span><br><span class="line"></span><br><span class="line">通过以下代码，来判断 &#96;location&#96; 是为相对路径还是绝对路径：</span><br></pre></td></tr></table></figure>
absoluteLocation = ResourcePatternUtils.isUrl(location) // &lt;1&gt;
  || ResourceUtils.toURI(location).isAbsolute(); // &lt;2&gt;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">判断绝对路径的规则如下：</span><br><span class="line"></span><br><span class="line">- &#96;&lt;1&gt;&#96; 以 &#96;classpath*:&#96; 或者 &#96;classpath:&#96; 开头的为绝对路径。</span><br><span class="line">- &#96;&lt;1&gt;&#96; 能够通过该 &#96;location&#96; 构建出 &#96;java.net.URL&#96; 为绝对路径。</span><br><span class="line">- &#96;&lt;2&gt;&#96; 根据 &#96;location&#96; 构造 &#96;java.net.URI&#96; 判断调用 &#96;#isAbsolute()&#96; 方法，判断是否为绝对路径。</span><br><span class="line"></span><br><span class="line">#### 2.2 处理绝对路径</span><br><span class="line"></span><br><span class="line">如果 &#96;location&#96; 为绝对路径，则调用 &#96;#loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources)&#96;， 方法。该方法在 &#96;org.springframework.beans.factory.support.AbstractBeanDefinitionReader&#96; 中定义，代码如下：</span><br></pre></td></tr></table></figure>
/**
* Load bean definitions from the specified resource location.
* &lt;p&gt;The location can also be a location pattern, provided that the
* ResourceLoader of this bean definition reader is a ResourcePatternResolver.
* @param location the resource location, to be loaded with the ResourceLoader
* (or ResourcePatternResolver) of this bean definition reader
* @param actualResources a Set to be filled with the actual Resource objects
* that have been resolved during the loading process. May be {@code null}
* to indicate that the caller is not interested in those Resource objects.
* @return the number of bean definitions found
* @throws BeanDefinitionStoreException in case of loading or parsing errors
* @see #getResourceLoader()
* @see #loadBeanDefinitions(org.springframework.core.io.Resource)
* @see #loadBeanDefinitions(org.springframework.core.io.Resource[])
*/
public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException {
  // 获得 ResourceLoader 对象
  ResourceLoader resourceLoader = getResourceLoader();
  if (resourceLoader == null) {
      throw new BeanDefinitionStoreException(
              &quot;Cannot load bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);
  }

  if (resourceLoader instanceof ResourcePatternResolver) {
      // Resource pattern matching available.
      try {
          // 获得 Resource 数组，因为 Pattern 模式匹配下，可能有多个 Resource 。例如说，Ant 风格的 location
          Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
          // 加载 BeanDefinition 们
          int count = loadBeanDefinitions(resources);
          // 添加到 actualResources 中
          if (actualResources != null) {
              Collections.addAll(actualResources, resources);
          }
          if (logger.isTraceEnabled()) {
              logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);
          }
          return count;
      } catch (IOException ex) {
          throw new BeanDefinitionStoreException(
                  &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);
      }
  } else {
      // Can only load single resources by absolute URL.
      // 获得 Resource 对象，
      Resource resource = resourceLoader.getResource(location);
      // 加载 BeanDefinition 们
      int count = loadBeanDefinitions(resource);
      // 添加到 actualResources 中
      if (actualResources != null) {
          actualResources.add(resource);
      }
      if (logger.isTraceEnabled()) {
          logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);
      }
      return count;
  }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">整个逻辑比较简单：</span><br><span class="line"></span><br><span class="line">- 首先，获取 ResourceLoader 对象。</span><br><span class="line">- 然后，根据不同的 ResourceLoader 执行不同的逻辑，主要是可能存在多个 Resource 。</span><br><span class="line">- 最终，都会回归到 &#96;XmlBeanDefinitionReader#loadBeanDefinitions(Resource... resources)&#96; 方法，所以这是一个递归的过程。</span><br><span class="line">- 另外，获得到的 Resource 的对象或数组，都会添加到 &#96;actualResources&#96; 中。</span><br><span class="line"></span><br><span class="line">#### 2.3 处理相对路径</span><br><span class="line"></span><br><span class="line">如果 &#96;location&#96; 是相对路径，则会根据相应的 Resource 计算出相应的相对路径的 Resource 对象 ，然后：</span><br><span class="line"></span><br><span class="line">- 若该 Resource 存在，则调用 &#96;XmlBeanDefinitionReader#loadBeanDefinitions()&#96; 方法，进行 BeanDefinition 加载。</span><br><span class="line">- 否则，构造一个绝对 &#96;location&#96;( 即 &#96;StringUtils.applyRelativePath(baseLocation, location)&#96; 处的代码)，并调用 &#96;#loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources)&#96; 方法，**与绝对路径过程一样**。</span><br><span class="line"></span><br><span class="line">### 3. 小结</span><br><span class="line"></span><br><span class="line">至此，&#96;import&#96; 标签解析完毕，整个过程比较清晰明了：**获取 source 属性值，得到正确的资源路径，然后调用 &#96;XmlBeanDefinitionReader#loadBeanDefinitions(Resource... resources)&#96; 方法，进行递归的 BeanDefinition 加载**。</span><br><span class="line"></span><br><span class="line">## 8. IoC 之解析 &lt;bean&gt; 标签：开启解析进程</span><br><span class="line"></span><br><span class="line">&#96;import&#96; 标签解析完毕了，我们一起来看看 Spring 中**最复杂也是最重要**的标签 &#96;bean&#96; 标签的解析过程。</span><br><span class="line"></span><br><span class="line">### 1. processBeanDefinition</span><br><span class="line"></span><br><span class="line">在方法 &#96;#parseDefaultElement(...)&#96; 方法中，如果遇到标签为 &#96;bean&#96; 时，则调用 &#96;#processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)&#96; 方法，进行 &#96;bean&#96; 标签的解析。代码如下：</span><br></pre></td></tr></table></figure>
// DefaultBeanDefinitionDocumentReader.java
</code></pre></li>
</ul>
<p>/**</p>
<ul>
<li>Process the given bean element, parsing the bean definition</li>
<li>and registering it with the registry.</li>
<li>/<br>protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {<br>  // 进行 bean 元素解析。<br>  // &lt;1&gt; 如果解析成功，则返回 BeanDefinitionHolder 对象。而 BeanDefinitionHolder 为 name 和 alias 的 BeanDefinition 对象<br>  // 如果解析失败，则返回 null 。<br>  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);<br>  if (bdHolder != null) {<pre><code>// &lt;2&gt; 进行自定义标签处理
bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
try {
    // &lt;3&gt; 进行 BeanDefinition 的注册
    // Register the final decorated instance.
    BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
} catch (BeanDefinitionStoreException ex) {
    getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; +
            bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex);
}
// &lt;4&gt; 发出响应事件，通知相关的监听器，已完成该 Bean 标签的解析。
// Send registration event.
getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</code></pre>  }<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">整个过程分为四个步骤：</span><br><span class="line"></span><br><span class="line">1. 调用</span><br></pre></td></tr></table></figure>
 BeanDefinitionParserDelegate#parseBeanDefinitionElement(Element ele, BeanDefinitionParserDelegate delegate) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   方法，进行元素解析。</span><br><span class="line"></span><br><span class="line">   - 如果解析**失败**，则返回 &#96;null&#96;，错误由 ProblemReporter 处理。</span><br><span class="line">   - 如果解析**成功**，则返回 BeanDefinitionHolder 实例 &#96;bdHolder&#96; 。BeanDefinitionHolder 为持有 &#96;name&#96; 和 &#96;alias&#96; 的 BeanDefinition。</span><br><span class="line">   - 详细解析，见 [「2. parseBeanDefinitionElement」](http:&#x2F;&#x2F;svip.iocoder.cn&#x2F;Spring&#x2F;IoC-parse-BeanDefinitions-in-processBeanDefinition&#x2F;#) 。</span><br><span class="line"></span><br><span class="line">2. 若实例 &#96;bdHolder&#96; 不为空，则调用 &#96;BeanDefinitionParserDelegate#decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder bdHolder)&#96; 方法，进行自定义标签处理。</span><br><span class="line"></span><br><span class="line">3. 解析完成后，则调用 &#96;BeanDefinitionReaderUtils#registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)&#96; 方法，对 &#96;bdHolder&#96; 进行 BeanDefinition 的注册。</span><br><span class="line"></span><br><span class="line">4. 发出响应事件，通知相关的监听器，完成 Bean 标签解析。</span><br><span class="line"></span><br><span class="line">### 2. parseBeanDefinitionElement</span><br><span class="line"></span><br><span class="line">&#96;BeanDefinitionParserDelegate#parseBeanDefinitionElement(Element ele, BeanDefinitionParserDelegate delegate)&#96; 方法，进行 &#96;&lt;bean&gt;&#96; 元素解析。代码如下：</span><br></pre></td></tr></table></figure>
// BeanDefinitionParserDelegate.java</li>
</ul>
<p>/**</p>
<ul>
<li>Parses the supplied {@code <bean>} element. May return {@code null}</bean></li>
<li>if there were errors during parse. Errors are reported to the</li>
<li>{@link org.springframework.beans.factory.parsing.ProblemReporter}.</li>
<li>/<br>@Nullable<br>public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {<br>  return parseBeanDefinitionElement(ele, null);<br>}</li>
</ul>
<p>/**</p>
<ul>
<li><p>Parses the supplied {@code <bean>} element. May return {@code null}</bean></p>
</li>
<li><p>if there were errors during parse. Errors are reported to the</p>
</li>
<li><p>{@link org.springframework.beans.factory.parsing.ProblemReporter}.</p>
</li>
<li></li>
<li><p>@param containingBean TODO 芋艿，需要进一步确认</p>
</li>
<li><p>/<br>@Nullable<br>public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {<br>  // &lt;1&gt; 解析 id 和 name 属性<br>  String id = ele.getAttribute(ID_ATTRIBUTE);<br>  String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</p>
<p>  // &lt;1&gt; 计算别名集合<br>  List<String> aliases = new ArrayList&lt;&gt;();<br>  if (StringUtils.hasLength(nameAttr)) {</String></p>
<pre><code>String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
aliases.addAll(Arrays.asList(nameArr));</code></pre><p>  }</p>
<p>  // &lt;3.1&gt; beanName ，优先，使用 id<br>  String beanName = id;<br>  // &lt;3.2&gt; beanName ，其次，使用 aliases 的第一个<br>  if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {</p>
<pre><code>beanName = aliases.remove(0); // 移除出别名集合
if (logger.isTraceEnabled()) {
    logger.trace(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName +
            &quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;);
}</code></pre><p>  }</p>
<p>  // &lt;2&gt; 检查 beanName 的唯一性<br>  if (containingBean == null) {</p>
<pre><code>checkNameUniqueness(beanName, aliases, ele);</code></pre><p>  }</p>
<p>  // &lt;4&gt; 解析属性，构造 AbstractBeanDefinition 对象<br>  AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);<br>  if (beanDefinition != null) {</p>
<pre><code>// &lt;3.3&gt; beanName ，再次，使用 beanName 生成规则
if (!StringUtils.hasText(beanName)) {
    try {
        if (containingBean != null) {
            // &lt;3.3&gt; 生成唯一的 beanName
            beanName = BeanDefinitionReaderUtils.generateBeanName(
                    beanDefinition, this.readerContext.getRegistry(), true);
        } else {
            // &lt;3.3&gt; 生成唯一的 beanName
            beanName = this.readerContext.generateBeanName(beanDefinition);
            // TODO 芋艿，需要进一步确认
            // Register an alias for the plain bean class name, if still possible,
            // if the generator returned the class name plus a suffix.
            // This is expected for Spring 1.2/2.0 backwards compatibility.
            String beanClassName = beanDefinition.getBeanClassName();
            if (beanClassName != null &amp;&amp;
                    beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;
                    !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                aliases.add(beanClassName);
            }
        }
        if (logger.isTraceEnabled()) {
            logger.trace(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - &quot; +
                    &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
        }
    } catch (Exception ex) {
        error(ex.getMessage(), ele);
        return null;
    }
}
// &lt;5&gt; 创建 BeanDefinitionHolder 对象
String[] aliasesArray = StringUtils.toStringArray(aliases);
return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</code></pre><p>  }<br>  return null;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个方法还没有对 &#96;bean&#96; 标签进行解析，只是在解析动作之前做了一些功能架构，主要的工作有：</span><br><span class="line"></span><br><span class="line">- &#96;&lt;1&gt;&#96; 处，解析 &#96;id&#96;、&#96;name&#96; 属性，确定 &#96;aliases&#96; 集合</span><br><span class="line"></span><br><span class="line">- &#96;&lt;2&gt;&#96; 处，检测 &#96;beanName&#96; 是否唯一。代码如下：</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>已使用 Bean 名字的集合</li>
<li></li>
<li>Stores all used bean names so we can enforce uniqueness on a per</li>
<li>beans-element basis. Duplicate bean ids/names may not exist within the</li>
<li>same level of beans element nesting, but may be duplicated across levels.</li>
<li>/<br>private final Set<String> usedNames = new HashSet&lt;&gt;();</String></li>
</ul>
<p>/**</p>
<ul>
<li><p>Validate that the specified bean name and aliases have not been used already</p>
</li>
<li><p>within the current level of beans element nesting.</p>
</li>
<li><p>/<br>protected void checkNameUniqueness(String beanName, List<String> aliases, Element beanElement) {<br>  // 寻找是否 beanName 已经使用<br>  String foundName = null;<br>  if (StringUtils.hasText(beanName) &amp;&amp; this.usedNames.contains(beanName)) {</String></p>
<pre><code>foundName = beanName;</code></pre><p>  }<br>  if (foundName == null) {</p>
<pre><code>foundName = CollectionUtils.findFirstMatch(this.usedNames, aliases);</code></pre><p>  }<br>  // 若已使用，使用 problemReporter 提示错误<br>  if (foundName != null) {</p>
<pre><code>error(&quot;Bean name &apos;&quot; + foundName + &quot;&apos; is already used in this &lt;beans&gt; element&quot;, beanElement);</code></pre><p>  }</p>
<p>  // 添加到 usedNames 集合<br>  this.usedNames.add(beanName);<br>  this.usedNames.addAll(aliases);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 这里有必要说下 &#96;beanName&#96; 的命名规则：</span><br><span class="line"></span><br><span class="line">  - &#96;&lt;3.1&gt;&#96; 处，如果 &#96;id&#96; 不为空，则 &#96;beanName &#x3D; id&#96; 。</span><br><span class="line">  - &#96;&lt;3.2&gt;&#96; 处，如果 &#96;id&#96; 为空，但是 &#96;aliases&#96; 不空，则 &#96;beanName&#96; 为 &#96;aliases&#96; 的**第一个**元素</span><br><span class="line">  - &#96;&lt;3.3&gt;&#96; 处，如果两者都为空，则根据**默认规则**来设置 beanName 。因为**默认规则**不是本文的重点，所以暂时省略。感兴趣的胖友，自己研究下哈。</span><br><span class="line"></span><br><span class="line">- &#96;&lt;4&gt;&#96; 处，调用 &#96;#parseBeanDefinitionElement(Element ele, String beanName, BeanDefinition containingBean)&#96; 方法，对属性进行解析并封装成 AbstractBeanDefinition 实例 &#96;beanDefinition&#96; 。详细解析，见 [「2.1 parseBeanDefinitionElement」](http:&#x2F;&#x2F;svip.iocoder.cn&#x2F;Spring&#x2F;IoC-parse-BeanDefinitions-in-processBeanDefinition&#x2F;#) 。</span><br><span class="line"></span><br><span class="line">- &#96;&lt;5&gt;&#96; 处，根据所获取的信息（&#96;beanName&#96;、&#96;aliases&#96;、&#96;beanDefinition&#96;）构造 BeanDefinitionHolder 实例对象并返回。其中，BeanDefinitionHolder 的简化代码如下：</span><br></pre></td></tr></table></figure>
<p>/**</p>
</li>
<li><p>BeanDefinition 对象</p>
</li>
<li><p>/<br>private final BeanDefinition beanDefinition;<br>/**</p>
</li>
<li><p>Bean 名字</p>
</li>
<li><p>/<br>private final String beanName;<br>/**</p>
</li>
<li><p>别名集合</p>
</li>
<li><p>/<br>@Nullable<br>private final String[] aliases;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; TODO 芋艿，需要进一步确认，未来参考下 [《Spring专题之IOC源码分析》](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000016261917) ，进行细化。</span><br><span class="line"></span><br><span class="line">#### 2.1 parseBeanDefinitionElement</span><br><span class="line"></span><br><span class="line">&#96;#parseBeanDefinitionElement(Element ele, String beanName, BeanDefinition containingBean)&#96; 方法，对属性进行解析并封装成 AbstractBeanDefinition 实例，代码如下：</span><br></pre></td></tr></table></figure>
<p>/**</p>
</li>
</ul>
</li>
<li><p>Parse the bean definition itself, without regard to name or aliases. May return</p>
</li>
<li><p>{@code null} if problems occurred during the parsing of the bean definition.</p>
</li>
<li><p>/<br>@Nullable<br>public AbstractBeanDefinition parseBeanDefinitionElement(</p>
<pre><code>Element ele, String beanName, @Nullable BeanDefinition containingBean) {</code></pre><p>  this.parseState.push(new BeanEntry(beanName));</p>
<p>  // 解析 class 属性<br>  String className = null;<br>  if (ele.hasAttribute(CLASS_ATTRIBUTE)) {</p>
<pre><code>className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</code></pre><p>  }<br>  // 解析 parent 属性<br>  String parent = null;<br>  if (ele.hasAttribute(PARENT_ATTRIBUTE)) {</p>
<pre><code>parent = ele.getAttribute(PARENT_ATTRIBUTE);</code></pre><p>  }</p>
<p>  try {</p>
<pre><code>// 创建用于承载属性的 AbstractBeanDefinition 实例
AbstractBeanDefinition bd = createBeanDefinition(className, parent);

// 解析默认 bean 的各种属性
parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
// 提取 description
bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

// tips：
// 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，
// 解析出来以后的信息都放到 bd 的属性中

// 解析元数据 &lt;meta /&gt;
parseMetaElements(ele, bd);
// 解析 lookup-method 属性 &lt;lookup-method /&gt;
parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
// 解析 replaced-method 属性 &lt;replaced-method /&gt;
parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

// 解析构造函数参数 &lt;constructor-arg /&gt;
parseConstructorArgElements(ele, bd);
// 解析 property 子元素 &lt;property /&gt;
parsePropertyElements(ele, bd);
// 解析 qualifier 子元素 &lt;qualifier /&gt;
parseQualifierElements(ele, bd);

bd.setResource(this.readerContext.getResource());
bd.setSource(extractSource(ele));

return bd;</code></pre><p>  } catch (ClassNotFoundException ex) {</p>
<pre><code>error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</code></pre><p>  } catch (NoClassDefFoundError err) {</p>
<pre><code>error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</code></pre><p>  } catch (Throwable ex) {</p>
<pre><code>error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</code></pre><p>  } finally {</p>
<pre><code>this.parseState.pop();</code></pre><p>  }</p>
<p>  return null;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">到这里，&#96;bean&#96; 标签的所有属性我们都可以看到其解析的过程，也就说到这里我们已经解析一个基本可用的 BeanDefinition 。</span><br><span class="line"></span><br><span class="line">#### 2.2 createBeanDefinition</span><br><span class="line"></span><br><span class="line">&#96;#createBeanDefinition(String className, String parentName)&#96; 方法，创建 AbstractBeanDefinition 对象。代码如下：</span><br></pre></td></tr></table></figure>
<p>/**</p>
</li>
<li><p>Create a bean definition for the given class name and parent name.</p>
</li>
<li><p>@param className the name of the bean class</p>
</li>
<li><p>@param parentName the name of the bean’s parent bean</p>
</li>
<li><p>@return the newly created bean definition</p>
</li>
<li><p>@throws ClassNotFoundException if bean class resolution was attempted but failed</p>
</li>
<li><p>/<br>protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)</p>
<pre><code>throws ClassNotFoundException {</code></pre><p>  return BeanDefinitionReaderUtils.createBeanDefinition(</p>
<pre><code>parentName, className, this.readerContext.getBeanClassLoader());</code></pre><p>}</p>
<pre><code></code></pre></li>
</ul>
<h3 id="3-小节"><a href="#3-小节" class="headerlink" title="3. 小节"></a>3. 小节</h3><p>由于解析过程 <code>bean</code> 标签的<strong>属性</strong>较为漫长，篇幅较大，为了更好的观看体验，将这篇博文进行<strong>拆分</strong>。</p>
<p>下篇博客主要介绍 BeanDefinition ，以及解析默认 <code>bean</code> 标签的各种属性的过程，即 <code>#parseBeanDefinitionAttributes(Element ele, String beanName, BeanDefinition containingBean, AbstractBeanDefinition bd)</code> 方法。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/03/10/%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8/" rel="next" title="父子容器">
                <i class="fa fa-chevron-left"></i> 父子容器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/10/%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%88%96%E7%BA%BF%E7%A8%8B/" rel="prev" title="一台机器有多少个进程或线程">
                一台机器有多少个进程或线程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="vcomments"></div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avator.png"
                alt="John Doe" />
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=442319&auto=1&height=66"></iframe>

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">313</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            


            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            


          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-IOC的理解"><span class="nav-number">1.</span> <span class="nav-text">1.IOC的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-统一资源加载策略"><span class="nav-number">2.</span> <span class="nav-text">2.统一资源加载策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-加载-BeanDefinition"><span class="nav-number">3.</span> <span class="nav-text">3.加载 BeanDefinition</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1loadBeanDefinitions"><span class="nav-number">3.1.</span> <span class="nav-text">3.1loadBeanDefinitions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-doLoadBeanDefinitions"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 doLoadBeanDefinitions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-doLoadDocument"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 doLoadDocument</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-registerBeanDefinitions"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 registerBeanDefinitions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-获取验证模型"><span class="nav-number">4.</span> <span class="nav-text">4.获取验证模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-getValidationModeForResource"><span class="nav-number">4.1.</span> <span class="nav-text">1. getValidationModeForResource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-XmlValidationModeDetector"><span class="nav-number">4.2.</span> <span class="nav-text">2. XmlValidationModeDetector</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-获取document对象"><span class="nav-number">5.</span> <span class="nav-text">5.获取document对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-DocumentLoader"><span class="nav-number">5.1.</span> <span class="nav-text">1. DocumentLoader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-DefaultDocumentLoader"><span class="nav-number">5.1.1.</span> <span class="nav-text">1.1 DefaultDocumentLoader</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-EntityResolver"><span class="nav-number">5.2.</span> <span class="nav-text">2. EntityResolver</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-子类"><span class="nav-number">5.2.1.</span> <span class="nav-text">2.1 子类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-作用"><span class="nav-number">5.2.2.</span> <span class="nav-text">2.2 作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-DelegatingEntityResolver"><span class="nav-number">5.2.3.</span> <span class="nav-text">2.3 DelegatingEntityResolver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-BeansDtdResolver"><span class="nav-number">5.2.4.</span> <span class="nav-text">2.4 BeansDtdResolver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-PluggableSchemaResolver"><span class="nav-number">5.2.5.</span> <span class="nav-text">2.5 PluggableSchemaResolver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-ResourceEntityResolver"><span class="nav-number">5.2.6.</span> <span class="nav-text">2.6 ResourceEntityResolver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-自定义-EntityResolver"><span class="nav-number">5.2.7.</span> <span class="nav-text">2.7 自定义 EntityResolver</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-注册-BeanDefinitions"><span class="nav-number">6.</span> <span class="nav-text">6.注册 BeanDefinitions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-createBeanDefinitionDocumentReader"><span class="nav-number">6.1.</span> <span class="nav-text">1. createBeanDefinitionDocumentReader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-registerBeanDefinitions"><span class="nav-number">6.2.</span> <span class="nav-text">2. registerBeanDefinitions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-DefaultBeanDefinitionDocumentReader"><span class="nav-number">6.2.1.</span> <span class="nav-text">2.1 DefaultBeanDefinitionDocumentReader</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-parseBeanDefinitions"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">2.1.1 parseBeanDefinitions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-createReaderContext"><span class="nav-number">6.3.</span> <span class="nav-text">3. createReaderContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-小结"><span class="nav-number">6.4.</span> <span class="nav-text">4. 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-解析-import-标签"><span class="nav-number">7.</span> <span class="nav-text">7.解析 import 标签</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-import-示例"><span class="nav-number">7.1.</span> <span class="nav-text">1. import 示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-importBeanDefinitionResource"><span class="nav-number">7.2.</span> <span class="nav-text">2. importBeanDefinitionResource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-小节"><span class="nav-number">7.3.</span> <span class="nav-text">3. 小节</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>
-->




    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共676.6k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  






  
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine@1.1.4/dist/Valine.min.js"></script>
  <script type="text/javascript">
    new Valine({
        av: AV,
        el: '#vcomments' ,
        verify: false,
        notify: false,
        app_id: 'poAXA1bCt4bcaGmuoHBrU52s-gzGzoHsz',
        app_key: 'ARaHT9OThVx8QqybEjteIed2',
        placeholder: 'Comment input placeholder'
    });
  </script>




  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "./public/search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  





<script type="text/javascript"
color="0,0,255" opacity='0.7' zIndex="-2" count="30" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<script type="text/javascript" src="/js/src/clicklove.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
