<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] Redis 学习笔记初识 RedisRedis 是一种基于键值对的 NoSQL 数据库，Redis 中的值可以是由 string、hash、list、set、zset 等多种数据结构和算法组成，因此 Redis 可以满足很多应用场景。Redis 将所有数据都存放在内存中，所以它的读写能力也非常高。Redis 还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器">
<meta property="og:type" content="article">
<meta property="og:title" content="redis相关问题剖析">
<meta property="og:url" content="http://aamingaa.github.io/2020/07/05/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%89%96%E6%9E%90/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[TOC] Redis 学习笔记初识 RedisRedis 是一种基于键值对的 NoSQL 数据库，Redis 中的值可以是由 string、hash、list、set、zset 等多种数据结构和算法组成，因此 Redis 可以满足很多应用场景。Redis 将所有数据都存放在内存中，所以它的读写能力也非常高。Redis 还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/10378860-f024bea7843b5e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/10378860-50aff3db93e8df4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/657/format/webp">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191213103148681.png">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://pics1.baidu.com/feed/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg?token=7ed4cf784a82d04e60b8dc72cf7e3c24&s=EDBAA5565D1859C85444707E02005071">
<meta property="og:image" content="https://pics5.baidu.com/feed/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg?token=a72f072d65d2de548d71bb459cd0bf4f&s=05AAFE168FF04C8A10FD2DEE0300E032">
<meta property="og:image" content="https://pics5.baidu.com/feed/1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg?token=22f387ba78130c6115420059481b2393&s=EF48A15796784D8816E1D9EB03007024">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190429094050254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0J1dHRlcmZseV9yZXN0aW5n,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-0e5e3f73c7cc427a688c6d45cf1f445a_hd.jpg">
<meta property="article:published_time" content="2020-07-05T12:19:55.000Z">
<meta property="article:modified_time" content="2020-11-13T13:09:34.196Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/10378860-f024bea7843b5e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507/format/webp">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://aamingaa.github.io/2020/07/05/redis相关问题剖析/"/>





  <title>redis相关问题剖析 | Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aamingaa.github.io/2020/07/05/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">redis相关问题剖析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-05T20:19:55+08:00">
                2020-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  18k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  65
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h1 id="Redis-学习笔记"><a href="#Redis-学习笔记" class="headerlink" title="Redis 学习笔记"></a>Redis 学习笔记</h1><h2 id="初识-Redis"><a href="#初识-Redis" class="headerlink" title="初识 Redis"></a>初识 Redis</h2><p>Redis 是一种基于键值对的 NoSQL 数据库，Redis 中的值可以是由 string、hash、list、set、zset 等多种数据结构和算法组成，因此 Redis 可以满足很多应用场景。Redis 将所有数据都存放在内存中，所以它的读写能力也非常高。Redis 还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会丢失。除了这些功能，Redis 还提供了键过期、发布订阅、事务、流水线、Lua 等附加功能。</p>
<h3 id="Redis-的特性"><a href="#Redis-的特性" class="headerlink" title="Redis 的特性"></a>Redis 的特性</h3><p><strong>速度快</strong></p>
<p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
<p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>4、使用多路I/O复用模型，非阻塞IO；</p>
<p><strong>基于键值对的数据结构服务器</strong></p>
<p>与很多键值对数据库不同的是，Redis 中的值不仅可以是字符串，还可以是具体的数据结构，这样不仅能应用于多种场景开发，也可以提高开发效率。Redis 的全称是 REmote Dictionary Server，它主要提供五种数据结构：字符串、哈希、列表、集合、有序集合，同时在字符串的基础上演变出了位图和 HyperLogLog 两种数据结构，随着 LBS 基于位置服务的发展，Redis 3.2 加入了有关 GEO 地理信息定位的功能。</p>
<p><strong>丰富的功能</strong></p>
<p>① 提供了键过期功能，可以实现缓存。② 提供了发布订阅功能，可以实现消息系统。③ 支持 Lua 脚本，可以创造新的 Redis 命令。④ 提供了简单的事务功能，能在一定程度商保证事务特性。⑤ 提供了流水线功能，这样客户端能将一批命令一次性传到 Redis，减少了网络开销。⑤IO多路复用</p>
<p><strong>持久化</strong></p>
<p>通常来说数据放在内存中是不安全的，一旦发生断电或故障数据就可能丢失，因此 Redis 提供了两种持久化方式 RDB 和 AOF 将内存的数据保存到硬盘中。</p>
<p><strong>对单线程的理解？</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10378860-f024bea7843b5e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10378860-50aff3db93e8df4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/657/format/webp" alt="img"></p>
<p>redis的IO复用是基于单线程的，但它的一些模块，比如删除过期缓存是多线程的</p>
<h3 id="Redis-的使用场景"><a href="#Redis-的使用场景" class="headerlink" title="Redis 的使用场景"></a>Redis 的使用场景</h3><p><strong>缓存</strong></p>
<p>缓存机制几乎在所有大型网站都有使用，合理使用缓存不仅可以加快数据的访问速度，而且能够有效降低后端数据源的压力。Redis 提供了键值过期时间设置，并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。</p>
<p><strong>排行榜系统</strong></p>
<p>排行榜系统几乎存在于所有网站，Redis 提供了列表和有序集合数据结构，合理使用这些数据结构可以方便构建各各种排行榜系统。</p>
<p><strong>计数器应用</strong></p>
<p>计数器在网站中的作用很重要，例如视频网站有播放数、电商网站有浏览数，为了保证数据实时性，每一次播放和浏览都要做加 1 的操作，如果并发量很大对于传统关系型数据库的性能是很大的挑战。Redis 天然支持计数功能而且性能也非常好。</p>
<p><strong>社交网络</strong></p>
<p>粉丝、共同好友/喜好、推送、下拉刷新等是社交网络的必备功能，由于社交网站的访问量通常很大，而且关系型数据不太适合保存这种类型的数据，Redis 提供的数据结构可以相对容易地实现这些功能。</p>
<p><strong>消息队列系统</strong></p>
<p>消息队列系统是一个大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis 提供了发布订阅和阻塞队列的功能，对于一般的消息队列功能基本可以满足。</p>
<p><strong>Redis 不适合非常大的数据量，成本非常高，也不适合冷数据，会浪费内存。</strong></p>
<hr>
<h2 id="API-的理解和使用"><a href="#API-的理解和使用" class="headerlink" title="API 的理解和使用"></a>API 的理解和使用</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串类型是 Redis 最基础的数据结构，键都是字符串类型，而且其他几种数据结构都是在字符串类型的基础上构建的。字符串类型的值可以实际可以是字符串（简单的字符串、复杂的字符串如 JSON、XML）、数字（整形、浮点数）、甚至二进制（图片、音频、视频），但是值最大不能超过 512 MB。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><strong>设置值</strong></p>
<p><code>set key value [ex seconds] [px millseconds] [nx|xx]</code></p>
<ul>
<li>ex seconds：为键设置秒级过期时间，跟 setex 效果一样</li>
<li>px millseconds：为键设置毫秒级过期时间</li>
<li>nx：键必须不存在才可以设置成功，用于添加，跟 setnx 效果一样。由于 Redis 的单线程命令处理机制，如果多个客户端同时执行，则只有一个客户端能设置成功，可以用作分布式锁的一种实现。</li>
<li>xx：键必须存在才可以设置成功，用于更新</li>
</ul>
<p><strong>获取值</strong></p>
<p><code>get key</code>，如果不存在返回 nil</p>
<p><strong>批量设置值</strong></p>
<p><code>mset key value [key value...]</code></p>
<p><strong>批量获取值</strong></p>
<p><code>mget key [key...]</code></p>
<p>批量操作命令可以有效提高开发效率，假如没有 mget，执行 n 次 get 命令需要 n 次网络时间 + n 次命令时间，使用 mget 只需要 1 次网络时间 + n 次命令时间。</p>
<p>Redis 可以支持每秒数万的读写操作，但这指的是 Redis 服务端的处理能力，对于客户端来说一次命令处理命令时间还有网络时间。因为 Redis 的处理能力已足够高，对于开发者来说，网络可能会成为性能瓶颈。</p>
<p><strong>计数</strong></p>
<p><code>incr key</code></p>
<p>incr 命令用于对值做自增操作，返回结果分为三种：① 值不是整数返回错误。② 值是整数，返回自增后的结果。③ 值不存在，按照值为 0 自增，返回结果 1。除了 incr 命令，还有自减 decr、自增指定数字 incrby、自减指定数组 decrby、自增浮点数 incrbyfloat。</p>
<hr>
<h4 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h4><p><strong>追加值</strong></p>
<p>append key  value，可以向字符串尾部追加值</p>
<p><strong>字符串长度</strong></p>
<p><code>strlen key</code></p>
<p><strong>设置并返回原值</strong></p>
<p><code>getset key value</code></p>
<p><strong>设置指定位置的字符</strong></p>
<p><code>setrange key offset value</code></p>
<p><strong>获取部分字符串</strong></p>
<p><code>getrange key start end</code>，start 和 end分别是开始和结束的偏移量，偏移量从 0 开始计算。</p>
<hr>
<h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><p>字符串类型的内部编码有三种:</p>
<ul>
<li>int：8 个字节的长整形</li>
<li>embstr：小于等于 39 个字节的字符串</li>
<li>raw：大于 39 个字节的字符串</li>
</ul>
<hr>
<h4 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h4><p><strong>缓存功能</strong></p>
<p>Redis 作为缓存层，MySQL 作为存储层，首先从 Redis 获取数据，如果没有获取到就从 MySQL 获取，并将结果写回到 Redis，添加过期时间。</p>
<p><strong>计数</strong></p>
<p>Redis 可以实现快速计数功能，例如视频每播放一次就用 incy 把播放数加 1。</p>
<p><strong>共享 Session</strong></p>
<p>一个分布式 Web 服务将用户的 Session 信息保存在各自服务器，但会造成一个问题，出于负载均衡的考虑，分布式服务会将用户的访问负载到不同服务器上，用户刷新一次可能会发现需要重新登陆。为解决该问题，可以使用 Redis 将用户的 Session 进行集中管理，在这种模式下只要保证 Redis 是高可用和扩展性的，每次用户更新或查询登录信息都直接从 Redis 集中获取。</p>
<p><strong>限速</strong></p>
<p>例如为了短信接口不被频繁访问会限制用户每分钟获取验证码的次数或者网站限制一个 IP 地址不能在一秒内访问超过 n 次。可以使用键过期策略和自增计数实现。</p>
<hr>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>哈希类型是指键值本身又是一个键值对结构，哈希类型中的映射关系叫做 field-value，这里的 value 是指 field 对于的值而不是键对于的值。</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><strong>设置值</strong></p>
<p><code>hset key field value</code>，如果设置成功会返回 1，反之会返回 0，此外还提供了 hsetnx 命令，作用和 setnx 类似，只是作用于由键变为 field。</p>
<p><strong>获取值</strong></p>
<p><code>hget key field</code>，如果不存在会返回 nil。</p>
<p><strong>删除 field</strong></p>
<p><code>hdel key field [field...]</code>，会删除一个或多个 field，返回结果为删除成功 field 的个数。</p>
<p><strong>计算 field 个数</strong></p>
<p><code>hlen key</code></p>
<p><strong>批量设置或获取 field-value</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field...]</span><br><span class="line">hmset key field value [field value...]</span><br></pre></td></tr></table></figure>

<p>hmset 需要的参数是 key 和多对 field-value，hmget 需要的参数是 key 和多个 field。</p>
<p><strong>判断 field 是否存在</strong></p>
<p><code>hexists key field</code>，存在返回 1，否则返回  0。</p>
<p><strong>获取所有的 field</strong></p>
<p><code>hkeys key</code>，返回指定哈希键的所有 field。</p>
<p><strong>获取所有 value</strong></p>
<p><code>hvals key</code>，获取指定键的所有 value。</p>
<p><strong>获取所有的 field-value</strong></p>
<p><code>hgetall key</code>，获取指定键的所有 field-value。</p>
<p><strong>计数</strong></p>
<p><code>hincrby key field</code> 和 <code>hincrbyfloat key field</code>，作用和 incrby 和 incrbyfloat 一样，作用域是 field。</p>
<p><strong>计算 value 的字符串长度</strong></p>
<p>hstrlen key field</p>
<hr>
<h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><p>哈希类型的内部编码有两种：</p>
<ul>
<li>ziplist 压缩列表：当哈希类型元素个数和值小于配置值（默认 512 个和 64 字节）时会使用 ziplist 作为内部实现，使用更紧凑的结构实现多个元素的连续存储，在节省内存方面比 hashtable 更优秀。</li>
<li>hashtable 哈希表：当哈希类型无法满足 ziplist 的条件时会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度都为 O(1)。</li>
</ul>
<hr>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>缓存用户信息，有三种实现：</p>
<ul>
<li><p>原生字符串类型：每个属性一个键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set user:1:name tom</span><br><span class="line">set user:1:age 23</span><br><span class="line">set user:1:city xi&#39;an</span><br></pre></td></tr></table></figure>

<p>优点：简单直观，每个属性都支持更新操作。</p>
<p>缺点：占用过多的键，内存占用量较大，用户信息内聚性差，一般不会在生产环境使用。</p>
</li>
<li><p>序列化字符串类型：将用户信息序列化后用一个键保存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set user:1 serialize(userInfo)</span><br></pre></td></tr></table></figure>

<p>优点：编程简单，如果合理使用序列化可以提高内存使用率。</p>
<p>缺点：序列化和反序列化有一定开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到 Redis。</p>
</li>
<li><p>哈希类型：每个用户属性使用一对 field-value，但只用一个键保存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset user:1 name tom age 23 city xi&#39;an</span><br></pre></td></tr></table></figure>

<p>优点：简单直观，如果合理使用可以减少内存空间使用。</p>
<p>缺点：要控制哈希在 ziplist 和 hashtable 两种内部编码的转换，hashtable 会消耗更多内存。</p>
</li>
</ul>
<hr>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表类型是用来存储多个有序的字符串，列表中的每个字符串称为元素，一个列表最多可以存储 2^32^-1 个元素。可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发中有很多应用场景。</p>
<p>列表类型有两个特点：① 列表中的元素是有序的，可以通过索引下标获取某个元素或者某个范围内的元素列表。② 列表中的元素可以重复。</p>
<h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><p><strong>添加操作</strong></p>
<p>从右边插入元素：<code>rpush key value [value...]</code></p>
<p>从左到右获取列表的所有元素：<code>lrange 0 -1</code></p>
<p>从左边插入元素：<code>lpush key value [value...]</code></p>
<p>向某个元素前或者后插入元素：<code>linsert key before|after pivot value</code>，会在列表中找到等于 pivot 的元素，在其前或后插入一个新的元素 value。</p>
<p><strong>查找</strong></p>
<p>获取指定范围内的元素列表：<code>lrange key start end</code>，索引从左到右的范围是 0<del>N-1，从右到左是 -1</del>-N，lrange 中的 end 包含了自身。</p>
<p>获取列表指定索引下标的元素：<code>lindex key index</code>，获取最后一个元素可以使用 <code>lindex key -1</code>。</p>
<p>获取列表长度：<code>llen key</code></p>
<p><strong>删除</strong></p>
<p>从列表左侧弹出元素：<code>lpop key</code></p>
<p>从列表右侧弹出元素：<code>rpop key</code></p>
<p>删除指定元素：<code>lrem key count value</code>，如果 count 大于 0，从左到右删除最多 count 个元素，如果 count 小于 0，从右到左删除最多个 count 绝对值个元素，如果 count 等于 0，删除所有。</p>
<p>按照索引范围修剪列表：<code>ltrim key start end</code>，只会保留 start ~ end 范围的元素。</p>
<p><strong>修改</strong></p>
<p>修改指定索引下标的元素：<code>lset key index newValue</code>。</p>
<p><strong>阻塞操作</strong></p>
<p>阻塞式弹出：<code>blpop/brpop key [key...] timeout</code>，timeout 表示阻塞时间。</p>
<p>当列表为空时，如果 timeout = 0，客户端会一直阻塞，如果在此期间添加了元素，客户端会立即返回。</p>
<p>如果是多个键，那么brpop会从左至右遍历键，一旦有一个键能弹出元素，客户端立即返回。</p>
<p>如果多个客户端对同一个键执行 brpop，那么最先执行该命令的客户端可以获取弹出的值。</p>
<hr>
<h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><p>列表的内部编码有两种：</p>
<ul>
<li>ziplist 压缩列表：跟哈希的 zipilist 相同，元素个数和大小小于配置值（默认 512 个和 64 字节）时使用。</li>
<li>linkedlist 链表：当列表类型无法满足 ziplist 的条件时会使用linkedlist。</li>
</ul>
<p>Redis 3.2 提供了 quicklist 内部编码，它是以一个 ziplist 为节点的 linkedlist，它结合了两者的优势，为列表类提供了一种更为优秀的内部编码实现。</p>
<hr>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p><strong>消息队列</strong></p>
<p>Redis 的 lpush + brpop 即可实现阻塞队列，生产者客户端使用 lpush 从列表左侧插入元素，多个消费者客户端使用 brpop 命令阻塞式地抢列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</p>
<p><strong>文章列表</strong></p>
<p>每个用户有属于自己的文章列表，现在需要分页展示文章列表，就可以考虑使用列表。因为列表不但有序，同时支持按照索引范围获取元素。每篇文章使用哈希结构存储，例如每篇文章有三个属性，title、timestamp 和 content：</p>
<p><code>hmset article:k title t timestamp 147651524 content c</code>。</p>
<p>向用户文章列表添加文章，<code>user:{id}:articles</code> 作为用户文章列表的键：</p>
<p><code>lpush user:k:articles article:k</code>。</p>
<p>分页获取用户文章列表，例如以下伪代码获取用户 id = 1 的前 10 篇文章。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">articles &#x3D; lrange user:1:articles 0 9</span><br><span class="line">for article in &#123;articles&#125;</span><br><span class="line">	hgetall &#123;article&#125;</span><br></pre></td></tr></table></figure>

<p>使用列表类型保存和获取文章列表存在两个问题：① 如果每次分页获取的文章个数较多，需要执行多次 hgetall 操作，此时可以考虑使用 Pipeline 批量获取，或者考虑将文章数据序列化为字符串类型，使用 mget 批量获取。② 分页获取文章列表时，lrange 命令在列表两端性能较好，但如果列表大，获取中间范围的元素性能会变差，可以考虑将列表做二级拆分，或使用 Redis3.2 的 quicklist。</p>
<hr>
<p><strong>lpush + lpop = 栈</strong></p>
<p><strong>lpush + rpop  = 队列</strong></p>
<p><strong>lpush + ltrim = 优先集合</strong></p>
<p><strong>lpush + brpop = 消息队列</strong></p>
<hr>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合类型也是用来保存多个字符串元素，和列表不同的是集合不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。一个集合最多可以存储 2^32^-1 个元素。Redis 除了支持集合内的增删改查，还支持多个集合取交集、并集、差集。</p>
<h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><p><strong>集合内操作</strong></p>
<p><strong>添加元素</strong></p>
<p><code>sadd key element [element...]</code>，返回结果为添加成功的元素个数。</p>
<p><strong>删除元素</strong></p>
<p><code>srem key element [element...]</code>，返回结果为成功删除的元素个数。</p>
<p><strong>计算元素个数</strong></p>
<p><code>scard key</code>，时间复杂度为 O(1)，会直接使用 Redis 内部的遍历。</p>
<p><strong>判断元素是否在集合中</strong></p>
<p><code>sismember key element</code>，如果存在返回 1，否则返回 0。</p>
<p><strong>随机从集合返回指定个数个元素</strong></p>
<p><code>srandmember key [count]</code>，如果不指定 count 默认为 1。</p>
<p><strong>从集合随机弹出元素</strong></p>
<p><code>spop key</code>，可以从集合中随机弹出一个元素。</p>
<p><strong>获取所有元素</strong></p>
<p><code>smembers key</code></p>
<hr>
<p><strong>集合间操作</strong></p>
<p><strong>求多个集合的交集</strong></p>
<p><code>sinter key [key...]</code></p>
<p><strong>求多个集合的并集</strong></p>
<p><code>sunion key [key...]</code></p>
<p><strong>求多个集合的差集</strong></p>
<p><code>sdiff key [key...]</code></p>
<p><strong>保存交集、并集、差集的结果</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key [key...]</span><br><span class="line">sunionstore destination destination key [key...]</span><br><span class="line">sdiffstore destination key [key...]</span><br></pre></td></tr></table></figure>

<p>集合间的运算在元素较多的情况下会比较耗时，所以 Redis 提供了这三个指令将集合间交集、并集、差集的结果保存在 destination key 中。</p>
<hr>
<h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><p>集合类型的内部编码有两种：</p>
<ul>
<li>intset 整数集合：当集合中的元素个数小于配置值（默认 512 个时），,且都是整数时，使用 intset。</li>
<li>hashtable 哈希表：当集合类型无法满足 intset 条件时使用 hashtable。当某个元素不为整数时，也会使用 hashtable。</li>
</ul>
<hr>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>集合类型比较典型的使用场景是标签，例如一个用户可能与娱乐、体育比较感兴趣，另一个用户可能对例时、新闻比较感兴趣，这些兴趣点就是标签。这些数据对于用户体验以及增强用户黏度比较重要。</p>
<p><strong>给用户添加标签</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2 tag5</span><br><span class="line">sadd user:2:tags tag3 tag4 tag5</span><br><span class="line">...</span><br><span class="line">sadd user:k:tags tagx tagy tagz</span><br></pre></td></tr></table></figure>

<p><strong>给标签添加用户</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd tag:1:users user:1 user:3</span><br><span class="line">sadd tag:2:users user:1 user:4 user:5</span><br><span class="line">...</span><br><span class="line">sadd tag:k:users user:x user:y ...</span><br></pre></td></tr></table></figure>

<p>用户和标签的关系维护应该在一个事务内执行，防止部分命令失败造成的数据不一致。</p>
<p><strong>删除用户标签</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem user:1:tags tag1 tag5</span><br></pre></td></tr></table></figure>

<p><strong>删除标签下的用户</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem tag:1:users user:1</span><br></pre></td></tr></table></figure>

<p>删除也同样应该放在一个事务中。</p>
<p><strong>求两个用户共同感兴趣的标签</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinter user:1:tags user:2:tags</span><br></pre></td></tr></table></figure>

<p><strong>sadd = 标签</strong></p>
<p><strong>spop/srandmember = 生成随机数，比如抽奖</strong></p>
<p><strong>sadd + sinter = 社交需求</strong></p>
<hr>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>有序集合保留了集合不能有重复成员的特性，不同的是可以排序。但是它和列表使用索引下标作为排序依据不同的是，他给每个元素设置一个分数（score）作为排序的依据。有序集合提供了获取指定分数和元素查询范围、计算成员排名等功能。</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>是否允许元素重复</th>
<th>是否有序</th>
<th>有序实现方式</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>列表</td>
<td>是</td>
<td>是</td>
<td>下标</td>
<td>时间轴，消息队列</td>
</tr>
<tr>
<td>集合</td>
<td>否</td>
<td>否</td>
<td>/</td>
<td>标签，社交</td>
</tr>
<tr>
<td>有序集合</td>
<td>否</td>
<td>是</td>
<td>分值</td>
<td>排行榜，社交</td>
</tr>
</tbody></table>
<h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><p><strong>集合内</strong></p>
<p><strong>添加成员</strong></p>
<p><code>zadd key score member [score member...]</code>，返回结果是成功添加成员的个数</p>
<p>Redis 3.2 为 zadd 命令添加了 nx、xx、ch、incr 四个选项：</p>
<ul>
<li>nx：member 必须不存在才可以设置成功，用于添加</li>
<li>xx：member 必须存在才能设置成功，用于更新</li>
<li>ch：返回此次操作后，有序集合元素和分数变化的个数</li>
<li>incr：对 score 做增加，相当于 zincrby</li>
</ul>
<p>zadd 的时间复杂度为 O(log<del>n</del>)，sadd 的时间复杂度为 O(1)。</p>
<p><strong>计算成员个数</strong></p>
<p><code>zcard key</code>，时间复杂度为 O(1)。</p>
<p><strong>计算某个成员的分数</strong></p>
<p><code>zscore key member</code> ，如果不存在则返回 nil。</p>
<p><strong>计算成员排名</strong></p>
<p><code>zrank key member</code>，从低到高返回排名</p>
<p><code>zrevrank key member</code>，从高到低返回排名</p>
<p><strong>删除成员</strong></p>
<p><code>zrem key member [member...]</code>，返回结果是成功删除的个数。</p>
<p><strong>增加成员的分数</strong></p>
<p><code>zincrby key increment member</code></p>
<p><strong>返回指定排名范围的成员</strong></p>
<p><code>zrange key start end [withscores]</code></p>
<p><code>zrevrange key start end [withscores]</code></p>
<p>zrange 从低到高返回，zrevrange 从高到底返回，如果加上 withscores 选项同时会返回成员的分数。</p>
<p><strong>返回指定分数范围的成员</strong></p>
<p><code>zrangebyscore key min max [withscores] [limit offset count]</code></p>
<p><code>zrevrangebyscore key min max [withscores] [limit offset count]</code></p>
<p>zrangebyscore 从低到高返回，zrevrangebyscore 从高到底返回，如果加上 withscores 选项同时会返回成员的分数。[limit offset count] 可以限制输出的起始位置和个数。</p>
<p><strong>返回指定分数范围成员个数</strong></p>
<p><code>zcount key min max</code></p>
<p><strong>删除指定排名内的升序元素</strong></p>
<p><code>zremrangebyrank key start end</code></p>
<p><strong>删除指定分数范围内的成员</strong></p>
<p><code>zremrangebyscore key min max</code></p>
<hr>
<p><strong>集合间的操作</strong></p>
<p><strong>交集</strong></p>
<p><code>zinterstore destination numkeys key [key...] [weights weight [weight...]] [aggregate sum|min|max]</code></p>
<ul>
<li><p>destination：交集结果保存到这个键</p>
</li>
<li><p>numkeys：要做交集计算键的个数</p>
</li>
<li><p>key [key…]：需要做交集计算的键</p>
</li>
<li><p>weights weight [weight…]：每个键的权重，默认 1</p>
</li>
<li><p>aggregate sum|min|max：计算交集后，分值可以按和、最小值、最大值汇总，默认 sum</p>
</li>
</ul>
<p><strong>并集</strong></p>
<p><code>zunionstore destination numkeys key [key...] [weights weight [weight...]] [aggregate sum|min|max]</code></p>
<hr>
<h4 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h4><p>有序集合的内部编码有两种：</p>
<ul>
<li>ziplist 压缩列表：当有序集合元素个数和值小于配置值（默认128 个和 64 字节）时会使用 ziplist 作为内部实现。</li>
<li>skiplist 跳跃表：当 ziplist 不满足条件时使用，因为此时 ziplist 的读写效率会下降。</li>
</ul>
<hr>
<h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>有序集合的典型使用场景就是排行榜系统。</p>
<p>例如用户 mike 上传了一个视频并添加了 3 个赞，可以使用有序集合的 zadd 和 zincrby：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd user:ranking:2020_06_19 3 mike</span><br></pre></td></tr></table></figure>

<p>如果之后再获得一个赞，可以使用 zincrby：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zincrby user:ranking:2020_06_19 1 mike</span><br></pre></td></tr></table></figure>

<p>例如需要将用户 tom 从榜单删除，可以使用 zrem：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem user:ranking:2020_06_19 tom</span><br></pre></td></tr></table></figure>

<p>展示获取赞数最多的十个用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrange user:ranking:2020_06_19 0 9</span><br></pre></td></tr></table></figure>

<p>展示用户信息及用户分数，将用户名作为键后缀，将用户信息保存在哈希类型中，至于用户分数和排名可以使用 zscore 和 zrank：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hgetall user:info:tom</span><br><span class="line">zscore user:ranking:2020_06_19 tom</span><br><span class="line">zrank user:ranking:2020_06_19 tom</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="键管理"><a href="#键管理" class="headerlink" title="键管理"></a>键管理</h3><h4 id="单个键管理"><a href="#单个键管理" class="headerlink" title="单个键管理"></a>单个键管理</h4><p><strong>键重命名</strong></p>
<p><code>rename key newkey</code></p>
<p>如果 rename 前键已经存在，那么它的值也会被覆盖。</p>
<p>为了防止强行覆盖，Redis 提供了 renamenx 命令，确保只有 newkey 不存在时才被覆盖。由于重命名键期间会执行 del 命令删除旧的键，如果键对应值比较大会存在阻塞的可能。</p>
<p><strong>随机返回一个键</strong></p>
<p><code>random key</code></p>
<p><strong>键过期</strong></p>
<p><code>expire key seconds</code>：键在 seconds 秒后过期</p>
<p><code>expireat key timestamp</code>：键在秒级时间戳 timestamp 后过期</p>
<p>如果过期时间为负值，键会被立即删除，和 del 命令一样。</p>
<p>persist 命令可以将键的过期时间清除。</p>
<p>对于字符串类型键，执行 set 命令会去掉过期时间，set 命令对应的函数 setKey 最后执行了 removeExpire 函数去掉了过期时间。</p>
<p>Redis 不支持二级数据结构（例如哈希、列表）内部元素的过期功能，例如不能对列表类型的一个元素设置过期时间。</p>
<p>setex 命令作为 set + expire 的组合，不单是原子执行并且减少了一次网络通信的时间。</p>
<p><strong>键迁移</strong></p>
<ul>
<li><p>move</p>
<p><code>move key db</code></p>
<p>move 命令用于在 Redis 内部进行数据迁移，<code>move key db</code> 就是把指定的键从源数据库移动到目标数据库中。</p>
</li>
<li><p>dump + restore</p>
<p><code>dump key</code></p>
<p><code>restore key ttl value</code></p>
<p>可以实现在不同的 Redis 势力之间进行数据迁移，分为两步：</p>
<p>① 在源 Redis 上，dump 命令会将键值序列化，格式采用 RDB 格式。</p>
<p>② 在目标 Redis 上，restore 命令将上面序列化的值进行复原，ttl 参数代表过期时间， ttl = 0 则没有过期时间。</p>
<p>整个迁移并非原子性的，而是通过客户端分步完成，并且需要两个客户端。</p>
</li>
<li><p>migrate</p>
<p>实际上 migrate 命令就是将 dump、restore、del 三个命令进行组合，从而简化了操作流程。migrate 具有原子性，且支持多个键的迁移，有效提高了迁移效率。实现过程和 dump + restore 类似，有三点不同：</p>
<p>① 整个过程是原子执行，不需要在多个 Redis 实例开启客户端。</p>
<p>② 数据传输直接在源 Redis 和目标 Redis 完成。</p>
<p>③ 目标 Redis 完成 restore 后会发送 OK 给源 Redis，源 Redis 接收后会根据 migrate 对应的选项来决定是否在源 Redis 上删除对应的键。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用域</th>
<th>原子性</th>
<th>支持多个键</th>
</tr>
</thead>
<tbody><tr>
<td>move</td>
<td>Redis 实例内部</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>dump + restore</td>
<td>Redis 实例之间</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>migrate</td>
<td>Redis 实例之间</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<hr>
<h4 id="遍历键"><a href="#遍历键" class="headerlink" title="遍历键"></a>遍历键</h4><p><strong>全量遍历键</strong></p>
<p><code>keys pattern</code></p>
<p><code>*</code>代表匹配任意字符，<code>?</code> 匹配一个字符，<code>[]</code> 匹配部分字符，例如 <code>[1,3]</code> 匹配 1 和 3， <code>[1-3]</code> 匹配 1 到 3 的任意数字，<code>\</code>用来做转义。</p>
<p><code>keys *</code> 遍历所有的键，一般不在生产环境使用，在以下情况可以使用：</p>
<p>① 在一个不对外提供服务的 Redis 从节点上执行，不会阻塞客户端的请求，但会影响主从复制。</p>
<p>② 如果确定键值总数比较少可以执行。</p>
<hr>
<p><strong>渐进式遍历</strong></p>
<p>Redis 从 2.8 版本后提供了一个新的命令 scan，能有效解决 keys 存在的问题。和 keys 遍历所有键不同，scan 采用渐进式遍历的方式解决阻塞问题，每次 scan 的时间复杂度为 O(1)，但是要真正实现 keys 的功能可能需要执行多次 scan。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan cursor [match pattern] [count number]</span><br></pre></td></tr></table></figure>

<p>cursor 是必须参数，代表一个游标，第一次遍历从 0 开始，每次 scan 完会返回当前游标的值，直到值为 0 表示遍历结束。</p>
<p>match pattern 是可选参数，作用是模式匹配。</p>
<p>count number 是可选参数，作用是表明每次要遍历的键个数，默认值为 10。</p>
<p>除了 scan 外，Redis 提供了面向哈希、集合、有序集合的扫描遍历命令，解决了 hgetall、smembers、zrange 可能产生的阻塞问题，对应命令分别为 hscan、sscan、zscan。</p>
<p>渐进式遍历可以有效解决 keys 命令可能产生的阻塞问题，但是如果在 scan 过程中有键的变化，那么遍历效果可能会遇到问题：新增的键没有被遍历到，遍历了重复的键等情况。</p>
<hr>
<h4 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h4><p><strong>切换数据库</strong></p>
<p><code>select dbIndex</code></p>
<p>Redis 中默认配置有 16 个数据库，例如 select 0 将切换到第一个数据库，数据库之间的数据是隔离的。</p>
<p><strong>flushdb/flushall</strong></p>
<p>用于清除数据库，flushdb 只清除当前数据库，flushall 会清除所有数据库。如果当前数据库键值数量比较多，flushdb/flushall 存在阻塞 Redis 的可能性。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redis 提供 5 种数据结构，每种数据结构都有多种内部编码实现。</p>
<p>纯内存存储、IO 多路复用计数、单线程架构是造就 Redis 高性能的三个因素。</p>
<p>由于 Redis 的单线程结构，所以需要每个命令能被快速执行完，否则会存在阻塞的可能。</p>
<p>批量操作（例如 mget、mset、hmset 等）能够有效提高命令执行的效率，但要注意每次批量操作的个数和字节数。</p>
<p>persist 命令可以删除任意类型键的过期时间，但 set 也会删除字符串类型键的过期时间。</p>
<p>move、dump + restore、migrate 是 Redis 发展过程中三种迁移键的方式，其中 move 命令基本废弃，migrate 命令用原子性的方式实现了 dump + restore，并且支持批量操作，是 Redis Cluster 实现水平扩容的重要工具。</p>
<p>scan 命令可以解决 keys 命令可能带来的阻塞问题，同时 Redis 还提供了 hscan、sscan、zscan 渐进式遍历 hash、set、zset。</p>
<hr>
<h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的<br>Redis会将一个事务中的所有命令序列化，然后按顺序执行。<br>1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。<br>2.如果在一个事务中的<strong>命令</strong>出现错误，那么<strong>所有的命令</strong>都不会执行；<br>3.如果在一个事务中出现<strong>运行错误</strong>，那么<strong>正确的命令</strong>会被执行。<br>注：redis的discard只是结束本次事务,正确命令造成的影响仍然存在.</p>
<p>1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。<br>2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。<br>3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。<br>4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</p>
<hr>
<h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>Bitmaps 本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。</p>
<p>Bitmaps 单独提供了一套命令，所以在 Redis 使用 Bitmaps 和使用字符串的方法不太相同，可以把 Bitmaps 看作一个以位为单位的数组，数组的每个单元只能存储 0 和 1，数组的下标叫做偏移量。</p>
<h4 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h4><p>例：将每个独立用户是否访问过网站存放在 Bitmaps 中，将访问过的用户记作 1，没有访问过的记作 0，偏移量作为用户的 id。</p>
<p><strong>设置值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure>

<p>设置键的第 offset 个位的值，假设有 20 个用户，id 为 0、5、11、15、19 的用户对网站进行了访问，那么初始化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setbit unique:users:2020-06-20 0 1</span><br><span class="line">setbit unique:users:2020-06-20 5 1</span><br><span class="line">setbit unique:users:2020-06-20 11 1</span><br><span class="line">setbit unique:users:2020-06-20 15 1</span><br><span class="line">setbit unique:users:2020-06-20 19 1</span><br></pre></td></tr></table></figure>

<p>很多应用的用户 id 直接以一个指定数字开头，例如 10000，直接将用户 id 与 Bitmaps 的偏移量对应势必会造成一定浪费，通常做法是每次做 setbit 操作时将用户 id 减去这个指定数字。在第一次初始化 Bitmaps 时，如果偏移量非常大，那么整个初始化过程会执行比较慢，可能造成阻塞。</p>
<p><strong>获取值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure>

<p>获取键的第 offset 个位的值，例如获取 id 为 8 的用户是否在 2020-06-20 这天访问过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit unique:users:2020-06-20 8</span><br></pre></td></tr></table></figure>

<p><strong>获取指定范围值为 1 的个数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure>

<p>例如获取 2020-06-20 这天访问过的用户数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount unique:users:2020-06-20</span><br></pre></td></tr></table></figure>

<p>start 和 end 代表起始和结束字节数。</p>
<p><strong>Bitmaps 间的运算</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop op destkey key [key...]</span><br></pre></td></tr></table></figure>

<p>bitop 是一个复合操作，它可以做交集、并集、非、异或并将结果保存到 destkey 中。</p>
<p>例如计算 2020-06-20 和 2020-06-21 都访问过网站的用户数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitop and unique:users:and:2020-06-20_21 unique:users:2020-06-20 unique:users:2020-06-21</span><br><span class="line">bitcount unique:users:and:2020-06-20_21</span><br></pre></td></tr></table></figure>

<p>例如计算 2020-06-20 和 2020-06-21 任意一天访问过网站的用户数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitop or unique:users:or:2020-06-20_21 unique:users:2020-06-20 unique:users:2020-06-21</span><br><span class="line">bitcount unique:users:or:2020-06-20_21</span><br></pre></td></tr></table></figure>

<p><strong>计算第一个值为 tartgetBit 的偏移量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitops key targetBit [start] [end]</span><br></pre></td></tr></table></figure>

<p>例如计算 2020-06-20 当前访问网站的最小用户 id：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitops unique:users:2019-06-20 1</span><br></pre></td></tr></table></figure>

<p>假设网站的活跃用户量很大，使用 Bitmaps 相比 set 可以节省很多内存，但如果活跃用户很少就会浪费内存。</p>
<hr>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>HyperLogLog 不是一种新的数据结构，实际也是字符串类型，是一种基数算法。提供 HyperLogLog 可以利用极小的内存空间完成独立总数的统计，数据集可以是 IP、Email、ID 等。</p>
<p><strong>添加</strong></p>
<p><code>pfadd key element [element...]</code>，如果添加成功会返回 1</p>
<p><strong>计算独立用户数</strong></p>
<p><code>pfcount key [key...]</code></p>
<p><strong>合并</strong></p>
<p><code>pfmerge destkey sourcekey [sourcekey...]</code></p>
<p>HyperLogLog 内存占用量非常小，但是存在错误率，开发者在进行数据结构选型时只需要确认如下两条：</p>
<ul>
<li>只为了计算独立总数，不需要获取单条数据。</li>
<li>可以容忍一定误差率，毕竟 HyperLogLog 在内存占用量上有很大优势。</li>
</ul>
<hr>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>Redis 提供了基于发布/订阅模式的消息机制，此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel）发送消息，订阅该频道的每个客户端都可以收到该消息。</p>
<h4 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h4><p><strong>发布消息</strong></p>
<p><code>publish channel message</code>，返回结果为订阅者的个数。</p>
<p><strong>订阅消息</strong></p>
<p><code>subscribe channel [channel..]</code>，订阅者可以订阅一个或多个频道。</p>
<p>客户端在执行订阅命令后会进入订阅状态，只能接收 subscribe、psubscribe、unsubscribe、punsubscribe 的四个命令。新开启的订阅客户端，无法收到该频道之前的消息，因为 Redis 不会对法捕的消息进行持久化。</p>
<p>和很多专业的消息队列系统如 Kafka、RocketMQ 相比，Redis 的发布订阅略显粗糙，例如无法实现消息堆积和回溯，但胜在足够简单，如果当前场景可以容忍这些缺点，也是一个不错的选择。</p>
<p><strong>取消订阅</strong></p>
<p><code>unsubscribe [channel [channel...]]</code></p>
<p>客户端可以通过 unsubscribe 命令取消对指定频道的订阅，取消成功后不会再收到该频道的发布消息。</p>
<p><strong>按照模式订阅和取消订阅</strong></p>
<p><code>psubscribe pattern [pattern...]</code></p>
<p><code>punsubscribe pattern [pattern...]</code></p>
<p>这两种命令支持 glob 风格，例如订阅所有以 it 开头的频道：<code>psubscribe it*</code></p>
<p><strong>查询订阅</strong></p>
<p>查看活跃的频道：<code>pubsub channels [pattern]</code>，活跃频道是指当前频道至少有一个订阅者。</p>
<p>查看频道订阅数：<code>pubsub numsub [channel ...]</code></p>
<p>查看模式订阅数：<code>pubsub numpat</code></p>
<hr>
<h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><p>聊天室、公告牌、服务之间利用消息解耦都可以使用发布订阅模式，以服务器解耦为例：视频管理系统负责管理视频信息，用户通过各种客户端获取视频信息。</p>
<p>假如视频管理员在视频管理系统中对视频信息进行了更新，希望及时通知给视频服务端，就可以采用发布订阅模式，发布视频信息变化的消息到指定频道，视频服务订阅这个频道及时更新视频信息，通过这种方式实现解耦。</p>
<p>视频服务订阅 video:changes 频道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe video:changes</span><br></pre></td></tr></table></figure>

<p>视频管理系统发布消息到 video:changes 频道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish video:changes &quot;video1,video3,video5&quot;</span><br></pre></td></tr></table></figure>

<p>视频服务收到消息，对视频信息进行更新..</p>
<hr>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>Redis 3.2 版本提供了 GEO 地理信息定位功能，支持存储地理位置信息用来实现诸如附近位置、摇一摇这一类依赖于地理位置信息的功能。</p>
<p><strong>增加地理位置信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member...]</span><br></pre></td></tr></table></figure>

<p>longitude、latitude、member 分别是该地理位置的经度、纬度、成员。</p>
<p>例如添加北京的地理位置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd cities:locations 116.28 39.55 beijing</span><br></pre></td></tr></table></figure>

<p>返回结果表示成功添加的个数，如果需要更新地理位置信息仍然可以使用 geoadd 命令，返回结果为 0。</p>
<p><strong>获取地理位置信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getpos key member [member...]</span><br></pre></td></tr></table></figure>

<p><strong>获取两个地理位置的距离</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure>

<p>其中 unit 代表返回结果的单位，包含 m 米、km 公里、mi 英里、ft 英尺。</p>
<p><strong>删除地理位置信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member</span><br></pre></td></tr></table></figure>

<p>GEO 没有提供删除成员的命令，但由于它底层是 zset，可以使用 zrem 删除。</p>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>慢查询中有两个重要参数 slowlog-log-slower-than 和 slowlog-max-len。</p>
<p>慢查询不包括命令网络传输和排队时间。</p>
<p>有必要将慢查询定期存放。</p>
<p>Pipeline 可以有效减少 RTT 次数，但每次 Pipeline 的命令数量不能无节制。</p>
<p>Redis 可以使用 Lua 脚本创造出原子、高效、自定义命令组合。</p>
<p>Bitmaps 可以用来做独立用户统计，有效节省内存。</p>
<p>Bitmaps 中 setbit 一个大的偏移量，由于申请大量内存会导致阻塞。</p>
<p>HyperLogLog 虽然在统计独立总量时存在一定误差，但是节省的内存量十分惊人。</p>
<p>Redis 的发布订阅相比许多专业消息队列系统功能较弱，不具备息堆积和回溯能力，但胜在足够简单。</p>
<p>Redis 3.2 提供了 GEO 功能，用来实现基于地理位置信息的应用，底层实现是 zset。</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p>
<p>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p>
<p><img src="https://img-blog.csdnimg.cn/20191213103148681.png" alt="img"></p>
<p>使用SETNX完成同步锁的流程及事项如下：</p>
<p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</p>
<p>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p>
<p>释放锁，使用DEL命令将锁数据删除</p>
<h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>​    <strong>描述：</strong></p>
<p>​    缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<p>   <strong>解决方案：</strong></p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ol>
<li><p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ol>
</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁</li>
</ol>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p><strong>1）缓存无效 key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>2）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md" target="_blank" rel="noopener">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">**缓存穿透**是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</span><br><span class="line"></span><br><span class="line">**解决方案**</span><br><span class="line"></span><br><span class="line">1. 接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</span><br><span class="line">2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</span><br><span class="line">3. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</span><br><span class="line"></span><br><span class="line">**附加**</span><br><span class="line"></span><br><span class="line">对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</span><br><span class="line">Bitmap： 典型的就是哈希表</span><br><span class="line">缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</span><br><span class="line"></span><br><span class="line">布隆过滤器（推荐）</span><br><span class="line"></span><br><span class="line">就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</span><br><span class="line">它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</span><br><span class="line">Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</span><br><span class="line">Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。</span><br><span class="line">Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</span><br></pre></td></tr></table></figure>



<p>is 对象的个数，在极端情况下可能会造成连接泄露，而连接池的形式可以有效的保护和控制资源的使用。</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>直连</td>
<td>简单方便，适用于少量长期连接的场景。</td>
<td>存在每次连接关闭 TCP 连接的开销，资源无法控制可能出现连接泄露，Jedis 对象线程不安全</td>
</tr>
<tr>
<td>连接池</td>
<td>无需每次连接都生成 Jedis 对象降低开销，使用连接池的形式保护和控制资源的使用</td>
<td>相对于直连比较麻烦，尤其在资源的管理上需要很多参数来保证，一旦规划不合理也会出现问题</td>
</tr>
</tbody></table>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。默认的文件名为dump.rdb。</p>
<p><strong>1、save触发方式</strong></p>
<p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：</p>
<p><img src="https://pics1.baidu.com/feed/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg?token=7ed4cf784a82d04e60b8dc72cf7e3c24&s=EDBAA5565D1859C85444707E02005071" alt="img"></p>
<p>执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p>
<p><strong>2、bgsave触发方式</strong></p>
<p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p>
<p><img src="https://pics5.baidu.com/feed/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg?token=a72f072d65d2de548d71bb459cd0bf4f&s=05AAFE168FF04C8A10FD2DEE0300E032" alt="img"></p>
<p>具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</p>
<p><strong>3、自动触发</strong></p>
<p>自动触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><img src="https://pics5.baidu.com/feed/1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg?token=22f387ba78130c6115420059481b2393&s=EF48A15796784D8816E1D9EB03007024" alt="img"></p>
<p><strong>AOF（append-only file）持久化</strong></p>
<p>与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>RDB 的优势和劣势</strong></p>
<p>①、优势</p>
<p>（1）RDB，全量备份，非常适合用于进行备份和灾难恢复。</p>
<p>（2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p>
<p>（3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>
<p>②、劣势</p>
<p>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p>
<p><strong>AOF 的优势和劣势</strong></p>
<p>(1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。</p>
<p>（2）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p>
<p><strong>5、缺点</strong></p>
<p>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p>
<p>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p>
<p><strong>相关 issue</strong> ：<a href="https://github.com/Snailclimb/JavaGuide/issues/783" target="_blank" rel="noopener">783：Redis 的 AOF 方式</a></p>
<hr>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(transaction)功能。</p>
<blockquote>
<p>MULTI<br>OK<br>INCR foo<br>QUEUED<br>INCR bar<br>QUEUED<br>EXEC</p>
</blockquote>
<p>1) (integer) 1<br>2) (integer) 1<br>Copy to clipboardErrorCopied<br>使用 MULTI命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了EXEC命令将执行所有命令。</p>
<p>Redis官网相关介绍 <a href="https://redis.io/topics/transactions" target="_blank" rel="noopener">https://redis.io/topics/transactions</a> 如下：</p>
<p>redis事务</p>
<p>但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： 1. 原子性，2. 隔离性，3. 持久性，4. 一致性。</p>
<p>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；<br>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；<br>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。<br>一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；<br>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</p>
<p>Redis官网也解释了自己为啥不支持回滚。简单来说就是Redis开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<p>redis roll back</p>
<p>你可以将Redis中的事务就理解为 ：Redis事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</p>
<h3 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h3><p>文件事件处理器包括分别是<strong>套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器</strong>。使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。<br>I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br><strong>工作原理：</strong><br>1)I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br>尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字.<br><img src="https://img-blog.csdnimg.cn/20190429094050254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0J1dHRlcmZseV9yZXN0aW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>redis 提供 6种数据淘汰策略：</p>
<ul>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从<strong>已设置过期时间</strong>的数据集（server.db[i].expires）中随机移除key</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-eviction：当内存不足以容纳新写入数据时，新写入操作会报错，无法写入新数据，一般不采用</li>
</ul>
<h3 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h3><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p>
<table>
<thead>
<tr>
<th>对比参数</th>
<th>Redis</th>
<th align="center">Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>1. 支持内存 2. 非关系型数据库</td>
<td align="center">1. 支持内存 2. 键值对形式 3. 缓存形式</td>
</tr>
<tr>
<td><strong>数据存储类型</strong></td>
<td>1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】</td>
<td align="center">只支持简单的key-value</td>
</tr>
<tr>
<td><strong>持久化支持</strong></td>
<td>1. RDB 2. AOF</td>
<td align="center">不支持</td>
</tr>
<tr>
<td><strong>集群模式</strong></td>
<td>原生支持 cluster 模式，可以实现主从复制，读写分离</td>
<td align="center">没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td>
</tr>
<tr>
<td>内存管理机制</td>
<td>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td>
<td align="center">Memcached 的数据则会一直在内存中，Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</td>
</tr>
</tbody></table>
<ul>
<li>存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。</li>
<li>数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。</li>
<li>用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>
<li>value的大小：<strong><em>\</em>redis可以达到1GB，而memcache只有1MB**</strong>。</li>
</ul>
<h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。<br>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h3 id="高并发情况下，对于Redis的更新操作有哪些注意事项？"><a href="#高并发情况下，对于Redis的更新操作有哪些注意事项？" class="headerlink" title="高并发情况下，对于Redis的更新操作有哪些注意事项？"></a>高并发情况下，对于Redis的更新操作有哪些注意事项？</h3><p>操作：先更新数据库，再删除缓存<br>正常的情况是这样的：  </p>
<ul>
<li>1、 先操作数据库，成功</li>
<li>2、再删除缓存，也成功</li>
<li>3、 如果原子性被破坏了：第一步成功(操作数据库)，第二步失败(删除缓存)，会导致数据库里是新数据，而缓存里是旧数据。</li>
</ul>
<p>如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。<br>如果在高并发的场景下，出现数据库与缓存数据不一致的概率特别低，也不是没有：缓存刚好失效//线程A查询数据库，得一个旧值//线程B将新值写入数据库//线程B删除缓存//线程A将查到的旧值写入缓存<br>要达成上述情况，还是说一句概率特别低,因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。对于这种策略，其实是一种设计模式：Cache Aside Pattern<br><strong>解决删除缓存失败的解决思路</strong>：将需要删除的key发送到消息队列中—自己消费消息，获得需要删除的key—不断重试删除操作，直到成功</p>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>Redis每次按key获取一个值的时候，都会更新value中的<strong>lru字段</strong>为当前秒级别的时间戳。</p>
<p>Redis初始的实现算法很简单，随机从dict中取出五个key,淘汰一个lru字段值最小的。</p>
<p>在3.0的时候，又改进了一版算法：</p>
<ul>
<li>首先第一次随机选取的key都会放入一个pool中(pool的大小为16)，pool中的key是按lru大小顺序排列的。</li>
<li>接下来每次随机选取的key <strong>lru值必须小于pool中最小的lru</strong>才会继续放入，直到将pool放满。</li>
<li>放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。</li>
<li><strong><em>\</em>淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰**</strong>。</li>
</ul>
<h3 id="Redis的IO复用"><a href="#Redis的IO复用" class="headerlink" title="Redis的IO复用"></a>Redis的IO复用</h3><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>
<p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件： 1. 文件事件; 2. 时间事件。</p>
<p>时间事件不需要多花时间了解，我们接触最多的还是 <strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p>可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png" alt="img"></p>
<h4 id="master结点挂了"><a href="#master结点挂了" class="headerlink" title="master结点挂了"></a>master结点挂了</h4><p>raft选举出新的leader</p>
<h3 id="节点间通信机制"><a href="#节点间通信机制" class="headerlink" title="节点间通信机制"></a>节点间通信机制</h3><p>支撑N个redis master node，每个master node都可以挂载多个slave node</p>
<p>读写分离的架构，对于每个master来说，写就写到master，然后读就从mater对应的slave去读</p>
<p>高可用，因为每个master都有salve节点，那么如果mater挂掉，redis cluster这套机制，就会自动将某个slave切换成master</p>
<h3 id="hash-slot"><a href="#hash-slot" class="headerlink" title="hash slot"></a>hash slot</h3><p>redis cluster有固定的16384个hash slot，对每个key计算CRC16值，然后对16384取模，可以获取key对应的hash slot</p>
<p>redis cluster中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot</p>
<h3 id="gossip？"><a href="#gossip？" class="headerlink" title="gossip？"></a>gossip？</h3><p>gossip协议包含多种消息，包括ping，pong，meet，fail，等等</p>
<p>Redis 集群是去中心化的，彼此之间状态同步靠 gossip 协议通信，集群的消息有以下几种类型：</p>
<ul>
<li><strong>Meet</strong> 通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群。</li>
<li><strong>Ping</strong> 节点每秒会向集群中其他节点发送 ping 消息，消息中带有自己已知的两个节点的地址、槽、状态信息、最后一次通信时间等。</li>
<li><strong>Pong</strong> 节点收到 ping 消息后会回复 pong 消息，消息中同样带有自己已知的两个节点信息。</li>
<li><strong>Fail</strong> 节点 ping 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-0e5e3f73c7cc427a688c6d45cf1f445a_hd.jpg" alt="img"></p>
<h4 id="redis键的删除策略"><a href="#redis键的删除策略" class="headerlink" title="redis键的删除策略"></a>redis键的删除策略</h4><p>问题：如果一个键过期了，那么它什么时候会被删除呢？有三个答案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在过期时间来临时，立即执行对键的删除操作 .。</span><br></pre></td></tr></table></figure>

<p>这种过期策略对内存友好，但对CPU是非常不友好的。因为还要主动设定定时器并主动删除，即通过CPU换内存（CPU主动删除了内存中的数据嘛，CPU忙，内存空闲）。可以想象一下在大数据大并发的时候，这种机制是多么灾难</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">惰性删除(Lazy Expiration)：redis内部不会监视记录是否过期，但是每次从键空间获取键时，检查记录是否过期。这种技术被称为lazy（惰性）expiration。</span><br></pre></td></tr></table></figure>

<p>与定时删除相反，此删除机制对内存是不友好的对CPU是友好的，惰性删除不会主动去删除已到期(expire)的键，而是等有需要调用的时候再判断，即内存换CPU（内存中有大量残留数据）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定期删除：每隔一段时间，对redis数据库进行一次检查，删除里面的过期键</span><br></pre></td></tr></table></figure>

<p>属于前两种方法的折中.但要注意操作检查执行的时间和频率，如果删除操作做的太频繁，或者检查执行的时间太长，定期策略就会退化成定时策略。</p>
<p>Redis服务器实际使用的是惰性删除和定期删除策略两种策略，配合使用两种策略和在使用CPU和内存找到平衡点。</p>
<h4 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h4><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p>有几种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.先更新redis再更新db</span><br><span class="line">2.先更新db再更新redis</span><br><span class="line">3.先更新DB再删除redis</span><br><span class="line">4.先删除redis再更新DB</span><br><span class="line">5.延迟双删</span><br><span class="line">6.延迟删除等变种</span><br></pre></td></tr></table></figure>



<h4 id="1-先更新redis再更新db"><a href="#1-先更新redis再更新db" class="headerlink" title="1.先更新redis再更新db"></a>1.先更新redis再更新db</h4><p>按下面步骤会有问题,AB是两个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A_update_redis</span><br><span class="line">B_update_redis</span><br><span class="line">B_update_db</span><br><span class="line">A_update_db</span><br></pre></td></tr></table></figure>

<p>最终db是a值但是redis是b值，不一致</p>
<h4 id="2-先更新db再更新redis"><a href="#2-先更新db再更新redis" class="headerlink" title="2.先更新db再更新redis"></a>2.先更新db再更新redis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A_update_db</span><br><span class="line">B_update_db</span><br><span class="line">B_update_redis</span><br><span class="line">A_update_redis</span><br></pre></td></tr></table></figure>

<p>最终db是b值但是redis是a值</p>
<h4 id="3-先更新DB再删除redis"><a href="#3-先更新DB再删除redis" class="headerlink" title="3.先更新DB再删除redis"></a>3.先更新DB再删除redis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A_update_db</span><br><span class="line">B_update_db</span><br><span class="line">B_rm_redis</span><br><span class="line">A_rm_redis</span><br></pre></td></tr></table></figure>

<p>是不是不明白。想不出来怎么不一致了？<br> 不是这样的，没这么简单，第二次rm_redis就会保证后面的redis和db是一致的<br> 实际是下面这种形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A_get_data</span><br><span class="line">redis_cache_miss</span><br><span class="line">A_get_db</span><br><span class="line">B_update_db</span><br><span class="line">B_rm_redis</span><br><span class="line">(此时如果拿db是b值，但是redis没有值)</span><br><span class="line">A_update_redis</span><br></pre></td></tr></table></figure>

<p>依赖于A_update_redis在B_update_db之后，极端情况<br> 此时redis是old，db是new</p>
<h4 id="4-先删除redis再更新DB"><a href="#4-先删除redis再更新DB" class="headerlink" title="4.先删除redis再更新DB"></a>4.先删除redis再更新DB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A_rm_redis</span><br><span class="line">B_get_data</span><br><span class="line">B_redis_miss</span><br><span class="line">B_get_db</span><br><span class="line">B_update_redis</span><br><span class="line">A_update_db</span><br></pre></td></tr></table></figure>

<p>此时redis是old值，db是new值</p>
<h4 id="5-延迟双删"><a href="#5-延迟双删" class="headerlink" title="5.延迟双删"></a>5.延迟双删</h4><p>即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm_redis</span><br><span class="line">update_db</span><br><span class="line">sleep xxx ms</span><br><span class="line">rm_redis</span><br></pre></td></tr></table></figure>

<p>这样叫做双删，最后一次sleep一段时间再rm_redis保证再次读请求回溯打到db，用最新值写redis</p>
<p>作者：赤子心_d709<br>链接：<a href="https://www.jianshu.com/p/125bba448cdd" target="_blank" rel="noopener">https://www.jianshu.com/p/125bba448cdd</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>I/O 多路复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/05/%E8%B7%B3%E8%B7%83%E8%A1%A8/" rel="next" title="跳跃表">
                <i class="fa fa-chevron-left"></i> 跳跃表
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/05/redis%E5%86%99%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E7%90%86/" rel="prev" title="redis写入和删除的原理">
                redis写入和删除的原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="vcomments"></div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avator.png"
                alt="John Doe" />
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=442319&auto=1&height=66"></iframe>

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">206</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            


            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            


          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-学习笔记"><span class="nav-number">1.</span> <span class="nav-text">Redis 学习笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#初识-Redis"><span class="nav-number">1.1.</span> <span class="nav-text">初识 Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-的特性"><span class="nav-number">1.1.1.</span> <span class="nav-text">Redis 的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-的使用场景"><span class="nav-number">1.1.2.</span> <span class="nav-text">Redis 的使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API-的理解和使用"><span class="nav-number">1.2.</span> <span class="nav-text">API 的理解和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">1.2.1.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用命令"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不常用命令"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">不常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#典型使用场景"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">典型使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希"><span class="nav-number">1.2.2.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-1"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表"><span class="nav-number">1.2.3.</span> <span class="nav-text">列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-1"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-2"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-1"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合"><span class="nav-number">1.2.4.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-2"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-3"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-2"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序集合"><span class="nav-number">1.2.5.</span> <span class="nav-text">有序集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-3"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-4"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-3"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#键管理"><span class="nav-number">1.2.6.</span> <span class="nav-text">键管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单个键管理"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">单个键管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历键"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">遍历键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库管理"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">数据库管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.2.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级功能"><span class="nav-number">1.3.</span> <span class="nav-text">高级功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事务"><span class="nav-number">1.3.1.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bitmaps"><span class="nav-number">1.3.2.</span> <span class="nav-text">Bitmaps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-4"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HyperLogLog"><span class="nav-number">1.3.3.</span> <span class="nav-text">HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发布订阅"><span class="nav-number">1.3.4.</span> <span class="nav-text">发布订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-5"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-4"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GEO"><span class="nav-number">1.3.5.</span> <span class="nav-text">GEO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">1.3.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式"><span class="nav-number">1.4.</span> <span class="nav-text">分布式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis实现分布式锁"><span class="nav-number">1.4.1.</span> <span class="nav-text">Redis实现分布式锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存异常"><span class="nav-number">1.5.</span> <span class="nav-text">缓存异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存穿透"><span class="nav-number">1.5.1.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存雪崩"><span class="nav-number">1.5.2.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存击穿"><span class="nav-number">1.5.3.</span> <span class="nav-text">缓存击穿</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#持久化"><span class="nav-number">1.6.</span> <span class="nav-text">持久化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他问题"><span class="nav-number">1.7.</span> <span class="nav-text">其他问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事务-1"><span class="nav-number">1.7.1.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis线程模型"><span class="nav-number">1.7.2.</span> <span class="nav-text">Redis线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#淘汰策略"><span class="nav-number">1.7.3.</span> <span class="nav-text">淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis与Memcached的区别"><span class="nav-number">1.7.4.</span> <span class="nav-text">Redis与Memcached的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何保证缓存与数据库双写时的数据一致性？"><span class="nav-number">1.7.5.</span> <span class="nav-text">如何保证缓存与数据库双写时的数据一致性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><span class="nav-number">1.7.6.</span> <span class="nav-text">假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高并发情况下，对于Redis的更新操作有哪些注意事项？"><span class="nav-number">1.7.7.</span> <span class="nav-text">高并发情况下，对于Redis的更新操作有哪些注意事项？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU"><span class="nav-number">1.7.8.</span> <span class="nav-text">LRU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis的IO复用"><span class="nav-number">1.7.9.</span> <span class="nav-text">Redis的IO复用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#master结点挂了"><span class="nav-number">1.7.9.1.</span> <span class="nav-text">master结点挂了</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#节点间通信机制"><span class="nav-number">1.7.10.</span> <span class="nav-text">节点间通信机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash-slot"><span class="nav-number">1.7.11.</span> <span class="nav-text">hash slot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gossip？"><span class="nav-number">1.7.12.</span> <span class="nav-text">gossip？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis键的删除策略"><span class="nav-number">1.7.12.1.</span> <span class="nav-text">redis键的删除策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#延时双删"><span class="nav-number">1.7.12.2.</span> <span class="nav-text">延时双删</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写"><span class="nav-number">1.7.13.</span> <span class="nav-text">写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-先更新redis再更新db"><span class="nav-number">1.7.13.1.</span> <span class="nav-text">1.先更新redis再更新db</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-先更新db再更新redis"><span class="nav-number">1.7.13.2.</span> <span class="nav-text">2.先更新db再更新redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-先更新DB再删除redis"><span class="nav-number">1.7.13.3.</span> <span class="nav-text">3.先更新DB再删除redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-先删除redis再更新DB"><span class="nav-number">1.7.13.4.</span> <span class="nav-text">4.先删除redis再更新DB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-延迟双删"><span class="nav-number">1.7.13.5.</span> <span class="nav-text">5.延迟双删</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-2"><span class="nav-number">1.8.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>
-->




    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共344.5k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  






  
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine@1.1.4/dist/Valine.min.js"></script>
  <script type="text/javascript">
    new Valine({
        av: AV,
        el: '#vcomments' ,
        verify: false,
        notify: false,
        app_id: 'poAXA1bCt4bcaGmuoHBrU52s-gzGzoHsz',
        app_key: 'ARaHT9OThVx8QqybEjteIed2',
        placeholder: 'Comment input placeholder'
    });
  </script>




  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "./public/search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  





<script type="text/javascript"
color="0,0,255" opacity='0.7' zIndex="-2" count="30" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<script type="text/javascript" src="/js/src/clicklove.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
