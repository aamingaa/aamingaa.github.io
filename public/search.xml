<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ConcurrentHashMap解析</title>
      <link href="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><ol><li><p>存储结构</p><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁<br>（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发<br>度更高（并发度就是 Segment 的个数）。Segment 继承自 ReentrantLock。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">   final int hash;</span><br><span class="line">   final K key;</span><br><span class="line">   volatile V value;</span><br><span class="line">   volatile HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁<br>   （Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发<br>   度更高（并发度就是 Segment 的个数）。<br>   <strong>Segment 继承自 ReentrantLock。</strong></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line">   private static final long serialVersionUID &#x3D; 2249069246763182397L;</span><br><span class="line">   static final int MAX_SCAN_RETRIES &#x3D;</span><br><span class="line">   Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;</span><br><span class="line">   transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">   transient int count;</span><br><span class="line">   transient int modCount;</span><br><span class="line">   transient int threshold;</span><br><span class="line">   final float loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure><p>   默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br></pre></td></tr></table></figure>   <img src="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/1.png" class title="如图"><p>   HashEntry跟HashMap差不多的，但是不同点是，他使用volatile去修饰了他的数据Value还有下一个节点next。</p><h2 id="并发度高的原因"><a href="#并发度高的原因" class="headerlink" title="并发度高的原因"></a>并发度高的原因</h2><p>原理上来说，ConcurrentHashMap 采用了<strong>分段锁</strong>技术，其中 Segment 继承于 ReentrantLock。</p><p>不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</p><p>1.尝试自旋获取锁。</p><p>2.如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get 逻辑比较简单，只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p><p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p><p>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</p><h2 id="jdk1-8他的数据结构"><a href="#jdk1-8他的数据结构" class="headerlink" title="jdk1.8他的数据结构"></a>jdk1.8他的数据结构</h2><p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p><p>跟HashMap很像，也把之前的HashEntry改成了Node，但是作用不变，把值和next采用了volatile去修饰，保证了可见性，并且也引入了红黑树，在链表大于一定值的时候会转换（默认是8）。</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><p>1.根据 key 计算出 hashcode 。</p><p>2.判断是否需要进行初始化。</p><p>3.即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p><p>4.如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p><p>5.如果都不满足，则利用 synchronized 锁写入数据。</p><p>6.如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</p><img src="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/2.png" class title="如图"><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>1.根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p><p>2.如果是红黑树那就按照树的方式获取值。</p><p>3.就不满足那就按照链表的方式遍历获取值。</p><img src="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/3.png" class title="如图">]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap解析</title>
      <link href="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>内部包含了一个 Entry 类型的数组 table,1.8之后改成Node。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;transient Entry[] table;</span><br><span class="line">  transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当<br>成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结<br>果相同的 Entry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//key的hash值，put和get的时候都需要用到它来确定元素在数组中的位置</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="comment">//指向单链表的下一个节点</span></span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="keyword">this</span>.hash = hash;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><img src="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/2.png" class title="流程图"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法，会先调用一个hash()方法，得到当前key的一个hash值，</span></span><br><span class="line"><span class="comment">//用于确定当前key应该存放在数组的哪个下标位置</span></span><br><span class="line"><span class="comment">//这里的 hash方法，我们姑且先认为是key.hashCode()，其实不是的，一会儿细讲</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把hash值和当前的key，value传入进来</span></span><br><span class="line"><span class="comment">//这里onlyIfAbsent如果为true，表明不能修改已经存在的值，因此我们传入false</span></span><br><span class="line"><span class="comment">//evict只有在方法 afterNodeInsertion(boolean evict) &#123; &#125;用到，可以看到它是一个空实现，因此不用关注这个参数</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">//判断table是否为空，如果空的话，会先调用resize扩容</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">n = (tab = resize()).length;</span><br><span class="line"><span class="comment">//根据当前key的hash值找到它在数组中的下标，判断当前下标位置是否已经存在元素，</span></span><br><span class="line"><span class="comment">//若没有，则把key、value包装成Node节点，直接添加到此位置。</span></span><br><span class="line"><span class="comment">// i = (n - 1) &amp; hash 是计算下标位置的，为什么这样算，后边讲</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">//如果当前位置已经有元素了，分为三种情况。</span></span><br><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">//1.当前位置元素的hash值等于传过来的hash，并且他们的key值也相等，</span></span><br><span class="line"><span class="comment">//则把p赋值给e，跳转到①处，后续需要做值的覆盖处理</span></span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">e = p;</span><br><span class="line"><span class="comment">//2.如果当前是红黑树结构，则把它加入到红黑树 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//3.说明此位置已存在元素，并且是普通链表结构，则采用尾插法，把新节点加入到链表尾部</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果头结点的下一个节点为空，则插入新节点</span></span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果在插入的过程中，链表长度超过了8，则转化为红黑树</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line"><span class="comment">//插入成功之后，跳出循环，跳转到①处</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若在链表中找到了相同key的话，直接退出循环，跳转到①处</span></span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">p = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//① </span></span><br><span class="line"><span class="comment">//1.说明发生了碰撞，e代表的是旧值，因此节点位置不变，但是需要替换为新值</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">V oldValue = e.value;</span><br><span class="line"><span class="comment">//用新值替换旧值，并返回旧值。</span></span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">e.value = value;</span><br><span class="line"><span class="comment">//看方法名字即可知，这是在node被访问之后需要做的操作。其实此处是一个空实现，</span></span><br><span class="line"><span class="comment">//只有在 LinkedHashMap才会实现，用于实现根据访问先后顺序对元素进行排序，hashmap不提供排序功能</span></span><br><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="comment">//void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span></span><br><span class="line">afterNodeAccess(e);</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fail-fast机制</span></span><br><span class="line">++modCount;</span><br><span class="line"><span class="comment">//如果当前数组中的元素个数超过阈值，则扩容</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">resize();</span><br><span class="line"><span class="comment">//同样的空实现</span></span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hash方法"><a href="#Hash方法" class="headerlink" title="Hash方法"></a>Hash方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">两个值进行与运算，结果会趋向于<span class="number">0</span>；或运算，结果会趋向于<span class="number">1</span>；而只有异或运算，<span class="number">0</span>和<span class="number">1</span>的比例可以达到<span class="number">1</span>:<span class="number">1</span>的平衡状态。（非呢？别扯犊子了，两个值怎么做非运算。。。）</span><br><span class="line">所以，异或运算之后，可以让结果的随机性更大，而随机性大了之后，哈希碰撞的概率当然就更小了</span><br></pre></td></tr></table></figure><p>这里，会先判断key是否为空，若为空则返回0。这也说明了hashMap是支持key传 null 的。若非空，则先计算key的hashCode值，赋值给h，然后把h右移16位，并与原来的h进行异或处理。为什么要这样做，这样做有什么好处呢？</p><p>可以看到，其实相当于，我们把高16位值和当前h的低16位进行了混合，这样可以尽量保留高16位的特征，从而降低哈希碰撞的概率。</p><p>思考一下，为什么这样做，就可以降低哈希碰撞的概率呢？先别着急，我们需要结合 i = (n - 1) &amp; hash 这一段运算来理解。</p><p> <strong>i = (n - 1) &amp; hash</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y :       10110010</span><br><span class="line">x-1 :     00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure><p>这个性质和 y 对 x 取模效果是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y :   10110010</span><br><span class="line">x :   00010000</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><img src="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/3.png" class title="流程图"><h3 id="为什么HashMap链表会形成死循环"><a href="#为什么HashMap链表会形成死循环" class="headerlink" title="为什么HashMap链表会形成死循环"></a>为什么HashMap链表会形成死循环</h3><p>准确的讲应该是 JDK1.7 的 HashMap 链表会有死循环的可能，因为JDK1.7是采用的头插法，在多线程环境下有可能会使链表形成环状，从而导致死循环。JDK1.8做了改进，用的是尾插法，不会产生死循环。</p><h3 id="JDK7与JDK8中HashMap的不同点"><a href="#JDK7与JDK8中HashMap的不同点" class="headerlink" title="JDK7与JDK8中HashMap的不同点"></a>JDK7与JDK8中HashMap的不同点</h3><ul><li><p>JDK8中使用了红黑树</p></li><li><p>JDK7中链表的插入使用的头插法（扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致CPU飙升），JDK8中链表使用的尾插法（JDK8中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法</p></li><li></li></ul><h2 id="那为啥用16不用别的呢？"><a href="#那为啥用16不用别的呢？" class="headerlink" title="那为啥用16不用别的呢？"></a>那为啥用16不用别的呢？</h2><p>因为在使用是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。</p><p>只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。这是为了<strong>实现均匀分布</strong>。</p><h2 id="什么时候变成红黑树"><a href="#什么时候变成红黑树" class="headerlink" title="什么时候变成红黑树"></a>什么时候变成红黑树</h2><p>一个是链表长度到8,一个是数组长度到64.</p><h2 id="HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？"><a href="#HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？" class="headerlink" title="HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？"></a>HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？</h2><p>1.Hashtable</p><p>2.ConcurrentHashMap</p><p>不过出于线程并发度的原因，我都会舍弃前两者使用最后的ConcurrentHashMap，他的性能和效率明显高于前两者。</p><h2 id="Hashtable效率低"><a href="#Hashtable效率低" class="headerlink" title="Hashtable效率低"></a>Hashtable效率低</h2><p>他在对数据操作的时候都会上锁，所以效率比较低下。</p><h2 id="为啥Hashtable-是不允许键或值为-null-的，HashMap-的键值则都可以为-null？"><a href="#为啥Hashtable-是不允许键或值为-null-的，HashMap-的键值则都可以为-null？" class="headerlink" title="为啥Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null？"></a>为啥Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null？</h2><p>Hashtable使用的是<strong>安全失败机制（fail-safe）</strong>，这种机制会使你此次读到的数据不一定是最新的数据。</p><p>如果你使用null值，就会使得其无法判断对应的key是不存在还是为空</p><h2 id="和HashTable的对比"><a href="#和HashTable的对比" class="headerlink" title="和HashTable的对比"></a>和HashTable的对比</h2><ul><li><p>HashTable 使用 synchronized 来进行同步。</p></li><li><p>HashMap 可以插入键为 null 的 Entry。(因为Hashtable在我们put 空值的时候会直接抛空指针异常，但是HashMap却做了特殊处理,hash)</p></li><li><p>初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75</p></li><li><p>扩容机制不同：当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1。</p></li><li><p>迭代器不同：HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。</p></li></ul><h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p>fail-fast的字面意思是“快速失败”。当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，需要比较操作前后 modCount 是否改变，如果改变了说明集合结构被改变，需要抛出ConcurrentModificationException,防止继续遍历。</p><h2 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h2><p>当我们对集合结构上做出改变的时候，fail-fast机制就会抛出异常。但是，对于采用fail-safe机制来说，就不会抛出异常(大家估计看到safe两个字就知道了)。</p><p>这是因为，当集合的结构被改变的时候，fail-safe机制会在复制原集合的一份数据出来，然后在复制的那份数据遍历。</p><p>因此，虽然fail-safe不会抛出异常，但存在以下缺点：</p><p>1.复制时需要额外的空间和时间上的开销。</p><p>2.不能保证遍历的是最新内容</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>换电脑了迁移hexo博客(Win-&gt;MAC)</title>
      <link href="/2020/06/26/%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E8%BF%81%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/06/26/%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E8%BF%81%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>1.找到自己Windows的hexo根目录</p><p>2.在 Mac安装git和node.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先在自己电脑上装好node和git（首先确保brew安装好了）</span><br><span class="line">brew install git</span><br><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>3.安装hexo</p><p>用node.js来安装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo g</span><br></pre></td></tr></table></figure><p>4.初始化hexo目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">新建一个hexo目录，</span><br><span class="line"></span><br><span class="line">mkdir bolg</span><br><span class="line"></span><br><span class="line">cd blog</span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line">在用hexo s测试是否成功，打开localhost:4000查看本地</span><br></pre></td></tr></table></figure><p>5.生成SSH密钥，关联github</p><p>先查看本地的SSH key: cd ~/.ssh<br>(我是新mac电脑，所以没有的，直接生成密钥）<br>$ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a>“    后面那个是注册邮箱</p><p>进入.ssh文件夹： cd ~/.ssh，然后打开里面的 id_rsa.pub文件，里面的内容就是 SSH key，复制全部内容；</p><p>网页打开 github 的设置：Settings -&gt; SSH and GPG keys，点击绿色的按钮 New SSH key，然后在输入框中输入刚才复制的内容；</p><p>保存后，github 会向你的邮箱发送一个验证链接（记得要去登录邮箱验证，不然之后的 hexo d 部署会一直不成功的！）；</p><p>测试一下是否成功：ssh <a href="mailto:git@github.com">git@github.com</a>，<br>看到以下即成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PTY allocation request failed on channel <span class="number">0</span></span><br><span class="line">Hi gjincai! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">Connection to github.com closed.</span></span><br></pre></td></tr></table></figure><p>6.文件配置转移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windows 下的博客根目录 hexo，复制该目录下的：_config.yml, scaffolds, source, themes,<span class="keyword">package</span>.json；</span><br><span class="line">mac 下的博客根目录 hexo，把刚才复制的内容，直接覆盖替换相同的文件文件夹。</span><br></pre></td></tr></table></figure><p> 7.设置个人信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname”</span><br><span class="line">git config --global user.email youremail@example.com</span><br></pre></td></tr></table></figure><p>到这就好了，和往常一样hexo g        hexo d发布文章吧！</p><p>结果会提示ERROR Deployer not found: git</p><p>安装以下再尝试：npm install hexo-deployer-git –save（若提示有关权限不足的，加sudo，反正我是遇到了）</p><p>之后就能正常发布文章了！nice</p>]]></content>
      
      
      <categories>
          
          <category> hexo相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis缓存穿透、击穿、雪崩等</title>
      <link href="/2020/06/26/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%AD%89/"/>
      <url>/2020/06/26/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h2><p>正常情况下，查询的数据都存在，如果请求一个不存在的数据，也就是缓存和数据库都查不到这个数据，每次都会去数据库查询，这种查询不存在数据的现象我们称为缓存穿透</p><h3 id="穿透带来的问题"><a href="#穿透带来的问题" class="headerlink" title="穿透带来的问题"></a>穿透带来的问题</h3><p>如果每次都拿一个不存在的id去查询数据库，可能会导致你的数据库压力增大</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>缓存空值<br> 之所以发生穿透，是因为缓存中没有存储这些数据的key，从而每次都查询数据库<br>我们可以为这些key在缓存中设置对应的值为null，后面查询这个key的时候就不用查询数据库了<br>当然为了健壮性，我们要对这些key设置过期时间，以防止真的有数据</li><li>BloomFilter<br>BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中<br>我们把有数据的key都放到BloomFilter中，每次查询的时候都先去BloomFilter判断，如果没有就直接返回null<br>注意BloomFilter没有删除操作，对于删除的key，查询就会经过BloomFilter然后查询缓存再查询数据库，所以BloomFilter可以结合缓存空值用，对于删除的key，可以在缓存中缓存null</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>在高并发的情况下，大量的请求同时查询同一个key时，此时这个key正好失效了，就会导致同一时间，这些请求都会去查询数据库，这样的现象我们称为缓存击穿</p><h3 id="击穿带来的问题"><a href="#击穿带来的问题" class="headerlink" title="击穿带来的问题"></a>击穿带来的问题</h3><p>会造成某一时刻数据库请求量过大</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>1.使用互斥锁(mutex key)</strong></p><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p><p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">String value = redis.get(key);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//代表缓存值过期</span></span><br><span class="line"><span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line"><span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//代表设置成功</span></span><br><span class="line">value = db.get(key);</span><br><span class="line">redis.set(key, value, expire_secs);</span><br><span class="line">redis.del(key_mutex);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">sleep(<span class="number">50</span>);</span><br><span class="line">get(key);</span><br><span class="line"><span class="comment">//重试</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.”永远不过期”**</p><p>这里的“永远不过期”包含两层意思：</p><p>(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。</p><p>(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期</p><p>从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">V v = redis.get(key);</span><br><span class="line">String value = v.getValue();</span><br><span class="line"><span class="keyword">long</span> timeout = v.getTimeout();</span><br><span class="line"><span class="keyword">if</span> (v.timeout &lt;= System.currentTimeMillis()) &#123;</span><br><span class="line"><span class="comment">// 异步更新后台异常执行  </span></span><br><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String keyMutex = <span class="string">"mutex:"</span> + key;</span><br><span class="line"><span class="keyword">if</span> (redis.setnx(keyMutex, <span class="string">"1"</span>)) &#123;</span><br><span class="line"><span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">redis.expire(keyMutex, <span class="number">3</span> * <span class="number">60</span>);</span><br><span class="line">String dbValue = db.get(key);</span><br><span class="line">redis.set(key, dbValue);</span><br><span class="line">redis.delete(keyMutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了</p><h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效</li><li>ehcache本地缓存 + Hystrix限流&amp;降级<br>ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵<br>使用 Hystrix进行限流 &amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑</li><li>在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了</li><li>热点数据永不过期，参考上文</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阻塞、同步、乐观悲观相关概念</title>
      <link href="/2020/06/25/%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E4%B9%90%E8%A7%82%E6%82%B2%E8%A7%82%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/06/25/%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E4%B9%90%E8%A7%82%E6%82%B2%E8%A7%82%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>当某个任务在执行过程中发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；</p><h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><p>当某个任务在执行过程中发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直处于等待状态。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>当多个任务要发生时，这些任务必须逐个地进行，一个任务的执行会导致整个流程的暂时等待，这些事件不是并发地执行的；</p><h2 id="非同步"><a href="#非同步" class="headerlink" title="非同步"></a>非同步</h2><p>当多个任务要发生时，这些任务可以并发地执行，一个任务的执行不会导致整个流程的暂时等待。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。</p><p>共享锁【Shared lock】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p><p>排他锁【Exclusive lock】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized的相关性质</title>
      <link href="/2020/06/24/synchronized%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/"/>
      <url>/2020/06/24/synchronized%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h2><p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>1.同步一个代码块</p><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.同步一个方法</p><p>作用于同一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.同步一个类</p><p>作用于整个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.同步一个静态方法</p><p>整个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和volatile的对比"><a href="#和volatile的对比" class="headerlink" title="和volatile的对比"></a>和volatile的对比</h2><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。自旋锁的思想是让一个线程在请求一个共享数据的锁时自旋一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。<br>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行循环操作占用 CPU 时间，它只适用于共享数据的<br>锁定状态很短的场景。<br>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数<br>及锁的拥有者的状态来决定。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。<br>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成<br>私有数据对待，也就可以将它们的锁进行消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次就可以了。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>自旋锁的目标是降低线程切换的成本。</p><blockquote><p><strong>加锁</strong></p></blockquote><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中<strong>创建用于存储锁记录的空间</strong>，并将对象头中的Mark Word复制到锁记录中，官方称为<strong>Displaced Mark Word</strong>。然后线程尝试使用CAS<strong>将对象头中的Mark Word替换为指向锁记录的指针</strong>。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><blockquote><p><strong>解锁</strong></p></blockquote><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗</strong>。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，同时使用 CAS 操作将线程 ID 记录到 Mark Word<br>中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。<br>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定<br>状态或者轻量级锁状态。</p><h2 id="synchronized和volatile的比较"><a href="#synchronized和volatile的比较" class="headerlink" title="synchronized和volatile的比较"></a>synchronized和volatile的比较</h2><p>1.volatile本质是告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取，synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p><p>2.volatile仅能用在变量级别，而synchronized可以使用在变量、方法、类级别。</p><p>3.volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</p><p>4.volatile不会造成线程阻塞，synchronized可能会造成线程阻塞。</p><p>5.volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><img src="/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1.png" class title="布隆过滤器">]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CAS</title>
      <link href="/2020/06/24/CAS/"/>
      <url>/2020/06/24/CAS/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="阻塞同步和非阻塞同步"><a href="#阻塞同步和非阻塞同步" class="headerlink" title="阻塞同步和非阻塞同步"></a>阻塞同步和非阻塞同步</h2><p>阻塞同步需要线程阻塞和唤醒所带来的性能问题，它属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><h2 id="CAS是什么"><a href="#CAS是什么" class="headerlink" title="CAS是什么"></a>CAS是什么</h2><p>我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数<br>据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要<br>将线程阻塞，因此这种同步操作称为非阻塞同步。<br>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件<br>支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是<br>内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。<br>以下代码使用了 AtomicInteger 执行了自增的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示<br>操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt()<br>来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。<br>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">   var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有</span><br><span class="line">被改变过。</span><br><span class="line">J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版</span><br><span class="line">本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统</span><br><span class="line">的互斥同步可能会比原子类更高效。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>volatile的性质</title>
      <link href="/2020/06/24/volatile%E7%9A%84%E6%80%A7%E8%B4%A8/"/>
      <url>/2020/06/24/volatile%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="说说你对volatile关键字的理解"><a href="#说说你对volatile关键字的理解" class="headerlink" title="说说你对volatile关键字的理解"></a>说说你对volatile关键字的理解</h2><p>就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性：</p><p>1 . 保证了不同线程对该变量操作的内存可见性;</p><p>2 . 禁止指令重排序</p><h2 id="volatile关键字如何满足并发编程的三大特性的？"><a href="#volatile关键字如何满足并发编程的三大特性的？" class="headerlink" title="volatile关键字如何满足并发编程的三大特性的？"></a>volatile关键字如何满足并发编程的三大特性的？</h2><p>重提volatile变量规则： 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。</p><h2 id="volatile可以保证原子性么？"><a href="#volatile可以保证原子性么？" class="headerlink" title="volatile可以保证原子性么？"></a>volatile可以保证原子性么？</h2><p>不能。比如对于volatile++操作,这里的操作inc++是个复合操作：</p><p><strong>i++的过程可以分为三步，首先获取i的值，其次对i的值进行加1，最后将得到的新值写会到缓存中。</strong></p><p>首先线程A读取了i的变量的值，i为10,  这个时候线程切换到了B，线程B同样从主内存中读取i的值，由于线程A没有对i做过任何修改，此时线程B获取到的i仍然是10。线程B为i执行了加1的操作，但是没有刷新到主内存中，这个时候又切换到了A线程，A线程直接对工作内存中的10进行加1运输（因为A线程已经读取过i的值了），由于线程B并未写入i的最新值，这个时候A线程的工内存中的10不会失效。 最后，线程A将i=11写入主内存中，线程B也将i=11写入主内存中。 始终需要记住，i++ 的操作是3步骤</p><p>有人说，<strong>volatile不是会使缓存行无效的吗</strong>？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。</p><p>又有人说，线程B将11写回主存，<strong>不会把线程A的缓存行设为无效吗</strong>？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。</p><p>综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。</p><h2 id="volatile底层的实现机制？"><a href="#volatile底层的实现机制？" class="headerlink" title="volatile底层的实现机制？"></a>volatile底层的实现机制？</h2><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p><p>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</p><p>1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置 </p><p>2.将当前处理器缓存行的数据写回到系统内存。</p><p>3.这个写回内存的操作会使其他在CPU里缓存了该内存地址的数据无效。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal的原理</title>
      <link href="/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>ThreadLocal 用于提供线程局部变量，在多线程环境可以保证各个线程里的变量独立于其它线程里的变量。</strong></p><p>也就是说 ThreadLocal 可以为每个线程创建一个【单独的变量副本】，相当于线程的 private static 类型变量。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String strLabel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLabel = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        strLabel = <span class="string">"main"</span>;</span><br><span class="line">        threadLabel.set(<span class="string">"main"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                strLabel = <span class="string">"child"</span>;</span><br><span class="line">                threadLabel.set(<span class="string">"child"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保证线程执行完毕</span></span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"strLabel = "</span> + strLabel);</span><br><span class="line">        System.out.println(<span class="string">"threadLabel = "</span> + threadLabel.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strLabel = child</span><br><span class="line">threadLabel = main</span><br></pre></td></tr></table></figure><h2 id="Set、Get、Remove"><a href="#Set、Get、Remove" class="headerlink" title="Set、Get、Remove"></a>Set、Get、Remove</h2><p>set(T value) 方法中，首先获取当前线程，然后在获取到当前线程的 ThreadLocalMap，如果 ThreadLocalMap 不为 null，则将 value 保存到 ThreadLocalMap 中，并用当前 ThreadLocal 作为 key；否则创建一个 ThreadLocalMap 并给到当前线程，然后保存 value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，在 get() 方法中也会获取到当前线程的 ThreadLocalMap，如果 ThreadLocalMap 不为 null，则把获取 key 为当前 ThreadLocal 的值；否则调用 setInitialValue() 方法返回初始值，并保存到新创建的 ThreadLocalMap 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 还有一个 remove() 方法，用来移除当前 ThreadLocal 对应的值。同样也是同过当前线程的 ThreadLocalMap 来移除相应的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="存储对象Entry-amp-内存泄漏"><a href="#存储对象Entry-amp-内存泄漏" class="headerlink" title="存储对象Entry&amp;内存泄漏"></a>存储对象Entry&amp;内存泄漏</h2><p>Entry 用于保存一个键值对，其中 key 以弱引用的方式保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存泄漏:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry 继承了 WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，</span><br><span class="line">即 Entry 的 key 是弱引用，</span><br><span class="line">所以 key 会在垃圾回收的时候被回收掉， </span><br><span class="line">而 key 对应的 value 则不会被回收， </span><br><span class="line">这样会导致一种现象：key 为 <span class="keyword">null</span>，value 有值。</span><br></pre></td></tr></table></figure><h2 id="怎么解决内存泄漏"><a href="#怎么解决内存泄漏" class="headerlink" title="怎么解决内存泄漏"></a>怎么解决内存泄漏</h2><p>当使用ThreadLocal保存一个value时，会在ThreadLocalMap中的数组插入一个Entry对象，按理说key-value都应该以强引用保存在Entry对象中，但在ThreadLocalMap的实现中，key被保存到了WeakReference对象中。这就导致了一个问题，ThreadLocal在没有外部强引用时，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><p>解决：使用remove</p><p>调用remove方法，肯定会删除对应的Entry对象</p><img src="/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/1.png" class title="内存模型"><h2 id="为什么要用弱引用"><a href="#为什么要用弱引用" class="headerlink" title="为什么要用弱引用"></a>为什么要用弱引用</h2><p>那换做强引用分析： <code>ThreadLocal</code>对象被两个强引用指向</p><ul><li>强引用： threadlocal1</li><li>强引用： Entry.key</li></ul><p>当我们断开程序中的强引用 <code>threadlocal1</code>时。<code>ThreadLocal</code>对象仍然被强引用<code>Entry.key</code>指向，不会回收，这就造成，<code>ThreadLocal</code>对象与 <code>value</code>都成为了脏数据。</p><h2 id="弱引用带来哪些问题"><a href="#弱引用带来哪些问题" class="headerlink" title="弱引用带来哪些问题"></a>弱引用带来哪些问题</h2><p>不管软引用还是强引用，都可能出现内存泄漏问题，弱引用反而将内存泄漏的程度降低**</p><p>利用弱引用的<strong>Entry会有key为null这个特征</strong>，可以识别哪些是不用的数据，进行清理操作，弱引用 反而提高了ThreadLocal的安全性。事实上当调用<code>ThreadLocal</code>的<code>get(),set(),reomve()</code>方法，都会清除掉线程<code>ThreadLocalMap</code>中所有Entry中Key为null的Value，并将整个Entry设置为null，利于下次内存回收。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的设计原则</title>
      <link href="/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><p><strong>开闭原则：</strong>面向对象设计中最基础的设计原则，指一个软件实体（类、模块、方法等）应该对扩展开放，对修改关闭。它强调用抽象构建框架，用实现扩展细节，提高代码的可复用性和可维护性。例如在版本更新时尽量不修改源代码，但可以增加新功能。</p><p><strong>单一职责原则：</strong>一个类、接口或方法只负责一个职责，可以提高代码可读性和可维护性，降低代码复杂度以及变更引起的风险。</p><p><strong>依赖倒置原则：</strong>程序应该依赖于抽象类或接口，而不是具体的实现类。可以降低代码的耦合度，提高系统的稳定性。</p><p><strong>接口隔离原则：</strong>将不同功能定义在不同接口中实现接口隔离，避免了类依赖它不需要的接口，减少了接口之间依赖的冗余性和复杂性。</p><p><strong>里氏替换原则：</strong>对开闭原则的补充，规定了任何父类可以出现的地方子类都一定可以出现，可以约束继承泛滥，加键程序健壮性。</p><p><strong>迪米特原则：</strong>也叫最少知道原则，每个模块对其他模块都要尽可能少的了解和依赖，可以降低代码耦合度。</p><p><strong>合成/聚合原则：</strong>尽量使用组合(has a)或聚合(contains a)而不是继承关系达到软件复用的目的，可以使系统更加灵活，降低耦合度。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型</title>
      <link href="/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
      <url>/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><strong>静态代理：代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hr</span> <span class="keyword">implements</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我需要找招聘一个员工"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hr hr;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hr = <span class="keyword">new</span> Hr();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hr.findWorker();</span><br><span class="line">        System.out.println(<span class="string">"找到了员工"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Company company=<span class="keyword">new</span> Proxy();</span><br><span class="line">        company.findWorker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理：</strong>动态代理在程序运行时才创建具体的代理类，代理类和被代理类的关系在运行前是不确定的。动态代理的适用性更强，主要分为 JDK 动态代理和 CGLib 动态代理。</p><p> JDK 动态代理：通过 Proxy类的 newInstance 方法获取一个动态代理对象，需要传入三个参数，被代理对象的类加载器、被代理对象实现的接口，以及一个 InvocationHandler 调用处理器实例来指明具体的逻辑，相比静态代理最大的优势是接口中声明的所有方法都被转移到 InvocationHandler 中的 invoke 方法集中处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hr hr = <span class="keyword">new</span> Hr();</span><br><span class="line">        Company proxyHr = (Company) Proxy.newProxyInstance(hr.getClass().getClassLoader(), hr.getClass().getInterfaces(), (proxy, method, args1) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"接收代理请求"</span>);</span><br><span class="line">            Object obj = method.invoke(hr, args1);</span><br><span class="line">            System.out.println(<span class="string">"找到了员工，完成请求"</span>);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;);</span><br><span class="line">        proxyHr.findWorker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VMWARE+Centos8配置静态IP地址</title>
      <link href="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/"/>
      <url>/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/1.png" class title="第一步"><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/2.png" class title="第二步"><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/3.png" class title="第三步"><p>打开网络和共享中心—&gt;更改适配器配置—–&gt;右键VMware Network Adapter—&gt;属性—-&gt;双击IPv4—&gt;</p><p>设置IP地址 以及网关</p><p>网关地址必须和vmwareNAT设置的一致，IP保持同一网段内即可</p><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/4.png" class title="如图所示"><p>重启虚拟机</p><p>使用root 用户修改 linux网络配置</p><p>su root</p><p>vi /etc/sysconfig/network-scripts/ifcfg-ens33</p><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/5.png" class title="如图所示"><p>重启网卡</p><p>nmcli c reload</p><p>配置到这里可以实现本机与虚拟机之间的通信了</p><p>虚拟机连接外网</p><p>如果你本机可以连接外网，但是虚拟机ping baidu.com 返回错误信息了，需要绑定DNS</p><p>vi /etc/resolv.conf （没有此文件新建一个即可）</p><p>nameserver 网关地址</p><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/6.png" class title="如图所示"><blockquote><p>链接：<a href="https://www.jianshu.com/p/6801da089cf2" target="_blank" rel="noopener">https://www.jianshu.com/p/6801da089cf2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker search报错解决方法</title>
      <link href="/2020/06/14/docker-search%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/14/docker-search%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ docker search sameersbn</span><br><span class="line">Error response from daemon: Get https:<span class="comment">//index.docker.io/v1/search?q=sameersbn&amp;n=25: dial tcp: lookup index.docker.io on 192.168.65.1:53: read udp 192.168.65.2:45190-&gt;192.168.65.1:53: i/o timeout</span></span><br></pre></td></tr></table></figure><p>解决方法:</p><p>通过dig @114.114.114.114 registry-1.docker.io找到可用ip</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ dig @<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span> registry-<span class="number">1</span>.docker.io</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG <span class="number">9.8</span><span class="number">.3</span>-P1 &lt;&lt;&gt;&gt; @<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span> registry-<span class="number">1</span>.docker.io</span><br><span class="line">; (<span class="number">1</span> server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: <span class="number">47220</span></span><br><span class="line">;; flags: qr rd ra; QUERY: <span class="number">1</span>, ANSWER: <span class="number">8</span>, AUTHORITY: <span class="number">4</span>, ADDITIONAL: <span class="number">9</span></span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: <span class="number">0</span>, flags:; udp: <span class="number">4096</span></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;registry-<span class="number">1</span>.docker.io.        IN    A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">54.164</span><span class="number">.230</span><span class="number">.151</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">35.169</span><span class="number">.231</span><span class="number">.249</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">34.205</span><span class="number">.207</span><span class="number">.96</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">34.200</span><span class="number">.28</span><span class="number">.105</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">52.204</span><span class="number">.202</span><span class="number">.231</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">54.152</span><span class="number">.209</span><span class="number">.167</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">52.22</span><span class="number">.181</span><span class="number">.254</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">52.54</span><span class="number">.216</span><span class="number">.153</span></span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">1827</span>.awsdns-<span class="number">36</span>.co.uk.</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">1168</span>.awsdns-<span class="number">18</span>.org.</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">513</span>.awsdns-<span class="number">00</span>.net.</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">421</span>.awsdns-<span class="number">52</span>.com.</span><br><span class="line"></span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">ns-<span class="number">421</span>.awsdns-<span class="number">52</span>.com.    <span class="number">148245</span>    IN    A    <span class="number">205.251</span><span class="number">.193</span><span class="number">.165</span></span><br><span class="line">ns-<span class="number">421</span>.awsdns-<span class="number">52</span>.com.    <span class="number">149402</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5301</span>:a500::<span class="number">1</span></span><br><span class="line">ns-<span class="number">513</span>.awsdns-<span class="number">00</span>.net.    <span class="number">149549</span>    IN    A    <span class="number">205.251</span><span class="number">.194</span><span class="number">.1</span></span><br><span class="line">ns-<span class="number">513</span>.awsdns-<span class="number">00</span>.net.    <span class="number">149549</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5302</span>:<span class="number">100</span>::<span class="number">1</span></span><br><span class="line">ns-<span class="number">1168</span>.awsdns-<span class="number">18</span>.org.    <span class="number">148917</span>    IN    A    <span class="number">205.251</span><span class="number">.196</span><span class="number">.144</span></span><br><span class="line">ns-<span class="number">1168</span>.awsdns-<span class="number">18</span>.org.    <span class="number">148917</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5304</span>:<span class="number">9000</span>::<span class="number">1</span></span><br><span class="line">ns-<span class="number">1827</span>.awsdns-<span class="number">36</span>.co.uk. <span class="number">148040</span>    IN    A    <span class="number">205.251</span><span class="number">.199</span><span class="number">.35</span></span><br><span class="line">ns-<span class="number">1827</span>.awsdns-<span class="number">36</span>.co.uk. <span class="number">148040</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5307</span>:<span class="number">2300</span>::<span class="number">1</span></span><br><span class="line"></span><br><span class="line">;; Query time: <span class="number">60</span> msec</span><br><span class="line">;; SERVER: 114.114.114.114#53(114.114.114.114)</span><br><span class="line">;; WHEN: Mon Aug <span class="number">20</span> <span class="number">22</span>:<span class="number">36</span>:<span class="number">29</span> <span class="number">2018</span></span><br><span class="line">;; MSG SIZE  rcvd: <span class="number">493</span></span><br></pre></td></tr></table></figure><p>尝试修改<code>/etc/hosts</code>强制<code>docker.io</code>相关的域名解析到其它可用IP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">54.164</span><span class="number">.230</span><span class="number">.151</span> registry-<span class="number">1</span>.docker.io</span><br></pre></td></tr></table></figure><p>保存后重试，成功！！</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker的安装和基本用法</title>
      <link href="/2020/06/14/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2020/06/14/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Centos安装命令"><a href="#Centos安装命令" class="headerlink" title="Centos安装命令"></a>Centos安装命令</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:<span class="comment">//get.docker.com | bash -s docker --mirror Aliyun</span></span><br></pre></td></tr></table></figure><h2 id="Docker基本用法"><a href="#Docker基本用法" class="headerlink" title="Docker基本用法"></a>Docker基本用法</h2><p>启动docker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>停止docker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p>docker搜索镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p>docker拉取镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull  mysql</span><br></pre></td></tr></table></figure><p>docker启动容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>查看正在运行容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>删除容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm id</span><br></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi id</span><br></pre></td></tr></table></figure><p>查看镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(行为型)</title>
      <link href="/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
      <url>/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CurrentConditionsDisplay implements Observer &#123;</span><br><span class="line">    public CurrentConditionsDisplay(Subject weatherData) &#123;</span><br><span class="line">        weatherData.registerObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(float temp) &#123;</span><br><span class="line">        System.out.println(&quot;Current temp: &quot;+temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StatisticsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">        weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Statistics temp: "</span>+temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            o.update(temperature);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">        CurrentConditionsDisplay currentConditionsDisplay = <span class="keyword">new</span></span><br><span class="line">                CurrentConditionsDisplay(weatherData);</span><br><span class="line">        StatisticsDisplay statisticsDisplay = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">0</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeOrTea</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        boil();</span><br><span class="line">        brew();</span><br><span class="line">        pour();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pour</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"boil"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">CaffeOrTea</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Coffee.brew"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">CaffeOrTea</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Tea.brew"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CaffeeOrTea c=<span class="keyword">new</span> Coffee();</span><br><span class="line">        c.prepare();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>定义一系列算法，封装每个算法，并使它们可以互换。</p><p>设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Quack!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gaga</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Gaga!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> QuackBehavior quackBehavior;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (quackBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">  quackBehavior.quack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.quackBehavior = quackBehavior;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Duck duck = <span class="keyword">new</span> Duck();</span><br><span class="line">    duck.setQuackBehavior(<span class="keyword">new</span> Squeak());</span><br><span class="line">    duck.performQuack();</span><br><span class="line">    duck.setQuackBehavior(<span class="keyword">new</span> Quack());</span><br><span class="line">    duck.performQuack();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(创建型)</title>
      <link href="/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
      <url>/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Ⅰ-懒汉式-线程不安全"><a href="#Ⅰ-懒汉式-线程不安全" class="headerlink" title="Ⅰ 懒汉式-线程不安全"></a>Ⅰ 懒汉式-线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton get <span class="title">uniqueInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅱ-饿汉式-线程安全"><a href="#Ⅱ-饿汉式-线程安全" class="headerlink" title="Ⅱ 饿汉式-线程安全"></a>Ⅱ 饿汉式-线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure><h2 id="Ⅲ-懒汉式-线程安全"><a href="#Ⅲ-懒汉式-线程安全" class="headerlink" title="Ⅲ 懒汉式-线程安全"></a>Ⅲ 懒汉式-线程安全</h2><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待,这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton get <span class="title">uniqueInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅳ-双重校验锁-线程安全"><a href="#Ⅳ-双重校验锁-线程安全" class="headerlink" title="Ⅳ 双重校验锁-线程安全"></a>Ⅳ 双重校验锁-线程安全</h2><p>第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了<br>加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实<br>是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址<br>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在<br>多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用<br>getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被<br>初始化。<br>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    s=<span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                                                                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅴ-静态内部类实现"><a href="#Ⅴ-静态内部类实现" class="headerlink" title="Ⅴ 静态内部类实现"></a>Ⅴ 静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE=<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来<br>实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">  Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// do something with the product</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂方法</p><p>多个工厂，一种抽象产品。例如一个麦当劳店，可以生产多种汉堡，一个肯德基店，也可以生产多种汉堡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">作者：冠状病毒biss</span><br><span class="line">链接：https:<span class="comment">//www.nowcoder.com/discuss/438905?type=all&amp;order=time&amp;pos=&amp;page=1&amp;channel=666&amp;source_id=search_all</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Hamburger <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCFactory</span> <span class="keyword">implements</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MCHamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCFactory</span> <span class="keyword">implements</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KFCHamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃麦当劳汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃肯德基汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HamburgerFactory mcFactory=<span class="keyword">new</span> MCFactory();</span><br><span class="line">    Hamburger hamburger=mcFactory.build();</span><br><span class="line">    hamburger.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>股票问题</title>
      <link href="/2020/06/13/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/06/13/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>股票问题（1）</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min=prices[<span class="number">0</span>],max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            max=Math.max(max,prices[i]-min);</span><br><span class="line">            min=Math.min(min,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>股票问题（2）</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="comment">//    能挣钱就卖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(prices[i]&gt;=prices[i-<span class="number">1</span>])</span><br><span class="line">          &#123;</span><br><span class="line">              ans+=(prices[i]-prices[i-<span class="number">1</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>股票问题 (3)</p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: [3,3,5,0,0,3,1,4]<br>输出: 6<br>解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        对于任意一天考虑四个变量:</span></span><br><span class="line"><span class="comment">        fstBuy: 在该天第一次买入股票可获得的最大收益 </span></span><br><span class="line"><span class="comment">        fstSell: 在该天第一次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secBuy: 在该天第二次买入股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secSell: 在该天第二次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        分别对四个变量进行相应的更新, 最后secSell就是最大</span></span><br><span class="line"><span class="comment">        收益值(secSell &gt;= fstSell)</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">int</span> fstBuy = Integer.MIN_VALUE, fstSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> secBuy = Integer.MIN_VALUE, secSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            fstBuy = Math.max(fstBuy, -p);</span><br><span class="line">            fstSell = Math.max(fstSell, fstBuy + p);</span><br><span class="line">            secBuy = Math.max(secBuy, fstSell - p);</span><br><span class="line">            secSell = Math.max(secSell, secBuy + p); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>股票(4)</p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: [2,4,1], k = 2<br>输出: 2<br>解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        当k大于等于数组长度一半时, 问题退化为贪心问题此时采用 买卖股票的最佳时机 II</span></span><br><span class="line"><span class="comment">        的贪心方法解决可以大幅提升时间性能, 对于其他的k, 可以采用 买卖股票的最佳时机 III</span></span><br><span class="line"><span class="comment">        的方法来解决, 在III中定义了两次买入和卖出时最大收益的变量, 在这里就是k租这样的</span></span><br><span class="line"><span class="comment">        变量, 即问题IV是对问题III的推广, t[i][0]和t[i][1]分别表示第i比交易买入和卖出时</span></span><br><span class="line"><span class="comment">        各自的最大收益</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= prices.length/<span class="number">2</span>) <span class="keyword">return</span> greedy(prices);</span><br><span class="line">        <span class="keyword">int</span>[][] t = <span class="keyword">new</span> <span class="keyword">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            t[i][<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            t[<span class="number">0</span>][<span class="number">0</span>] = Math.max(t[<span class="number">0</span>][<span class="number">0</span>], -p);</span><br><span class="line">            t[<span class="number">0</span>][<span class="number">1</span>] = Math.max(t[<span class="number">0</span>][<span class="number">1</span>], t[<span class="number">0</span>][<span class="number">0</span>] + p);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                t[i][<span class="number">0</span>] = Math.max(t[i][<span class="number">0</span>], t[i-<span class="number">1</span>][<span class="number">1</span>] - p);</span><br><span class="line">                t[i][<span class="number">1</span>] = Math.max(t[i][<span class="number">1</span>], t[i][<span class="number">0</span>] + p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t[k-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>])</span><br><span class="line">                max += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/2020/05/31/ArrayList/"/>
      <url>/2020/05/31/ArrayList/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机面试问题</title>
      <link href="/2020/05/31/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/2020/05/31/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-各个垃圾回收器有什么区别？"><a href="#1-各个垃圾回收器有什么区别？" class="headerlink" title="1.各个垃圾回收器有什么区别？"></a>1.各个垃圾回收器有什么区别？</h2><h2 id="2-什么情况下会Stop-The-World？"><a href="#2-什么情况下会Stop-The-World？" class="headerlink" title="2.什么情况下会Stop The World？"></a>2.什么情况下会Stop The World？</h2><h2 id="3-G1和CMS的区别？"><a href="#3-G1和CMS的区别？" class="headerlink" title="3.G1和CMS的区别？"></a>3.G1和CMS的区别？</h2><h2 id="4-什么时候会STOP-THE-WORLD？"><a href="#4-什么时候会STOP-THE-WORLD？" class="headerlink" title="4.什么时候会STOP THE WORLD？"></a>4.什么时候会STOP THE WORLD？</h2>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型(一)</title>
      <link href="/2020/05/30/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/05/30/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-内存模型的定义"><a href="#1-内存模型的定义" class="headerlink" title="1.内存模型的定义"></a>1.内存模型的定义</h2><p>Java 内存模型试图来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，又在CPU里加了好几层高速缓存。</p><p>在Java内存模型里，对上述的优化又进行了一些抽象。JMM规定所有变量都是存在主存中的，每个线程又包含自己的工作内存，也就是CPU上的寄存器或者高速缓存。所以线程的操作都只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</p><img src="/2020/05/30/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/JMM.png" class title="this is} ## 2.内存间交互操作 {% asset_img 1.png 操作"><p>read：把一个变量的值从主内存传输到工作内存中<br>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中<br>use：把工作内存中一个变量的值传递给执行引擎<br>assign：把一个从执行引擎接收到的值赋给工作内存的变量<br>store：把工作内存的一个变量的值传送到主内存中<br>write：在 store 之后执行，把 store 得到的值放入主内存的变量中<br>lock：作用于主内存的变量<br>unlock</p><h2 id="3-内存模型三大特性"><a href="#3-内存模型三大特性" class="headerlink" title="3.内存模型三大特性"></a>3.内存模型三大特性</h2><p>1.原子性：</p><p><strong>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。</strong></p><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int<br>类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的<br>64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以<br>不具备原子性。</p><p>2.可见性</p><p><strong>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。</strong>Java 内存模型是通过在变量修改后将新<br>值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引<br>用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><p>3.有序性</p><p>有序性是指：<strong>在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因</strong><br><strong>为发生了指令重排序。</strong>在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程<br>程序的执行，却会影响到多线程并发执行的正确性。<br>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test1</title>
      <link href="/2020/05/25/test1/"/>
      <url>/2020/05/25/test1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/05/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/05/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>##第一章</p><p>内容</p><hr><p>##第二章</p><p>##<a href="https://blog.csdn.net/xjm850552586/article/details/84101345?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/25/hello-world/"/>
      <url>/2020/05/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
