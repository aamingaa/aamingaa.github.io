<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rpc项目总结</title>
      <link href="/2020/11/19/rpc%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2020/11/19/rpc%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="kyrio序列化"><a href="#kyrio序列化" class="headerlink" title="kyrio序列化"></a>kyrio序列化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Kryo序列化类，Kryo序列化效率很高，但是只兼容 Java 语言</span><br><span class="line"> *</span><br><span class="line"> * @author shuang.kou</span><br><span class="line"> * @createTime 2020年05月13日 19:29:00</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Slf4j</span><br><span class="line">public class KryoSerializer implements Serializer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 由于 Kryo 不是线程安全的。每个线程都应该有自己的 Kryo，Input 和 Output 实例。</span><br><span class="line">     * 所以，使用 ThreadLocal 存放 Kryo 对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final ThreadLocal&lt;Kryo&gt; kryoThreadLocal &#x3D; ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        Kryo kryo &#x3D; new Kryo();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        kryo.setReferences(true); &#x2F;&#x2F;默认值为true,是否关闭注册行为,关闭之后可能存在序列化问题，一般推荐设置为 true</span><br><span class="line">        kryo.setRegistrationRequired(false); &#x2F;&#x2F;默认值为false,是否关闭循环引用，可以提高性能，但是一般不推荐设置为 true</span><br><span class="line">        return kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte[] serialize(Object obj) &#123;</span><br><span class="line">        try (ByteArrayOutputStream byteArrayOutputStream &#x3D; new ByteArrayOutputStream();</span><br><span class="line">             Output output &#x3D; new Output(byteArrayOutputStream)) &#123;</span><br><span class="line">            Kryo kryo &#x3D; kryoThreadLocal.get();</span><br><span class="line">            &#x2F;&#x2F; Object-&gt;byte:将对象序列化为byte数组</span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            return output.toBytes();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new SerializeException(&quot;序列化失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T deserialize(byte[] bytes, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        try (ByteArrayInputStream byteArrayInputStream &#x3D; new ByteArrayInputStream(bytes);</span><br><span class="line">             Input input &#x3D; new Input(byteArrayInputStream)) &#123;</span><br><span class="line">            Kryo kryo &#x3D; kryoThreadLocal.get();</span><br><span class="line">            &#x2F;&#x2F; byte-&gt;Object:从byte数组中反序列化出对对象</span><br><span class="line">            Object o &#x3D; kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            return clazz.cast(o);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new SerializeException(&quot;反序列化失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>放在静态代码块中,new 一个Bootstrap,初始化Kryo序列化类，调用Bootstrap.group(eventLoopGroup),设置Nio模式，用option设置连接超时时间，handler 里定义 ch.pipeline().addLast，自定义序列化编解码器和解码器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup eventLoopGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">      b &#x3D; new Bootstrap();</span><br><span class="line">      KryoSerializer kryoSerializer &#x3D; new KryoSerializer();</span><br><span class="line">      b.group(eventLoopGroup)</span><br><span class="line">              .channel(NioSocketChannel.class)</span><br><span class="line">              .handler(new LoggingHandler(LogLevel.INFO))</span><br><span class="line">              &#x2F;&#x2F; 连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span><br><span class="line">              &#x2F;&#x2F;  如果 15 秒之内没有发送数据给服务端的话，就发送一次心跳请求</span><br><span class="line">              .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)</span><br><span class="line">              .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  protected void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                      &#x2F;*</span><br><span class="line">                       自定义序列化编解码器</span><br><span class="line">                       *&#x2F;</span><br><span class="line">                      &#x2F;&#x2F; RpcResponse -&gt; ByteBuf</span><br><span class="line">                      ch.pipeline().addLast(new NettyKryoDecoder(kryoSerializer, RpcResponse.class));</span><br><span class="line">                      &#x2F;&#x2F; ByteBuf -&gt; RpcRequest</span><br><span class="line">                      ch.pipeline().addLast(new NettyKryoEncoder(kryoSerializer, RpcRequest.class));</span><br><span class="line">                      ch.pipeline().addLast(new NettyClientHandler());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h5><p>调用Bootstrap的connect连接，返回ChannelFuture.channel，返回一个futureChannel，通过 <code>Channel</code> 向服务端发送消息<code>RpcRequest</code></p><p>发送成功后，阻塞等待 ，直到<code>Channel</code>关闭，拿到服务端返回的结果 <code>RpcResponse</code>    AttributeKey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f &#x3D; b.connect(host, port).sync();</span><br><span class="line">logger.info(&quot;client connect  &#123;&#125;&quot;, host + &quot;:&quot; + port);</span><br><span class="line">Channel futureChannel &#x3D; f.channel();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">            if (futureChannel !&#x3D; null) &#123;</span><br><span class="line">                futureChannel.writeAndFlush(rpcRequest).addListener(future -&gt; &#123;</span><br><span class="line">                  ...</span><br><span class="line">                &#125;);</span><br><span class="line">                futureChannel.closeFuture().sync();</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AttributeKey&lt;RpcResponse&gt; key &#x3D; AttributeKey.valueOf(&quot;rpcResponse&quot;);</span><br><span class="line">return futureChannel.attr(key).get();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.简单的实现</title>
      <link href="/2020/11/19/1-%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/11/19/1-%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_40856284/article/details/106972652" target="_blank" rel="noopener">https://blog.csdn.net/qq_40856284/article/details/106972652</a></p><p>本章对应的commit为<a href="https://github.com/CN-GuoZiyang/My-RPC-Framework/commit/73aa960b0c457770859f81a3210de56370862439" target="_blank" rel="noopener">73aa960</a>，完整项目为<a href="https://github.com/CN-GuoZiyang/My-RPC-Framework/tree/73aa960b0c457770859f81a3210de56370862439" target="_blank" rel="noopener">https://github.com/CN-GuoZiyang/My-RPC-Framework/tree/73aa960b0c457770859f81a3210de56370862439</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用（抄）一下Guide哥的一张图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jbi1ndW96aXlhbmcuZ2l0aHViLmlvL015LVJQQy1GcmFtZXdvcmsvaW1nL1JQQyVFNiVBMSU4NiVFNiU5RSVCNiVFNiU4MCU5RCVFOCVCNyVBRi5qcGVn?x-oss-process=image/format,png" alt="RPC框架思路"></p><p>那么我们首先要思考，RPC框架的原理。</p><p>原理很简单，客户端和服务端都可以访问到通用的接口，但是只有服务端有这个接口的实现类，客户端调用这个接口的方式，是通过网络传输，告诉服务端我要调用这个接口，服务端收到之后找到这个接口的实现类，并且执行，将执行的结果返回给客户端，作为客户端调用接口方法的返回值。</p><p>原理很简单，但是实现值得商榷，例如客户端怎么知道服务端的地址？客户端怎么告诉服务端我要调用的接口？客户端怎么传递参数？只有接口客户端怎么生成实现类……等等等等。</p><p>这一章，我们就来探讨一个最简单的实现。一个最简单的实现，基于这样一个假设，那就是客户端已经知道了服务端的地址，这部分会由后续的服务发现机制完善。</p><h2 id="通用接口"><a href="#通用接口" class="headerlink" title="通用接口"></a>通用接口</h2><p>我们先把通用的接口写好，然后再来看怎么实现客户端和服务端。</p><p>接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(HelloObject object)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>hello方法需要传递一个对象，HelloObject对象，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>注意这个对象需要实现<code>Serializable</code>接口，因为它需要在调用过程中从客户端传递给服务端。</p><p>接着我们在服务端对这个接口进行实现，实现的方式也很简单，返回一个字符串就行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(HelloObject object)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"接收到：&#123;&#125;"</span>, object.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是掉用的返回值，id="</span> + object.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><p>严格来说，这并不能算是协议……但也大致算一个传输格式吧。</p><p>我们来思考一下，服务端需要哪些信息，才能唯一确定服务端需要调用的接口的方法呢？</p><p>首先，就是接口的名字，和方法的名字，但是由于方法重载的缘故，我们还需要这个方法的所有参数的类型，最后，客户端调用时，还需要传递参数的实际值，那么服务端知道以上四个条件，就可以找到这个方法并且调用了。我们把这四个条件写到一个对象里，到时候传输时传输这个对象就行了。即<code>RpcRequest</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用接口名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure><p>参数类型我是直接使用Class对象，其实用字符串也是可以的。</p><p>那么服务器调用完这个方法后，需要给客户端返回哪些信息呢？如果调用成功的话，显然需要返回值，如果调用失败了，就需要失败的信息，这里封装成一个<code>RpcResponse</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer statusCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态补充信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setStatusCode(ResponseCode.SUCCESS.getCode());</span><br><span class="line">        response.setData(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">fail</span><span class="params">(ResponseCode code)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setStatusCode(code.getCode());</span><br><span class="line">        response.setMessage(code.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure><p>这里还多写了两个静态方法，用于快速生成成功与失败的响应对象。其中，statusCode属性可以自行定义，客户端服务端一致即可。</p><h2 id="客户端的实现——动态代理"><a href="#客户端的实现——动态代理" class="headerlink" title="客户端的实现——动态代理"></a>客户端的实现——动态代理</h2><p>客户端方面，由于在客户端这一侧我们并没有接口的具体实现类，就没有办法直接生成实例对象。这时，我们可以通过动态代理的方式生成实例，并且调用方法时生成需要的RpcRequest对象并且发送给服务端。</p><p>这里我们采用JDK动态代理，代理类是需要实现<code>InvocationHandler</code>接口的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><p>我们需要传递host和port来指明服务端的位置。并且使用getProxy()方法来生成代理对象。</p><p><code>InvocationHandler</code>接口需要实现invoke()方法，来指明代理对象的方法被调用时的动作。在这里，我们显然就需要生成一个RpcRequest对象，发送出去，然后返回从服务端接收到的结果即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcRequest rpcRequest = RpcRequest.builder()</span><br><span class="line">                .interfaceName(method.getDeclaringClass().getName())</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .parameters(args)</span><br><span class="line">                .paramTypes(method.getParameterTypes())</span><br><span class="line">                .build();</span><br><span class="line">        RpcClient rpcClient = <span class="keyword">new</span> RpcClient();</span><br><span class="line">        <span class="keyword">return</span> ((RpcResponse) rpcClient.sendRequest(rpcRequest, host, port)).getData();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p>生成RpcRequest很简单，我使用Builder模式来生成这个对象。发送的逻辑我使用了一个RpcClient对象来实现，这个对象的作用，就是将一个对象发过去，并且接受返回的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest, String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(host, port)) &#123;</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">            objectOutputStream.writeObject(rpcRequest);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            <span class="keyword">return</span> objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"调用时有错误发生："</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><p>我的实现很简单，直接使用Java的序列化方式，通过Socket传输。创建一个Socket，获取ObjectOutputStream对象，然后把需要发送的对象传进去即可，接收时获取ObjectInputStream对象，readObject()方法就可以获得一个返回的对象。</p><h2 id="服务端的实现——反射调用"><a href="#服务端的实现——反射调用" class="headerlink" title="服务端的实现——反射调用"></a>服务端的实现——反射调用</h2><p>服务端的实现就简单多了，使用一个ServerSocket监听某个端口，循环接收连接请求，如果发来了请求就创建一个线程，在新线程中处理调用。这里创建线程采用线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">60</span>;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS, workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><p>这里简化了一下，RpcServer暂时只能注册一个接口，即对外提供一个接口的调用服务，添加register方法，在注册完一个服务后立刻开始监听：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object service, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">            logger.info(<span class="string">"服务器正在启动..."</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">"客户端连接！Ip为："</span> + socket.getInetAddress());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> WorkerThread(socket, service));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"连接时有错误发生："</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>这里向工作线程WorkerThread传入了socket和用于服务端实例service。</p><p>WorkerThread实现了Runnable接口，用于接收RpcRequest对象，解析并且调用，生成RpcResponse对象并传输回去。run方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">             ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;</span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) objectInputStream.readObject();</span><br><span class="line">            Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">            Object returnObject = method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">            objectOutputStream.writeObject(RpcResponse.success(returnObject));</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"调用或发送时有错误发生："</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><p>其中，通过class.getMethod方法，传入方法名和方法参数类型即可获得Method对象。如果你上面RpcRequest中使用String数组来存储方法参数类型的话，这里你就需要通过反射生成对应的Class数组了。通过method.invoke方法，传入对象实例和参数，即可调用并且获得返回值。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>服务端侧，我们已经在上面实现了一个HelloService的实现类HelloServiceImpl的实现类了，我们只需要创建一个RpcServer并且把这个实现类注册进去就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        RpcServer rpcServer = <span class="keyword">new</span> RpcServer();</span><br><span class="line">        rpcServer.register(helloService, <span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>服务端开放在9000端口。</p><p>客户端方面，我们需要通过动态代理，生成代理对象，并且调用，动态代理会自动帮我们向服务端发送请求的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">"This is a message"</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><p>我们这里生成了一个HelloObject对象作为方法的参数。</p><p>首先启动服务端，再启动客户端，服务端输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务器正在启动...</span><br><span class="line">客户端连接！Ip为：127.0.0.1</span><br><span class="line">接收到：This is a message</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>客户端输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是调用的返回值，id&#x3D;12</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rpc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unsafe包</title>
      <link href="/2020/11/18/Unsafe%E5%8C%85/"/>
      <url>/2020/11/18/Unsafe%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>Java和C++语言的一个重要区别就是Java中我们无法直接操作一块内存区域，不能像C++中那样可以自己申请内存和释放内存。Java中的Unsafe类为我们提供了类似C++手动管理内存的能力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class RevisedObjectInHeap</span><br><span class="line">&#123;</span><br><span class="line">    public Unsafe getUnsafe() throws IllegalAccessException &#123;</span><br><span class="line">        Field unsafeField &#x3D; Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(true);</span><br><span class="line">        Unsafe unsafe &#x3D; (Unsafe) unsafeField.get(null);</span><br><span class="line">        return unsafe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long address &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private Unsafe unsafe &#x3D; getUnsafe();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 让对象占用堆内存,触发[Full GC</span><br><span class="line">    private byte[] bytes &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public RevisedObjectInHeap() throws IllegalAccessException &#123;</span><br><span class="line">        address &#x3D; unsafe.allocateMemory(2 * 1024 * 1024);</span><br><span class="line">        bytes &#x3D; new byte[1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.out.println(&quot;finalize.&quot; + bytes.length);</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException &#123;</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            RevisedObjectInHeap heap &#x3D; new RevisedObjectInHeap();</span><br><span class="line">            System.out.println(&quot;memory address&#x3D;&quot; + heap.address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>Unsafe的功能如下图：</p><p>​    <img src="https://user-gold-cdn.xitu.io/2019/2/24/1691f484296ba537?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Unsafe-xmind"></p><h2 id="普通读写"><a href="#普通读写" class="headerlink" title="普通读写"></a>普通读写</h2><p>通过Unsafe可以读写一个类的属性，即使这个属性是私有的，也可以对这个属性进行读写。</p><p><strong>读写一个Object属性的相关方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public native int getInt(Object var1, long var2);</span><br><span class="line"></span><br><span class="line">public native void putInt(Object var1, long var2, int var4);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>getInt用于从对象的指定偏移地址处读取一个int。putInt用于在对象指定偏移地址处写入一个int。其他的primitive type也有对应的方法。</p><p><strong>Unsafe还可以直接在一个地址上读写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public native byte getByte(long var1);</span><br><span class="line"></span><br><span class="line">public native void putByte(long var1, byte var3);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>getByte用于从指定内存地址处开始读取一个byte。putByte用于从指定内存地址写入一个byte。其他的primitive type也有对应的方法。</p><h2 id="volatile读写"><a href="#volatile读写" class="headerlink" title="volatile读写"></a>volatile读写</h2><p>普通的读写无法保证可见性和有序性，而volatile读写就可以保证可见性和有序性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public native int getIntVolatile(Object var1, long var2);</span><br><span class="line"></span><br><span class="line">public native void putIntVolatile(Object var1, long var2, int var4);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>getIntVolatile方法用于在对象指定偏移地址处volatile读取一个int。putIntVolatile方法用于在对象指定偏移地址处volatile写入一个int。</p><p>volatile读写相对普通读写是更加昂贵的，因为需要保证可见性和有序性，而与volatile写入相比putOrderedXX写入代价相对较低，putOrderedXX写入不保证可见性，但是保证有序性，所谓有序性，就是保证指令不会重排序。</p><h2 id="有序写入"><a href="#有序写入" class="headerlink" title="有序写入"></a>有序写入</h2><p>有序写入只保证写入的有序性，不保证可见性，就是说一个线程的写入不保证其他线程立马可见。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public native void putOrderedObject(Object var1, long var2, Object var4);</span><br><span class="line"></span><br><span class="line">public native void putOrderedInt(Object var1, long var2, int var4);</span><br><span class="line"></span><br><span class="line">public native void putOrderedLong(Object var1, long var2, long var4);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="直接内存操作"><a href="#直接内存操作" class="headerlink" title="直接内存操作"></a>直接内存操作</h2><p>我们都知道Java不可以直接对内存进行操作，对象内存的分配和回收都是由JVM帮助我们实现的。但是Unsafe为我们在Java中提供了直接操作内存的能力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分配内存</span><br><span class="line">public native long allocateMemory(long var1);</span><br><span class="line">&#x2F;&#x2F; 重新分配内存</span><br><span class="line">public native long reallocateMemory(long var1, long var3);</span><br><span class="line">&#x2F;&#x2F; 内存初始化</span><br><span class="line">public native void setMemory(long var1, long var3, byte var5);</span><br><span class="line">&#x2F;&#x2F; 内存复制</span><br><span class="line">public native void copyMemory(Object var1, long var2, Object var4, long var5, long var7);</span><br><span class="line">&#x2F;&#x2F; 清除内存</span><br><span class="line">public native void freeMemory(long var1);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="CAS相关"><a href="#CAS相关" class="headerlink" title="CAS相关"></a>CAS相关</h2><p>JUC中大量运用了CAS操作，可以说CAS操作是JUC的基础，因此CAS操作是非常重要的。Unsafe中提供了int,long和Object的CAS操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>CAS一般用于乐观锁，它在Java中有广泛的应用，ConcurrentHashMap，ConcurrentLinkedQueue中都有用到CAS来实现乐观锁。</p><h2 id="偏移量相关"><a href="#偏移量相关" class="headerlink" title="偏移量相关"></a>偏移量相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public native long staticFieldOffset(Field var1);</span><br><span class="line"></span><br><span class="line">public native long objectFieldOffset(Field var1);</span><br><span class="line"></span><br><span class="line">public native Object staticFieldBase(Field var1);</span><br><span class="line"></span><br><span class="line">public native int arrayBaseOffset(Class&lt;?&gt; var1);</span><br><span class="line"></span><br><span class="line">public native int arrayIndexScale(Class&lt;?&gt; var1);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>staticFieldOffset方法用于获取静态属性Field在对象中的偏移量，读写静态属性时必须获取其偏移量。objectFieldOffset方法用于获取非静态属性Field在对象实例中的偏移量，读写对象的非静态属性时会用到这个偏移量。staticFieldBase方法用于返回Field所在的对象。arrayBaseOffset方法用于返回数组中第一个元素实际地址相对整个数组对象的地址的偏移量。arrayIndexScale方法用于计算数组中第一个元素所占用的内存空间。</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public native void unpark(Object var1);</span><br><span class="line"></span><br><span class="line">public native void park(boolean var1, long var2);</span><br><span class="line"></span><br><span class="line">public native void monitorEnter(Object var1);</span><br><span class="line"></span><br><span class="line">public native void monitorExit(Object var1);</span><br><span class="line"></span><br><span class="line">public native boolean tryMonitorEnter(Object var1);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>park方法和unpark方法相信看过LockSupport类的都不会陌生，这两个方法主要用来挂起和唤醒线程。LockSupport中的park和unpark方法正是通过Unsafe来实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 挂起线程</span><br><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker); &#x2F;&#x2F; 通过Unsafe的putObject方法设置阻塞阻塞当前线程的blocker</span><br><span class="line">    UNSAFE.park(false, 0L); &#x2F;&#x2F; 通过Unsafe的park方法来阻塞当前线程，注意此方法将当前线程阻塞后，当前线程就不会继续往下走了，直到其他线程unpark此线程</span><br><span class="line">    setBlocker(t, null); &#x2F;&#x2F; 清除blocker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 唤醒线程</span><br><span class="line">public static void unpark(Thread thread) &#123;</span><br><span class="line">    if (thread !&#x3D; null)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>monitorEnter方法和monitorExit方法用于加锁，Java中的synchronized锁就是通过这两个指令来实现的。</p><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public native Class&lt;?&gt; defineClass(String var1, byte[] var2, int var3, int var4, ClassLoader var5, ProtectionDomain var6);</span><br><span class="line"></span><br><span class="line">public native Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; var1, byte[] var2, Object[] var3);</span><br><span class="line"></span><br><span class="line">public native Object allocateInstance(Class&lt;?&gt; var1) throws InstantiationException;</span><br><span class="line"></span><br><span class="line">public native boolean shouldBeInitialized(Class&lt;?&gt; var1);</span><br><span class="line"></span><br><span class="line">public native void ensureClassInitialized(Class&lt;?&gt; var1);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>defineClass方法定义一个类，用于动态地创建类。 defineAnonymousClass用于动态的创建一个匿名内部类。 allocateInstance方法用于创建一个类的实例，但是不会调用这个实例的构造方法，如果这个类还未被初始化，则初始化这个类。 shouldBeInitialized方法用于判断是否需要初始化一个类。 ensureClassInitialized方法用于保证已经初始化过一个类。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public native void loadFence();</span><br><span class="line"></span><br><span class="line">public native void storeFence();</span><br><span class="line"></span><br><span class="line">public native void fullFence();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>loadFence：保证在这个屏障之前的所有读操作都已经完成。 storeFence：保证在这个屏障之前的所有写操作都已经完成。 fullFence：保证在这个屏障之前的所有读写操作都已经完成。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP的RTT、RTO?</title>
      <link href="/2020/11/18/TCP%E7%9A%84RTT%E3%80%81RTO/"/>
      <url>/2020/11/18/TCP%E7%9A%84RTT%E3%80%81RTO/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><ul><li><code>RTT(Round Trip Time)</code>：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值；</li><li><code>RTO(Retransmission Time Out)</code>：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队头阻塞</title>
      <link href="/2020/11/18/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E/"/>
      <url>/2020/11/18/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常我们提到队头阻塞，指的可能是TCP协议中的队头阻塞，但是HTTP1.1中也有一个类似TCP队头阻塞的问题，下面各自介绍一下。</p><h2 id="TCP队头阻塞"><a href="#TCP队头阻塞" class="headerlink" title="TCP队头阻塞"></a>TCP队头阻塞</h2><p>队头阻塞（head-of-line blocking）发生在一个TCP分节丢失，导致其后续分节不按序到达接收端的时候。该后续分节将被接收端一直保持直到丢失的第一个分节被发送端重传并到达接收端为止。该后续分节的延迟递送确保接收应用进程能够按照发送端的发送顺序接收数据。这种为了达到完全有序而引入的延迟机制非常有用，但也有不利之处。</p><p>假设在单个TCP连接上发送语义独立的消息，比如说服务器可能发送3幅不同的图像供Web浏览器显示。为了营造这几幅图像在用户屏幕上并行显示的效果，服务器先发送第一幅图像的一个断片，再发送第二幅图像的一个断片，然后再发送第三幅图像的一个断片；服务器重复这个过程，直到这3幅图像全部成功地发送到浏览器为止。</p><p>要是第一幅图像的某个断片内容的TCP分节丢失了，客户端将保持已到达的不按序的所有数据，直到丢失的分节重传成功。这样不仅延缓了第一幅图像数据的递送，也延缓了第二幅和第三幅图像数据的递送。</p><h2 id="HTTP队头阻塞"><a href="#HTTP队头阻塞" class="headerlink" title="HTTP队头阻塞"></a>HTTP队头阻塞</h2><p>上面用浏览器请求图片资源举例子，但实际上HTTP自身也有类似TCP队头阻塞的情况。要介绍HTTP队头阻塞，就需要先讲讲HTTP的管道化（pipelining）。</p><h3 id="HTTP管道化是什么"><a href="#HTTP管道化是什么" class="headerlink" title="HTTP管道化是什么"></a>HTTP管道化是什么</h3><p>HTTP1.1 允许在持久连接上可选的使用请求管道。这是相对于keep-alive连接的又一性能优化。在相应到达之前，可以将多条请求放入队列，当第一条请求发往服务器的时候，第二第三条请求也可以开始发送了，在高延时网络条件下，这样做可以降低网络的环回时间，提高性能。</p><p>非管道化与管道化的区别示意</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/21/16ad9415ebab724b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="HTTP管道化产生的背景"><a href="#HTTP管道化产生的背景" class="headerlink" title="HTTP管道化产生的背景"></a>HTTP管道化产生的背景</h3><p>在一般情况下，HTTP遵守“请求-响应”的模式，也就是客户端每次发送一个请求到服务端，服务端返回响应。这种模式非常容易理解，但是效率并不是那么高，为了提高速度和效率，人们做了很多尝试：</p><ul><li>最简单的情况下，服务端一旦返回响应后就会把对应的连接关闭，客户端的多个请求实际上是串行发送的。</li><li>除此之外，客户端可以选择同时创建多个连接，在多个连接上并行的发送不同请求。但是创建更多连接也带来了更多的消耗，当前大部分浏览器都会限制对同一个域名的连接数。</li><li>从HTTP1.0开始增加了持久连接的概念（HTTP1.0的Keep-Alive和HTTP1.1的persistent），可以使HTTP能够复用已经创建好的连接。客户端在收到服务端响应后，可以复用上次的连接发送下一个请求，而不用重新建立连接。</li><li>现代浏览器大多采用并行连接与持久连接共用的方式提高访问速度，对每个域名建立并行地少量持久连接。</li><li>而在持久连接的基础上，HTTP1.1进一步地支持在持久连接上使用管道化（pipelining）特性。管道化允许客户端在已发送的请求收到服务端的响应之前发送下一个请求，借此来减少等待时间提高吞吐；如果多个请求能在同一个TCP分节发送的话，还能提高网络利用率。但是因为HTTP管道化本身可能会导致队头阻塞的问题，以及一些其他的原因，现代浏览器默认都关闭了管道化。</li></ul><h3 id="HTTP管道化的限制"><a href="#HTTP管道化的限制" class="headerlink" title="HTTP管道化的限制"></a>HTTP管道化的限制</h3><ol><li>管道化要求服务端按照请求发送的顺序返回响应（FIFO），原因很简单，HTTP请求和响应并没有序号标识，无法将乱序的响应与请求关联起来。</li><li>客户端需要保持未收到响应的请求，当连接意外中断时，需要重新发送这部分请求。</li><li>只有幂等的请求才能进行管道化，也就是只有GET和HEAD请求才能管道化，否则可能会出现意料之外的结果</li></ol><h3 id="HTTP管道化引起的请求队头阻塞"><a href="#HTTP管道化引起的请求队头阻塞" class="headerlink" title="HTTP管道化引起的请求队头阻塞"></a>HTTP管道化引起的请求队头阻塞</h3><p>前面提到HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。</p><h2 id="如何解决队头阻塞"><a href="#如何解决队头阻塞" class="headerlink" title="如何解决队头阻塞"></a>如何解决队头阻塞</h2><h3 id="如何解决HTTP队头阻塞"><a href="#如何解决HTTP队头阻塞" class="headerlink" title="如何解决HTTP队头阻塞"></a>如何解决HTTP队头阻塞</h3><p>对于HTTP1.1中管道化导致的请求/响应级别的队头阻塞，可以使用HTTP2解决。HTTP2不使用管道化的方式，而是引入了帧、消息和数据流等概念，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后在组装成消息，这样就避免了请求/响应阻塞。</p><p>当然，即使使用HTTP2，如果HTTP2底层使用的是TCP协议，仍可能出现TCP队头阻塞。</p><h3 id="如何解决TCP队头阻塞"><a href="#如何解决TCP队头阻塞" class="headerlink" title="如何解决TCP队头阻塞"></a>如何解决TCP队头阻塞</h3><p>TCP中的队头阻塞的产生是由TCP自身的实现机制决定的，无法避免。想要在应用程序当中避免TCP队头阻塞带来的影响，只有舍弃TCP协议。</p><p>比如google推出的<a href="https://km.sankuai.com/page/108687233" target="_blank" rel="noopener">quic</a>协议，在某种程度上可以说避免了TCP中的队头阻塞，因为它根本不使用TCP协议，而是在UDP协议的基础上实现了可靠传输。而UDP是面向数据报的协议，数据报之间不会有阻塞约束。</p><p>此外还有一个SCTP（流控制传输协议），它是和TCP、UDP在同一层次的传输协议。SCTP的多流特性也可以尽可能的避免队头阻塞的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从TCP队头阻塞和HTTP队头阻塞的原因我们可以看到，出现队头阻塞的原因有两个：</p><ol><li>独立的消息数据都在一个链路上传输，也就是有一个“队列”。比如TCP只有一个流，多个HTTP请求共用一个TCP连接</li><li>队列上传输的数据有严格的顺序约束。比如TCP要求数据严格按照序号顺序，HTTP管道化要求响应严格按照请求顺序返回</li></ol><p>所以要避免队头阻塞，就需要从以上两个方面出发，比如quic协议不使用TCP协议而是使用UDP协议，SCTP协议支持一个连接上存在多个数据流等等。</p><p>作者：熊纪元<br>链接：<a href="https://juejin.im/post/6844903853985366023" target="_blank" rel="noopener">https://juejin.im/post/6844903853985366023</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>半打开，半关闭，半连接</title>
      <link href="/2020/11/18/%E5%8D%8A%E6%89%93%E5%BC%80%EF%BC%8C%E5%8D%8A%E5%85%B3%E9%97%AD%EF%BC%8C%E5%8D%8A%E8%BF%9E%E6%8E%A5/"/>
      <url>/2020/11/18/%E5%8D%8A%E6%89%93%E5%BC%80%EF%BC%8C%E5%8D%8A%E5%85%B3%E9%97%AD%EF%BC%8C%E5%8D%8A%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h1><p>close：全关闭，不再输出，也不能接收输入</p><p>shutdown:半关闭</p><p>当半关闭输出时：对应TCP四次挥手的 FIN_WAIT_2状态</p><p><img src="https://img2018.cnblogs.com/blog/1383984/201904/1383984-20190417145024224-277153479.png" alt="img"></p><h1 id="半打开："><a href="#半打开：" class="headerlink" title="半打开："></a>半打开：</h1><p>如果一方异常关闭（断网，断电），而另一方并不知情。处于半打开的状态，如果双方不进行数据通信，是无法发现问题的。可以引入心跳机制，以检测半打开状态，检测到了发送RST重新建立连接</p><h1 id="半连接："><a href="#半连接：" class="headerlink" title="半连接："></a>半连接：</h1><p>三次握手中，主动发起握手的一方不发最后一次ACK，使得服务器端阻塞在SYN_RECV状态</p><p>半连接攻击（SYN攻击）：会耗尽服务器资源，使得真正的请求无法建立连接。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些特殊的TCP选项</title>
      <link href="/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/"/>
      <url>/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>TCP异常终止（reset报文）</strong></p><p><strong>TCP的异常终止是相对于正常释放TCP连接的过程而言的</strong>，我们都知道，TCP连接的建立是通过三次握手完成的，而TCP正常释放连接是通过四次挥手来完成，但是有些情况下，TCP在交互的过程中会出现一些意想不到的情况，导致TCP无法按照正常的四次挥手来释放连接，如果此时不<strong>通过其他的方式来释放TCP连接</strong>的话，这个TCP连接将会一直存在，占用系统的部分资源。在这种情况下，我们就需要有一种能够释放TCP连接的机制，这种机制就是TCP的reset报文。reset报文是指TCP报头的标志字段中的reset位置一的报文，如下图所示：</p><p><img src="https://img-my.csdn.net/uploads/201210/08/1349695916_7871.png" alt="img"></p><p><strong>TCP异常终止的常见情形</strong></p><p>我们在实际的工作环境中，导致某一方发送reset报文的情形主要有以下几种：</p><p><strong><em>\</em>1，客户端尝试与服务器\</strong>*<em>未对外提供服务的端口*</em>*<em>建立TCP连接，服务器将会直接向客户端发送reset报文。***</em></p><p><img src="/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201118224909130.png" alt="image-20201118224909130"></p><p><strong>*\</strong>*2**<em>*</em>*，客户端和服务器的某一方在交互的过程中发生异常（如程序崩溃等），该方系统将向对端发送*<em>*</em>**TCP reset**<em>*</em>*报文，告之对方释放相关的*<em>*</em>**TCP**<em>*</em>*连接****，如下图所示：</p><p><img src="/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201118224917728.png" alt="image-20201118224917728"></p><p>3<strong><em>\</em>，接收端收到TCP报文，但是发现该TCP的报文，并不在其\</strong>*<em>已建立的TCP连接列表*</em>*<em>内，则其直接向对端发送reset报文***</em>，如下图所示：</p><p><img src="/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201118224926584.png" alt="image-20201118224926584"></p><p><strong>*\</strong>*4**<em>*</em>*<em>\</em>，在交互的双方中的某一方长期未收到来自对方的确认报文，则其在超出一定的重传次数或时间后，会****主动****向对端发送**<em>*</em>*<em>\</em>reset**<em>*</em>*报文释放该*<em>*</em>**TCP**<em>*****</em>*连接****，如下图所示：</p><p><img src="/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201118224938327.png" alt="image-20201118224938327"></p><p><strong>*\</strong>*5**<em>*</em>*<em>\</em>，有些应用开发者在设计应用系统时，会****利用**<em>*</em>*<em>\</em>**reset******报文快速释放已经完成数据交互的******TCP******连接，以提高业务交互的效率**<em>**</em>，如下图所示：</p><p><img src="/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201118224947724.png" alt="image-20201118224947724"></p><p><strong>Reset报文的利用</strong></p><p><strong><em>\</em>1\</strong> *<em>安全设备利用*</em>*<em>reset*</em>*<em>报文阻断异常连接***</em></p><p>安全设备（如防火墙、入侵检测系统等）在发现某些可疑的TCP连接时，会构造交互双方的reset报文发给对端，让对端释放该TCP连接。比如入侵检测检测到黑客攻击的TCP连接，其构造成被攻击端给黑客主机发送reset报文，让黑客主机释放攻击连接。</p><p><strong><em>\</em>2\</strong> *<em>利用*</em>*<em>reset*</em>*<em>报文实施攻击***</em></p><p>安全设备可以利用reset报文达到安全防护的效果，黑客和攻击者也可以利用reset报文实现对某些主机的入侵和攻击，最常见的就是TCP会话劫持攻击。关于TCP会话劫持的相关知识请参考第三章《TCP会话劫持》一文。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题</title>
      <link href="/2020/11/18/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/18/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong><em>\</em>什么是跨域？**</strong></p><p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是<strong><em>\</em>浏览器施加的**</strong>安全限制。</p><p><strong><em>\</em>所谓同源是指，域名，协议，端口均相同，不明白没关系，举个栗子：**</strong></p><p><strong><em>\</em><a href="http://www.123.com/index.html" target="_blank" rel="noopener">http://www.123.com/index.html</a> 调用 <a href="http://www.123.com/server.php" target="_blank" rel="noopener">http://www.123.com/server.php</a> （非跨域）**</strong></p><p><strong><em>\</em><a href="http://www.123.com/index.html" target="_blank" rel="noopener">http://www.123.com/index.html</a> 调用 <a href="http://www.456.com/server.php" target="_blank" rel="noopener">http://www.456.com/server.php</a> （主域名不同:123/456，跨域）**</strong></p><p><strong><em>\</em><a href="http://abc.123.com/index.html" target="_blank" rel="noopener">http://abc.123.com/index.html</a> 调用 <a href="http://def.123.com/server.php" target="_blank" rel="noopener">http://def.123.com/server.php</a> （子域名不同:abc/def，跨域）**</strong></p><p><strong><a href="http://www.123.com:8080/index.html" target="_blank" rel="noopener">http://www.123.com:8080/index.html</a> 调用 <a href="http://www.123.com:8081/server.php" target="_blank" rel="noopener">http://www.123.com:8081/server.php</a> （端口不同:8080/8081，跨域）</strong></p><p><strong><a href="http://www.123.com/index.html" target="_blank" rel="noopener">http://www.123.com/index.html</a> 调用 <a href="https://www.123.com/server.php" target="_blank" rel="noopener">https://www.123.com/server.php</a> （协议不同:http/https，跨域）</strong></p><p><strong>请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。</strong></p><p>浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。</p><p><strong>解决办法：</strong></p><p><strong>1、JSONP：</strong></p><p>使用方式就不赘述了，但是要注意JSONP只支持GET请求，不支持POST请求。</p><p><strong>2、代理：</strong></p><p>例如<a href="http://www.123.com/index.html需要调用www.456.com/server.php，可以写一个接口www.123.com/server.php，由这个接口在后端去调用www.456.com/server.php并拿到返回值，然后再返回给index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。" target="_blank" rel="noopener">www.123.com/index.html需要调用www.456.com/server.php，可以写一个接口www.123.com/server.php，由这个接口在后端去调用www.456.com/server.php并拿到返回值，然后再返回给index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。</a></p><p><strong>3、PHP端修改header（XHR2方式）</strong></p><p>在php接口脚本中加入以下两句即可：</p><p>header(‘Access-Control-Allow-Origin:*’);//允许所有来源访问</p><p>header(‘Access-Control-Allow-Method:POST,GET’);//允许访问的方式</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最左匹配的一些情况</title>
      <link href="/2020/11/18/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%85%E5%86%B5/"/>
      <url>/2020/11/18/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<p>看了好多博客，讲讲自己的理解：索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。<br>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的</p><p><img src="https://img-blog.csdnimg.cn/20190401113210176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxOTE3MTA5,size_16,color_FFFFFF,t_70" alt="img"></p><p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p><p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a&gt;1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p><p><strong>最左匹配原则：</strong>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。</p><p> 假如建立联合索引（a,b,c）</p><p><strong>1 全值匹配查询时</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = <span class="string">'1'</span> <span class="keyword">and</span> b = <span class="string">'2'</span> <span class="keyword">and</span> c = <span class="string">'3'</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> b = <span class="string">'2'</span> <span class="keyword">and</span> a = <span class="string">'1'</span> <span class="keyword">and</span> c = <span class="string">'3'</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> c = <span class="string">'3'</span> <span class="keyword">and</span> b = <span class="string">'2'</span> <span class="keyword">and</span> a = <span class="string">'1'</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>用到了索引</p><p>where子句几个搜索条件顺序调换不影响查询结果，因为Mysql中有查询优化器，会自动优化查询顺序 </p><p><strong>2 匹配左边的列时</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = <span class="string">'1'</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = <span class="string">'1'</span> <span class="keyword">and</span> b = <span class="string">'2'</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = <span class="string">'1'</span> <span class="keyword">and</span> b = <span class="string">'2'</span> <span class="keyword">and</span> c = <span class="string">'3'</span></span><br></pre></td></tr></table></figure><p>都从最左边开始<strong>连续</strong>匹配，用到了索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  b = <span class="string">'2'</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  c = <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  b = <span class="string">'1'</span> <span class="keyword">and</span> c = <span class="string">'3'</span></span><br></pre></td></tr></table></figure><p>这些没有从最左边开始，最后查询没有用到索引，用的是全表扫描 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = <span class="string">'1'</span> <span class="keyword">and</span> c = <span class="string">'3'</span></span><br></pre></td></tr></table></figure><p>如果不连续时，只用到了a列的索引，b列和c列都没有用到 </p><p> <strong>3 匹配列前缀</strong></p><p>如果列是字符型的话它的比较规则是先比较字符串的第一个字符，第一个字符小的哪个字符串就比较小，如果两个字符串第一个字符相通，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小，依次类推，比较字符串。</p><p>如果a是字符类型，那么前缀匹配用的是索引，后缀和中缀只能全表扫描了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">'As%'</span>; //前缀都是排好序的，走索引查询</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  a <span class="keyword">like</span> <span class="string">'%As'</span>//全表查询</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  a <span class="keyword">like</span> <span class="string">'%As%'</span>//全表查询</span><br></pre></td></tr></table></figure><p><strong>4 匹配范围值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  a &gt; <span class="number">1</span> <span class="keyword">and</span> a &lt; <span class="number">3</span></span><br></pre></td></tr></table></figure><p>可以对最左边的列进行范围查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  a &gt; <span class="number">1</span> <span class="keyword">and</span> a &lt; <span class="number">3</span> <span class="keyword">and</span> b &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>多个列同时进行范围查找时，只有对索引最左边的那个列进行范围查找才用到B+树索引，也就是只有a用到索引，在1&lt;a&lt;3的范围内b是无序的，不能用索引，找到1&lt;a&lt;3的记录后，只能根据条件 b &gt; 1继续逐条过滤</p><p> <strong>5 精确匹配某一列并范围匹配另外一列</strong></p><p>如果左边的列是精确查找的，右边的列可以进行范围查找</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  a = <span class="number">1</span> <span class="keyword">and</span> b &gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p> a=1的情况下b是有序的，进行范围查找走的是联合索引</p><p><strong>6 排序</strong></p><p>一般情况下，我们只能把记录加载到内存中，再用一些排序算法，比如快速排序，归并排序等在内存中对这些记录进行排序，有时候查询的结果集太大不能在内存中进行排序的话，还可能暂时借助磁盘空间存放中间结果，排序操作完成后再把排好序的结果返回客户端。Mysql中把这种再内存中或磁盘上进行排序的方式统称为文件排序。文件排序非常慢，但如果order子句用到了索引列，就有可能省去文件排序的步骤</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> a,b,c <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>因为b+树索引本身就是按照上述规则排序的，所以可以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了</p><p>order by的子句后面的顺序也必须按照索引列的顺序给出，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> b,c,a <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p> 这种颠倒顺序的没有用到索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> a <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> a,b <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这种用到部分索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a =<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> b,c <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>联合索引左边列为常量，后边的列排序可以用到索引</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>B+树分裂?</title>
      <link href="/2020/11/18/B-%E6%A0%91%E5%88%86%E8%A3%82/"/>
      <url>/2020/11/18/B-%E6%A0%91%E5%88%86%E8%A3%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h1><p>1）若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。</p><p>2）针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2+1个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。</p><p>3）针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。</p><h1 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h1><p>如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤</p><p>1）删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2，删除操作结束,否则执行第2步。</p><p>2）若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。</p><p>3）若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。</p><p>4）若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步</p><p>5）若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步</p><p>6）当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。</p><p>注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。</p><p><img src="https://img-blog.csdnimg.cn/20200413111039577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTU2MzE2MQ==,size_16,color_FFFFFF,t_70" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用户态、内核态</title>
      <link href="/2020/11/18/%E7%94%A8%E6%88%B7%E6%80%81%E3%80%81%E5%86%85%E6%A0%B8%E6%80%81/"/>
      <url>/2020/11/18/%E7%94%A8%E6%88%B7%E6%80%81%E3%80%81%E5%86%85%E6%A0%B8%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="内核态和用户态？为什么？"><a href="#内核态和用户态？为什么？" class="headerlink" title="内核态和用户态？为什么？"></a>内核态和用户态？为什么？</h3><p> 假设没有这种内核态和用户态之分，程序随随便便就能访问硬件资源，比如说分配内存，程序能随意的读写所有的内存空间，如果程序员一不小心将不适当的内容写到了不该写的地方，就很可能导致系统崩溃。用户程序是不可信的，不管程序员是有意的还是无意的，都很容易将系统干到崩溃。</p><p>​    正因为如此，Intel就发明了ring0-ring3这些访问控制级别来保护硬件资源，ring0的就是我们所说的内核级别,要想使用硬件资源就必须获取相应的权限（设置PSW寄存器，这个操作只能由操作系统设置）。操作系统对内核级别的指令进行封装，统一管理硬件资源，然后向用户程序提供系统服务，用户程序进行系统调用后，操作系统执行一系列的检查验证，确保这次调用是安全的，再进行相应的资源访问操作。<strong>内核态能有效保护硬件资源的安全。</strong></p><h3 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h3><ol><li>大内核<br>大内核是将操作系统功能作为一个紧密结合的整体放到内核。<br>由于各模块共享信息，因此有很高的性能。</li><li>微内核<br>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则<br>划分成若干服务，相互独立。<br>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在<br>用户态。<br>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</li></ol><h3 id="用户态到内核态切换的三种方式："><a href="#用户态到内核态切换的三种方式：" class="headerlink" title="用户态到内核态切换的三种方式："></a>用户态到内核态切换的三种方式：</h3><ol><li>外中断<br>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输<br>入/输出请求。此外还有时钟中断、控制台中断等。</li><li>异常<br>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</li><li>系统调用：用户态的进程通过系统调用申请试用操作系统提供的服务程序完成工作，比如fork()就是执行了一个创建新进程的系统调用</li></ol><h3 id="用户态和内核态对于读写文件的操作有什么区别"><a href="#用户态和内核态对于读写文件的操作有什么区别" class="headerlink" title="用户态和内核态对于读写文件的操作有什么区别?"></a>用户态和内核态对于读写文件的操作有什么区别?</h3><p>内核态：CPU可以访问内存的所有数据，包括外围设备，例如网卡、硬盘，CPU也可以将自己从一个程序切换到另一个程序<br>用户态：CPU只能受限地访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取<br>所有的用户程序都是运行在用户态的，但是有的时候需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统疑问?</title>
      <link href="/2020/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%96%91%E9%97%AE/"/>
      <url>/2020/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%96%91%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="线程组成？"><a href="#线程组成？" class="headerlink" title="线程组成？"></a>线程组成？</h3><p>一个标准的线程由线程id，当前指令指针(pc)，寄存器集合和堆栈组成</p><h3 id="进程切换发生哪些事情"><a href="#进程切换发生哪些事情" class="headerlink" title="进程切换发生哪些事情?"></a>进程切换发生哪些事情?</h3><ul><li>保存CPU的上下文环境，包括程序计数器和寄存器，处理具体的中断、异常</li><li>调整被中断进程的PCB信息，比如进程状态</li><li>把进程移入相应的队列，比如就绪或者阻塞队列</li><li>选择另一个进程执行并更新其PCB</li><li>恢复CPU的上下文</li></ul><h3 id="为什么进程切换慢，线程切换快"><a href="#为什么进程切换慢，线程切换快" class="headerlink" title="为什么进程切换慢，线程切换快?"></a>为什么进程切换慢，线程切换快?</h3><ul><li><p>进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用TLB(Translation Lookaside Buffer)来缓存页地址，用来加速页表查找。当进程切换后页表也要进行切换，页表切换后TLB就失效了，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p></li><li><p>而且保存CPU的上下文环境</p></li></ul><h3 id="进程切换的时机"><a href="#进程切换的时机" class="headerlink" title="进程切换的时机?"></a>进程切换的时机?</h3><p>其中主动放弃处理器的场景是</p><ol><li><p>进程正常结束，主动放弃。</p></li><li><p>进程在执行时发生了异常。</p></li></ol><p>被动放弃处理器的场景是</p><ol><li><p>进程在执行时有个更紧急的任务(比如IO操作)</p></li><li><p>遇到有更高优先级的进程</p></li><li><p>进程的时间片过期</p></li></ol><h3 id="中断一定会引起进程切换吗"><a href="#中断一定会引起进程切换吗" class="headerlink" title="中断一定会引起进程切换吗?"></a>中断一定会引起进程切换吗?</h3><p>不一定</p><p>有一些中断／异常不会引起进程状态转换，不会引起进程切换，只是在处理完成后把控制权交还给被中断进程。</p><p>以下是处理流程：</p><p>1、（中断／异常等触发）正向模式切换并压入PSW／PC 。 </p><p>2、保存被中断进程的现场信息。</p><p>3、处理具体中断、异常。</p><p>4、恢复被中断进程的现场信息。</p><p>5、（中断返回指令触发）逆向模式转换并弹出PSW／PC。</p><h3 id="进程中打开文件其他线程可以直接读写那个文件吗？"><a href="#进程中打开文件其他线程可以直接读写那个文件吗？" class="headerlink" title="进程中打开文件其他线程可以直接读写那个文件吗？"></a>进程中打开文件其他线程可以直接读写那个文件吗？</h3><p>1.两个进程中分别产生生成两个独立的fd</p><p>2.两个进程可以任意对文件进行读写操作，操作系统并不保证写的原子性<br>3.进程可以通过系统调用对文件加锁，从而实现对文件内容的保护<br>4.<br>任何一个进程删除该文件时，另外一个进程不会立即出现读写失败</p><p>5.两个进程可以分别读取文件的不同部分而不会相互影响</p><p>6.一个进程对文件长度和内容的修改另外一个进程可以立即感知</p><p>内核中，对应于每个进程都有一个文件描述符表，表示这个进程打开的所有文件。文件描述表中每一项都是一个指针，指向一个用 于描述打开的文件的数据块———file对象，file对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的file对象。</p><p><img src="https://img-blog.csdn.net/20181014110752978?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvMTIzMDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h3 id="为什么要设计成三级缓存？"><a href="#为什么要设计成三级缓存？" class="headerlink" title="为什么要设计成三级缓存？"></a>为什么要设计成三级缓存？</h3><p>1、一级缓存基本上都是内置在cpu的内部和cpu一个速度进行运行，能有效的提升cpu的工作效率。一级缓存越多，cpu的工作效率就会越来越高，是cpu的内部结构限制了一级缓存的容量大小，使一级缓存的容量都是很小的。<br>2、二级缓存主要作用是协调一级缓存和内存之间的工作效率。cpu首先用的是一级内存，当cpu的速度慢慢提升之后，一级缓存就不够cpu的使用量了，这就需要用到二级内存。<br>3、CPU三级缓存，就是指CPU的第三层级的高速缓存，其作用是进一步降低内存的延迟，同时提升海量数据量计算时的性能。和一级缓存、二级缓存不同的是，三级缓存是核心共享的，能够将容量做的很大。</p><h3 id="Linux的buffer内存和cache内存"><a href="#Linux的buffer内存和cache内存" class="headerlink" title="Linux的buffer内存和cache内存"></a>Linux的buffer内存和cache内存</h3><ul><li>Buffers 是对原始磁盘块的临时存储，也就是用来<strong>缓存磁盘的数据</strong>，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写等等。合并这里似乎和大数据生态中的Hadoop组件中的小文件合并有相似。</li><li>Cached 是从磁盘读取文件的页缓存，也就是用来<strong>缓存从文件读取的数据</strong>。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。</li></ul><h3 id="操作系统除了堆，栈还包括哪些段呢？"><a href="#操作系统除了堆，栈还包括哪些段呢？" class="headerlink" title="操作系统除了堆，栈还包括哪些段呢？"></a>操作系统除了堆，栈还包括哪些段呢？</h3><p> 代码段 数据段</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各种join的区别</title>
      <link href="/2020/11/18/%E5%90%84%E7%A7%8Djoin%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/11/18/%E5%90%84%E7%A7%8Djoin%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>哈，好久没更新文章了，今天来说说关于mySQL那些年的小事。说到mySQL啊，用了挺久的了，但是有个问题一直在困扰着我，就是left join、join、right join和inner join等等各种join的区别。网上搜，最常见的就是一张图解图，如下：</p><p><img src="https://segmentfault.com/img/bVbk2mR?w=966&h=760" alt="clipboard.png"></p><p>真的是一张图道清所有join的区别啊，可惜我还是看不懂，可能人比较懒，然后基本一个left join给我就是够用的了，所以就没怎么去仔细研究了，但是现实还是逼我去搞清楚，索性自己动手，总算理解图中的含义了，下面就听我一一道来。</p><p>首先，我们先来建两张表，第一张表命名为kemu，第二张表命名为score：</p><p><img src="https://segmentfault.com/img/bVbk2or?w=118&h=92" alt="clipboard.png">)<img src="https://segmentfault.com/img/bVbk2oz?w=128&h=94" alt="clipboard.png"></p><p><strong>一、left join</strong><br>顾名思义，就是“左连接”，表1左连接表2，以左为主，表示以表1为主，关联上表2的数据，查出来的结果显示左边的所有数据，然后右边显示的是和左边有交集部分的数据。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">   *</span><br><span class="line">from</span><br><span class="line">   kemu</span><br><span class="line">left join score on kemu.id &#x3D; score.id</span><br></pre></td></tr></table></figure><p>结果集：<br><img src="https://segmentfault.com/img/bVbk2uE?w=205&h=144" alt="clipboard.png">)<img src="https://segmentfault.com/img/bVbk2qQ?w=238&h=103" alt="clipboard.png"></p><p><strong>二、right join</strong></p><p>“右连接”，表1右连接表2，以右为主，表示以表2为主，关联查询表1的数据，查出表2所有数据以及表1和表2有交集的数据，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">   *</span><br><span class="line">from</span><br><span class="line">   kemu</span><br><span class="line">right join score on kemu.id &#x3D; score.id</span><br></pre></td></tr></table></figure><p>结果集：</p><p><img src="https://segmentfault.com/img/bVbk2uI?w=222&h=143" alt="clipboard.png">)<img src="https://segmentfault.com/img/bVbk2uP?w=228&h=104" alt="clipboard.png"></p><p><strong>三、join</strong><br>join，其实就是“inner join”，为了简写才写成join，两个是表示一个的，内连接，表示以两个表的交集为主，查出来是两个表有交集的部分，其余没有关联就不额外显示出来，这个用的情况也是挺多的，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">   *</span><br><span class="line">from</span><br><span class="line">   kemu</span><br><span class="line">join score on kemu.id &#x3D; score.id</span><br></pre></td></tr></table></figure><p>结果集：</p><p><img src="https://segmentfault.com/img/bVbk2v1?w=227&h=145" alt="clipboard.png">)<img src="https://segmentfault.com/img/bVbk2MW?w=231&h=69" alt="clipboard.png"></p><p>以上就是三种连接的区别！</p><p> 从算法上来看，根据mysql文档，<code>inner join</code>在连接的时候，mysql会自动选择较小的表来作为驱动表，从而达到减少循环次数的目的。我们在使用<code>left join</code>表的时候，默认是使用左表作为驱动表，那么此时左表的大小是我们来控制的，如果控制不当，左表比较大，那么自然循环次数也会变多，效率会下降。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>捕获线程的异常</title>
      <link href="/2020/11/18/%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/11/18/%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="多线程之运行线程异常捕获"><a href="#多线程之运行线程异常捕获" class="headerlink" title="多线程之运行线程异常捕获"></a>多线程之运行线程异常捕获</h1><h2 id="单个线程异常捕获"><a href="#单个线程异常捕获" class="headerlink" title="单个线程异常捕获"></a>单个线程异常捕获</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程异常捕捉</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-12-23 22:22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程抛出异常</span></span><br><span class="line">        <span class="comment">//thread1();</span></span><br><span class="line">        <span class="comment">//捕获异常</span></span><br><span class="line">        thread2();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2_000</span>);</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2_000</span>);</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出异常信息</span></span><br><span class="line">        thread.setUncaughtExceptionHandler((t, e) -&gt; &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950</span></span><br></pre></td></tr></table></figure><p>thread1()方法运行结果</p><p><img src="https://img-blog.csdnimg.cn/20191223223356236.png" alt="在这里插入图片描述"><br>捕获线程异常使用 setUncaughtExceptionHandler（Thread t,Exception e）方法捕捉异常信息返回，然后再进行处理</p><p>thread1()方法运行结果<br><img src="https://img-blog.csdnimg.cn/20191223223420287.png" alt="在这里插入图片描述"></p><h2 id="线程池捕捉异常"><a href="#线程池捕捉异常" class="headerlink" title="线程池捕捉异常"></a>线程池捕捉异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置异常处理器</span></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ThreadTask());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><p>异常处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span>  <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"捕获到异常 : 线程名["</span> + t.getName() + <span class="string">"], 异常名["</span> + e + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常栈的信息</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO ... 如果对异常还需要做特殊处理,可以在此处继续实现处理方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>自定义抛出异常的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//运行异常</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">     System.out.println(<span class="string">"异常被谁处理："</span> + t.getUncaughtExceptionHandler());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>异常捕获</p><p><img src="https://img-blog.csdnimg.cn/20200118175528316.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程间通信?</title>
      <link href="/2020/11/18/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2020/11/18/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><ol><li>volatile</li><li>等待/通知机制</li><li>join方式</li><li>threadLocal</li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>冷备份和热备份</title>
      <link href="/2020/11/18/%E5%86%B7%E5%A4%87%E4%BB%BD%E5%92%8C%E7%83%AD%E5%A4%87%E4%BB%BD/"/>
      <url>/2020/11/18/%E5%86%B7%E5%A4%87%E4%BB%BD%E5%92%8C%E7%83%AD%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<p>数据库热备：一般bai用于保证du服务正常不zhi间断运行，用两台机dao器作为服务机4102器，一台用于实际1653数据库操作应用,另外一台实时的从前者中获取数据以保持数据一致.如果当前的机器熄火,备份的机器立马取代当前的机器继续提供服务</p><p>冷备：.冷备份指在数据库关闭后,进行备份,适用于所有模式的数据库.</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>可重入锁</title>
      <link href="/2020/11/18/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
      <url>/2020/11/18/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>什么是 “可重入”，可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.test.reen;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 演示可重入锁是什么意思，可重入，就是可以重复获取相同的锁，synchronized和ReentrantLock都是可重入的</span><br><span class="line">&#x2F;&#x2F; 可重入降低了编程复杂性</span><br><span class="line">public class WhatReentrant &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">System.out.println(&quot;第1次获取锁，这个锁是：&quot; + this);</span><br><span class="line">int index &#x3D; 1;</span><br><span class="line">while (true) &#123;</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">System.out.println(&quot;第&quot; + (++index) + &quot;次获取锁，这个锁是：&quot; + this);</span><br><span class="line">&#125;</span><br><span class="line">if (index &#x3D;&#x3D; 10) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.test.reen;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 演示可重入锁是什么意思</span><br><span class="line">public class WhatReentrant2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(&quot;第1次获取锁，这个锁是：&quot; + lock);</span><br><span class="line"></span><br><span class="line">int index &#x3D; 1;</span><br><span class="line">while (true) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(&quot;第&quot; + (++index) + &quot;次获取锁，这个锁是：&quot; + lock);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(new Random().nextInt(200));</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (index &#x3D;&#x3D; 10) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么时候使用myisam?</title>
      <link href="/2020/11/17/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8myisam/"/>
      <url>/2020/11/17/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8myisam/</url>
      
        <content type="html"><![CDATA[<p>1、平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。</p><p>2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。<br>3.MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出该值。<br>　　<br>　　MyISAM适合：<br>(1)做很多count 的计算；<br>(2)插入不频繁，查询非常频繁；<br>(3)没有事务。 </p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引汇总</title>
      <link href="/2020/11/17/%E7%B4%A2%E5%BC%95%E6%B1%87%E6%80%BB/"/>
      <url>/2020/11/17/%E7%B4%A2%E5%BC%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Inoodb的底层原理和具体结构</title>
      <link href="/2020/11/17/Inoodb%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%B7%E4%BD%93%E7%BB%93%E6%9E%84/"/>
      <url>/2020/11/17/Inoodb%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%B7%E4%BD%93%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor中的keepAliveTime详解</title>
      <link href="/2020/11/17/ThreadPoolExecutor%E4%B8%AD%E7%9A%84keepAliveTime%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/11/17/ThreadPoolExecutor%E4%B8%AD%E7%9A%84keepAliveTime%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>阅读这篇文章，你将会知道：</p><ol><li>keepAliveTime的概念。</li><li>keepAliveTime是如何设置的。</li><li>线程是如何根据keepAliveTime进行销毁的。</li></ol></blockquote><h2 id="一-keepAliveTime的概念："><a href="#一-keepAliveTime的概念：" class="headerlink" title="一.keepAliveTime的概念："></a>一.keepAliveTime的概念：</h2><ol><li>keepAliveTime的单位是纳秒，即1s=1000000000ns，1秒等于10亿纳秒。</li><li>keepAliveTime是线程池中空闲线程等待工作的超时时间。</li><li>当线程池中线程数量大于corePoolSize（核心线程数量）或设置了allowCoreThreadTimeOut（是否允许空闲核心线程超时）时，线程会根据keepAliveTime的值进行活性检查，一旦超时便销毁线程。</li><li>否则，线程会永远等待新的工作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Timeout in nanoseconds for idle threads waiting for work.</span></span><br><span class="line"><span class="comment">     * Threads use this timeout when there are more than corePoolSize</span></span><br><span class="line"><span class="comment">     * present or if allowCoreThreadTimeOut. Otherwise they wait</span></span><br><span class="line"><span class="comment">     * forever for new work.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h2 id="二-keepAliveTime的设置方法"><a href="#二-keepAliveTime的设置方法" class="headerlink" title="二. keepAliveTime的设置方法"></a>二. keepAliveTime的设置方法</h2><h3 id="1-通过构造函数设置"><a href="#1-通过构造函数设置" class="headerlink" title="1.通过构造函数设置"></a>1.通过构造函数设置</h3><p>通过 keepAliveTime 、unit共同决定实际的 keepAliveTime值，最终会转化成纳秒单位。<br><img src="https://img-blog.csdnimg.cn/20190420151619845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDEyOTY=,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-通过setKeepAliveTime方法动态设置"><a href="#2-通过setKeepAliveTime方法动态设置" class="headerlink" title="2.通过setKeepAliveTime方法动态设置"></a>2.通过setKeepAliveTime方法动态设置</h3><p>重新设置线程池的keepAliveTime属性，如果发现将要设置的值比原来的keepAliveTime值要小（即减小keepAliveTime），则触发interruptIdleWorkers()，中断空闲线程。<br><img src="https://img-blog.csdnimg.cn/20190420152745847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDEyOTY=,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>interruptIdleWorkers()是怎么中断线程的呢？</strong><br>（1）interruptIdleWorkers先拿出所有的工作者进行遍历，判断工作者对应的线程是否已经中断。<br>（2）如果没有产生中断，则判断是否可以获得锁，如果能获得锁，则代表是空闲线程，然后中断该线程。<br>（3）至于线程的中断在什么时候会抛出中断异常，同学们可以自己找下资料，也可以参考下别人写的这篇文章<a href="https://www.cnblogs.com/yangming1996/p/7612653.html" target="_blank" rel="noopener">Java并发之线程中断</a><br><img src="https://img-blog.csdnimg.cn/20190420155452451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDEyOTY=,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="三-线程是如何根据keepAliveTime进行销毁的"><a href="#三-线程是如何根据keepAliveTime进行销毁的" class="headerlink" title="三.线程是如何根据keepAliveTime进行销毁的"></a>三.线程是如何根据keepAliveTime进行销毁的</h2><ol><li>线程池中的线程通过工作者（Worker）这个类进行包装，Worker通过 ThreadPoolExecutor.runWorker() 这个方法进行自旋，从队列中获得task，并完成工作。</li><li>如果拿不到task（即firstTask == null 或 getTask() == null），则会退出自旋，进入finally代码块。finally中会调用processWorkerExit方法，注销当前Worker，实现worker的销毁。对keepAliveTime的使用，就在getTask()方法中，这个在后面讲解。<br><img src="https://img-blog.csdnimg.cn/20190420162707287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDEyOTY=,size_16,color_FFFFFF,t_70" alt="img"></li><li>getTask 怎么使用 keepAliveTime<br>（1）首先也是一个自旋，当allowCoreThreadTimeout(运行空闲核心线程超时) 或 wc&gt;corePoolSize(当前线程数量大于核心线程数量) 时，timed会标识为true，表示需要进行超时判断。<br>（2）当wc（当前工作者数量）大于 最大线程数 或 空闲线程的空闲时间大于keepAliveTime（timed &amp;&amp; timeout），以及wc&gt;1或（workQueue）任务队列为空时，会进入compareAndDecrementWorkerCount方法，对wc的值减1。<br>（3）当compareAndDecrementWorkerCount方法返回true时，则getTask方法会返回null，终止getTask方法的自旋。这时候回到runWorker方法，就会进入到processWorkerExit方法，进行销毁worker。<br><img src="https://img-blog.csdnimg.cn/20190420161304138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDEyOTY=,size_16,color_FFFFFF,t_70" alt="img"></li><li>compareAndDecrementWorkerCount中操作的是ctl属性：<br>（1）ctl是中心控制器，一个AtomicInteger类型的整数，通过数字的二进制编码的位进行分段，不同的二进制位段表示有不同的含义。<br>（2）在ctl中，低29为表示线程池的容量，即线程池最大容量为 536870911 = 000 11111111111111111111111111111。<br><img src="https://img-blog.csdnimg.cn/20190420170422593.png" alt="img"></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The main pool control state, ctl, is an atomic integer packing</span></span><br><span class="line"><span class="comment">    * two conceptual fields</span></span><br><span class="line"><span class="comment">    *   workerCount, indicating the effective number of threads</span></span><br><span class="line"><span class="comment">    *   runState,    indicating whether running, shutting down etc</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">   <span class="comment">// COUNT_BITS = 29</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">   <span class="comment">// CAPACITY = 536870911 = 000 11111111111111111111111111111</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; </span><br><span class="line"><span class="keyword">return</span> c &amp; CAPACITY; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Http3.0的特点?</title>
      <link href="/2020/11/17/Http3-0%E7%9A%84%E7%89%B9%E7%82%B9/"/>
      <url>/2020/11/17/Http3-0%E7%9A%84%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h2><p><a href="https://www.mobibrw.com/2020/23190" target="_blank" rel="noopener">https://www.mobibrw.com/2020/23190</a></p><p>HTTP2.0 也是基于TCP协议的，tcp协议在处理包时是有严格顺序的</p><p>当其中一个数据包遇到问题，TCP连接需要等待找个包完成重传之后才能继续进行，虽然HTTP2.0通过多个stream，使得逻辑上一个tcp连接上的并行内容，进行多路数据的传输，然而这中间没有关联的数据，一前一后，前面stream2的帧没有收到，后面stream1的帧也会因此堵塞</p><p>于是google的 QUIC协议从TCP切换到UDP</p><ul><li>机制一：自定义连接机制<br>一条tcp连接是由四元组标识的，分别是源ip、源端口、目的端口，一旦一个元素发生变化时，就会断开重连，重新连接。在次进行三次握手，导致一定的延时</li></ul><p>在TCP是没有办法的，但是基于UDP，就可以在QUIC自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个64<br>位的随机数作为ID来标识，而且UDP是无连接的，所以当ip或者端口变化的时候，只要ID不变，就不需要重新建立连接</p><ul><li>机制二：自定义重传机制<br>tcp为了保证可靠性，通过使用序号和应答机制，来解决顺序问题和丢包问题</li></ul><p>任何一个序号的包发过去，都要在一定的时间内得到应答，否则一旦超时，就会重发这个序号的包，通过自适应重传算法（通过采样往返时间RTT不断调整）</p><p>但是，在TCP里面超时的采样存在不准确的问题。例如发送一个包，序号100，发现没有返回，于是在发送一个100，过一阵返回ACK101.客户端收到了，但是往返的时间是多少，没法计算。是ACK到达的时候减去第一还是第二。</p><p>QUIC也有个序列号，是递增的，任何宇哥序列号的包只发送一次，下次就要加1，那样就计算可以准确了</p><p>但是有一个问题，就是怎么知道包100和包101发送的是同样的内容呢？quic定义了一个offset概念。QUIC既然是面向连接的，也就像TCP一样，是一个数据流，发送的数据在这个数据流里面有个偏移量offset，可以通过offset查看数据发送到了那里，这样只有这个offset的包没有来，就要重发。如果来了，按照offset拼接，还是能够拼成一个流。</p><p><img src="http://www.chenjinxinlove.com/cdn/offsetbbb.png" alt="image"></p><ul><li>机制三： 无阻塞的多路复用</li></ul><p>有了自定义的连接和重传机制，就可以解决上面HTTP2.0的多路复用问题</p><p>同HTTP2.0一样，同一条 QUIC连接上可以创建多个stream，来发送多个HTTP请求，但是，QUIC是基于UDP的，一个连接上的多个stream之间没有依赖。这样，假如stream2丢了一个UDP包，后面跟着stream3的一个UDP包，虽然stream2的那个包需要重新传，但是stream3的包无需等待，就可以发给用户。</p><ul><li>机制四：自定义流量控制</li></ul><p>TCP的流量控制是通过滑动窗口协议。QUIC的流量控制也是通过window_update，来告诉对端它可以接受的字节数。但是QUIC的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个steam控制窗口。</p><p>在TCP协议中，接收端的窗口的起始点是下一个要接收并且ACK的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，因为TCP的ACK机制是基于序列号的累计应答，一旦ACK了一个序列号，就说明前面的都到了，所以是要前面的没到，后面的到了也不能ACK,就会导致后面的到了，也有可能超时重传，浪费带宽</p><p>QUIC的ACK是基于offset的，每个offset的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空档会等待到来或者重发，而窗口的起始位置为当前收到的最大offset，从这个offset到当前的stream所能容纳的最大缓存，是真正的窗口的大小，显然，那样更加准确。<br><img src="http://www.chenjinxinlove.com/cdn/offsetoss.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>限流算法</title>
      <link href="/2020/11/16/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
      <url>/2020/11/16/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>限流顾名思义是限制流量，限制流量的目的是为了保障服务稳定运行，避免服务被流量冲垮。当流量超出服务处理能力时，部分请求将会被限流组件拦截。被拦截的请求可能会被丢弃，如果是 C 端请求，那么这个请求可能会被导向指定的错误页上，而不是生硬的拒绝。这里我们丢弃掉一部分请求，以保证大部分请求可以正常响应。如果我们不这样做，那么服务崩溃后，所有请求都将无法响应了。当一台机器崩溃后，该机器的所有流量将由其他机器承担，这样就会造成剩余机器压力增大，进而导致奔溃，最后形成雪崩。除此之外，服务崩溃还会造成数据不一致的严重问题，特别是一些敏感数据。比如对于电商网站，如果后台服务准备将某笔订单数据存入数据库时，服务突然崩溃，导致数据没有落库。这个时候，开发同学就要想办法修订数据了。</p><p>综上，我们可以看出来限流的重要性。接下来，我将向大家介绍三种常用的限流算法，分别是计数器、漏桶算法和令牌桶算法。下面我们从最简单的计数器开始说起。</p><h2 id="2-限流算法"><a href="#2-限流算法" class="headerlink" title="2.限流算法"></a>2.限流算法</h2><h3 id="2-1-计数器"><a href="#2-1-计数器" class="headerlink" title="2.1 计数器"></a>2.1 计数器</h3><p>计数器算法的思想很简单，每当一个请求到来时，我们就将计数器加一，当计数器数值超过阈值后，就拒绝余下请求。一秒钟后，我们将计数器清零，开始新一轮的计数。计数器算法简单粗暴，易于实现。但是缺点也是有的，也就是所谓的”突刺现象”。举例说明一下，假如我们给计数器设置的阈值为100。系统瞬间内（比如10毫秒内）有200个请求到来，这个时候计数器只能放过其中的100个请求，余下的100个请求全部被拒绝掉。如果第二秒内没有请求到来，那么系统就处于空闲状态。也就是上一秒忙的要死，这一秒又闲的要死。如果我们能用一个容器将剩余的100个请求缓存起来，待计数器重置后再将这些请求放出来。这样系统在这两秒内的吞吐量就由100变成了200，提升了一倍。基于这个思考，下面我们再来看看漏桶算法。</p><h3 id="2-2-漏桶算法"><a href="#2-2-漏桶算法" class="headerlink" title="2.2 漏桶算法"></a>2.2 漏桶算法</h3><p>漏桶算法由流量容器、流量入口和出口组成。其中流量出口流速即为我们期望的限速值，比如 100 QPS。漏桶算法除了具备限流能力，还具备流量整型功能。下面我们通过一张图来了解漏桶算法。</p><p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15581714015488.jpg" alt="img"></p><p><strong>图片出处：未知</strong></p><p>如上图，流入漏桶流量的流速是不恒定的，经过漏桶限速后，流出流量的速度是恒定的。需要说明的是，漏桶的容量是有限的，一旦流入流量超出漏桶容量，这部分流量只能被丢弃了。</p><p>漏桶是一个比较好的限流整型工具，不过漏桶不能处理突发流量，一些观点认为这是它的一个缺点。不过如果较起真来，我觉得这个缺点是不成立的。毕竟漏桶本就是用来平滑流量的，如果支持突发，那么输出流量反而不平滑了。如果要找一种能够支持突发流量的限流算法，那么令牌桶算法可以满足需求。</p><h3 id="2-3-令牌桶算法"><a href="#2-3-令牌桶算法" class="headerlink" title="2.3 令牌桶算法"></a>2.3 令牌桶算法</h3><p>令牌桶和漏桶颇有几分相似，只不过令牌通里存放的是令牌。它的运行过程是这样的，一个令牌工厂按照设定值定期向令牌桶发放令牌。当令牌桶满了后，多出的令牌会被丢弃掉。每当一个请求到来时，该请求对应的线程会从令牌桶中取令牌。初期由于令牌桶中存放了很多个令牌，因此允许多个请求同时取令牌。当桶中没有令牌后，无法获取到令牌的请求可以丢弃，或者重试。下面我们来看一下的令牌桶示意图：</p><p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15581714388053.jpg" alt="img"></p><p><strong>图片出处：未知</strong></p><p>尽管令牌桶允许突发流量，但突发流量速率 R1 + 限流速率 R2 不能超过系统最大的处理能力 Rt，即 R1 + R2 ≤ Rt,否则会冲垮系统。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>以上就是本篇文章的全部内容。本篇文章简单分析几种常见限流算法的运行过程，限于能力原因，文章若有错误不妥之处还请指明。除了文字性描述，这里也把三种算法的简单实现代码贴出来 <a href="https://github.com/code4wt/RateLimiter" target="_blank" rel="noopener">RateLimiter</a>，有兴趣的同学自取。</p><p>好了，本篇文章到这里就结束了，感谢大家的阅读。</p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>binlog,redolog,undolog的区别?</title>
      <link href="/2020/11/16/binlog-redolog-undolog%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/11/16/binlog-redolog-undolog%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何设计一个秒杀系统?</title>
      <link href="/2020/11/16/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/11/16/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>​    <strong>1**</strong>：这个项目主要是针对处理高并发问题。主要考虑的问题有以下几个方面：**</p><p><strong>一、正确性。核心问题就是防止超卖，和重复下单。</strong></p><p><strong>二、高并发。主要是采用**</strong>Redis<strong>**进行缓存常用查询、消息队列异步下单、页面资源静态化等方面减去数据库压力。</strong></p><p><strong>三、安全性。主要有动态地址生成和接口放刷，双重**</strong>MD5<strong>**加密密码。</strong></p><p><strong>四、高可用性。一方面使用**</strong>Redis<strong><strong>集群的主从复制和主从切换保证</strong></strong>redis<strong><strong>的高可用性，另一方面，为防止</strong></strong>redsi<strong>**服务器宕</strong>   <strong>机，使用限流来防止**</strong>mysql<strong>**承受过多的请求。</strong></p><p>第二个项目介绍：</p><p>​    <strong>这个项目是我们实验室的项目，是和军方合作的项目。项目的流程，投标，竞标，开发和需求对接我都有参与。</strong></p><p><strong>项目主要是关于知识图谱的。主要是将客户的数据导入系统进行处理，定义**</strong>shcema,<strong>**建立本体以及本体之间的关系，然后按照一定的将数据导入图数据中，并提供搜索展示。</strong></p><p>​    <strong>数据的切割，就是将大的数据表切割成几张小表，表于表之间用外键关联，每个表生成一个实体，外键关联生成表与表之间的关系。</strong></p><p><strong>一如何防止超卖：</strong></p><p>​    1、利用数据库自带排他锁，当减库存的时候，进位where判断，只有库存余量大于0的时候才进行进库存; update goods set num = num - 1 WHERE id = 1001 and num &gt; 0; 2、也可以可用乐观锁CAS版本号机制。select version from goods WHERE id= 1001；update goods set num = num - 1, version = version + 1 WHERE id= 1001 AND num &gt; 0 AND version = @version(上面查到的version);</p><p><strong>二、服务器抗压思路：</strong></p><p>​    一、使用消息队列、异步生成订单；</p><p>​    二、redis库存量预缓存。只将少量的请求流入到服务器。如果全部卖完，拦截请求。</p><p>​    三、生成订单前，进行一系列的检验：是否还有库存，是否重复下单，这些数据都可以缓存。</p><p><strong>三、前端设计</strong></p><p>​    <strong>静态资源缓存：</strong>将活动页面上的所有可以静态的元素全部静态化，尽量减少动态元素；通过CDN缓存静态资源，来抗峰值。在url后面加上？即可。</p><p>​    <strong>禁止重复提交</strong>：前端:用户提交之后按钮置灰，禁止重复提交；后端：在进入页面时，服务器生成token并存到缓存或者session中，form表单使用隐藏域来存储这个token，提交之后带有token.后端收到这个token,看是否与服务器生成的token一致，如果不一致就是重复提交。如果一致，处理完之后清除token.</p><p>服务器返回表单页面时，会先生成一个subToken保存于session，并把该subToen传给表单页面。当表单提交时会带上subToken，服务器拦截器Interceptor会拦截该请求，拦截器判断session保存的subToken和表单提交subToken是否一致。若不一致或session的subToken为空或表单未携带subToken则不通过。</p><p>首次提交表单时session的subToken与表单携带的subToken一致走正常流程，然后拦截器内会删除session保存的subToken。当再次提交表单时由于session的subToken为空则不通过。从而实现了防止表单重复提交。</p><p>​    <strong>用户限流：某一时间段内只允许用户提交少数次请求，**</strong>IP<strong><strong>限流</strong></strong>(Nginx<strong><strong>设置</strong></strong>IP<strong><strong>地址限流</strong></strong>)<strong>**。</strong></p><p>​    </p><p><strong>中间代理层：</strong></p><p>​    <strong>利用负载均衡（例如反响代理**</strong>Nginx<strong>**等）使用多个服务器并发处理请求，减小服务器压力。</strong>   </p><p>​    <strong>(**</strong>正向代理代理客户端<strong><strong>VPN</strong></strong>，反向代理代理服务器。<strong>**NGINX)</strong> </p><p>​    横向增加服务器数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。普通轮询算法、比例加权轮询、ip路由负载、基于服务器响应时间负载分配、根据域名负载。</p><p>轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><p>指定权重：指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><p>IP绑定ip_hash：每个请求按ip的hash结果分配，<strong>这样每个访客固定访问一个后端服务器</strong>，<strong>可以解决**</strong>session<strong>**的问题。</strong></p><p>url_hash：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p><p>fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><p><strong>服务层：</strong></p><p>​    <strong>业务分离**</strong>:**将秒杀业务系统和其他业务分离，单独放在高配服务器上。</p><p>​    采<strong>用消息队列缓存请求</strong>：将大流量请求写到消息队列缓存，利用服务器根据自己的处理能力主动到消息缓存队列中抓取任务处理请求。</p><p>​    <strong>利用缓存应对读请求</strong>：对于读多写少业务，大部分请求是查询请求，所以可以读写分离，利用缓存分担数据库压力。</p><p><strong>数据库层：</strong></p><p>​    上游就需要把请求拦截掉，数据库层只承担“能力范围内”的访问请求。所以，上面通过在服务层引入队列和缓存，让最底层的数据库高枕无忧。可以对数据库进行优化，减少数据库压力。</p><p>​    如果redis挂掉的话，如果提高数据库的并发能力：</p><p>​    <strong>业务拆分</strong>：将不同功能的模块拆分，使用不同的数据库。</p><p>​    MySQL<strong>主从复制，读写分离</strong>：</p><p>​    <strong>分表分库：</strong></p><p><strong>其他策略：为请求分配成功状态或者分配秒杀资格，将没有资格的请求全部过滤，</strong>只有有资格的才能参与秒杀。说到底的秒杀这个高并发，并不是真正的处理高并发请求，而是如何应对高并发。将大量请求拦截然后放小量请求到数据库执行抢单是完全可以的，不用担心请求丢失的问题。</p><p><strong>四、怎么保证**</strong>redis<strong>**缓存和数据库的一致性</strong></p><p>​    <strong>延时双删；</strong></p><p>​    存在不一致问题的，基本都是库存量。秒杀系统的设计，最重要的是不能超卖，这个问题我们已经谈过，用mysql排他锁或者乐观CAS版本号机制可以防止。而即使redis库存量比实际mysql库存量大，依然不会超卖。而redis库存量比mysql库存量小，可能发生没少卖的情况。少卖，问题不大。如果不能少卖，可以将redis预库存调大，他主要起到拦截请求降流的作用，一致不一致问题不大。</p><p><strong>五、安全性问题</strong></p><p>​    <strong>1**</strong>、动态地址生成**  </p><p>​    <strong>2**</strong>、接口防刷**</p><p>​    </p><p><strong>六、消息队列</strong></p><p>​    <strong>防止重复消费</strong>：重复消费在消息队列所存在的问题中，从来都不是一个严重的问题。如果是消息是读，那多消费一次没啥影响。如果是写，例如我们这个订单生成，消费之前，查询一下是否之前已经存在用户ID商品ID构成的订单，我们可以将生成的订单存入缓存，所以查询一次也不费劲。</p><p>​    <strong>消息的消费结果如何返回给消息发送方</strong>：客户端轮询订单生成结果。</p><p>​    <strong>消息丢失：</strong>秒杀系统中，本来就是万中选一的，丢失无所谓。如果是重要的信息，我们可以从三个角度来避免。如果是发送者丢失，开启confirm机制，如果队列丢失，开始queue持久化和消息持久化。如果是消费者丢失，关闭自动ACK,当我们消费完之后，调用API给queue发送确认信息。</p><p><strong>七、秒杀流程、画架构图</strong></p><p>​    1、登录进入商品列表页面，静态资源缓存</p><p>​    2、点击进入商品详情页面，静态资源缓存，ajax获取验证码(服务器生成三个数的预算，并将结果缓存到redis);</p><p>​    3、点击秒杀, 将验证码结果和商品ID传给后端，如果结果正确。动态生成随机串UUID,结合用户ID和商品ID存入redis，并将path传给前端。前端获取path后，再根据path地址调用秒杀服务；</p><p>​    4、服务端获取请求的path参数，去查缓存是否在；</p><p>​    5、如果存在，预减redis库存，如果还有库存，看是否已经生成订单，没有的话就将请求入消息队列。</p><p>​    6、从消息队列中取消息：获取商品Id和用户ID,判断库存，重复下单；然后下单。</p><p>​    7、下单：减库存，生成订单； </p><p>​    8、前端轮询订单生成结果。50ms继续轮询或者秒杀是否成功和失败;</p><p><strong>八、优化策略</strong></p><p>​    多服务器负载均衡、</p><p><strong>简单介绍一下**</strong>Nginx** </p><p>​    Nginx是一款<strong>轻量级的**</strong>Web** <strong>服务器**</strong>/<strong><strong>反向代理服务器及电子邮件（</strong></strong>IMAP/POP3<strong>**）代理服务器</strong>。 <strong>Nginx</strong> <strong>主要提供反向代理、负载均衡、动静分离**</strong>(<strong><strong>静态资源服务</strong></strong>)<strong>**等服务</strong>。下面我简单地介绍一下这些名词。</p><p>​    正向代理：某些情况下，<strong>代理我们用户去访问服务器</strong>，<strong>需要用户手动的设置代理服务器的**</strong>ip<strong>**和端口号。</strong>正向代理比较常见的一个例子就是 VPN了。</p><p>​    反向代理：<strong>是用来代理服务器的，代理我们要访问的目标服务器。代理服务器接受请求，然后将请求转发给内</strong></p><p><strong>部网络的服务器，</strong>并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。</p><p>​    <strong>负载均衡</strong> </p><p>​    在高并发情况下需要使用，其原理就是将并发请求分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集</p><p>群)共同完成工作任务，从而提高了数据的吞吐量。Nginx支持的<strong>weight**</strong>轮询（默认）、<strong><strong>ip_hash</strong></strong>、<strong><strong>fair</strong></strong>、<strong><strong>url_hash</strong></strong>这四种负载均衡调度算法**，感兴趣的可以自行查阅。负载均衡相比于反向代理更侧重的时将请求分担到多台服务器上去，所以谈论负载均衡只有在提供某服务的服务器大于两台时才有意义。</p><p>​    <strong>动静分离</strong> </p><p>​    动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以</p><p>后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p><p>22.设计秒杀方案（从高并发、快速响应、高可用三方面回答，高并发（增加网络带宽、DNS域名解析分发多台服务器、使用前置代理服务器ngnix、CDN内容分发、数据库查询优化（读写分离、分库分表）），快速响应（缓存服务器（memcached、redis）、能使用静态页面就用静态页面，减少容器解析、把常访问的图片等内容缓存）、高可用（热备，如数据库服务器的热备、集群监控（如使用zabbix，重点关注IO、内存、带宽和机器load）））</p><p>服务器返回表单页面时，会先生成一个subToken保存于session，并把该subToen传给表单页面。当表单提交时会带上subToken，服务器拦截器Interceptor会拦截该请求，拦截器判断session保存的subToken和表单提交subToken是否一致。若不一致或session的subToken为空或表单未携带subToken则不通过。</p><p>首次提交表单时session的subToken与表单携带的subToken一致走正常流程，然后拦截器内会删除session保存的subToken。当再次提交表单时由于session的subToken为空则不通过。从而实现了防止表单重复提交。</p><p><strong>缓存、降级和限流：</strong></p><p><strong>在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流：</strong></p><p>​    <strong>缓存：缓存的目的是提升系统访问速度和增大系统处理容量</strong></p><p>​    <strong>降级：降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉，待高峰或者问题解决后再打开</strong></p><p>​    <strong>限流：限流的目的是通过对并发访问**</strong>/<strong>**请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理。</strong></p><p>​    计数器法：设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置 counter。缺点：统计的精度太低，无法处理临界问题。如果我在单位时间<strong>1s**</strong>内的前<strong><strong>10ms</strong></strong>，已经通过了<strong><strong>100</strong></strong>个请求，那后面的<strong><strong>990ms</strong></strong>，只能眼巴巴的把请求拒绝，我们把这种现象称为<strong><strong>“</strong></strong>突刺现象<strong>**”</strong></p><p> public boolean grant() {</p><p>​    long now = getNowTime();</p><p>​    if (now &lt; timeStamp + interval) {</p><p>​      // 在时间窗口内</p><p>​      reqCount++;</p><p>​      // 判断当前时间窗口内是否超过最大请求控制数</p><p>​      return reqCount &lt;= limit;</p><p>​     } else {</p><p>​      timeStamp = now;</p><p>​      // 超时后重置</p><p>​      reqCount = 1;</p><p>​      return true;</p><p>​    }</p><p>  }</p><p>滑动窗口算法：将窗口更加细分，每个窗口都有自己的计数器，当总计算达到限定时，限流。这个滑动窗口只是将计算法变得更平滑而已。本质一样。</p><p>漏斗法：将容器比作一个漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。</p><p>在<strong>令牌桶算法</strong>中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。通过Google开源的guava包，我们可以很轻松的创建一个令牌桶算法的限流器。</p><p>Google开源工具包Guava提供了限流工具类<strong>RateLimiter</strong>，该类基于令牌桶算法(Token Bucket)来完成限流，非常易于使用。RateLimiter经常用于限制对一些物理资源或者逻辑资源的访问速率，它支持两种获取permits接口，一<strong>种是如果拿不到立刻返回**</strong>false<strong><strong>（</strong></strong>tryAcquire()<strong><strong>），一种会阻塞等待一段时间看能不能拿到（</strong></strong>tryAcquire(long timeout, TimeUnit unit)<strong>**）。</strong></p><p>缺点：传<strong>统的方式整合**</strong>RateLimiter** <strong>有很大的缺点</strong>：<strong>代码重复量特别大**</strong>，而且本身不支持注解方式。**</p><p><strong>ES:</strong></p><p>Elasticsearch是一个近乎实时的搜索平台。这意味着从索引文档到可以搜索的时间只有轻微的延迟（通常是1秒）.</p><p>集群是一个或多个节点(服务器)的集合. 节点是一个单独的服务器，它是集群的一部分，存储数据，并参与集群的索引和搜索功能。</p><p>索引是具有某种相似特征的文档的集合。例如，你可以有一个顾客数据索引，产品目录索引和订单数据索引。文档是可以被索引的基本信息单元。文档用JSON表示,有多个field,如年龄，性别，地址。</p><p>Elasticsearch提供了将你的索引细分为多个碎片（或者叫分片）的能力。在创建索引时，可以简单地定义所需的分片数量。每个分片本身就是一个功能完全独立的“索引”，可以驻留在集群中的任何节点上。Shards &amp; Replicas.每个分片又有副本。</p><p><strong>正向索引是通过**</strong>key<strong><strong>找</strong></strong>value<strong><strong>，反向索引则是通过</strong></strong>value<strong><strong>找</strong></strong>key<strong>**。</strong></p><p>首先将文本分割成一系列被称为语汇单元(token)的独立原子元素，此过程即为文档分析，然后建立倒排索引，也就是每个term关键词出现在哪些文档之中。ID TERM DOCUMENT List.，Elasticsearch分别为每个field都建立了一个倒排索引。</p><p>Elasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是Term Dictionary。又有一个Term Index，就像字典里的索引页一样，A开头的有哪些term，分别在哪页，可以理<strong>解**</strong>term index<strong>**是一颗树</strong>：这棵树不会包含所有的term，它包含的是term的一些前缀。通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。再结合FST(Finite State Transducers)<strong>的压缩技术，可以使**</strong>term index<strong><strong>缓存到内存中。从</strong></strong>term index<strong><strong>查到对应的</strong></strong>term dictionary<strong><strong>的</strong></strong>block<strong><strong>位置之后，再去磁盘上找</strong></strong>term<strong>**，大大减少了磁盘随机读的次数。</strong></p><p><strong>用**</strong>FST<strong><strong>压缩</strong></strong>term index<strong><strong>外，对</strong></strong>posting list<strong><strong>也有压缩技巧，如</strong></strong>bitmap<strong>**；</strong></p><p><strong>联合索引直接利用跳表**</strong>(Skip list)<strong><strong>的数据结构快速做“与”运算，或者利用上面提到的</strong></strong>bitset<strong>**按位“与”。</strong></p><p><strong>shard = hash(document_id) % (num_of_primary_shards)</strong></p><p>字典树：</p><p>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</p><p>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</p><p>每个节点的所有子节点包含的字符都不相同。</p><p><strong>系统设计问题：</strong></p><p>​    <strong>1**</strong>、**让你系统的设计一个高并发的架构，你会从哪几个方面考虑？</p><p>​    <strong>2**</strong>、一个千万级的<strong><strong>APP</strong></strong>，你要搞定关注和粉丝列表，你用什么来做。要求最后一个关注的在最前面。新增和取关都要比较快的反馈你怎么做？如果一个人关注了之后，服务器宕机了怎么办？**</p><p>​    <strong>3**</strong>、**设计一个榨汁机类，面向对象怎么设计 </p><p>​    <strong>4**</strong>、**OOD design：计费停车场</p><p>​    5、多个服务器间共享session的解决方案</p><p>​    问了new一个对象的加载顺序, 答了从父类到子类的加载过程 静态变量和静态块, 哪个先加载, 答了静态变量。</p><p>​    假设有这么一个场景，有一条新闻，新闻的评论量可能很大，如何设计评论的读和写</p><p>​    你如果写用InnoDB，读用Myisam的话，主从同步怎么做</p><p>​    假设如果有同一时间海量数据入库，你怎么做（期间扯到了鹿晗关晓彤，这种微博大 V给他安排上，还提了消息队列做削峰）</p><p>​    你对Elasticsearch有什么了解</p><p>然后就问开放题了，问12306怎么处理大量请求。 </p><p>  问12306怎么处理大量的读请求。 </p><p>  问12306为什么有的时候会有看的时候有票，但是买的时候没票的情况，问我有可能会是什么原因。 </p><p>  问12306可能存在第三方软件帮忙抢票，怎么防止。</p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Springg事务</title>
      <link href="/2020/11/16/Springg%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/11/16/Springg%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-中的事务传播行为了解吗-TransactionDefinition-接口中哪五个表示隔离级别的常量"><a href="#Spring-中的事务传播行为了解吗-TransactionDefinition-接口中哪五个表示隔离级别的常量" class="headerlink" title="Spring 中的事务传播行为了解吗?TransactionDefinition 接口中哪五个表示隔离级别的常量?"></a>Spring 中的事务传播行为了解吗?TransactionDefinition 接口中哪五个表示隔离级别的常量?</h2><h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>事务传播行为（为了解决业务层方法之间互相调用的事务问题）： 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在 TransactionDefinition 定义中包括了如下几个表示传播行为的常量：</p><p><strong>支持当前事务的情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><ul><li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别.</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GC调优</title>
      <link href="/2020/11/16/GC%E8%B0%83%E4%BC%98/"/>
      <url>/2020/11/16/GC%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Java内存区域常见配置参数概览"><a href="#Java内存区域常见配置参数概览" class="headerlink" title="Java内存区域常见配置参数概览"></a>Java内存区域常见配置参数概览</h3><blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/内存区域常见配置参数.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0.png" alt="img"></a></p><h3 id="堆参数"><a href="#堆参数" class="headerlink" title="堆参数"></a>堆参数</h3><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/media/pictures/jvm/java_jvm_heap_parameters.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/media/pictures/jvm/java_jvm_heap_parameters.png" alt="堆参数"></a></p><h3 id="回收器参数"><a href="#回收器参数" class="headerlink" title="回收器参数"></a>回收器参数</h3><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/media/pictures/jvm/java_jvm_garbage_collector_parameters.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/media/pictures/jvm/java_jvm_garbage_collector_parameters.png" alt="垃圾回收器参数"></a></p><p>如上表所示，目前<strong>主要有串行、并行和并发三种</strong>，对于大内存的应用而言，串行的性能太低，因此使用到的主要是并行和并发两种。并行和并发 GC 的策略通过 <code>UseParallelGC</code>和<code>UseConcMarkSweepGC</code> 来指定，还有一些细节的配置参数用来配置策略的执行方式。例如：<code>XX:ParallelGCThreads</code>， <code>XX:CMSInitiatingOccupancyFraction</code> 等。 通常：Young 区对象回收只可选择并行（耗时间），Old 区选择并发（耗 CPU）。</p><h3 id="项目中常用配置"><a href="#项目中常用配置" class="headerlink" title="项目中常用配置"></a>项目中常用配置</h3><blockquote><p>备注：在Java8中永久代的参数<code>-XX:PermSize</code> 和<code>-XX：MaxPermSize</code>已经失效。</p></blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/media/pictures/jvm/java_jvm_suggest_parameters.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/media/pictures/jvm/java_jvm_suggest_parameters.png" alt="项目中垃圾回收器常用配置"></a></p><h3 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h3><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/media/pictures/jvm/java_jvm_compose_garbage_collector.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/media/pictures/jvm/java_jvm_compose_garbage_collector.png" alt="垃圾回收器常用组合"></a></p><h2 id="常用-GC-调优策略"><a href="#常用-GC-调优策略" class="headerlink" title="常用 GC 调优策略"></a>常用 GC 调优策略</h2><ol><li>GC 调优原则；</li><li>GC 调优目的；</li><li>GC 调优策略；</li></ol><h3 id="GC-调优原则"><a href="#GC-调优原则" class="headerlink" title="GC 调优原则"></a>GC 调优原则</h3><p>在调优之前，我们需要记住下面的原则：</p><blockquote><p>多数的 Java 应用不需要在服务器上进行 GC 优化； 多数导致 GC 问题的 Java 应用，都不是因为我们参数设置错误，而是代码问题； 在应用上线之前，先考虑将机器的 JVM 参数设置到最优（最适合）； 减少创建对象的数量； 减少使用全局变量和大对象； GC 优化是到最后不得已才采用的手段； 在实际使用中，分析 GC 情况优化代码比优化 GC 参数要多得多。</p></blockquote><h3 id="GC-调优目的"><a href="#GC-调优目的" class="headerlink" title="GC 调优目的"></a>GC 调优目的</h3><p>将转移到老年代的对象数量降低到最小； 减少 GC 的执行时间。</p><h3 id="GC-调优策略"><a href="#GC-调优策略" class="headerlink" title="GC 调优策略"></a>GC 调优策略</h3><p><strong>策略 1：</strong>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p><p><strong>策略 2：</strong>大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。<code>-XX:PretenureSizeThreshold</code> 可以设置直接进入老年代的对象大小。</p><p><strong>策略 3：</strong>合理设置进入老年代对象的年龄，<code>-XX:MaxTenuringThreshold</code> 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。</p><p><strong>策略 4：</strong>设置稳定的堆大小，堆大小设置有两个参数：<code>-Xms</code> 初始化堆大小，<code>-Xmx</code> 最大堆大小。</p><p><strong>策略5：</strong>注意： 如果满足下面的指标，<strong>则一般不需要进行 GC 优化：</strong></p><blockquote><p>MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring如何解决循环依赖?</title>
      <link href="/2020/11/15/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2020/11/15/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实际工作中，经常由于设计不佳或者各种因素，导致类之间相互依赖。这些类可能单独使用时不会出问题，但是在使用Spring进行管理的时候可能就会抛出BeanCurrentlyInCreationException等异常 。当抛出这种异常时表示Spring解决不了该循环依赖，本文将简要说明Spring对于循环依赖的解决方法。</p><h2 id="循环依赖的产生和解决的前提"><a href="#循环依赖的产生和解决的前提" class="headerlink" title="循环依赖的产生和解决的前提"></a>循环依赖的产生和解决的前提</h2><p>循环依赖的产生可能有很多种情况，例如：</p><ul><li>A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象</li><li>A的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象，以及反之</li><li>A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象，以及反之</li></ul><p>当然，Spring对于循环依赖的解决不是无条件的，首先前提条件是针对scope单例并且没有显式指明不需要解决循环依赖的对象，而且要求该对象没有被代理过。同时Spring解决循环依赖也不是万能，以上三种情况只能解决两种，第一种在构造方法中相互依赖的情况Spring也无力回天。结论先给在这，下面来看看Spring的解决方法，知道了解决方案就能明白为啥第一种情况无法解决了。</p><h2 id="Spring对于循环依赖的解决"><a href="#Spring对于循环依赖的解决" class="headerlink" title="Spring对于循环依赖的解决"></a>Spring对于循环依赖的解决</h2><p>Spring循环依赖的理论依据其实是Java基于引用传递，当我们获取到对象的引用时，对象的field或者或属性是可以延后设置的。<br> Spring单例对象的初始化其实可以分为三步：</p><ul><li>createBeanInstance， 实例化，实际上就是调用对应的构造方法构造对象，此时只是调用了构造方法，spring xml中指定的property并没有进行populate</li><li>populateBean，填充属性，这步对spring xml中指定的property进行populate</li><li>initializeBean，调用spring xml中指定的init方法，或者AfterPropertiesSet方法<br> 会发生循环依赖的步骤集中在第一步和第二步。</li></ul><h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>对于单例对象来说，在Spring的整个容器的生命周期内，有且只存在一个对象，很容易想到这个对象应该存在Cache中，Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至使用了“三级缓存”。</p><p>“三级缓存”主要是指</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="emphasis">** Cache of singleton objects: bean name --&gt; bean instance *</span>/</span></span></span><br><span class="line">private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment"><span class="markdown">/<span class="emphasis">** Cache of singleton factories: bean name --&gt; ObjectFactory *</span>/</span></span></span><br><span class="line">private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment"><span class="markdown">/<span class="emphasis">** Cache of early singleton objects: bean name --&gt; bean instance *</span>/</span></span></span><br><span class="line">private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>从字面意思来说：singletonObjects指单例对象的cache，singletonFactories指单例对象工厂的cache，earlySingletonObjects指提前曝光的单例对象的cache。以上三个cache构成了三级缓存，Spring就用这三级缓存巧妙的解决了循环依赖问题。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>回想上篇文章中关于Bean创建的过程，首先Spring会尝试从缓存中获取，这个缓存就是指singletonObjects，主要调用的方法是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">   Object singletonObject = <span class="keyword">this</span>.singletonObjects.<span class="keyword">get</span>(beanName);</span><br><span class="line">   <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      synchronized (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">         singletonObject = <span class="keyword">this</span>.earlySingletonObjects.<span class="keyword">get</span>(beanName);</span><br><span class="line">         <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.<span class="keyword">get</span>(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">               singletonObject = singletonFactory.getObject();</span><br><span class="line">               <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">               <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);&#125;</span><br></pre></td></tr></table></figure><p>首先解释两个参数：</p><ul><li>isSingletonCurrentlyInCreation 判断对应的单例对象是否在创建中，当单例对象没有被初始化完全(例如A定义的构造函数依赖了B对象，得先去创建B对象，或者在populatebean过程中依赖了B对象，得先去创建B对象，此时A处于创建中)</li><li>allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象</li></ul><p>分析getSingleton的整个过程，Spring首先从singletonObjects（一级缓存）中尝试获取，如果获取不到并且对象在创建中，则尝试从earlySingletonObjects(二级缓存)中获取，如果还是获取不到并且允许从singletonFactories通过getObject获取，则通过singletonFactory.getObject()(三级缓存)获取。如果获取到了则</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">this</span><span class="selector-class">.earlySingletonObjects</span><span class="selector-class">.put</span>(<span class="selector-tag">beanName</span>, <span class="selector-tag">singletonObject</span>);</span><br><span class="line"><span class="selector-tag">this</span><span class="selector-class">.singletonFactories</span><span class="selector-class">.remove</span>(<span class="selector-tag">beanName</span>);</span><br></pre></td></tr></table></figure><p>则移除对应的singletonFactory,将singletonObject放入到earlySingletonObjects，其实就是将三级缓存提升到二级缓存中！</p><p>Spring解决循环依赖的诀窍就在于singletonFactories这个cache，这个cache中存的是类型为ObjectFactory，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;&#125;</span><br></pre></td></tr></table></figure><p>在bean创建过程中，有两处比较重要的匿名内部类实现了该接口。一处是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span>   <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">      &#125;      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         destroySingleton(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;   &#125;</span><br></pre></td></tr></table></figure><p>在上文已经提到，Spring利用其创建bean（这样做真的很不明确呀…）</p><p>另一处就是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span>   <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">   &#125;&#125;);</span><br></pre></td></tr></table></figure><p>此处就是解决循环依赖的关键，这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来的。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p><p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，长大成人，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象也蜕变完美了！一切都是这么神奇！！</p><p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring通过三级缓存加上“提前曝光”机制，配合Java的对象引用原理，比较完美地解决了某些情况下的循环依赖问题！</p><p>作者：LNAmp<br>链接：<a href="https://www.jianshu.com/p/6c359768b1dc" target="_blank" rel="noopener">https://www.jianshu.com/p/6c359768b1dc</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解</title>
      <link href="/2020/11/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/11/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：<br>　　　　1.@Target,<br>　　　　2.@Retention,<br>　　　　3.@Documented,<br>　　　　4.@Inherited<br>　　这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明</p><p><strong>@Target：</strong></p><p>　　　@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。</p><p>　　<strong>作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</strong></p><p>　　<strong>取值(ElementType)有：</strong></p><p>　　　　1.CONSTRUCTOR:用于描述构造器<br>　　　　2.FIELD:用于描述域<br>　　　　3.LOCAL_VARIABLE:用于描述局部变量<br>　　　　4.METHOD:用于描述方法<br>　　　　5.PACKAGE:用于描述包<br>　　　　6.PARAMETER:用于描述参数<br>　　　　7.TYPE:用于描述类、接口(包括注解类型) 或enum声明</p><p><strong>@Retention：</strong></p><p>　　<strong>@Retention</strong>定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。</p><p>　　<strong>作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</strong></p><p>　　<strong>取值（RetentionPoicy）有：</strong></p><p>　　　　1.SOURCE:在源文件中有效（即源文件保留）<br>　　　　2.CLASS:在class文件中有效（即class保留）<br>　　　　3.RUNTIME:在运行时有效（即运行时保留）</p><p>　<strong>@Documented:</strong></p><p>　　<strong><em>\</em>@**</strong>Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。</p><p><strong>@Inherited：</strong></p><p>　　@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</p><p>　　注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。</p><p>　　当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper的leader选举</title>
      <link href="/2020/11/14/Zookeeper%E7%9A%84leader%E9%80%89%E4%B8%BE/"/>
      <url>/2020/11/14/Zookeeper%E7%9A%84leader%E9%80%89%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Zookeeper的Leader选举"><a href="#Zookeeper的Leader选举" class="headerlink" title="Zookeeper的Leader选举"></a>Zookeeper的Leader选举</h1><p>前面我们聊了一下ZAB协议以及Zookeeper的基础概念，心想着都到这个份上了，那还是把剩下的“Leader选举”、“分布式锁”、“惊群和脑裂”都跟大家简单聊聊,这些知识应该足够准备校招的你<code>造火箭</code>了。</p><p>今天首先说一下Zookeeper的<code>Leader选举流程</code>以及其中涉及的<code>FastLeaderElection选举算法</code>。</p><h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p><strong>ZAB协议是保证Zookeeper集群数据一致性协议其中会涉及选举流程，FastLeaderElection是Zookeeper选举Leader的算法之一。这两点概念一定要搞清楚，不然很容易混为一谈。</strong></p><h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>两个关键时期：</p><ul><li>启动Zookeeper集群时</li><li>Leader崩溃进行崩溃恢复时</li></ul><p><strong>一些基础概念你需要提前预知：</strong></p><p><img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/887a4826415141fda9e48fbf29503ccd~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>1.对选举Leader的要求:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选出的leader节点上要持有最高zxid</span><br><span class="line">选出的leader要有过半数节点同意</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>2.内置实现的选举算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LeaderElection</span><br><span class="line">FastLeaderElection（默认的）</span><br><span class="line">AuthFastLeaderElection</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>3.选举状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LOOKING：竞选状态</span><br><span class="line">FOLLOWING：跟随状态，同步leader状态，参与投票</span><br><span class="line">OBSERVING：管擦状态，同步leader状态，不参与投票</span><br><span class="line">LEADING：领导者状态</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>4.部分名词</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务器id---myid(或后文的sid，集群模式下必有该配置项) </span><br><span class="line">事务id---服务器中存放的最大zxid</span><br><span class="line">逻辑时钟---发起的投票轮数计数</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h2><blockquote><p>Zookeeper要求集群机器必须是<code>奇数个</code>(避免脑裂，下文会讲)，那么我们假设有三台服务器。接着介绍一下三台服务器的Leader选举流程。</p></blockquote><ul><li>每个Server发出一个投票。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID，使用(myid, ZXID)来表示，此时Server1的投票为(1, 0)，Server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS：不懂什么叫为自己投票(不知道票的数据结构？)，别急后面带你看源码！！！</span><br></pre></td></tr></table></figure><ul><li>接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。</li><li>处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行比较，比较规则如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 优先判断ZXID。ZXID（事务ID）比较大的服务器优先作为Leader。</span><br><span class="line"> </span><br><span class="line"> 如果ZXID相同，那么就比较myid。myid（服务器ID）较大的服务器作为Leader服务器。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>对于Server1而言，它的投票是(1, 0)，接收Server2的投票为(2, 0)，首先会比较两者的ZXID，均为0，再比较myid，此时Server2的myid最大，于是更新自己的投票为(2, 0)，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS:于是更新自己的投票为(2, 0)?</span><br></pre></td></tr></table></figure><p>其涵义指的是将自己下次发出的投票信息更新为(2, 0)，以该票作为新的投票依据。</p><ul><li>统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于Server1、Server2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出了Leader。</li><li>改变服务器状态。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。</li></ul><hr><p><strong>简而言之</strong></p><p>1.每个服务实例均发起选举自己为leader的投票。</p><p>2.其他服务实例收到投票邀请时，比较发起者的数据事务id是否比自己最新的事务ID大，大则给它投一票，小则不投票，相等则比较发起者的服务器ID，大则投票给它 。</p><p>3.发起者收到大家的投票反馈后，看投票数（包括自己的票数）是否大于集群的半数，大于则成为leader，未超过半数且leader未选出，则再次发起投票。</p><h3 id="Leader选举算法"><a href="#Leader选举算法" class="headerlink" title="Leader选举算法"></a>Leader选举算法</h3><blockquote><p>在了解了选举流程后我们介绍一下Zookeeper源码中对于算法中的实现细节。</p></blockquote><p>借助网上随处可以百度到的算法描述，我再一次针对其中涉及的<code>疑难点</code>做一个解说，其大致流程如下：</p><p><strong>第一次投票</strong>。无论哪种导致进行Leader选举，集群的所有机器都处于试图选举出一个Leader的状态，即LOOKING状态，LOOKING机器会向所有其他机器发送消息，该消息称为投票。投票中包含了SID（服务器的唯一标识）和ZXID（事务ID），(SID, ZXID)形式来标识一次投票信息。</p><p>假定Zookeeper由5台机器组成，SID分别为1、2、3、4、5，ZXID分别为9、9、9、8、8，并且此时SID为2的机器是Leader机器，某一时刻，1、2所在机器出现故障，因此集群开始进行Leader选举。在第一次投票时，每台机器都会将自己作为投票对象，于是SID为3、4、5的机器投票情况分别为(3, 9)，(4, 8)， (5, 8)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">此时五台机器手里的投票分别为：</span><br><span class="line">服务器一：（1，9）假设故障 ×</span><br><span class="line">服务器二：（2，9）假设故障 ×</span><br><span class="line">服务器三：（3，9）</span><br><span class="line">服务器四：（4，8）</span><br><span class="line">服务器五：（5，8）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>变更投票</strong>。每台机器发出投票后，也会收到其他机器的投票，每台机器会根据一定规则来处理收到的其他机器的投票，并以此来决定是否需要变更自己的投票，这个规则也是整个Leader选举算法的核心所在，其中术语描述如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vote_sid：接收到的投票中所推举Leader服务器的SID。</span><br><span class="line"></span><br><span class="line">vote_zxid：接收到的投票中所推举Leader服务器的ZXID。</span><br><span class="line"></span><br><span class="line">self_sid：当前服务器自己的SID。</span><br><span class="line"></span><br><span class="line">self_zxid：当前服务器自己的ZXID。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>每次对收到的投票的处理，都是对(vote_sid, vote_zxid)和(self_sid, self_zxid)对比的过程。</p><p>规则一：如果vote_zxid大于self_zxid，就认可当前收到的投票，并再次将该投票发送出去。(接收到的事务id大于自己当前事务id)</p><p>规则二：如果vote_zxid小于self_zxid，那么坚持自己的投票，不做任何变更。(接收到的事务id小于自己当前事务id)</p><p>规则三：如果vote_zxid等于self_zxid，那么就对比两者的SID，如果vote_sid大于self_sid，那么就认可当前收到的投票，并再次将该投票发送出去。（事务ID相等比较服务器ID及zxid）</p><p>规则四：如果vote_zxid等于self_zxid，并且vote_sid小于self_sid，那么坚持自己的投票，不做任何变更。</p><p><strong>具体流程如图：</strong></p><p><img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba3f5da1aad24e7da6ef1309643d10e9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p><strong>确定Leader</strong>。经过第二轮投票后，集群中的每台机器都会再次接收到其他机器的投票，然后开始统计投票，如果一台机器收到了超过半数的相同投票，那么这个投票对应的SID机器即为Leader。此时Server3将成为Leader。</p><h2 id="选举流程源码"><a href="#选举流程源码" class="headerlink" title="选举流程源码"></a>选举流程源码</h2><blockquote><p>光说不练假把式，搞懂了Leader选举的基本流程，再来探究一下源码，源码之下无秘密！</p></blockquote><p>用我的地址去拉取源码可能会快些。<a href="https://hub.fastgit.org/Xxianglei/zookeeper.git" target="_blank" rel="noopener">Zookeeper源码 git clone</a></p><h3 id="投票数据结构"><a href="#投票数据结构" class="headerlink" title="投票数据结构"></a>投票数据结构</h3><p>我们先解决前面的疑惑投票（或者说票）到底是什么结构？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vote</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> version;<span class="comment">// 版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id;<span class="comment">//被推举的Leader的SID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> zxid;<span class="comment">//被推举的Leader事务ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> electionEpoch;<span class="comment">//逻辑时钟，用来判断多个投票是否在同一轮选举周期中，每轮自加1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> peerEpoch;<span class="comment">//被推举的Leader的epoch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerState state;<span class="comment">//当前服务器的状态</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务器状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ServerState &#123;</span><br><span class="line">        LOOKING,</span><br><span class="line">        FOLLOWING,</span><br><span class="line">        LEADING,</span><br><span class="line">        OBSERVING</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>知道我们投的是什么票了，接下来我们理一下整个算法流程。</p><h3 id="源码入口"><a href="#源码入口" class="headerlink" title="源码入口"></a>源码入口</h3><blockquote><p>zookeeper\zookeeper-server\src\main\java\org\apache\zookeeper\server\quorum下</p></blockquote><p>非核心代码我给大家省去了，如果有兴趣想研究，可以按着我的分析流程查看源码细节。</p><h4 id="QuorumPeerMain-java"><a href="#QuorumPeerMain-java" class="headerlink" title="QuorumPeerMain.java"></a>QuorumPeerMain.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * To start the replicated server specify the configuration file name on</span></span><br><span class="line"><span class="comment"> * the command line.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args path to the configfile</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    QuorumPeerMain main = <span class="keyword">new</span> QuorumPeerMain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        main.initializeAndRun(args);<span class="comment">//入口</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(<span class="string">"Exiting normally"</span>);</span><br><span class="line">    ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeAndRun</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ConfigException, IOException, AdminServerException </span>&#123;</span><br><span class="line">    QuorumPeerConfig config = <span class="keyword">new</span> QuorumPeerConfig();</span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">        config.parse(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start and schedule the the purge task</span></span><br><span class="line">    DatadirCleanupManager purgeMgr = <span class="keyword">new</span> DatadirCleanupManager(</span><br><span class="line">        config.getDataDir(),</span><br><span class="line">        config.getDataLogDir(),</span><br><span class="line">        config.getSnapRetainCount(),</span><br><span class="line">        config.getPurgeInterval());</span><br><span class="line">    purgeMgr.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是standalone模式还是集群模式</span></span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span> &amp;&amp; config.isDistributed()) &#123;</span><br><span class="line">        <span class="comment">//集群模式</span></span><br><span class="line">        runFromConfig(config);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG.warn(<span class="string">"Either no config or no quorum defined in config, running in standalone mode"</span>);</span><br><span class="line">        <span class="comment">// there is only server in the quorum -- run as standalone</span></span><br><span class="line">        ZooKeeperServerMain.main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFromConfig</span><span class="params">(QuorumPeerConfig config)</span> <span class="keyword">throws</span> IOException, AdminServerException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ManagedUtil.registerLog4jMBeans();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JMException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">"Unable to register log4j JMX control"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG.info(<span class="string">"Starting quorum peer"</span>);</span><br><span class="line">    MetricsProvider metricsProvider;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        metricsProvider = MetricsProviderBootstrap.startMetricsProvider(</span><br><span class="line">            config.getMetricsProviderClassName(),</span><br><span class="line">            config.getMetricsProviderConfiguration());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MetricsProviderLifeCycleException error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Cannot boot MetricsProvider "</span> + config.getMetricsProviderClassName(), error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServerMetrics.metricsProviderInitialized(metricsProvider);</span><br><span class="line">        ServerCnxnFactory cnxnFactory = <span class="keyword">null</span>;</span><br><span class="line">        ServerCnxnFactory secureCnxnFactory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为客户端提供读写的server 及2181的端口</span></span><br><span class="line">        <span class="keyword">if</span> (config.getClientPortAddress() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config.getSecureClientPortAddress() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            secureCnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">//启动主线程</span></span><br><span class="line">        quorumPeer.start();</span><br><span class="line">        ZKAuditProvider.addZKStartStopAuditLog();</span><br><span class="line">        quorumPeer.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// warn, but generally this is ok</span></span><br><span class="line">        LOG.warn(<span class="string">"Quorum Peer interrupted"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="调用-QuorumPeer-的-start方法"><a href="#调用-QuorumPeer-的-start方法" class="headerlink" title="调用 QuorumPeer 的 start方法"></a>调用 QuorumPeer 的 start方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getView().containsKey(myid)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"My id "</span> + myid + <span class="string">" not in the peer list"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//loaddatabase主要是从本地文件中恢复数据，以及获取最新的 zxid</span></span><br><span class="line">    loadDataBase();</span><br><span class="line">    startServerCnxnFactory();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        adminServer.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AdminServerException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">"Problem starting AdminServer"</span>, e);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//选举初始化</span></span><br><span class="line">    startLeaderElection();</span><br><span class="line">    startJvmPauseMonitor();</span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startLeaderElection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前节点状态是LOOKING 投票给自己</span></span><br><span class="line">        <span class="keyword">if</span> (getPeerState() == ServerState.LOOKING) &#123;</span><br><span class="line">            currentVote = <span class="keyword">new</span> Vote(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        RuntimeException re = <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        re.setStackTrace(e.getStackTrace());</span><br><span class="line">        <span class="keyword">throw</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据配置获取选举算法 可以通过在 zoo.cfg 里面进行配置，默认是 fast 选举</span></span><br><span class="line">    <span class="keyword">this</span>.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Election <span class="title">createElectionAlgorithm</span><span class="params">(<span class="keyword">int</span> electionAlgorithm)</span> </span>&#123;</span><br><span class="line">    Election le = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> use a factory rather than a switch</span></span><br><span class="line">    <span class="keyword">switch</span> (electionAlgorithm) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Election Algorithm 1 is not supported."</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Election Algorithm 2 is not supported."</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="comment">//leader选举网络io负责类（负责底层网络处理接收和发送队列中的消息）</span></span><br><span class="line">        QuorumCnxManager qcm = createCnxnManager();</span><br><span class="line">        QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);</span><br><span class="line">        <span class="keyword">if</span> (oldQcm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LOG.warn(<span class="string">"Clobbering already-set QuorumCnxManager (restarting leader election?)"</span>);</span><br><span class="line">            oldQcm.halt();</span><br><span class="line">        &#125;</span><br><span class="line">        QuorumCnxManager.Listener listener = qcm.listener;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//启动已绑定的选举线程 等待集群中其他机器连接</span></span><br><span class="line">            listener.start();</span><br><span class="line">            <span class="comment">//基于TCP的选举算法 FastLeaderElection</span></span><br><span class="line">            FastLeaderElection fle = <span class="keyword">new</span> FastLeaderElection(<span class="keyword">this</span>, qcm);</span><br><span class="line">            fle.start();</span><br><span class="line">            le = fle;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.error(<span class="string">"Null listener when initializing cnx manager"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> le;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中FastLeaderElection fle = new FastLeaderElection(this, qcm);会调用一下构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FastLeaderElection</span><span class="params">(QuorumPeer self, QuorumCnxManager manager)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.stop = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">this</span>.manager = manager;</span><br><span class="line">   starter(self, manager);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一目了然不多解释</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">starter</span><span class="params">(QuorumPeer self, QuorumCnxManager manager)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.self = self;</span><br><span class="line">   proposedLeader = -<span class="number">1</span>;</span><br><span class="line">   proposedZxid = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   sendqueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;ToSend&gt;();</span><br><span class="line">   recvqueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Notification&gt;();</span><br><span class="line">   <span class="keyword">this</span>.messenger = <span class="keyword">new</span> Messenger(manager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FastLeaderElection的start方法被调用会构建Messenger</span></span><br><span class="line"><span class="comment">//Starts instances of WorkerSender and WorkerReceiver启动消息接收器和发送器线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messenger.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructor of class Messenger.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> manager   Connection manager</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> Messenger(QuorumCnxManager manager) &#123;</span><br><span class="line">  <span class="keyword">this</span>.ws = <span class="keyword">new</span> WorkerSender(manager);</span><br><span class="line">  <span class="keyword">this</span>.wsThread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>.ws, <span class="string">"WorkerSender[myid="</span> + self.getId() + <span class="string">"]"</span>);</span><br><span class="line">  <span class="keyword">this</span>.wsThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.wr = <span class="keyword">new</span> WorkerReceiver(manager);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.wrThread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>.wr, <span class="string">"WorkerReceiver[myid="</span> + self.getId() + <span class="string">"]"</span>);</span><br><span class="line">  <span class="keyword">this</span>.wrThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Starts instances of WorkerSender and WorkerReceiver</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.wsThread.start();</span><br><span class="line">  <span class="keyword">this</span>.wrThread.start();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 以上执行完成后QuorumPeer的run方法被调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Main loop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">//判断当前节点状态</span></span><br><span class="line">            <span class="keyword">switch</span> (getPeerState()) &#123;</span><br><span class="line">            <span class="keyword">case</span> LOOKING:</span><br><span class="line">                <span class="comment">//如果是LOOKING 则进入选举流程</span></span><br><span class="line">                LOG.info(<span class="string">"LOOKING"</span>);</span><br><span class="line">                ServerMetrics.getMetrics().LOOKING_COUNT.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"readonlymode.enabled"</span>)) &#123;</span><br><span class="line">                    LOG.info(<span class="string">"Attempting to start ReadOnlyZooKeeperServer"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Create read-only server but don't start it immediately</span></span><br><span class="line">                    <span class="keyword">final</span> ReadOnlyZooKeeperServer roZk = <span class="keyword">new</span> ReadOnlyZooKeeperServer(logFactory, <span class="keyword">this</span>, <span class="keyword">this</span>.zkDb);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Instead of starting roZk immediately, wait some grace</span></span><br><span class="line">                    <span class="comment">// period before we decide we're partitioned.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// Thread is used here because otherwise it would require</span></span><br><span class="line">                    <span class="comment">// changes in each of election strategy classes which is</span></span><br><span class="line">                    <span class="comment">// unnecessary code coupling.</span></span><br><span class="line">                    Thread roZkMgr = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// lower-bound grace period to 2 secs</span></span><br><span class="line">                                sleep(Math.max(<span class="number">2000</span>, tickTime));</span><br><span class="line">                                <span class="keyword">if</span> (ServerState.LOOKING.equals(getPeerState())) &#123;</span><br><span class="line">                                    roZk.startup();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                LOG.info(<span class="string">"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started"</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                LOG.error(<span class="string">"FAILED to start ReadOnlyZooKeeperServer"</span>, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        roZkMgr.start();</span><br><span class="line">                        reconfigFlagClear();</span><br><span class="line">                        <span class="keyword">if</span> (shuttingDownLE) &#123;</span><br><span class="line">                            shuttingDownLE = <span class="keyword">false</span>;</span><br><span class="line">                            startLeaderElection();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//此处通过策略模式来决定当前用哪个选举算法来进行领导选举</span></span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// If the thread is in the the grace period, interrupt</span></span><br><span class="line">                        <span class="comment">// to come out of waiting.</span></span><br><span class="line">                        roZkMgr.interrupt();</span><br><span class="line">                        roZk.shutdown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        reconfigFlagClear();</span><br><span class="line">                        <span class="keyword">if</span> (shuttingDownLE) &#123;</span><br><span class="line">                            shuttingDownLE = <span class="keyword">false</span>;</span><br><span class="line">                            startLeaderElection();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//此处通过策略模式决定当前用哪个选举算法来进行领导选举</span></span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEADING:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="执行核心选举算法"><a href="#执行核心选举算法" class="headerlink" title="执行核心选举算法"></a>执行核心选举算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口前文：setCurrentVote(makeLEStrategy().lookForLeader());</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vote <span class="title">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            self.jmxLeaderElectionBean = <span class="keyword">new</span> LeaderElectionBean();</span><br><span class="line">            MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.warn(<span class="string">"Failed to register with JMX"</span>, e);</span><br><span class="line">            self.jmxLeaderElectionBean = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.start_fle = Time.currentElapsedTime();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * The votes from the current leader election are stored in recvset. In other words, a vote v is in recvset</span></span><br><span class="line"><span class="comment">             * if v.electionEpoch == logicalclock. The current participant uses recvset to deduce on whether a majority</span></span><br><span class="line"><span class="comment">             * of participants has voted for it.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//保存收到的投票</span></span><br><span class="line">            Map&lt;Long, Vote&gt; recvset = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * The votes from previous leader elections, as well as the votes from the current leader election are</span></span><br><span class="line"><span class="comment">             * stored in outofelection. Note that notifications in a LOOKING state are not stored in outofelection.</span></span><br><span class="line"><span class="comment">             * Only FOLLOWING or LEADING notifications are stored in outofelection. The current participant could use</span></span><br><span class="line"><span class="comment">             * outofelection to learn which participant is the leader if it arrives late (i.e., higher logicalclock than</span></span><br><span class="line"><span class="comment">             * the electionEpoch of the received notifications) in a leader election.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//存储选举结果</span></span><br><span class="line">            Map&lt;Long, Vote&gt; outofelection = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> notTimeout = minNotificationInterval;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">//增加逻辑时钟  +1原子操作</span></span><br><span class="line">                logicalclock.incrementAndGet();</span><br><span class="line">                <span class="comment">//更新自己的zxid和epoch</span></span><br><span class="line">                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LOG.info(</span><br><span class="line">                <span class="string">"New election. My id = &#123;&#125;, proposed zxid=0x&#123;&#125;"</span>,</span><br><span class="line">                self.getId(),</span><br><span class="line">                Long.toHexString(proposedZxid));</span><br><span class="line">            <span class="comment">//发送投票 包括发送给自己（广播）</span></span><br><span class="line">            sendNotifications();</span><br><span class="line"></span><br><span class="line">            SyncedLearnerTracker voteSet;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Loop in which we exchange notifications until we find a leader</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//进行while循环 直到选举出leader</span></span><br><span class="line">            <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp; (!stop)) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Remove next notification from queue, times out after 2 times</span></span><br><span class="line"><span class="comment">                 * the termination time</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//从接收IO线程里拿到投票信息 自己的投票也在这里处理</span></span><br><span class="line">                Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Sends more notifications if haven't received enough.</span></span><br><span class="line"><span class="comment">                 * Otherwise processes new notification.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//如果为空 消息发完了 继续发送 一直到选出leader为止</span></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (manager.haveDelivered()) &#123;</span><br><span class="line">                        sendNotifications();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//消息还没投递出去 可能是其他server还没启动 尝试再连接</span></span><br><span class="line">                        manager.connectAll();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Exponential backoff</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="comment">//延长超时时间</span></span><br><span class="line">                    <span class="keyword">int</span> tmpTimeOut = notTimeout * <span class="number">2</span>;</span><br><span class="line">                    notTimeout = Math.min(tmpTimeOut, maxNotificationInterval);</span><br><span class="line">                    LOG.info(<span class="string">"Notification time out: &#123;&#125;"</span>, notTimeout);</span><br><span class="line">                    <span class="comment">//收到投票消息 判断收到的消息是不是属于这个集群内</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (validVoter(n.sid) &amp;&amp; validVoter(n.leader)) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Only proceed if the vote comes from a replica in the current or next</span></span><br><span class="line"><span class="comment">                     * voting view for a replica in the current or next voting view.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="comment">//判断收到的消息的节点的状态</span></span><br><span class="line">                    <span class="keyword">switch</span> (n.state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> LOOKING:</span><br><span class="line">                        <span class="keyword">if</span> (getInitLastLoggedZxid() == -<span class="number">1</span>) &#123;</span><br><span class="line">                            LOG.debug(<span class="string">"Ignoring notification as our zxid is -1"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (n.zxid == -<span class="number">1</span>) &#123;</span><br><span class="line">                            LOG.debug(<span class="string">"Ignoring notification from member with -1 zxid &#123;&#125;"</span>, n.sid);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// If notification &gt; current, replace and send messages out</span></span><br><span class="line">                        <span class="comment">//判断接收到的节点epoch大于logicalclock  则表示当前是新一轮的选举</span></span><br><span class="line">                        <span class="keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;</span><br><span class="line">                            <span class="comment">//更新本地logicalclock</span></span><br><span class="line">                            logicalclock.set(n.electionEpoch);</span><br><span class="line">                            <span class="comment">//清空接收队列</span></span><br><span class="line">                            recvset.clear();</span><br><span class="line">                            <span class="comment">//检查收到的消息是否可以胜出 依次比较epoch zxid myid</span></span><br><span class="line">                            <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;</span><br><span class="line">                                <span class="comment">//胜出后 把投票改为对方的票据</span></span><br><span class="line">                                updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//否则 票据不变</span></span><br><span class="line">                                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//继续广播 让其他节点知道我现在的票据</span></span><br><span class="line">                            sendNotifications();</span><br><span class="line">                            <span class="comment">//如果收到的消息epoch小于当前节点的epoch 则忽略这条消息</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;</span><br><span class="line">                                LOG.debug(</span><br><span class="line">                                    <span class="string">"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x&#123;&#125;, logicalclock=0x&#123;&#125;"</span>,</span><br><span class="line">                                    Long.toHexString(n.electionEpoch),</span><br><span class="line">                                    Long.toHexString(logicalclock.get()));</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                            <span class="comment">//如果epoch相同 继续比较zxid myid 如果胜出 则更新自己的票据 并发出广播</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) &#123;</span><br><span class="line">                            updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                            sendNotifications();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        LOG.debug(</span><br><span class="line">                            <span class="string">"Adding vote: from=&#123;&#125;, proposed leader=&#123;&#125;, proposed zxid=0x&#123;&#125;, proposed election epoch=0x&#123;&#125;"</span>,</span><br><span class="line">                            n.sid,</span><br><span class="line">                            n.leader,</span><br><span class="line">                            Long.toHexString(n.zxid),</span><br><span class="line">                            Long.toHexString(n.electionEpoch));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// don't care about the version if it's in LOOKING state</span></span><br><span class="line">                        <span class="comment">//添加到本机投票集合 用来做选举终结判断</span></span><br><span class="line">                        recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line"></span><br><span class="line">                        voteSet = getVoteTracker(recvset, <span class="keyword">new</span> Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//判断选举是否结束 默认算法是超过半数server同意</span></span><br><span class="line">                        <span class="keyword">if</span> (voteSet.hasAllQuorums()) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Verify if there is any change in the proposed leader</span></span><br><span class="line">                            <span class="comment">//一直等到新的通知到达 直到超时</span></span><br><span class="line">                            <span class="keyword">while</span> ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) &#123;</span><br><span class="line">                                    recvqueue.put(n);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * This predicate is true once we don't read any new</span></span><br><span class="line"><span class="comment">                             * relevant message from the reception queue</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="comment">//确定leader</span></span><br><span class="line">                            <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//修改状态</span></span><br><span class="line">                                setPeerState(proposedLeader, voteSet);</span><br><span class="line">                                Vote endVote = <span class="keyword">new</span> Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);</span><br><span class="line">                                leaveInstance(endVote);</span><br><span class="line">                                <span class="keyword">return</span> endVote;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//OBSERVING 不参与选举投票</span></span><br><span class="line">                    <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                        LOG.debug(<span class="string">"Notification from observer: &#123;&#125;"</span>, n.sid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//这两种需要参与选举</span></span><br><span class="line">                    <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                    <span class="keyword">case</span> LEADING:</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Consider all notifications from the same epoch</span></span><br><span class="line"><span class="comment">                         * together.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="comment">//判断epoch是否相同</span></span><br><span class="line">                        <span class="keyword">if</span> (n.electionEpoch == logicalclock.get()) &#123;</span><br><span class="line">                            <span class="comment">//如果相同 加入本机的投票集合</span></span><br><span class="line">                            recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line">                            voteSet = getVoteTracker(recvset, <span class="keyword">new</span> Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line">                            <span class="comment">//判断是否结束 如果结束 确认leader是否有效</span></span><br><span class="line">                            <span class="keyword">if</span> (voteSet.hasAllQuorums() &amp;&amp; checkLeader(recvset, n.leader, n.electionEpoch)) &#123;</span><br><span class="line">                                <span class="comment">//修改自己的状态并返回投票结果</span></span><br><span class="line">                                setPeerState(n.leader, voteSet);</span><br><span class="line">                                Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);</span><br><span class="line">                                leaveInstance(endVote);</span><br><span class="line">                                <span class="keyword">return</span> endVote;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Before joining an established ensemble, verify that</span></span><br><span class="line"><span class="comment">                         * a majority are following the same leader.</span></span><br><span class="line"><span class="comment">                         *</span></span><br><span class="line"><span class="comment">                         * Note that the outofelection map also stores votes from the current leader election.</span></span><br><span class="line"><span class="comment">                         * See ZOOKEEPER-1732 for more information.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        outofelection.put(n.sid, <span class="keyword">new</span> Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line">                        voteSet = getVoteTracker(outofelection, <span class="keyword">new</span> Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (voteSet.hasAllQuorums() &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;</span><br><span class="line">                            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                                logicalclock.set(n.electionEpoch);</span><br><span class="line">                                setPeerState(n.leader, voteSet);</span><br><span class="line">                            &#125;</span><br><span class="line">                            Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);</span><br><span class="line">                            leaveInstance(endVote);</span><br><span class="line">                            <span class="keyword">return</span> endVote;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        LOG.warn(<span class="string">"Notification state unrecoginized: &#123;&#125; (n.state), &#123;&#125;(n.sid)"</span>, n.state, n.sid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!validVoter(n.leader)) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">"Ignoring notification for non-cluster member sid &#123;&#125; from sid &#123;&#125;"</span>, n.leader, n.sid);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!validVoter(n.sid)) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">"Ignoring notification for sid &#123;&#125; from non-quorum member sid &#123;&#125;"</span>, n.leader, n.sid);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (self.jmxLeaderElectionBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOG.warn(<span class="string">"Failed to unregister with JMX"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            self.jmxLeaderElectionBean = <span class="keyword">null</span>;</span><br><span class="line">            LOG.debug(<span class="string">"Number of connection processing threads: &#123;&#125;"</span>, manager.getConnectionThreadCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Send notifications to all peers upon a change in our vote</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   广播消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendNotifications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//循环发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> sid : self.getCurrentAndNextConfigVoters()) &#123;</span><br><span class="line">            QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">            <span class="comment">//消息实体</span></span><br><span class="line">            ToSend notmsg = <span class="keyword">new</span> ToSend(</span><br><span class="line">                ToSend.mType.notification,</span><br><span class="line">                proposedLeader,</span><br><span class="line">                logicalclock.get(),</span><br><span class="line">                QuorumPeer.ServerState.LOOKING,</span><br><span class="line">                sid,</span><br><span class="line">                proposedEpoch,</span><br><span class="line">                qv.toString().getBytes());</span><br><span class="line"></span><br><span class="line">            LOG.debug(</span><br><span class="line">                <span class="string">"Sending Notification: &#123;&#125; (n.leader), 0x&#123;&#125; (n.zxid), 0x&#123;&#125; (n.round), &#123;&#125; (recipient),"</span></span><br><span class="line">                    + <span class="string">" &#123;&#125; (myid), 0x&#123;&#125; (n.peerEpoch) "</span>,</span><br><span class="line">                proposedLeader,</span><br><span class="line">                Long.toHexString(proposedZxid),</span><br><span class="line">                Long.toHexString(logicalclock.get()),</span><br><span class="line">                sid,</span><br><span class="line">                self.getId(),</span><br><span class="line">                Long.toHexString(proposedEpoch));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加到发送队列 这个队列会被workersender消费</span></span><br><span class="line">            sendqueue.offer(notmsg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>借助一张网络图片，该图对于选举流程中涉及到数据的流向的描述还是很清楚的。</p><p><img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3e4e95bf12d42c5b54cd862dea068e6~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>其中涉及一个<code>网络IO管理器</code>：负责维护处理发送和接收两个线程。及选举算法从<code>队列消费</code>和<code>生产</code>投票消息。最终执行核心的<code>选票PK</code>，按照一定策略进行更新和丢弃，直到选<code>举出一个</code>Leader。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要想理解清楚Leader选举流程，其中几个重要的概念及名词要清楚。</p><ul><li>事务ID和Zxid的概念要明确</li><li>Zxid和Sid比较的先后顺序及比较策略</li><li>如何理解更新选票并广播自己的选票</li></ul><p>OK！关于Zookeeper的Leader选举流程暂时就聊这么多，后期还会对ZK实现的分布式锁以及涉及到的”惊群和脑裂的概念做一个介绍”，如果还有时间的话，再聊聊Zk是进行数据同步的几种模式！欢迎关注公众号：“<code>Java编程之道</code>”！🌹</p><p>作者：爱唠嗑的阿磊<br>链接：<a href="https://juejin.im/post/6883483460686594061" target="_blank" rel="noopener">https://juejin.im/post/6883483460686594061</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZAB协议</title>
      <link href="/2020/11/14/ZAB%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/11/14/ZAB%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><blockquote><p>百度百科：ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。</p><p>它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等</p></blockquote><p>zookeeper是一个很热门的分布式框架，熟练掌握ZK的基本使用、分布式锁的实现以及相关场景的运用是必不可少的。鄙人有幸在<code>Shopee</code>的面试中被问过ZAB协议以及Learder选举流程，所以在此做一个总结，分享给大家自己的理解，愿对你有所帮助。</p><p>今天不介绍ZK的基础使用，仅对ZK中的ZAB协议的理解进行一个分享，如有不足之处欢迎大家指出。</p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><blockquote><p>ZAB 协议全称：Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。</p></blockquote><p>Zookeeper 是一个为分布式应用提供高效且可靠的分布式协调服务。在CAP理论中Zookeeper 属于CP模型，强调各个节点间数据强一致性，通过zab协议建立一个高可用可扩展的分布式数据主备系统。</p><ol><li>深刻理解ZAB协议，才能更好的理解zookeeper对于分布式系统建设的重要性。以及为什么采用zookeeper就能保证分布式系统中数据最终一致性，服务的高可用性。</li></ol><h2 id="ZAB协议原理"><a href="#ZAB协议原理" class="headerlink" title="ZAB协议原理"></a>ZAB协议原理</h2><p>ZAB协议要求每个leader都要经历三个阶段，即发现，同步，广播。</p><ul><li><strong>发现</strong>：即要求zookeeper集群必须选择出一个leader进程，同时leader会维护一个follower可用列表。将来客户端可以这follower中的节点进行通信。</li><li><strong>同步</strong>：leader要负责将本身的数据与follower完成同步，做到多副本存储。这样也是体现了CAP中高可用和分区容错。follower将队列中未处理完的请求消费完成后，写入本地事物日志中。</li><li><strong>广播</strong>：leader可以接受客户端新的proposal请求，将新的proposal请求广播给所有的follower。</li></ul><h2 id="应用范畴"><a href="#应用范畴" class="headerlink" title="应用范畴"></a>应用范畴</h2><ul><li>原子广播（Leader可用时）</li><li>崩溃恢复（Leader不可用时）</li></ul><p>下面我会重点讲这两个东西。</p><p>zookeeper根据ZAB协议建立了主备模型完成zookeeper集群中数据的同步。这里所说的主备系统架构模型是指，在zookeeper集群中，只有<code>一台leader</code>负责处理外部客户端的<code>事务请求</code>(或写操作)，然后leader服务器将客户端的<code>写操作数据</code>同步到<code>所有的followe</code>r节点中。</p><p><strong>注意：</strong></p><ul><li>所有的操作都有Learder发出，即时客户端向Fllower发出请求，最终它会把这个请求交给Leader处理。</li></ul><p><img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24100c7784c84a038a540c3b0fa427a1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h4 id="数据是如何复制的呢？"><a href="#数据是如何复制的呢？" class="headerlink" title="数据是如何复制的呢？"></a>数据是如何复制的呢？</h4><p>其实zab协议下的数据复制类似于2PC。但ZAB只需要Follower有<code>一半以上返回Ack</code>信息就可以执行<code>commit</code>提交。接收到半数Ack就提交的方式，可以大大减少同步阻塞，避免过长等待所有节点的反馈才进行操作（要么全部成功要么全部失败）。</p><p>如何理解这句话将直接影响你对於ZAB的理解。所以请继续往后看！ <img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99470d1e344e49d8a034cd6e5f9d188a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><ol><li>zk集群中只有一个节点即Leader将客户端的写操作<code>转化为事务</code>(或提议-proposal)–记住这个proposal的含义他会贯穿zk的整个体系。</li><li>Leader节点再数据写完之后，将向所有的follower节点发送数据广播（复制）请求，等待所有的follower节点<code>反馈（Ack</code>）。</li><li>待Leader接收到超过半数follower节点反馈（Ack），Leader节点就会向所有的follower服务器<code>发送commit（事务提交）</code>消息。</li><li>最后数据同步到follower上，完成数据同步。</li></ol><h2 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h2><p>在Zookeeper集群中，Fllower和Leader之间的通信是通过消息队列来实现的，消息队列的加入降低了耦合度，解除了同步阻塞。</p><p><img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48356152f70648de8540dc1cab12537e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p><strong>Zookeeper中消息广播的具体步骤如下</strong>：</p><ul><li>客户端发起一个写操作请求 ，Leader服务器将客户端的request请求转化为事物proposql提案，同时为每个proposal分配一个<code>全局递增唯一</code>的ID，即ZXID（事务ID）。</li><li>leader服务器与每个follower之间都有一个队列，leader将消息发送到该队列 。</li><li>follower机器从队列中取出消息处理完(<code>写入本地事物日志中</code>)毕后，向leader服务器发送ACK确认。</li><li>leader服务器收到半数以上的follower的ACK后，即认为可以发送commit 。leader向所有的follower服务器发送commit消息。</li></ul><h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><blockquote><p>在刚刚我们说的消息广播过程中，Leader在某个时间节点突然崩溃下线了我们又该如何保证数据的一致性，比如Leader本地提交了，但是commit没有发送？</p></blockquote><p>Zab协议在原Leader崩溃后会立即要求zookeeper集群进行<code>崩溃恢复</code>和<code>leader选举</code>。我们先简单聊一下崩溃恢复的机制。</p><p>ZAB协议崩溃恢复要求满足如下2个原则：</p><ul><li>确保已经被leader提交的proposal（提议）<code>必须最终</code>被所有的follower服务器提交。</li><li>确保<code>丢弃</code>已经被leader发出的但是没有被提交的proposal。</li></ul><p>所以，ZAB设计了一下的选举算法：</p><p>前面我们提交到每个客户端请求都会被Leader包装成一个拥有唯一递增的事务ID，如果我们可以保证新选举的leader节点中含有最高的ZXID。那么就可以满足ZAB协议的两个重要原则。这样做<code>可以省去 Leader 服务器检查事务的提交和丢弃工作的这一步操作</code></p><p><strong>Why？</strong></p><p>在Leader崩溃之前，所有的从队列里面取出事务来处理的Fllower的事务ID应该是一样的。如果我们从现有的Fllower中可以选举出最高的ZXID所在的服务器：</p><ul><li>假设：leader在提出proposal时未提交之前就崩溃，那么我们找到的最大的ZXID所在的服务器一定不包含未提交的提议（proposal）。</li><li>假设：leader在发送commit消息之后崩溃。即消息已经发送到队列中，期间该被提交（commit）的提议（proposal）会被Fllower处理，那么我们一定可以找到一个ZXID最大的服务器。即该follower节点将会被选举为最新的Leader。</li></ul><p><strong>在选举出Leader后需要进行的就是Leader和Fllower之间的数据同步。</strong></p><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><blockquote><p>关于数据同步Zookeeper中数据同步一共有四类，如下：</p><ul><li>DIFF：直接差异化同步</li><li>TRUNC+DIFF：先回滚再差异化同步</li><li>TRUNC：仅回滚同步</li><li>SNAP：全量同步</li></ul></blockquote><p>本次就不对其中的四种方式一一细说，大家可以参阅《<a href="https://www.cnblogs.com/youngchaolin/p/13211752.html" target="_blank" rel="noopener">Zookeeper-数据同步</a>》这篇文章，在此我只是笼统的介绍一下ZK的数据同步概念。</p><p>Zookeeper集群中新的leader选举成功之后，leader会将自身的提交的最大提议（proposal）的事务ZXID发送给其他的follower节点。follower节点会根据leader的消息进行<code>回退</code>或者是<code>数据同步</code>操作。具体流程请移步《Zookeeper-数据同步》。</p><p><strong>Zookeeper集群如何保证新选举的leader分配的ZXID是全局唯一呢？</strong></p><p>ZXID是一个长度64位的数字，其中低32位是按照<code>数字递增</code>，即每次客户端发起一个proposal,低32位的数字简单加1。高32位是leader周期的<code>epoch编号</code>，每当选举出一个新的leader时，新的leader就从<code>本地事物日志中取出ZXID</code>,然后解析出高32位的epoch编号，<code>进行加1</code>，再将低32位的<code>全部设置为0</code>。这样就保证了每次新选举的leader后，保证了ZXID的唯一性而且是<code>保证递增</code>的。 <img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f336c11472dd425bac74cacdcede634e~tplv-k3u1fbpfcp-zoom-1.image" alt="网络图片"></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于ZAB协议的介绍暂时就这么多了，Zookeeper通过ZAB协议来保证Zookeeper集群的强一致性其核心在于<code>类2PC的数据复制</code>方法以及<code>ZXID的唯一性设计</code>。</p><p>关于Zookeeper后续还会再出一篇Zookeeper实现分布式锁的原理及Leader选举算法的介绍，这些都是Zookeeper面试中的高频考点，感兴趣的同学可以关注我的公众号 <strong>“Java编程之道”</strong> 哦！</p><p>作者：爱唠嗑的阿磊<br>链接：<a href="https://juejin.im/post/6882277384112832519" target="_blank" rel="noopener">https://juejin.im/post/6882277384112832519</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 2.0具体？</title>
      <link href="/2020/11/14/HTTP-2-0%E5%85%B7%E4%BD%93%EF%BC%9F/"/>
      <url>/2020/11/14/HTTP-2-0%E5%85%B7%E4%BD%93%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a><strong>二进制传输</strong></h3><p>HTTP/2 采用二进制格式传输数据，而非 HTTP/1 的文本格式，二进制协议解析起来更高效。</p><p>HTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。<strong>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码</strong>。</p><p>接下来我们介绍几个重要的概念：</p><ul><li><strong>流（stream）：</strong>流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）</li><li><strong>消息（message）：</strong>指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成</li><li><strong>帧（frame）：</strong>HTTP/2 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷等</li></ul><p>​        <img src="https://oscimg.oschina.net/oscnet/909bd5cf6598834690fac8da866915a742c.jpg" alt="img"></p><p>HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</p><ul><li>并行交错地发送多个请求，请求之间互不影响</li><li>并行交错地发送多个响应，响应之间互不干扰</li></ul><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客<br>户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><p><img src="/2020/11/14/HTTP-2-0%E5%85%B7%E4%BD%93%EF%BC%9F/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201114160941824.png" alt="image-20201114160941824"></p><h3 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a><strong>Header 压缩</strong></h3><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。<br>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。<br>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p><p><img src="/2020/11/14/HTTP-2-0%E5%85%B7%E4%BD%93%EF%BC%9F/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201114161042689.png" alt="image-20201114161042689"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>攻击技术</title>
      <link href="/2020/11/14/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/"/>
      <url>/2020/11/14/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="arp欺骗"><a href="#arp欺骗" class="headerlink" title="arp欺骗"></a>arp欺骗</h3><p>在使用以太网交换机的网络中，攻击者向某个以太网交换机发送大量的伪造源 MAC 地址，以太网交换机收到这样的帧就把虚假的 MAC 源地址填入到交换表中，由于伪造的数量很大很快就填满了表，导致以太网交换机无法正常工作。</p><p> 1.解决方法：利用交换机防止ARP攻击</p><p>在交换机上绑定MAC地址与IP地址，为每台主机添加一条IP地址和MAC地址对应的关系静态地址表。用户发送数据包时，若交换机获得的IP和MAC地址与之前建立的映射表匹配，则发送的包能通过，否则将丢弃该数据包，从而有效地防止ARP欺骗。</p><p>2.[DHCP snooping](<a href="https://baike.baidu.com/item/DHCP" target="_blank" rel="noopener">https://baike.baidu.com/item/DHCP</a> snooping)，网上设备可借由<a href="https://baike.baidu.com/item/DHCP" target="_blank" rel="noopener">DHCP</a>保留网络上各计算机的MAC地址，在伪造的ARP数据包发出时即可侦测到。此方式已在一些厂牌的网上设备产品所支持。</p><p>3.每台计算机的ARP一律改用静态的方式，不过这在大型的网上是不可行的，因为需要经常更新每台计算机的ARP表。</p><h3 id="SYN-flood"><a href="#SYN-flood" class="headerlink" title="SYN flood"></a>SYN flood</h3><p>Syn-Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问。</p><p>解决方法</p><p>1.无效连接监视释放</p><p>这种方法不停监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。</p><p>2.延缓TCB分配方法</p><p>从前面SYN Flood原理可以看到，消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用SYN Cache和SYN Cookie技术。</p><p>SYN Cache技术：</p><p>这种技术是在收到SYN数据报文时不急于去分配TCB，而是先回应一个SYN ACK报文，并在一个专用HASH表（Cache）中保存这种半开连接信息，直到收到正确的回应ACK报文再分配TCB。</p><p>SYN Cookie技术：</p><p>对于SYN攻击，SYN Cache虽然不分配TCB，但是为了判断后续对方发来的ACK报文中的Sequence Number的正确性，还是需要使用一些空间去保存己方生成的Sequence Number等信息，也造成了一些资源的浪费。Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（SequenceNumber-1）相同，从而决定是否分配TCB资源。</p><p>3．使用SYN Proxy防火墙</p><p>SYN Cache技术和SYN Cookie技术总的来说是一种主机保护技术，需要系统的TCP/IP协议栈的支持，而目前并非所有的操作系统支持这些技术。因此很多防火墙中都提供一种 SYN代理的功能，其主要原理是对试图穿越的SYN请求进行验证后才放行，下图描述了这种过程：</p><h3 id="DNS欺骗？"><a href="#DNS欺骗？" class="headerlink" title="DNS欺骗？"></a>DNS欺骗？</h3><p> DNS欺骗就是攻击者冒充<a href="https://baike.baidu.com/item/域名服务器/9705133" target="_blank" rel="noopener">域名服务器</a>的一种欺骗行为。 原理：如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。</p><ol><li><p>进行IP地址和MAC地址的绑定</p><p>(1)预防ARP欺骗攻击。因为DNS攻击的欺骗行为要以ARP欺骗作为开端，所以如果能有效防范或避免ARP欺骗，也就使得DNS ID欺骗攻击无从下手。例如可以通过将Gateway Router 的Ip Address和MAC Address静态绑定在一起，就可以防范ARP攻击欺骗。</p></li></ol><p>2.直接使用IP地址访问</p><p>   对个别信息安全等级要求十分严格的WEB站点尽量不要使用DNS进行解析。由于DNS欺骗攻击中不少是针对窃取客户的私密数据而来的，而多数用户访问的站点并不涉及这些隐私信息，因此当访问具有严格保密信息的站点时，可以直接使用IP地址而无需通过DNS解析，这样所有的DNS欺骗攻击可能造成的危害就可以避免了。除此，应该做好DNS Server的安全配置项目和升级DNS软件，合理限定DNS Server进行响应的IP地址区间，关闭DNS Server的递归查询项目等。</p><p>3.对DNS数据包进行监测</p><p>   在DNS欺骗攻击中，Client会接收到至少两个DNS的数据响应包，一个是真实的数据包，另一个是攻击数据包。欺骗攻击数据包为了抢在真实应答包之前回复给Client，它的信息数据结构与真实的数据包相比十分简单，只有应答域，而不包括授权域和附加域。因此，可以通过监测DNS响应包，遵循相应的原则和模型算法对这两种响应包进行分辨，从而避免虚假数据包的攻击。</p><h3 id="中间人攻击？"><a href="#中间人攻击？" class="headerlink" title="中间人攻击？"></a>中间人攻击？</h3><p>中间人（MITM）攻击是一种攻击类型，其中攻击者将它自己放到两方之间，通常是客户端和服务端通信线路的中间。这可以通过破坏原始频道之后拦截一方的消息并将它们转发（有时会有改变）给另一方来实现。(DNS欺骗等攻击都是典型的MITM攻击)</p><p>攻击者常考虑的方式是ARP欺骗或DNS欺骗等，将会话双方的通讯流暗中改变</p><h3 id="跨域攻击-CSRF-？"><a href="#跨域攻击-CSRF-？" class="headerlink" title="跨域攻击(CSRF)？"></a>跨域攻击(CSRF)？</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>final finally finalize的区别</title>
      <link href="/2020/11/14/final-finally-finalize%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/11/14/final-finally-finalize%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>1. final</strong> </p><p>　　在java中，final可以用来修饰类，方法和变量（成员变量或局部变量）。下面将对其详细介绍。</p><p><strong>1.1 修饰类</strong></p><p>　　当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰，但要注意：</p><p>final类中所有的成员方法都会隐式的定义为final方法。</p><p><strong>1.2 修饰方法</strong></p><p>final方法意味着“最后的、最终的”含义，即此方法不能被重写。</p><p><strong>注意：若父类中final方法的访问权限为private，将导致子类中不能直接继承该方法，因此，此时可以在子类中定义相同方法名的函数，此时不会与重写final的矛盾，而是在子类中重新地定义了新方法。</strong></p><p><strong>1.3 修饰变量</strong></p><p> 　final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。类似于C++中的const。</p><p>　　当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。　</p><p><strong>2. finally</strong></p><p> 　finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。（×）（这句话其实存在一定的问题）</p><p>　　很多人都认为finally语句块一定会执行，但真的是这样么？答案是否定的，例如下面这个例子：</p><p><strong>3. finalize</strong>　　</p><p>　　finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。 </p><p>　　一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象</p><p>在finalize()方法中重新引用到”GC  Roots”链上（如把当前对象的引用this赋值给某对象的类变量/成员变量，重新建立可达的引用）</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis的IO复用?</title>
      <link href="/2020/11/13/redis%E7%9A%84IO%E5%A4%8D%E7%94%A8/"/>
      <url>/2020/11/13/redis%E7%9A%84IO%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的<br>事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p><p><img src="/2020/11/13/redis%E7%9A%84IO%E5%A4%8D%E7%94%A8/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201113211529798.png" alt="image-20201113211529798"></p><h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的<br>时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。<br>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def aeProcessEvents():</span><br><span class="line">    # 获取到达时间离当前时间最接近的时间事件</span><br><span class="line">    time_event &#x3D; aeSearchNearestTimer()</span><br><span class="line">    # 计算最接近的时间事件距离到达还有多少毫秒</span><br><span class="line">    remaind_ms &#x3D; time_event.when - unix_ts_now()</span><br><span class="line">    # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span><br><span class="line">    if remaind_ms &lt; 0:</span><br><span class="line">    remaind_ms &#x3D; 0</span><br><span class="line">    # 根据 remaind_ms 的值，创建 timeval</span><br><span class="line">    timeval &#x3D; create_timeval_with_ms(remaind_ms)</span><br><span class="line">    # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">    # 处理所有已产生的文件事件</span><br><span class="line">    procesFileEvents()</span><br><span class="line">    # 处理所有已到达的时间事件</span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如<br>下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    # 初始化服务器</span><br><span class="line">    init_server()</span><br><span class="line">    # 一直处理事件，直到服务器关闭为止</span><br><span class="line">    while server_is_not_shutdown():</span><br><span class="line">    aeProcessEvents()</span><br><span class="line">    # 服务器关闭，执行清理操作</span><br><span class="line">    clean_server()</span><br></pre></td></tr></table></figure><p>从事件处理的角度来看，服务器运行流程如下：</p><p><img src="/2020/11/13/redis%E7%9A%84IO%E5%A4%8D%E7%94%A8/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201113211637841.png" alt="image-20201113211637841"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大量time_wait出现的原因?</title>
      <link href="/2020/11/13/%E5%A4%A7%E9%87%8Ftime-wait%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>/2020/11/13/%E5%A4%A7%E9%87%8Ftime-wait%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="大量TIME-WAIT出现场景"><a href="#大量TIME-WAIT出现场景" class="headerlink" title="大量TIME_WAIT出现场景"></a><strong>大量TIME_WAIT出现场景</strong></h3><p>　　在<strong>高并发短连接</strong>的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p><h3 id="大量TIME-WAIT解决方案"><a href="#大量TIME-WAIT解决方案" class="headerlink" title="大量TIME_WAIT解决方案"></a><strong>大量TIME_WAIT解决方案</strong></h3><h4 id="应用层面"><a href="#应用层面" class="headerlink" title="应用层面"></a><strong>应用层面</strong></h4><p>　　尽量避免频繁关闭连接，如业务优化，或者使用长连接等；</p><h4 id="系统层面"><a href="#系统层面" class="headerlink" title="系统层面"></a><strong>系统层面</strong></h4><ol><li>缩短MSL时间。</li><li>增加可用端口数量。可用端口数量=单进程可打开的连接数量*机器数量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大量close_wait出现的原因?</title>
      <link href="/2020/11/13/%E5%A4%A7%E9%87%8Fclose-wait%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>/2020/11/13/%E5%A4%A7%E9%87%8Fclose-wait%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<p>通常，CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的 CLOSE_WAIT 状态，那么就意味着被动关闭的一方没有及时发出 FIN 包，一般有如下几种可能：</p><ul><li>程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。</li><li>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。</li></ul><p><a href="https://www.cnblogs.com/grey-wolf/p/10936657.html" target="_blank" rel="noopener">https://www.cnblogs.com/grey-wolf/p/10936657.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器排查问题</title>
      <link href="/2020/11/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="TOP指令"><a href="#TOP指令" class="headerlink" title="TOP指令"></a>TOP指令</h3><p>图一(ubuntu)：</p><p><img src="https://img-blog.csdn.net/2018080815173689?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqY2xzeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><strong>第1行：top - 05:43:27 up 4:52, 2 users, load average: 0.58, 0.41, 0.30</strong><br>第1行是任务队列信息，其参数如下：</p><table><thead><tr><th align="left">内容</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">05:43:27</td><td align="left">表示当前时间</td></tr><tr><td align="left">up 4:52</td><td align="left">系统运行时间 格式为时：分</td></tr><tr><td align="left">2 users</td><td align="left">当前登录用户数</td></tr><tr><td align="left">load average: 0.58, 0.41, 0.30</td><td align="left">系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</td></tr></tbody></table><p>load average: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">系统平均负载被定义为在特定时间间隔内运行队列中的平均进程数。</span><br></pre></td></tr></table></figure><p><strong>第2行：Tasks: 159 total, 1 running, 158 sleeping, 0 stopped, 0 zombie</strong><br><strong>第3行：%Cpu(s): 37.0 us, 3.7 sy, 0.0 ni, 59.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</strong><br>第2、3行为进程和CPU的信息<br>当有多个CPU时，这些内容可能会超过两行，其参数如下：</p><table><thead><tr><th align="left">内容</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">159 total</td><td align="left">进程总数</td></tr><tr><td align="left">1 running</td><td align="left">正在运行的进程数</td></tr><tr><td align="left">158 sleeping</td><td align="left">睡眠的进程数</td></tr><tr><td align="left">0 stopped</td><td align="left">停止的进程数</td></tr><tr><td align="left">0 zombie</td><td align="left">僵尸进程数</td></tr><tr><td align="left">37.0 us</td><td align="left">用户空间占用CPU百分比</td></tr><tr><td align="left">3.7 sy</td><td align="left">内核空间占用CPU百分比</td></tr><tr><td align="left"><strong>0.0 ni</strong></td><td align="left">用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td align="left">59.3 id</td><td align="left">空闲CPU百分比</td></tr><tr><td align="left">0.0 wa</td><td align="left">等待输入输出的CPU时间百分比</td></tr><tr><td align="left"><strong>0.0 hi</strong></td><td align="left">硬中断（Hardware IRQ）占用CPU的百分比</td></tr><tr><td align="left"><strong>0.0 si</strong></td><td align="left">软中断（Software Interrupts）占用CPU的百分比</td></tr><tr><td align="left"><strong>0.0 st</strong></td><td align="left"></td></tr></tbody></table><p>第4行：KiB Mem: 1530752 total, 1481968 used, 48784 free, 70988 buffers<br>第5行：KiB Swap: 3905532 total, 267544 used, 3637988 free. 617312 cached Mem<br>第4、5行为内存信息<br>其参数如下：</p><table><thead><tr><th align="left">内容</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">KiB Mem: 1530752 total</td><td align="left">物理内存总量</td></tr><tr><td align="left">1481968 used</td><td align="left">使用的物理内存总量</td></tr><tr><td align="left">48784 free</td><td align="left">空闲内存总量</td></tr><tr><td align="left">70988 buffers（buff/cache）</td><td align="left">用作内核缓存的内存量</td></tr><tr><td align="left">KiB Swap: 3905532 total</td><td align="left">交换区总量</td></tr><tr><td align="left">267544 used</td><td align="left">使用的交换区总量</td></tr><tr><td align="left">3637988 free</td><td align="left">空闲交换区总量</td></tr><tr><td align="left">617312 cached Mem</td><td align="left">缓冲的交换区总量。</td></tr><tr><td align="left">3156100 avail Mem</td><td align="left">代表可用于进程下一次分配的物理内存数量</td></tr></tbody></table><p>上述最后提到的缓冲的交换区总量，这里解释一下，所谓缓冲的交换区总量，即内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。 </p><p>计算可用内存数有一个近似的公式：<br>第四行的free + 第四行的buffers + 第五行的cached</p><h4 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h4><table><thead><tr><th align="left">列名</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">PID</td><td align="left">进程id</td></tr><tr><td align="left">PPID</td><td align="left">父进程id</td></tr><tr><td align="left">RUSER</td><td align="left">Real user name</td></tr><tr><td align="left">UID</td><td align="left">进程所有者的用户id</td></tr><tr><td align="left">USER</td><td align="left">进程所有者的用户名</td></tr><tr><td align="left">GROUP</td><td align="left">进程所有者的组名</td></tr><tr><td align="left">TTY</td><td align="left">启动进程的终端名。不是从终端启动的进程则显示为 ?</td></tr><tr><td align="left">PR</td><td align="left">优先级</td></tr><tr><td align="left">NI</td><td align="left">nice值。负值表示高优先级，正值表示低优先级</td></tr><tr><td align="left">P</td><td align="left">最后使用的CPU，仅在多CPU环境下有意义</td></tr><tr><td align="left">%CPU</td><td align="left">上次更新到现在的CPU时间占用百分比</td></tr><tr><td align="left">TIME</td><td align="left">进程使用的CPU时间总计，单位秒</td></tr><tr><td align="left">TIME+</td><td align="left">进程使用的CPU时间总计，单位1/100秒</td></tr><tr><td align="left">%MEM</td><td align="left">进程使用的物理内存百分比</td></tr><tr><td align="left">VIRT</td><td align="left">进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td></tr><tr><td align="left">SWAP</td><td align="left">进程使用的虚拟内存中，被换出的大小，单位kb</td></tr><tr><td align="left">RES</td><td align="left">进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td></tr><tr><td align="left">CODE</td><td align="left">可执行代码占用的物理内存大小，单位kb</td></tr><tr><td align="left">DATA</td><td align="left">可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</td></tr><tr><td align="left">SHR</td><td align="left">共享内存大小，单位kb</td></tr><tr><td align="left">nFLT</td><td align="left">页面错误次数</td></tr><tr><td align="left">nDRT</td><td align="left">最后一次写入到现在，被修改过的页面数。</td></tr><tr><td align="left">S</td><td align="left">进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</td></tr><tr><td align="left">COMMAND</td><td align="left">命令名/命令行</td></tr><tr><td align="left">WCHAN</td><td align="left">若该进程在睡眠，则显示睡眠中的系统函数名</td></tr><tr><td align="left">Flags</td><td align="left">任务标志</td></tr></tbody></table><h3 id="服务器IO延时高"><a href="#服务器IO延时高" class="headerlink" title="服务器IO延时高"></a>服务器IO延时高</h3><p>Linux系统出现了性能问题，一般我们可以通过top、iostat、iotop、free、vmstat等命令来查看初步定位问题。</p><p>今天我们讲解就是iostat和iotop，定位问题的一般步骤：</p><p>Step-1】 iostat这个命令可以给我们提供丰富的IO状态数据，一般我们先通过该命令来查看是否存在性能瓶颈</p><p>Step-2】用iotop找出io高的进程</p><p>1、iostat常见用法：</p><p>iostat -d -k 1 10    #查看TPS和吞吐量信息</p><p>参数 -d 表示，显示设备（磁盘）使用状态；</p><p>-k某些使用block为单位的列强制使用Kilobytes为单位；</p><p>1 10表示，数据显示每隔1秒刷新一次，共显示10次</p><p><img src="https://img-blog.csdnimg.cn/20190525103401667.png" alt="img"></p><p>iostat -d -x -k 1 10   #查看设备使用率（%util）、响应时间（await）</p><p>使用-x参数我们可以获得更多统计信息。<br>注意】一般%util大于70%,I/O压力就比较大，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。磁盘可能存在瓶颈。</p><p><img src="https://img-blog.csdnimg.cn/20190525103444926.png" alt="img"></p><p>iostat还可以用来获取cpu部分状态值：</p><p>iostat -c 1 10  #查看cpu状态</p><p>注意】idle小于70% IO压力就较大了,一般读取速度有较多的wait。</p><p><img src="https://img-blog.csdnimg.cn/20190525103534337.png" alt="img"></p><p>2、我们通过上面iostat的常用命令基本可以判断IO是否存在瓶颈了，然后我们通过iotop命令来抓出罪魁祸首的进程，这里比较简单直接输入命令，然后执行（一般抓到的是java进程、mysqld，干的越多问题越多）    <img src="https://img-blog.csdnimg.cn/20190525103609528.png" alt="img"></p><p> <img src="https://img-blog.csdnimg.cn/20190525103625220.png" alt="img"></p><p><strong>只显示正在产生I/O的进程或线程。除了传参，可以在运行过程中按o生效。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node105 ~]# iotop  -o</span><br></pre></td></tr></table></figure><h3 id="CPU延时高"><a href="#CPU延时高" class="headerlink" title="CPU延时高"></a>CPU延时高</h3><p>在最近上线过程中遇到cpu占用率过高问题</p><p><img src="https://img-blog.csdn.net/20180516093934334?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>由于问题已解决,此时仅重现操作方法</p><p>1.先用top命令,找到cpu占用最高的进程 PID 如上图</p><p>2.再用ps -mp pid -o THREAD,tid,time  查询进程中,那个线程的cpu占用率高 记住TID</p><p><img src="https://img-blog.csdn.net/20180516095941290?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>3.jstack 29099 &gt;&gt; xxx.log  打印出该进程下线程日志</p><p><img src="https://img-blog.csdn.net/20180516100207813?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>4.sz xxx.log 将日志文件下载到本地</p><p><img src="https://img-blog.csdn.net/20180516100356373?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>5.将查找到的 线程占用最高的 tid 上上上图中 29108  转成16进制 — 71b4</p><p><img src="https://img-blog.csdn.net/20180516100651297?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/20180516100717935?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>6.打开下载好的 xxx.log 通过 查找方式 找到 对应线程 进行排查</p><p><img src="https://img-blog.csdn.net/20180516100825613?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf &#39;%x&#39; 32826 获取16进制的线程id，用于dump信息查询，结果为 803a。最后我们执行jstack 32805 |grep -A 20 803a</span><br><span class="line"></span><br><span class="line"> grep -A -B -C -A -B -C 后面都跟阿拉伯数字 -A是显示匹配后和它后面的n行</span><br></pre></td></tr></table></figure><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>查看当前所有tcp端口使用情况：</p><p><img src="https://img-blog.csdn.net/20160617153120931" alt="è¿éåå¾çæè¿°"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# netstat -an | grep 3306   &#x2F;&#x2F;查看所有3306端口使用情况·</span><br></pre></td></tr></table></figure><h3 id="CPU暴增"><a href="#CPU暴增" class="headerlink" title="CPU暴增"></a>CPU暴增</h3><p><strong>如果服务器在运行中cpu突然暴增怎么排查</strong><br>首先通过ps命令查看一下占用cpu最多的进程，再根据请求选择是否要杀死它还是用其他的解决方案。</p><p>然后通过stack工具打印Java的方法栈，查看是否有死锁的存在。</p><p>然后通过其他排查工具定位问题所在。如果是数据库连接的的问题，就用回滚策略解决。如果只是单纯的请求量暴增导致的，那么就先重启服务，并在以后的开发中多进行压测。</p><h3 id="查看端口是否占用"><a href="#查看端口是否占用" class="headerlink" title="查看端口是否占用"></a>查看端口是否占用</h3><h2 id="netstat-1"><a href="#netstat-1" class="headerlink" title="netstat"></a>netstat</h2><p><strong>①.\</strong>查看所有的端口占用情况****</p><p>C:&gt;<strong>netstat -ano</strong></p><p><img src="https://img-blog.csdn.net/20180519232705552" alt="img"></p><h4 id="查看端口号-netstat"><a href="#查看端口号-netstat" class="headerlink" title="查看端口号 netstat"></a>查看端口号 netstat</h4><p>如果发现某个端口被占用后，可以用命令查看，该端口到底是被哪个进程所占用。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -pan | grep 5623</span><br><span class="line">#其中5623位端口号</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlcy5jbmJsb2dzLmNvbS9jbmJsb2dzX2NvbS9idWdpbmdjb2RlLzExNDY5NTgvb19saW51eC1uZXRzdGF0MS5wbmc?x-oss-process=image/format,png" alt="img"></p><p>发现5623的端口，被28425的进程id所占用，继续进一步跟踪，到底是哪个程序所占用了。</p><h4 id="通过进程id查找程序–ps"><a href="#通过进程id查找程序–ps" class="headerlink" title="通过进程id查找程序–ps"></a>通过进程id查找程序–ps</h4><p>直接通过：ps -aux | grep pid 查看，进程程序名称，</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlcy5jbmJsb2dzLmNvbS9jbmJsb2dzX2NvbS9idWdpbmdjb2RlLzExNDY5NTgvb19saW51eC1uZXRzdGF0Mi5wbmc?x-oss-process=image/format,png" alt="img"></p><p>通过netstat查找端口占用的pid，再通过pid进一步的查找程序名称，能够确认目前冲突的端口是哪个程序已经占用了，我们是重新启用换一个端口号，还是结束已经占用的端口号所用的程序，清空被占用的端口号。</p><h4 id="netstat-中参数选项"><a href="#netstat-中参数选项" class="headerlink" title="netstat 中参数选项"></a>netstat 中参数选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-a或--all：显示所有连线中的Socket； </span><br><span class="line">-A&lt;网络类型&gt;或--&lt;网络类型&gt;：列出该网络类型连线中的相关地址； </span><br><span class="line">-c或--continuous：持续列出网络状态； </span><br><span class="line">-C或--cache：显示路由器配置的快取信息； </span><br><span class="line">-e或--extend：显示网络其他相关信息； </span><br><span class="line">-F或--fib：显示FIB； </span><br><span class="line">-g或--groups：显示多重广播功能群组组员名单； </span><br><span class="line">-h或--help：在线帮助； </span><br><span class="line">-i或--interfaces：显示网络界面信息表单； </span><br><span class="line">-l或--listening：显示监控中的服务器的Socket； </span><br><span class="line">-M或--masquerade：显示伪装的网络连线； </span><br><span class="line">-n或--numeric：直接使用ip地址，而不通过域名服务器； </span><br><span class="line">-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称； </span><br><span class="line">-o或--timers：显示计时器； </span><br><span class="line">-p或--programs：显示正在使用Socket的程序识别码和程序名称； </span><br><span class="line">-r或--route：显示Routing Table； </span><br><span class="line">-s或--statistice：显示网络工作信息统计表； </span><br><span class="line">-t或--tcp：显示TCP传输协议的连线状况； </span><br><span class="line">-u或--udp：显示UDP传输协议的连线状况； </span><br><span class="line">-v或--verbose：显示指令执行过程； </span><br><span class="line">-V或--version：显示版本信息； </span><br><span class="line">-w或--raw：显示RAW传输协议的连线状况； </span><br><span class="line">-x或--unix：此参数的效果和指定&quot;-A unix&quot;参数相同； </span><br><span class="line">--ip或--inet：此参数的效果和指定&quot;-A inet&quot;参数相同。</span><br></pre></td></tr></table></figure><h3 id="tcpdump是干啥的？什么场景用？"><a href="#tcpdump是干啥的？什么场景用？" class="headerlink" title="tcpdump是干啥的？什么场景用？"></a>tcpdump是干啥的？什么场景用？</h3>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>公网私网？</title>
      <link href="/2020/11/12/%E5%85%AC%E7%BD%91%E7%A7%81%E7%BD%91%EF%BC%9F/"/>
      <url>/2020/11/12/%E5%85%AC%E7%BD%91%E7%A7%81%E7%BD%91%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>怎么对json格式的数据进行修改？</title>
      <link href="/2020/11/12/%E6%80%8E%E4%B9%88%E5%AF%B9json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%EF%BC%9F/"/>
      <url>/2020/11/12/%E6%80%8E%E4%B9%88%E5%AF%B9json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>建表语句如下，为 area 字段 声明为 JSON 类型；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`order`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'订单编号'</span>,</span><br><span class="line">  <span class="string">`order_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单名称'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`year`</span> <span class="keyword">year</span>(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年份'</span>,</span><br><span class="line">  <span class="string">`area`</span> <span class="keyword">json</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'地区'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`order_name`</span> (<span class="string">`order_name`</span>,<span class="string">`create_time`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">9</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>MySQL 中支持 json 对象 和json 数组，他们之间可以相互嵌套；json类似map，在java中json就是map得实现类，初学者若不懂何为json，就当作map来用，即储存 key - value 形式得数据结构；<strong>注意点是 json 数据 得key 必须是字符串，可以有key无value</strong>；</p><h2 id="2-1-插入-josn数据"><a href="#2-1-插入-josn数据" class="headerlink" title="2.1 插入 josn数据"></a>2.1 插入 josn数据</h2><p>插入 json 对象，east 得值 为 50 ， sourth 值为65 得 json对象；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order`</span>(<span class="string">`order_name`</span>, <span class="string">`year`</span>, <span class="string">`area`</span>) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'荷小花的订单'</span>, <span class="number">2020</span>, <span class="string">'&#123;"east": "50", "south": "65"&#125;'</span>);</span><br></pre></td></tr></table></figure><p>等效于使用 <code>JSON_OBJECT</code> 函数， 示例如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order`</span>(<span class="string">`order_name`</span>, <span class="string">`year`</span>, <span class="string">`area`</span>) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'荷小花的订单'</span>, <span class="number">2020</span>, JSON_OBJECT(<span class="string">"east"</span>, <span class="string">"50"</span>, <span class="string">"south"</span>, <span class="string">"65"</span>));</span><br></pre></td></tr></table></figure><p>插入 json 数组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order`</span>(<span class="string">`order_name`</span>, <span class="string">`year`</span>, <span class="string">`area`</span>) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'荷小花的订单'</span>, <span class="number">2020</span>, <span class="string">'[&#123;"east": "50", "south": "65"&#125;]'</span>);</span><br></pre></td></tr></table></figure><p>等效于使用 <code>JSON_ARRAY</code> 函数，示例如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order`</span>(<span class="string">`order_name`</span>, <span class="string">`year`</span>, <span class="string">`area`</span>) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'荷小花的订单'</span>, <span class="number">2020</span>, JSON_ARRAY(<span class="string">"east"</span>, <span class="string">"50"</span>, <span class="string">"south"</span>, <span class="string">"65"</span>));</span><br></pre></td></tr></table></figure><h2 id="2-2-查询json数据"><a href="#2-2-查询json数据" class="headerlink" title="2.2 查询json数据"></a>2.2 查询json数据</h2><p>使用 column - path 路径符 <code>-&gt;</code> 查询 指定key 得值，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_name, area -&gt; <span class="string">'$.east'</span> <span class="keyword">from</span> <span class="string">`order`</span></span><br></pre></td></tr></table></figure><p>注意，如果json 数据中不存在 east 得键，则列出为null值</p><p>输出如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---------   ------</span></span><br><span class="line">荷小花的订单"50"</span><br><span class="line">荷小花的订单</span><br></pre></td></tr></table></figure><p>也可以使用 -&gt;&gt; 符号, 不同之处是使用 <code>-&gt;&gt;</code> 更加直观，输出得json数据最外层不会携带双引号，内层数据中存在双引号不会有反斜杠转义；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_name, area -&gt;&gt; <span class="string">'$.east'</span> <span class="keyword">from</span> <span class="string">`order`</span></span><br></pre></td></tr></table></figure><p>使用 单引号 代替 双引号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_name, area -&gt;&gt; <span class="string">"$.east"</span> <span class="keyword">from</span> <span class="string">`order`</span></span><br></pre></td></tr></table></figure><p>我们 也可以使用 <code>JSON_EXTRACT</code> 函数 达到同样得效果；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_name,JSON_EXTRACT(area, <span class="string">'$.east'</span>) <span class="keyword">from</span> <span class="string">`order`</span>;</span><br></pre></td></tr></table></figure><h2 id="2-3-修改json数据"><a href="#2-3-修改json数据" class="headerlink" title="2.3 修改json数据"></a>2.3 修改json数据</h2><p>使用 <code>JSON_SET</code> 设置 json key 得 值</p><p>id = 1 得 area 数据如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"north": "55", "south": "66"&#125;</span><br></pre></td></tr></table></figure><p>现在将south 值改为 60 的语句示例如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="string">`order`</span> <span class="keyword">set</span> area = json_set(area, <span class="string">'$[0].south'</span>, <span class="string">'60'</span>) <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><p>其中 $[0] 代表 json 中的第一个对象 ,以此类推 $[1] 为 josn 中的第二个对象；</p><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;6&quot;,&quot;2&quot;,&#123;&quot;east&quot;: &quot;50&quot;, &quot;south&quot;: &quot;65&quot;&#125;]</span><br></pre></td></tr></table></figure><p>$[0] 为”6”，$[1] 为 “2” , $[2] 为 {“east”: “50”, “south”: “65”}; $[2].east 为 “50” , 或者 <code>$[2][1]</code>;</p><p>如果上面$[*] 表达式式理解困难也可以使用如下方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="string">`order`</span> <span class="keyword">set</span> area = json_set(area, <span class="string">'$.south'</span>, <span class="string">'60'</span>) <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><blockquote><p>tip: 如果更改整个json值 与 平时的更新数据方式一致</p></blockquote><h2 id="2-4-删除json中的数据"><a href="#2-4-删除json中的数据" class="headerlink" title="2.4 删除json中的数据"></a>2.4 删除json中的数据</h2><p>使用 json_remove 可以达到效果；</p><p>示例: 删除json 中的 south 键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="string">`order`</span> <span class="keyword">set</span> area =json_remove(area, <span class="string">'$.south'</span>) <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><h1 id="三-json函数"><a href="#三-json函数" class="headerlink" title="三 json函数"></a>三 json函数</h1><h2 id="3-5-JSON-INSERT"><a href="#3-5-JSON-INSERT" class="headerlink" title="3.5 JSON_INSERT"></a>3.5 JSON_INSERT</h2><p>JSON_INSERT 函数 向 json 中添加新的值，不会改变已经存在的值；</p><p>id = 1 的数据如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"north": "55"&#125;</span><br></pre></td></tr></table></figure><p>更新语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="string">`order`</span> <span class="keyword">set</span> area =JSON_INSERT(area, <span class="string">'$.north'</span>, <span class="number">55</span> ,<span class="string">'$.south'</span>, <span class="string">"60"</span>) <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><p>更改结果如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"north": "55", "south": "60"&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-JSON-KEYS"><a href="#3-8-JSON-KEYS" class="headerlink" title="3.8 JSON_KEYS"></a>3.8 JSON_KEYS</h2><p>返回json顶级值底下所有key</p><p>id = 1 的数据如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;"north": "50", "south": "60"&#125;, &#123;"north": "50", "south": "70"&#125;]</span><br></pre></td></tr></table></figure><p>查询json数据中第一个json对象所有的key</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> JSON_KEYS(area, <span class="string">'$[0]'</span>)  <span class="keyword">from</span> <span class="string">`order`</span>  <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">["north", "south"]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对Content-type的理解?</title>
      <link href="/2020/11/12/%E5%AF%B9Content-type%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/11/12/%E5%AF%B9Content-type%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>Content-Type</strong>是指http/https发送信息至服务器时的内容编码类型，contentType用于表明发送数据流的类型，服务器根据编码类型使用特定的解析方式，获取数据流中的数据。</p><h3 id="一：application-x-www-form-urlencoded-主要用于如下"><a href="#一：application-x-www-form-urlencoded-主要用于如下" class="headerlink" title="一：application/x-www-form-urlencoded 主要用于如下:"></a><strong>一：application/x-www-form-urlencoded 主要用于如下:</strong></h3><h4 id="urlencoded是什么意思？"><a href="#urlencoded是什么意思？" class="headerlink" title="urlencoded是什么意思？"></a>urlencoded是什么意思？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、它是post的默认格式，使用js中URLencode转码方法。包括将name、value中的空格替换为加号；将非ascii字符做百分号编码；将input的name、value用‘&#x3D;’连接，不同的input之间用‘&amp;’连接。</span><br></pre></td></tr></table></figure><p>1.1: 最常见的POST提交数据方式。<br>1.2：原生form默认的提交方式(可以使用enctype指定提交数据类型)。<br>1.3：jquery，zepto等默认post请求提交的方式。</p><p>\1. 首先来看下form表单中post默认提交方式的数据；代码如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;0&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&quot; method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">      &lt;p&gt;username: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;age: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如下图所示：</p><p><img src="https://images2018.cnblogs.com/blog/561794/201804/561794-20180430225744260-1116552426.png" alt="img"></p><p>application/x-www-form-urlencoded 是最常用的一种请求编码方式，支持GET/POST等方法，所有数据变成键值对的形式 key1=value1&amp;key2=value2<br>的形式，并且特殊字符需要转义成utf-8编号，如空格会变成 %20;</p><p>默认的提交方式是 application/x-www-form-urlencoded 编码提交数据的，在chrome的network面板下，默认的请求体是被解析的。展示成formData的形式；</p><p>如下是使用ajax的方式提交的；</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;0&quot;&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;tugenhua0707.github.io&#x2F;html5UploadImage&#x2F;js&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;btn&quot;&gt;发送post请求&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var obj &#x3D; &#123;</span><br><span class="line">      &quot;name&quot;: &#39;CntChen&#39;,</span><br><span class="line">      &quot;info&quot;: &#39;Front-End&#39;,</span><br><span class="line">    &#125;;</span><br><span class="line">    $(&#39;.btn&#39;).click(function() &#123;</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: &#39;www.example.com&#39;,</span><br><span class="line">        type: &#39;POST&#39;,</span><br><span class="line">        dataType: &#39;json&#39;,</span><br><span class="line">        data: obj,</span><br><span class="line">        success: function(d) &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如下图所示：</p><p><img src="https://images2018.cnblogs.com/blog/561794/201804/561794-20180430225835153-863701865.png" alt="img"></p><p>如上默认提交的 contentType为 application/x-www-form-urlencoded，此时提交的数据将会格式化成：<br>username=111&amp;age=2;</p><p>如果请求类型type是GET的话，那么格式化的字符串将直接拼接在url后发送到服务端； 如果请求类型是POST, 那么格式化的字符串将放在http body的Form Data中发送。</p><h3 id="二：multipart-form-data"><a href="#二：multipart-form-data" class="headerlink" title="二：multipart/form-data"></a><strong>二：multipart/form-data</strong></h3><p>对于一段utf8编码的字节，用application/x-www-form-urlencoded传输其中的ascii字符没有问题，但对于非ascii字符传输效率就很低了（汉字‘丁’从三字节变成了九字节），因此在传很长的字节（如文件）时应用multipart/form-data格式。smtp等协议也使用或借鉴了此格式。</p><p>使用表单上传文件时，必须指定表单的 enctype属性值为 multipart/form-data. 请求体被分割成多部分，每部分使用 –boundary分割；</p><p>html代码如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;0&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&quot; method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">      &lt;p&gt;username: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;age: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如下图所示：</p><p><img src="https://images2018.cnblogs.com/blog/561794/201804/561794-20180430225931100-66284411.png" alt="img"></p><p><a href="https://www.cnblogs.com/tugenhua0707/p/7599691.html" target="_blank" rel="noopener">ajax formdata提交数据请看这篇文章</a></p><h3 id="三：application-json"><a href="#三：application-json" class="headerlink" title="三：application/json"></a><strong>三：application/json</strong></h3><p>在http请求中，ContentType都是默认的值 application/x-www-form-urlencoded, 这种编码格式的特点是：name/value值对，<br>每组之间使用&amp;连接，而name与value之间是使用 = 连接，比如 key=xxx&amp;name=111&amp;password=123456; 键值对一般的情况下是没有什么问题的，<br>是很简单的json形式，比如如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会解析成 a=1&amp;b=2这样的，但是在一些复杂的情况下，比如需要传一个复杂的json对象，也就是对象嵌套数组的情况下，比如如下代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  obj: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: 111,</span><br><span class="line">      &quot;password&quot;: 22</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>这样复杂的对象，application/x-www-form-urlencoded这种形式传递的话， 会被解析成 obj[0][‘name’]=111&amp;obj[0].[‘password’]=2这样的。<br>然后再转成json形式；</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;obj&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: 111,</span><br><span class="line">      &quot;password&quot;: 22</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>对于一些复制的数据对象，对象里面再嵌套数组的话，建议使用application/json传递比较好，开发那边也会要求使用application/json。因为他们那边不使用application/json的话，使用默认的application/x-www-form-urlencoded传递的话，开发那边先要解析成如上那样的，<br>然后再解析成json对象，如果对于比上面更复杂的json对象的话，那么他们那边是很解析的，所以直接json对象传递的话，对于他们来说更简单。</p><p>通过json的形式将数据发送给服务器。json的形式的优点是它可以传递结构复杂的数据形式，比如对象里面嵌套数组这样的形式等。</p><p>如下代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;0&quot;&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;tugenhua0707.github.io&#x2F;html5UploadImage&#x2F;js&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;btn&quot;&gt;发送post请求&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    $(&#39;.btn&#39;).click(function() &#123;</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: &#39;http:&#x2F;&#x2F;www.example.com&#39;,</span><br><span class="line">        type: &#39;POST&#39;,</span><br><span class="line">        dataType: &#39;json&#39;,</span><br><span class="line">        contentType: &#39;application&#x2F;json&#39;,</span><br><span class="line">        data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;),</span><br><span class="line">        success: function(d) &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>但是如上代码，在浏览器运行后，发现跨域了，我们看如下截图所示：</p><p><img src="https://images2018.cnblogs.com/blog/561794/201804/561794-20180430230249656-1515790837.png" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/561794/201804/561794-20180430230257449-234197367.png" alt="img"></p><h3 id="3-1-理解ajax跨域设置-ContentType-application-json"><a href="#3-1-理解ajax跨域设置-ContentType-application-json" class="headerlink" title="3.1 理解ajax跨域设置 ContentType: application/json"></a><strong>3.1 理解ajax跨域设置 ContentType: application/json</strong></h3><p>在使用ajax跨域请求时，如果设置Header的ContentType为 application/json，它会发两次请求，第一次先发Method为OPTIONS的请求到服务器，<br>这个请求会询问服务器支持那些请求方法(比如GET,POST)等。如果这个请求支持跨域的话，就会发送第二个请求，否则的话在控制台会报错，第二个请求不会请求。如下我们做个简单的demo，不跨域的如下：</p><p>如下的代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;0&quot;&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;tugenhua0707.github.io&#x2F;html5UploadImage&#x2F;js&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;btn&quot;&gt;发送post请求&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    $(&#39;.btn&#39;).click(function() &#123;</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: &#39;http:&#x2F;&#x2F;localhost:8081&#x2F;api.json&#39;,</span><br><span class="line">        type: &#39;POST&#39;,</span><br><span class="line">        dataType: &#39;json&#39;,</span><br><span class="line">        contentType: &#39;application&#x2F;json&#39;,</span><br><span class="line">        data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;),</span><br><span class="line">        success: function(d) &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如下图所示：</p><p><img src="https://images2018.cnblogs.com/blog/561794/201804/561794-20180430230355691-288861275.png" alt="img"></p><p>如上我们可以看到json格式提交的数据会显示 Request Payload;</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程中如何使用CPU缓存?</title>
      <link href="/2020/11/12/%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CPU%E7%BC%93%E5%AD%98/"/>
      <url>/2020/11/12/%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CPU%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>CPU缓存会把一片连续的内存空间读入， 因为数组结构是连续的内存地址，所以数组全部或者部分元素被连续存在CPU缓存里面， 平均读取每个元素的时间只要3个CPU时钟周期。   而链表的节点是分散在堆空间里面的，这时候CPU缓存帮不上忙，只能是去读取内存，平均读取时间需要100个CPU时钟周期。 这样算下来，数组访问的速度比链表快33倍！ （这里只是介绍概念，具体的数字因CPU而异）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis分布式锁剖析</title>
      <link href="/2020/11/12/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/11/12/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>如何用Redis实现分布式锁？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;6844903616667451399</span><br></pre></td></tr></table></figure><p>Redis分布式锁的基本流程并不难理解，但要想写得尽善尽美，也并不是那么容易。在这里，我们需要先了解分布式锁实现的三个核心要素：</p><p><strong>1.加锁</strong></p><p>最简单的方法是使用setnx命令。key是锁的唯一标识，按业务来决定命名。比如想要给一种商品的秒杀活动加锁，可以给key命名为 “lock_sale_商品ID” 。而value设置成什么呢？我们可以姑且设置成1。加锁的伪代码如下：    </p><p><strong>setnx（key，1）</strong></p><p>当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败。</p><p><strong>2.解锁</strong></p><p>**<br>**</p><p>有加锁就得有解锁。当得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式是执行del指令，伪代码如下：</p><p><strong>del（key）</strong></p><p>释放锁之后，其他线程就可以继续执行setnx命令来获得锁。</p><p><strong>3.锁超时</strong></p><p>锁超时是什么意思呢？如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住，别的线程再也别想进来。</p><p>所以，setnx的key必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一定时间后自动释放。setnx不支持超时参数，所以需要额外的指令，伪代码如下：</p><p><strong>expire（key， 30）</strong></p><p>综合起来，我们分布式锁实现的第一版伪代码如下：</p><p><strong>if（setnx（key，1） == 1）{</strong></p><p>​    <strong>expire（key，30）</strong></p><p>​    <strong>try {</strong></p><p>​        <strong><em>\</em>do something ……\</strong><br>**</p><p>​    <strong>} finally {</strong></p><p>​        <strong><em>\</em>del（key）**</strong></p><p>​    <strong>}</strong></p><p><strong>}</strong></p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="650" height="300"/>)</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="650" height="300"/>)</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="650" height="300"/>)</p><p>好端端的代码，怎么就回家等通知了呢？</p><p>因为上面的伪代码中，存在着三个致命问题：</p><p><strong>1. \</strong>setnx和expire的非原子性****</p><p><strong><em>\</em><br>**</strong></p><p>设想一个极端场景，当某线程执行setnx，成功得到了锁：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/5/163ce411edffe08a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>setnx刚执行成功，还未来得及执行expire指令，节点1 Duang的一声挂掉了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/5/163ce411fcaed3b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>这样一来，这把锁就没有设置过期时间，变得“长生不老”，别的线程再也无法获得锁了。</p><p>怎么解决呢？setnx指令本身是不支持传入超时时间的，幸好Redis 2.6.12以上版本为<strong>set</strong>指令增加了可选参数，伪代码如下：</p><p><strong>set（key，1，30，NX）</strong></p><p>这样就可以取代setnx指令。</p><p><strong><em>\</em>2. ******del 导致误删*****\</strong>***</p><p>又是一个极端场景，假如某线程成功得到了锁，并且设置的超时时间是30秒。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="567" height="341"/>)</p><p>如果某些原因导致线程B执行的很慢很慢，过了30秒都没执行完，这时候锁过期自动释放，线程B得到了锁。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="567" height="341"/>)</p><p>随后，线程A执行完了任务，线程A接着执行del指令来释放锁。但这时候线程B还没执行完，<strong>线程A实际上删除的是线程B加的锁</strong>。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="567" height="341"/>)</p><p><strong>*\</strong>*****<br>******<em>**</em></p><p><strong>*\</strong>*****<br>******<em>**</em></p><p>怎么避免这种情况呢？可以在del释放锁之前做一个判断，验证当前的锁是不是自己加的锁。</p><p>至于具体的实现，可以在加锁的时候把当前的线程ID当做value，并在删除之前验证key对应的value是不是自己线程的ID。</p><p>加锁：</p><p><strong>String threadId = Thread.currentThread().getId()</strong></p><p><strong>*\</strong>*******set（key，*********<strong>**</strong>*<em>\</em>********threadId**********<em>**</em> <strong>*\</strong>*******，30，NX）************</p><p>解锁：</p><p><strong>if（**</strong>threadId** <strong>.equals(redisClient.get(\</strong>key*<em>))）{*</em></p><p>​    *<em>del(key)<br>*</em></p><p><strong>}</strong></p><p>**<br>**</p><p>但是，这样做又隐含了一个新的问题，<strong>判断和释放锁是两个独立操作，不是原子性</strong>。</p><p>我们都是追求极致的程序员，所以这一块要用Lua脚本来实现：</p><p><strong>String luaS**</strong>cript = “if redis.call(‘get’, KEYS[1]) == ARGV[1] then return *<em>\</em>*redis**<em>\</em>.call(‘del’, KEYS[1]) else return 0 end”;**</p><p>**<br>**</p><p><strong><em>\</em>redisClient\</strong>.eval(*<em>luaS*</em>*<em>cript*</em> , Collections.singletonList(key), Collections.singletonList(threadId));**</p><p>这样一来，验证和删除过程就是原子操作了。</p><p><strong>*\</strong>*****<br>******<em>**</em></p><p><strong><em>\</em>3. ******出现并发的可能性*****\</strong>***</p><p><strong>*\</strong>*****<br>******<em>**</em></p><p>还是刚才第二点所描述的场景，虽然我们避免了线程A误删掉key的情况，但是同一时间有A，B两个线程在访问代码块，仍然是不完美的。</p><p>怎么办呢？我们可以让获得锁的线程开启一个<strong>守护线程</strong>，用来给快要过期的锁“续航”。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="567" height="439"/>)</p><p>当过去了29秒，线程A还没执行完，这时候守护线程会执行expire指令，为这把锁“续命”20秒。守护线程从第29秒开始执行，每20秒执行一次。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="567" height="274"/>)</p><p><strong>*\</strong>*****<br>******<em>**</em></p><p>当线程A执行完任务，会显式关掉守护线程。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/5/163ce4121756cc64?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>另一种情况，如果节点1 忽然断电，由于线程A和守护线程在同一个进程，守护线程也会停下。这把锁到了超时的时候，没人给它续命，也就自动释放了。</p><p>**<br>**</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/5/163ce4122ea9f38a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>守护线程的代码并不难实现，有了大体思路，大家可以自己尝试实现一下。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双亲委派剖析</title>
      <link href="/2020/11/08/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%89%96%E6%9E%90/"/>
      <url>/2020/11/08/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>双亲委派模型要求<strong>除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器</strong>。</p><p>双亲委派模型的工作过程是：</p><ul><li>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。</li><li>每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。</li><li>只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性</strong>，每一个类加载器，都拥有一个独立的类名称空间。因此，使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处：<strong>类随着它的类加载器一起具备了一种带有优先级的层次关系</strong>。</p><p>例如类<code>java.lang.Object</code>，它由启动类加载器加载。双亲委派模型保证任何类加载器收到的对<code>java.lang.Object</code>的加载请求，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此<strong>Object类在程序的各种类加载器环境中都是同一个类</strong>。</p><p>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并用自定义的类加载器加载，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>根据双亲委派机制，我们知道它一定是被应用程序类加载器AppClassLoader加载，而不是我们自定义的类加载器</p><h3 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h3><p><strong>失败的尝试</strong><br>由于需要使用不同的类加载器加载类，所以自定义了一个类加载器从指定的目录下加载类。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class TestStaticBlock &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;static block init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        &#x2F;&#x2F;new TestStaticBlock();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; class0 &#x3D; TestStaticBlock.class;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(class0.getClassLoader() instanceof MyClassLoader);</span><br><span class="line">            Class&lt;?&gt; class1 &#x3D; class0.getClassLoader().loadClass(&quot;classloader.TestStaticBlock&quot;);</span><br><span class="line">            ClassLoader classLoader &#x3D; new MyClassLoader();</span><br><span class="line">            Class&lt;?&gt; class2 &#x3D; classLoader.loadClass(&quot;TestStaticBlock&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(class1.hashCode());</span><br><span class="line">            System.out.println(class2.hashCode());</span><br><span class="line">            System.out.println(class1.equals(class2));</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;自定义一个类加载器从指定磁盘目录加载类</span><br><span class="line">    public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line">        &#x2F;&#x2F;不破坏双亲委派模型</span><br><span class="line">        @Override</span><br><span class="line">        protected Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">            String myPath &#x3D; &quot;D:&#x2F;myeclipseworkspace&#x2F;class&#x2F;&quot; + name.replace(&quot;.&quot;,&quot;&#x2F;&quot;) + &quot;.class&quot;;</span><br><span class="line">            System.out.println(myPath);</span><br><span class="line">            byte[] classBytes &#x3D; null;</span><br><span class="line">            FileInputStream in &#x3D; null;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                File file &#x3D; new File(myPath);</span><br><span class="line">                in &#x3D; new FileInputStream(file);</span><br><span class="line">                classBytes &#x3D; new byte[(int) file.length()];</span><br><span class="line">                in.read(classBytes);</span><br><span class="line">            &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; clazz &#x3D; defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">            return clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859</span><br></pre></td></tr></table></figure><p>System.out.println(class1.equals(class2));猜猜输出的结果是什么？答案居然是true！这不是违背了我们平时的认知吗？被不同的类加载器加载的类不应该是不同的类吗？机智的博主很快想到了可能是双亲委派模型在作祟，先让我们看一看ClassLoader中loadClass()的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">      throws ClassNotFoundException</span><br><span class="line">  &#123;</span><br><span class="line">      synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">          &#x2F;&#x2F; First, check if the class has already been loaded</span><br><span class="line">          Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">          if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">              long t0 &#x3D; System.nanoTime();</span><br><span class="line">              try &#123;</span><br><span class="line">                  &#x2F;&#x2F;双亲委派模型的体现</span><br><span class="line">                  if (parent !&#x3D; null) &#123;</span><br><span class="line">                      c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                  &#x2F;&#x2F; ClassNotFoundException thrown if class not found</span><br><span class="line">                  &#x2F;&#x2F; from the non-null parent class loader</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                  &#x2F;&#x2F; If still not found, then invoke findClass in order</span><br><span class="line">                  &#x2F;&#x2F; to find the class.</span><br><span class="line">                  long t1 &#x3D; System.nanoTime();</span><br><span class="line">                  c &#x3D; findClass(name);</span><br><span class="line"></span><br><span class="line">                  &#x2F;&#x2F; this is the defining class loader; record the stats</span><br><span class="line">                  sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                  sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                  sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (resolve) &#123;</span><br><span class="line">              resolveClass(c);</span><br><span class="line">          &#125;</span><br><span class="line">          return c;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;1234567891011121314151617181920212223242526272829303132333435363738</span><br></pre></td></tr></table></figure><p>看看打印的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(classLoader.getParent());</span><br><span class="line">System.out.println(class0.getClassLoader());12</span><br><span class="line">sun.misc.Launcher$AppClassLoader@6d06d69c</span><br><span class="line">sun.misc.Launcher$AppClassLoader@6d06d69c12</span><br></pre></td></tr></table></figure><p>当当当当，发现我们虽然重写了ClassLoader的findClass()方法，但是并没有打破双亲委派模型。使用自定义类加载器加载TestStaticBlock最后还是被转发到了父类加载器，而从输出结果可以看出这个父类加载器就是class0.getClassLoader()。当然加载出来的类也会是同一个类。</p><hr><p><strong>打破双亲委派模型</strong><br>那么就没有办法打破双亲委派模型吗？结果当然是false。只需要重写ClassLoader类的loadClass()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;破坏双亲委派模型</span><br><span class="line">  @Override</span><br><span class="line">public Class&lt;?&gt; loadClass(String name)</span><br><span class="line">    throws ClassNotFoundException &#123;</span><br><span class="line">      String myPath &#x3D; &quot;D:&#x2F;myeclipseworkspace&#x2F;class&#x2F;&quot; + name.replace(&quot;.&quot;,&quot;&#x2F;&quot;) + &quot;.class&quot;;</span><br><span class="line">      System.out.println(myPath);</span><br><span class="line">      byte[] classBytes &#x3D; null;</span><br><span class="line">      FileInputStream in &#x3D; null;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">    File file &#x3D; new File(myPath);</span><br><span class="line">    in &#x3D; new FileInputStream(file);</span><br><span class="line">    classBytes &#x3D; new byte[(int) file.length()];</span><br><span class="line">    in.read(classBytes);</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      System.out.println();</span><br><span class="line">      Class&lt;?&gt; clazz &#x3D; defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">      return clazz;</span><br><span class="line">&#125;123456789101112131415161718192021222324252627282930</span><br></pre></td></tr></table></figure><p>以为这就结束了吗？naive。让我们看看运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.FileNotFoundException: D:\myeclipseworkspace\class\java\lang\Object.class (系统找不到指定的路径。)1</span><br></pre></td></tr></table></figure><p>由于我们打破了双亲委派模型，所以父类的加载（Object）也会交由我们自自定义的类加载器加载。而很明显在我们自定义的加载目录下是不会有Object.class这个文件的。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逃逸分析</title>
      <link href="/2020/11/08/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
      <url>/2020/11/08/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。</p><p>第一段编译就是<code>javac</code>命令。</p><p>在第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了 JIT（即时编译） 技术。</p><p>引入了 JIT 技术后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p><p>由于关于JIT编译和热点检测的内容，我在<a href="http://www.hollischuang.com/archives/2322" target="_blank" rel="noopener">深入分析Java的编译原理</a>中已经介绍过了，这里就不在赘述，本文主要来介绍下JIT中的优化。JIT优化中最重要的一个就是逃逸分析。</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>关于逃逸分析的概念，可以参考<a href="http://www.hollischuang.com/archives/2398" target="_blank" rel="noopener">对象和数组并不是都在堆上分配内存的。</a>一文，这里简单回顾一下：</p><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p><p>例如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static StringBuffer craeteStringBuffer(String s1, String s2) &#123;</span><br><span class="line">    StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    return sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String createStringBuffer(String s1, String s2) &#123;</span><br><span class="line">    StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>第一段代码中的<code>sb</code>就逃逸了，而第二段代码中的<code>sb</code>就没有逃逸。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><p>二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p><p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p><p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，</p><p><code>-XX:+DoEscapeAnalysis</code> ： 表示开启逃逸分析</p><p><code>-XX:-DoEscapeAnalysis</code> ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p><h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p><p>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫<a href="http://www.hollischuang.com/archives/2344" target="_blank" rel="noopener">锁消除</a>。</p><p>如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void f() &#123;</span><br><span class="line">    Object hollis &#x3D; new Object();</span><br><span class="line">    synchronized(hollis) &#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void f() &#123;</span><br><span class="line">    Object hollis &#x3D; new Object();</span><br><span class="line">    System.out.println(hollis);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>所以，在使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。</p><h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void alloc() &#123;</span><br><span class="line">   Point point &#x3D; new Point（1,2）;</span><br><span class="line">   System.out.println(&quot;point.x&#x3D;&quot;+point.x+&quot;; point.y&#x3D;&quot;+point.y);</span><br><span class="line">&#125;</span><br><span class="line">class Point&#123;</span><br><span class="line">    private int x;</span><br><span class="line">    private int y;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上代码中，point对象并没有逃逸出<code>alloc</code>方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。</p><p>以上代码，经过标量替换后，就会变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void alloc() &#123;</span><br><span class="line">   int x &#x3D; 1;</span><br><span class="line">   int y &#x3D; 2;</span><br><span class="line">   System.out.println(&quot;point.x&#x3D;&quot;+x+&quot;; point.y&#x3D;&quot;+y);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p><p>标量替换为栈上分配提供了很好的基础。</p><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。</p><p>关于栈上分配的详细介绍，可以参考<a href="http://www.hollischuang.com/archives/2398" target="_blank" rel="noopener">对象和数组并不是都在堆上分配内存的。</a>。</p><p>这里，还是要简单说一下，其实在现有的虚拟机中，并没有真正的实现栈上分配，在<a href="http://www.hollischuang.com/archives/2398" target="_blank" rel="noopener">对象和数组并不是都在堆上分配内存的。</a>中我们的例子中，对象没有在堆上分配，其实是标量替换实现的。</p><h3 id="逃逸分析并不成熟"><a href="#逃逸分析并不成熟" class="headerlink" title="逃逸分析并不成熟"></a>逃逸分析并不成熟</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>G1相关补充</title>
      <link href="/2020/11/07/G1%E7%9B%B8%E5%85%B3%E8%A1%A5%E5%85%85/"/>
      <url>/2020/11/07/G1%E7%9B%B8%E5%85%B3%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>G1收集概览：</strong></p><p>G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片问题的存在了。</p><p><strong>Humongous区域：</strong></p><p>在G1中，还有一种特殊的区域，叫Humongous区域。如果一个对象占用的空间达到或者超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。</p><p><strong>G1 Young GC:</strong></p><ul><li>Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC完成工作，应用线程继续执行。</li><li>如果仅仅GC新生代对象，我们如何找到所有的根对象呢？老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是,G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。下面看图：<br><img src="https://img2018.cnblogs.com/blog/324374/201907/324374-20190707204635341-1202702709.png" alt="img"></li><li>在CMS中，也有RSet的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。 </li><li>但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。</li><li>于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。</li><li>由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用既可。</li><li>需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（既数组下标）来标识每个分区的空间地址。</li><li>默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为“0”，既标记为被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。</li></ul><p>另外它分为下几个阶段：</p><ul><li>阶段1：根扫描<br>表态和本地对象被扫描</li><li>阶段2：更新RS<br>处理dirty card队列更新RS</li><li>阶段3：处理RS<br>检测从年轻代指向老年代的对象</li><li>阶段4：对象拷贝<br>拷贝存活的对象到survivor/old区域</li><li>阶段5：处理引用队列<br>软引用、弱引用、虚引用处理</li></ul><p><strong>再谈Mixed GC:</strong></p><ul><li>Mixed GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。</li><li>这的GC步骤分为两步：<br>1、全局并发标记（global concurrent marking）<br>2、拷贝存活对象（evacuation）</li><li>在G1 GC中，global concurrent marking主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。global concurrent marking的执行过程分为四个步骤，这个在之前已经学习过了，回忆一下：<br><img src="https://img2018.cnblogs.com/blog/324374/201907/324374-20190707211002790-2041758892.png" alt="img"></li></ul><p><strong>三色标记算法：</strong></p><ul><li>提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性。 </li><li>我们将对象分成三种类型：<br>1、黑色：根对象，或者该对象与它的子对象都被扫描过（对象被标记了，且它的所有field也被标记完了）。<br>2、灰色：对象本身被扫描，但还没扫描完该对象中的子对象（它的field还没有被标记或标记完）。<br>3、白色：未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，既垃圾对象（对象没有被标记到）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型问题</title>
      <link href="/2020/11/07/%E6%B3%9B%E5%9E%8B%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/07/%E6%B3%9B%E5%9E%8B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>泛型指的是可以将类型作为参数进行传递，其本质上就是类型参数化。比如:我们平时定义一个方法的时候，常会指定要传入一个具体类对象作为参数。而如果使用泛型，那么这个具体传入类的对象，就可以指定为某个类型，而不必指定具体的类。也就是我们将某个类型作为参数进行传递了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;普通方法</span><br><span class="line">public void testValue(String s) &#123;&#125;</span><br><span class="line">&#x2F;&#x2F;泛型方法</span><br><span class="line">public &lt;T&gt; void testValue(T t) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用泛型有哪些好处？"><a href="#2-使用泛型有哪些好处？" class="headerlink" title="2. 使用泛型有哪些好处？"></a>2. 使用泛型有哪些好处？</h3><ul><li>它可以避免类型强制转换，而引起的程序异常。</li><li>可以是代码更加简洁易度。</li></ul><h3 id="3-类型擦除"><a href="#3-类型擦除" class="headerlink" title="3. 类型擦除"></a>3. 类型擦除</h3><p>泛型值存在于编译期，代码在进入虚拟机后泛型就会会被擦除掉，这个者特性就叫做类型擦除。当泛型被擦除后，他有两种转换方式，第一种是如果泛型没有设置类型上限，那么将泛型转化成Object类型，第二种是如果设置了类型上限，那么将泛型转化成他的类型上限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;未指定上限</span><br><span class="line">public class Test1&lt;T&gt; &#123;</span><br><span class="line">    T t;</span><br><span class="line">    public T getValue() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setVale(T t) &#123;</span><br><span class="line">        this.t &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;指定上限</span><br><span class="line">public class Test2&lt;T extends String&gt; &#123;</span><br><span class="line">    T t;</span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;通过反射调用获取他们的属性类型</span><br><span class="line">@Test</span><br><span class="line">public void testType1() &#123;</span><br><span class="line">    Test1&lt;String&gt; test1 &#x3D; new Test1&lt;&gt;();</span><br><span class="line">    test1.setVale(&quot;11111&quot;);</span><br><span class="line">    Class&lt;? extends Test1&gt; aClass &#x3D; test1.getClass();</span><br><span class="line">    for (Field field : aClass.getDeclaredFields()) &#123;</span><br><span class="line">        System.out.println(&quot;Test1属性:&quot; + field.getName() + &quot;的类型为：&quot; + field.getType().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Test2 test2 &#x3D; new Test2();</span><br><span class="line">    test2.setT(&quot;2222&quot;);</span><br><span class="line">    Class&lt;? extends Test2&gt; aClass2 &#x3D; test2.getClass();</span><br><span class="line">    for (Field field : aClass2.getDeclaredFields()) &#123;</span><br><span class="line">        System.out.println(&quot;test2属性：&quot; + field.getName() + &quot;的类型为：&quot; + field.getType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面方法打印的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test1属性:t的类型为：java.lang.Object</span><br><span class="line">Test2属性：t的类型为：java.lang.String</span><br></pre></td></tr></table></figure><h3 id="4-泛型的两个关键字？"><a href="#4-泛型的两个关键字？" class="headerlink" title="4.泛型的两个关键字？"></a>4.泛型的两个关键字？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        List&lt;? extends A&gt; list1 &#x3D; new ArrayList&lt;A&gt;();</span><br><span class="line">&#x2F;&#x2F;          list1.add(new A()); &#x2F;&#x2F;错误，编译器无法确定List所持有的类型，所以无法安全的向其中添加对象</span><br><span class="line">        A a &#x3D; list1.get(0);</span><br><span class="line">        List&lt;? extends A&gt; list2 &#x3D; new ArrayList&lt;B&gt;();</span><br><span class="line">        List&lt;? super B&gt; list3 &#x3D; new ArrayList&lt;B&gt;();</span><br><span class="line">        list3.add(new B());</span><br><span class="line">        &#x2F;&#x2F;想要正确，必须向下转型，但是向下转型是不安全的，非常容易出错</span><br><span class="line">       &#x2F;&#x2F;   B b &#x3D; list3.get(0); &#x2F;&#x2F;编译器无法确定get返回的对象类型是B,还是B的父类或 Object.</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static class A&#123;&#125;</span><br><span class="line">    static class B extends A &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList heroList&lt;? extends Hero&gt; 表示这是一个Hero泛型或者其子类泛型<br>heroList 的泛型可能是Hero<br>heroList 的泛型可能是APHero<br>heroList 的泛型可能是ADHero<br>所以 可以确凿的是，<strong>从heroList取出来的对象，一定是可以转型成Hero的</strong></p><p>但是，不能往里面放东西，因为<br>放APHero就不满足<ADHero><br>放ADHero又不满足<APHero></APHero></ADHero></p><p>ArrayList heroList&lt;? super Hero&gt; 表示这是一个Hero泛型或者其父类泛型<br>heroList的泛型可能是Hero<br>heroList的泛型可能是Object</p><p><strong>可以往里面插入Hero以及Hero的子类</strong><br>但是取出来有风险，因为不确定取出来是Hero还是Object</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TLAB是什么</title>
      <link href="/2020/11/07/TLAB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2020/11/07/TLAB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>TLAB （Thread Local Allocation Buffer，线程本地分配缓冲区）是 Java 中内存分配的一个概念，它是在 Java 堆中划分出来的针对每个线程的内存区域，专门在该区域为该线程创建的对象分配内存。它的主要目的是在多线程并发环境下需要进行内存分配的时候，减少线程之间对于内存分配区域的竞争，加速内存分配的速度。TLAB 本质上还是在 Java 堆中的，因此在 TLAB 区域的对象，也可以被其他线程访问。</p><p>如果没有启用 TLAB，多个并发执行的线程需要创建对象、申请分配内存的时候，有可能在 Java 堆的同一个位置申请，这时就需要对拟分配的内存区域进行加锁或者采用 CAS 等操作，保证这个区域只能分配给一个线程。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>final关键字</title>
      <link href="/2020/11/07/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/11/07/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final 类不能被继承，所有成员方法都会被隐式地指定为 final 方法，final 方法不能被重写。</p><p>final 变量表示常量，只能被赋值一次，赋值后值不再改变。</p><ul><li>修饰基本数据类型时，该值在初始化后不能改变。</li><li>修饰引用类型时，引用指向的对象在初始化后不能改变，但该对象的内容可以发生变化。</li></ul><p><strong>内存语义</strong></p><ul><li><p>编译器会在 final 域的写后，构造方法的 return 前插入一个 Store Store 屏障，确保对象引用为任意线程可见前其 final 域已初始化。 </p></li><li><p>编译器在读 final 域操作的前面插入一个 Load Load 屏障，确保在读一个对象的 final 域前一定会先读包含这个 final 域的对象引用。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantReadWriteLock剖析</title>
      <link href="/2020/11/07/ReentrantReadWriteLock%E5%89%96%E6%9E%90/"/>
      <url>/2020/11/07/ReentrantReadWriteLock%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>ReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过AQS来实现的。</p><p><img src="https://img-blog.csdn.net/2018083010475814?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4a2NzZG4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>AQS定义了独占模式的acquire()和release()方法，共享模式的acquireShared()和releaseShared()方法.还定义了抽象方法tryAcquire()、tryAcquiredShared()、tryRelease()和tryReleaseShared()由子类实现，tryAcquire()和tryAcquiredShared()分别对应独占模式和共享模式下的锁的尝试获取，就是通过这两个方法来实现公平性和非公平性，在尝试获取中，如果新来的线程必须先入队才能获取锁就是公平的，否则就是非公平的。这里可以看出AQS定义整体的同步器框架，具体实现放手交由子类实现。</p><blockquote><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3></blockquote><p>ReadLock和WriteLock方法都是通过调用Sync的方法实现的，所以我们先来分析一下Sync源码：</p><p>AQS 的状态state是32位（int 类型）的，辦成两份，读锁用高16位，表示持有读锁的线程数（sharedCount），写锁低16位，表示写锁的重入次数 （exclusiveCount）。状态值为 0 表示锁空闲，sharedCount不为 0 表示分配了读锁，exclusiveCount 不为 0 表示分配了写锁，sharedCount和exclusiveCount 一般不会同时不为 0，只有当线程占用了写锁，该线程可以重入获取读锁，反之不成立。</p><p><img src="http://ifeve.com/wp-content/uploads/2015/10/1.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       static final int SHARED_SHIFT   &#x3D; 16;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 由于读锁用高位部分，所以读锁个数加1，其实是状态值加 2^16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       static final int SHARED_UNIT    &#x3D; (1 &lt;&lt; SHARED_SHIFT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 写锁的可重入的最大次数、读锁允许的最大数量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       static final int MAX_COUNT      &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 写锁的掩码，用于状态的低16位有效值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       static final int EXCLUSIVE_MASK &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 读锁计数，当前持有读锁的线程数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 写锁的计数，也就是它的重入次数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 重入计数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * 每个线程特定的 read 持有计数。存放在ThreadLocal，不需要是线程安全的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static final class HoldCounter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 使用id而不是引用是为了避免保留垃圾。注意这是个常量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        final long tid &#x3D; Thread.currentThread().getId();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * 采用继承是为了重写 initialValue 方法，这样就不用进行这样的处理：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * 如果ThreadLocal没有当前线程的计数，则new一个，再放进ThreadLocal里。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * 可以直接调用 get。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static final class ThreadLocalHoldCounter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        extends ThreadLocal&lt;HoldCounter&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public HoldCounter initialValue() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return new HoldCounter();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * 保存当前线程重入读锁的次数的容器。在读锁重入次数为 0 时移除。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private transient ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * 最近一个成功获取读锁的线程的计数。这省却了ThreadLocal查找，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * 通常情况下，下一个释放线程是最后一个获取线程。这不是 volatile 的，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * 因为它仅用于试探的，线程进行缓存也是可以的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * （因为判断是否是当前线程是通过线程id来比较的）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private transient HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * firstReader是这样一个特殊线程：它是最后一个把 共享计数 从 0 改为 1 的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * （在锁空闲的时候），而且从那之后还没有释放读锁的。如果不存在则为null。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * firstReaderHoldCount 是 firstReader 的重入计数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * firstReader 不能导致保留垃圾，因此在 tryReleaseShared 里设置为null，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * 除非线程异常终止，没有释放读锁。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * 作用是在跟踪无竞争的读锁计数时非常便宜。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     * firstReader及其计数firstReaderHoldCount是不会放入 readHolds 的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private transient Thread firstReader &#x3D; null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private transient int firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Sync() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        readHolds &#x3D; new ThreadLocalHoldCounter();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        setState(getState()); &#x2F;&#x2F; 确保 readHolds 的内存可见性，利用 volatile 写的内存语义。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync中提供了很多方法，但是有两个方法是抽象的，子类必须实现。下面以FairSync为例，分析一下这两个抽象方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private static final long serialVersionUID &#x3D; -2274990926593161451L;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        final boolean writerShouldBlock() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return hasQueuedPredecessors();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        final boolean readerShouldBlock() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return hasQueuedPredecessors();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>writerShouldBlock和readerShouldBlock方法都表示当有别的线程也在尝试获取锁时，是否应该阻塞。<br>对于公平模式，hasQueuedPredecessors()方法表示前面是否有等待线程。一旦前面有等待线程，那么为了遵循公平，当前线程也就应该被挂起。 </p><p>下面再来看NonfairSync的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private static final long serialVersionUID &#x3D; -8159625535654395037L;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        final boolean writerShouldBlock() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return false; &#x2F;&#x2F; 写线程总是可以闯入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        final boolean readerShouldBlock() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return apparentlyFirstQueuedIsExclusive();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**如果头节点的下一个节点是独占线程，为了防止独占线程也就是写线程饥饿等待，则后入线程应该排队，否则可以闯入*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final boolean apparentlyFirstQueuedIsExclusive() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Node h, s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return (h &#x3D; head) !&#x3D; null &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            (s &#x3D; h.next)  !&#x3D; null &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            !s.isShared()         &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            s.thread !&#x3D; null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，非公平模式下，writerShouldBlock直接返回false，说明不需要阻塞；而readShouldBlock调用了apparentFirstQueuedIsExcluisve()方法。如果等待队列中第一个等待线程想获取写锁，返回true；否则返回false。也就说明，如果等待队列中第一个等待线程想获取写锁，那么该读线程应该阻塞。</p><p>如果当前全局处于读锁状态，且等待队列中第一个等待线程想获取写锁，那么当前线程能够获取到读锁的条件为：当前线程获取了写锁，还未释放；当前线程获取了读锁，这一次只是重入读锁而已；其它情况当前线程入队尾。之所以这样处理一方面是为了效率，一方面是为了避免想获取写锁的线程饥饿，老是得不到执行的机会   。</p><p>例如：线程C请求一个写锁，由于当前其他两个线程拥有读锁，写锁获取失败，线程C入队列(根据规则i)，如下所示</p><p> <img src="https://img-blog.csdn.net/20160904214925521" alt="img"> </p><p>AQS初始化会创建一个空的头节点，C入队列，然后会休眠，等待其他线程释放锁唤醒。</p><p>此时线程D也来了，线程D想获取一个读锁，上面规则，队列中第一个等待线程C请求的是写锁，为避免写锁迟迟获取不到，并且线程D不是重入获取读锁，所以线程D也入队，如下图所示：</p><p>   <img src="https://img-blog.csdn.net/20160904214945256" alt="img"></p><blockquote><h3 id="读锁获取"><a href="#读锁获取" class="headerlink" title="读锁获取"></a>读锁获取</h3></blockquote><h3 id="获取共享lock-方法-acquireShared"><a href="#获取共享lock-方法-acquireShared" class="headerlink" title="获取共享lock 方法 acquireShared"></a>获取共享lock 方法 acquireShared</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if(tryAcquireShared(arg) &lt; 0)&#123;  &#x2F;&#x2F; 1. 调用子类, 获取共享 lock  返回 &lt; 0, 表示失败</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        doAcquireShared(arg);       &#x2F;&#x2F; 2. 调用 doAcquireShared 当前 线程加入 Sync Queue 里面, 等待获取 lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Sync实现的尝试获取锁</p><p>在以下几种情况，获取读锁会失败：</p><p>（1）有线程持有写锁，且该线程不是当前线程，获取锁失败。</p><p>（2）写锁空闲 且  公平策略决定 读线程应当被阻塞，除了重入获取，其他获取锁失败。</p><p>（3）读锁数量达到最多，抛出异常。</p><p>除了以上三种情况，该线程会循环尝试获取读锁直到成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Thread current &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (exclusiveCount(c) !&#x3D; 0 &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                getExclusiveOwnerThread() !&#x3D; current)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                return -1;            &#x2F;&#x2F;1.有线程持有写锁，且该线程不是当前线程，获取锁失败</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            int r &#x3D; sharedCount(c);   &#x2F;&#x2F;2.获取读锁计数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (!readerShouldBlock() &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;&#x2F;&#x2F;3.如果不应该阻塞，且读锁数&lt;MAX_COUNT且设置同步状态state成功，获取锁成功。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if (r &#x3D;&#x3D; 0) &#123;            &#x2F;&#x2F;下面对firstReader的处理：firstReader是不会放到readHolds里的，这样，在读锁只有一个的情况下，就避免了查找readHolds。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    firstReader &#x3D; current;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    firstReaderHoldCount &#x3D; 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125; else if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  &#x2F;&#x2F; 非 firstReader 读锁重入计数更新</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; current.getId())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        cachedHoldCounter &#x3D; rh &#x3D; readHolds.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    else if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    rh.count++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                return 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;4.获取读锁失败，放到循环里重试。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return fullTryAcquireShared(current);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">final int fullTryAcquireShared(Thread current) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            HoldCounter rh &#x3D; null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            for (;;) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                int c &#x3D; getState();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if (exclusiveCount(c) !&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    if (getExclusiveOwnerThread() !&#x3D; current)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        return -1;     &#x2F;&#x2F;1.有线程持有写锁，且该线程不是当前线程，获取锁失败</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;2.有线程持有写锁，且该线程是当前线程，则应该放行让其重入获取锁，否则会造成死锁。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125; else if (readerShouldBlock()) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;3.写锁空闲  且  公平策略决定 读线程应当被阻塞</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                      &#x2F;&#x2F; 下面的处理是说，如果是已获取读锁的线程重入读锁时，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                      &#x2F;&#x2F; 即使公平策略指示应当阻塞也不会阻塞。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                      &#x2F;&#x2F; 否则，这也会导致死锁的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        &#x2F;&#x2F; assert firstReaderHoldCount &gt; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        if (rh &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            rh &#x3D; cachedHoldCounter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; current.getId()) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                rh &#x3D; readHolds.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    readHolds.remove();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        &#x2F;&#x2F;4.需要阻塞且是非重入(还未获取读锁的)，获取失败。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            return -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;5.写锁空闲  且  公平策略决定线程可以获取读锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if (sharedCount(c) &#x3D;&#x3D; MAX_COUNT)&#x2F;&#x2F;6.读锁数量达到最多</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;7. 申请读锁成功，下面的处理跟tryAcquireShared是类似的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    if (sharedCount(c) &#x3D;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        firstReader &#x3D; current;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        firstReaderHoldCount &#x3D; 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125; else if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        if (rh &#x3D;&#x3D; null)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            rh &#x3D; cachedHoldCounter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; current.getId())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            rh &#x3D; readHolds.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        else if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        rh.count++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        cachedHoldCounter &#x3D; rh; &#x2F;&#x2F; cache for release</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    return 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="获取共享lock-方法-doAcquireShared"><a href="#获取共享lock-方法-doAcquireShared" class="headerlink" title="获取共享lock 方法 doAcquireShared"></a>获取共享lock 方法 doAcquireShared</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);       &#x2F;&#x2F; 1. 将当前的线程封装成 Node 加入到 Sync Queue 里面</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(;;)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            final Node p &#x3D; node.predecessor();      &#x2F;&#x2F; 2. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if(p &#x3D;&#x3D; head)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);      &#x2F;&#x2F; 3. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquireShared 尝试获取一下</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if(r &gt;&#x3D; 0)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    setHeadAndPropagate(node, r);   &#x2F;&#x2F; 4. 获取 lock 成功, 设置新的 head, 并唤醒后继获取  readLock 的节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    if(interrupted)&#123;               &#x2F;&#x2F; 5. 在获取 lock 时, 被中断过, 则自己再自我中断一下(外面的函数可能需要这个参数)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        selfInterrupt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    return;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if(shouldParkAfterFailedAcquire(p, node) &amp;&amp; &#x2F;&#x2F; 6. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    parkAndCheckInterrupt())&#123;           &#x2F;&#x2F; 7. 现在lock还是被其他线程占用 那就睡一会, 返回值判断是否这次线程的唤醒是被中断唤醒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;finally &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if(failed)&#123;             &#x2F;&#x2F; 8. 在整个获取中出错(比如线程中断&#x2F;超时)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            cancelAcquire(node);  &#x2F;&#x2F; 9. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>独占锁模式获取成功以后设置头结点然后返回中断状态，结束流程。而共享锁模式获取成功以后，调用了setHeadAndPropagate方法，从方法名就可以看出除了设置新的头结点以外还有一个传递动作，一起看下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;两个入参，一个是当前成功获取共享锁的节点，一个就是tryAcquireShared方法的返回值，注意上面说的，它可能大于0也可能等于0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node h &#x3D; head; &#x2F;&#x2F;记录当前头节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置新的头节点，即把当前获取到锁的节点设置为头节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注：这里是获取到锁之后的操作，不需要并发控制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    setHead(node);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这里意思有两种情况是需要执行唤醒操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.propagate &gt; 0 表示调用方指明了后继节点有可能需要被唤醒，因为此方法是获取读锁过程调用，那么后面节点很可能也要获取读锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.头节点后面的节点需要被唤醒（waitStatus&lt;0），不论是老的头结点还是新的头结点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Node s &#x3D; node.next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果当前节点的后继节点是共享类型获取没有后继节点，则进行唤醒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;这里可以理解为除非明确指明不需要唤醒（后继等待节点是独占类型），否则都要唤醒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;这里的初衷是   后一个节点正好是共享节点，就唤醒，实现共享，独占有锁释放时候唤醒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;后面详细说</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            doReleaseShared();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void setHead(Node node) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    head &#x3D; node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    node.thread &#x3D; null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    node.prev &#x3D; null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：这个唤醒操作在releaseShared()方法里也会调用。唤醒后面想获取锁的节点。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;唤醒操作由头结点开始，注意这里的头节点已经是上面新设置的头结点了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;其实就是唤醒上面新获取到共享锁的节点的后继节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Node h &#x3D; head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                int ws &#x3D; h.waitStatus;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;表示后继节点需要被唤醒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;这里需要控制并发，因为入口有setHeadAndPropagate跟releaseShared两个，避免两次unpark</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        continue;      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;执行唤醒操作      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;如果后继节点暂时不需要唤醒，则把当前节点状态设置为PROPAGATE确保以后可以传递下去</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    continue;                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果头结点没有发生变化，表示设置完成，退出循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果头结点发生变化，比如说其他线程获取到了锁，为了使自己的唤醒动作可以传递，必须进行重试</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (h &#x3D;&#x3D; head)                   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里分析一下共享锁是如何进行传递的</p><blockquote><h3 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       if (tryReleaseShared(arg)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           doReleaseShared();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           return true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>释放锁tryReleaseShared由子类Sync实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Thread current &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 清理firstReader缓存 或 readHolds里的重入计数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; assert firstReaderHoldCount &gt; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (firstReaderHoldCount &#x3D;&#x3D; 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            firstReader &#x3D; null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        else</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; current.getId())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            rh &#x3D; readHolds.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int count &#x3D; rh.count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (count &lt;&#x3D; 1) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 完全释放读锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            readHolds.remove();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (count &lt;&#x3D; 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                throw unmatchedUnlockException();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        --rh.count; &#x2F;&#x2F; 主要用于重入退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 循环在CAS更新状态值，主要是把读锁数量减 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int nextc &#x3D; c - SHARED_UNIT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 释放读锁对其他读线程没有任何影响，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 但可以允许等待的写线程继续，如果读锁、写锁都空闲。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return nextc &#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h3></blockquote><p>写锁的获取和ReentrantLock独占锁的锁获取过程几乎一样，除了tryAcquire（）方法，要考虑读锁的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            selfInterrupt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在以下情况，写锁获取失败：</p><p>（1） 写锁为0，读锁不为0   或者写锁不为0，且当前线程不是已获取独占锁的线程，锁获取失败。</p><p>（2）写锁数量已达到最大值，写锁获取失败。</p><p>（3）当前线程应该阻塞，或者设置同步状态state失败，获取锁失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Thread current &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            int w &#x3D; exclusiveCount(c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (c !&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 1.写锁为0，读锁不为0    或者写锁不为0，且当前线程不是已获取独占锁的线程，锁获取失败</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;2. 写锁数量已达到最大值，写锁获取失败</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Reentrant acquire</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                setState(c + acquires);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;3.当前线程应该阻塞，或者设置同步状态state失败，获取锁失败。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (writerShouldBlock() ||</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">    public final boolean release(int arg) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (tryRelease(arg)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Node h &#x3D; head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (!isHeldExclusively())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            int nextc &#x3D; getState() - releases;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            boolean free &#x3D; exclusiveCount(nextc) &#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (free)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            setState(nextc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return free;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3></blockquote><p>（1）首先说一下公平锁和非公平锁的区别，</p><p>公平锁：当线程发现已经有线程在排对获取锁了，那么它必须排队，除了一种情况就是，线程已经占有锁，此次是重入，不用排队。</p><p>非公平锁：只有一种情况需排队，其他情况不用排队就可以尝试获取锁： 如果当前全局处于读锁状态，且等待队列中第一个等待线程想获取写锁，那么当前线程能够获取到读锁的条件为：当前线程获取了写锁，还未释放；当前线程获取了读锁，这一次只是重入读锁而已；其它情况当前线程入队尾。</p><p>（2）获取读锁和释放读锁</p><p>获取锁的过程：</p><ol><li>当线程调用acquireShared()申请获取锁资源时，如果成功，则进入临界区。</li><li>当获取锁失败时，则创建一个共享类型的节点并进入一个FIFO等待队列，然后被挂起等待唤醒。</li><li>当队列中的等待线程被唤醒以后就重新尝试获取锁资源，如果成功则<strong>唤醒后面还在等待的共享节点并把该唤醒事件传递下去，即会依次唤醒在该节点后面的所有共享节点</strong>，然后进入临界区，否则继续挂起等待。</li></ol><p>释放锁过程：</p><ol><li>当线程调用releaseShared()进行锁资源释放时，如果释放成功，则唤醒队列中等待的节点，如果有的话。</li></ol><p>（3）跟独占锁相比，共享锁的主要特征在于当一个在等待队列中的共享节点成功获取到锁以后（它获取到的是共享锁），既然是共享，那它必须要依次唤醒后面所有可以跟它一起共享当前锁资源的节点，毫无疑问，这些节点必须也是在等待共享锁（这是大前提，如果等待的是独占锁，那前面已经有一个共享节点获取锁了，它肯定是获取不到的）。当共享锁被释放的时候，可以用读写锁为例进行思考，当一个读锁被释放，此时不论是读锁还是写锁都是可以竞争资源的。</p><p>参考文章：</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库的乐观锁怎么实现的?</title>
      <link href="/2020/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
      <url>/2020/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>MySql最经常使用的乐观锁时进行版本控制，也就是在数据库表中增加一列，记为version，当我们将数据读出时，将版本号一并读出，当数据进行更新时，会对这个版本号进行加1，当我们提交数据时，会判断数据库表中当前的version列值和当时读出的version是否相同，若相同说明没有进行更新的操作，不然，则取消这次的操作。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些比较偏门的面试题</title>
      <link href="/2020/11/05/%E4%B8%80%E4%BA%9B%E6%AF%94%E8%BE%83%E5%81%8F%E9%97%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/11/05/%E4%B8%80%E4%BA%9B%E6%AF%94%E8%BE%83%E5%81%8F%E9%97%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>10.101.102.103是公网IP还是内网IP，如何区分公网内网？</p><p>//了解中间人攻击和跨域攻击吗?</p><p>//可以伪造证书吗？</p><p>// BBR 怎么快，怎么实现，和之前的有什么区别?</p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>说一下快排的最好和最坏的时间复杂度？稳定吗？</p><p>邻接表和邻接矩阵？</p><p>识别2的n次方</p><p>用int值表示ip如何做（刚好32位bit一对一映射），写个伪代码做transfer</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>模糊查询like语句该怎么写?<br>第1种：在Java代码中添加sql通配符。</p><p>一个线程在10：00：00（十点0分0秒）访问数据库进行查询操作，10：00：10（10点0分十秒）返回，但是另一个线程在10：00：01对数据库同一个元素进行了修改，问返回的结果是修改前的还是修改后的</p><p><a href="#">复制代码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string wildcardname &#x3D; “%smi%”;&#96;&#96;list names &#x3D; mapper.selectlike(wildcardname);&#96; &#96; &#96;&#96;select * from foo where bar like #&#123;value&#125;</span><br></pre></td></tr></table></figure><p>第2种：在sql语句中拼接通配符，会引起sql注入</p><p><a href="#">复制代码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string wildcardname &#x3D; “smi”;&#96;&#96;list names &#x3D; mapper.selectlike(wildcardname);&#96; &#96;   &#96;&#96;select * from foo where bar like &#96;&#96;&quot;%&quot;&#96;&#96;#&#123;value&#125;&#96;&#96;&quot;%&quot;</span><br></pre></td></tr></table></figure><p><strong>数据库中为什么不推荐使用外键约束</strong><br>电商<a href>项目</a>中数据库表不推荐外键关联，但是在被关联表中删除数据时会导致关联表中经常出现数据缺失的问题，但如果在删除数据时在业务层删除数据做关联查询来判断是否被关联使用，会导致业务层逻辑复杂，特别是被多个业务表关联，会导致多次关联查询操作，后面每次增加一个业务关联都得增加一次判断。<br>解决方案：<br>可以在关联表中增加一个被关联次数的字段，每次关联时都加1，每次取消关联都减一。</p><p>讲一下char和varchar的区别？优缺点？索引用char还是varchar好？</p><p>假如现在读写有10%的概率冲突，用什么隔离级别?</p><p><strong>场景设计：url存储数据库就算设置了索引也会很慢，应该怎么设计存储？</strong> </p><p>  我有了几种思路，想过切分，想过压缩，想过存md5，但我一个没说。。。最后他说要超时了，直接跟我说正解，我抱着反正要结束了的想法随便说了个切分和压缩的思路，然后面试官说你要是有思路一定要跟我说的啊，不然我不知道你有没有想法不知道怎么引导（对不起我真的交流能力巨差。。。<br>  然后他讲了几种方法，而且是层层优化的： </p><p>1.存md5（恨自己没胆子说出口 </p><p>2.md5也很长，只存前几个字符的话可能会冲突，所以可以同时存md5的前几个字符和原url，然后where md5 = ‘xxxx’ and url = ‘xxxxx’，让md5走索引。 </p><p>3.自己构建哈希映射</p><p>drop delete truncate 区别</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>redis的跳表要实现快速查找第k小的元素怎么做</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>linux 文件系统架构</p><p>inode 有什么信息</p><p>看tw状态的进程load average 是什么，怎么看，怎么分析</p><p>linux底层的零拷贝技术（<strong>经历4次 -》3次 -》2次拷贝的优化历程）</strong></p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p> tomcat如果有两个<a href>项目</a>，两个<a href>项目</a>里面如果有相同的class，那么tomcat是如何对其进行区别?</p><p>分布式系统如何实现数据一致性</p><h3 id="虚拟机？"><a href="#虚拟机？" class="headerlink" title="虚拟机？"></a>虚拟机？</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>单例模式，懒汉，饿汉，双重校验的优缺点</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>登录怎么做。判断用户是否登录。</p><p>高并发系统的限流如何实现</p><p>高并发秒杀系统的设计</p><p>负载均衡如何设计</p><p>怎么进行一个权限控制</p><p>linux字节码</p><p>linux代码对齐?</p><p>N个线程交替打印，怎么实现，写出来，跑一下<br>设计长短地址转换</p><p>汇编过程</p><p>tcp洪流知道吗</p><p>怎么设计一个日志系统</p><p>怎么提升系统的并发能力（从索引优化、读写分离、分库分表说到<a href="https://www.nowcoder.com/jump/super-jump/word?word=redis" target="_blank" rel="noopener">redis</a>主从集群、分布式锁、mq解耦异步削峰、ngnix、限流）面试官补充说还要考虑网路传输、<a href="https://www.nowcoder.com/jump/super-jump/word?word=前端" target="_blank" rel="noopener">前端</a>优化等等，</p><p>如果访问一个网页，发现超时了，是怎么去排查问题的</p><p>降级处理hystrix了解过么</p><p>CPU架构，控制器，寄存器，运算器，高速缓存？</p><p>NIO的原理，jdk中有哪些工具和类去实现，如何实现（selector和channel的用法）,真的好用吗？还可以用什么？（面试官应该是想问netty，因为没有实际用过，只能给他讲了netty的原理） </p><p> 那来说说AIO吧，和NIO什么区别（对异步的理解）,AIO在工程中如何实现的？（大概说了下ajax的回调函数），又问回调函数具体是怎么实现的（传递函数指针）。 </p><p> 然后借着异步IO想问消息队列，讲了一下几种模型和原理。（面试中没有用过没关系，只要你懂原理还是可以跟面试官讲，起码可以证明你是爱学习的）</p><p>讲讲Spring中怎么对初始化的bean做其他操作。（这里有三种方式，@PostConstruct注解方式，init-method的XML配置方式，InitializingBean接口方式） </p><p> 三种实现上有什么区别（还好看过点<a href>源码</a>，其实前两种是一个意思，都是通过反射的方式用aop思想实现，可以消除对spring的依赖；接口方式是直接调用afterPropertiesSet方法，效率更高点。spring加载bean时先判断接口方式，再执行配置注解方式）</p><p>问卷发给1w个人，都是20-30岁之间的，怎么最快的按年龄<a href>排序</a>？** </p><p>  觉得要用好题目给的关键信息，最后说不出来，还想过双轴快排，因为我面试前还在复习Arrays.sort()的<a href>源码</a>。。。，然后他说了实现，就是用一个大小为10的列表数组，遍历一次问卷就可以排好序了。其实我还是很迷惑，我以为他是要1w份全都严格<a href>排序</a>，就是先按年龄后按问卷内容。。。<br>4kw个不重复的数，max不超过8kw，找小于max之后的不存在在数组中的4个数，如果内存只有10m怎么找？举例：1，2，3，8，答案是：7，6，5，4** </p><p>  想了想分片，他说不对，最后答案是用位图。我直呼妙啊然后说你太有意思了 😂我真的全程就在卖傻你知道吗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[海量数据](https:&#x2F;&#x2F;www.nowcoder.com&#x2F;jump&#x2F;super-jump&#x2F;word?word&#x3D;海量数据)库解决方案 》（而我看的技术内幕），jvm的题是来自JVM设计[算法]</span><br></pre></td></tr></table></figure><p>RSA 具体说说?</p><p>DES 和 AES 区别?</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring剖析</title>
      <link href="/2020/11/05/spring%E5%89%96%E6%9E%90/"/>
      <url>/2020/11/05/spring%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringIOC%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="Spring IoC的初始化过程"></p><ul><li><p>如果要使用Spring实现控制反转，需要先在src/main/resources下创建一个名为spring.xml的XML配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 将Student交给spring容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.sjh.entity.Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"sjh"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"24"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>利用IoC获取对象（通过bean的id）：</p><p>ClassPathXmlApplicationContext获取了配置文件，通过配置文件对象的getBean方法获取一个Student的实例，由于在配置文件中已经注入了属性，此时student是有相关属性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIoC2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring.xml"</span>);</span><br><span class="line">    Student student = (Student) ac.getBean(<span class="string">"student"</span>);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2020/11/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/11/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。<br>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p><h3 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h3><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这<br>些参与者是否要真正执行事务。</p><ol><li><p>运行过程<br> 1.1 准备阶段<br> 协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p><p><img src="/2020/11/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201114200146983.png" alt="image-20201114200146983"></p></li></ol><p>1.2 提交阶段<br>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚<br>事务。<br>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进<br>行提交或者回滚。</p><p><img src="/2020/11/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201114200203810.png" alt="image-20201114200203810"></p><p>存在的问题<br>2.1 同步阻塞<br>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。<br>2.2 单点问题<br>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等<br>待，无法完成其它操作。</p><p>  2.3 数据不一致<br>  在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消<br>  息，也就是说只有部分参与者提交了事务，使得系统数据不一致。<br>  2.4 太过保守<br>  任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(如果任一参与者(Cohort)节点在第一阶段返回的响应消息为&quot;No&quot;，或者协调者(Coordinator)节点在第一阶段的询问超时之前无法获取所有参与者(Cohort)节点的响应消息时：)</span><br></pre></td></tr></table></figure><h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>三阶段提交（Three-phase commit），是二阶段提交（2PC）的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点。</p><blockquote><ol><li><code>引入超时机制</code>。同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个<code>准备阶段</code>。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，3PC把2PC的<code>准备阶段再次一分为二</code>，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</li></ol></blockquote><p><img src="https://user-gold-cdn.xitu.io/2020/6/9/17298d963cef2191?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p><strong>CanCommit</strong>：协调者向所有参与者发送CanCommit命令，询问是否可以执行事务提交操作。如果全部响应YES则进入下一个阶段。</p><p><strong>PreCommit</strong>：<code>协调者</code>向所有<code>参与者</code>发送<code>PreCommit</code>命令，询问是否可以进行事务的预提交操作，参与者接收到PreCommit请求后，如参与者成功的执行了事务操作，则返回<code>Yes</code>响应，进入最终commit阶段。一旦参与者中有向协调者发送了<code>No</code>响应，协调者向所有参与者发送<code>abort</code>请求，参与者接受abort命令执行事务的中断。</p><p><strong>DoCommit</strong>： 在前两个阶段中所有参与者的响应反馈均是<code>YES</code>后，协调者向参与者发送<code>DoCommit</code>命令正式提交事务，如协调者没有接收到参与者发送的ACK响应，会向所有参与者发送<code>abort</code>请求命令，执行事务的中断。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><blockquote><p>同时在协调者和参与者中都引入超时机制。 改善同步阻塞 改善单点故障</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2020/5/23/1723f9467bcffd7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h3><p>Try</p><ul><li>做业务检查及资源预留（比如冻结库存，而不是直接减库存）。</li></ul><p>Confirm</p><ul><li>确认提交，在Try阶段所有事务参与者执行成功之后开始执行Confirm，通常情况下，TCC默认Confirm是不会出错的，认为只要Try成功，则Confirm一定成功，若Confirm真的出错了，需要采用重试机制或者人工干预。</li></ul><p>Cancel</p><ul><li>执行回滚，在Try阶段有事务参与者执行失败则开始执行Cancel，通常情况下，TCC默认Cancel是不会出错的，认为只要Try成功，则Cancel一定成功，若Cancel真的出错了，需要采用重试机制或者人工干预。</li></ul><h3 id="基于消息中间件的最终一致性事务方案"><a href="#基于消息中间件的最终一致性事务方案" class="headerlink" title="基于消息中间件的最终一致性事务方案"></a>基于消息中间件的最终一致性事务方案</h3><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并<br>且使用了消息队列来保证最终一致性。</p><ol><li><p>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一<br> 定会被写入本地消息表中。</p></li><li><p>之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转<br> 发。</p></li><li><p>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</p><p><img src="/2020/11/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201114202427598.png" alt="image-20201114202427598"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT认证</title>
      <link href="/2020/11/05/JWT%E8%AE%A4%E8%AF%81/"/>
      <url>/2020/11/05/JWT%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JWT-身份认证优缺点分析以及常见问题解决方案"><a href="#JWT-身份认证优缺点分析以及常见问题解决方案" class="headerlink" title="JWT 身份认证优缺点分析以及常见问题解决方案"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=jwt-身份认证优缺点分析以及常见问题解决方案" target="_blank" rel="noopener">JWT 身份认证优缺点分析以及常见问题解决方案</a></h1><p>之前分享了一个使用 Spring Security 实现 JWT 身份认证的 Demo，文章地址：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485622&idx=1&sn=e9750ed63c47457ba1896db8dfceac6a&chksm=cea2477df9d5ce6b7af20e582c6c60b7408a6459b05b849394c45f04664d1651510bdee029f7&token=684071313&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">适合初学者入门 Spring Security With JWT 的 Demo</a>。 Demo 非常简单，没有介绍到 JWT 存在的一些问题。所以，单独抽了一篇文章出来介绍。为了完成这篇文章，我查阅了很多资料和文献，我觉得应该对大家有帮助。</p><p>相关阅读：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485626&idx=1&sn=3247aa9000693dd692de8a04ccffeec1&chksm=cea24771f9d5ce675ea0203633a95b68bfe412dc6a9d05f22d221161147b76161d1b470d54b3&token=684071313&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">《一问带你区分清楚Authentication,Authorization以及Cookie、Session、Token》</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485622&idx=1&sn=e9750ed63c47457ba1896db8dfceac6a&chksm=cea2477df9d5ce6b7af20e582c6c60b7408a6459b05b849394c45f04664d1651510bdee029f7&token=684071313&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">适合初学者入门 Spring Security With JWT 的 Demo</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485640&idx=1&sn=0ff147808318d53b371f16bb730c96ef&chksm=cea24703f9d5ce156ba67662f6f3f482330e8e6ebd9d44c61bf623083e9b941d8a180db6b0ea&token=1533246333&lang=zh_CN#rd" target="_blank" rel="noopener">Spring Boot 使用 JWT 进行身份和权限验证</a></li></ul><h2 id="Token-认证的优势"><a href="#Token-认证的优势" class="headerlink" title="Token 认证的优势"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=token-认证的优势" target="_blank" rel="noopener">Token 认证的优势</a></h2><p>相比于 Session 认证的方式来说，使用 token 进行身份认证主要有下面三个优势：</p><h3 id="1-无状态"><a href="#1-无状态" class="headerlink" title="1.无状态"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=_1无状态" target="_blank" rel="noopener">1.无状态</a></h3><p>token 自身包含了身份验证所需要的所有信息，使得我们的服务器不需要存储 Session 信息，这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。但是，也正是由于 token 的无状态，也导致了它最大的缺点：当后端在token 有效期内废弃一个 token 或者更改它的权限的话，不会立即生效，一般需要等到有效期过后才可以。另外，当用户 Logout 的话，token 也还有效。除非，我们在后端增加额外的处理逻辑。</p><h3 id="2-有效避免了CSRF-攻击"><a href="#2-有效避免了CSRF-攻击" class="headerlink" title="2.有效避免了CSRF 攻击"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=_2有效避免了csrf-攻击" target="_blank" rel="noopener">2.有效避免了CSRF 攻击</a></h3><p><strong>CSRF（Cross Site Request Forgery）</strong>一般被翻译为 <strong>跨站请求伪造</strong>，属于网络攻击领域范围。相比于 SQL 脚本注入、XSS等等安全攻击方式，CSRF 的知名度并没有它们高。但是,它的确是每个系统都要考虑的安全隐患，就连技术帝国 Google 的 Gmail 在早些年也被曝出过存在 CSRF 漏洞，这给 Gmail 的用户造成了很大的损失。</p><p>那么究竟什么是 <strong>跨站请求伪造</strong> 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子：</p><p>小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">src</span>=<span class="string">http://www.mybank.com/Transfer?bankId</span>=<span class="string">11&amp;money</span>=<span class="string">10000</span>&gt;</span>科学理财，年盈利率过万<span class="tag">&lt;/&gt;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>导致这个问题很大的原因就是： Session 认证中 Cookie 中的 session_id 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。</p><p><strong>那为什么 token 不会存在这种问题呢？</strong></p><p>我是这样理解的：一般情况下我们使用 JWT 的话，在我们登录成功获得 token 之后，一般会选择存放在 local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 token 的，所以这个请求将是非法的。</p><p>但是这样会存在 XSS 攻击中被盗的风险，为了避免 XSS 攻击，你可以选择将 token 存储在标记为<code>httpOnly</code> 的cookie 中。但是，这样又导致了你必须自己提供CSRF保护。</p><p>具体采用上面哪两种方式存储 token 呢，大部分情况下存放在 local storage 下都是最好的选择，某些情况下可能需要存放在标记为<code>httpOnly</code> 的cookie 中会更好。</p><h3 id="3-适合移动端应用"><a href="#3-适合移动端应用" class="headerlink" title="3.适合移动端应用"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=_3适合移动端应用" target="_blank" rel="noopener">3.适合移动端应用</a></h3><p>使用 Session 进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到 Cookie（需要 Cookie 保存 SessionId），所以不适合移动端。</p><p>但是，使用 token 进行身份认证就不会存在这种问题，因为只要 token 可以被客户端存储就能够使用，而且 token 还可以跨语言使用。</p><h3 id="4-单点登录友好"><a href="#4-单点登录友好" class="headerlink" title="4.单点登录友好"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=_4单点登录友好" target="_blank" rel="noopener">4.单点登录友好</a></h3><p>使用 Session 进行身份认证的话，实现单点登录，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 token 进行认证的话， token 被保存在客户端，不会存在这些问题。</p><h2 id="Token-认证常见问题以及解决办法"><a href="#Token-认证常见问题以及解决办法" class="headerlink" title="Token 认证常见问题以及解决办法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=token-认证常见问题以及解决办法" target="_blank" rel="noopener">Token 认证常见问题以及解决办法</a></h2><h3 id="1-注销登录等场景下-token-还有效"><a href="#1-注销登录等场景下-token-还有效" class="headerlink" title="1.注销登录等场景下 token 还有效"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=_1注销登录等场景下-token-还有效" target="_blank" rel="noopener">1.注销登录等场景下 token 还有效</a></h3><p>与之类似的具体相关场景有：</p><ol><li>退出登录;</li><li>修改密码;</li><li>服务端修改了某个用户具有的权限或者角色；</li><li>用户的帐户被删除/暂停。</li><li>用户由管理员注销；</li></ol><p>这个问题不存在于 Session 认证方式中，因为在 Session 认证方式中，遇到这种情况的话服务端删除对应的 Session 记录即可。但是，使用 token 认证的方式就不好解决了。我们也说过了，token 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的。那么，我们如何解决这个问题呢？查阅了很多资料，总结了下面几种方案：</p><ul><li><strong>将 token 存入内存数据库</strong>：将 token 存入 DB 中，redis 内存数据库在这里是是不错的选择。如果需要让某个 token 失效就直接从 redis 中删除这个 token 即可。但是，这样会导致每次使用 token 发送请求都要先从 DB 中查询 token 是否存在的步骤，而且违背了 JWT 的无状态原则。</li><li><strong>黑名单机制</strong>：和上面的方式类似，使用内存数据库比如 redis 维护一个黑名单，如果想让某个 token 失效的话就直接将这个 token 加入到 <strong>黑名单</strong> 即可。然后，每次使用 token 进行请求的话都会先判断这个 token 是否存在于黑名单中。</li><li><strong>修改密钥 (Secret)</strong> : 我们为每个用户都创建一个专属密钥，如果我们想让某个 token 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大，比如：1⃣️如果服务是分布式的，则每次发出新的 token 时都必须在多台机器同步密钥。为此，你需要将必须将机密存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。2⃣️如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的。</li><li><strong>保持令牌的有效期限短并经常轮换</strong> ：很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。</li></ul><p>对于修改密码后 token 还有效问题的解决还是比较容易的，说一种我觉得比较好的方式：<strong>使用用户的密码的哈希值对 token 进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。</strong></p><h3 id="2-token-的续签问题"><a href="#2-token-的续签问题" class="headerlink" title="2.token 的续签问题"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=_2token-的续签问题" target="_blank" rel="noopener">2.token 的续签问题</a></h3><p>token 有效期一般都建议设置的不太长，那么 token 过期后如何认证，如何实现动态刷新 token，避免用户经常需要重新登录？</p><p>我们先来看看在 Session 认证中一般的做法：<strong>假如 session 的有效期30分钟，如果 30 分钟内用户有访问，就把 session 有效期被延长30分钟。</strong></p><ol><li><strong>类似于 Session 认证中的做法</strong>：这种方案满足于大部分场景。假设服务端给的 token 有效期设置为30分钟，服务端每次进行校验时，如果发现 token 的有效期马上快过期了，服务端就重新生成 token 给客户端。客户端每次请求都检查新旧token，如果不一致，则更新本地的token。这种做法的问题是仅仅在快过期的时候请求才会更新 token ,对客户端不是很友好。</li><li><strong>每次请求都返回新 token</strong> :这种方案的的思路很简单，但是，很明显，开销会比较大。</li><li><strong>token 有效期设置到半夜</strong> ：这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</li><li><strong>用户登录返回两个 token</strong> ：第一个是 acessToken ，它的过期时间 token 本身的过期时间比如半个小时，另外一个是 refreshToken 它的过期时间更长一点比如为1天。客户端登录后，将 accessToken和refreshToken 保存在本地，每次访问将 accessToken 传给服务端。服务端校验 accessToken 的有效性，如果过期的话，就将 refreshToken 传给服务端。如果有效，服务端就生成新的 accessToken 给客户端。否则，客户端就重新登录即可。该方案的不足是：1⃣️需要客户端来配合；2⃣️用户注销的时候需要同时保证两个 token 都无效；3⃣️重新请求获取 token 的过程中会有短暂 token 不可用的情况（可以通过在客户端设置定时器，当accessToken 快过期的时候，提前去通过 refreshToken 获取新的accessToken）。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=总结" target="_blank" rel="noopener">总结</a></h2><p>JWT 最适合的场景是不需要服务端保存用户状态的场景，比如如果考虑到 token 注销和 token 续签的场景话，没有特别好的解决方案，大部分解决方案都给 token 加上了状态，这就有点类似 Session 认证了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两阶段提交</title>
      <link href="/2020/11/04/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
      <url>/2020/11/04/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><h3 id="redo-log日志模块"><a href="#redo-log日志模块" class="headerlink" title="redo log日志模块"></a>redo log日志模块</h3><p>redo log是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败（media failure）时，redo log文件就能派上用场，如数据库掉电，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。</p><p>在一条更新语句进行执行的时候，InnoDB引擎会把更新记录写到redo log日志中，然后更新内存，此时算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将redo log中的内容更新到磁盘中，这里涉及到<code>WAL</code>即<code>Write Ahead logging</code>技术，他的关键点是先写日志，再写磁盘。</p><p>有了redo log日志，那么在数据库进行异常重启的时候，可以根据redo log日志进行恢复，也就达到了<code>crash-safe</code>。</p><p>redo log日志的大小是固定的，即记录满了以后就从头循环写。</p><p><img src="https://www.linuxidc.com/upload/2018_11/181121105137361.jpg" alt="img"></p><p>图片来自极客时间，该图展示了一组4个文件的redo log日志，checkpoint之前表示擦除完了的，即可以进行写的，擦除之前会更新到磁盘中，write pos是指写的位置，当write pos和checkpoint相遇的时候表明redo log已经满了，这个时候数据库停止进行数据库更新语句的执行，转而进行redo log日志同步到磁盘中。</p><p>（bin log日志用于数据恢复和主从复制）</p><p><strong>为了保证事务的持久性</strong>，mysql的InnoDB采用了WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。<br> 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p><p><img src="https://img2020.cnblogs.com/blog/1331592/202008/1331592-20200817182643325-434826336.png" alt="img"></p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p>binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠binlog是没有<code>crash-safe</code>能力的</p><p>MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。<br> <strong>为什么会有两份日志呢？</strong>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p><p>这两种日志有以下三点不同。<br> 1.redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。<br> 2.redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。<br> 3.redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><p><strong>为了保证两份日志的逻辑一致性</strong>mysql采用了两阶段提交。<br> 下面是一个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p><p><img src="https:////upload-images.jianshu.io/upload_images/8561045-47d41f9158ff9570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1142/format/webp" alt="img"></p><p>2e5bff4910ec189fe1ee6e2ecc7b4bbe.png</p><p> 最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。<br><strong>为什么必须有“两阶段提交”呢？</strong><br> 如果不使用两阶段提交，假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？<br> 1.<strong>先写 redo log 后写 binlog。</strong>假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。<br> 但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。<br> 然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。<br> 2.<strong>先写 binlog 后写 redo log。</strong>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。<br> 可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。<br><strong>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka副本同步</title>
      <link href="/2020/11/04/kafka%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5/"/>
      <url>/2020/11/04/kafka%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Kafka副本"><a href="#Kafka副本" class="headerlink" title="Kafka副本"></a>Kafka副本</h2><p>Kafka中主题的每个Partition有一个预写式日志文件，每个Partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到Partition中，Partition中的每个消息都有一个连续的序列号叫做offset,<br>确定它在分区日志中唯一的位置。<br><img src="https://img-blog.csdn.net/20160620014300167" alt="这里写图片描述"><br>Kafka每个topic的partition有N个副本，其中N是topic的复制因子。Kafka通过多副本机制实现故障自动转移，当Kafka集群中一个Broker失效情况下仍然保证服务可用。在Kafka中发生复制时确保partition的预写式日志有序地写到其他节点上。N个replicas中。其中一个replica为leader，其他都为follower，leader处理partition的所有读写请求，与此同时，follower会被动定期地去复制leader上的数据。<br><img src="https://img-blog.csdn.net/20160620014329074" alt="这里写图片描述"><br>Kafka必须提供数据复制算法保证,如果leader发生故障或挂掉，一个新leader被选举并接收客户端的消息成功写入。Kafka确保从同步副本列表中选举一个副本为leader,或者换句话说,follower追赶leader数据。leader负责维护和跟踪ISR中所有follower滞后状态。当生产者发送一条消息到Broker,leader写入消息并复制到所有follower。消息提交之后才被成功复制到所有的同步副本。消息复制延迟受最慢的follower限制,重要的是快速检测慢副本,如果follower”落后”太多或者失效,leader将会把它从replicas从ISR移除。</p><h2 id="partition的follower追上leader含义"><a href="#partition的follower追上leader含义" class="headerlink" title="partition的follower追上leader含义"></a>partition的follower追上leader含义</h2><p>Kafka中每个partition的follower没有“赶上”leader的日志可能会从同步副本列表中移除。下面用一个例子解释一下“追赶”到底是什么意思。请看一个例子：主题名称为foo 1 partition 3 replicas。假如partition的replication分布在Brokers 1、2和3上，并且Broker 3消息已经成功提交。同步副本列表中1为leader、2和3为follower。假设replica.lag.max.messages设置为4，表明只要follower落后leader不超过3，就不会从同步副本列表中移除。replica.lag.time.max设置为500 ms，表明只要follower向leader发送请求时间间隔不超过500 ms，就不会被标记为死亡,也不会从同步副本列中移除。<br><img src="https://img-blog.csdn.net/20160620014619456" alt="这里写图片描述"><br>下面看看，生产者发送下一条消息写入leader，与此同时follower Broker 3 GC暂停，如下图所示:<br><img src="https://img-blog.csdn.net/20160620014641722" alt="这里写图片描述"><br>直到follower Broker 3从同步副本列表中移除或追赶上leader log end offset，最新的消息才会认为提交。注意,因为follower Broker 3小于replica.lag.max.messages= 4落后于leader Broker 1，Kafka不会从同步副本列表中移除。在这种情况下,这意味着follower Broker 3需要迎头追赶上知道offset = 6,如果是,那么它完全“赶上” leader Broker 1 log end offset。让我们假设代理3出来的GC暂停在100 ms和追赶上领袖的日志结束偏移量。在这种状态下，下面partition日志会看起来像这样<br><img src="https://img-blog.csdn.net/20160620014718389" alt="这里写图片描述"></p><h2 id="是什么原因导致分区的副本与leader不同步"><a href="#是什么原因导致分区的副本与leader不同步" class="headerlink" title="是什么原因导致分区的副本与leader不同步"></a>是什么原因导致分区的副本与leader不同步</h2><h3 id="一个副本可以不同步Leader有如下几个原因"><a href="#一个副本可以不同步Leader有如下几个原因" class="headerlink" title="一个副本可以不同步Leader有如下几个原因"></a>一个副本可以不同步Leader有如下几个原因</h3><ul><li>慢副本：在一定周期时间内follower不能追赶上leader。最常见的原因之一是I / O瓶颈导致follower追加复制消息速度慢于从leader拉取速度。</li><li>卡住副本：在一定周期时间内follower停止从leader拉取请求。follower replica卡住了是由于GC暂停或follower失效或死亡。</li><li>新启动副本：当用户给主题增加副本因子时，新的follower不在同步副本列表中，直到他们完全赶上了leader日志。</li></ul><p>一个partition的follower落后于leader足够多时，被认为不在同步副本列表或处于滞后状态。在Kafka-0.8.2.x中,副本滞后判断依据是副本落后于leader最大消息数量(replica.lag.max.messages)或replicas响应partition leader的最长等待时间(replica.lag.time.max.ms)。前者是用来检测缓慢的副本,而后者是用来检测失效或死亡的副本</p><h2 id="如何确定副本是滞后的"><a href="#如何确定副本是滞后的" class="headerlink" title="如何确定副本是滞后的"></a>如何确定副本是滞后的</h2><p>这个模型检测不同步卡住副本列表工作下所有情况都适用。它追踪follower replica时间内没有向leader发送拉取请求,表明它已经死了。另一方面,如果均匀流量模式情况下，为一个主题或多个主题设置这些参数检测模型不同步慢副本列表消息的数量会工作很好,但我们发现生产环境中它不扩展到所有主题各种工作负载。</p><p>接着上面的例子,如果主题foo获取数据速率2 msg/sec，leader单次批量接收一般不会超过3条消息,然后你知道主题参数replica.lag.max.messages设置为4。为什么?因为follower replica从leader复制消息前，已经有大批量消息写leader，follower replica落后于leader不超过3条消息 。另一方面，如果主题foo的follower replica初始落后于leader持续超过3消息,leader会从同步副本列表中移除慢副本，避免消息写延迟增加。</p><p>这本质上是replica.lag.max.messages的目标。能够检测follower与leader不一致且从同步副本列表移除。然而,主题在流量高峰期发送了一批消息(4条消息),等于replica.lag.max.messages = 4配置值。在那一瞬间,2个follower replica将被认为是”out-of-sync”并且leader会从同步副本列表中移除。<br><img src="https://img-blog.csdn.net/20160620014916999" alt="这里写图片描述"><br>2个follower replica都是活着,下次拉取请求他们会赶上leader log end offset并重新加入同步副本列表。重复相同的过程，如果生产者继续发送相对一批较大消息到leader。这种情况演示了当follower replica频繁在从同步副本列表移除和重新加入同步副本列表之间来回切换时，不必要触发虚假警报。<br><img src="https://img-blog.csdn.net/20160620014944061" alt="这里写图片描述"><br>参数replica.lag.max.messages指向核心问题。它的配置值根据队列流量大小和集群一般负载情况做出判断并设置一个合适值!</p><h2 id="副本配置规则"><a href="#副本配置规则" class="headerlink" title="副本配置规则"></a>副本配置规则</h2><p>笔者认为真正重要的事情是检测卡或慢副本,这段时间follower replica是“out-of-sync”落后于leader。在服务端现在只有一个参数需要配置replica.lag.time.max.ms。这个参数解释replicas响应partition leader的最长等待时间。检测卡住或失败副本的探测——如果一个replica失败导致发送拉取请求时间间隔超过replica.lag.time.max.ms。Kafka会认为此replica已经死亡会从同步副本列表从移除。检测慢副本机制发生了变化——如果一个replica开始落后leader超过replica.lag.time.max.ms。Kafka会认为太缓慢并且会从同步副本列表中移除。除非replica请求leader时间间隔大于replica.lag.time.max.ms，因此即使leader使流量激增和大批量写消息。Kafka也不会从同步副本列表从移除该副本。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka的分区再平衡</title>
      <link href="/2020/11/04/kafka%E7%9A%84%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1/"/>
      <url>/2020/11/04/kafka%E7%9A%84%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>所谓的再平衡，指的是在kafka consumer所订阅的topic发生变化时发生的一种分区重分配机制。一般有三种情况会触发再平衡：</p><ul><li>consumer group中的新增或删除某个consumer，导致其所消费的分区需要分配到组内其他的consumer上；</li><li>consumer订阅的topic发生变化，比如订阅的topic采用的是正则表达式的形式，如<code>test-*</code>此时如果有一个新建了一个topic <code>test-user</code>，那么这个topic的所有分区也是会自动分配给当前的consumer的，此时就会发生再平衡；</li><li>consumer所订阅的topic发生了新增分区的行为，那么新增的分区就会分配给当前的consumer，此时就会触发再平衡。</li></ul><p>​    Kafka提供的再平衡策略主要有三种：<code>Round Robin</code>，<code>Range</code>和<code>Sticky</code>，默认使用的是<code>Range</code>。这三种分配策略的主要区别在于：</p><ul><li><p><code>Round Robin</code>：会采用轮询的方式将当前所有的分区依次分配给所有的consumer；</p></li><li><p><code>Range</code>：首先会计算每个consumer可以消费的分区个数，然后按照顺序将指定个数范围的分区分配给各个consumer；</p></li><li><pre><code>Sticky</code></pre><p>：这种分区策略是最新版本中新增的一种策略，其主要实现了两个目的：</p><ul><li>将现有的分区尽可能均衡的分配给各个consumer，存在此目的的原因在于<code>Round Robin</code>和<code>Range</code>分配策略实际上都会导致某几个consumer承载过多的分区，从而导致消费压力不均衡；</li><li>如果发生再平衡，那么重新分配之后在前一点的基础上会尽力保证当前未宕机的consumer所消费的分区不会被分配给其他的consumer上；</li></ul></li></ul><p>​    本文主要会通过几个示例来对上面讲解的三种分区重分配策略的基本实现原理进行讲解。</p><h3 id="1-Round-Robin"><a href="#1-Round-Robin" class="headerlink" title="1. Round Robin"></a>1. Round Robin</h3><p>​    关于<code>Roudn Robin</code>重分配策略，其主要采用的是一种轮询的方式分配所有的分区，该策略主要实现的步骤如下。这里我们首先假设有三个topic：t0、t1和t2，这三个topic拥有的分区数分别为1、2和3，那么总共有六个分区，这六个分区分别为：t0-0、t1-0、t1-1、t2-0、t2-1和t2-2。这里假设我们有三个consumer：C0、C1和C2，它们订阅情况为：C0订阅t0，C1订阅t0和t1，C2订阅t0、t1和t2。那么这些分区的分配步骤如下：</p><ul><li><p>首先将所有的partition和consumer按照字典序进行排序，所谓的字典序，就是按照其名称的字符串顺序，那么上面的六个分区和三个consumer排序之后分别为：</p><p><img src="https://oscimg.oschina.net/oscnet/bfde045a28d96bfe89e264d83ebcaabfe51.jpg" alt="img"></p></li><li><p>然后依次以按顺序轮询的方式将这六个分区分配给三个consumer，如果当前consumer没有订阅当前分区所在的topic，则轮询的判断下一个consumer：</p><ul><li>尝试将t0-0分配给C0，由于C0订阅了t0，因而可以分配成功；</li><li>尝试将t1-0分配给C1，由于C1订阅了t1，因而可以分配成功；</li><li>尝试将t1-1分配给C2，由于C2订阅了t1，因而可以分配成功；</li><li>尝试将t2-0分配给C0，由于C0没有订阅t2，因而会轮询下一个consumer；</li><li>尝试将t2-0分配给C1，由于C1没有订阅t2，因而会轮询下一个consumer；</li><li>尝试将t2-0分配给C2，由于C2订阅了t2，因而可以分配成功；</li><li>同理由于t2-1和t2-2所在的topic都没有被C0和C1所订阅，因而都不会分配成功，最终都会分配给C2。</li></ul></li><li><p>按照上述的步骤将所有的分区都分配完毕之后，最终分区的订阅情况如下：</p><p><img src="https://oscimg.oschina.net/oscnet/4e2eebc70c1cc07da63a01f4f684d725db7.jpg" alt="img"></p></li></ul><p>​    从上面的步骤分析可以看出，轮询的策略就是简单的将所有的partition和consumer按照字典序进行排序之后，然后依次将partition分配给各个consumer，如果当前的consumer没有订阅当前的partition，那么就会轮询下一个consumer，直至最终将所有的分区都分配完毕。但是从上面的分配结果可以看出，轮询的方式会导致每个consumer所承载的分区数量不一致，从而导致各个consumer压力不均一。</p><h3 id="2-Range"><a href="#2-Range" class="headerlink" title="2. Range"></a>2. Range</h3><p>​    所谓的<code>Range</code>重分配策略，就是首先会计算各个consumer将会承载的分区数量，然后将指定数量的分区分配给该consumer。这里我们假设有两个consumer：C0和C1，两个topic：t0和t1，这两个topic分别都有三个分区，那么总共的分区有六个：t0-0、t0-1、t0-2、t1-0、t1-1和t1-2。那么<code>Range</code>分配策略将会按照如下步骤进行分区的分配：</p><ul><li><p>需要注意的是，<code>Range</code>策略是按照topic依次进行分配的，比如我们以t0进行讲解，其首先会获取t0的所有分区：t0-0、t0-1和t0-2，以及所有订阅了该topic的consumer：C0和C1，并且会将这些分区和consumer按照字典序进行排序；</p></li><li><p>然后按照平均分配的方式计算每个consumer会得到多少个分区，如果没有除尽，则会将多出来的分区依次计算到前面几个consumer。比如这里是三个分区和两个consumer，那么每个consumer至少会得到1个分区，而3除以2后还余1，那么就会将多余的部分依次算到前面几个consumer，也就是这里的1会分配给第一个consumer，总结来说，那么C0将会从第0个分区开始，分配2个分区，而C1将会从第2个分区开始，分配1个分区；</p></li><li><p>同理，按照上面的步骤依次进行后面的topic的分配。</p></li><li><p>最终上面六个分区的分配情况如下：</p><p><img src="https://oscimg.oschina.net/oscnet/3c02720944f3c60b0109eeeb42a729005a1.jpg" alt="img"></p></li></ul><p>​    可以看到，如果按照<code>Range</code>分区方式进行分配，其本质上是依次遍历每个topic，然后将这些topic的分区按照其所订阅的consumer数量进行平均的范围分配。这种方式从计算原理上就会导致排序在前面的consumer分配到更多的分区，从而导致各个consumer的压力不均衡。</p><h3 id="3-Sticky"><a href="#3-Sticky" class="headerlink" title="3. Sticky"></a>3. Sticky</h3><p>​    <code>Sticky</code>策略是新版本中新增的策略，顾名思义，这种策略会保证再分配时已经分配过的分区尽量保证其能够继续由当前正在消费的consumer继续消费，当然，前提是每个consumer所分配的分区数量都大致相同，这样能够保证每个consumer消费压力比较均衡。关于这种分配方式的分配策略，我们分两种情况进行讲解，即初始状态的分配和某个consumer宕机时的分配情况。</p><h4 id="3-1-初始分配"><a href="#3-1-初始分配" class="headerlink" title="3.1 初始分配"></a>3.1 初始分配</h4><p>​    初始状态分配的特点是，所有的分区都还未分配到任意一个consumer上。这里我们假设有三个consumer：C0、C1和C2，三个topic：t0、t1和t2，这三个topic分别有1、2和3个分区，那么总共的分区为：t0-0、t1-0、t1-1、t2-0、t2-1和t2-2。关于订阅情况，这里C0订阅了t0，C1订阅了t0和1，C2则订阅了t0、t1和t2。这里的分区分配规则如下：</p><ul><li><p>首先将所有的分区进行排序，排序方式为：首先按照当前分区所分配的consumer数量从低到高进行排序，如果consumer数量相同，则按照分区的字典序进行排序。这里六个分区由于所在的topic的订阅情况各不相同，因而其排序结果如下：</p><p><img src="https://oscimg.oschina.net/oscnet/73f396c655fefaced5135ab9b9e3071a472.jpg" alt="img"></p></li><li><p>然后将所有的consumer进行排序，其排序方式为：首先按照当前consumer已经分配的分区数量有小到大排序，如果两个consumer分配的分区数量相同，则会按照其名称的字典序进行排序。由于初始时，这三个consumer都没有分配任何分区，因而其排序结果即为其按照字典序进行排序的结果：</p><p><img src="https://oscimg.oschina.net/oscnet/2a0a58803b1119d6041b7879d3fa00e8deb.jpg" alt="img"></p></li><li><p>然后将各个分区依次遍历分配给各个consumer，首先需要注意的是，这里的遍历并不是C0分配完了再分配给C1，而是每次分配分区的时候都整个的对所有的consumer从头开始遍历分配，如果当前consumer没有订阅当前分区，则会遍历下一个consumer。然后需要注意的是，在整个分配的过程中，各个consumer所分配的分区数是动态变化的，而这种变化是会体现在各个consumer的排序上的，比如初始时C0是排在第一个的，此时如果分配了一个分区给C0，那么C0就会排到最后，因为其拥有的分区数是最多的。上面的六个分区整体的分配流程如下：</p><ul><li><p>首先将t2-0尝试分配给C0，由于C0没有订阅t2，因而分配不成功，继续轮询下一个consumer；</p></li><li><p>然后将t2-0尝试分配给C1，由于C1没有订阅t2，因而分配不成功，继续轮询下一个consumer；</p></li><li><p>接着将t2-0尝试分配给C2，由于C2订阅了t2，因而分配成功，此时由于C2分配的分区数发生变化，各个consumer变更后的排序结果为：</p><p><img src="https://oscimg.oschina.net/oscnet/2a0a58803b1119d6041b7879d3fa00e8deb.jpg" alt="img"></p></li><li><p>接下来的t2-1和t2-2，由于也只有C2订阅了t2，因而其最终还是会分配给C2，最终在t2-0、t2-1和t2-2分配完之后，各个consumer的排序以及其分区分配情况如下：</p><p><img src="https://oscimg.oschina.net/oscnet/010128b28d8b230cfb6c43903f6cf6ebf78.jpg" alt="img"></p></li><li><p>接着继续分配t1-0，首先尝试将其分配给C0，由于C0没有订阅t1，因而分配不成功，继续轮询下一个consumer；</p></li><li><p>然后尝试将t1-0分配给C1，由于C1订阅了t1，因而分配成功，此时各个consumer以及其分配的分区情况如下：</p><p><img src="https://oscimg.oschina.net/oscnet/6d8420689c9649ec4dfaa4c96fc68f1e3f3.jpg" alt="img"></p></li><li><p>同理，接下来会分配t1-1，虽然C1和C2都订阅了t1，但是由于C1排在C2前面，因而该分区会分配给C1，即：</p><p><img src="https://oscimg.oschina.net/oscnet/68f5c95c763932ccbbb1e214bbe4676918b.jpg" alt="img"></p></li><li><p>最后，尝试将t0-0分配给C0，由于C0订阅了t0，因而分配成功，最终的分配结果为：</p><p><img src="https://oscimg.oschina.net/oscnet/38a844fde826df22422a8ff3e09763cd4de.jpg" alt="img"></p></li></ul></li></ul><p>​    上面的分配过程中，需要始终注意的是，虽然示例中的consumer顺序始终没有变化，但这是由于各个分区分配之后正好每个consumer所分配的分区数量的排序结果与初始状态一致。这里读者也可以比较一下这种分配方式与前面讲解的<code>Round Robin</code>进行对比，可以很明显的发现，<code>Sticky</code>重分配策略分配得更加均匀一些。</p><h4 id="3-2-模拟consumer宕机"><a href="#3-2-模拟consumer宕机" class="headerlink" title="3.2 模拟consumer宕机"></a>3.2 模拟consumer宕机</h4><p>​    由于前一个示例中最终的分区分配方式模拟宕机的情形比较简单，因而我们使用另一种订阅策略。这里我们的示例的consumer有三个：C0、C1和C2，topic有四个：t0、t1、t2和t3，每个topic都有两个分区，那么总的分区有：t0-0、t0-1、t1-0、t1-1、t2-0、t2-1、t3-0和t3-1。这里的订阅情况为三个consumer订阅所有的主题，那么如果按照<code>Sticky</code>的分区分配策略，初始状态时，分配情况如下，读者可以按照前一示例讲解的方式进行推算：</p><p><img src="https://oscimg.oschina.net/oscnet/5d9dafd67da6a142d0ff5ab627744d23128.jpg" alt="img"></p><p>​    这里我们假设在消费的过程中，C1发生了宕机，此时就会发生再平衡，而根据<code>Sticky</code>策略，其再分配步骤如下：</p><ul><li><p>首先会将宕机之后未分配的分区进行排序，排序方式为：首先按照分区所拥有的consumer数量从低到高进行排序，如果consumer数量相同，则按照分区的字典序进行排序。这里需要注意的是，由于只有C1宕机，因而未分配的分区为：t0-1、t2-0和t3-1，排序之后的结果为：</p><p><img src="https://oscimg.oschina.net/oscnet/eded864b37d0f1ed850d5f48c5af8a8d026.jpg" alt="img"></p></li><li><p>然后将所有的consumer进行排序，排序方式为：首先将consumer按照其所拥有的consumer数量从小到大排序，如果数量相同，则按照consumer名称的字典序进行排序，排序结果如下：</p><p><img src="https://oscimg.oschina.net/oscnet/9bc178a76f9d1699a05084afdf13a46036f.jpg" alt="img"></p></li><li><p>接着依次遍历各个分区，将其分配给各个consumer，需要注意的是，在分配的过程中，consumer所分配的分区数量是在变化的，而这种变化是会反应在consumer的排序上的：</p><ul><li><p>首先尝试将t0-1分配给C2，由于C2订阅了t0，因而可以分配成功，此时consumer排序和分区分配情况如下，需要注意的是，虽然分配之后，C2和C0的分区数量相同，但是由于按照字典序，C0在C2前面，因而排序情况还是会发生变化：</p><p><img src="https://oscimg.oschina.net/oscnet/6ef5f794a592fc11f2a670f72220054dfbe.jpg" alt="img"></p></li><li><p>然后尝试将t2-0分配给C0，由于C0订阅了t2，因而分配可以成功，此时consumer排序和分区分配情况如下：</p><p><img src="https://oscimg.oschina.net/oscnet/c6051c8d5b1238118362136c20e492d5f6b.jpg" alt="img"></p></li><li><p>最后尝试分配t3-1给C2，由于C2订阅了t3，因而分配可以成功，此时consumer排序与分区分配情况如下：</p><p><img src="https://oscimg.oschina.net/oscnet/3e12c580fff3c763836125ce414f66e6f0f.jpg" alt="img"></p></li></ul></li></ul><p>​    在上面的分区分配过程中，我们可以看到，由于分区的不断分配，各个consumer所拥有的分区数量也在不断变化，因而其排序情况也在变化，但是最终可以看到，各个分区是均匀的分配到各个consumer的，并且还保证了当前consumer已经消费的分区是不会分配到其他的consumer上的。</p><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>​    本文首先对kafka的分区重分配策略进行了讲解，然后通过四个示例对各个策略重分配的过程进行了讲解。需要说明的是，本文所使用的示例正好是Kafka源码中所提供了三个分配策略类所演示的几个示例，只不过其并没有演示其分配的具体细节，而是只讲解了最终的结果。同样的，在网上搜索相关的博文，其也只是将分配的结果直接展示出来，而并没有演示具体的细节。本文则主要对这些示例的具体实现细节进行了一一讲解，以方便读者朋友能够更好的理解各个分区重分配策略</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka的集群选举、数据同步</title>
      <link href="/2020/11/04/kafka%E7%9A%84%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE%E3%80%81%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
      <url>/2020/11/04/kafka%E7%9A%84%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE%E3%80%81%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Broker选举"><a href="#Broker选举" class="headerlink" title="Broker选举"></a>Broker选举</h3><p>kafka的控制器选举很简单，kafka的每一个broker都有一个ID唯一标识符，在集群启动的时候会把id注册到zookeeper的/broker/ids/节点下作为临时子节点，节点的增加和删除其他子节点都会得到通知，第一个启动的broker会在zookeeper里创建一个临时节点/controll让自己成为控制器，其他后续节点启动的也会创建，当发现已经存在这个临时节点了那么会抛出异常，会意识到此时节点已经存在，那么后续的broker会在这个控制器节点创建watch事件，用来监听控制器状态，如果控制器的broker挂掉了，其他节点有机会成为控制器</p><h3 id="分区Leader选举"><a href="#分区Leader选举" class="headerlink" title="分区Leader选举"></a>分区Leader选举</h3><p>基本思路是按照AR集合中副本的顺序查找第一个存活的副本，并且这个副本在ISR集合中。一个分区的AR集合在分配的时候就被指定，并且只要不发生重分配的情况，集合内部副本的顺序是保持不变的，而分区的ISR集合中副本的顺序可能会改变。注意这里是根据AR的顺序而不是ISR的顺序进行选举的。这个说起来比较抽象，有兴趣的读者可以手动关闭/开启某个集群中的broker来观察一下具体的变化。</p><p>还有一些情况也会发生分区leader的选举，比如当分区进行重分配（reassign）的时候也需要执行leader的选举动作。这个思路比较简单：从重分配的AR列表中找到第一个存活的副本，且这个副本在目前的ISR列表中。</p><p>再比如当发生优先副本（preferred replica partition leader election）的选举时，直接将优先副本设置为leader即可，AR集合中的第一个副本即为优先副本。</p><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka怎么保证顺序消费</title>
      <link href="/2020/11/04/kafka%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9/"/>
      <url>/2020/11/04/kafka%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>如果Kafka要保证多个partition有序，不仅broker保存的数据要保持顺序，消费时也要按序消费。假设partition1堵了，为了有序，那partition2以及后续的分区也不能被消费，这种情况下，Kafka 就退化成了单一队列，毫无并发性可言，极大降低系统性能。因此Kafka使用多partition的概念，并且只保证单partition有序。这样不同partiiton之间不会干扰对方</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka消息堆积</title>
      <link href="/2020/11/04/kafka%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF/"/>
      <url>/2020/11/04/kafka%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何保证消费的幂等性(不重复消费)</title>
      <link href="/2020/11/04/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>/2020/11/04/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p><p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</p><p>举个栗子。<br>有这么个场景。数据 1/2/3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152/153/154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 offset=153的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1/2 的 offset 并没有提交，kafka 也就不知道你已经消费了 offset=153 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1/2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p><p><img src="https://segmentfault.com/img/bVbp58K?w=568&h=454" alt="clipboard.png"></p><p>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1/2 在数据库里插入了 2 次，那么数据就错啦。</p><p>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。</p><p>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</p><p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。<br>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</p><p>所以第二个问题来了，怎么保证消息队列消费的幂等性？<br>其实还是得结合业务来思考，我这里给几个思路：</p><p>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。<br>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。<br>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。<br>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</p><p><img src="https://segmentfault.com/img/bVbp58O?w=401&h=371" alt="clipboard.png"></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper在kafka中的作用</title>
      <link href="/2020/11/04/zookeeper%E5%9C%A8kafka%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2020/11/04/zookeeper%E5%9C%A8kafka%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Zookeeper-在-Kafka-中的作用"><a href="#Zookeeper-在-Kafka-中的作用" class="headerlink" title="Zookeeper 在 Kafka 中的作用"></a>Zookeeper 在 Kafka 中的作用</h2><h3 id="1、Broker注册"><a href="#1、Broker注册" class="headerlink" title="1、Broker注册"></a>1、Broker注册</h3><p><strong>Broker是分布式部署并且相互之间相互独立，但是需要有一个注册系统能够将整个集群中的Broker管理起来</strong>，此时就使用到了Zookeeper。在Zookeeper上会有一个专门<strong>用来进行Broker服务器列表记录</strong>的节点：</p><p>/brokers/ids</p><p>每个Broker在启动时，都会到Zookeeper上进行注册，即到/brokers/ids下创建属于自己的节点，如/brokers/ids/[0…N]。</p><p>Kafka使用了全局唯一的数字来指代每个Broker服务器，不同的Broker必须使用不同的Broker ID进行注册，创建完节点后，<strong>每个Broker就会将自己的IP地址和端口信息记录</strong>到该节点中去。其中，Broker创建的节点类型是临时节点，一旦Broker宕机，则对应的临时节点也会被自动删除。</p><p>kafka的元数据都存放在zk上面,由zk来管理</p><h3 id="2、Topic注册"><a href="#2、Topic注册" class="headerlink" title="2、Topic注册"></a>2、Topic注册</h3><p>在Kafka中，同一个<strong>Topic的消息会被分成多个分区</strong>并将其分布在多个Broker上，<strong>这些分区信息及与Broker的对应关系</strong>也都是由Zookeeper在维护，由专门的节点来记录，如：</p><p>/borkers/topics</p><p>Kafka中每个Topic都会以/brokers/topics/[topic]的形式被记录，如/brokers/topics/login和/brokers/topics/search等。Broker服务器启动后，会到对应Topic节点（/brokers/topics）上注册自己的Broker ID并写入针对该Topic的分区总数，如/brokers/topics/login/3-&gt;2，这个节点表示Broker ID为3的一个Broker服务器，对于”login”这个Topic的消息，提供了2个分区进行消息存储，同样，这个分区节点也是临时节点。</p><h3 id="3、生产者负载均衡"><a href="#3、生产者负载均衡" class="headerlink" title="3、生产者负载均衡"></a>3、生产者负载均衡</h3><p>由于同一个Topic消息会被分区并将其分布在多个Broker上，因此，<strong>生产者需要将消息合理地发送到这些分布式的Broker上</strong>，那么如何实现生产者的负载均衡，Kafka支持传统的四层负载均衡，也支持Zookeeper方式实现负载均衡。</p><p>(1) 四层负载均衡，根据生产者的IP地址和端口来为其确定一个相关联的Broker。通常，一个生产者只会对应单个Broker，然后该生产者产生的消息都发往该Broker。这种方式逻辑简单，每个生产者不需要同其他系统建立额外的TCP连接，只需要和Broker维护单个TCP连接即可。但是，其无法做到真正的负载均衡，因为实际系统中的每个生产者产生的消息量及每个Broker的消息存储量都是不一样的，如果有些生产者产生的消息远多于其他生产者的话，那么会导致不同的Broker接收到的消息总数差异巨大，同时，生产者也无法实时感知到Broker的新增和删除。</p><p>(2) 使用Zookeeper进行负载均衡，由于每个Broker启动时，都会完成Broker注册过程，生产者会通过该节点的变化来动态地感知到Broker服务器列表的变更，这样就可以实现动态的负载均衡机制。</p><h3 id="4、消费者负载均衡"><a href="#4、消费者负载均衡" class="headerlink" title="4、消费者负载均衡"></a>4、消费者负载均衡</h3><p>与生产者类似，Kafka中的消费者同样需要进行负载均衡来实现多个消费者合理地从对应的Broker服务器上接收消息，每个消费者分组包含若干消费者，<strong>每条消息都只会发送给分组中的一个消费者</strong>，不同的消费者分组消费自己特定的Topic下面的消息，互不干扰。</p><h3 id="5、分区-与-消费者-的关系"><a href="#5、分区-与-消费者-的关系" class="headerlink" title="5、分区 与 消费者 的关系"></a>5、分区 与 消费者 的关系</h3><p><strong>消费组 (Consumer Group)：</strong><br> consumer group 下有多个 Consumer（消费者）。<br> 对于每个消费者组 (Consumer Group)，Kafka都会为其分配一个全局唯一的Group ID，Group 内部的所有消费者共享该 ID。订阅的topic下的每个分区只能分配给某个 group 下的一个consumer(当然该分区还可以被分配给其他group)。<br> 同时，Kafka为每个消费者分配一个Consumer ID，通常采用”Hostname:UUID”形式表示。</p><p>在Kafka中，规定了<strong>每个消息分区 只能被同组的一个消费者进行消费</strong>，因此，需要在 Zookeeper 上记录 消息分区 与 Consumer 之间的关系，每个消费者一旦确定了对一个消息分区的消费权力，需要将其Consumer ID 写入到 Zookeeper 对应消息分区的临时节点上，例如：</p><p>/consumers/[group_id]/owners/[topic]/[broker_id-partition_id]</p><p>其中，[broker_id-partition_id]就是一个 消息分区 的标识，节点内容就是该 消息分区 上 消费者的Consumer ID。</p><h3 id="6、消息-消费进度Offset-记录"><a href="#6、消息-消费进度Offset-记录" class="headerlink" title="6、消息 消费进度Offset 记录"></a>6、消息 消费进度Offset 记录</h3><p>在消费者对指定消息分区进行消息消费的过程中，<strong>需要定时地将分区消息的消费进度Offset记录到Zookeeper上</strong>，以便在该消费者进行重启或者其他消费者重新接管该消息分区的消息消费后，能够从之前的进度开始继续进行消息消费。Offset在Zookeeper中由一个专门节点进行记录，其节点路径为:</p><p>/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]</p><p>节点内容就是Offset的值。</p><h3 id="7、消费者注册"><a href="#7、消费者注册" class="headerlink" title="7、消费者注册"></a>7、消费者注册</h3><p>消费者服务器在初始化启动时加入消费者分组的步骤如下</p><p>注册到消费者分组。每个消费者服务器启动时，都会到Zookeeper的指定节点下创建一个属于自己的消费者节点，例如/consumers/[group_id]/ids/[consumer_id]，完成节点创建后，消费者就会将自己订阅的Topic信息写入该临时节点。</p><p><strong>对 消费者分组 中的 消费者 的变化注册监听</strong>。每个 消费者 都需要关注所属 消费者分组 中其他消费者服务器的变化情况，即对/consumers/[group_id]/ids节点注册子节点变化的Watcher监听，一旦发现消费者新增或减少，就触发消费者的负载均衡。</p><p><strong>对Broker服务器变化注册监听</strong>。消费者需要对/broker/ids/[0-N]中的节点进行监听，如果发现Broker服务器列表发生变化，那么就根据具体情况来决定是否需要进行消费者负载均衡。</p><p><strong>进行消费者负载均衡</strong>。为了让同一个Topic下不同分区的消息尽量均衡地被多个 消费者 消费而进行 消费者 与 消息 分区分配的过程，通常，对于一个消费者分组，如果组内的消费者服务器发生变更或Broker服务器发生变更，会发出消费者负载均衡。</p><p>以下是kafka在zookeep中的详细存储结构图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/3149801-0d2ed2bd8b7bec25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka如何保证不丢失消息</title>
      <link href="/2020/11/04/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF/"/>
      <url>/2020/11/04/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="生产者丢失消息的情况"><a href="#生产者丢失消息的情况" class="headerlink" title="生产者丢失消息的情况"></a>生产者丢失消息的情况</h3><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p><p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是  Kafka 生产者(Producer) 使用  <code>send</code> 方法发送消息实际上是异步的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p><blockquote><p><strong>详细代码见我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486269&idx=2&sn=ec00417ad641dd8c3d145d74cafa09ce&chksm=cea244f6f9d5cde0c8eb233fcc4cf82e11acd06446719a7af55230649863a3ddd95f78d111de&token=1633957262&lang=zh_CN#rd" target="_blank" rel="noopener">Kafka系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列?</a></strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SendResult&lt;String, Object&gt; sendResult &#x3D; kafkaTemplate.send(topic, o).get();</span><br><span class="line">if (sendResult.getRecordMetadata() !&#x3D; null) &#123;</span><br><span class="line">  logger.info(&quot;生产者成功发送消息到&quot; + sendResult.getProducerRecord().topic() + &quot;-&gt; &quot; + sendRe</span><br><span class="line">              sult.getProducerRecord().value().toString());</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future &#x3D; kafkaTemplate.send(topic, o);</span><br><span class="line">        future.addCallback(result -&gt; logger.info(&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">                ex -&gt; logger.error(&quot;生产者发送消失败，原因：&#123;&#125;&quot;, ex.getMessage()));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p><p><strong>另外这里推荐为 Producer 的<code>retries</code>（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你3次一下子就重试完了</strong></p><h3 id="消费者丢失消息的情况"><a href="#消费者丢失消息的情况" class="headerlink" title="消费者丢失消息的情况"></a>消费者丢失消息的情况</h3><p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170e29d648e63e5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="kafka offset"></p><p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p><p><strong>解决办法也比较粗暴，我们手动关闭闭自动提交 offset，每次在真正消费完消息之后之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p><h3 id="Kafka-弄丢了消息"><a href="#Kafka-弄丢了消息" class="headerlink" title="Kafka 弄丢了消息"></a>Kafka 弄丢了消息</h3><p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p><p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p><h4 id="设置-acks-all"><a href="#设置-acks-all" class="headerlink" title="设置 acks = all"></a>设置 acks = all</h4><p>解决办法就是我们设置  <strong>acks = all</strong>。acks 是 Kafka 生产者(Producer)  很重要的一个参数。</p><p>acks 的默认值即为1，代表我们的消息被leader副本接收之后就算被成功发送。当我们配置 <strong>acks = all</strong> 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。</p><h4 id="设置-replication-factor-gt-3"><a href="#设置-replication-factor-gt-3" class="headerlink" title="设置 replication.factor &gt;= 3"></a>设置 replication.factor &gt;= 3</h4><p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;= 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p><h4 id="设置-min-insync-replicas-gt-1"><a href="#设置-min-insync-replicas-gt-1" class="headerlink" title="设置 min.insync.replicas &gt; 1"></a>设置 min.insync.replicas &gt; 1</h4><p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p><p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下加入两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor = min.insync.replicas + 1</strong>。</p><h4 id="设置-unclean-leader-election-enable-false"><a href="#设置-unclean-leader-election-enable-false" class="headerlink" title="设置 unclean.leader.election.enable = false"></a>设置 unclean.leader.election.enable = false</h4><blockquote><p><strong>Kafka 0.11.0.0版本开始 unclean.leader.election.enable 参数的默认值由原来的true 改为false</strong></p></blockquote><p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable = false</strong>  的话，当 leader 副本发生故障时就不会从  follower 副本中和 leader 同步程度达不到要求的副本中选择出  leader ，这样降低了消息丢失的可能性。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="Ack-有哪几种-生产中怎样选择"><a href="#Ack-有哪几种-生产中怎样选择" class="headerlink" title="Ack 有哪几种, 生产中怎样选择?"></a>Ack 有哪几种, 生产中怎样选择?</h4><p>ack=0/1/-1的不同情况：</p><ul><li><p>Ack = 0</p><p>producer不等待broker的ack，broker一接收到还没有写入磁盘就已经返回，当broker故障时有可能丢失数据；</p></li><li><p>Ack = 1</p><p>producer等待broker的ack，partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将会丢失数据；</p></li><li><p>Ack = -1</p><p>producer等待broker的ack，partition的leader和follower全部落盘成功后才返回ack，数据一般不会丢失，延迟时间长但是可靠性高。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka剖析</title>
      <link href="/2020/11/04/kafka%E5%89%96%E6%9E%90/"/>
      <url>/2020/11/04/kafka%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="kafka的架构"><a href="#kafka的架构" class="headerlink" title="kafka的架构"></a>kafka的架构</h3><p><img src="https://user-gold-cdn.xitu.io/2020/1/17/16fb2cd4f1223ab9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>Producer：</strong> 消息生产者，向 Kafka Broker 发消息的客户端。</p><p><strong>Consumer：</strong> 消息消费者，从 Kafka Broker 取消息的客户端。</p><p><strong>Consumer Group：</strong> 消费者组（CG），消费者组内每个消费者负责消费不同分区的数据，提高消费能力。一个分区只能由组内一个消费者消费，消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</p><p><strong>Broker：</strong> 一台 Kafka 机器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。</p><p><strong>Topic：</strong> 可以理解为一个队列，topic 将消息分类，生产者和消费者面向的是同一个 topic。</p><p><strong>Partition：</strong> 为了实现扩展性，提高并发能力，一个非常大的 topic 可以分布到多个 broker （即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个 有序的队列。</p><p><strong>Replica：</strong> 副本，为实现备份的功能，保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 Kafka 仍然能够继续工作，Kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。</p><p><strong>Leader：</strong> 每个分区多个副本的“主”副本，生产者发送数据的对象，以及消费者消费数据的对象，都是 leader。</p><p><strong>Follower：</strong> 每个分区多个副本的“从”副本，实时从 leader 中同步数据，保持和 leader 数据的同步。leader 发生故障时，某个 follower 还会成为新的 leader。</p><p><strong>offset：</strong> 消费者消费的位置信息，监控数据消费到什么位置，当消费者挂掉再重新恢复的时候，可以从消费位置继续消费。</p><p><strong>Zookeeper：</strong> Kafka 集群能够正常工作，需要依赖于 zookeeper，zookeeper 帮助 Kafka 存储和管理集群信息。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Kafka集群将 Record 流存储在称为 topic 的类别中，每个记录由一个键、一个值和一个时间戳组成。<strong>Kafka 是一个分布式流平台</strong>，这到底是什么意思？</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/17/16fb2cd4f14b369d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Kafka 工作流程"></p><p>Kafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，面向的都是同一个 topic。<br> topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文件，该 log 文件中存储的就是 Producer 生产的数据。Producer 生产的数据会不断追加到该 log 文件末端，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自己消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。</p><p>作者：臧小晶<br>链接：<a href="https://juejin.im/post/6844904050064883725" target="_blank" rel="noopener">https://juejin.im/post/6844904050064883725</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p><img src="https://user-gold-cdn.xitu.io/2020/1/17/16fb2cd4f11f1b55?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Kafka文件存储机制"></p><p>由于生产者生产的消息会不断追加到 log 文件末尾，为防止 log 文件过大导致数据定位效率低下，Kafka 采取了<strong>分片</strong>和<strong>索引</strong>机制，将每个 partition 分为多个 segment，每个 segment 对应两个文件：“.index” 索引文件和 “.log” 数据文件。</p><h3 id="分区原因"><a href="#分区原因" class="headerlink" title="分区原因"></a>分区原因</h3><p>方便在集群中扩展，每个 partition 可以通过调整以适应它所在的机器，而一个 topic 又可以有多个 partition 组成，因此可以以 partition 为单位读写了。</p><h3 id="数据可靠性保证"><a href="#数据可靠性保证" class="headerlink" title="数据可靠性保证"></a>数据可靠性保证</h3><p>为保证 producer 发送的数据，能可靠地发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack（acknowledge 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/20/16fc0ef625f8c1c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h4 id="副本数据同步策略"><a href="#副本数据同步策略" class="headerlink" title="副本数据同步策略"></a>副本数据同步策略</h4><p><strong>（1）何时发送 ack？</strong><br> 确保有 follower 与 leader 同步完成，leader 再发送 ack，这样才能保证 leader 挂掉之后，能在 follower 中选举出新的 leader 而不丢数据。<br> <strong>（2）多少个 follower 同步完成后发送 ack？</strong><br> 全部 follower 同步完成，再发送 ack。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/20/16fc0ef626139ae5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="同步策略方案比较"></p><h4 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h4><p>采用第二种方案，所有 follower 完成同步，producer 才能继续发送数据，设想有一个 follower 因为某种原因出现故障，那 leader 就要一直等到它完成同步。这个问题怎么解决？<br> leader维护了一个动态的 in-sync replica set（ISR）：和 leader 保持同步的 follower 集合。当 ISR 集合中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower 长时间未向 leader 同步数据，则该 follower 将被踢出 ISR 集合，该时间阈值由 replica.lag.time.max.ms 参数设定。leader 发生故障后，就会从 ISR 中选举出新的 leader。</p><h4 id="ack-应答机制"><a href="#ack-应答机制" class="headerlink" title="ack 应答机制"></a>ack 应答机制</h4><p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等 ISR 中的 follower 全部接受成功。<br> 所以 Kafka 为用户提供了三种可靠性级别，用户根据可靠性和延迟的要求进行权衡，选择以下的配置。<br> <strong>（1）ack 参数配置：</strong></p><ul><li>0：producer 不等待 broker 的 ack，这提供了最低延迟，broker 一收到数据还没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据。</li><li>1：producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据。</li><li>-1（all）：producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才返回 ack。但是在 broker 发送 ack 时，leader 发生故障，则会造成数据重复。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/1/20/16fc0ef62659d31e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="acks=-1 造成数据重复分析"></p><h4 id="故障处理细节"><a href="#故障处理细节" class="headerlink" title="故障处理细节"></a>故障处理细节</h4><p><img src="https://user-gold-cdn.xitu.io/2020/1/20/16fc0ef626ae3ed5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Log 文件中的 HW 和 LEO"></p><p><strong>LEO：每个副本最大的 offset。<br> HW：消费者能见到的最大的 offset，ISR 队列中最小的 LEO。</strong><br><strong>（1）Follower 故障</strong><br> follower 发生故障后会被临时踢出 ISR 集合，待该 follower 恢复后，follower 会 读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步数据操作。等该 follower 的 LEO 大于等于该 partition 的 HW，即 follower 追上 leader 后，就可以重新加入 ISR 了。<br><strong>（2）Leader 故障</strong><br> leader 发生故障后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。<br><strong>注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</strong></p><p>作者：臧小晶<br>链接：<a href="https://juejin.im/post/6844904050064883725" target="_blank" rel="noopener">https://juejin.im/post/6844904050064883725</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="kafka的特点"><a href="#kafka的特点" class="headerlink" title="kafka的特点"></a>kafka的特点</h3><p>　　高吞吐量：Kafka 每秒可以生产约 25 万消息（50 MB），每秒处理 55 万消息（110 MB）<br>　　持久化数据存储：可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如 ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication 防止数据丢失。<br>　　分布式系统易于扩展：所有的 producer、broker 和 consumer 都会有多个，均为分布式的。无需停机即可扩展机器。<br>　　客户端状态维护：消息被处理的状态是在 consumer 端维护，而不是由 server 端维护。当失败时能自动平衡。</p><h3 id="Zookeeper在kafka中的作用"><a href="#Zookeeper在kafka中的作用" class="headerlink" title="Zookeeper在kafka中的作用?"></a>Zookeeper在kafka中的作用?</h3><h3 id="kafka基于硬盘为什么这么快"><a href="#kafka基于硬盘为什么这么快" class="headerlink" title="kafka基于硬盘为什么这么快"></a>kafka基于硬盘为什么这么快</h3><h4 id="顺序读写"><a href="#顺序读写" class="headerlink" title="顺序读写"></a>顺序读写</h4><p>众所周知Kafka是将消息记录持久化到本地磁盘中的，一般人会认为磁盘读写性能差，可能会对Kafka性能如何保证提出质疑。实际上不管是内存还是磁盘，快或慢关键在于寻址的方式，磁盘分为顺序读写与随机读写，内存也一样分为顺序读写与随机读写。基于磁盘的随机读写确实很慢，但磁盘的顺序读写性能却很高，一般而言要高出磁盘随机读写三个数量级，一些情况下磁盘顺序读写性能甚至要高于内存随机读写，这里给出著名学术期刊 ACM Queue 上的一张性能对比图：</p><p><img src="https://img-blog.csdnimg.cn/20190523181118864.png#pic_center" alt="img"><br>磁盘的顺序读写是磁盘使用模式中最有规律的，并且操作系统也对这种模式做了大量优化，Kafka就是使用了磁盘顺序读写来提升的性能。Kafka的message是不断追加到本地磁盘文件末尾的，而不是随机的写入，这使得Kafka写入吞吐量得到了显著提升。</p><h4 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h4><p>为了优化读写性能，Kafka利用了操作系统本身的Page Cache，就是利用操作系统自身的内存而不是JVM空间内存。这样做的好处有：</p><ul><li>避免Object消耗：如果是使用Java堆，Java对象的内存消耗比较大，通常是所存储数据的两倍甚至更多。</li><li>避免GC问题：随着JVM中数据不断增多，垃圾回收将会变得复杂与缓慢，使用系统缓存就不会存在GC问题。</li></ul><p>相比于使用JVM或in-memory cache等数据结构，利用操作系统的Page Cache更加简单可靠。首先，操作系统层面的缓存利用率会更高，因为存储的都是紧凑的字节结构而不是独立的对象。其次，操作系统本身也对于Page Cache做了大量优化，提供了write-behind、read-ahead以及flush等多种机制。再者，即使服务进程重启，系统缓存依然不会消失，避免了in-process cache重建缓存的过程。</p><p>通过操作系统的Page Cache，Kafka的读写操作基本上是基于内存的，读写速度得到了极大的提升。</p><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>这里主要讲的是Kafka利用linux操作系统的 “零拷贝（zero-copy）” 机制在消费端做的优化。首先来了解下数据从文件发送到socket网络连接中的常规传输路径：</p><ul><li>操作系统从磁盘读取数据到内核空间（kernel space）的Page Cache</li><li>应用程序读取Page Cache的数据到用户空间（user space）的缓冲区</li><li>应用程序将用户空间缓冲区的数据写回内核空间到socket缓冲区（socket buffer）</li><li>操作系统将数据从socket缓冲区复制到网络发送的NIC缓冲区</li></ul><p>这个过程包含4次copy操作和2次系统上下文切换，性能其实非常低效。linux操作系统 “零拷贝” 机制使用了sendfile方法，允许操作系统将数据从Page Cache 直接发送到网络，只需要最后一步的copy操作将数据复制到 NIC 缓冲区，这样避免重新复制数据。示意图如下：<br><img src="https://img-blog.csdnimg.cn/20190523181559385.png#pic_center" alt="img"></p><h4 id="分区分段"><a href="#分区分段" class="headerlink" title="分区分段"></a>分区分段</h4><p>Kafka的message是按topic分类存储的，topic中的数据又是按照一个一个的partition即分区存储到不同broker节点。每个partition对应了操作系统上的一个文件夹，partition实际上又是按照segment分段存储的。这也非常符合分布式系统分区分桶的设计思想。</p><p>通过这种分区分段的设计，Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。</p><h4 id="批量发送"><a href="#批量发送" class="headerlink" title="批量发送"></a>批量发送</h4><p>Kafka允许进行批量发送消息，先将消息缓存在内存中，然后一次请求批量发送出去<br>比如可以指定缓存的消息达到某个量的时候就发出去，或者缓存了固定的时间后就发送出去</p><h3 id="和其他消息中间件的对比"><a href="#和其他消息中间件的对比" class="headerlink" title="和其他消息中间件的对比"></a>和其他消息中间件的对比</h3><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis的主从复制</title>
      <link href="/2020/11/03/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2020/11/03/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="同步操作（PSYNC命令）"><a href="#同步操作（PSYNC命令）" class="headerlink" title="同步操作（PSYNC命令）"></a>同步操作（PSYNC命令）</h2><p><strong>PSYNC命令具有完整重同步（full resy nchronization）和部分重同步（partial resynchronization）两种模式：</strong></p><ul><li><strong>完整重同步：</strong>用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步 骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓 冲区里面的写命令来进行同步</li><li><strong>部分重同步：</strong>则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器 时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务 器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li></ul><h2 id="完整重同步"><a href="#完整重同步" class="headerlink" title="完整重同步"></a>完整重同步</h2><ul><li><p><strong>概念：</strong>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，<strong>将从服务器的数据库状态更新至主服务器当前所处的数据库状态</strong></p></li><li><p><strong>SYNC命令：</strong></p><p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：</p><ul><li>①从服务器向主服务器<strong>发送SYNC命令</strong></li><li>②收到SYNC命令的主服务器<strong>执行BGSAVE命令，在后台生成一个RDB文件</strong>，并使用一 个缓冲区记录从现在开始执行的所有写命令</li><li>③当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的<strong>RDB文件发送给从服务器</strong>，从服务器<strong>接收并载入</strong>这个RDB文件，将自己的数据库状态更新至主服务器 执行BGSAVE命令时的数据库状态</li><li>④主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写 命令，将自己的数据库状态更新至主服务器数据库当前所处的状态</li></ul></li><li><p>下图展示了SYNC命令执行期间，主从服务器的通信过程：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20191201105150863.png" alt="img"></p><blockquote><h3 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h3><ul><li>下表展示了一个主从服务器进行同步的例子</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201105237782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><h2 id="部分重同步的实现细节"><a href="#部分重同步的实现细节" class="headerlink" title="部分重同步的实现细节"></a>部分重同步的实现细节</h2><ul><li><strong>同步功能由以下三个部分构成：</strong><ul><li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区（replication backlog）</li><li>服务器的运行ID（run ID）</li></ul></li></ul><blockquote><h3 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h3><ul><li><p>执行复制的双方——主服务器和从服务器会</p><p><strong>分别维护一个复制偏移量：</strong></p><ul><li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li><li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li></ul></li><li><p>通过对比主从服务器的复制偏移量，</p><p><strong>程序可以很容易地知道主从服务器是否处于一致状态：</strong></p><ul><li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li><li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</li></ul></li><li><p>在下图所示的例子中，主从服务器的复制偏移量的值都为10086</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121350757.png" alt="img"></p><ul><li>如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121359413.png" alt="img"></p><h3 id="网络断开重连后的复制偏移量"><a href="#网络断开重连后的复制偏移量" class="headerlink" title="网络断开重连后的复制偏移量"></a>网络断开重连后的复制偏移量</h3><ul><li>考虑以下这个例子：假设如上面的图片所示，主从服务器当前的复制偏移量都为10086，但是就在主服务器要向从服务器传播长度为33字节的数据之前，从<strong>服务器A断线</strong>了，那么主服务 器传播的数据将只有从服务器B和从服务器C能收到，在这之后，主服务器、从服务器B和从 服务器C三个服务器的复制偏移量都将更新为10119，而断线的从服务器A的复制偏移量仍然停留在10086，这说明从服务器A与主服务器并不一致，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121522212.png" alt="img"></p><ul><li>假设从服务器A在断线之后就立即重新连接主服务器，并且成功，那么接下来，从服务器将向主服务器发送PSYNC命令，报告从服务器A当前的复制偏移量为10086，那么这时， <strong>主服务器应该对从服务器执行完整重同步还是部分重同步呢？</strong>如果执行部分重同步的话，主 服务器又如何补偿从服务器A在断线期间丢失的那部分数据呢？<strong>以上问题的答案都和复制积压缓冲区有关</strong></li></ul></blockquote><blockquote><h3 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h3><ul><li>复制积压缓冲区是由主服务器维护的一个<strong>固定长度（fixed-size）先进先出（FIFO）队列</strong>，默认大小为1MB</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121735717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会<strong>将写命令入队到复制积压缓冲区里面</strong>，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121909779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会<strong>为队列中的每个字节记录相应的复制偏移量</strong>，就像下表展示的那样</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121943503.png" alt="img"></p><ul><li><p>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令</p><p><strong>将自己的复制偏移量offset发送给主服务器</strong></p><p>，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操 作：</p><ul><li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）<strong>仍然存在于复制积压缓冲区里面</strong>，那么主服务器将对从服务器执行部分重同步操作</li><li>相反，如果offset偏移量之后的数据<strong>已经不存在于复制积压缓冲区</strong>，那么主服务器将对从服务器执行完整重同步操作</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/2019120112234757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong><em>\</em>演示案例：**</strong></p><ul><li>回到之前上面图片所展示的断线后重连接例子：</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121522212.png" alt="img"></p><ul><li>当从服务器A断线之后，它立即重新连接主服务器，并<strong>向主服务器发送PSYNC命令，报告自己的复制偏移量为10086</strong></li><li>主服务器收到从服务器发来的PSYNC命令以及偏移量10086之后，主服务器将<strong>检查偏移量10086之后的数据是否存在于复制积压缓冲区里面</strong>，结果发现<strong>这些数据仍然存在</strong>，于是主服务器向从服务器发送+CONTINUE回复，表示数据同步将以部分重同步模式来进行</li><li>接着主服务器会将复制积压缓冲区10086偏移量之后的<strong>所有数据（偏移量为10087至 10119）都发送给从服务器</strong></li><li>从服务器只要接收这33字节的缺失数据，就可以回到与主服务器一致的状态，如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201122209306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><blockquote><h3 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h3><ul><li><p>除了复制偏移量和复制积压缓冲区之外，</p><p><strong>实现部分重同步还需要用到服务器运行ID（run ID）：</strong></p><ul><li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID</li><li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3</li></ul></li><li><p>当从服务器对主服务器<strong>进行初次复制时</strong>，主服务器会<strong>将自己的运行ID传送给从服务器</strong>， 而从服务器则会将<strong>这个运行ID保存起来</strong></p></li><li><p>当从服务器断线并重新连上一个主服务器时，</p><p><strong>从服务器将向当前连接的主服务器发送之前保存的运行ID：</strong></p><ul><li>如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID相同</strong>，那么说明从服务器 断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操 作</li><li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID并不相同</strong>，那么 说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服 务器执行完整重同步操作</li></ul></li><li><p>举个例子，假设从服务器原本正在复制一个运行ID为 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3的主服务器，那么在网络断开，从服务器重新连 接上主服务器之后，从服务器将向主服务器发送这个运行ID，主服务器根据自己的运行ID是 否53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3来判断是执行部分重同步还是执行完整重同步</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis集群</title>
      <link href="/2020/11/03/redis%E9%9B%86%E7%BE%A4/"/>
      <url>/2020/11/03/redis%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h3><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑<strong>读高并发</strong>的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的<strong>读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20200115180329317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="redis-master-slave"></p><p><strong>主节点和从节点数据同步，也就复制的问题</strong></p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>消息通知：实例故障了通知管理员和客户端新的地址</p><p>故障发现</p><p>故障转移</p><h4 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h4><h5 id="一、检测主观下线状态"><a href="#一、检测主观下线状态" class="headerlink" title="一、检测主观下线状态"></a>一、检测主观下线状态</h5><ul><li>在默认情况下，Sentinel会<strong>以每秒一次的频率</strong>向所有与它创建了命令连接的实例（<strong>包括主服务器、从服务器、其他Sentinel在内</strong>）发送<strong>PING命令</strong>，并通过实例返回的PING命令回复来判断实例是否在线</li></ul><h5 id="二、检测客观下线状态"><a href="#二、检测客观下线状态" class="headerlink" title="二、检测客观下线状态"></a>二、检测客观下线状态</h5><ul><li>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线 了，它会<strong>向同样监视这一主服务器的其他Sentinel进行询问</strong>，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里<strong>接收到足够数量的已下线判断之后</strong>，Sentinel就会将从服务器判定为客观下线，并对主服务器<strong>执行故障转移操作</strong></li></ul><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的<strong>各个Sentinel会进行协商</strong>，选举出一个领头Sentinel，当某个sentinel被半数以上的sentinel设置成为领头sentinel，那么这个sentinel称为领头sentinel并由领头Sentinel<strong>对下线主服务器执行故障转移操作</strong>(raft)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Raft算法</span><br></pre></td></tr></table></figure><h4 id="故障自动转移"><a href="#故障自动转移" class="headerlink" title="故障自动转移"></a>故障自动转移</h4><p>领头的sentinel负责故障转移<br>从从服务器列表中选择一个节点作为新节点</p><p>1 过滤掉：下线、5s内没有回应InFO、与主服务器失联超过down-after-milliseconds的从服务器<br>2 选择从服务器中优先级最高的。若具有多个同样优先级的，则继续<br>3 选择复制偏移量最大的从节点。若具有多个复制偏移量相同的，则继续<br>4 选择 run id最小的从服务器</p><p>sentinel会对1中选出的从服务器发送slaveof no one使其成为主服务器<br>sentinel向其余从服务器发送命令，让他们成为新主服务器的从服务器，并同步数据<br>sentinel会关注刚刚下线的主服务器，并让它成为从服务器，当它恢复的时候就去同步数据</p><h3 id="官方Redis-Cluster-方案-服务端路由查询"><a href="#官方Redis-Cluster-方案-服务端路由查询" class="headerlink" title="官方Redis Cluster 方案(服务端路由查询)"></a>官方Redis Cluster 方案(服务端路由查询)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.主从复制不能实现高可用</span><br><span class="line">2.随着公司发展，用户数量增多，并发越来越多，业务需要更高的QPS，而主从复制中单机的QPS可能无法满足业务需求</span><br><span class="line">3.数据量的考虑，现有服务器内存不能满足业务数据的需要时，单纯向服务器添加内存不能达到要求，此时需要考虑分布式需求，把数据分布到不同服务器上</span><br></pre></td></tr></table></figure><p>redis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</p><p>那么redis 是如何合理分配这些节点和数据的呢？</p><p>Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做<code>哈希槽 (hash slot)</code>的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用<code>CRC16</code>算法来取模得到所属的<code>slot</code>，然后将这个key 分到哈希槽区间的节点上，具体算法就是：<code>CRC16(key) % 16384</code>。</p><ul><li><strong>Redis集群采用P2P的Gossip（流言）协议，</strong> Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200806112902246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><strong>通信过程说明：</strong><ul><li>1）集群中的每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口上加10000</li><li>2）每个节点在固定周期内通过特定规则选择几个节点发送ping消息</li><li>3）接收到ping消息的节点用pong消息作为响应</li></ul></li><li>集群中每个节点通过一定规则挑选要通信的节点，每个节点可能知道全部节点，也可能仅知道部分节点，<strong>只要这些节点彼此可以正常通信，最终它们会达到一致的状态</strong>。当节点出故障、新节点加入、主从角色变化、槽信息 变更等事件发生时，通过不断的ping/pong消息通信，经过一段时间后<strong>所有的节点都会知道整个集群全部节点的最新状态，从而达到集群状态同步的目的</strong></li></ul><blockquote><h3 id="Gossip消息"><a href="#Gossip消息" class="headerlink" title="Gossip消息"></a>Gossip消息</h3><ul><li>Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息，了解这些消息<strong>有助于我们理解集群如何完成信息交换</strong></li><li><strong>常用的Gossip消息可分为：</strong><ul><li><strong>meet消息：</strong>用于通知新节点加入。消息发送者通知接收者加入到当前 集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong消息交换</li><li><strong>ping消息：</strong>集群内交换最频繁的消息，集群内每个节点每秒向多个其 他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消 息发送封装了自身节点和部分其他节点的状态数据。</li><li><strong>pong消息：</strong>当接收到ping、meet消息时，作为响应消息回复给发送方确 认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内 广播自身的pong消息来通知整个集群对自身状态进行更新</li><li><strong>fail消息：</strong>当节点判定集群内另一个节点下线时，会向集群内广播一个 fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。具体细节将在后面的“故障转移”文章中说明</li></ul></li><li><strong>它们的通信模式如下图所示：</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20200531152212286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><h3 id="MOVED重定向"><a href="#MOVED重定向" class="headerlink" title="MOVED重定向"></a>MOVED重定向</h3><ul><li><strong>概念：</strong>在集群模式下，bRedis接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；否则回复MOVED重定向错误，通知客户端请求正确的节点。如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/20200531231926655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><h3 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h3><ul><li>Redis集群支持<strong>在线迁移槽（slot）和数据来完成水平伸缩</strong>，当slot对应的数据从源节点到目标节点迁移过程中，客户端需要做到智能识别，保证键命令可正常执行。例如当一个slot数据从源节点迁移到目标节点时，期间可能出现一部分数据在源节点，而另一部分在目标节点，如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/20200806113128921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><strong>当出现上述情况时，客户端键命令执行流程将发生变化，如下所示：</strong><ul><li>1）客户端根据本地slots缓存发送命令到源节点，如果存在键对象则直接执行并返回结果给客户端</li><li>2）如果键对象不存在，则可能存在于目标节点，这时源节点会回复ASK重定向异常。格式如下：(error) ASK {slot} {targetIP}:{targetPort}</li><li>3）客户端从ASK重定向异常提取出目标节点信息，发送asking命令到目标节点打开客户端连接标识，再执行键命令。如果存在则执行，不存在则返回不存在信息</li></ul></li><li><strong>ASK重定向整体流程如下图所示：</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20200806113146529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><ul><li><strong>ASK与MOVED虽然都是对客户端的重定向控制，但是有着本质区别：</strong><ul><li>ASK重定向说明集群正在进行slot数据迁移，<strong>客户端无法知道什么时候迁移完成，因此只能是临时性的重定向</strong>，客户端不会更新slots缓存</li><li>但是MOVED重定向说明键<strong>对应的槽已经明确指定到新的节点</strong>，因此需要更新slots缓存</li></ul></li></ul><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><ul><li><strong>Redis集群自身实现了高可用。高可用首先需要解决集群部分失败的场景：</strong>当集群内少量节点出现故障时通过自动故障转移保证集群可以正常对外提供服务。本文介绍故障转移的细节，分析故障发现和替换故障节点的过程</li></ul><blockquote><h3 id="故障发现-1"><a href="#故障发现-1" class="headerlink" title="故障发现"></a>故障发现</h3><ul><li>当集群内某个节点出现问题时，需要通过一种健壮的方式保证<strong><em>\</em>识别出节点是否发生了故障**</strong></li><li><strong>因此故障发现也是通过消息传播机制实现的，主要环节包括：</strong><ul><li><strong>主观下线 （pfail）：</strong>指某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况</li><li><strong>客观下线（fail）：</strong>指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移</li></ul></li></ul></blockquote><blockquote><h3 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h3><ul><li>集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong消息作为响应。<strong>如果在cluster-node-timeout时间内通信一直失败，则发送节点会\</strong>认为接收节点存在故障*<strong>*，把接收节点标记为</strong>主观下线（pfail）状态**</li></ul><h3 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a><strong>客观下线</strong></h3><ul><li><p>当某个节点判断另一个节点主观下线后，相应的<strong><em>\</em>节点状态会跟随消息在集群内传播**</strong></p></li><li><p>通过Gossip消息传播，集群内节点不断收集到故障节点的下线报告。<strong>当半数以上持有槽的主节点都标记某个节点是主观下线时。触发客观下线流程</strong></p></li><li><p>假设节点a标记节点b为主观下线，</p><p><strong>一段时间后节点a通过消息把节点b的状态发送到其他节点，当节点c接受到消息并解析出消息体含有节点b的pfail状态时，会触发客观下线流程</strong></p><p>，如下图所示：</p><ul><li>1）当消息体内含有其他节点的pfail状态会判断发送节点的状态，<strong>如果发送节点是主节点则对报告的pfail状态处理，从节点则忽略</strong></li><li>2）找到pfail对应的节点结构，更新clusterNode内部下线报告链表</li><li>3）根据更新后的下线报告链表告尝试进行客观下线</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200601000227906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><blockquote><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><ul><li>故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要<strong>在它的从节点中选出一个替换它，从而保证集群的高可用</strong></li><li>下线主节点的所有从节点承担故障恢复的义务，当从节点通过内部定时任务发现自身复制的主节点进入客观下线时，将会<strong><em>\</em>触发故障恢复流程，**</strong>如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200806113530768.png" alt="img"></p><h3 id="资格检查"><a href="#资格检查" class="headerlink" title="资格检查"></a>资格检查</h3><ul><li>每个从节点都要检查最后与主节点断线时间<strong>，判断是否有资格替换故障的主节点</strong></li><li>如果从节点与主节点断线时间<strong>超过cluster-node-time*cluster-slavevalidity-factor，**</strong>则当前从节点不具备故障转移资格**。参数cluster-slavevalidity-factor用于从节点的有效因子，默认为10</li></ul><h3 id="准备选举时间"><a href="#准备选举时间" class="headerlink" title="准备选举时间"></a>准备选举时间</h3><ul><li>当从节点符合故障转移资格后，<strong>更新触发故障选举的时间，只有到达该时间后才能执行后续流程</strong></li></ul><h3 id="发起选举"><a href="#发起选举" class="headerlink" title="发起选举"></a>发起选举</h3><ul><li><p>当从节点定时任务</p><p><strong>检测到达故障选举时间（failover_auth_time）到达后，发起选举流程如下：</strong></p><ul><li><strong>（1）更新配置纪元：</strong>配置纪元是一个只增不减的整数，每个主节点自身维护一个配置纪元标示当前主节点的版本，所有主节点的配置纪元都不相等，从节点会复制主节点的配置纪元，整个集群又维护一个全局的配置纪元，用于记录集群内所有主节点配置纪元的最大版本。<strong>从节点每次发起投票时都会自增集群的全局配置纪元</strong></li><li><strong>（2）广播选举消息：</strong>在集群内广播选举消息（FAILOVER_AUTH_REQUEST），并记录已发送过消息的状态，保证该从节点在一个配置纪元内只能发起一次选举</li></ul></li></ul><h3 id="选举投票"><a href="#选举投票" class="headerlink" title="选举投票"></a>选举投票</h3><ul><li><strong>只有持有槽的主节点才会处理故障选举消息</strong>，因为每个持有槽的节点在一个配置纪元内都有唯一的一张选票，当接到第一个请求投票的从节点消息时回复FAILOVER_AUTH_ACK消息作为投票，之后相同配置纪元内其他从节点的 选举消息将忽略</li><li><strong><em>\</em>投票过程其实是一个领导者选举的过程\</strong>，**如集群内有N个持有槽的主节点代表有N张选票。由于在每个配置纪元内持有槽的主节点只能投票给一个 从节点，因此只能有一个从节点获得N/2+1的选票，保证能够找出唯一的从节点</li><li><strong>Redis集群没有直接使用从节点进行领导者选举，</strong>主要因为从节点数必须大于等于3个才能保证凑够N/2+1个节点，将导致从节点资源浪费。使用 集群内所有持有槽的主节点进行领导者选举，即使只有一个从节点也可以完 成选举过程</li><li><strong>当从节点收集到N/2+1个持有槽的主节点投票时，从节点可以执行替换主节点操作</strong>，例如集群内有5个持有槽的主节点，主节点b故障后还有4个， 当其中一个从节点收集到3张投票时代表获得了足够的选票可以进行替换主 节点操作，如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/20200601194700684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="替换主节点"><a href="#替换主节点" class="headerlink" title="替换主节点"></a>替换主节点</h3><ul><li><strong>当从节点收集到足够的选票之后，触发替换主节点操作：</strong><ul><li>1）当前从节点<strong>取消复制变为主节点</strong></li><li>2）执行clusterDelSlot操作<strong>撤销故障主节点负责的槽</strong>，并执行clusterAddSlot把这些槽委派给自己</li><li><strong>3）向集群广播自己的pong消息，</strong>通知集群内所有的节点当前从节点变为主节点并接管了故障主节点的槽信息</li></ul></li></ul></blockquote><h3 id="基于客户端分配"><a href="#基于客户端分配" class="headerlink" title="基于客户端分配"></a>基于客户端分配</h3><p><img src="https://img-blog.csdnimg.cn/20200115173640248.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>简介</strong></p><p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool</p><p><strong>优点</strong></p><p>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</p><p><strong>缺点</strong></p><ul><li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li><li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</li></ul><h3 id="基于代理服务器分片"><a href="#基于代理服务器分片" class="headerlink" title="基于代理服务器分片"></a>基于代理服务器分片</h3><p><img src="https://img-blog.csdnimg.cn/20200115173630730.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>简介</strong></p><p>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端</p><p><strong>特征</strong></p><ul><li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li><li>Proxy 的逻辑和存储的逻辑是隔离的</li><li>代理层多了一次转发，性能有所损耗</li></ul><p><strong>业界开源方案</strong></p><ul><li>Twtter开源的Twemproxy</li><li>豌豆荚开源的Codis</li></ul><h3 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h3><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将<br>该数据分配的节点序号为：hash(key)%N。<br>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，<br>将导致大量的数据迁移。</p><h4 id="顺序分布"><a href="#顺序分布" class="headerlink" title="顺序分布"></a>顺序分布</h4><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用<br>顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。<br>顺序分布相比于哈希分布的主要优点如下：</p><ul><li>能保持数据原有的顺序；</li><li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li></ul><h4 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h4><p>将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值<br>之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p><p><img src="/2020/11/03/redis%E9%9B%86%E7%BE%A4/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201106202450535.png" alt="image-20201106202450535"></p><p>虚拟节点</p><p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。<br>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。<br>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节<br>点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双写问题和延时双删</title>
      <link href="/2020/11/02/%E5%8F%8C%E5%86%99%E9%97%AE%E9%A2%98%E5%92%8C%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0/"/>
      <url>/2020/11/02/%E5%8F%8C%E5%86%99%E9%97%AE%E9%A2%98%E5%92%8C%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>我们讨论<strong>两种</strong>更新策略：</p><ul><li>1.先删除缓存，再更新数据库</li><li>2.先更新数据库，再删除缓存</li></ul><h2 id="先删缓存，再更新数据库"><a href="#先删缓存，再更新数据库" class="headerlink" title="先删缓存，再更新数据库"></a>先删缓存，再更新数据库</h2><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p><ul><li><p>（1）请求A进行写操作，删除缓存</p></li><li><p>（2）请求B查询发现缓存不存在</p></li><li><p>（3）请求B去数据库查询得到旧值</p></li><li><p>（4）请求B将旧值写入缓存</p></li><li><p>（5）请求A将新值写入数据库 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p><p>那么，如何解决呢？采用延时双删策略 伪代码如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">        redis.delKey(key);</span><br><span class="line">        db.updateData(data);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        redis.delKey(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>转化为中文描述就是</p><p>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存 这么做，可以将1秒内所造成的缓存脏数据，再次删除。</p><p><strong>第二次删除,如果删除失败怎么办？</strong></p><p>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：</p><ul><li>（1）请求A进行写操作，删除缓存</li><li>（2）请求B查询发现缓存不存在</li><li>（3）请求B去数据库查询得到旧值</li><li>（4）请求B将旧值写入缓存</li><li>（5）请求A将新值写入数据库</li><li>（6）请求A试图去删除请求B写入对缓存值，结果失败了。 ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。 <strong>如何解决呢？</strong> 具体解决方案，且看博主对第(3)种更新策略的解析。</li></ul><h3 id="先更新DB再删除缓存"><a href="#先更新DB再删除缓存" class="headerlink" title="先更新DB再删除缓存"></a>先更新DB再删除缓存</h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href="https://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">《Cache-Aside pattern》</a>。其中就指出</p><ol><li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li><li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li></ol><p><strong>这种情况不存在并发问题么？</strong></p><p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p><p>（1）缓存刚好失效</p><p>（2）请求A查询数据库，得一个旧值</p><p>（3）请求B将新值写入数据库</p><p>（4）请求B删除缓存</p><p>（5）请求A将查到的旧值写入缓存 ok，如果发生上述情况，确实是会发生脏数据。</p><p><strong>然而，发生这种情况的概率又有多少呢？</strong></p><p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。</p><p>可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。 假设，有人非要抬杠，有强迫症，一定要解决怎么办？</p><ol><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事务的实现原理</title>
      <link href="/2020/11/02/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2020/11/02/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>相信大家都用过事务以及了解他的特点，如原子性(Atomicity),一致性(Consistency),隔离型(Isolation)以及持久性(Durability)等。今天想跟大家一起研究下事务内部到底是怎么实现的，在讲解前我想先抛出个问题：<br><strong>事务想要做到什么效果？</strong></p><p>按我理解，无非是要做到<strong>可靠性</strong>以及<strong>并发处理</strong></p><p>可靠性：数据库要保证当insert或update操作时抛异常或者数据库crash的时候需要保障数据的操作前后的一致，想要做到这个，我需要知道我修改之前和修改之后的状态，所以就有了undo log和redo log。</p><p>并发处理：也就是说当多个并发请求过来，并且其中有一个请求是对数据修改操作的时候会有影响，为了避免读到脏数据，所以需要对事务之间的读写进行隔离，至于隔离到啥程度得看业务系统的场景了，实现这个就得用MySQL 的隔离级别。</p><p>下面我首先讲实现事务功能的三个技术，分别是日志文件(redo log 和 undo log)，锁技术以及MVCC，然后再讲事务的实现原理，包括原子性是怎么实现的，隔离型是怎么实现的等等。最后在做一个总结，希望大家能够耐心看完</p><ul><li>redo log与undo log介绍</li><li>mysql锁技术以及MVCC基础</li><li>事务的实现原理</li><li>总结</li></ul><hr><h3 id="二、-redo-log-与-undo-log介绍"><a href="#二、-redo-log-与-undo-log介绍" class="headerlink" title="二、 redo log 与 undo log介绍"></a>二、 redo log 与 undo log介绍</h3><h4 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1. redo log"></a>1. redo log</h4><p><strong>什么是redo log ?</strong></p><p>redo log叫做<strong>重做</strong>日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当<strong>事务提交之后</strong>会把所有修改信息都会存到该日志中。当数据发生修改时，InnoDB不仅会修改Buffer Pool中的数据，也会在redo log buffer记录这次操作；当事务提交时，会对redo log buffer进行刷盘，记录到redo log file中(WAL)。如果MySQL宕机，重启时可以读取redo log file中的数据，对数据库进行恢复。这样就不需要每次提交事务都实时进行刷脏了</p><p>假设有个表叫做tb1(id,username) 现在要插入数据（3，ceshi）</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2ff3e4c3b8b46?w=2368&h=788&f=png&s=226339" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select balance from bank where name&#x3D;&quot;zhangsan&quot;;</span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 balance&#x3D;600</span><br><span class="line">update bank set balance &#x3D; balance - 400; </span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 amount&#x3D;400</span><br><span class="line">update finance set amount &#x3D; amount + 400;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h3 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h3><p><img src="https://img-blog.csdnimg.cn/20201030172624806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTQ2Nzk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>注意点：</p><ul><li>先修改Buffer Pool，后写 redo log buffer。</li><li>redo日志比数据页先写回磁盘：事务提交的时候，会把redo log buffer写入redo log file，写入成功才算提交成功（也有其他场景触发写入，这里就不展开了），而Buffer Pool的数据由后台线程在后续某个时刻写入磁盘。</li><li>刷脏的时候一定会保证对应的redo log已经落盘了，也即是所谓的WAL（预写式日志），否则会有数据丢失的可能性。</li></ul><h4 id="2-undo-log"><a href="#2-undo-log" class="headerlink" title="2.undo log"></a>2.undo log</h4><p><strong>什么是 undo log ？</strong></p><p>undo log 叫做回滚日志，用于记录数据<strong>被修改前</strong>的信息。他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p><p>还用上面那两张表</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe552145e2c1?w=4652&h=1848&f=png&s=867671" alt="img"></p><p>每次写入数据或者修改数据之前都会把修改前的信息记录到 undo log。</p><p><strong>undo log 有什么作用？</strong></p><p>undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。</p><p>总结：<br>undo log是用来回滚数据的用于保障 未提交事务的原子性</p><hr><h3 id="三、mysql锁技术以及MVCC基础"><a href="#三、mysql锁技术以及MVCC基础" class="headerlink" title="三、mysql锁技术以及MVCC基础"></a>三、mysql锁技术以及MVCC基础</h3><h4 id="1-mysql锁技术"><a href="#1-mysql锁技术" class="headerlink" title="1. mysql锁技术"></a>1. mysql锁技术</h4><p>当有多个请求来读取表中的数据时可以不采取任何操作，但是多个请求里有读请求，又有修改请求时必须有一种措施来进行并发控制。不然很有可能会造成不一致。<br><strong>读写锁</strong><br>解决上述问题很简单，只需用两种锁的组合来对读写请求进行控制即可，这两种锁被称为：</p><p>共享锁(shared lock),又叫做”读锁”<br>读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。</p><p>排他锁(exclusive lock),又叫做”写锁”<br>写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a27696def80b5f?w=416&h=183&f=png&s=16219" alt="img"></p><p>总结：<br>通过读写锁，可以做到读读可以并行，但是不能做到写读，写写并行<br>事务的隔离性就是根据读写锁来实现的！！！这个后面再说。</p><h4 id="2-MVCC基础"><a href="#2-MVCC基础" class="headerlink" title="2. MVCC基础"></a>2. MVCC基础</h4><p>MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。</p><blockquote><p>InnoDB的 MVCC ，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，<br>一个保存了行的创建时间，一个保存了行的过期时间，<br>当然存储的并不是实际的时间值，而是系统版本号。</p></blockquote><p>以上片段摘自《高性能Mysql》这本书对MVCC的定义。他的主要实现思想是通过<strong>数据多版本</strong>来做到<strong>读写分离</strong>。从而实现不加锁读进而做到读写并行。</p><p><strong>MVCC在mysql中的实现依赖的是undo log与read view</strong></p><ul><li>undo log :undo log 中记录某行数据的多个版本的数据。</li><li>read view :用来判断当前版本数据的可见性</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f5e3c3950ca1?w=3612&h=1512&f=png&s=816439" alt="img"></p><hr><h3 id="四、事务的实现"><a href="#四、事务的实现" class="headerlink" title="四、事务的实现"></a>四、事务的实现</h3><p>前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。</p><ul><li>事务的原子性是通过 undo log 来实现的</li><li>事务的持久性性是通过 redo log 来实现的</li><li>事务的隔离性是通过 (读写锁+MVCC)来实现的</li><li>而事务的终极大 boss <strong>一致性</strong>是通过原子性，持久性，隔离性来实现的！！！</li></ul><p><strong>原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！</strong></p><p>总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。</p><h4 id="1-原子性的实现"><a href="#1-原子性的实现" class="headerlink" title="1.原子性的实现"></a>1.原子性的实现</h4><p>什么是原子性：</p><p>一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。</p><p>上面这段话取自《高性能MySQL》这本书对原子性的定义，原子性可以概括为就是要实现要么全部失败，要么全部成功。</p><p>以上概念相信大家伙儿都了解，那么数据库是怎么实现的呢？ 就是通过<strong>回滚</strong>操作。<br>所谓回滚操作就是当发生错误异常或者显式的执行rollback语句时需要把数据还原到原先的模样，所以这时候就需要用到undo log来进行回滚，接下来看一下undo log在实现事务原子性时怎么发挥作用的</p><h5 id="1-1-undo-log-的生成"><a href="#1-1-undo-log-的生成" class="headerlink" title="1.1 undo log 的生成"></a>1.1 undo log 的生成</h5><p>假设有两个表 bank和finance，表中原始数据如图所示，当进行插入，删除以及更新操作时生成的undo log如下面图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe331bab111c?w=4652&h=1848&f=png&s=867671" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe2457ff3820?w=1904&h=744&f=png&s=319469" alt="img"></p><p>从上图可以了解到数据的变更都伴随着回滚日志的产生：<br>(1) 产生了被修改前数据(zhangsan,1000) 的回滚日志</p><p>(2) 产生了被修改前数据(zhangsan,0) 的回滚日志</p><p>根据上面流程可以得出如下结论：<br><strong>1.每条数据变更(insert/update/delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上</strong><br><strong>2.所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</strong></p><p>思考：为什么先写日志后写数据库？ —稍后做解释</p><h5 id="1-2-根据undo-log-进行回滚"><a href="#1-2-根据undo-log-进行回滚" class="headerlink" title="1.2 根据undo log 进行回滚"></a>1.2 根据undo log 进行回滚</h5><p>为了做到同时成功或者失败，当系统发生错误或者执行rollback操作时需要根据undo log 进行回滚</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fece4894a8a8?w=3748&h=1100&f=png&s=475112" alt="img"></p><p>回滚操作就是要还原到原来的状态，undo log记录了数据被修改前的信息以及新增和被删除的数据信息，根据undo log生成回滚语句，比如：</p><p>(1) 如果在回滚日志里有新增数据记录，则生成删除该条的语句</p><p>(2) 如果在回滚日志里有删除数据记录，则生成生成该条的语句</p><p>(3) 如果在回滚日志里有修改数据记录，则生成修改到原先数据的语句</p><h4 id="2-持久性的实现"><a href="#2-持久性的实现" class="headerlink" title="2.持久性的实现"></a>2.持久性的实现</h4><p>事务一旦提交，其所作做的修改会永久保存到数据库中，此时即使系统崩溃修改的数据也不会丢失。</p><p>先了解一下MySQL的数据存储机制，MySQL的表数据是存放在磁盘上的，因此想要存取的时候都要经历磁盘IO,然而即使是使用SSD磁盘IO也是非常消耗性能的。<br>为此，为了提升性能InnoDB提供了缓冲池(Buffer Pool)，Buffer Pool中包含了磁盘数据页的映射，可以当做缓存来使用：<br><strong>读数据</strong>：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取在放入缓冲池；<br><strong>写数据</strong>：会首先写入缓冲池，缓冲池中的数据会定期同步到磁盘中；</p><p>上面这种缓冲池的措施虽然在性能方面带来了质的飞跃，但是它也带来了新的问题，当MySQL系统宕机，断电的时候可能会丢数据！！！</p><p>因为我们的数据已经提交了，但此时是在缓冲池里头，还没来得及在磁盘持久化，所以我们急需一种机制需要存一下已提交事务的数据，为恢复数据使用。</p><p>于是 redo log就派上用场了。下面看下redo log是什么时候产生的</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a26f9acf011739?w=994&h=373&f=png&s=120202" alt="img"></p><p>既然redo log也需要存储，也涉及磁盘IO为啥还用它？</p><p>（1）redo log 的存储是顺序存储，而缓存同步是随机操作。</p><p>（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。</p><hr><h4 id="3-隔离性实现"><a href="#3-隔离性实现" class="headerlink" title="3.隔离性实现"></a>3.隔离性实现</h4><p>隔离性是事务ACID特性里最复杂的一个。在SQL标准里定义了四种隔离级别，每一种级别都规定一个事务中的修改，哪些是事务之间可见的，哪些是不可见的。</p><p>级别越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。</p><p>Mysql 隔离级别有以下四种（级别由低到高）：</p><ul><li><strong>READ UNCOMMITED</strong> (未提交读)</li><li><strong>READ COMMITED</strong> (提交读)</li><li><strong>REPEATABLE READ</strong> (可重复读)</li><li><strong>SERIALIZABLE</strong> (可重复读)</li></ul><p>只要彻底理解了隔离级别以及他的实现原理就相当于理解了ACID里的隔离型。前面说过原子性，隔离性，持久性的目的都是为了要做到一致性，但隔离型跟其他两个有所区别，原子性和持久性是为了要实现数据的可性保障靠，比如要做到宕机后的恢复，以及错误后的回滚。</p><p>那么隔离性是要做到什么呢？ <strong>隔离性是要管理多个并发读写请求的访问顺序。</strong> 这种顺序包括<strong>串行</strong>或者是<strong>并行</strong><br>说明一点，写请求不仅仅是指insert操作，又包括update操作。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2c1c8b5285ee3?w=688&h=233&f=png&s=40492" alt="img"></p><p>总之，从隔离性的实现可以看出这是一场数据的可靠性与性能之间的权衡。</p><ul><li>可靠性性高的，并发性能低(比如 Serializable)</li><li>可靠性低的，并发性能高(比如 Read Uncommited)</li></ul><p><strong>READ UNCOMMITTED</strong></p><p>在READ UNCOMMITTED隔离级别下，事务中的修改即使还没提交，对其他事务是可见的。事务可以读取未提交的数据，造成脏读。</p><p>因为读不会加任何锁，所以写操作在读的过程中修改数据，所以会造成脏读。好处是可以提升并发处理性能，能做到<strong>读写并行</strong>。</p><p>换句话说，读的操作不能排斥写请求。<br><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2ed4dbd348a68?w=4284&h=1288&f=png&s=731191" alt="img"></p><p>优点：读写并行，性能高<br>缺点：造成脏读</p><p><strong>READ COMMITTED</strong></p><p>一个事务的修改在他提交之前的所有修改，对其他事务都是不可见的。其他事务能读到已提交的修改变化。在很多场景下这种逻辑是可以接受的。</p><p>InnoDB在 READ COMMITTED，使用排它锁,读取数据不加锁而是使用了MVCC机制。或者换句话说他采用了<strong>读写分离机制</strong>。<br>但是该级别会产生<strong>不可重读</strong>以及<strong>幻读</strong>问题。</p><blockquote><p>什么是不可重读？</p></blockquote><p>在一个事务内多次读取的结果不一样。</p><blockquote><p>为什么会产生不可重复读？</p></blockquote><p>这跟 READ COMMITTED 级别下的MVCC机制有关系，在该隔离级别下每次 select的时候新<strong>生成一个版本号</strong>，所以每次select的时候读的不是一个副本而是不同的副本。</p><p>在每次select之间有其他事务<strong>更新</strong>了我们读取的数据并提交了，那就出现了不可重复读<br><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f05d63f388d0?w=3612&h=1512&f=png&s=816439" alt="img"></p><p><strong>REPEATABLE READ</strong>(Mysql默认隔离级别)</p><p>在一个事务内的多次读取的结果是一样的。这种级别下可以避免，脏读，不可重复读等查询问题。mysql 有两种机制可以达到这种隔离级别的效果，分别是采用读写锁以及MVCC。</p><p><strong>采用读写锁实现</strong>：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2c351eb03fc24?w=1082&h=290&f=png&s=120400" alt="img"><br>为什么能可重复度？只要没释放读锁，在次读的时候还是可以读到第一次读的数据。</p><p>优点：实现起来简单</p><p>缺点：无法做到读写并行</p><p><strong>采用MVCC实现</strong>：<br><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f054474b394b?w=3584&h=1512&f=png&s=756027" alt="img"></p><p>为什么能可重复度？因为多次读取只生成一个版本，读到的自然是相同数据。</p><p>优点：读写并行</p><p>缺点：实现的复杂度高</p><p>但是在该隔离级别下仍会存在幻读的问题，关于幻读的解决我打算另开一篇来介绍。</p><p><strong>SERIALIZABLE</strong></p><p>该隔离级别理解起来最简单，实现也最单。在隔离级别下除了不会造成数据不一致问题，没其他优点。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f56d34ff739e?w=3528&h=1060&f=png&s=414467" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f69776d551b3?w=2608&h=776&f=png&s=445068" alt="img"></p><p>–摘自《高性能Mysql》</p><h4 id="4-一致性的实现"><a href="#4-一致性的实现" class="headerlink" title="4.一致性的实现"></a>4.一致性的实现</h4><blockquote><p>数据库总是从一个一致性的状态转移到另一个一致性的状态.</p></blockquote><p>下面举个例子:zhangsan 从银行卡转400到理财账户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select balance from bank where name&#x3D;&quot;zhangsan&quot;;</span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 balance&#x3D;600</span><br><span class="line">update bank set balance &#x3D; balance - 400; </span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 amount&#x3D;400</span><br><span class="line">update finance set amount &#x3D; amount + 400;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>1.假如执行完 <code>update bank set balance = balance - 400;</code>之发生异常了，银行卡的钱也不能平白无辜的减少，而是回滚到最初状态。</p><p>2.又或者事务提交之后，缓冲池还没同步到磁盘的时候宕机了，这也是不能接受的，应该在重启的时候恢复并持久化。</p><p>3.假如有并发事务请求的时候也应该做好事务之间的可见性问题，避免造成脏读，不可重复读，幻读等。在涉及并发的情况下往往在性能和一致性之间做平衡，做一定的取舍，所以隔离性也是对一致性的一种破坏。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文出发点是想讲一下Mysql的事务的实现原理。</p><p>实现事务采取了哪些技术以及思想？</p><ul><li>原子性：使用 undo log ，从而达到回滚</li><li>持久性：使用 redo log，从而达到故障后恢复</li><li>隔离性：使用锁以及MVCC,运用的优化思想有读写分离，读读并行，读写并行</li><li>一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>论坛项目过程</title>
      <link href="/2020/11/01/%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/11/01/%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><h4 id="用户表-user"><a href="#用户表-user" class="headerlink" title="用户表 user"></a>用户表 user</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>username</td><td>varchar</td><td>用户名，创建索引</td></tr><tr><td>password</td><td>varchar</td><td>用户密码</td></tr><tr><td>salt</td><td>varchar</td><td>加密盐值</td></tr><tr><td>email</td><td>varchar</td><td>用户邮箱，创建索引</td></tr><tr><td>type</td><td>int</td><td>用户类型：0 普通、1 管理员、2 版主</td></tr><tr><td>status</td><td>int</td><td>用户状态：0 未激活、1 已激活</td></tr><tr><td>activation_code</td><td>varchar</td><td>激活码</td></tr><tr><td>header_url</td><td>varchar</td><td>用户头像地址</td></tr><tr><td>create_time</td><td>timestamp</td><td>注册时间</td></tr></tbody></table><h4 id="评论表-comment"><a href="#评论表-comment" class="headerlink" title="评论表 comment"></a>评论表 comment</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>user_id</td><td>int</td><td>评论的用户 id，创建索引</td></tr><tr><td>entity_id</td><td>int</td><td>评论实体 id，创建索引</td></tr><tr><td>entity_type</td><td>int</td><td>评论实体类型：1 帖子评论、2 评论回复</td></tr><tr><td>target_id</td><td>int</td><td>评论目标 id</td></tr><tr><td>content</td><td>text</td><td>评论内容</td></tr><tr><td>status</td><td>int</td><td>评论状态：0 有效、1 无效</td></tr><tr><td>create_time</td><td>timestamp</td><td>评论发表时间</td></tr></tbody></table><h4 id="帖子表-discuss-post"><a href="#帖子表-discuss-post" class="headerlink" title="帖子表 discuss_post"></a>帖子表 discuss_post</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>user_id</td><td>int</td><td>发帖的用户 id，创建索引</td></tr><tr><td>title</td><td>varchar</td><td>帖子表标题</td></tr><tr><td>content</td><td>text</td><td>帖子内容</td></tr><tr><td>type</td><td>int</td><td>帖子类型：0 普通、1 置顶</td></tr><tr><td>comment_count</td><td>int</td><td>评论数量</td></tr><tr><td>status</td><td>int</td><td>帖子状态：0 普通、1 精华、2 拉黑</td></tr><tr><td>create_time</td><td>timestamp</td><td>评论发表时间</td></tr></tbody></table><h4 id="用户登录凭证表-login-ticket"><a href="#用户登录凭证表-login-ticket" class="headerlink" title="用户登录凭证表 login_ticket"></a>用户登录凭证表 login_ticket</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>user_id</td><td>int</td><td>登录用户 id</td></tr><tr><td>ticket</td><td>varchar</td><td>登录凭证，随机字符串</td></tr><tr><td>status</td><td>int</td><td>登录状态：0 有效、1 无效</td></tr><tr><td>expired</td><td>timestamp</td><td>过期时间</td></tr></tbody></table><h4 id="消息表-message"><a href="#消息表-message" class="headerlink" title="消息表 message"></a>消息表 message</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>from_id</td><td>int</td><td>发消息的 id，创建索引</td></tr><tr><td>to_id</td><td>int</td><td>收消息的 id，创建索引</td></tr><tr><td>conversation_id</td><td>varchar</td><td>会话 id，由通信双方 id 拼接，创建索引</td></tr><tr><td>content</td><td>text</td><td>消息内容</td></tr><tr><td>status</td><td>int</td><td>消息状态：0 未读、1 已读、2 删除</td></tr><tr><td>create_time</td><td>timestamp</td><td>消息发送时间</td></tr></tbody></table><hr><h2 id="开发社区首页"><a href="#开发社区首页" class="headerlink" title="开发社区首页"></a>开发社区首页</h2><h3 id="搭建基本环境"><a href="#搭建基本环境" class="headerlink" title="搭建基本环境"></a>搭建基本环境</h3><p>构建 SpringBoot 的 maven 项目，引入 mysql 和 mybatis 依赖。</p><hr><p>在 <code>application.properties</code> 配置文件中：</p><ul><li>关闭 thymeleaf 缓存</li><li>配置数据库，设置基本连接信息、最大线程数，最小空闲线程数，最大空闲时间等</li><li>mybatis，设置 mapper 文件的位置、实体类包名、使用主键等</li></ul><hr><p>创建 community 数据库和数据库表。</p><hr><p>用户相关操作：</p><ul><li>创建对应 user 表的 User 实体类</li><li>创建 UserMapper 接口，使用 <code>@Mapper</code> 注解</li><li>创建 user-mapper.xml，重复 sql 语句可以写在 <code>&lt;sql id = &quot;xxx&quot;&gt;</code> 标签，通过 <code>&lt;include refid=&quot;xxx&quot;/&gt;</code> 引用。</li></ul><hr><h3 id="开发社区首页（discuss-post-表）"><a href="#开发社区首页（discuss-post-表）" class="headerlink" title="开发社区首页（discuss_post 表）"></a>开发社区首页（discuss_post 表）</h3><p>功能拆分：开发社区首页，显示前 10 个帖子。开发分页组件，分页显示所有帖子。</p><p>用到的表是 discuss_post 数据库表，包括帖子 id、发帖人 id、标题、内容、类型、状态、发帖时间、评论数量（为了提高效率，避免关联查询，因此冗余存储）、分数（用于进行热度排名）。</p><h4 id="开发数据层"><a href="#开发数据层" class="headerlink" title="开发数据层"></a>开发数据层</h4><p>帖子相关操作：</p><ul><li><p>创建对应 discuss_post 表的 DisscussPost 实体类。</p></li><li><p>创建 DisscussPostMapper 接口，使用 <code>@Mapper</code> 注解。</p><ul><li>分页查询中用户 id 是可选参数，通过动态 SQL 选择，如果为 0 就不使用，在开发用户个人主页查询用户发帖记录时需要使用。</li><li>如果只有一个参数，并且在动态 SQL 的 <code>&lt;if&gt;</code> 里使用，必须使用 <code>@Param</code> 加别名。</li></ul></li><li><p>创建 <code>disscusspost-mapper.xml</code>。</p><ul><li><p><code>where status != 2</code> 拉黑的帖子不展现。</p></li><li><p><code>&lt;if test=&quot;userId!=0&quot;&gt;</code>  userID 为 0 时不使用，按照类型，发帖时间排序。</p></li></ul></li></ul><hr><h4 id="开发业务层"><a href="#开发业务层" class="headerlink" title="开发业务层"></a>开发业务层</h4><p>创建 DiscussPostService 类，可以分页查询帖子和帖子数量。</p><p>创建 UserService 类，实现根据 id 查询用户功能，因为显示帖子时不显示用户 id，而是显示用户名。</p><hr><h4 id="开发视图层"><a href="#开发视图层" class="headerlink" title="开发视图层"></a>开发视图层</h4><p>把静态资源 css、html、img、js 放到 static 目录下。</p><p>把模板 mail、site、index.html 放到 template 目录下。</p><p>创建 HomeController，<code>getIndexPage</code> 方法，用 map 集合把帖子和用户封装到一起。</p><p>修改 <code>index.html</code>，使用 <code>&lt;th:text=&quot;${map.xxx.xxx}&quot;</code> 动态替换。</p><p>【问题】使用帖子关联查询用户时，给查询用户的 <code>findUserById</code> 方法传入了帖子的 <code>getId</code> 方法，应该是 <code>getUserId</code> 方法。</p><hr><h4 id="开发分页组件"><a href="#开发分页组件" class="headerlink" title="开发分页组件"></a>开发分页组件</h4><p>创建 Page 实体类，封装分页信息，包括当前页码、显示限制、帖子总数、查询路径等。显示的起始页不能小于 1，最大页不能超过 total。</p><p>在 <code>index.html</code> 中，当 <code>page.rows &gt; 0</code> 时显示分页信息。</p><p>如果 <code>page.current</code>  等于 1 或 <code>page.total</code>，代表是首页或末页，此时不能点击上一页和下一页，用 <code>disabled</code> 属性实现。</p><hr><h2 id="开发注册登录模块"><a href="#开发注册登录模块" class="headerlink" title="开发注册登录模块"></a>开发注册登录模块</h2><hr><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>在新浪邮箱打开 SMTP 服务。</p><p>引入 <code>spring-boot-starter-mail</code> 依赖。</p><p>在配置文件配置主机、端口、发送邮箱、授权码等。</p><p>创建 MailClient 类，调用 JavaMailSender 发送邮件。</p><p>使用 thymeleaf 发送 HTML 邮件，调用 TemplateEngine 把信息封装到 HTML 模板。</p><p>【问题】发送邮件成功但没接收到，在垃圾箱中可找到。</p><hr><h3 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h3><p>把 register.html 地址关联到首页的注册 href 属性。</p><p>设置域名、创建 CommunityUtil 工具类，在工具类创建生产随机字符串和 MD5 加密方法。</p><p>创建 LoginController，创建 <code>getRegisterPage</code> 方法，跳转注册页面。</p><p>在 UserService 中创建 <code>register</code> 方法，判断注册信息合规后插入数据库，发送激活邮件。</p><p>在 LoginController 创建 <code>register</code> 方法，调用 UserService 的 <code>register</code> 方法。</p><p>创建接口 CommunityConstant，定义激活码的三种状态，成功、重复、失败，让 UserService 和 LoginController 实现该接口。</p><p>点击激活邮件的 url 【本地服务器的url】后，服务器通过 LoginController 的 <code>activation</code> 方法查询数据库用户，如果 url 中的激活码和设置的一样，就把用户 status 改为 1。</p><hr><h3 id="生成验证码"><a href="#生成验证码" class="headerlink" title="生成验证码"></a>生成验证码</h3><p>在 <code>pom.xml</code> 导入 kaptcha 的 jar 包。</p><p>创建配置类 KaptchaConfig，设置验证码的大小、范围、长度等。</p><p>在 LoginController 类新增 <code>getKaptcha</code> 方法生成验证码图片。</p><p>在 <code>login.html</code> 中，将刷新验证码的链接绑定 <code>refresh_kaptcha</code> 方法，通过 id 选择器获取 img 组件，重新访问  <code>getKaptcha</code> 方法生成验证码图片。</p><p>【问题】由于访问同一个生成验证码路径，需要在 url 参数加上一个随机数字，保证会重新请求获取新图片。</p><hr><h3 id="登录退出功能（login-ticket-表）"><a href="#登录退出功能（login-ticket-表）" class="headerlink" title="登录退出功能（login_ticket 表）"></a>登录退出功能（login_ticket 表）</h3><p>登录成功时，需要生成一个登录凭证发送给客户端。凭证可以在多个业务中连续地验证用户的登陆状态，凭证信息存储在 login_ticket 数据库表中，status 的 0 和 1 表示有效和无序，expire 表示过期时间。</p><p>创建对应 login_ticket 表的 LoginTicket 实体类，对应 login_ticket 数据库表。</p><p>创建 LoginTicketMapper 接口，通过 <code>@Insert</code>、<code>@Select</code>、<code>@Update</code> 注解来插入、查询、更新凭证。</p><p>在 UserServce </p><ul><li><p>创建 <code>login</code> 方法，验证账户合规后将凭证信息插入数据库，添加登录凭证到 map 中。</p></li><li><p>创建 <code>logout</code> 方法，将对应凭证设为无效。</p></li></ul><p>在 LoginController </p><ul><li><p>创建 <code>login</code> 方法，判断验证码正确后调用  UserServce 的 <code>login</code> 方法，如果 map 包含 ticket 代表登录成功，重定向跳转首页，否则添加错误信息并跳回登录页。</p></li><li><p>创建 <code>logout</code> 方法，判断验证码正确后调用  UserServce 的<code>logout</code> 方法，跳转至登录页。</p></li></ul><p>在 <code>login.html</code> 绑定登录链接，<code>index.html</code> 绑定退出登录链接。</p><p>【问题】登录成功后，创建了凭证，但忘记将凭证信息插入数据库。</p><hr><h3 id="显示登录信息"><a href="#显示登录信息" class="headerlink" title="显示登录信息"></a>显示登录信息</h3><p>创建 CookieUtil 工具类，通过 name 查询对应 cookie 的 value。</p><p>在 UserService 中新增 <code>findLoginTicket</code> 方法，根据 ticket 查询 LoginTicket。</p><p>创建 HostHolder 类用来模拟 session 的功能，利用 ThreadLocal 实现，存储用户信息。</p><p>创建 LoginTicketInterceptor 拦截器，实现 HandlerInterceptor 接口。</p><ul><li>在 <code>preHandle</code> 方法中通过 CookieUtil 的 <code>getValue</code> 方法查询是否有凭证 cookie，如果有则通过 UserService 的  <code>findloginTicket</code> 方法查询用户 ID，再通过用户 ID 查询用户。最后将用户放入 hostHolder 中。</li><li>在 <code>postHandle</code> 方法中通过 hostHolder 的 <code>get</code> 方法获取用户，并将其存入视图中。</li><li>在 <code>afterCompletion</code> 方法中清除 hostHolder 中存放的用户信息。</li></ul><p>创建 WebMvcConfig 配置类，实现 WebMvcConfigurer接口，配置 LoginTicketInterceptor，拦截除了静态资源之外的所有路径。</p><hr><h3 id="上传头像"><a href="#上传头像" class="headerlink" title="上传头像"></a>上传头像</h3><p>在 UserService 新增 <code>updateHeader</code> 方法，更改指定用户的头像。</p><p>创建 UserController</p><ul><li><p>新增 <code>getSettingPage</code> 方法访问账户设置 <code>setting.html</code> ，并在 <code>index.html</code> 的账号设置按钮关联该链接。</p></li><li><p>新增 <code>uploadHeader</code> 方法更新用户头像，如果上传出现错误将错误信息存在 Model 对象中。</p><p>如果没有错误，生成一个文件对象 dest，利用 MultipartFile 接口的 <code>transferTo</code> 方法将用户上传文件导入 dest，并从 hostHolder 中取出用户，更新用户的头像路径。</p></li><li><p>新增 <code>getHeader</code> 方法获取用户头像，利用文件输入流读取图片数据，利用 HttpServletResponse 的字节输出流再进行输出。</p></li></ul><p>调整 <code>setting.html</code> 的 form 表单， method=”post”，enctype=”multipart/form-data”，并设置提交路径。</p><hr><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>在 UserService 中新增 <code>changePassword</code> 方法，判断原密码是否正确，正确则修改密码并返回 1，否则返回 0。</p><p>在 UserController 中新增 <code>changePassword</code> 方法，根据 UserService 的  <code>changePassword</code> 方法的返回值判断原密码是否成功修改，封装为 JSON 数据并返回。</p><p>在 <code>setting.html</code> 中</p><ul><li>首先在前端判断两次输入的新密码是否一致，如果不一致不允许点击提交并显示错误信息。</li><li>利用 ajax 向 UserController 的  <code>changePassword</code> 方法发送 POST 请求，得到 JSON 数据并解析，如果状态码为 0 提示错误，如果状态码为 1 弹出修改成功提示。</li></ul><p>【问题】js 的虚拟路径问题，需要加上 <code>../</code>。</p><p>【问题】使用 ajax 请求时，表单按钮类型必须是 button，不能是 submit，否则 405 报错。</p><p>【问题】使用 ajax 请求时，Controller 中方法的返回值必须是 JSON 数据，并且需要加上 <code>@ResponseBody</code>。</p><p>【问题】使用 ajax 请求时，回调函数需要先对返回的 JSON 数据进行解析再使用。</p><hr><h3 id="检查登录状态"><a href="#检查登录状态" class="headerlink" title="检查登录状态"></a>检查登录状态</h3><p>利用拦截器，实现只处理带有自定义注解的方法，防止用户在未登录情况下通过 url 访问没有权限的页面。</p><p>创建 <code>@LoginRequired</code> 自定义注解，作用范围在方法上，有效期为运行时。</p><p>在 UserController 中需要在登录状态下调用的方法，访问设置页面、修改密码、上传头像等加上自定义注解。</p><p>创建 LoginRequiredInterceptor 拦截器，在 <code>preHandle</code> 方法中判断方法是否加了 <code>@LoginRequired</code> 注解，如果加了注解并且此时从 hostHolder 中获取不到用户则拒绝访问。</p><p>在 WebMvcConfig 配置类配置 LoginRequiredInterceptor，拦截除了静态资源之外的所有路径。</p><hr><h2 id="开发核心功能"><a href="#开发核心功能" class="headerlink" title="开发核心功能"></a>开发核心功能</h2><h3 id="敏感词过滤"><a href="#敏感词过滤" class="headerlink" title="敏感词过滤"></a>敏感词过滤</h3><p>利用字典树数据结构解决。</p><p>创建 SensitiveFilter 类</p><ul><li>创建静态内部类 TrieNode ，通过 boolean 类型的结束符判断是否匹配到关键字尾部。</li><li>利用 <code>@PostConstruct</code> 注解，在构造方法执行后初始化字典树。</li><li>添加 <code>filter</code> 方法，利用双指针进行匹配，过滤敏感词。</li></ul><p>【问题】判断子节点空时，直接添加了一个 new 的子节点，没有将对象赋值给子节点变量。</p><hr><h3 id="发布帖子"><a href="#发布帖子" class="headerlink" title="发布帖子"></a>发布帖子</h3><p>引入 fastjson 依赖，在 CommunityUtil 中新增 <code>getJSONString</code> 方法封装 JSON 信息。</p><p>在 DisscussPostMapper 接口新增 <code>insertDiscussPost</code> 方法，并在 <code>disscusspost-mapper.xml</code> 配置 insert 语句。</p><p>在 DiscussPostService 新增 <code>addDiscussPost</code> 方法调用 DisscussPostMapper 的 <code>insertDiscussPost</code> 方法，其中需要进行对标题内容和发帖内容进行 HTML 转义以及过滤敏感词。</p><p>创建 DiscussPostController 类，新增 <code>addDiscussPost</code> 方法，调用 DiscussPostService 的 <code>addDiscussPost</code> 方法发帖。</p><p>在 <code>index.html</code> 中为发帖按钮绑定函数，利用 Ajax 向 DiscussPostController 的 <code>addDiscussPost</code> 方法发送 POST 请求。</p><hr><h3 id="显示帖子内容"><a href="#显示帖子内容" class="headerlink" title="显示帖子内容"></a>显示帖子内容</h3><p>在 DisscussPostMapper 接口新增 <code>selectDiscussPostById</code> 方法，在 <code>disscusspost-mapper.xml</code> 配置 select 语句。</p><p>在 DiscussPostService 新增 <code>findDiscussPostById</code> 方法调用 DisscussPostMapper 的 <code>selectDiscussPostById</code> 方法。</p><p>在 DiscussPostController 新增 <code>getDiscussPost</code> 方法，调用 DiscussPostService 的 <code>findDiscussPostById</code> 方法查询帖子内容，将 DiscussPost 对象和 User 对象（通过 userId 查询，不在 DAO 层关联查询）数据存放到 Model 对象，返回模板 <code>discuss-detail</code>。</p><p>在 <code>discuss-detail.html</code> 取出 Model 对象存放的数据绑定到对应组件显示。</p><hr><h3 id="显示评论（comment-表）"><a href="#显示评论（comment-表）" class="headerlink" title="显示评论（comment 表）"></a>显示评论（comment 表）</h3><p>创建 comment 表对应的实体类 Comment。</p><p>创建 CommentMapper 接口</p><ul><li>新增 <code>selectCommentsByEntity</code> 方法，根据实体查询一页的评论数据。</li><li>新增 <code>selectCountByEntity</code> 方法，根据实体查询评论的数量。</li><li>在 <code>comment-mapper.xml</code> 配置 select 语句。</li></ul><p>创建 CommentService 类</p><ul><li>新增 <code>findCommentByEntity</code> 方法，调用 CommentMapper 的 <code>selectCommentByEntity</code> 方法。</li><li>新增 <code>findCommentCount</code> 方法，调用 CommentMapper 的 <code>selectCountByEntity</code> 方法。</li></ul><p>在 DiscussPostController 的 <code>getDiscussPost</code> 方法中增加查询帖子评论和回复的逻辑，将结果存储在 Model 对象。</p><p>【问题】sql 的 xml 文件中绑定参数时，应传入实体类属性名，拼错成数据库字段名（entityId 写成 entity_id）。</p><hr><h3 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h3><p>在 CommentMapper 接口新增 <code>insertComment</code> 方法，添加评论数据，在 <code>comment-mapper</code> 配置对应 sql。</p><p>在 DiscussPostMapper 接口新增 <code>updateCommentCount</code> 方法，增加评论数量，在 <code>discusspost-mapper</code> 配置对应 sql。</p><p>在 DiscussPostService 类新增 <code>updateCommentCount</code> 方法，调用 DiscussPostMapper 的 <code>updateCommentCount</code> 方法。</p><p>在 CommentService 类新增 <code>addComment</code> 方法，调用 CommentMapper 的 <code>insertComment</code> 新增评论，并调用 DiscussPostService 的 <code>updateCommentCount</code> 更新评论数量，使用 <code>@Transactional</code> 注解保证事务。</p><p>创建 CommentController 类，新增 <code>addComment</code> 方法，从 hostHolder 获取用户信息，然后调用 CommentService 的 <code>addComment</code> 方法添加评论。</p><p>【问题】sql 的 xml 文件中绑定参数时，应传入实体类属性名，拼错成数据库字段名（entityId 写成 entity_id）。</p><hr><h3 id="显示私信列表-（message-表）"><a href="#显示私信列表-（message-表）" class="headerlink" title="显示私信列表 （message 表）"></a>显示私信列表 （message 表）</h3><p>创建对应 message 表的实体类 Message。</p><p>创建 MessageMapper 接口，增加查询会话列表、会话数量、私信列表、私信数量、未读私信数量等方法，在 <code>message-mapper.xml</code> 中配置对应的 sql。</p><p>创建 MessageService，调用 MessageMapper 中的方法。</p><p>创建 MessgaeController</p><ul><li>新增 <code>getLetterList</code> 方法，将会话列表信息存储到 Model 对象，返回 <code>letter</code> 视图。</li><li>新增 <code>getLetterDetail</code> 方法，将每个会话具体的私信信息存储到 Model 对象，返回 <code>letter-datail</code> 视图。</li></ul><hr><h3 id="发送私信"><a href="#发送私信" class="headerlink" title="发送私信"></a>发送私信</h3><p>在 MessageMapper </p><ul><li>新增 <code>insertMessage</code> 方法插入私信记录，在 <code>message-mapper.xml</code>  配置 insert 语句。</li><li>新增 <code>updateMessgae</code> 方法修改私信状态，在 <code>message-mapper.xml</code>  配置 update 语句，利用 foreach 动态 sql。</li></ul><p>在 MessageService</p><ul><li><p>新增 <code>addMessage</code> 发送私信方法，过滤敏感词后，调用 MessageMapper 的 <code>insertMessage</code> 。</p></li><li><p>新增 <code>readMessage</code> 方法读取信息，调用MessageMapper 的 <code>updateMessgae</code> 更新私信的状态为 1。</p></li></ul><p>在 MessageController </p><ul><li><p>新增 <code>getLetterIds</code> 方法，将私信集合中未读私信的 id 添加到 List 集合并返回，在 <code>getLetterDetail</code> 方法调用该方法设置已读。</p></li><li><p>新增 <code>sendLetter</code> 发送私信方法，设置私信信息后调用 MessageService 的 <code>addMessage</code> 发送。</p></li></ul><hr><h3 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h3><p>在 HomeController 中增加 <code>getErrorPage</code> 方法，返回错误页面。</p><p>创建 ExceptionAdvice 类</p><ul><li>加上 <code>@ControllerAdvice</code> 注解，表示该类是 Controller 的全局配置类。</li><li>创建 <code>handleException</code> 方法，加上 <code>@ExceptionHandler</code> 注解，该方法在 Controller 出现异常后调用，处理捕获异常。如果是异步请求返回一个 JSON 数据，否则重定向至 HomeController 的 <code>getErrorPage</code> 方法。</li></ul><hr><h3 id="统一日志处理"><a href="#统一日志处理" class="headerlink" title="统一日志处理"></a>统一日志处理</h3><p>在 <code>pom.xml</code> 引入 aspectj 的依赖。</p><p>创建 ServiceLogAspect 类，添加 <code>@Aspect</code> 切面注解，配置切入点表达式，拦截所有 service 包下的方法，利用 <code>@Before</code> 记录日志。</p><hr><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>创建 RedisKeyUtil 工具类</p><ul><li>定义分隔符 <code>:</code> 以及实体获得赞的 key 前缀常量 <code>like:entity</code>。</li><li>新增 <code>getEntityLikeKey(int entityType,int entityId)</code> 方法，通过实体类型和实体 id 生成对应实体获得赞的 key。</li></ul><p>创建业务层的 LikeService 类</p><ul><li><p>注入 RedisTemplate 实例。</p></li><li><p>新增 <code>like</code> 点赞方法，首先通过 RedisKeyUtil 工具类的  <code>getEntityLikeKey</code> 方法获得实体点赞的 key，然后通过 RedisTemplate 对象对 set 集合的 <code>isMember</code> 方法查询 userId 是否存在于对应 key 的 set 集合中，如果存在则移除出点赞的用户集合，如果不存在则添加到点赞的用户集合。</p></li><li><p>新增 <code>findEntityLikeCount</code> 方法查询实体的点赞数量，通过调用 set 集合的 <code>size</code> 方法查询元素个数。</p></li><li><p>新增 <code>findEntityLikeStatus</code> 方法查询某用户对某实体的点赞状态，逻辑如 <code>like</code> 方法，通过 set 集合的 <code>isMember</code> 方法实现。</p></li></ul><p>创建表现层的 LikeController 类</p><ul><li>注入 LikeService 和 HostHolder 实例。</li><li>新增 <code>like</code> 点赞方法，调用业务层的 <code>like</code> 方法进行点赞、调用  <code>findEntityLikeCount</code> 和 <code>findEntityLikeStatus</code>  查询点赞数量和点赞状态，封装到 map 集合，然后通过工具类封装成 JSON 数据返回。</li></ul><p>（更新首页帖子点赞数量）在表现层的 HomeController 类</p><ul><li>注入 LikeService 实例。</li><li>在 <code>getIndexPage</code> 方法在通过 LikeService 类的方法获得点赞数量，存储到 map 集合。</li></ul><hr><h3 id="收到的赞"><a href="#收到的赞" class="headerlink" title="收到的赞"></a>收到的赞</h3><p>对点赞功能进行重构</p><p>在 RedisUnitl 工具类</p><ul><li><p>新增用户获得赞 key 的前缀常量 <code>like:user</code></p></li><li><p>新增 <code>getUserLikeKey(int userId)</code> 方法，通过用户 id 生成对应用户获得赞的 key。</p></li></ul><p>在 LikeService 中</p><ul><li><p>重构 <code>like</code> 方法，在参数列表中加入 entityUserId 表示被点赞用户的 id，用来更新用户的被点赞数量。</p><ul><li><p>通过 RedisTemplate 对象的 <code>execute</code> 方法实现事务，保证被点赞用户点和点赞用户的数据更新一致。通过 <code>isMember</code> 方法查询用户的点赞状态，之后通过 <code>mutli</code> 方法开启事务。</p></li><li><p>当用户已点赞时，调用 <code>remove</code> 方法将当前用户从点赞用户的集合中移除，调用 <code>decrement</code> 方法将被点赞用户的被点赞数减 1；当用户未点赞时，调用 <code>add</code> 方法将当前用户添加到点赞用户的集合，调用 <code>increment</code> 方法将被点赞用户的被点赞数加 1。</p></li></ul></li><li><p>增加 <code>findUserLikeCount</code> 方法，以用户 id 作为 key，调用 <code>get</code> 方法查询用户所获得的点赞数。</p></li></ul><p>在 LikeController 中给 <code>like</code> 方法增加 entityUserId 参数即可。</p><hr><h3 id="关注"><a href="#关注" class="headerlink" title="关注"></a>关注</h3><p>在 RedisUnitl 工具类</p><ul><li><p>新增用户关注实体（帖子、评论、用户等）和粉丝（用户）的前缀常量 <code>followee</code> 和 <code>follower</code></p></li><li><p>新增 <code>getFolloweeKey(int userId, int entityType)</code> 方法，通过用户 id 和实体类型生成用户关注实体的 key。</p></li><li><p>新增 <code>getFollowerKey(int entityType, int entityId)</code> 方法，通过实体类型和实体 id 生成实体用户粉丝的 key。</p></li></ul><p>创建业务层的 FollowService 类</p><ul><li>新增 <code>follow</code> 方法，当用户关注某实体时，<ul><li>调用 <code>add</code> 方法将当前实体 id  和时间作为 value 和 score加入用户的关注集合。</li><li>调用 <code>add</code> 方法将当前用户 id 和时间作为 value 和 score 加入实体的粉丝集合。</li></ul></li><li>新增 <code>unfollow</code> 方法，当用户取消关注某实体时，<ul><li>调用 <code>remove</code> 方法将当前实体从用户的关注集合移除。</li><li>调用 <code>remove</code> 方法将用户从实体的粉丝集合移除。</li></ul></li></ul><hr><h3 id="个人主页"><a href="#个人主页" class="headerlink" title="个人主页"></a>个人主页</h3><p>在业务层的 FollowService 类</p><ul><li>新增 <code>findFolloweeCount</code> 方法，调用 zset 的 <code>zcard</code>  方法查询某用户关注的实体数量。</li><li>新增 <code>findFollowerCount</code> 方法，调用 zset 的 <code>zcard</code>  方法查询某实体的粉丝数量。</li><li>新增 <code>hasFollowed</code> 方法，根据 zset 的 <code>zscore</code>  方法返回值查询当前用户是否关注某实体。</li></ul><p>在 UserController 中新增 <code>getProfilePage</code> 方法获取个人主页。</p><ul><li>调用 LikeService 的  <code>findUserLikeCount</code> 查询用户获赞数，并添加到 Model 中。</li><li>调用 FollowService 的<code>findFolloweeCount</code>、<code>findFollowerCount</code> 、<code>hasFollowed</code> 方法分别查询关注数量、粉丝数量、用户是否关注三项信息并添加到 Model 对象中存储。</li></ul><hr><h3 id="关注列表和粉丝列表"><a href="#关注列表和粉丝列表" class="headerlink" title="关注列表和粉丝列表"></a>关注列表和粉丝列表</h3><p>在业务层的 FollowService 类</p><ul><li>新增 <code>findFollowees</code> 方法，查询用户关注列表，主要通过 zset 的  <code>reverseRange</code> 获取 value 即关注用户的 userId，再查询出其 user，之后通过 <code>score</code> 获取关注时间，存入 map 集合，将 map 添加到 list 列表返回。</li><li>新增 <code>findFollowers</code> 方法，查询用户粉丝列表，主要通过 zset 的  <code>reverseRange</code> 获取 value 即粉丝的 userId，再查询出其 user，之后通过 <code>score</code> 获取关注时间，存入 map 集合，将 map 添加到 list 列表返回。</li></ul><p>在表现层的 FollowController 类</p><ul><li>新增 <code>getFollowees</code> 方法，获取关注列表，存入 Model 对象。</li><li>新增 <code>getFollowers</code> 方法，获取粉丝列表，存入 Model 对象。</li></ul><hr><h3 id="优化登录模块"><a href="#优化登录模块" class="headerlink" title="优化登录模块"></a>优化登录模块</h3><p><strong>存储验证码</strong></p><p>在 RedisUntil 工具类</p><ul><li>新增验证码前缀常量 <code>kaptcha</code></li><li>新增 <code>getKaptchaKey</code> 方法，通过一个用户凭证（由于未登录，利用 cookie 实现）获得对应验证码的 key 值（利用 string 存储验证码）。</li></ul><p>在表现层的 LoginController 类</p><ul><li>重构 <code>getKaptcha</code> 方法，将验证码存入 redis，key 值是当前随机生成的一个字符串，同时将该字符串存入 cookie。</li><li>重构 <code>login</code> 方法，从 cookie 中获得随机字符串，生成验证码的 key 值，然后获取对应的 value 值即验证码。</li></ul><hr><p><strong>存储登录凭证</strong></p><p>在 RedisUntil 工具类</p><ul><li>新增登录凭证前缀常量 <code>ticket</code></li><li>新增 <code>getTicketKey</code> 方法，通过字符串获得登录凭证的对应 key 值（利用 string 存储）。</li></ul><p>在业务层的 UserService 类</p><ul><li>重构 <code>login</code> 方法，将登录凭证存入 redis 中。</li><li>重构 <code>logout</code> 方法，先从 redis 中获取登录凭证对象，将状态设为无效再重新存储进 redis。</li><li>重构 <code>findLoginTicket</code> 方法，根据 ticket 字符串获得对应登录凭证的 key，然后从 redis 查询登录凭证。</li></ul><hr><p><strong>缓存用户信息</strong></p><p>在 RedisUntil 工具类</p><ul><li>新增用户前缀常量 <code>user</code></li><li>新增 <code>getUserKey</code> 方法，通过用户 id 获得用户的对应 key 值（利用 string 存储）。</li></ul><p>在业务层的 UserService 类</p><ul><li><p>新增 <code>getCache</code>，从缓存获取用户信息。</p></li><li><p>新增 <code>initCache</code>，从 MySQL 查询用户信息并存入 redis。</p></li><li><p>新增 <code>clearCache</code>，用户信息变更（更新头像，激活）时清除缓存。</p></li><li><p>重构 <code>findUserById</code> 方法，首先调用 <code>getCache</code>从缓存获取用户信息，如果获取为 null 则调用 <code>initCache</code>。</p></li></ul><hr><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="发送系统通知"><a href="#发送系统通知" class="headerlink" title="发送系统通知"></a>发送系统通知</h3><p>在 CommunityConstant 接口中新增三个常量，代表三个主题：评论、点赞、关注。</p><p>创建 Event 类，封装事件对象，包括主题、用户 id、实体类型、实体 id、实体用户 id 以及一个 map 集合存放其它信息。</p><h4 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h4><p>创建 EventProducer 事件生产者，新增 <code>fireEvent(Event event)</code> 方法，通过 Event 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 KafkaTemplate 实例的 send 方法发送。</p><p>在 CommentController、LikeControler、FollowController 中注入 EventProducer 实例，分别重构 <code>addComment</code> 方法、<code>like</code> 方法、<code>follow</code> 方法，封装 Event 对象，然后调用 EventProducer 的<code>fireEvent</code> 方法发布通知。</p><h4 id="消费事件"><a href="#消费事件" class="headerlink" title="消费事件"></a>消费事件</h4><p>创建 EventConsumer 事件消费者，消费者是被动触发的。</p><ul><li>注入 MessageService 实例。</li><li>增加 <code>handleCommentMessage(ConsumerRecord record)</code> 方法，通过 <code>@KafkaListener</code> 注解，topic 包括了评论、点赞和关注。从 recored 中获取信息，封装成 Message 对象然后调用 <code>addMessage</code> 方法插入数据库。</li></ul><p>【问题】没有向数据库插入系统通知记录，原因是 ServiceLogAspect 类进行日志处理时要获取 ServletRequestAttributes 请求对象，Kafka 的消费事件是自动触发的，没有进行新的请求，产生了请求对象的空指针异常。</p><hr><h3 id="显示系统通知"><a href="#显示系统通知" class="headerlink" title="显示系统通知"></a>显示系统通知</h3><h4 id="通知列表"><a href="#通知列表" class="headerlink" title="通知列表"></a>通知列表</h4><p>在 MessageMapper 接口中</p><ul><li><p>新增 <code>selectLatestNotice(int userId, String topic)</code> 方法，查询某主题最新的通知。</p></li><li><p>新增 <code>selectNoticeCount(int userId, String topic)</code> 方法，查询某主题通知的数量。</p></li><li><p>新增 <code>selectNoticeUnreadCount(int userId, String topic)</code> 方法，查询未读通知的数量。</p></li><li><p>在 <code>message-mapper.xml</code> 配置三个方法的 sql 语句，其中查询未读通知时使用 if 动态语句，如果没有传入 topic 就查询未读总量。</p></li></ul><p>在业务层的 MessageService 中</p><ul><li>新增 <code>findLatestNotice</code> 方法，调用 <code>selectLatestNotice</code> 方法查询最新通知。</li><li>新增 <code>findNoticeCount</code> 方法，调用 <code>selectNoticeCount</code> 方法查询某主题通知的数量。</li><li>新增 <code>findNoticeUnreadCount</code> 方法，调用 <code>selectNoticeUnreadCount</code> 方法查询未读通知的数量。</li></ul><p>在表现层的 MessageController 中新增 <code>getNoticeList</code> 方法，获取通知列表</p><ul><li>调用业务层 MessageService 的方法查询评论、点赞、关注的通知，将其封装在一个 HashMap 集合中然后添加到 Model 对象里。</li><li>调用业务层 MessageService 的方法查询私信和通知的总未读数量，添加到 Model 对象里。</li><li>返回 <code>notice.html</code> 页面。</li></ul><hr><h4 id="显示通知详情"><a href="#显示通知详情" class="headerlink" title="显示通知详情"></a>显示通知详情</h4><p>在 MessageMapper 接口新增 <code>selectNotices</code> 方法，查询某个主题的通知列表，在 <code>message-mapper.xml</code> 配置 SQL。</p><p>在业务层的 MessageService 中新增 <code>findNotices</code> 方法，调用 <code>selectNotices</code> 方法。</p><p>在表现层的 MessageController 中新增 <code>getNoticeDetail</code> 方法</p><ul><li>调用 <code>findNotices</code> 方法获取通知列表详情，封装到 List 集合并存入 Model 对象。</li><li>从通知集合中获取 id 集合，调用 <code>readMessage</code> 方法将消息设为已读。</li><li>返回 <code>notice-detail.html</code> 页面。</li></ul><hr><h4 id="显示未读通知总数"><a href="#显示未读通知总数" class="headerlink" title="显示未读通知总数"></a>显示未读通知总数</h4><p>创建 MessageInterceptor 拦截器</p><ul><li>注入 MessageService 实例和 HostHolder 实例。</li><li>重写 <code>postHandle</code> 方法，查询私信和通知的未读数量和，然后添加到 ModelAndView 对象。</li></ul><p>在 WebConfig 中注入 MessageInterceptor 实例，并在 <code>addInterceptors</code> 方法中添加该拦截器。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>论坛的总结和改进</title>
      <link href="/2020/11/01/%E8%AE%BA%E5%9D%9B%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%94%B9%E8%BF%9B/"/>
      <url>/2020/11/01/%E8%AE%BA%E5%9D%9B%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%94%B9%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2020/11/01/%E8%AE%BA%E5%9D%9B%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%94%B9%E8%BF%9B/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201115163502330.png" alt="image-20201115163502330"></p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><strong>用户表</strong>，包括 id、用户名、密码、盐值、邮箱、类型（普通/管理员/版主）、状态（激活/未激活）、激活码（随机字符串）、头像 url、注册时间。</p><p><strong>登录凭证表</strong>，包括 id、用户 id、登陆凭证（随机字符串）、登录状态（有效/无效）、过期时间。</p><p><strong>评论表</strong>，包括 id、评论用户 id（索引）、评论实体 id（索引）、评论类型（帖子/回复）、被评论目标 id、评论内容、评论状态（有效/无效）、评论时间。</p><p><strong>帖子表</strong>，包括 id、发帖用户 id（索引）、标题、帖子内容、类型（普通/置顶）、评论数量、状态（普通/精华/拉黑）、发帖时间。</p><p><strong>消息表</strong>，包括 id、发消息 id（索引）、收消息 id（索引）、会话 id（由发消息双方 id 拼接，索引）、内容、状态（未读/已读/删除）、发消息时间。</p><hr><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p><strong>判断注册合法性</strong></p><ul><li>利用 StringUtils 判断用户名、密码、邮箱是否非空。</li><li>分别通过用户名和邮箱查询是否已经注册（为数据库的用户名和邮箱字段添加索引）。</li></ul><p><strong>通过 <code>set</code> 方法为用户设置各项信息</strong>，包括 MD5 加密后的密码、激活码等，然后插入数据库。</p><p><strong>给用户发送激活邮件</strong></p><ul><li><p>在新浪邮箱打开 SMTP 服务，引入 <code>spring-boot-starter-mail</code> 依赖。</p></li><li><p>在配置文件配置主机（smtp.sina.com）、端口（465）、邮箱、授权码、协议（smtps），设置 smtp.ssl.enable = true。</p></li><li><p>调用 JavaMailSender 的 API 发送邮件，激活 url 由用户 id 和用户的激活码拼接而成。点击激活 url 后由 controller 中的方法进行处理（成功/重复/失败），调用 Model 对象的 <code>addAttribute</code> 方法将结果返回前端。</p></li></ul><hr><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p><strong>生成验证码</strong></p><ul><li><p>引入 kaptcha 依赖，将验证码的大小、范围、长度等属性封装到 Properties 对象，作为参数构造 Config 对象，再用 Config 对象作为 DeafultKaptcha 对象  <code>setConfig</code> 方法的参数为验证码设置属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Producer kaptchaProducer() &#123;</span><br><span class="line">    Properties properties &#x3D; new Properties();</span><br><span class="line">    properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;100&quot;);</span><br><span class="line">    properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;40&quot;);</span><br><span class="line">    properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;32&quot;);</span><br><span class="line">    properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;0,0,0&quot;);</span><br><span class="line">    properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;, &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYAZ&quot;);</span><br><span class="line">    properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;);</span><br><span class="line">    properties.setProperty(&quot;kaptcha.noise.impl&quot;, &quot;com.google.code.kaptcha.impl.NoNoise&quot;);</span><br><span class="line">  </span><br><span class="line">    DefaultKaptcha kaptcha &#x3D; new DefaultKaptcha();</span><br><span class="line">    Config config &#x3D; new Config(properties);</span><br><span class="line">    kaptcha.setConfig(config);</span><br><span class="line">    return kaptcha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在登录的 controller 处理验证码，设置页面的响应类型为 png，通过 ImageIO 的 <code>write</code> 方法将图片输出到浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成验证码</span><br><span class="line">    String text &#x3D; kaptchaProducer.createText();</span><br><span class="line">    BufferedImage image &#x3D; kaptchaProducer.createImage(text);</span><br><span class="line">    &#x2F;&#x2F; 验证码的归属</span><br><span class="line">    &#x2F;&#x2F; 将验证码存入Redis</span><br><span class="line">    &#x2F;&#x2F; 将突图片输出给浏览器</span><br><span class="line">    response.setContentType(&quot;image&#x2F;png&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">    OutputStream os &#x3D; response.getOutputStream();</span><br><span class="line">    ImageIO.write(image, &quot;png&quot;, os);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">    logger.error(&quot;响应验证码失败:&quot; + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>判断验证码正确后，调用业务层处理</strong></p><ul><li>利用 StringUtils 判断用户名、密码是否非空，之后判断用户是否存在、用户是否激活、密码是否正确，将错误信息存到 map 集合。(LoginTicketMapper)</li><li>如果全部合法，为用户生成一个包含过期时间的登录凭证，将凭证存入 redis 和 map 集合。</li></ul><p><strong>根据返回的 map 是否包含登陆凭证判断登陆状态</strong></p><ul><li>如果登录成功，将凭证存入 cookie 并重定向至首页。</li><li>如果登陆失败，将 map 中的错误信息添加到 Model 对象，返回登录页。</li></ul><hr><h3 id="检查登录状态"><a href="#检查登录状态" class="headerlink" title="检查登录状态"></a>检查登录状态</h3><p>只处理带有自定义注解的方法，防止用户在未登录情况下通过 url 访问没有权限的页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface LoginRequired &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 ThreadLocal 创建 HostHolder 类，包括 <code>set</code>、<code>get</code>、<code>remove</code> 方法，模拟 session 存储用户信息。</p><p>通过实现 HandlerInterceptor 接口创建一个拦截器，在 <code>preHandle</code> 方法中通过查询是否有登录凭证的 cookie，如果有则通过登录凭证查询用户 ID，再通过用户 ID 查询用户。最后将用户放入 hostHolder 中，在本次请求中持有用户信息。</p><p>创建 <code>@LoginRequired</code> 自定义注解，作用范围在方法上，有效期为运行时。为需要在登录状态下调用的方法，例如修改密码、上传头像等方法上等加上自定义注解。</p><p>创建拦截器，在 <code>preHandle</code> 中判断方法是否添加了 <code>@LoginRequired</code> 注解，如果加了并且从 hostHolder 获取不到用户则拒绝访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class LoginRequiredInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        if (handler instanceof HandlerMethod) &#123;</span><br><span class="line">            HandlerMethod handlerMethod &#x3D; (HandlerMethod) handler;</span><br><span class="line">            Method method &#x3D; handlerMethod.getMethod();</span><br><span class="line">            LoginRequired loginRequired &#x3D; method.getAnnotation(LoginRequired.class);</span><br><span class="line">            if (loginRequired !&#x3D; null &amp;&amp; hostHolder.getUser() &#x3D;&#x3D; null) &#123;</span><br><span class="line">                response.sendRedirect(request.getContextPath() + &quot;&#x2F;login&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在webMVC中排除掉静态资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">       registry.addInterceptor(alphaInterceptor)</span><br><span class="line">               .excludePathPatterns(&quot;&#x2F;**&#x2F;*.css&quot;, &quot;&#x2F;**&#x2F;*.js&quot;, &quot;&#x2F;**&#x2F;*.png&quot;, &quot;&#x2F;**&#x2F;*.jpg&quot;, &quot;&#x2F;**&#x2F;*.jpeg&quot;)</span><br><span class="line">               .addPathPatterns(&quot;&#x2F;register&quot;, &quot;&#x2F;login&quot;);</span><br></pre></td></tr></table></figure><hr><h3 id="发帖、评论、私信"><a href="#发帖、评论、私信" class="headerlink" title="发帖、评论、私信"></a>发帖、评论、私信</h3><p><strong>敏感词过滤</strong></p><ul><li>创建静态内部类 TrieNode ，通过 boolean 结束符判断是否匹配到关键字尾部。</li><li>利用 <code>@PostConstruct</code> 注解，在构造方法执行后初始化字典树。</li><li>添加 <code>filter</code> 方法，利用双指针进行匹配，过滤敏感词。</li></ul><p><strong>发帖、评论、私信</strong></p><ul><li><p>对内容进行 HTML 转义以及过滤敏感词。</p></li><li><p>将信息插入数据库的帖子/评论/消息表。</p><p>发帖</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;add&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String addDiscussPost(String title, String content) &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line">    if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return CommunityUtil.getJSONString(403, &quot;你还没有登录哦!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DiscussPost post &#x3D; new DiscussPost();</span><br><span class="line">    post.setUserId(user.getId());</span><br><span class="line">    post.setTitle(title);</span><br><span class="line">    post.setContent(content);</span><br><span class="line">    post.setCreateTime(new Date());</span><br><span class="line">    discussPostService.addDiscussPost(post);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int addDiscussPost(DiscussPost post) &#123;</span><br><span class="line">    if (post &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;参数不能为空!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 转义HTML标记</span><br><span class="line">    post.setTitle(HtmlUtils.htmlEscape(post.getTitle()));</span><br><span class="line">    post.setContent(HtmlUtils.htmlEscape(post.getContent()));</span><br><span class="line">    &#x2F;&#x2F; 过滤敏感词</span><br><span class="line">    post.setTitle(sensitiveFilter.filter(post.getTitle()));</span><br><span class="line">    post.setContent(sensitiveFilter.filter(post.getContent()));</span><br><span class="line"></span><br><span class="line">    return discussPostMapper.insertDiscussPost(post);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;insertDiscussPost&quot; parameterType&#x3D;&quot;DiscussPost&quot; keyProperty&#x3D;&quot;id&quot;&gt;</span><br><span class="line">    insert into discuss_post(&lt;include refid&#x3D;&quot;insertFields&quot;&gt;&lt;&#x2F;include&gt;)</span><br><span class="line">    values(#&#123;userId&#125;,#&#123;title&#125;,#&#123;content&#125;,#&#123;type&#125;,#&#123;status&#125;,#&#123;createTime&#125;,#&#123;commentCount&#125;,#&#123;score&#125;)</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure><p>帖子详情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public String getDiscussPost(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Model model, Page page) &#123;</span><br><span class="line">    &#x2F;&#x2F; 帖子</span><br><span class="line">    DiscussPost post &#x3D; discussPostService.findDiscussPostById(discussPostId);</span><br><span class="line">    model.addAttribute(&quot;post&quot;, post);</span><br><span class="line">    &#x2F;&#x2F; 作者</span><br><span class="line">    User user &#x3D; userService.findUserById(post.getUserId());</span><br><span class="line">    model.addAttribute(&quot;user&quot;, user);</span><br><span class="line">    &#x2F;&#x2F; 点赞数量</span><br><span class="line">    long likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);</span><br><span class="line">    model.addAttribute(&quot;likeCount&quot;, likeCount);</span><br><span class="line">    &#x2F;&#x2F; 点赞状态</span><br><span class="line">    int likeStatus &#x3D; hostHolder.getUser() &#x3D;&#x3D; null ? 0 :</span><br><span class="line">            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);</span><br><span class="line">    model.addAttribute(&quot;likeStatus&quot;, likeStatus);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 评论分页信息</span><br><span class="line">    page.setLimit(5);</span><br><span class="line">    page.setPath(&quot;&#x2F;discuss&#x2F;detail&#x2F;&quot; + discussPostId);</span><br><span class="line">    page.setRows(post.getCommentCount());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 评论: 给帖子的评论</span><br><span class="line">    &#x2F;&#x2F; 回复: 给评论的评论</span><br><span class="line">    &#x2F;&#x2F; 评论列表</span><br><span class="line">    List&lt;Comment&gt; commentList &#x3D; commentService.findCommentsByEntity(</span><br><span class="line">            ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());</span><br><span class="line">    &#x2F;&#x2F; 评论VO列表</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; commentVoList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (commentList !&#x3D; null) &#123;</span><br><span class="line">        for (Comment comment : commentList) &#123;</span><br><span class="line">            &#x2F;&#x2F; 评论VO</span><br><span class="line">           </span><br><span class="line">            &#x2F;&#x2F; 评论</span><br><span class="line">          </span><br><span class="line">            &#x2F;&#x2F; 作者</span><br><span class="line">         </span><br><span class="line">            &#x2F;&#x2F; 点赞数量</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 点赞状态</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 回复列表</span><br><span class="line">     </span><br><span class="line">            &#x2F;&#x2F; 回复VO列表</span><br><span class="line">            List&lt;Map&lt;String, Object&gt;&gt; replyVoList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            if (replyList !&#x3D; null) &#123;</span><br><span class="line">                for (Comment reply : replyList) &#123;</span><br><span class="line">                  </span><br><span class="line">                    &#x2F;&#x2F; 回复</span><br><span class="line">                 </span><br><span class="line">                    &#x2F;&#x2F; 作者</span><br><span class="line">                 </span><br><span class="line">                    &#x2F;&#x2F; 回复目标</span><br><span class="line">                   </span><br><span class="line">                    &#x2F;&#x2F; 点赞数量</span><br><span class="line">                </span><br><span class="line">                    &#x2F;&#x2F; 点赞状态</span><br><span class="line">                  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 回复数量</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(&quot;comments&quot;, commentVoList);</span><br><span class="line"></span><br><span class="line">    return &quot;&#x2F;site&#x2F;discuss-detail&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>帖子列表</p><p>添加评论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;insertComment&quot; parameterType&#x3D;&quot;Comment&quot;&gt;</span><br><span class="line">    insert into comment(&lt;include refid&#x3D;&quot;insertFields&quot;&gt;&lt;&#x2F;include&gt;)</span><br><span class="line">    values(#&#123;userId&#125;,#&#123;entityType&#125;,#&#123;entityId&#125;,#&#123;targetId&#125;,#&#123;content&#125;,#&#123;status&#125;,#&#123;createTime&#125;)</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure><p>事务管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; REQUIRED: 支持当前事务(外部事务),如果不存在则创建新事务.</span><br><span class="line">&#x2F;&#x2F; REQUIRES_NEW: 创建一个新事务,并且暂停当前事务(外部事务).</span><br><span class="line">&#x2F;&#x2F; NESTED: 如果当前存在事务(外部事务),则嵌套在该事务中执行(独立的提交和回滚),否则就会REQUIRED一样.</span><br><span class="line">@Transactional(isolation &#x3D; Isolation.READ_COMMITTED, propagation &#x3D; Propagation.REQUIRED)</span><br></pre></td></tr></table></figure><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>创建 RedisKeyUtil 工具类，通过实体类型和实体 id 生成对应实体获得赞的 key。</p><p>点赞/取消点赞：</p><ul><li>通过 RedisKeyUtil 获得实体点赞的 key，然后通过 RedisTemplate 的 API 操作，调用集合的 <code>isMember</code> 方法查询 userId 是否存在于对应集合中，如果存在则移除出点赞的用户集合，如果不存在则添加到点赞的用户集合。</li><li>通过 RedisTemplate 的 <code>execute</code> 方法实现事务，保证被点赞用户点和点赞用户的数据更新一致。通过 <code>isMember</code> 方法查询用户的点赞状态，之后通过 <code>mutli</code> 方法开启事务。</li></ul><p>点赞数量：通过调用 set 集合的 <code>size</code> 方法查询元素个数。</p><p>点赞状态：通过 set 集合的 <code>isMember</code> 方法实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void like(int userId, int entityType, int entityId, int entityUserId) &#123;</span><br><span class="line">    redisTemplate.execute(new SessionCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            String entityLikeKey &#x3D; RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">            String userLikeKey &#x3D; RedisKeyUtil.getUserLikeKey(entityUserId);</span><br><span class="line"></span><br><span class="line">            boolean isMember &#x3D; operations.opsForSet().isMember(entityLikeKey, userId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            if (isMember) &#123;</span><br><span class="line">                operations.opsForSet().remove(entityLikeKey, userId);</span><br><span class="line">                operations.opsForValue().decrement(userLikeKey);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                operations.opsForSet().add(entityLikeKey, userId);</span><br><span class="line">                operations.opsForValue().increment(userLikeKey);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template &#x3D; new RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置key的序列化方式</span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        &#x2F;&#x2F; 设置value的序列化方式</span><br><span class="line">        template.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        &#x2F;&#x2F; 设置hash的key的序列化方式</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        &#x2F;&#x2F; 设置hash的value的序列化方式</span><br><span class="line">        template.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 某个实体的赞</span><br><span class="line">&#x2F;&#x2F; like:entity:entityType:entityId -&gt; set(userId)</span><br><span class="line">public static String getEntityLikeKey(int entityType, int entityId) &#123;</span><br><span class="line">    return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="关注和粉丝"><a href="#关注和粉丝" class="headerlink" title="关注和粉丝"></a>关注和粉丝</h3><p>在 RedisUnitl 工具类增加两个方法</p><ul><li><p>通过用户 id 和实体类型获得用户关注的实体集合的 key。</p></li><li><p>通过实体类型和实体 id 获得实体拥有的粉丝集合的 key。</p></li></ul><p>当用户关注某实体时，</p><ul><li>将实体 id 和时间作为 value 和 score 加入用户的关注集合。</li><li>将用户 id 和时间作为 value 和 score 加入实体的粉丝集合。</li></ul><p>当用户取消关注某实体时，将实体从用户的关注集合移除，用户从实体的粉丝集合移除。</p><p><strong>关注列表和粉丝列表</strong></p><ul><li>用户的关注列表，通过 zset 的  <code>reverseRange</code> 获取 value 即关注用户的 userId，再查询出 user，通过 <code>score</code> 获取关注时间。</li><li>用户的粉丝列表，通过 zset 的  <code>reverseRange</code> 获取 value 即粉丝的 userId，再查询出 user，通过 <code>score</code> 获取关注时间。</li><li>列表信息封装在 list 集合中，再将 list 添加到 Model 对象里。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void follow(int userId, int entityType, int entityId) &#123;</span><br><span class="line">    redisTemplate.execute(new SessionCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            String followeeKey &#x3D; RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">            String followerKey &#x3D; RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());</span><br><span class="line">            operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">            return operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void unfollow(int userId, int entityType, int entityId) &#123;</span><br><span class="line">    redisTemplate.execute(new SessionCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            String followeeKey &#x3D; RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">            String followerKey &#x3D; RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            operations.opsForZSet().remove(followeeKey, entityId);</span><br><span class="line">            operations.opsForZSet().remove(followerKey, userId);</span><br><span class="line"></span><br><span class="line">            return operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询某用户关注的人</span><br><span class="line">public List&lt;Map&lt;String, Object&gt;&gt; findFollowees(int userId, int offset, int limit) &#123;</span><br><span class="line">    String followeeKey &#x3D; RedisKeyUtil.getFolloweeKey(userId, ENTITY_TYPE_USER);</span><br><span class="line">    Set&lt;Integer&gt; targetIds &#x3D; redisTemplate.opsForZSet().reverseRange(followeeKey, offset, offset + limit - 1);</span><br><span class="line"></span><br><span class="line">    if (targetIds &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (Integer targetId : targetIds) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        User user &#x3D; userService.findUserById(targetId);</span><br><span class="line">        map.put(&quot;user&quot;, user);</span><br><span class="line">        Double score &#x3D; redisTemplate.opsForZSet().score(followeeKey, targetId);</span><br><span class="line">        map.put(&quot;followTime&quot;, new Date(score.longValue()));</span><br><span class="line">        list.add(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查询某用户的粉丝</span><br><span class="line">public List&lt;Map&lt;String, Object&gt;&gt; findFollowers(int userId, int offset, int limit) &#123;</span><br><span class="line">    String followerKey &#x3D; RedisKeyUtil.getFollowerKey(ENTITY_TYPE_USER, userId);</span><br><span class="line">    Set&lt;Integer&gt; targetIds &#x3D; redisTemplate.opsForZSet().reverseRange(followerKey, offset, offset + limit - 1);</span><br><span class="line"></span><br><span class="line">    if (targetIds &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (Integer targetId : targetIds) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        User user &#x3D; userService.findUserById(targetId);</span><br><span class="line">        map.put(&quot;user&quot;, user);</span><br><span class="line">        Double score &#x3D; redisTemplate.opsForZSet().score(followerKey, targetId);</span><br><span class="line">        map.put(&quot;followTime&quot;, new Date(score.longValue()));</span><br><span class="line">        list.add(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p><strong>发送系统通知</strong></p><p>创建 Event 类，封装事件对象，包括主题（评论、点赞、关注）、用户 id、实体类型、实体 id，以及一个 map 集合存放其它信息.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Event &#123;</span><br><span class="line"></span><br><span class="line">    private String topic;</span><br><span class="line">    private int userId;</span><br><span class="line">    private int entityType;</span><br><span class="line">    private int entityId;</span><br><span class="line">    private int entityUserId;</span><br><span class="line">    private Map&lt;String, Object&gt; data &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>触发事件</strong></p><p>通过 Event 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 KafkaTemplate 实例的 send 方法发送。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class EventProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理事件</span><br><span class="line">    public void fireEvent(Event event) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将事件发布到指定的主题</span><br><span class="line">        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 触发发帖事件</span><br><span class="line">Event event &#x3D; new Event()</span><br><span class="line">        .setTopic(TOPIC_PUBLISH)</span><br><span class="line">        .setUserId(user.getId())</span><br><span class="line">        .setEntityType(ENTITY_TYPE_POST)</span><br><span class="line">        .setEntityId(post.getId());</span><br><span class="line">eventProducer.fireEvent(event);</span><br></pre></td></tr></table></figure><p><strong>消费事件</strong></p><p>通过 <code>@KafkaListener</code> 注解，topic 包括了评论、点赞和关注。从 recored 中获取信息，封装成 Message 对象然后调用 <code>addMessage</code> 方法插入数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 消费发帖事件</span><br><span class="line">@KafkaListener(topics &#x3D; &#123;TOPIC_PUBLISH&#125;)</span><br><span class="line">public void handlePublishMessage(ConsumerRecord record) &#123;</span><br><span class="line">    if (record &#x3D;&#x3D; null || record.value() &#x3D;&#x3D; null) &#123;</span><br><span class="line">        logger.error(&quot;消息的内容为空!&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Event event &#x3D; JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">    if (event &#x3D;&#x3D; null) &#123;</span><br><span class="line">        logger.error(&quot;消息格式错误!&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DiscussPost post &#x3D; discussPostService.findDiscussPostById(event.getEntityId());</span><br><span class="line">    elasticsearchService.saveDiscussPost(post);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h3><p>Unique Visitor 独立游客</p><p>通过用户IP排重统计数据。</p><h3 id="DAU"><a href="#DAU" class="headerlink" title="DAU"></a>DAU</h3><p>Daily Active User  日活跃用户</p><p>通过用户ID排重统计数据</p><p><img src="/2020/11/01/%E8%AE%BA%E5%9D%9B%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%94%B9%E8%BF%9B/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201115211418953.png" alt="image-20201115211418953"></p><h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拆分为dubbo</title>
      <link href="/2020/10/30/%E6%8B%86%E5%88%86%E4%B8%BAdubbo/"/>
      <url>/2020/10/30/%E6%8B%86%E5%88%86%E4%B8%BAdubbo/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="gateway"><a href="#gateway" class="headerlink" title="gateway"></a>gateway</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Reference(interfaceClass &#x3D; RedisServiceApi.class)</span><br></pre></td></tr></table></figure><h4 id="总的pom"><a href="#总的pom" class="headerlink" title="总的pom"></a>总的pom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"> </span><br><span class="line">&lt;groupId&gt;com.example&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dubbodemo&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"> </span><br><span class="line">&lt;name&gt;dubbodemo&lt;&#x2F;name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"> </span><br><span class="line">&lt;modules&gt;</span><br><span class="line">&lt;module&gt;provider&lt;&#x2F;module&gt;</span><br><span class="line">&lt;module&gt;consumer&lt;&#x2F;module&gt;</span><br><span class="line">&lt;module&gt;api&lt;&#x2F;module&gt;</span><br><span class="line">&lt;&#x2F;modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><h4 id="common模块（api模块"><a href="#common模块（api模块" class="headerlink" title="common模块（api模块)"></a>common模块（api模块)</h4><p>User.java，实体类根据需要自己编写，但要注意的是需要实现Serializable这个接口</p><p>api中存放entity实体类和service接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line"> </span><br><span class="line">    private static final long serialVersionUID &#x3D; 7739394865008699599L;</span><br><span class="line"> </span><br><span class="line">    private Long id;</span><br><span class="line"> </span><br><span class="line">    private String username;</span><br><span class="line"> </span><br><span class="line">    private String password;</span><br><span class="line"> </span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, password&#x3D;&#39;&quot; + password + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通用模块的pom"><a href="#通用模块的pom" class="headerlink" title="通用模块的pom"></a>通用模块的pom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;name&gt;dis-seckill-common&lt;&#x2F;name&gt;</span><br><span class="line">&lt;description&gt;通用模块&lt;&#x2F;description&gt;</span><br></pre></td></tr></table></figure><h4 id="消费者的配置文件"><a href="#消费者的配置文件" class="headerlink" title="消费者的配置文件"></a>消费者的配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 避免和provider工程端口冲突</span><br><span class="line">server.port&#x3D;7001</span><br><span class="line">## Dubbo 服务消费者配置</span><br><span class="line">spring.dubbo.application.name&#x3D;consumer &#x2F;&#x2F;模块名字</span><br><span class="line">## Dubbo 服务对象的注册中心zookeeper的地址和端口</span><br><span class="line">spring.dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;localhost:2181</span><br><span class="line">##  服务对象的被注入的包扫描范围</span><br><span class="line">spring.dubbo.scan&#x3D;com.example.consumer.controller &#x2F;&#x2F;相应的service包的位置</span><br></pre></td></tr></table></figure><p><img src="/2020/10/30/%E6%8B%86%E5%88%86%E4%B8%BAdubbo/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201030093252682.png" alt="image-20201030093252682"></p><h4 id="消费者的pom"><a href="#消费者的pom" class="headerlink" title="消费者的pom"></a>消费者的pom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    &lt;name&gt;dis-seckill-goods&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;商品模块&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 添加对api模块的依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.example&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- Spring Boot Dubbo 依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.dubbo.springboot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-dubbo&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;dubbo-spring-boot&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;&#x2F;exclusion&gt;</span><br><span class="line">&lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="服务提供者的配置"><a href="#服务提供者的配置" class="headerlink" title="服务提供者的配置"></a>服务提供者的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;8001</span><br><span class="line">## Dubbo 服务提供者配置</span><br><span class="line">spring.dubbo.application.name&#x3D;provider</span><br><span class="line">## Dubbo 服务对象的注册中心zookeeper的地址和端口</span><br><span class="line">spring.dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;localhost:2181</span><br><span class="line">## 用Dubbo协议在20880端口暴露服务</span><br><span class="line">spring.dubbo.protocol.name&#x3D;dubbo</span><br><span class="line">spring.dubbo.protocol.port&#x3D;20880</span><br><span class="line">## 包扫描范围</span><br><span class="line">spring.dubbo.scan&#x3D;com.example.provider.serviceimpl</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机常见的监控工具</title>
      <link href="/2020/10/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/10/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JDK-监控和故障处理工具总结"><a href="#JDK-监控和故障处理工具总结" class="headerlink" title="JDK 监控和故障处理工具总结"></a>JDK 监控和故障处理工具总结</h1><h2 id="JDK-命令行工具"><a href="#JDK-命令行工具" class="headerlink" title="JDK 命令行工具"></a>JDK 命令行工具</h2><p>这些命令在 JDK 安装目录下的 bin 目录下：</p><ul><li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li><li><strong><code>jstat</code></strong>（ JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li><li><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;</li><li><strong><code>jmap</code></strong> (Memory Map for Java) :生成堆转储快照;</li><li><strong><code>jhat</code></strong> (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</li><li><strong><code>jstack</code></strong> (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li></ul><h3 id="jps-查看所有-Java-进程"><a href="#jps-查看所有-Java-进程" class="headerlink" title="jps:查看所有 Java 进程"></a>jps:查看所有 Java 进程</h3><p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code> 命令。</p><p><code>jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。<code>jps -q</code> ：只输出进程的本地虚拟机唯一 ID。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">16504</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServerCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps <span class="literal">-l</span></span><br><span class="line"><span class="number">7360</span> firstNettyDemo.NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">16492</span> sun.tools.jps.Jps</span><br><span class="line"><span class="number">17340</span> firstNettyDemo.NettyServerCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p><p><code>jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p><h3 id="jstat-监视虚拟机各种运行状态信息"><a href="#jstat-监视虚拟机各种运行状态信息" class="headerlink" title="jstat: 监视虚拟机各种运行状态信息"></a>jstat: 监视虚拟机各种运行状态信息</h3><p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p><p><strong>jstat 命令使用格式：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-<span class="type">t</span>] [-<span class="type">h</span>&lt;<span class="type">lines</span>&gt;] &lt;vmid&gt; [&lt;<span class="built_in">int</span><span class="type">erval</span>&gt; [&lt;<span class="type">count</span>&gt;]]Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>比如 <code>jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p><p><strong>常见的 option 如下：</strong></p><ul><li><code>jstat -class vmid</code> ：显示 ClassLoader 的相关信息；</li><li><code>jstat -compiler vmid</code> ：显示 JIT 编译的相关信息；</li><li><code>jstat -gc vmid</code> ：显示与 GC 相关的堆信息；</li><li><code>jstat -gccapacity vmid</code> ：显示各个代的容量及使用情况；</li><li><code>jstat -gcnew vmid</code> ：显示新生代信息；</li><li><code>jstat -gcnewcapcacity vmid</code> ：显示新生代大小与使用情况；</li><li><code>jstat -gcold vmid</code> ：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了；</li><li><code>jstat -gcoldcapacity vmid</code> ：显示老年代的大小；</li><li><code>jstat -gcpermcapacity vmid</code> ：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了；</li><li><code>jstat -gcutil vmid</code> ：显示垃圾收集信息；</li></ul><p>另外，加上 <code>-t</code>参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。</p><h3 id="jinfo-实时地查看和调整虚拟机各项参数"><a href="#jinfo-实时地查看和调整虚拟机各项参数" class="headerlink" title="jinfo: 实时地查看和调整虚拟机各项参数"></a>jinfo: 实时地查看和调整虚拟机各项参数</h3><p><code>jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p><p><code>jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code>-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span> MaxHeapSize <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:MaxHeapSize=<span class="number">2124414976</span></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span> PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:<span class="literal">-PrintGCCopy</span> to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p><p><code>jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:<span class="literal">-PrintGC</span></span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  +PrintGC <span class="number">17340</span></span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:+PrintGCCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="jmap-生成堆转储快照"><a href="#jmap-生成堆转储快照" class="headerlink" title="jmap:生成堆转储快照"></a>jmap:生成堆转储快照</h3><p><code>jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code>jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code>“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 <code>kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p><p><code>jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在 Windows 平台下也是受限制的。</p><p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jmap <span class="literal">-dump</span>:format=b,file=C:\Users\SnailClimb\Desktop\heap.hprof <span class="number">17340</span></span><br><span class="line">Dumping heap to C:\Users\SnailClimb\Desktop\heap.hprof ...</span><br><span class="line">Heap dump file createdCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="jhat-分析-heapdump-文件"><a href="#jhat-分析-heapdump-文件" class="headerlink" title="jhat: 分析 heapdump 文件"></a>jhat: 分析 heapdump 文件</h3><p><strong><code>jhat</code></strong> 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jhat C:\Users\SnailClimb\Desktop\heap.hprof</span><br><span class="line">Reading from C:\Users\SnailClimb\Desktop\heap.hprof...</span><br><span class="line">Dump file created Sat May <span class="number">04</span> <span class="number">12</span>:<span class="number">30</span>:<span class="number">31</span> CST <span class="number">2019</span></span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving <span class="number">131419</span> objects...</span><br><span class="line">Chasing references, expect <span class="number">26</span> dots..........................</span><br><span class="line">Eliminating duplicate references..........................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port <span class="number">7000</span></span><br><span class="line">Server is ready.Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:7000/" target="_blank" rel="noopener">http://localhost:7000/</a></p><h3 id="jstack-生成虚拟机当前时刻的线程快照"><a href="#jstack-生成虚拟机当前时刻的线程快照" class="headerlink" title="jstack :生成虚拟机当前时刻的线程快照"></a>jstack :生成虚拟机当前时刻的线程快照</h3><p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p><p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p><p><strong>下面是一个线程死锁的代码。我们下面会通过 <code>jstack</code> 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><p><strong>通过 <code>jstack</code> 命令分析：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">13792</span> KotlinCompileDaemon</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">8932</span> Launcher</span><br><span class="line"><span class="number">9256</span> DeadLockDemo</span><br><span class="line"><span class="number">10764</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServer</span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jstack <span class="number">9256</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>输出的部分内容如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Found one Java<span class="literal">-level</span> deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"线程 2"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000333e668 (object <span class="number">0</span>x00000000d5efe1c0, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"线程 1"</span></span><br><span class="line"><span class="string">"线程 1"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000333be88 (object <span class="number">0</span>x00000000d5efe1d0, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"线程 2"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"线程 2"</span>:</span><br><span class="line">        at DeadLockDemo.lambda<span class="variable">$main</span><span class="variable">$1</span>(DeadLockDemo.java:<span class="number">31</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo<span class="variable">$</span><span class="variable">$Lambda</span><span class="variable">$2</span>/<span class="number">1078694789</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">"线程 1"</span>:</span><br><span class="line">        at DeadLockDemo.lambda<span class="variable">$main</span><span class="variable">$0</span>(DeadLockDemo.java:<span class="number">16</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo<span class="variable">$</span><span class="variable">$Lambda</span><span class="variable">$1</span>/<span class="number">1324119927</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>可以看到 <code>jstack</code> 命令已经帮我们找到发生死锁的线程的具体信息。</p><h2 id="JDK-可视化分析工具"><a href="#JDK-可视化分析工具" class="headerlink" title="JDK 可视化分析工具"></a>JDK 可视化分析工具</h2><h3 id="JConsole-Java-监视与管理控制台"><a href="#JConsole-Java-监视与管理控制台" class="headerlink" title="JConsole:Java 监视与管理控制台"></a>JConsole:Java 监视与管理控制台</h3><p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出<code>console</code>命令启动或者在 JDK 目录下的 bin 目录找到<code>jconsole.exe</code>然后双击启动。</p><h4 id="连接-Jconsole"><a href="#连接-Jconsole" class="headerlink" title="连接 Jconsole"></a>连接 Jconsole</h4><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/1JConsole%E8%BF%9E%E6%8E%A5.png" alt="连接 Jconsole"></p><p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Djava.rmi.server.hostname</span>=<span class="string">外网访问 ip 地址 </span></span><br><span class="line"><span class="meta">-Dcom.sun.management.jmxremote.port</span>=<span class="string">60001   //监控的端口号</span></span><br><span class="line"><span class="meta">-Dcom.sun.management.jmxremote.authenticate</span>=<span class="string">false   //关闭认证</span></span><br><span class="line"><span class="meta">-Dcom.sun.management.jmxremote.ssl</span>=<span class="string">falseCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>在使用 JConsole 连接时，远程进程地址如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外网访问 ip 地址:60001 Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="查看-Java-程序概况"><a href="#查看-Java-程序概况" class="headerlink" title="查看 Java 程序概况"></a>查看 Java 程序概况</h4><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/2%E6%9F%A5%E7%9C%8BJava%E7%A8%8B%E5%BA%8F%E6%A6%82%E5%86%B5.png" alt="查看 Java 程序概况 "></p><h4 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h4><p>JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。</p><p>点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。</p><blockquote><ul><li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li></ul></blockquote><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/3%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7.png" alt="内存监控 "></p><h4 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h4><p>类似我们前面讲的 <code>jstack</code> 命令，不过这个是可视化的。</p><p>最下面有一个”检测死锁 (D)”按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/4%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7.png" alt="线程监控 "></p><h3 id="Visual-VM-多合一故障处理工具"><a href="#Visual-VM-多合一故障处理工具" class="headerlink" title="Visual VM:多合一故障处理工具"></a>Visual VM:多合一故障处理工具</h3><p>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<a href="https://visualvm.github.io/" target="_blank" rel="noopener">https://visualvm.github.io/</a> 。Visual VM 中文文档:<a href="https://visualvm.github.io/documentation.html。" target="_blank" rel="noopener">https://visualvm.github.io/documentation.html。</a></p><p>下面这段话摘自《深入理解 Java 虚拟机》。</p><blockquote><p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p></blockquote><p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p><ul><li><strong>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</strong></li><li><strong>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</strong></li><li><strong>dump 以及分析堆转储快照（jmap、jhat）。</strong></li><li><strong>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</strong></li><li><strong>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</strong></li><li><strong>其他 plugins 的无限的可能性……</strong></li></ul><h2 id="CPU占满"><a href="#CPU占满" class="headerlink" title="CPU占满"></a>CPU占满</h2><p>模拟CPU占满还是比较简单，直接写一个死循环计算消耗CPU即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 模拟CPU占满</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @GetMapping(&quot;&#x2F;cpu&#x2F;loop&quot;)</span><br><span class="line">  public void testCPULoop() throws InterruptedException &#123;</span><br><span class="line">      System.out.println(&quot;请求cpu死循环&quot;);</span><br><span class="line">      Thread.currentThread().setName(&quot;loop-thread-cpu&quot;);</span><br><span class="line">      int num &#x3D; 0;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">          num++;</span><br><span class="line">          if (num &#x3D;&#x3D; Integer.MAX_VALUE) &#123;</span><br><span class="line">              System.out.println(&quot;reset&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          num &#x3D; 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>请求接口地址测试<code>curl localhost:8080/cpu/loop</code>,发现CPU立马飙升到100%</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance1.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance1.png" alt="img"></a></p><p>通过执行<code>top -Hp 32805</code> 查看Java线程情况</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance2.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance2.png" alt="img"></a></p><p>执行 <code>printf &#39;%x&#39; 32826</code> 获取16进制的线程id，用于<code>dump</code>信息查询，结果为 <code>803a</code>。最后我们执行<code>jstack 32805 |grep -A 20 803a</code>来查看下详细的<code>dump</code>信息。</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance3.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance3.png" alt="img"></a></p><p>这里<code>dump</code>信息直接定位出了问题方法以及代码行，这就定位出了CPU占满的问题。</p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>模拟内存泄漏借助了ThreadLocal对象来完成，ThreadLocal是一个线程私有变量，可以绑定到线程上，在整个线程的生命周期都会存在，但是由于ThreadLocal的特殊性，ThreadLocal是基于ThreadLocalMap实现的，ThreadLocalMap的Entry继承WeakReference，而Entry的Key是WeakReference的封装，换句话说Key就是弱引用，弱引用在下次GC之后就会被回收，如果ThreadLocal在set之后不进行后续的操作，因为GC会把Key清除掉，但是Value由于线程还在存活，所以Value一直不会被回收，最后就会发生内存泄漏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 模拟内存泄漏</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;memory&#x2F;leak&quot;)</span><br><span class="line">    public String leak() &#123;</span><br><span class="line">        System.out.println(&quot;模拟内存泄漏&quot;);</span><br><span class="line">        ThreadLocal&lt;Byte[]&gt; localVariable &#x3D; new ThreadLocal&lt;Byte[]&gt;();</span><br><span class="line">        localVariable.set(new Byte[4096 * 1024]);&#x2F;&#x2F; 为线程添加变量</span><br><span class="line">        return &quot;ok&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们给启动加上堆内存大小限制，同时设置内存溢出的时候输出堆栈快照并输出日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Xms500m -Xmx500m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;tmp&#x2F;heapdump.hprof -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:&#x2F;tmp&#x2F;heaplog.log analysis-demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>启动成功后我们循环执行100次,<code>for i in {1..500}; do curl localhost:8080/memory/leak;done</code>,还没执行完毕，系统已经返回500错误了。查看系统日志出现了如下异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><p>我们用<code>jstat -gc pid</code> 命令来看看程序的GC情况。</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance4.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance4.png" alt="img"></a></p><p>很明显，内存溢出了，堆内存经过45次 Full Gc 之后都没释放出可用内存，这说明当前堆内存中的对象都是存活的，有GC Roots引用，无法回收。那是什么原因导致内存溢出呢？是不是我只要加大内存就行了呢？如果是普通的内存溢出也许扩大内存就行了，但是如果是内存泄漏的话，扩大的内存不一会就会被占满，所以我们还需要确定是不是内存泄漏。我们之前保存了堆 Dump 文件，这个时候借助我们的MAT工具来分析下。导入工具选择<code>Leak Suspects Report</code>，工具直接就会给你列出问题报告。</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance5.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance5.png" alt="img"></a></p><p>这里已经列出了可疑的4个内存泄漏问题，我们点击其中一个查看详情。</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance6.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance6.png" alt="img"></a></p><p>这里已经指出了内存被线程占用了接近50M的内存，占用的对象就是ThreadLocal。如果想详细的通过手动去分析的话，可以点击<code>Histogram</code>,查看最大的对象占用是谁，然后再分析它的引用关系，即可确定是谁导致的内存溢出。</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance7.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance7.png" alt="img"></a></p><p>上图发现占用内存最大的对象是一个Byte数组，我们看看它到底被那个GC Root引用导致没有被回收。按照上图红框操作指引，结果如下图：</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance8.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance8.png" alt="img"></a></p><p>我们发现Byte数组是被线程对象引用的，图中也标明，Byte数组对像的GC Root是线程，所以它是不会被回收的，展开详细信息查看，我们发现最终的内存占用对象是被ThreadLocal对象占据了。这也和MAT工具自动帮我们分析的结果一致。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁会导致耗尽线程资源，占用内存，表现就是内存占用升高，CPU不一定会飙升(看场景决定)，如果是直接new线程，会导致JVM内存被耗尽，报无法创建线程的错误，这也是体现了使用线程池的好处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> ExecutorService service &#x3D; new ThreadPoolExecutor(4, 10,</span><br><span class="line">            0, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">   &#x2F;**</span><br><span class="line">     * 模拟死锁</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;cpu&#x2F;test&quot;)</span><br><span class="line">    public String testCPU() throws InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;请求cpu&quot;);</span><br><span class="line">        Object lock1 &#x3D; new Object();</span><br><span class="line">        Object lock2 &#x3D; new Object();</span><br><span class="line">        service.submit(new DeadLockThread(lock1, lock2), &quot;deadLookThread-&quot; + new Random().nextInt());</span><br><span class="line">        service.submit(new DeadLockThread(lock2, lock1), &quot;deadLookThread-&quot; + new Random().nextInt());</span><br><span class="line">        return &quot;ok&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public class DeadLockThread implements Runnable &#123;</span><br><span class="line">    private Object lock1;</span><br><span class="line">    private Object lock2;</span><br><span class="line"></span><br><span class="line">    public DeadLockThread1(Object lock1, Object lock2) &#123;</span><br><span class="line">        this.lock1 &#x3D; lock1;</span><br><span class="line">        this.lock2 &#x3D; lock2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (lock2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;get lock2 and wait lock1&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lock1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;get lock1 and lock2 &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们循环请求接口2000次，发现不一会系统就出现了日志错误，线程池和队列都满了,由于我选择的当队列满了就拒绝的策略，所以系统直接抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@2760298 rejected from java.util.concurrent.ThreadPoolExecutor@7ea7cd51[Running, pool size &#x3D; 10, active threads &#x3D; 10, queued tasks &#x3D; 1024, completed tasks &#x3D; 846]</span><br></pre></td></tr></table></figure><p>通过<code>ps -ef|grep java</code>命令找出 Java 进程 pid，执行<code>jstack pid</code> 即可出现java线程堆栈信息，这里发现了5个死锁，我们只列出其中一个，很明显线程<code>pool-1-thread-2</code>锁住了<code>0x00000000f8387d88</code>等待<code>0x00000000f8387d98</code>锁，线程<code>pool-1-thread-1</code>锁住了<code>0x00000000f8387d98</code>等待锁<code>0x00000000f8387d88</code>,这就产生了死锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Java stack information for the threads listed above:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;pool-1-thread-2&quot;:</span><br><span class="line">        at top.luozhou.analysisdemo.controller.DeadLockThread2.run(DeadLockThread.java:30)</span><br><span class="line">        - waiting to lock &lt;0x00000000f8387d98&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000f8387d88&gt; (a java.lang.Object)</span><br><span class="line">        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;pool-1-thread-1&quot;:</span><br><span class="line">        at top.luozhou.analysisdemo.controller.DeadLockThread1.run(DeadLockThread.java:30)</span><br><span class="line">        - waiting to lock &lt;0x00000000f8387d88&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000f8387d98&gt; (a java.lang.Object)</span><br><span class="line">        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">          </span><br><span class="line"> Found 5 deadlocks.</span><br></pre></td></tr></table></figure><h2 id="线程频繁切换"><a href="#线程频繁切换" class="headerlink" title="线程频繁切换"></a>线程频繁切换</h2><p>上下文切换会导致将大量CPU时间浪费在寄存器、内核栈以及虚拟内存的保存和恢复上，导致系统整体性能下降。当你发现系统的性能出现明显的下降时候，需要考虑是否发生了大量的线程上下文切换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> @GetMapping(value &#x3D; &quot;&#x2F;thread&#x2F;swap&quot;)</span><br><span class="line">    public String theadSwap(int num) &#123;</span><br><span class="line">        System.out.println(&quot;模拟线程切换&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; num; i++) &#123;</span><br><span class="line">            new Thread(new ThreadSwap1(new AtomicInteger(0)),&quot;thread-swap&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;ok&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">public class ThreadSwap1 implements Runnable &#123;</span><br><span class="line">    private AtomicInteger integer;</span><br><span class="line"></span><br><span class="line">    public ThreadSwap1(AtomicInteger integer) &#123;</span><br><span class="line">        this.integer &#x3D; integer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            integer.addAndGet(1);</span><br><span class="line">            Thread.yield(); &#x2F;&#x2F;让出CPU资源</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我创建多个线程去执行基础的原子+1操作，然后让出 CPU 资源，理论上 CPU 就会去调度别的线程，我们请求接口创建100个线程看看效果如何，<code>curl localhost:8080/thread/swap?num=100</code>。接口请求成功后，我们执行`vmstat 1 10，表示每1秒打印一次，打印10次，线程切换采集结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line">101  0 128000 878384    908 468684    0    0     0     0 4071 8110498 14 86  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4065 8312463 15 85  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4107 8207718 14 87  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4083 8410174 14 86  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4083 8264377 14 86  0  0  0</span><br><span class="line">100  0 128000 878384    908 468688    0    0     0   108 4182 8346826 14 86  0  0  0</span><br></pre></td></tr></table></figure><p>这里我们关注4个指标，<code>r</code>,<code>cs</code>,<code>us</code>,<code>sy</code>。</p><p><strong>r=100</strong>,说明等待的进程数量是100，线程有阻塞。</p><p><strong>cs=800多万</strong>，说明每秒上下文切换了800多万次，这个数字相当大了。</p><p><strong>us=14</strong>，说明用户态占用了14%的CPU时间片去处理逻辑。</p><p><strong>sy=86</strong>，说明内核态占用了86%的CPU，这里明显就是做上下文切换工作了。</p><p>我们通过<code>top</code>命令以及<code>top -Hp pid</code>查看进程和线程CPU情况，发现Java线程CPU占满了，但是线程CPU使用情况很平均，没有某一个线程把CPU吃满的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                            </span><br><span class="line"> 87093 root      20   0 4194788 299056  13252 S 399.7 16.1  65:34.67 java </span><br><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                             </span><br><span class="line"> 87189 root      20   0 4194788 299056  13252 R  4.7 16.1   0:41.11 java                                                                                </span><br><span class="line"> 87129 root      20   0 4194788 299056  13252 R  4.3 16.1   0:41.14 java                                                                                </span><br><span class="line"> 87130 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.51 java                                                                                </span><br><span class="line"> 87133 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.59 java                                                                                </span><br><span class="line"> 87134 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.95 java</span><br></pre></td></tr></table></figure><p>结合上面用户态CPU只使用了14%，内核态CPU占用了86%，可以基本判断是Java程序线程上下文切换导致性能问题。</p><p>我们使用<code>pidstat</code>命令来看看Java进程内部的线程切换数据，执行<code>pidstat -p 87093 -w 1 10</code>,采集数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">11:04:30 PM   UID       TGID       TID   cswch&#x2F;s nvcswch&#x2F;s  Command</span><br><span class="line">11:04:30 PM     0         -     87128      0.00     16.07  |__java</span><br><span class="line">11:04:30 PM     0         -     87129      0.00     15.60  |__java</span><br><span class="line">11:04:30 PM     0         -     87130      0.00     15.54  |__java</span><br><span class="line">11:04:30 PM     0         -     87131      0.00     15.60  |__java</span><br><span class="line">11:04:30 PM     0         -     87132      0.00     15.43  |__java</span><br><span class="line">11:04:30 PM     0         -     87133      0.00     16.02  |__java</span><br><span class="line">11:04:30 PM     0         -     87134      0.00     15.66  |__java</span><br><span class="line">11:04:30 PM     0         -     87135      0.00     15.23  |__java</span><br><span class="line">11:04:30 PM     0         -     87136      0.00     15.33  |__java</span><br><span class="line">11:04:30 PM     0         -     87137      0.00     16.04  |__java</span><br></pre></td></tr></table></figure><p>根据上面采集的信息，我们知道Java的线程每秒切换15次左右，正常情况下，应该是个位数或者小数。结合这些信息我们可以断定Java线程开启过多，导致频繁上下文切换，从而影响了整体性能。</p><p><strong>为什么系统的上下文切换是每秒800多万，而 Java 进程中的某一个线程切换才15次左右？</strong></p><p>系统上下文切换分为三种情况:</p><p>1、多任务：在多任务环境中，一个进程被切换出CPU，运行另外一个进程，这里会发生上下文切换。</p><p>2、中断处理：发生中断时，硬件会切换上下文。在vmstat命令中是<code>in</code></p><p>3、用户和内核模式切换：当操作系统中需要在用户模式和内核模式之间进行转换时，需要进行上下文切换,比如进行系统函数调用。</p><p>Linux 为每个 CPU 维护了一个就绪队列，将活跃进程按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。也就是vmstat命令中的<code>r</code>。</p><p>那么，进程在什么时候才会被调度到 CPU 上运行呢？</p><ul><li>进程执行完终止了，它之前使用的 CPU 会释放出来，这时再从就绪队列中拿一个新的进程来运行</li><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片被轮流分配给各个进程。当某个进程时间片耗尽了就会被系统挂起，切换到其它等待 CPU 的进程运行。</li><li>进程在系统资源不足时，要等待资源满足后才可以运行，这时进程也会被挂起，并由系统调度其它进程运行。</li><li>当进程通过睡眠函数 sleep 主动挂起时，也会重新调度。</li><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li></ul><p>结合我们之前的内容分析，阻塞的就绪队列是100左右，而我们的CPU只有4核，这部分原因造成的上下文切换就可能会相当高，再加上中断次数是4000左右和系统的函数调用等，整个系统的上下文切换到800万也不足为奇了。Java内部的线程切换才15次，是因为线程使用<code>Thread.yield()</code>来让出CPU资源，但是CPU有可能继续调度该线程，这个时候线程之间并没有切换，这也是为什么内部的某个线程切换次数并不是非常大的原因。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文模拟了常见的性能问题场景，分析了如何定位CPU100%、内存泄漏、死锁、线程频繁切换问题。分析问题我们需要做好两件事，第一，掌握基本的原理，第二，借助好工具。本文也列举了分析问题的常用工具和命令，希望对你解决问题有所帮助。当然真正的线上环境可能十分复杂，并没有模拟的环境那么简单，但是原理是一样的，问题的表现也是类似的，我们重点抓住原理，活学活用，相信复杂的线上问题也可以顺利解决。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计一个高可用系统</title>
      <link href="/2020/10/28/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/10/28/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="什么是高可用？可用性的判断标准是啥？"><a href="#什么是高可用？可用性的判断标准是啥？" class="headerlink" title="什么是高可用？可用性的判断标准是啥？"></a>什么是高可用？可用性的判断标准是啥？</h2><p><strong>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</strong></p><p><strong>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。</strong></p><p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</p><h2 id="哪些情况会导致系统不可用？"><a href="#哪些情况会导致系统不可用？" class="headerlink" title="哪些情况会导致系统不可用？"></a>哪些情况会导致系统不可用？</h2><ol><li>黑客攻击；</li><li>硬件故障，比如服务器坏掉。</li><li>并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。</li><li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。</li><li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。</li><li>自然灾害或者人为破坏。</li><li>……</li></ol><h2 id="有哪些提高系统可用性的方法？"><a href="#有哪些提高系统可用性的方法？" class="headerlink" title="有哪些提高系统可用性的方法？"></a>有哪些提高系统可用性的方法？</h2><h3 id="1-注重代码质量，测试严格把关"><a href="#1-注重代码质量，测试严格把关" class="headerlink" title="1. 注重代码质量，测试严格把关"></a>1. 注重代码质量，测试严格把关</h3><p>我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！</p><p>另外，安利这个对提高代码质量有实际效果的宝贝：</p><ol><li>sonarqube ：保证你写出更安全更干净的代码！（ps: 目前所在的项目基本都会用到这个插件）。</li><li>Alibaba 开源的 Java 诊断工具 Arthas 也是很不错的选择。</li><li>IDEA 自带的代码分析等工具进行代码扫描也是非常非常棒的。</li></ol><h3 id="2-使用集群，减少单点故障"><a href="#2-使用集群，减少单点故障" class="headerlink" title="2.使用集群，减少单点故障"></a>2.使用集群，减少单点故障</h3><p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例，不到一秒就会有另外一台 Redis 实例顶上。</p><h3 id="3-限流"><a href="#3-限流" class="headerlink" title="3.限流"></a>3.限流</h3><p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。——来自 alibaba-<a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel</a> 的 wiki。</p><h3 id="4-超时和重试机制设置"><a href="#4-超时和重试机制设置" class="headerlink" title="4.超时和重试机制设置"></a>4.超时和重试机制设置</h3><p>一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p><h3 id="5-熔断机制"><a href="#5-熔断机制" class="headerlink" title="5.熔断机制"></a>5.熔断机制</h3><p>超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的是流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。</p><h3 id="6-异步调用"><a href="#6-异步调用" class="headerlink" title="6.异步调用"></a>6.异步调用</h3><p>异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 <strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。</p><h3 id="7-使用缓存"><a href="#7-使用缓存" class="headerlink" title="7.使用缓存"></a>7.使用缓存</h3><p>如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！</p><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h3><ol><li><strong>核心应用和服务优先使用更好的硬件</strong></li><li><strong>监控系统资源使用情况增加报警设置。</strong></li><li><strong>注意备份，必要时候回滚。</strong></li><li><strong>灰度发布：</strong> 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可</li><li><strong>定期检查/更换硬件：</strong> 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。</li><li>…..(想起来再补充！也欢迎各位欢迎补充！)</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/high-availability/如何设计一个高可用系统要考虑哪些地方?id=总结" target="_blank" rel="noopener">总结</a></h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%EF%BC%9F.png" alt="如何设计高可用系统？"></p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式ID生成方案</title>
      <link href="/2020/10/28/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"/>
      <url>/2020/10/28/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做<strong>分布式ID</strong>，或<strong>全局ID</strong>。下面来分析各个生成分布式ID的机制。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%88%86%E5%B8%83%E5%BC%8Fid%E6%96%B9%E6%A1%88.jpeg" alt="常用分布式id方案"></p><p>这篇文章并不会分析的特别详细，主要是做一些总结，以后再出一些详细某个方案的文章。</p><h2 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h2><p>第一种方案仍然还是基于数据库的自增ID，需要单独使用一个数据库实例，在这个实例中新建一个单独的表：</p><p>表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`SEQID`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SEQID.SEQUENCE_ID (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment, </span><br><span class="line">    stub <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> stub (stub)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>可以使用下面的语句生成并获取到一个自增ID</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">replace</span> <span class="keyword">into</span> SEQUENCE_ID (stub) <span class="keyword">VALUES</span> (<span class="string">'anyword'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">last_insert_id</span>();</span><br><span class="line"><span class="keyword">commit</span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>stub字段在这里并没有什么特殊的意义，只是为了方便的去插入数据，只有能插入数据才能产生自增id。而对于插入我们用的是replace，replace会先看是否存在stub指定值一样的数据，如果存在则先delete再insert，如果不存在则直接insert。</p><p>这种生成分布式ID的机制，需要一个单独的Mysql实例，虽然可行，但是基于性能与可靠性来考虑的话都不够，<strong>业务系统每次需要一个ID时，都需要请求数据库获取，性能低，并且如果此数据库实例下线了，那么将影响所有的业务系统。</strong></p><p>为了解决数据库可靠性问题，我们可以使用第二种分布式ID生成方案。</p><h2 id="数据库多主模式"><a href="#数据库多主模式" class="headerlink" title="数据库多主模式"></a>数据库多主模式</h2><p>如果我们两个数据库组成一个<strong>主从模式</strong>集群，正常情况下可以解决数据库可靠性问题，但是如果主库挂掉后，数据没有及时同步到从库，这个时候会出现ID重复的现象。我们可以使用<strong>双主模式</strong>集群，也就是两个Mysql实例都能单独的生产自增ID，这样能够提高效率，但是如果不经过其他改造的话，这两个Mysql实例很可能会生成同样的ID。需要单独给每个Mysql实例配置不同的起始值和自增步长。</p><p>第一台Mysql实例配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">1</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>第二台Mysql实例配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">2</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>经过上面的配置后，这两个Mysql实例生成的id序列如下： mysql1,起始值为1,步长为2,ID生成的序列为：1,3,5,7,9,… mysql2,起始值为2,步长为2,ID生成的序列为：2,4,6,8,10,…</p><p>对于这种生成分布式ID的方案，需要单独新增一个生成分布式ID应用，比如DistributIdService，该应用提供一个接口供业务应用获取ID，业务应用需要一个ID时，通过rpc的方式请求DistributIdService，DistributIdService随机去上面的两个Mysql实例中去获取ID。</p><p>实行这种方案后，就算其中某一台Mysql实例下线了，也不会影响DistributIdService，DistributIdService仍然可以利用另外一台Mysql来生成ID。</p><p>但是这种方案的扩展性不太好，如果两台Mysql实例不够用，需要新增Mysql实例来提高性能时，这时就会比较麻烦。</p><p>现在如果要新增一个实例mysql3，要怎么操作呢？ 第一，mysql1、mysql2的步长肯定都要修改为3，而且只能是人工去修改，这是需要时间的。 第二，因为mysql1和mysql2是不停在自增的，对于mysql3的起始值我们可能要定得大一点，以给充分的时间去修改mysql1，mysql2的步长。 第三，在修改步长的时候很可能会出现重复ID，要解决这个问题，可能需要停机才行。</p><p>为了解决上面的问题，以及能够进一步提高DistributIdService的性能，如果使用第三种生成分布式ID机制。</p><h2 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h2><p>我们可以使用号段的方式来获取自增ID，号段可以理解成批量获取，比如DistributIdService从数据库获取ID时，如果能批量获取多个ID并缓存在本地的话，那样将大大提供业务应用获取ID的效率。</p><p>比如DistributIdService每次从数据库获取ID时，就获取一个号段，比如(1,1000]，这个范围表示了1000个ID，业务应用在请求DistributIdService提供ID时，DistributIdService只需要在本地从1开始自增并返回即可，而不需要每次都请求数据库，一直到本地自增到1000时，也就是当前号段已经被用完时，才去数据库重新获取下一号段。</p><p>所以，我们需要对数据库表进行改动，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> id_generator (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  current_max_id <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'当前最大id'</span>,</span><br><span class="line">  increment_step <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'号段的长度'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这个数据库表用来记录自增步长以及当前自增ID的最大值（也就是当前已经被申请的号段的最后一个值），因为自增逻辑被移到DistributIdService中去了，所以数据库不需要这部分逻辑了。</p><p>这种方案不再强依赖数据库，就算数据库不可用，那么DistributIdService也能继续支撑一段时间。但是如果DistributIdService重启，会丢失一段ID，导致ID空洞。</p><p>为了提高DistributIdService的高可用，需要做一个集群，业务在请求DistributIdService集群获取ID时，会随机的选择某一个DistributIdService节点进行获取，对每一个DistributIdService节点来说，数据库连接的是同一个数据库，那么可能会产生多个DistributIdService节点同时请求数据库获取号段，那么这个时候需要利用乐观锁来进行控制，比如在数据库表中增加一个version字段，在获取号段时使用如下SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> id_generator <span class="keyword">set</span> current_max_id=<span class="comment">#&#123;newMaxId&#125;, version=version+1 where version = #&#123;version&#125;Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>因为newMaxId是DistributIdService中根据oldMaxId+步长算出来的，只要上面的update更新成功了就表示号段获取成功了。</p><p>为了提供数据库层的高可用，需要对数据库使用多主模式进行部署，对于每个数据库来说要保证生成的号段不重复，这就需要利用最开始的思路，再在刚刚的数据库表中增加起始值和步长，比如如果现在是两台Mysql，那么 mysql1将生成号段（1,1001]，自增的时候序列为1，3，4，5，7…. mysql1将生成号段（2,1002]，自增的时候序列为2，4，6，8，10…</p><p>更详细的可以参考滴滴开源的TinyId：<a href="https://github.com/didi/tinyid/wiki/tinyid原理介绍" target="_blank" rel="noopener">github.com/didi/tinyid…</a></p><p>在TinyId中还增加了一步来提高效率，在上面的实现中，ID自增的逻辑是在DistributIdService中实现的，而实际上可以把自增的逻辑转移到业务应用本地，这样对于业务应用来说只需要获取号段，每次自增时不再需要请求调用DistributIdService了。</p><h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>上面的三种方法总的来说是基于自增思想的，而接下来就介绍比较著名的雪花算法-snowflake。</p><p>我们可以换个角度来对分布式ID进行思考，只要能让负责生成分布式ID的每台机器在每毫秒内生成不一样的ID就行了。</p><p>snowflake是twitter开源的分布式ID生成算法，是一种算法，所以它和上面的三种生成分布式ID机制不太一样，它不依赖数据库。</p><p>核心思想是：分布式ID固定是一个long型的数字，一个long型占8个字节，也就是64个bit，原始snowflake算法中对于bit的分配如下图：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.png" alt="雪花算法"></p><ul><li>第一个bit位是标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以固定为0。</li><li>时间戳部分占41bit，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li><li>工作机器id占10bit，这里比较灵活，比如，可以使用前5位作为数据中心机房标识，后5位作为单机房机器标识，可以部署1024个节点。</li><li>序列号部分占12bit，支持同一毫秒内同一个节点可以生成4096个ID</li></ul><p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p><p>snowflake算法实现起来并不难，提供一个github上用java实现的：<a href="https://github.com/beyondfengyu/SnowFlake" target="_blank" rel="noopener">github.com/beyondfengy…</a></p><p>在大厂里，其实并没有直接使用snowflake，而是进行了改造，因为snowflake算法中最难实践的就是工作机器id，原始的snowflake算法需要人工去为每台机器去指定一个机器id，并配置在某个地方从而让snowflake从此处获取机器id。</p><p>但是在大厂里，机器是很多的，人力成本太大且容易出错，所以大厂对snowflake进行了改造。</p><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><p>github地址：<a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener">uid-generator</a></p><p>uid-generator使用的就是snowflake，只是在生产机器id，也叫做workId时有所不同。</p><p>uid-generator中的workId是由uid-generator自动生成的，并且考虑到了应用部署在docker上的情况，在uid-generator中用户可以自己去定义workId的生成策略，默认提供的策略是：应用启动时由数据库分配。说的简单一点就是：应用在启动时会往数据库表(uid-generator需要新增一个WORKER_NODE表)中去插入一条数据，数据插入成功后返回的该数据对应的自增唯一id就是该机器的workId，而数据由host，port组成。</p><p>对于uid-generator中的workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，同一个应用每重启一次就会消费一个workId。</p><p>具体可参考<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">github.com/baidu/uid-g…</a></p><h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><p>github地址：<a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener">Leaf</a></p><p>美团的Leaf也是一个分布式ID生成框架。它非常全面，即支持号段模式，也支持snowflake模式。号段模式这里就不介绍了，和上面的分析类似。</p><p>Leaf中的snowflake模式和原始snowflake算法的不同点，也主要在workId的生成，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，在启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总得来说，上面两种都是自动生成workId，以让系统更加稳定以及减少人工成功。</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>这里额外再介绍一下使用Redis来生成分布式ID，其实和利用Mysql自增ID类似，可以利用Redis中的incr命令来实现原子性的自增与返回，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set seq_id 1     // 初始化自增ID为1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 3Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>使用redis的效率是非常高的，但是要考虑持久化的问题。Redis支持RDB和AOF两种持久化的方式。</p><p>RDB持久化相当于定时打一个快照进行持久化，如果打完快照后，连续自增了几次，还没来得及做下一次快照持久化，这个时候Redis挂掉了，重启Redis后会出现ID重复。</p><p>AOF持久化相当于对每条写命令进行持久化，如果Redis挂掉了，不会出现ID重复的现象，但是会由于incr命令过得，导致重启恢复数据时间过长。</p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单点登录</title>
      <link href="/2020/10/28/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2020/10/28/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>只有光头才能变强。</p></blockquote><blockquote><p>文本已收录至我的GitHub仓库，欢迎Star：<a href="https://github.com/ZhongFuCheng3y/3y" target="_blank" rel="noopener">github.com/ZhongFuChen…</a></p></blockquote><p>在我实习之前我就已经在看单点登录的是什么了，但是实习的时候一直在忙其他的事，所以有几个网站就一直躺在我的收藏夹里边：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/12/16aac3544ce88c36?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="收藏的一些网站"></p><p>在前阵子有个读者来我这投稿，是使用JWT实现单点登录的（但是文章中并没有介绍什么是单点登录），所以我觉得是时候来整理一下了。</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247485189&idx=1&sn=44e9558f3a03f9c5e1ec539e1a10dbe2&chksm=ebd74604dca0cf126c64586b448ee8c7bccd51545d7a27d06b21bc75a2e390f961d7cafac375&token=1875959808&lang=zh_CN#rd" target="_blank" rel="noopener">简单代码实现JWT(json web token)完成SSO单点登录</a></li></ul><h2 id="一、什么是单点登录？"><a href="#一、什么是单点登录？" class="headerlink" title="一、什么是单点登录？"></a>一、什么是单点登录？</h2><p>单点登录的英文名叫做：Single Sign On（简称<strong>SSO</strong>）。</p><p>在<strong>初学/以前</strong>的时候，一般我们就<strong>单系统</strong>，所有的功能都在同一个系统上。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/12/16aac3544cd4a892?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="所有的功能都在同一个系统上"></p><p>后来，我们为了<strong>合理利用资源和降低耦合性</strong>，于是把单系统<strong>拆分</strong>成多个子系统。</p><ul><li>回顾：<a href="https://mp.weixin.qq.com/s/mwn2X0G9UgUDz1sgGgL1mA" target="_blank" rel="noopener">分布式基础知识</a></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/5/12/16aac3544d675a4b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="拆分成多个子系统"></p><p>比如阿里系的<strong>淘宝和天猫</strong>，很明显地我们可以知道这是两个系统，但是你在使用的时候，登录了天猫，淘宝也会自动登录。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb63967305d5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="登录了天猫，淘宝也登录了"></p><p>简单来说，单点登录就是<strong>在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录。</strong></p><h2 id="二、回顾单系统登录"><a href="#二、回顾单系统登录" class="headerlink" title="二、回顾单系统登录"></a>二、回顾单系统登录</h2><p>在我初学JavaWeb的时候，登录和注册是我做得最多的一个功能了（初学Servlet的时候做过、学SpringMVC的时候做过、跟着做项目的时候做过…），反正我也数不清我做了多少次登录和注册的功能了…这里简单讲述一下我们初学时是怎么做登录功能的。</p><p>众所周知，HTTP是<strong>无状态</strong>的协议，这意味着<strong>服务器无法确认用户的信息</strong>。于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是<strong>Cookie</strong>。</p><p>如果说Cookie是检查用户身上的”通行证“来确认用户的身份，那么Session就是通过检查服务器上的”客户明细表“来确认用户的身份的。<strong>Session相当于在服务器中建立了一份“客户明细表”</strong>。</p><p>HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一个用户。于是乎：服务器向用户浏览器发送了一个名为JESSIONID的Cookie，它的值是Session的id值。<strong>其实Session是依据Cookie来识别是否是同一个用户</strong>。</p><p>所以，一般我们单系统实现登录会这样做：</p><ul><li><p>登录</p><p>：将用户信息保存在Session对象中</p><ul><li>如果在Session对象中能查到，说明已经登录</li><li>如果在Session对象中查不到，说明没登录（或者已经退出了登录）</li></ul></li><li><p><strong>注销（退出登录）</strong>：从Session中删除用户的信息</p></li><li><p><strong>记住我（关闭掉浏览器后，重新打开浏览器还能保持登录状态）</strong>：配合Cookie来用</p></li></ul><p>我之前Demo的代码，可以参考一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> * 用户登陆</span><br><span class="line"> *&#x2F;</span><br><span class="line">@PostMapping(value &#x3D; &quot;&#x2F;user&#x2F;session&quot;, produces &#x3D; &#123;&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;&#125;)</span><br><span class="line">public Result login(String mobileNo, String password, String inputCaptcha, HttpSession session, HttpServletResponse response) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断验证码是否正确</span><br><span class="line">    if (WebUtils.validateCaptcha(inputCaptcha, &quot;captcha&quot;, session)) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断有没有该用户</span><br><span class="line">        User user &#x3D; userService.userLogin(mobileNo, password);</span><br><span class="line">        if (user !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;*设置自动登陆，一个星期.  将token保存在数据库中*&#x2F;</span><br><span class="line">            String loginToken &#x3D; WebUtils.md5(new Date().toString() + session.getId());</span><br><span class="line">            user.setLoginToken(loginToken);</span><br><span class="line">            User user1 &#x3D; userService.userUpload(user);</span><br><span class="line"></span><br><span class="line">            session.setAttribute(&quot;user&quot;, user1);</span><br><span class="line"></span><br><span class="line">            CookieUtil.addCookie(response,&quot;loginToken&quot;,loginToken,604800);</span><br><span class="line"></span><br><span class="line">            return ResultUtil.success(user1);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ResultUtil.error(ResultEnum.LOGIN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return ResultUtil.error(ResultEnum.CAPTCHA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用户退出</span><br><span class="line"> *&#x2F;</span><br><span class="line">@DeleteMapping(value &#x3D; &quot;&#x2F;session&quot;, produces &#x3D; &#123;&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;&#125;)</span><br><span class="line">public Result logout(HttpSession session,HttpServletRequest request,HttpServletResponse response ) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;删除session和cookie</span><br><span class="line">    session.removeAttribute(&quot;user&quot;);</span><br><span class="line"></span><br><span class="line">    CookieUtil.clearCookie(request, response, &quot;loginToken&quot;);</span><br><span class="line"></span><br><span class="line">    return ResultUtil.success();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @author ozc</span><br><span class="line">* @version 1.0</span><br><span class="line">* &lt;p&gt;</span><br><span class="line">* 拦截器；实现自动登陆功能</span><br><span class="line">*&#x2F;</span><br><span class="line">public class UserInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private UserService userService;</span><br><span class="line"></span><br><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception &#123;</span><br><span class="line">    User sessionUser &#x3D; (User) request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 已经登陆了，放行</span><br><span class="line">    if (sessionUser !&#x3D; null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;得到带过来cookie是否存在</span><br><span class="line">        String loginToken &#x3D; CookieUtil.findCookieByName(request, &quot;loginToken&quot;);</span><br><span class="line">        if (StringUtils.isNotBlank(loginToken)) &#123;</span><br><span class="line">            &#x2F;&#x2F;到数据库查询有没有该Cookie</span><br><span class="line">            User user &#x3D; userService.findUserByLoginToken(loginToken);</span><br><span class="line">            if (user !&#x3D; null) &#123;</span><br><span class="line">                request.getSession().setAttribute(&quot;user&quot;, user);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;没有该Cookie与之对应的用户(Cookie不匹配)</span><br><span class="line">                CookieUtil.clearCookie(request, response, &quot;loginToken&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;没有cookie、也没有登陆。是index请求获取用户信息，可以放行</span><br><span class="line">            if (request.getRequestURI().contains(&quot;session&quot;)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;没有cookie凭证</span><br><span class="line">            response.sendRedirect(&quot;&#x2F;login.html&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>总结一下上面代码的思路：</p><ul><li>用户登录时，验证用户的账户和密码</li><li>生成一个Token保存在数据库中，将Token写到Cookie中</li><li>将用户数据保存在Session中</li><li>请求时都会带上Cookie，检查有没有登录，如果已经登录则放行</li></ul><p>如果没看懂的同学，建议回顾Session和Cookie和HTTP：</p><ul><li><a href="https://mp.weixin.qq.com/s/JW7mxXEqrV1rZ_pQOteXGQ" target="_blank" rel="noopener">介绍会话技术、Cookie的API、详解、应用</a></li><li><a href="https://mp.weixin.qq.com/s/kjiAznd2MKD0Y-shXtzVQg" target="_blank" rel="noopener">Session介绍、API、生命周期、应用、与Cookie区别</a></li><li><a href="https://mp.weixin.qq.com/s/8cNJy7fbI0CVbTCyrYoDeQ" target="_blank" rel="noopener">什么是HTTP</a></li></ul><h2 id="三、多系统登录的问题与解决"><a href="#三、多系统登录的问题与解决" class="headerlink" title="三、多系统登录的问题与解决"></a>三、多系统登录的问题与解决</h2><h3 id="3-1-Session不共享问题"><a href="#3-1-Session不共享问题" class="headerlink" title="3.1 Session不共享问题"></a>3.1 Session不共享问题</h3><p>单系统登录功能主要是用Session保存用户信息来实现的，但我们清楚的是：多系统即可能有多个Tomcat，而Session是依赖当前系统的Tomcat，所以系统A的Session和系统B的Session是<strong>不共享</strong>的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb63966d02418?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="系统A的Session和系统B的Session是不共享的"></p><p>解决系统之间Session不共享问题有一下几种方案：</p><ul><li><p>Tomcat集群Session全局复制（集群内每个tomcat的session完全同步）【会影响集群的性能呢，不建议】</p></li><li><p>根据请求的IP进行<strong>Hash映射</strong>到对应的机器上（这就相当于请求的IP一直会访问同一个服务器）【如果服务器宕机了，会丢失了一大部分Session的数据，不建议】</p></li><li><p>把Session数据放在Redis中（使用Redis模拟Session）【</p><p>建议</p><p>】</p><ul><li>如果还不了解Redis的同学，建议移步（<a href="https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A" target="_blank" rel="noopener">Redis合集</a>）</li></ul></li></ul><p>我们可以将登录功能<strong>单独抽取</strong>出来，做成一个子系统。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb639676f4f1d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="抽取出来成为子系统"></p><p>SSO（登录系统）的逻辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 登录功能(SSO单独的服务)</span><br><span class="line">@Override</span><br><span class="line">public TaotaoResult login(String username, String password) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据用户名查询用户信息</span><br><span class="line">TbUserExample example &#x3D; new TbUserExample();</span><br><span class="line">Criteria criteria &#x3D; example.createCriteria();</span><br><span class="line">criteria.andUsernameEqualTo(username);</span><br><span class="line">List&lt;TbUser&gt; list &#x3D; userMapper.selectByExample(example);</span><br><span class="line">if (null &#x3D;&#x3D; list || list.isEmpty()) &#123;</span><br><span class="line">return TaotaoResult.build(400, &quot;用户不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;核对密码</span><br><span class="line">TbUser user &#x3D; list.get(0);</span><br><span class="line">if (!DigestUtils.md5DigestAsHex(password.getBytes()).equals(user.getPassword())) &#123;</span><br><span class="line">return TaotaoResult.build(400, &quot;密码错误&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;登录成功，把用户信息写入redis</span><br><span class="line">&#x2F;&#x2F;生成一个用户token</span><br><span class="line">String token &#x3D; UUID.randomUUID().toString();</span><br><span class="line">jedisCluster.set(USER_TOKEN_KEY + &quot;:&quot; + token, JsonUtils.objectToJson(user));</span><br><span class="line">&#x2F;&#x2F;设置session过期时间</span><br><span class="line">jedisCluster.expire(USER_TOKEN_KEY + &quot;:&quot; + token, SESSION_EXPIRE_TIME);</span><br><span class="line">return TaotaoResult.ok(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其他子系统登录时，<strong>请求SSO（登录系统）进行登录，将返回的token写到Cookie中</strong>，下次访问时则把Cookie带上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public TaotaoResult login(String username, String password, </span><br><span class="line">HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">&#x2F;&#x2F;请求参数</span><br><span class="line">Map&lt;String, String&gt; param &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">param.put(&quot;username&quot;, username);</span><br><span class="line">param.put(&quot;password&quot;, password);</span><br><span class="line">&#x2F;&#x2F;登录处理</span><br><span class="line">String stringResult &#x3D; HttpClientUtil.doPost(REGISTER_USER_URL + USER_LOGIN_URL, param);</span><br><span class="line">TaotaoResult result &#x3D; TaotaoResult.format(stringResult);</span><br><span class="line">&#x2F;&#x2F;登录出错</span><br><span class="line">if (result.getStatus() !&#x3D; 200) &#123;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;登录成功后把取token信息，并写入cookie</span><br><span class="line">String token &#x3D; (String) result.getData();</span><br><span class="line">&#x2F;&#x2F;写入cookie</span><br><span class="line">CookieUtils.setCookie(request, response, &quot;TT_TOKEN&quot;, token);</span><br><span class="line">&#x2F;&#x2F;返回成功</span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>SSO系统生成一个token，并将用户信息存到Redis中，并设置过期时间</li><li>其他系统请求SSO系统进行登录，得到SSO返回的token，写到Cookie中</li><li>每次请求时，Cookie都会带上，拦截器得到token，判断是否已经登录</li></ul><p>到这里，其实我们会发现其实就两个变化：</p><ul><li>将登陆功能抽取为一个系统（SSO），其他系统请求SSO进行登录</li><li>本来将用户信息存到Session，现在将用户信息存到Redis</li></ul><h3 id="3-2-Cookie跨域的问题"><a href="#3-2-Cookie跨域的问题" class="headerlink" title="3.2 Cookie跨域的问题"></a>3.2 Cookie跨域的问题</h3><p>上面我们解决了Session不能共享的问题，但其实还有另一个问题。<strong>Cookie是不能跨域的</strong></p><p>比如说，我们请求<code>&lt;https://www.google.com/&gt;</code>时，浏览器会自动把<code>google.com</code>的Cookie带过去给<code>google</code>的服务器，而不会把<code>&lt;https://www.baidu.com/&gt;</code>的Cookie带过去给<code>google</code>的服务器。</p><p>这就意味着，<strong>由于域名不同</strong>，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。</p><p>针对Cookie存在跨域问题，有几种解决方案：</p><ol><li>服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了</li><li>多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。</li><li>将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了）</li></ol><p>到这里，我们已经可以实现单点登录了。</p><h3 id="3-3-CAS原理"><a href="#3-3-CAS原理" class="headerlink" title="3.3 CAS原理"></a>3.3 CAS原理</h3><p>说到单点登录，就肯定会见到这个名词：CAS （Central Authentication Service），下面说说CAS是怎么搞的。</p><p><strong>如果已经将登录单独抽取成系统出来</strong>，我们还能这样玩。现在我们有两个系统，分别是<code>www.java3y.com</code>和<code>www.java4y.com</code>，一个SSO<code>www.sso.com</code></p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb639678ec21c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="现在我们有三个系统"></p><p>首先，用户想要访问系统A<code>www.java3y.com</code>受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统A<code>www.java3y.com</code>发现用户并没有登录，于是<strong>重定向到sso认证中心，并将自己的地址作为参数</strong>。请求的地址如下：</p><ul><li><code>www.sso.com?service=www.java3y.com</code></li></ul><p>sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立<strong>全局会话（生成一份Token，写到Cookie中，保存在浏览器上）</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb6396dba1c48?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="4步过程"></p><p>随后，认证中心<strong>重定向回系统A</strong>，并把Token携带过去给系统A，重定向的地址如下：</p><ul><li><code>www.java3y.com?token=xxxxxxx</code></li></ul><p>接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（<strong>创建Session</strong>）。到此，系统A和用户已经是登录状态了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb6396e70f83b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="第五步和第六步"></p><p>此时，用户想要访问系统B<code>www.java4y.com</code>受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统B<code>www.java4y.com</code>发现用户并没有登录，于是<strong>重定向到sso认证中心，并将自己的地址作为参数</strong>。请求的地址如下：</p><ul><li><code>www.sso.com?service=www.java4y.com</code></li></ul><p>注意，因为之前用户与认证中心<code>www.sso.com</code>已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B<strong>重定向</strong>到认证中心<code>www.sso.com</code>是可以带上Cookie的。</p><p>认证中心<strong>根据带过来的Cookie</strong>发现已经与用户建立了全局会话了，认证中心<strong>重定向回系统B</strong>，并把Token携带过去给系统B，重定向的地址如下：</p><ul><li><code>www.java4y.com?token=xxxxxxx</code></li></ul><p>接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（<strong>创建Session</strong>）。到此，系统B和用户已经是登录状态了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb63a1ccb78a1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="系统B的流程图"></p><p>看到这里，其实SSO认证中心就类似一个<strong>中转站</strong></p><p>作者：Java3y<br>链接：<a href="https://juejin.im/post/6844903845424971783" target="_blank" rel="noopener">https://juejin.im/post/6844903845424971783</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/2020/10/28/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2020/10/28/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//集合中是否还有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得集合中的下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>Iterator</code> 对象称为迭代器（设计模式的一种），迭代器可以对集合进行遍历，但每一个集合内部的数据结构可能是不尽相同的，所以每一个集合存和取都很可能是不一样的，虽然我们可以人为地在每一个类中定义 <code>hasNext()</code> 和 <code>next()</code> 方法，但这样做会让整个集合体系过于臃肿。于是就有了迭代器。</p><p>迭代器是将这样的方法抽取出接口，然后在每个类的内部，定义自己迭代方式，这样做就规定了整个集合体系的遍历方式都是 <code>hasNext()</code>和<code>next()</code>方法，使用者不用管怎么实现的，会用即可。迭代器的定义为：提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。</p><h4 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h4><p><code>Iterator</code> 主要是用来遍历集合用的，它的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 <code>ConcurrentModificationException</code> 异常。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>我们通过使用迭代器来遍历 <code>HashMap</code>，演示一下 迭代器 Iterator 的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"Java"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"C++"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"PHP"</span>);</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">  System.out.println(entry.getKey() + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识大杂烩</title>
      <link href="/2020/10/25/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
      <url>/2020/10/25/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<p>作者：0XCAFEBABY<br>链接：<a href="https://www.nowcoder.com/discuss/438311" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/438311</a><br>来源：牛客网</p><p>1.JDK JRE<br>\2. Java异常了解吗？说说平时遇到的异常？说出6种常见的java异常。写程序遇到过哪些异常 运行时异常有哪些<br>\3. 面向对象 面对对象的几大特性 多态怎么理解<br>\4. 修饰符：public；protect；default；private优先级<br>\5. 对string类的理解。stringbuffer 和 stringbuilder<br>\6. 反射机制介绍一下<br>\7. bio，nio，aio分别介绍一下，nio的实现方式<br>\8. 问了public等变量定义修饰词的时间域<br>\9. 问了反射机制，还有问了动态代理的好处和坏处，好处答不上来<br>\10. 接口和抽象类的区别。<br>\11. 有一个public static final的HashMap，里边对象的属性能不能修改？<br>\12. 为什么java 平台无关性 机器码和字节码区别 JVM加载代码的一个流程<br>\13. java数据类型以及自己的应用 自动拆箱和自动装箱以及自己的应用即什么时候用到的，列举几种情况<br>\14. 什么是值传递和引用传递，区别及应用<br>\15. 重载和重写<br>\16. static方法是否能重写，接口和抽象类的区别<br>\17. 你觉得java是一种什么样的语言以及java特性<br>\18. lamda表达式了解吗？1.8新特性有什么？（面试宝典对接口抽象这个问题是错的，过时了）<br>\19. 内存泄露怎么造成的，怎么排查<br>\20. 讲讲final修饰符。<br>\21. 一个对象占多少内存。<br>\22. 最短路径问题<br>\23. java浅拷贝和深拷贝<br>\24. 内存泄露的原因和处理<br>\25. java反射机制，优点缺点<br>\26. 说说静态变量和非静态变量的区别，用类名调用静态变量和用实例对象调用静态变量有区别吗？非静态方法里可以有静态变量吗？<br>\27. static能不能被重写？<br> - 重写方法的目的是为了多态，或者说：重写是实现多态的前提，即重写是发生在继承中且是针对非static方法的。<br>语法上子类允许出现和父类只有方法体不一样其他都一模一样的static方法，但是在父类引用指向子类对象时，通过父类引用调用的依然是父类的static方法，而不是子类的static方法。<br>即：语法上static支持重写，但是运行效果上达不到多态目的<br>\28. 序列化，反序列化，什么时候用？ 如何对一个对象序列化</p><h2 id="Java集合类"><a href="#Java集合类" class="headerlink" title="Java集合类"></a>Java集合类</h2><ol><li>Hashmap底层（数组+<a href>链表</a>+<a href>红黑树</a>）hashmap为什么线程不安全，如何保证线程安全，就扯到concurrenthashmap hashmap底层实现 多线程会出现什么情况 扩容机制是什么为什么会死锁 如何解决碰撞 Jdk 1.8的优化。为什么使用<a href>红黑树</a>，它是如何做到效率优化的？ hashmap了解不，原理是什么，位图了解不，跳跃表了解不，<a href>红黑树</a>了解不，<a href>红黑树</a>插入过程，B+树了解不，B+树特点和插入过程，邻接表和邻接矩阵区别，分别在什么地方用到，<br> 插入和查询的流程。</li><li>concurrenthashmap1.7和1.8的区别；concurrenthashmap说说，它是如何保证线程安全的？jdk1.7的hashentry和segment锁。具体说说segment锁？能讲下ConcurrentHashMap的实现原理么 JDK7或者8都行</li><li>常用集合类 实现类 </li><li>list和set区别（重复/不重复）</li><li>set，list，map（线程安全的map，map怎么实现之类的）</li><li><a href>红黑树</a>介绍一下，跟<a href>平衡二叉树</a>比较一下，<a href>红黑树</a>有哪些应用场景</li><li>你常用的数据结构有哪些？</li><li><a href>红黑树</a>的特点，AVL树</li><li>一致性哈希函数以及hashmap的put方法</li><li>数组、二叉搜索树、B树、B+树</li><li>堆和栈。堆、栈</li><li><a href>二叉树</a>的最大节点个数；2^n-1;</li></ol><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><ol><li>java创建线程的方式，runnable和callable区别（参数不同）1. java线程的状态有哪些；线程的几种状态</li><li>wait和sleep的区别；wait和notify的使用场景；</li><li>介绍一下volatile以及原理；volatile介绍一下Volatile底层是如何实现的？ 说了内存可见性和内存屏障，Volatile是绝对线2程安全的吗？不是，没有保证原子性。volatile关键字在线程通信的问题</li><li>介绍一下synchornized以及原理； lock和synchornized的区别；synchronized锁的升级过程？Synchronized，底层是如何实现的？说了monitor对象头，以及两个monitorenter和monitorexit运用于代码块。<br>对象头是存储了哪些信息？说说synchronized的锁优化过程？说了偏向，自旋，轻量和重量。</li><li>介绍一下AQS;</li><li>说一下公平锁和非公平锁的原理；</li><li>cas操作是什么，以及可能出现的问题；</li><li>线程池，然后你再平时怎么用的，工作原理，有哪些重要参数，饱和策略有哪些；线程池了解吧，说说如何实现线程池？核心参数哪些？有哪些阻塞队列呢？如何优雅的关闭线程池 线程池（线程大小，阻塞队列）线程创建，线程池参数，说说你常用的线程池？说了new ***d 和newFixed。以及介绍各个参数</li><li>说说你理解的悲观锁和乐观锁？乐观锁有哪些？乐观锁有什么缺点？</li><li>阻塞队列 线程间通信方式 创建线程方式 创建线程池方式 线程池常用参数</li><li>锁有哪些</li><li>说说你常用的并发包JUI？</li><li>问了如何保证多线程通信</li><li>你用过Java的J.U.C并发包吧，给我讲一下AQS的原理</li><li>CAS的原理给我讲一下，他是怎么保证内存的可见性的。CAS会产生什么问题</li><li>知道Java中的内存模型吧，它有8个指令你给我说一下</li><li>多线程如何保持同步？</li><li>java可见性的关键字及其原理。</li><li>cpu密集型多线程和io密集型多线程的比较。cpu密集型里如何管理多线程？ 用什么样的线程池和阻塞队列？</li><li>cpu线程特别多会产生什么问题？io密集型里怎么减少需要的线程数？</li><li>io多路复用的原理和实现。怎么减少处理io（和磁盘io交互）所需要的线程？</li><li>线程实现方式。有什么区别。线程之间的通讯，进程之间的通讯。</li></ol><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol><li>JVM运行时内存区域划分？哪些线程私有？运行时数据区，私有共享都是哪些？堆区内存如何分配？</li><li>对象的生命周期？</li><li>JVM垃圾回收器，cms和g1的特点，两者的区别是什么，比g1更加先进的垃圾回收器有了解么，ZGC原理，能够管理多大的内存，CMS能管理多大的内存，G1呢</li><li>JVM内存模型 类的生命周期 类加载过程 双亲委派机制了解吗 进入老年代过程 什么情况下直接进入老年代</li><li>JVM内存分布（堆栈等，程序计数器+jvm栈+本地方法栈线程不共享，堆和方法区线程共享）</li><li>类加载机制，过程，类加载机制？如何自定义实现类加载器？双亲委派模型、类加载器类别，双亲委派模型本质是解决了什么问题？安全性，有哪几种类加载器？类加载的流程。知道哪些类加载器。类加载器之间的关系？双亲委派模型。为什么使用双亲委派模型？</li><li>垃圾回收<a href>算法</a>，常见的垃圾回收器及他们之间区别，垃圾回收发生在哪里，怎么判断对象存活、GC Roots具体有哪些、讲讲对象分配与回收，什么可以作为垃圾回收的对象，垃圾回收<a href>算法</a>和流程。</li><li>栈什么情况下会溢出？</li><li>静态变量存放在内存哪个区域？</li><li>怎么查看java虚拟机内存占用？</li><li>如何减少full gc的次数？方法区是否需要gc</li><li>4个引用类型 </li></ol><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol><li>输入一个url后的过程；浏览器从发送请求的全部过程</li><li>OSI七层和TCP四层协议，OSI七层模型/五层模型，每一层有哪些协议，http，tcp，ip位于哪一层</li><li>TCP三次握手四次分手，tcp四次挥手为什么要四次，为什么TCP是安全的，TCP，UDP的区别</li><li>TCP报文结构，HTTP结构， TCP，UDP，HTTP的报文格式（我懵了）</li><li>设计一个应用层协议（没有答出来</li><li>HTTP协议连接过程，HTTPS连接过程，HTTP的长连接是怎么做的HTTP2和HTTP1区别，HTTP请求过程<br>http的几种方法，HTTP跟HTTPS的区别，https加密过程</li></ol><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol><li>程序，进程和线程的区别</li><li>什么时候情况下要用多线程？</li><li>进程之间怎么通信的？</li><li>一个手机应用程序里面的进程和线程分别是怎么进行的？</li><li>死锁，怎么解死锁，死锁条件，怎么预防</li><li>进程的状态：阻塞+就绪+执行</li><li>手机内存8g，是32位的，一个进程能申请多少内存？</li><li>线程的应用，举例，线程的阻塞</li><li>主线程和子线程的区别</li></ol><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux :"></a>Linux :</h2><ol><li>linux中如何查看CPU负载 top</li><li>linux用过嘛（扯到了我训练过深度模型，小哥哥直接来了个场景题）<br>场景题：推荐<a href>算法</a>中如何控制广告推送频率（结合强化学习说了一些</li><li>Linux了解不，df dh区别，如何格式化磁盘，磁盘挂载过程，tcp丢包如何排查，docker是用什么实现的</li><li>怎么查找特定后缀名或前缀名的文件</li></ol><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ol><li>数据库引擎事务隔离级别，串行化如何实现，数据库的隔离级别？四个。你平常使用的是哪个隔离级别。数据库隔离级别以及分别解决了什么问题</li><li>MySQL的存储引擎有哪些？它们之间的区别？你用的mysql存储引擎？为什么选择它？实现原理？</li><li>怎么判断一个SQL语句有没有走索引？紧接着问explain知道哪些字段吗</li><li>mysql存储模型 区别 怎么看用没用索引 怎么判断sql语句好坏</li><li>数据库中索引B+树</li><li>一个手机应用要更改数据库，它的底层是怎么实现的？</li><li>sql查询过程</li><li>MySQL InnoDB存储引擎中的MVCC解决了什么问题，能说下MVCC的实现原理么</li><li>SQL语句经常写吧，那我给你出一道SQL题（分组求和<a href>排序</a>）</li><li>你认为什么情况下不应该建立索引</li><li>mysql有几种锁？怎么实现？</li><li>innodb事物的级别</li><li>b 树的结构？与<a href>二叉树</a>的区别？与b树的区别？</li><li>写过最复杂的sql， 手写代码： 统计各个科目考试最高分:最复杂的包括了sum、case、left join、group by，追问左连接和内联区别，没答上来</li><li>聚簇索引跟<a href>红黑树</a></li><li>sql :给一个日期范围，统计每天入库的数据总量</li><li>sql语句里like和in关键字</li><li>sql语句，求平均分超过60分的学生学号</li><li>数据库sql怎么优化 </li><li>什么情况不能用索引？</li><li>SELECT column_name(s)<br>FROM table_name<br>WHERE column_name<br>BETWEEN value1 AND value2 什么时候会发生死锁；怎么解决死锁；N个资源怎么办？</li></ol><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a><a href>redis</a></h2><ol><li>你知道<a href>redis</a>的什么东西</li><li><a href>redis</a>中zset，说了一下跳跃表的插入，删除过程；</li><li>位图知道原理嘛（操作系统中的位示图还是bitmap?不太了解）</li><li><a href>redis</a>数据类型，<a href>redis</a>的应用场景，为什么<a href>redis</a>快</li><li>Redis的key的写入和删除的原理</li><li>怎么保证Redis的高可用</li><li><a href>redis</a>数据结构？单线程还是多线程？</li><li>用什么样的队列？你是怎么实现？我回答的<a href>redis</a>的list实现的）这种队列有什么缺点？</li><li>分布式锁；</li></ol><h2 id="mq"><a href="#mq" class="headerlink" title="mq"></a>mq</h2><ol><li>你还用过rabbitMQ呀，它能够做什么？</li><li>rabbitMQ是怎么保证消息不丢的，从<a href>客户端</a>—消息队列， 消息队列—服务器端的角度考虑</li></ol><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><ol><li>开源框架有哪些了解的 为什么用spring 为什么不用new就可以自动生产 能不能自己实现一个</li><li>spring security是干嘛的，原理是啥，jwt干啥的</li><li>后台用什么框架？ioc，aop,其他还有什么框架也可以做到ioc,aop（2333～不就spring?）</li><li>Spring IOC,AOP,注解</li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol><li>双重检索单例</li><li>设计模式分为哪三类，各有什么？设计模式，用过哪些设计模式，讲几个，设计模式和原则</li><li>代理模式属于哪一类</li><li>生产者消费者模式,生产消费者的，以及多生产者同步</li><li>描述适配器，写单例</li><li>单例模式，装饰模式，</li></ol><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ol><li>负载均衡的<a href>算法</a>有哪些；</li><li>rpc dubbo的组件有哪些</li><li>分布式事务，CAP定理，有没有使用过相关的产品</li><li>zoo<a href>keep</a>er了解吗</li><li>hbase索引的结构，kafka存储的结构，二进制文件的组织方式，kafka如何避免消息丢失，zoo<a href>keep</a>er在kafka中是干啥的，kafka在zoo<a href>keep</a>er中存储的数据，zoo<a href>keep</a>er了解不，zoo<a href>keep</a>er的共识<a href>算法</a>，分区后如何解决。</li><li>protobuf了解不，grpc了解不，用的什么协议，HTTP2和HTTP1区别，websocket建立连接过程</li><li>RPC你了解过吗？</li><li>如何分布式存储？</li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><a href>算法</a></h2><ol><li><a href>排序</a><a href>算法</a>有哪些，简述冒泡和归并<a href>排序</a>，冒泡<a href>算法</a>的优化,讲讲归并<a href>排序</a>,冒泡的优化知道吗；回答相等不交换，还有flag做已<a href>排序</a>标志的优化；直接插入<a href>排序</a>，写一下伪代码或者说一下思路,插入<a href>排序</a>，时间复杂度</li><li>堆<a href>排序</a>原理</li><li>快排,快排是什么思想，快排的优化是啥，为啥这么做；</li><li>字母<a href>排序</a></li><li>100个数中找出想要的数</li><li>一个数组分成2个相等或接近的子数组</li><li>派单的最短路径问题</li><li>很大的数据，内存放不下，如何快速找到中间值</li><li>手撕栈</li><li><a href>链表</a>找环 <a href>链表</a>找环入口，不用双指针怎么做</li><li>双向<a href>链表</a>实现 ，写了个add()和add(index)的</li><li>求数组的全排列</li><li>中序遍历，递归非递归</li><li>求四个数绝对值的最小值</li><li>黑猫白猫，混在一起，如何把他们区分开？ 黑白灰三种猫混在一起，如何按照黑白灰排好序？ 还有两个小问题忘记了。</li><li>如何用一个int值，表示三种状态？</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>给你10个tomcat你如何判断自己用哪个（容器？emmmm，求指点）<br>位图知道原理嘛（操作系统中的位示图还是bitmap?不太了解）<br>所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此可以大大节省存储空间。<br>其实就是位示图为原型，01存储的，建议面试的时候知道多少说多少，知道什么说什么~</li><li>序列化相关</li><li>最后还是问<a href>项目</a>，<a href>项目</a>中的难点，是如何解决的？</li><li>c++编程搞过没，GPU编程了解不，用的什么GPU，GPU运算性能是什么决定的</li><li>如果某个用户同时请求创建活动接口100次，如果防止它被重复创建？创建前查看该记录是否存在、使用锁、如果是分布式的使用分布式锁—这样解决了99.99%的问题。除了使用这些方案，还能使用什么方法解决吗？</li><li>讲讲分布式锁的实现</li><li>io量很大，队列很长怎么办？</li><li>Q:觉得用过的模板解析引擎有什么不同的特征。<br>A:用过JSP和Thymeleaf，JSP我就说适合Java程序员做<a href>前端</a>，本质还是Servlet，生产环境下调试方便；Thymeleaf是SpringBoot<a href>项目</a>碰到的，本质是EL，语法特殊，但是前后端传值、传对象方便。</li><li>讲一下对jQUERY的使用感受<br>A：研一的<a href>项目</a>做过iOS开发，用OC做的webview APP，用到了jQuery Mobile做界面和事件控制，感觉很方便。 后面的Web<a href>项目</a>主要用来进行Ajax操作，选择器很方便。</li><li>硕士一个<a href>项目</a>涉及到跨系统集成，要我在纸上画出集成逻辑架构，介绍一下开发用到的技术和业务环境。<br> 集成用的WebService，引入Apache旗下的Axis， 涉及到文件传输和多数据源配置。。。。</li><li>用过eclipse、IDEA、Myeclipse，评价一下区别 代码提示、插件库、收费与免费、代码模板、资源消耗</li><li>用过EJB和SSH，评价一下区别</li><li>问了实习经历 了解分布式吗？</li><li>你怎么用的websocket?</li><li>想做安卓还是java后台？手机端安卓怎么开发的？</li><li>activity四大组件</li><li>介绍一下service</li><li>APP的启动流程</li><li>Android事件分发机制</li><li>view的测量方法；</li><li>Android之间线程通信</li><li>介绍一个你用心做的模块，<a href>项目</a>流程，怎么理解异步同步，什么场景用；<br>static能不能被重写？</li><li>MD5为啥要加盐(彩虹表·)；UUID有多少位(32位)</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis源码剖析</title>
      <link href="/2020/10/24/redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/10/24/redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><a href="https://juejin.im/post/6855129008091332615" target="_blank" rel="noopener">https://juejin.im/post/6855129008091332615</a></p><p>本文知识脑图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758550e143b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h2 id="一、Redis的数据模型"><a href="#一、Redis的数据模型" class="headerlink" title="一、Redis的数据模型"></a>一、Redis的数据模型</h2><p>用 键值对 <code>name：&quot;小明&quot;</code>来展示Redis的数据模型如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758534a337a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><ul><li><strong>dictEntry:</strong>   在一些编程语言中，键值对的数据结构被称为字典，而在Redis中，会给每一个key-value键值对分配一个字典实体，就是“dicEntry”。dicEntry包含三部分： <strong>key的指针、val的指针、next指针</strong>，next指针指向下一个dicteEntry形成链表，这个next指针可以将多个哈希值相同的键值对链接在一起，<strong>通过链地址法来解决哈希冲突的问题</strong></li><li><strong>sds</strong> ：<strong>Simple Dynamic String</strong>，简单动态字符串，存储字符串数据。</li><li><strong>redisObject</strong>：Redis的5种常用类型都是以RedisObject来存储的，redisObject中的<strong>type</strong>字段指明了值的数据类型（也就是5种基本类型)。<strong>ptr</strong>字段指向对象所在的地址。</li></ul><p>RedisObject对象很重要，Redis<strong>对象的类型</strong>、<strong>内部编码</strong>、<strong>内存回收</strong>、<strong>共享对象</strong>等功能，都是基于RedisObject对象来实现的。</p><p><strong>这样设计的好处是：可以针对不同的使用场景，对5种常用类型设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</strong></p><p>Redis将jemalloc作为默认内存分配器，减小内存碎片。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Redis 对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 类型</span><br><span class="line">    unsigned type:4;        </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 不使用(对齐位)</span><br><span class="line">    unsigned notused:2;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 编码方式</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; LRU 时间（相对于 server.lruclock）</span><br><span class="line">    unsigned lru:22;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 引用计数</span><br><span class="line">    int refcount;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 指向对象的值</span><br><span class="line">    void *ptr;</span><br><span class="line"> </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h2 id="二、Redis支持的数据结构"><a href="#二、Redis支持的数据结构" class="headerlink" title="二、Redis支持的数据结构"></a>二、Redis支持的数据结构</h2><p>Redis支持的数据结构有哪些？</p><p>如果回答是String、List、Hash、Set、Zset就不对了，这5种是redis的常用基本数据类型，每一种数据类型内部还包含着多种数据结构。</p><p>用encoding指令来看一个值的数据结构。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name tom</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此处设置了name值是tom，它的数据结构是embstr，下文介绍字符串时会详解说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding age</span><br><span class="line">&quot;int&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如下表格总结Redis中所有的数据结构类型：</p><table><thead><tr><th>底层数据结构</th><th>编码常量</th><th>object encoding指令输出</th></tr></thead><tbody><tr><td>整数类型</td><td>REDIS_ENCODING_INT</td><td>“int”</td></tr><tr><td>embstr字符串类型</td><td>REDIS_ENCODING_EMBSTR</td><td>“embstr”</td></tr><tr><td>简单动态字符串</td><td>REDIS_ENCODING_RAW</td><td>“raw”</td></tr><tr><td>字典类型</td><td>REDIS_ENCODING_HT</td><td>“hashtable”</td></tr><tr><td>双端链表</td><td>REDIS_ENCODING_LINKEDLIST</td><td>“linkedlist”</td></tr><tr><td>压缩列表</td><td>REDIS_ENCODING_ZIPLIST</td><td>“ziplist”</td></tr><tr><td>整数集合</td><td>REDIS_ENCODING_INTSET</td><td>“intset”</td></tr><tr><td>跳表和字典</td><td>REDIS_ENCODING_SKIPLIST</td><td>“skiplist”</td></tr></tbody></table><p><strong>补充说明</strong></p><blockquote><p>假如面试官问：redis的数据类型有哪些？</p><p>回答：String、list、hash、set、zet</p></blockquote><p>一般情况下这样回答是正确的，前文也提到redis的数据类型确实是包含这5种，但细心的同学肯定发现了之前说的是<strong>“常用”</strong>的5种数据类型。其实，随着Redis的不断更新和完善，Redis的数据类型早已不止5种了。</p><p>登录redis的官方网站打开官方的数据类型介绍：</p><p><a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">redis.io/topics/data…</a></p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b4475857ff2a94?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>发现Redis支持的数据结构不止5种，而是8种，后三种类型分别是：</p><ul><li>位数组（或简称位图）：使用特殊命令可以处理字符串值，如位数组：您可以设置和清除各个位，将所有位设置为1，查找第一个位或未设置位，等等。</li><li>HyperLogLogs：这是一个概率数据结构，用于估计集合的基数。不要害怕，它比看起来更简单。</li><li>Streams：仅附加的类似于地图的条目集合，提供抽象日志数据类型。</li></ul><p>本文主要介绍5种常用的数据类型，上述三种以后再共同探索。</p><h3 id="2-1-string字符串"><a href="#2-1-string字符串" class="headerlink" title="2.1 string字符串"></a>2.1 string字符串</h3><p>字符串类型是redis最常用的数据类型，在Redis中，字符串是可以修改的，在底层它是以字节数组的形式存在的。</p><p>Redis中的字符串被称为简单动态字符串「SDS」，这种结构很像Java中的ArrayList，其长度是动态可变的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SDS&lt;T&gt; &#123;</span><br><span class="line">  T capacity; &#x2F;&#x2F; 数组容量</span><br><span class="line">  T len; &#x2F;&#x2F; 数组长度</span><br><span class="line">  byte[] content; &#x2F;&#x2F; 数组内容</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b447584f4b52d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p><strong>content[]</strong> 存储的是字符串的内容，<strong>capacity</strong>表示数组分配的长度，<strong>len</strong>表示字符串的实际长度。</p><p>字符串的编码类型有int、embstr和raw三种，如上表所示，那么这三种编码类型有什么不同呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;    &#x2F;&#x2F;简单动态字符串(simple dynamic string, SDS)的抽象类型</span><br><span class="line">  &#x2F;&#x2F; 用于记录buf数组中使用的字节的数目</span><br><span class="line">  &#x2F;&#x2F; 和SDS存储的字符串的长度相等  </span><br><span class="line">int len;    </span><br><span class="line">  &#x2F;&#x2F; 用于记录buf数组中没有使用的字节的数目   </span><br><span class="line">int free;    </span><br><span class="line">  &#x2F;&#x2F; 字节数组，用于储存字符串</span><br><span class="line">char buf[];   &#x2F;&#x2F;buf的大小等于len+free+1，其中多余的1个字节是用来存储’\0’的。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>int 编码</strong>：保存的是可以用 long 类型表示的整数值。</li><li><strong>raw 编码</strong>：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li><li><strong>embstr 编码</strong>：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li></ul><p><img src="https://img2018.cnblogs.com/blog/1432634/201907/1432634-20190724185636136-1199490260.png" alt="img"></p><p>设置一个值测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set num 300</span><br><span class="line">127.0.0.1:6379&gt; object encoding num</span><br><span class="line">&quot;int&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key1 wealwaysbyhappyhahaha</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key2 hahahahahahahaahahahahahahahahahahahaha</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; strlen key2</span><br><span class="line">(integer) 39</span><br><span class="line">127.0.0.1:6379&gt; object encoding key2</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key2 hahahahahahahaahahahahahahahahahahahahahahaha</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key2</span><br><span class="line">&quot;raw&quot;</span><br><span class="line">127.0.0.1:6379&gt; strlen key2</span><br><span class="line">(integer) 45</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="raw类型和embstr类型对比"><a href="#raw类型和embstr类型对比" class="headerlink" title="raw类型和embstr类型对比"></a>raw类型和embstr类型对比</h4><p>embstr编码的结构:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b447584f3e35a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>raw编码的结构：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758547bc9c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="raw编码"></p><blockquote><p>embstr和raw都是由redisObject和sds组成的。不同的是：embstr的redisObject和sds是连续的，只需要使用<strong>malloc</strong>分配一次内存；而raw需要为redisObject和sds分别分配内存，即需要分配两次内存。</p><p>所有相比较而言，embstr少分配一次内存，更方便。但embstr也有明显的缺点：如要增加长度，redisObject和sds都需要重新分配内存。</p></blockquote><p>上文介绍了embstr和raw结构上的不同。重点来了~ <strong>为什么会选择44作为两种编码的分界点？在3.2版本之前为什么是39？这两个值是怎么得出来的呢？</strong></p><p><strong>1） 计算RedisObject占用的字节大小</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct RedisObject &#123;</span><br><span class="line">    int4 type; &#x2F;&#x2F; 4bits</span><br><span class="line">    int4 encoding; &#x2F;&#x2F; 4bits</span><br><span class="line">    int24 lru; &#x2F;&#x2F; 24bits</span><br><span class="line">    int32 refcount; &#x2F;&#x2F; 4bytes &#x3D; 32bits</span><br><span class="line">    void *ptr; &#x2F;&#x2F; 8bytes，64-bit system</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>type: 不同的redis对象会有不同的数据类型(string、list、hash等)，type记录类型，会用到<strong>4bits</strong>。</li><li>encoding：存储编码形式，用<strong>4bits</strong>。</li><li>lru：用<strong>24bits</strong>记录对象的LRU信息。</li><li>refcount：引用计数器，用到<strong>32bits</strong>。</li><li><em>ptr：指针指向对象的具体内容，需要*</em>64bits**。</li></ul><p>计算： 4 + 4 + 24 + 32 + 64 = 128bits = <strong>16bytes</strong></p><p>第一步就完成了，RedisObject对象头信息会占用<strong>16字节</strong>的大小，这个大小通常是固定不变的.</p><p><strong>2) sds占用字节大小计算</strong></p><p><strong>旧版本：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SDS &#123;</span><br><span class="line">    unsigned int capacity; &#x2F;&#x2F; 4byte</span><br><span class="line">    unsigned int len; &#x2F;&#x2F; 4byte</span><br><span class="line">    byte[] content; &#x2F;&#x2F; 内联数组，长度为 capacity</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里的<strong>unsigned int</strong> 一个4字节，加起来是8字节.</p><p>内存分配器jemalloc分配的内存如果超出了64个字节就认为是一个大字符串，就会用到raw编码。</p><p>前面提到 SDS 结构体中的 content 的字符串是以字节\0结尾的字符串，之所以多出这样一个字节，是为了便于直接使用 glibc 的字符串处理函数，以及为了便于字符串的调试打印输出。所以我们还要减去1字节 <strong>64byte  -  16byte   -  8byte  -  1byte  =  39byte</strong></p><p><strong>新版本：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct SDS &#123;</span><br><span class="line">    int8 capacity; &#x2F;&#x2F; 1byte</span><br><span class="line">    int8 len; &#x2F;&#x2F; 1byte</span><br><span class="line">    int8 flags; &#x2F;&#x2F; 1byte</span><br><span class="line">    byte[] content; &#x2F;&#x2F; 内联数组，长度为 capacity</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里unsigned int 变成了uint8_t、uint16_t.的形式，还加了一个char flags标识，总共只用了3个字节的大小。相当于优化了sds的内存使用，相应的用于存储字符串的内存就会变大。</p><p>然后进行计算：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b447586c898442?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p><strong>64byte - 16byte -3byte -1byte = 44byte</strong>。</p><p><strong>总结：</strong></p><p>所以，redis 3.2版本之后embstr最大能容纳的字符串长度是44，之前是39。长度变化的原因是SDS中内存的优化。</p><h3 id="2-2-List"><a href="#2-2-List" class="headerlink" title="2.2 List"></a>2.2 List</h3><p>Redis中List对象的底层是由quicklist(快速列表)实现的，快速列表支持从链表头和尾添加元素，并且可以获取指定位置的元素内容。</p><p>那么，快速列表的底层是如何实现的呢？为什么能够达到如此快的性能？</p><p>罗马不是一日建成的，quicklist也不是一日实现的，起初redis的list的底层是ziplist（压缩列表）或者是  linkedlist（双端列表）。先分别介绍这两种数据结构。</p><h4 id="ziplist-压缩列表"><a href="#ziplist-压缩列表" class="headerlink" title="ziplist 压缩列表"></a>ziplist 压缩列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个列表中只包含少量列表项，且是小整数值或长度比较短的字符串时，redis就使用ziplist（压缩列表）来做列表键的底层实现。压缩列表顾名思义是进行了压缩，每一个节点之间没有指针的指向，而是多个元素相邻，没有缝隙。</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush dotahero sf qop doom</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; object encoding dotahero</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此处使用老版本redis进行测试，向dota英雄列表中加入了qop痛苦女王、sf影魔、doom末日使者三个英雄，数据结构编码使用的是ziplist。</p><p><strong>所以 ziplist是Redis为了节约内存而开发的</strong>，是由一系列特殊编码的连续内存块组成的顺序型数据结构。具体结构相对比较复杂，大家有兴趣地话可以深入了解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct ziplist&lt;T&gt; &#123;</span><br><span class="line">    int32 zlbytes; &#x2F;&#x2F; 整个压缩列表占用字节数</span><br><span class="line">    int32 zltail_offset; &#x2F;&#x2F; 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点</span><br><span class="line">    int16 zllength; &#x2F;&#x2F; 元素个数</span><br><span class="line">    T[] entries; &#x2F;&#x2F; 元素内容列表，挨个挨个紧凑存储</span><br><span class="line">    int8 zlend; &#x2F;&#x2F; 标志压缩列表的结束，值恒为 0xFF</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b447587271beeb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h4 id="双端列表（linkedlist）"><a href="#双端列表（linkedlist）" class="headerlink" title="双端列表（linkedlist）"></a>双端列表（linkedlist）</h4><p>双端列表大家都很熟悉，这里的双端列表和java中的linkedlist很类似。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b4475875e8182a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>从图中可以看出Redis的linkedlist双端链表有以下特性：节点带有prev、next指针、head指针和tail指针，获取前置节点、后置节点、表头节点和表尾节点、获取长度的复杂度都是O(1)。</p><p><strong>压缩列表占用内存少，但是是顺序型的数据结构，插入删除元素的操作比较复杂，所以压缩列表适合数据比较小的情况，当数据比较多的时候，双端列表的高效插入删除还是更好的选择</strong></p><p>在Redis开发者的眼中，数据结构的选择，时间上、空间上都要达到极致，所以，他们将压缩列表和双端列表合二为一，创建了<strong>快速列表（quicklist）</strong>。和java中的hashmap一样，结合了数组和链表的优点。</p><h4 id="快速列表（quicklist）"><a href="#快速列表（quicklist）" class="headerlink" title="快速列表（quicklist）"></a>快速列表（quicklist）</h4><ul><li>rpush: listAddNodeHead —O(1)</li><li>lpush: listAddNodeTail —O(1)</li><li>push:listInsertNode —O(1)</li><li>index : listIndex —O(N)</li><li>pop:ListFirst/listLast —O(1)</li><li>llen:listLength —O(N)</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b4475876af391e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct ziplist &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">struct ziplist_compressed &#123;</span><br><span class="line">    int32 size;</span><br><span class="line">    byte[] compressed_data;</span><br><span class="line">&#125;</span><br><span class="line">struct quicklistNode &#123;</span><br><span class="line">    quicklistNode* prev;</span><br><span class="line">    quicklistNode* next;</span><br><span class="line">    ziplist* zl; &#x2F;&#x2F; 指向压缩列表</span><br><span class="line">    int32 size; &#x2F;&#x2F; ziplist 的字节总数</span><br><span class="line">    int16 count; &#x2F;&#x2F; ziplist 中的元素数量</span><br><span class="line">    int2 encoding; &#x2F;&#x2F; 存储形式 2bit，原生字节数组还是 LZF 压缩存储</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">struct quicklist &#123;</span><br><span class="line">    quicklistNode* head;</span><br><span class="line">    quicklistNode* tail;</span><br><span class="line">    long count; &#x2F;&#x2F; 元素总数</span><br><span class="line">    int nodes; &#x2F;&#x2F; ziplist 节点的个数</span><br><span class="line">    int compressDepth; &#x2F;&#x2F; LZF 算法压缩深度</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数list-compress-depth决定。为了支持快速的 push/pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p><h3 id="2-3-Hash"><a href="#2-3-Hash" class="headerlink" title="2.3 Hash"></a>2.3 Hash</h3><p>Hash数据类型的底层实现是ziplist（压缩列表）或字典（也称为hashtable或散列表）。这里压缩列表或者字典的选择，也是根据元素的数量大小决定的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758773ee9fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>如图hset了三个键值对，每个值的字节数不超过64的时候，默认使用的数据结构是<strong>ziplist</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b4475886a94f94?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>当我们加入了字节数超过64的值的数据时，默认的数据结构已经成为了hashtable。</p><p><strong>Hash对象只有同时满足下面两个条件时，才会使用ziplist（压缩列表）：</strong></p><ul><li>哈希中元素数量小于512个；</li><li>哈希中所有键值对的键和值字符串长度都小于64字节。</li></ul><p>压缩列表刚才已经了解了，hashtables类似于jdk1.7以前的hashmap。hashmap采用了链地址法的方法解决了哈希冲突的问题。想要深入了解的话可以参考之前写的一篇博客： <a href="https://blog.csdn.net/qq_32519415/article/details/87006982" target="_blank" rel="noopener">hashmap你真的了解吗</a></p><h4 id="Redis中的字典"><a href="#Redis中的字典" class="headerlink" title="Redis中的字典"></a>Redis中的字典</h4><p><strong>典</strong>， 又称符号表（symbol table）、关联数组（associative array）或者映射（map）， 是一种用于保存键值对（key-value pair）的抽象数据结构。在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。</p><p>字典中的每个键都是独一无二的， 程序可以在字典中根据键查找与之关联的值， 或者通过键来更新值， 又或者根据键来删除整个键值对， 等等。</p><h4 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h4><blockquote><p>Redis 的字典采用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。所以咱们依次来分析一下哈希表、哈希表节点、以及字典的结构。</p></blockquote><h4 id="1-哈希表结构"><a href="#1-哈希表结构" class="headerlink" title="1.哈希表结构"></a>1.哈希表结构</h4><p><strong>哈希表结构定义</strong> （dict.h/dictht）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表数组</span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表大小</span><br><span class="line">    unsigned long size;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表大小掩码，用于计算索引值</span><br><span class="line">    &#x2F;&#x2F; 总是等于 size - 1</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 该哈希表已有节点的数量</span><br><span class="line">    unsigned long used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>描述</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h&#x2F;dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</span><br><span class="line"></span><br><span class="line">size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</span><br><span class="line"></span><br><span class="line">sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>结构图解：一个空的哈希表</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6adabf00ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><h4 id="2-哈希表节点"><a href="#2-哈希表节点" class="headerlink" title="2.哈希表节点"></a>2.哈希表节点</h4><p>一个哈希表里面可以有多个哈希表节点，那么每个哈希表节点的结构以及多个哈希表节点之间的存储关系是怎么样的呢？</p><p><strong>哈希表节点结构定义</strong> （dictEntry）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 键</span><br><span class="line">    void *key;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 值</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指向下个哈希表节点，形成链表</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>描述</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， </span><br><span class="line">或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</span><br><span class="line"></span><br><span class="line">next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以此来解决键冲突（collision）的问题。</p><p>结构图解：多个哈希值相同的键值对存储结构，解决键冲突</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6adb3ebce3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><h4 id="3-字典结构实现"><a href="#3-字典结构实现" class="headerlink" title="3.字典结构实现"></a>3.字典结构实现</h4><p><strong>字典结构定义</strong> （dict.h/dict）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 类型特定函数</span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; rehash 索引</span><br><span class="line">    &#x2F;&#x2F; 当 rehash 不在进行时，值为 -1</span><br><span class="line">    int rehashidx; &#x2F;* rehashing not in progress if rehashidx &#x3D;&#x3D; -1 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>描述</strong>：type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数，</span><br><span class="line">Redis 会为用途不同的字典设置不同的类型特定函数。</span><br><span class="line"></span><br><span class="line">privdata 属性则保存了需要传给那些类型特定函数的可选参数。</span><br><span class="line">复制代码</span><br><span class="line">typedef struct dictType &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 计算哈希值的函数</span><br><span class="line">    unsigned int (*hashFunction)(const void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 复制键的函数</span><br><span class="line">    void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 复制值的函数</span><br><span class="line">    void *(*valDup)(void *privdata, const void *obj);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对比键的函数</span><br><span class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁键的函数</span><br><span class="line">    void (*keyDestructor)(void *privdata, void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁值的函数</span><br><span class="line">    void (*valDestructor)(void *privdata, void *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p><p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p><p>结构图解：普通状态下（没有进行 rehash）的字典</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6adba856b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><h4 id="哈希表分析"><a href="#哈希表分析" class="headerlink" title="哈希表分析"></a>哈希表分析</h4><h4 id="1-哈希算法"><a href="#1-哈希算法" class="headerlink" title="1.哈希算法"></a>1.哈希算法</h4><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><p>Redis 计算哈希值和索引值的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash &#x3D; dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class="line">index &#x3D; hash &amp; dict-&gt;ht[x].sizemask;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如图 4-4：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6adc63be56?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><p>举个例子， 对于图 4-4 所示的字典来说， 如果我们要将一个键值对 k0 和 v0 添加到字典里面， 那么程序会先使用语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash &#x3D; dict-&gt;type-&gt;hashFunction(k0);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>计算键 k0 的哈希值。</p><p>假设计算得出的哈希值为 8 ， 那么程序会继续使用语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index &#x3D; hash &amp; dict-&gt;ht[0].sizemask &#x3D; 8 &amp; 3 &#x3D; 0;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>计算出键 k0 的索引值 0 ， 这表示包含键值对 k0 和 v0 的节点应该被放置到哈希表数组的索引 0 位置上， 结构图解：图 4-5</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6ae014913d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><h4 id="2-键冲突解决"><a href="#2-键冲突解决" class="headerlink" title="2.键冲突解决"></a>2.键冲突解决</h4><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p><p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p><p>举个例子， 假设程序要将键值对 k2 和 v2 添加到图 4-6 所示的哈希表里面， 并且计算得出 k2 的索引值为 2 ， 那么键 k1 和 k2 将产生冲突， 而解决冲突的办法就是使用 next 指针将键 k2 和 k1 所在的节点连接起来。 结构图解：图 4-7</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6ae08fb489?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6b451b7570?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><p>因为 dictEntry 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面。</p><h4 id="3-rehash"><a href="#3-rehash" class="headerlink" title="3.rehash"></a>3.rehash</h4><p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大<br>的负担。<br>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次<br>rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1]<br>上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。<br>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。<br>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执<br>行。</p><h2 id="四、要点总结"><a href="#四、要点总结" class="headerlink" title="四、要点总结"></a>四、要点总结</h2><blockquote><p>1.字典 ht 属性是包含两个哈希表项的数组，一般情况下， 字典只使用 ht[0]， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash (下节分析) 时使用</p></blockquote><p>作者：程序员油七<br>链接：<a href="https://juejin.im/post/6855129008087793678" target="_blank" rel="noopener">https://juejin.im/post/6855129008087793678</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>redis中的dict 结构内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的。但是在 dict 扩容缩容时，需要分配新的 hashtable，然后进行渐进式搬迁，这时两个 hashtable 存储的分别是旧的 hashtable 和新的 hashtable。待搬迁结束后，旧的 hashtable 被删除，新的 hashtable 取而代之。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758921c661d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h3 id="2-4-Set"><a href="#2-4-Set" class="headerlink" title="2.4 Set"></a>2.4 Set</h3><p>Set数据类型的底层可以是<strong>intset</strong>(整数集)或者是<strong>hashtable</strong>(散列表也叫哈希表)。</p><p>当数据都是整数并且数量不多时，使用intset作为底层数据结构；当有除整数以外的数据或者数据量增多时，使用hashtable作为底层数据结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset 111 222 333</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; object encoding myset</span><br><span class="line">&quot;intset&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd myset hahaha</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding myset</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>inset的数据结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    &#x2F;&#x2F; 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    &#x2F;&#x2F; 集合包含的元素数量</span><br><span class="line">    uint32_t length;</span><br><span class="line">    &#x2F;&#x2F; 保存元素的数组</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>intset底层实现为有序、无重复数的数组。 intset的整数类型可以是16位的、32位的、64位的。如果数组里所有的整数都是16位长度的，新加入一个32位的整数，那么整个16的数组将升级成一个32位的数组。升级可以提升intset的灵活性，又可以节约内存，但不可逆。</p></blockquote><h3 id="2-5-Zset"><a href="#2-5-Zset" class="headerlink" title="2.5 Zset"></a>2.5 Zset</h3><p>Redis中的Zset，也叫做<strong>有序集合</strong>。它的底层是ziplist（压缩列表）或 <strong>skiplist</strong>（跳跃表）。</p><p>压缩列表前文已经介绍过了，同理是在元素数量比较少的时候使用。此处主要介绍跳跃列表。</p><hr><p>  跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>  跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p>  在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p><p>  Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>  和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。</p><hr><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>跳跃表（skiplist）是一种<strong>有序数据链表结构</strong>， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。查询平均性能为O(logN)，最坏的情况会出现O(N)情况，而redis中的zset在数据较多的时候底层就是采用跳跃表去实现的，元素较少的时候会进行小对象压缩采用压缩列表实现。</p><p><img src="https://img-blog.csdnimg.cn/20200413141708514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9mZW5nMTAzMzAxMTE=,size_16,color_FFFFFF,t_70" alt="img"></p><p>从上述图我们可以看出跳跃表有以下几个特点：</p><ul><li><p>跳跃表的每个节点都有多层构成。</p></li><li><p>跳跃表存在一个头结点，该头结点有64层结构，每层都包含指向下个节点的指针，指向本层下个节点中间所跨越的节点个数为跨度（span）。</p></li><li><p>除头结点以外，层高最高的节点为该跳跃表的level，图中的跳跃表level为3。</p></li><li><p>每层都是一个有序链表。</p></li><li><p>最底层的有序链表包含所有的节点数，也即是整个跳跃表的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    robj *obj;  &#x2F;*成员对象*&#x2F;</span><br><span class="line">    double score;   &#x2F;*分值*&#x2F;</span><br><span class="line">    struct zskiplistNode *backward; &#x2F;*后退指针*&#x2F;</span><br><span class="line">    struct zskiplistLevel &#123; &#x2F;*层*&#x2F;</span><br><span class="line">        struct zskiplistNode *forward;  &#x2F;*前进指针*&#x2F;</span><br><span class="line">        unsigned int span;  &#x2F;*跨度*&#x2F;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    struct zskiplistNode *header, *tail;    &#x2F;&#x2F;header指向跳跃表的表头节点，tail指向跳跃表的表尾节点</span><br><span class="line">    unsigned long length;   &#x2F;&#x2F;记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</span><br><span class="line">    int level;  &#x2F;&#x2F;记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>跳跃表<strong><em>\</em>每个节点都维护了多个指向其他节点的指针\</strong>，*<em>所以在进行查询、更新、删除等操作的时候不需要进行整条链表的遍历*</em>，*<em>可以通过维护的指针过滤掉中间的很多节点，从而达到很快速的访问效果***</em>，一般情况来说跳跃表的性能能与平衡树相媲美的，而且跳跃表实现较为简单，所以这也是<strong><em>\</em>redis为什么采用跳跃表来作为zset底层的数据结构实现**</strong>。</p><p><strong>查找过程</strong></p><p>跳跃表的查询，跳跃表有多层的情况下查询复杂度为O(logN)，如果跳跃表就一层那么查询复杂度会上升为O(N)，接下来我们就用图1的实例来模拟下查询score为70的节点的具体查询过程。</p><p><img src="https://img-blog.csdnimg.cn/20200413191759762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9mZW5nMTAzMzAxMTE=,size_16,color_FFFFFF,t_70" alt="img"></p><p>如图所示我们需要找到score为70的节点，查找首先从header开始，因为level为3我们先从L2开始往后开始遍历，查找到第一个节点，发现score比70小，继续往后遍历查找到第五个节点，发现score比70大，于是从当前节点往下一层进行查找，查找到节点3，以此类推，最终查询到score为70的节点。</p><p><strong>插入以及更新过程</strong><br>插入过程：跳跃表插入节点的时候，首先需要通过score找到自己的位置，也就是需要先走一步查找过程，找到新节点所处的位置的时候就创建一个新节点，并对新节点分配一个层数（这里层数的分配redis采用的是random随机机制，分配层数从1开始，每次晋升为上一层的概率为0.25），层数分配完了之后将前后指针进行赋值将新节点与旧节点串起来，<strong><em>\</em>如果层数大于当前的level还需要进行level的更新操作。**</strong></p><p>更新过程：更新过程会稍微复杂一些，更新其实就是插入，只不过插入的时候发现value已经存在了，只是<strong>需要调整一下score值</strong>，如果更新的score值不会带来位置上的改变，那么直接更新score就行不需要进行调整位置，但是如果新score会导致排序改变，那么就需要调整位置了，redis采用的方式比较直接就是先删除这个元素然后再插入这个元素即可，前后需要两次路径搜索</p><p>  Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。</p><p><img src="https://img-blog.csdn.net/20160412161658898" alt="一个跳跃表"></p><p>  上图展示了一个跳跃表示例，位于图片最左边的是zskiplist结构，该结构包含以下属性：</p><ul><li>header：指向跳跃表的表头节点</li><li>tail：指向跳跃表的表尾节点</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li><li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</li></ul><p>  位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：</p><ul><li>层(level)：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，依次类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li><li>后退(backward)指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>分值(score)：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>成员对象(obj)：各个节点中的o1、o2和o3是节点所保存的成员对象。</li></ul><p>  注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#### **跳跃表节点**</span><br><span class="line"></span><br><span class="line">  跳跃表节点的实现由redis.h&#x2F;zskiplistNode结构定义：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;c</span><br><span class="line">&#x2F;* ZSETs use a specialized version of Skiplists *&#x2F;</span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    robj *obj;  &#x2F;*成员对象*&#x2F;</span><br><span class="line">    double score;   &#x2F;*分值*&#x2F;</span><br><span class="line">    struct zskiplistNode *backward; &#x2F;*后退指针*&#x2F;</span><br><span class="line">    struct zskiplistLevel &#123; &#x2F;*层*&#x2F;</span><br><span class="line">        struct zskiplistNode *forward;  &#x2F;*前进指针*&#x2F;</span><br><span class="line">        unsigned int span;  &#x2F;*跨度*&#x2F;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;12345678910</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>  1、分值和成员</p><p>  节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。</p><p>  节点的成员对象(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。</p><p>  在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分至相同的节点将按照成员对象在字典中的大小来进行排序，成员对象较小的节点会排在前面(靠近表头的方向)，而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p><p>  举个例子，在下图中所示的跳跃表中，三个跳跃表节点都保存了相同的分值10086.0，但保存成员对象o1的节点却排在保存成员对象o2和o3的节点的前面，而保存成员对象o2的节点又排在保存成员对象o3的节点之前，由此可见，o1、o2、o3三个成员对象在字典中的排序为o1&lt;=o2&lt;=o3。</p><p><img src="https://img-blog.csdn.net/20160412174412181" alt="三个带有相同分值的跳跃表节点"></p><p>  2、后退指针</p><p>  节点的后退指针(backward属性)用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p><p>  下图用虚线展示了如何从表尾向表头遍历跳跃表中的所有节点：程序首先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点，之后再沿着后退指针访问倒数第三个节点，再之后遇到指向NULL的后退指针，于是访问结束。</p><p><img src="https://img-blog.csdn.net/20160412194049758" alt="从表尾向表头方向遍历跳跃表"></p><p>  3、层</p><p>  跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。</p><p>  每次创建一个新跳跃表节点的时候，程序根据幂次定律(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。</p><p>  下图分别展示了三个高度为1层、3层和5层的节点，因为C语言的数组索引总是从0开始的，所以节点的第一层是level[0]，而第二层是level[1]，依次类推。</p><p><img src="https://img-blog.csdn.net/20160412195202083" alt="带有不同层高的节点"></p><p>  4、前进指针</p><p>  每个层都有一个指向表尾方向的前进指针(level[i].forward属性)，用于从表头向表尾方向访问节点。下图用虚线表示出了程序从表头向表尾方向，遍历跳跃表中所有节点的路径：</p><p><img src="https://img-blog.csdn.net/20160412195458493" alt="遍历整个跳跃表"></p><p>  1) 迭代程序首先访问跳跃表的第一个节点(表头)，然后从第四层的前进指针移动到表中的第二个节点。<br>  2) 在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。<br>  3) 在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。<br>  4) 当程序再次沿着第四个节点的前进指针移动时，它碰到一个NULL，程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历。</p><p>  5、跨度</p><p>  层的跨度(level[i].span属性)用于记录两个节点之间的距离：</p><ul><li>两个节点之间的跨度越大，它们相距得就越远。</li><li>指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。</li></ul><p>  初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样的，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p>  举个例子，下图用虚线标记了在跳跃表中查找分值为3.0、成员对象为o3的节点时，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为3，所以目标节点在跳跃表中的排位为3。</p><p><img src="https://img-blog.csdn.net/20160412201553302" alt="计算节点的排位"></p><p>  再举个例子，下图用虚线标记了在跳跃表中查找分值为2.0、成员对象为o2的节点时，沿途经历的层：在查找节点的过程中，程序经过了两个跨度为1的节点，因此可以计算出，目标节点在跳跃表中的排位为2。</p><p><img src="https://img-blog.csdn.net/20160412201857509" alt="另一个计算节点排位的例子"></p><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a><strong>跳跃表</strong></h4><p>  仅靠多个跳跃表节点就可以组成一个跳跃表，如下图所示：</p><p><img src="https://img-blog.csdn.net/20160412202104618" alt="多个跳跃节点组成的跳跃表"></p><p>  但通过使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量(也即是跳跃表的长度)等信息，如下图所示：</p><p><img src="https://img-blog.csdn.net/20160412202419032" alt="带有zskiplist结构的跳跃表"></p><p>  zskiplist结构的定义如下：</p><p>​<code>ctypedef struct zskiplist {    struct zskiplistNode *header, *tail;    //header指向跳跃表的表头节点，tail指向跳跃表的表尾节点    unsigned long length;   //记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)    int level;  //记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)} zskiplist;12345​</code></p><p>  这样获取表头、表尾节点，表长，以及表中最高层数的复杂度均为O(1)。</p><p>```</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文大概介绍了Redis的5种常用数据类型的底层实现，希望大家结合源码和资料更深入地了解。</p><p>数据结构之美在Redis中体现得淋漓尽致，从String到压缩列表、快速列表、散列表、跳表，这些数据结构都适用在了不同的地方，各司其职。</p><p>不仅如此，Redis将这些数据结构加以升级、结合，将内存存储的效率性能达到了极致，正因为如此，Redis才能成为众多互联网公司不可缺少的高性能、秒级的key-value内存数据库。</p><p>作者：宜信技术学院<br>链接：<a href="https://juejin.im/post/6844903863145742350" target="_blank" rel="noopener">https://juejin.im/post/6844903863145742350</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2020/10/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1. 01背包问题"></a>1. 01背包问题</h2><p>有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。</p><p>第 ii 件物品的体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 读入数据的代码</span><br><span class="line">        Scanner reader &#x3D; new Scanner(System.in);</span><br><span class="line">        &#x2F;&#x2F; 物品的数量为N</span><br><span class="line">        int N &#x3D; reader.nextInt();</span><br><span class="line">        &#x2F;&#x2F; 背包的容量为V</span><br><span class="line">        int V &#x3D; reader.nextInt();</span><br><span class="line">        &#x2F;&#x2F; 一个长度为N的数组，第i个元素表示第i个物品的体积；</span><br><span class="line">        int[] v &#x3D; new int[N + 1] ;</span><br><span class="line">        &#x2F;&#x2F; 一个长度为N的数组，第i个元素表示第i个物品的价值；</span><br><span class="line">        int[] w &#x3D; new int[N + 1] ;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;1 ; i &lt;&#x3D; N ; i++)&#123;</span><br><span class="line">            &#x2F;&#x2F; 接下来有 N 行，每行有两个整数:v[i],w[i]，用空格隔开，分别表示第i件物品的体积和价值</span><br><span class="line">            v[i] &#x3D; reader.nextInt();</span><br><span class="line">            w[i] &#x3D; reader.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close() ;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 正式工作的代码</span><br><span class="line">        &#x2F;*</span><br><span class="line">        定义一个二阶矩阵dp[N+1][V+1],</span><br><span class="line">        这里之所以要N+1和V+1，是因为第0行表示只能选择第0个物品的时候，即没有物品的时候</span><br><span class="line">        第0列表示背包的体积为0的时候，即不能装任何东西的时候</span><br><span class="line"></span><br><span class="line">        dp[i][j]表示在 只能选择前i个物品，背包容量为j的情况下，背包中物品的最大价值</span><br><span class="line">        对于dp[i][j]有两种情况：</span><br><span class="line">        1. 不选择当前的第i件物品&#x2F;第i件物品比背包容量要大，则dp[i][j] &#x3D; dp[i-1][j]</span><br><span class="line">        2. 选择当前的第i件物品（潜在要求第i件物品体积小于等于背包总容量），则能装入的物品最大价值为：</span><br><span class="line">            当前物品的价值 加上 背包剩余容量在只能选前i-1件物品的情况下的最大价值</span><br><span class="line">            dp[i][j] &#x3D; dp[i-1][j-v[i]] + w[i]</span><br><span class="line">        dp[i][j]在两种情况中选择比较大的情况作为当前的最优解；</span><br><span class="line">        即：</span><br><span class="line">        if(j &gt;&#x3D; v[i]):</span><br><span class="line">            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])</span><br><span class="line">        else:</span><br><span class="line">            dp[i][j] &#x3D; dp[i-1][j]</span><br><span class="line">        *&#x2F;</span><br><span class="line">        int[][] dp &#x3D; new int[N+1][V+1];</span><br><span class="line">        dp[0][0] &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt;&#x3D; V; j++)&#123;</span><br><span class="line">                if(j &gt;&#x3D; v[i])&#123;</span><br><span class="line">                    dp[i][j] &#x3D; Math.max(dp[i-1][j], dp[i-1][j-v[i]] + w[i]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[N][V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后代码</p><pre><code>import java.util.Scanner;public class Main{    public static void main(String[] args) throws Exception {        // 读入数据的代码        Scanner reader = new Scanner(System.in);        // 物品的数量为N        int N = reader.nextInt();        // 背包的容量为V        int V = reader.nextInt();        // 一个长度为N的数组，第i个元素表示第i个物品的体积；        int[] v = new int[N + 1] ;        // 一个长度为N的数组，第i个元素表示第i个物品的价值；        int[] w = new int[N + 1] ;        for (int i=1 ; i &lt;= N ; i++){            // 接下来有 N 行，每行有两个整数:v[i],w[i]，用空格隔开，分别表示第i件物品的体积和价值            v[i] = reader.nextInt();            w[i] = reader.nextInt();        }    reader.close() ;    // 正式算法的代码    // 将dp优化为一维数组    /*    注意，这里第二层循环的时候，还是小到大循环的话，那么    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])    实际上变成了    dp[i][j] = Math.max(dp[i][j], dp[i][j-v[i]] + w[i]);    因为i-1的值已经在前面被更新过了，覆盖了    为了避免这个问题，所以要逆序更新，即先更新第i个，然后更新第i-1个，从而保证第i-1个不被覆盖    如果不逆序的话，输出结果为10，dp数组实际为：    0 0 0 0 0 0     0 2 4 6 8 10    0 2 4 6 8 10    0 2 4 6 8 10    0 2 4 6 8 10    */    int[] dp = new int[V+1];    dp[0] = 0;    for(int i = 1; i &lt;= N; i++){        for(int j = V; j &gt;= v[i]; j--){            dp[j] = Math.max(dp[j], dp[j-v[i]] + w[i]);        }        // for(int j = 0; j &lt;= V; j++){        //     System.out.print(dp[j]);        //     System.out.print(&quot; &quot;);        // }        // System.out.print(&quot;\n&quot;);    }    System.out.println(dp[V]); }}</code></pre><h2 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2.完全背包问题"></a>2.完全背包问题</h2><p>有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。</p><p>第 ii 种物品的体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 1010;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int dp[N][N], v[N], w[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</span><br><span class="line">        for(int j &#x3D; 0; j &lt;&#x3D; m; j ++ )</span><br><span class="line">            for(int k &#x3D; 0; k * v[i] &lt;&#x3D; j; k ++ )</span><br><span class="line">                dp[i][j] &#x3D; max(dp[i][j], dp[i - 1][j - k * v[i]] + k * w[i]);</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇总版</title>
      <link href="/2020/10/15/%E6%B1%87%E6%80%BB%E7%89%88/"/>
      <url>/2020/10/15/%E6%B1%87%E6%80%BB%E7%89%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>笔试题整理</title>
      <link href="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-王大锤"><a href="#1-王大锤" class="headerlink" title="1.王大锤"></a>1.王大锤</h2><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002172244791.png" alt="image-20201002172244791"></p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002172300325.png" alt="image-20201002172300325"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这题就暴力扫一遍就可以了，碰到3个连续的或者AABB删掉那个字符即可。。。</span><br><span class="line">&#x2F;&#x2F;当时没做出来。。。菜是原罪！</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        while(sc.hasNext())&#123;</span><br><span class="line">            int n &#x3D; Integer.parseInt(sc.nextLine());</span><br><span class="line">            for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">                StringBuilder sb &#x3D; new StringBuilder(sc.nextLine());</span><br><span class="line">                for(int j &#x3D; 2; j &lt; sb.length(); j++)&#123;</span><br><span class="line">                    if(sb.charAt(j) &#x3D;&#x3D; sb.charAt(j - 1) </span><br><span class="line">                       &amp;&amp; sb.charAt(j - 1) &#x3D;&#x3D; sb.charAt(j - 2))&#123;</span><br><span class="line">                        sb.deleteCharAt(j);</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if(isPattern(sb, j - 3, j))&#123;</span><br><span class="line">                        sb.deleteCharAt(j);</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean isPattern(StringBuilder sb, int i, int j)&#123;</span><br><span class="line">        if(i &lt; 0) return false;</span><br><span class="line">        return sb.charAt(i) &#x3D;&#x3D; sb.charAt(i + 1) &amp;&amp;</span><br><span class="line">                sb.charAt(j - 1) &#x3D;&#x3D; sb.charAt(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-雀魂"><a href="#2-雀魂" class="headerlink" title="2.雀魂"></a>2.雀魂<img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002220653472.png" alt="image-20201002220653472"></h2><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002220728137.png" alt="image-20201002220728137"></p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002220743070.png" alt="image-20201002220743070"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 回溯法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static int[] arr &#x3D; new int[13];</span><br><span class="line">    private static int[] count;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        count &#x3D; new int[9];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; scanner.nextInt();</span><br><span class="line">            ++count[arr[i]-1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int winCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 选择1到9中的一个作为第14张牌，然后判断是否胡牌</span><br><span class="line">        for (int i &#x3D; 1 ; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            if(count[i-1]&lt;4)&#123;</span><br><span class="line">                ++count[i-1];</span><br><span class="line">                if(win())&#123;</span><br><span class="line">                    ++winCount;</span><br><span class="line">                    System.out.print(i);</span><br><span class="line">                    System.out.print(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                --count[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(winCount&#x3D;&#x3D;0)&#123;</span><br><span class="line">            System.out.println(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean win()&#123;</span><br><span class="line">        &#x2F;&#x2F; 从1到9 中选择一个作为雀头, 然后判断剩余的牌是否构成4对</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            if(count[i-1]&lt;2)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            count[i-1]-&#x3D;2;</span><br><span class="line">            if(hasTriples(4))&#123;</span><br><span class="line">                count[i-1]+&#x3D;2;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            count[i-1]+&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean hasTriples(int n)&#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 1到9，每一张牌尝试三张或顺子</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            if(count[i-1]&gt;&#x3D;3)&#123;</span><br><span class="line">                count[i-1]-&#x3D;3;</span><br><span class="line">                boolean subHashTriples &#x3D; hasTriples(n-1);</span><br><span class="line">                count[i-1]+&#x3D;3;</span><br><span class="line">                if(subHashTriples)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i&lt;&#x3D;7  &amp;&amp; count[i-1]&gt;0 &amp;&amp; count[i] &gt; 0 &amp;&amp; count[i+1]&gt;0)&#123;</span><br><span class="line">                --count[i-1];</span><br><span class="line">                --count[i];</span><br><span class="line">                --count[i+1];</span><br><span class="line">                boolean subHasTriples &#x3D; hasTriples(n-1);</span><br><span class="line"></span><br><span class="line">                ++count[i-1];</span><br><span class="line">                ++count[i];</span><br><span class="line">                ++count[i+1];</span><br><span class="line">                if(subHasTriples)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.特工</p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002221037230.png" alt="image-20201002221037230"></p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002221054430.png" alt="image-20201002221054430"></p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002221105589.png" alt="image-20201002221105589"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    private int mod &#x3D; 99997867;</span><br><span class="line"></span><br><span class="line">    private void sln() &#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        int N &#x3D; sc.nextInt(), D &#x3D; sc.nextInt();</span><br><span class="line">        long cnt &#x3D; 0;</span><br><span class="line">        if (N &lt;&#x3D; 2) &#123;</span><br><span class="line">            System.out.println(-1);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] locs &#x3D; new int[N];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">            locs[i] &#x3D; sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">        int left &#x3D; 0, right &#x3D; 2;</span><br><span class="line">        while (right &lt; N) &#123;</span><br><span class="line">            if (locs[right] - locs[left] &gt; D) left++;</span><br><span class="line">            else if (right - left &lt; 2) right++;</span><br><span class="line">            else &#123;</span><br><span class="line">                cnt +&#x3D; calC(right - left);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt %&#x3D; mod;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long calC(long num) &#123;</span><br><span class="line">        return num * (num - 1) &#x2F; 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Main().sln();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3。迷宫"><a href="#3。迷宫" class="headerlink" title="3。迷宫"></a>3。迷宫</h2><p>由于新冠肺炎疫情的爆发，小明养在宿舍的小昆虫已经很久很久都没有人管了。小昆虫已经饿的不行了，必须出来找东西吃，可是出来之后需要走出一个迷宫。小昆虫每次可以朝上、下、左、右四个方向之一走一步，且只要走出任意一条边界线即可逃出迷宫。这只小昆虫曾感染过X星的一种奇异病毒，目前还没有发现任何副作用，但是却拥有了一项特异功能——破坏障碍物。<br>假设小昆虫在一个N<em>M的迷宫中，”@”代表小昆虫的初始位置，”.”代表可以通过的空地，”</em>“代表可以破坏的障碍物，”#”代表不可破坏的障碍物。请问小昆虫最少需要使用多少次特异功能才可以逃出迷宫？</p><p>输入描述<br>多组数据，第1行有1个正整数T，表示有T组数据。（T&lt;=100）<br>对于每组数据，第1行有两个整数N和M。(1&lt;=N, M&lt;=1000)<br>接着N行，每行有一个长度为M的字符串，表示N*M的迷宫。<br>输出描述<br>输出一个整数，表示使用特异功能的最少次数。如果小昆虫不能走出迷宫，则输出-1。</p><p>样例输入<br>3<br>3 3<br>###<br>#@*</p><p>3 4<br>####<br>#@.*<br><em>*.</em><br>3 3<br>.#.<br>#@#<br>.#.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.util.PriorityQueue;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class D2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        String st &#x3D; sc.nextLine();</span><br><span class="line">       int t &#x3D; Integer.parseInt(st);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; t; i++) &#123;</span><br><span class="line">            String str &#x3D; sc.nextLine();</span><br><span class="line">            String[] strs &#x3D; str.split(&quot; &quot;);</span><br><span class="line">            int n &#x3D;Integer.parseInt(strs[0]);    &#x2F;&#x2F;行数</span><br><span class="line">            int m &#x3D;Integer.parseInt(strs[1]);    &#x2F;&#x2F;列数</span><br><span class="line"></span><br><span class="line">            char[][] board &#x3D; new char[n][m];</span><br><span class="line">            int x &#x3D; -1;</span><br><span class="line">            int y &#x3D; -1;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                String s &#x3D; sc.nextLine();</span><br><span class="line">                for (int k &#x3D; 0; k &lt; m; k++) &#123;</span><br><span class="line">                    board[j][k]&#x3D;s.charAt(k);</span><br><span class="line">                    if (board[j][k] &#x3D;&#x3D; &#39;@&#39;) &#123;</span><br><span class="line">                        x &#x3D; k;    &#x2F;&#x2F;列号</span><br><span class="line">                        y &#x3D; j;    &#x2F;&#x2F;行号</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            boolean[][] used &#x3D; new boolean[n][m];</span><br><span class="line">            int[][] move &#x3D; new int[4][2];</span><br><span class="line">            move[0][0]&#x3D;0;</span><br><span class="line">            move[0][1]&#x3D;1;</span><br><span class="line">            move[1][0]&#x3D;0;</span><br><span class="line">            move[1][1]&#x3D;-1;</span><br><span class="line">            move[2][0]&#x3D;1;</span><br><span class="line">            move[2][1]&#x3D;0;</span><br><span class="line">            move[3][0]&#x3D;-1;</span><br><span class="line">            move[3][1]&#x3D;0;</span><br><span class="line"></span><br><span class="line">            PriorityQueue&lt;Integer&gt; list &#x3D; new PriorityQueue&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F;System.out.println(t +&quot; &quot;+n+ &quot; &quot;+m+&quot; &quot;+x+&quot; &quot;+y );</span><br><span class="line">            dis(x,y,board,used,list,0,move);</span><br><span class="line">            if(list.size()&gt;0)&#123;</span><br><span class="line">                System.out.println(list.poll());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(&quot;-1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void dis(int x,int y,char[][] board,boolean[][] used, PriorityQueue&lt;Integer&gt; list,int count,int[][] move)&#123;</span><br><span class="line">        if(x&lt;&#x3D;0||x&gt;&#x3D;board[0].length-1||y&lt;&#x3D;0||y&gt;&#x3D;board.length-1)&#123;     &#x2F;&#x2F;第3个或写成了与</span><br><span class="line">            &#x2F;&#x2F;System.out.println(count);</span><br><span class="line">            list.add(count);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">            x&#x3D;x+move[i][0];</span><br><span class="line">            y&#x3D;y+move[i][1];</span><br><span class="line">            if(x&gt;&#x3D;0&amp;&amp;x&lt;board[0].length&amp;&amp;y&gt;&#x3D;0&amp;&amp;y&lt;board.length&amp;&amp;!used[y][x])&#123;</span><br><span class="line">                used[y][x] &#x3D; true;</span><br><span class="line">                if (board[y][x]&#x3D;&#x3D;&#39;*&#39;)&#123;</span><br><span class="line">                    dis(x,y,board,used,list,count+1,move);</span><br><span class="line">                    &#x2F;&#x2F; System.out.println(count);</span><br><span class="line">                &#125;else if (board[y][x]&#x3D;&#x3D;&#39;.&#39;)&#123;</span><br><span class="line">                    dis(x,y,board,used,list,count,move);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                used[y][x] &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            x-&#x3D;move[i][0];</span><br><span class="line">            y-&#x3D;move[i][1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int bfs(vector&lt;string&gt; grid)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; direct&#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">    queue&lt;vector&lt;int&gt;&gt; que_;</span><br><span class="line">    int hei &#x3D; grid.size();</span><br><span class="line">    int wid &#x3D; grid[0].length();</span><br><span class="line">    int result &#x3D; -1;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; visited(hei, vector&lt;int&gt;(wid, -1));</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; hei; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; wid; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (grid[i][j] &#x3D;&#x3D; &#39;@&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                que_.push(&#123;i, j, 0&#125;);</span><br><span class="line">                visited[i][j] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (!que_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        auto cur &#x3D; que_.front();</span><br><span class="line">        que_.pop();</span><br><span class="line">        if (cur[0] &#x3D;&#x3D; 0 || cur[0] &#x3D;&#x3D; hei - 1 || cur[1] &#x3D;&#x3D; 0 || cur[1] &#x3D;&#x3D; wid - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            if (cur[2] &lt; result || result &#x3D;&#x3D; -1)</span><br><span class="line">            &#123;</span><br><span class="line">                result &#x3D; cur[2];</span><br><span class="line">            &#125;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 4; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int next_y &#x3D; cur[0] + direct[i][0];</span><br><span class="line">            int next_x &#x3D; cur[1] + direct[i][1];</span><br><span class="line">            int last_time &#x3D; cur[2];</span><br><span class="line">            if (visited[next_y][next_x] !&#x3D; -1 &amp;&amp; visited[next_y][next_x] &lt;&#x3D; last_time + 1)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[next_y][next_x] &#x3D; last_time + 1;</span><br><span class="line">            if (grid[next_y][next_x] &#x3D;&#x3D; &#39;.&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                que_.push(&#123;next_y, next_x, last_time&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (grid[next_y][next_x] &#x3D;&#x3D; &#39;*&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                que_.push(&#123;next_y, next_x, last_time + 1&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t, n, m;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; grids(t);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        grids[i].resize(n);</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; grids[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (auto grid : grids)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bfs(grid) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">public class hello &#123;&#x2F;&#x2F;100 999</span><br><span class="line">    static int[][] dir&#x3D;&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">    static int startX,startY;</span><br><span class="line">  &#x2F;&#x2F;  static int endX,endY;</span><br><span class="line">    static int min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">    static int[][] vis;</span><br><span class="line">    static Scanner sc&#x3D;new Scanner(System.in);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    int x&#x3D;sc.nextInt();</span><br><span class="line"></span><br><span class="line">    while(x--&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        int n&#x3D;sc.nextInt();</span><br><span class="line">        int m&#x3D;sc.nextInt();</span><br><span class="line">        char[][] matrix&#x3D;new char[n][m];</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[i]&#x3D;sc.next().toCharArray();</span><br><span class="line">          &#x2F;&#x2F;  sc.nextLine();</span><br><span class="line">            for(int j&#x3D;0;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">             if(matrix[i][j]&#x3D;&#x3D;&#39;@&#39;)</span><br><span class="line">             &#123;</span><br><span class="line">                 startX&#x3D;i;</span><br><span class="line">                 startY&#x3D;j;</span><br><span class="line">             &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis&#x3D;new int[n][m];</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i][j]&#x3D;-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        Queue&lt;Node&gt; q&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">        q.add(new Node(startX,startY));</span><br><span class="line">        BFS(matrix,q);</span><br><span class="line">        System.out.println(min);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void BFS(char[][] matrix,Queue&lt;Node&gt; q) &#123;</span><br><span class="line">    while(!q.isEmpty()) &#123;</span><br><span class="line">        int size &#x3D; q.size();</span><br><span class="line">        while (size-- &gt; 0) &#123;</span><br><span class="line">            Node nowNode &#x3D; q.poll();</span><br><span class="line">            int i &#x3D; nowNode.x, j &#x3D; nowNode.y;</span><br><span class="line">            vis[i][j]&#x3D;nowNode.step;</span><br><span class="line">            if (i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; matrix.length - 1</span><br><span class="line">                    || j &#x3D;&#x3D; 0</span><br><span class="line">                    || j &#x3D;&#x3D; matrix[0].length - 1</span><br><span class="line">            ) &#123;</span><br><span class="line">                min&#x3D;Math.min(vis[i][j],min);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int[] d : dir) &#123;</span><br><span class="line">                int newX &#x3D; d[0] + i;</span><br><span class="line">                int newY &#x3D; d[1] + j;</span><br><span class="line">                if (matrix[newX][newY] &#x3D;&#x3D; &#39;#&#39;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(vis[newX][newY]!&#x3D;-1 &amp;&amp; vis[newX][newY]&lt;&#x3D;nowNode.step+1)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                Node newNode &#x3D; new Node(newX, newY);</span><br><span class="line">                if (matrix[newX][newY] &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line"></span><br><span class="line">                    newNode.step &#x3D;nowNode.step+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(matrix[newX][newY] &#x3D;&#x3D; &#39;.&#39;)</span><br><span class="line">                &#123;</span><br><span class="line">                    newNode.step &#x3D;nowNode.step;</span><br><span class="line">                &#125;</span><br><span class="line">                q.add(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;  ####</span><br><span class="line">        &#x2F;&#x2F; ####</span><br><span class="line">        &#x2F;&#x2F; #@.*</span><br><span class="line">        &#x2F;&#x2F; **.*</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static class Node</span><br><span class="line">    &#123;</span><br><span class="line">        int x;</span><br><span class="line">        int y;</span><br><span class="line">        int step;</span><br><span class="line">        Node(int a,int b)</span><br><span class="line">        &#123;</span><br><span class="line">            x&#x3D;a;</span><br><span class="line">            y&#x3D;b;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据</title>
      <link href="/2020/09/30/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
      <url>/2020/09/30/%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>1MB=2^20B</p><p>1KB=2^10B=10^3B</p><h2 id="1-共同URL"><a href="#1-共同URL" class="headerlink" title="1.共同URL"></a>1.共同URL</h2><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。</p><blockquote><p>5,000,000,000 * 64B ≈ 5GB * 64 = 320GB</p></blockquote><p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p><strong>思路如下</strong>：</p><p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code>，根据计算结果把遍历到的  URL 存储到文件  a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p><p>接着遍历 ai( <code>i∈[0,999]</code>)，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p><h3 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h3><p>1.分而治之，进行哈希取余；2.对每个子文件进行 HashSet 统计。</p><h2 id="2-频率Top100"><a href="#2-频率Top100" class="headerlink" title="2.频率Top100"></a>2.频率Top100</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p><h3 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h3><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p><p><strong>思路如下</strong>：</p><p>首先遍历大文件，对遍历到的每个词x，执行 <code>hash(x) % 5000</code>，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p><p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 <code>map.put(x, 1)</code>；若存在，则执行 <code>map.put(x, map.get(x)+1)</code>，将该词频数加 1。</p><p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p><h3 id="方法总结-1"><a href="#方法总结-1" class="headerlink" title="方法总结"></a>方法总结</h3><p>1.分而治之，进行哈希取余；2.使用 HashMap 统计频数；3.求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</p><h2 id="3-找不重复"><a href="#3-找不重复" class="headerlink" title="3.找不重复"></a>3.找不重复</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p><h3 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h3><h4 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p><h4 id="方法二：位图法"><a href="#方法二：位图法" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h4><p><strong>位图</strong>，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p><p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p><p>假设我们要对 <code>[0,7]</code> 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000</span><br></pre></td></tr></table></figure><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00001010</span><br></pre></td></tr></table></figure><p>依次遍历，结束后，位数组是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01101110</span><br></pre></td></tr></table></figure><p>每个为 1 的位，它的下标都表示了一个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in range(8):if bits[i] &#x3D;&#x3D; 1:print(i)</span><br></pre></td></tr></table></figure><p>这样我们其实就已经实现了排序。</p><p>对于整数相关的算法的求解，<strong>位图法</strong>是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 2^32。</p><p><strong>那么对于这道题</strong>，我们用 2 个 bit 来表示各个数字的状态：</p><p>•00 表示这个数字没出现过；•01 表示这个数字出现过一次（即为题目所找的不重复整数）；•10 表示这个数字出现了多次。</p><p>那么这 232 个整数，总共所需内存为 2^32*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p><p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p><h3 id="方法总结-2"><a href="#方法总结-2" class="headerlink" title="方法总结"></a>方法总结</h3><p><strong>判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p><h2 id="4-1亿个正整数-范围是0-42亿。求出现次数是2的数字，空间复杂度"><a href="#4-1亿个正整数-范围是0-42亿。求出现次数是2的数字，空间复杂度" class="headerlink" title="4.1亿个正整数,范围是0-42亿。求出现次数是2的数字，空间复杂度"></a>4.1亿个正整数,范围是0-42亿。求出现次数是2的数字，空间复杂度</h2><p>使用位图bitMap     。位图是以 bit     位为单位进行数据存储，这样每个字节8个位就可以存储8个数字，普通的一个int占4个字节，32位，用了位图之后可以将空间节省32倍。     </p><p>​      开一个42亿大小的位图，将这一亿个数字存进数字大小对应的位置，一个bit每存进去一个数字，就将value+1,比如第一次存8，就将索引为8的位置的value置为1，第二次就置为2，存完之后搜索value为2的key是多少。     </p><p>​      32位机器最大能表示的数字是42亿9千多万。     </p><p>​      42亿bit /(8 * 1024 * 1024) = 500MB</p><h2 id="5-有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？"><a href="#5-有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？" class="headerlink" title="5.有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？"></a>5.有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？</h2><p>思路一：分治法，将ip地址根据前三位分成256份，然后看这个ip地址对应的网段，只比对这个网段里面是否有这个ip，当然还可以继续分下去，根据数据量来决定分成多少份。     </p><p>​      思路二：位图，将每一条ip对应位图中的一个位，2^32次方(42亿多)个数据只需要512M空间。可以实现O(1)的时间搜索，O(n)的时间存储。     </p><h2 id="6-2g内存，要求一个10g文件的中位数"><a href="#6-2g内存，要求一个10g文件的中位数" class="headerlink" title="6. 2g内存，要求一个10g文件的中位数**"></a>6. 2g内存，要求一个10g文件的中位数**</h2><p>如题 “在一个文件中有 10G 个整数,乱序排列,要求找出中位数(内存限制为 2G)”</p><p>原创，网上这个题目有好多答案，但是有好多都不准确。</p><p> 假设整数用32bit来表示。</p><p>第一步：要表示10G个整数，最少需要一个64位的数据空间。（10G = 5 * 2^31 &gt; 2^32 )</p><p>第二步：分区间</p><p>2G的内存，能够表示多少个64bit，就能分多少个区间。（一个区间 就表示 一个64bit的数据空间）</p><p>区间数位：2G / 64bit = 256M 个区间。</p><p>第三步：求区间表示范围</p><p>32bit的整数最大值为2^32-1,所以区间的范围是2^32 / 256M = 16.</p><p>即0 ~ 15 ，16 ~ 31，32 ~ 47，……（总共256M个)</p><p>此时我们有 256M个区间，大小总共为256M * 64bit = 2G内存。</p><p>第四步：遍历10G个整数。每读取一个整数就将此整数对应的区间+1。</p><p>第五步：找出中位数所在的区间</p><p>统计每个区间中整数的值。然后从第一个区间的整数值开始累加。当累加到5G时，停止。此时的区间便包含中位数。记下此区间所表示的范围，设为[a,a+15].并且记下此区间之前所有区间的累加和，设为m。释放掉除包含中位数区间的其他所有区间的内存。</p><p>第六步：再次遍历10G个整数，统计出现在区间[a,a+15]中每个值的计数，有16个数值，按照a到a+15排序。设为n0,n1,n2,…n15</p><p>第七步：当m+n0+n1+…+nx首次大于5G时，此时的 a+x 就是所求的中位数。</p><p>7.</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智力题</title>
      <link href="/2020/09/30/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
      <url>/2020/09/30/%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-三门问题（Monty-Hall-problem）"><a href="#1-三门问题（Monty-Hall-problem）" class="headerlink" title="1.三门问题（Monty Hall problem）"></a>1.三门问题（Monty Hall problem）</h2><p>亦称为蒙提霍尔问题或蒙提霍尔悖论，大致出自美国的电视游戏节目Let’s Make a Deal。问题名字来自该节目的主持人蒙提·霍尔（Monty Hall）。参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机率？</p><p>作为工科生，还是拿贝叶斯公式来分析一波：</p><p>首先看贝叶斯公式： </p><p><img src="https://img-blog.csdnimg.cn/20190707193021763.png" alt="img"></p><p>p(A|B)的意思是在B事件发生的情况下，A事件发生的概率。p(A,B)是两个事件同时发生的概率。</p><p>那么上面的公式可以延伸出下面的公式：</p><p><img src="https://img-blog.csdnimg.cn/20190707193821826.png" alt="img"></p><p>好，然后我们针对这个题目，我们假设有A、B、C三个门，参赛者选择了A门，主持人打开了B门，然后要参赛者在A门和C门之间抉择换还是不换。那么如果汽车在B门后面，换与不换得到汽车的概率均为0，如果换了能赢，那么汽车必须在C门后面， 现在我们求以下概率：</p><p><img src="https://img-blog.csdnimg.cn/20190707200643101.png" alt="img"></p><p>我们先看分母，我们三种可能情况列一下：</p><p><img src="https://img-blog.csdnimg.cn/20190707201600435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3Vuc2hp,size_16,color_FFFFFF,t_70" alt="img"></p><p>所以分母为：</p><p><img src="https://img-blog.csdnimg.cn/20190707201824129.png" alt="img"></p><p>再看分子，当车在C后面时，参赛者选择了A门，支持人只有B门可以打开，所以：</p><p><img src="https://img-blog.csdnimg.cn/20190707202332301.png" alt="img"></p><p>而车在C门后的概率显而易见：</p><p><img src="https://img-blog.csdnimg.cn/20190707202715221.png" alt="img"></p><p>然后我们就求得了换门获胜的概率：</p><p><img src="https://img-blog.csdnimg.cn/20190707203200890.png" alt="img"></p><p>-———————————————————————————————————————— </p><p>这个问题就结束了。然而对于贝叶斯公式还没有结束。</p><p>贝叶斯公式还会有如下写法：</p><p><img src="https://img-blog.csdnimg.cn/20190707211603830.png" alt="img"></p><p>这个公式可以用在分类上，具体的可以去翻看我的另一篇博客</p><h2 id="2-桶装水"><a href="#2-桶装水" class="headerlink" title="2.桶装水"></a>2.桶装水</h2><p>有无限的水，5L和6L 的桶精确装4L 水</p><blockquote><p>通用解法： 用小的桶不断往大桶填水</p><p>这里： 5L桶 6L桶</p><p>0 0</p><p>5 0</p><p>0 5</p><p>5 5</p><p>4 6</p></blockquote><p><strong>一个装了10L水的桶，一个7L的空桶，一个3L的空桶，怎样变成2个5L</strong></p><p>初始时为10，0，0。<br>第二步7，0，3。<br>然后7，3，0。<br>然后4，3，3。<br>然后4，6，0。<br>然后1，6，3。<br>然后1，7，2。<br>然后8，0，2。<br>然后8，2，0。<br>然后5，2，3。<br>然后5，5，0。</p><p><strong>如果你有无穷多的水，一个3夸脱的和一个5夸脱的提桶，你如何准确称出 4夸脱的水？</strong></p><p>初始时0，5<br>然后3，2<br>然后0，2<br>然后2，0<br>然后2，5<br>然后1，4</p><p>两个舀酒的勺子，分别能舀7两和11两酒，二两酒？</p><p>初始0，11<br>然后7，4<br>然后0，4<br>然后4，0<br>然后4，11<br>然后7，8<br>然后0，8<br>然后7，1<br>然后0，1<br>-—–<br>然后1，11<br>然后7，5<br>然后0，5<br>然后5，0<br>然后5，11，<br>然后7，9<br>然后0，9<br>然后7，2</p><h2 id="3-瞎子分牌"><a href="#3-瞎子分牌" class="headerlink" title="3.瞎子分牌"></a>3.瞎子分牌</h2><p>一副牌52张,告诉瞎子里面有10张牌是正面朝上的, 要求瞎子把这52张牌分成两堆, 并且每堆牌正面朝上的张数相同，可任意翻动牌，但是一直不可以看。</p><blockquote><p>分成10和42， 10 中的所有牌。</p><p>proof： 第一堆（10张牌里有x张向上），全翻 = 10-x 张向上，等于第二堆向上的牌数</p></blockquote><h2 id="4-赛马问题"><a href="#4-赛马问题" class="headerlink" title="4.赛马问题"></a>4.赛马问题</h2><p>64匹马，8个跑道，选跑最快的4匹马需要比赛多少次。</p><p>(     锦标赛<a href>排序</a><a href>算法</a>     )      sum = 11     </p><p>​      第一步：首先每8匹马跑一次，总共需要8次，假设结果中A1&gt;A2&gt;A3&gt;……,B1&gt;B2&gt;B3&gt;….等。 sum=8；     </p><p>​      第二步：这8组中的第一名拉出来跑一次，那么这次最快的是总的第一名，假设是A1，同时假设B1&gt;C1&gt;D1。这时还要角逐2,3,4名，     那这一轮中的第五到第八组都可以直接舍弃     ，因为他们所有的马一定进不了前4名。sum=9。     </p><p>​      第三步：从A组中选A2，A3，A4，B组中B1，B2，B3，C组中C1，C2，D组中D1，这些才有资格角逐2,3,4名。这时需要再比赛两次。 sum=11。（但是如果第10轮选择A4不上场，如果A3获得了第4名，那么A4就不需要比赛了，这样     sum=10     ）。</p><p>25匹马，5个跑道，每个跑道最多能有1匹马进行比赛，最少比多少次能比出前3名？前5名？</p><h2 id="5-老鼠死亡问题"><a href="#5-老鼠死亡问题" class="headerlink" title="5.老鼠死亡问题"></a>5.老鼠死亡问题</h2><p>1000瓶药，有一些可能有毒，用老鼠来喝药，喝到有毒的一周就死。一周内至少需要多少只老鼠才能检测到哪些有毒</p><p>同时给老鼠编号，从1,2,…10，从低位开始，让第n个编号老鼠喝下第n个bit位为1的瓶子中的药水。<br>一周后，若所有的老鼠都没有发病，那么是第0个瓶子有毒，<br>如果有一些编号的老鼠发病，死亡的老鼠记为1，正常老鼠记为0，那么按照老鼠编号1-10对应bit位从低到高，对应的10进制即为有毒药水的编号。</p><p><strong>附上百度解释</strong><br>给1000个瓶分别标上如下标签（10位长度）：<br>0000000001 （第1瓶）<br>0000000010 （第2瓶）<br>0000000011 （第3瓶）<br>……<br>1111101000 （第1000瓶）<br>从编号最后1位是1的所有的瓶子里面取出1滴混在一起（比如从第一瓶，第三瓶，。。。里分别取出一滴混在一起）并标上记号为1。以此类推，从编号第一位是1的所有的瓶子里面取出1滴混在一起并标上记号为10。现在得到有10个编号的混合液，小白鼠排排站，分别标上10，9，。。。1号，并分别给它们灌上对应号码的混合液。24小时过去了，过来验尸吧：<br><strong>从左到右，死了的小白鼠贴上标签1，没死的贴上0，最后得到一个序号，把这个序号换成10进制的数字，就是有毒的那瓶水的编号。</strong><br>检验一下：假如第一瓶有毒，按照0000000001 （第1瓶），说明第1号混合液有毒，因此小白鼠的生死符为0000000001（编号为1的小白鼠挂了），0000000001二进制标签转换成十进制=1号瓶有毒；假如第三瓶有毒，0000000011 （第3瓶），第1号和第2号混合液有毒，因此小白鼠的生死符为00000011（编号为1，2的鼠兄弟挂了），0000000011二进制标签转换成十进制=3号瓶有毒。</p><p>————————————————————————————————————————————<br><strong>举例，10瓶药水，4个bit表示，对应药水编号0-9，又4个bit对应4个老鼠，则老鼠编号1-4，</strong><br>0000， 0<br>0001， 1<br>0010， 2<br>0011， 3<br>0100， 4<br>0101，5<br>0110，6<br>0111，7<br>1000，8<br>1001，9</p><p>老鼠编号 对应药水瓶子编号<br>1， ，，， 1，3，5，7，9<br>2， ，，， 2，3，6，7<br>3， ，，，4，5，6，7<br>4， ，，，8，9</p><p>如果一周之后，全都安然无恙，则0号药水瓶子有毒，<br>如果1，2，3编号老鼠死亡，则很容易看出7号有毒，<br>或者1，2，3编号老鼠置为1，4号置为0，从低到高即为0111=7</p><h2 id="6-石头称重"><a href="#6-石头称重" class="headerlink" title="6.石头称重"></a>6.石头称重</h2><p>13个石头，有一个比较重其他都一样，用天平测量最多需要几次才能测出重的那个</p><p>4 4 5</p><p> 1) 如果 4 == 4 在 5 里面 分为 2 2 1<br> 1.1) 如果 2 == 2 在 1 那 ok <strong>两次</strong><br> 1.2) 如果 2 != 2 称 1 1 ，那个沉就是答案，<strong>三次</strong><br> 2) 4 != 4 在 沉的那堆里面<br> 2.1) 称2 2 排除 2个 再称1 1 ，那个沉就是答案，<strong>三次</strong></p><h2 id="7-抛硬币"><a href="#7-抛硬币" class="headerlink" title="7.抛硬币"></a>7.抛硬币</h2><p>一硬币，一面向上概率0.7，一面0.3，如何公平？</p><p>两个人轮流抛硬币，先抛到正面的赢，问先抛的人赢的概率？</p><p>每一轮 抛硬币，A先抛赢得概率是1/2，B后抛赢得概率是（1/2）*（1/2）= 1/4。那么 每一轮A赢得概率都是B赢得概率的2倍 ，总概率为1,所以A赢的概率是2/3。</p><h2 id="8-蚊香"><a href="#8-蚊香" class="headerlink" title="8.蚊香"></a>8.蚊香</h2><p>两根香，一根烧完1小时，如何测量15分钟</p><p>开始时一根香两头点着，一根香只点一头，两头点着的香烧完说明过去了半小时，这时将只点了一头的香另一头也点着，从这时开始到烧完就是15分钟。</p><h2 id="9-海盗分金币"><a href="#9-海盗分金币" class="headerlink" title="9.海盗分金币"></a>9.海盗分金币</h2><p>1.</p><p>在加勒比海上，有五个海盗，共同抢到了100枚金币， 每一个人按顺序依次提出自己的分配方案，如果提出的方案没有获得<strong>半数或半数以上</strong>的人的同意，则这个提出方案的人就被扔到海里喂鲨鱼，那么第一个提出方案的人要怎么做，才能使自己的利益最大化？（前提是海盗都是十分聪明和贪婪的）</p><p>假使前三个人都因为分配金币的方式不合理而被扔下大海，此时还剩下两个人，也就是4号和5号，那么问题就简单了：</p><p><strong>4号和5号</strong>分金币的情况：<br>   4号提出方案，自己一定会同意的，并且只要自己同意，这个方案就已经获得了半数的支持，就可以被实施<br>   因此，无论5号是否同意4号提出的方案，都不会对最终的结果造成影响，因此，<strong>4号一定会要100枚金币</strong>，以使自己的利益最大化，结果就变成了这样：<br>     <strong>4号</strong>     5号<br>     <strong>100</strong>     0</p><p>现在我们多添加一个人，<br><strong>3号，4号和5号</strong>分金币的情况：<br>   3号要使自己的提议获得半数的支持就必须再拉拢一个人，拉拢4号显然是不合适的，4号一定不会同意，4号知道，只要搞死了3号，剩下的100枚金币都是自己的。（就像上面4号和5号分金币的情况）拉拢5号是合适的，因为5号之前得不到金币，现在只要3号给5号一个金币就能够获得5号的支持，因为5号也知道，如果3号死亡，自己一定一枚金币都得不到。</p><p>情况就变成了这样：</p><p>​    <strong>3号</strong>     4号    <strong>5号</strong><br>​     <strong>99</strong>      0      <strong>1</strong></p><p>现在我们再多添加一个人：<br><strong>2号，3号，4号和5号</strong>分金币的情况：<br>   2号要使自己的提议获得半数的支持也必须再拉拢一个人，拉拢3号显示是不合适的，3号一定不会同意，3号知道，只要搞死了2号，有99枚金币都是自己的（就像上面3号，4号和5号分金币的情况）， 拉拢5号貌似是可以的，他已经有一个金币了，要让他支持自己只要再多给他一个金币就可以了，拉拢4号也是可以的，4号现在没有金币，只要给他一个就可以让他自持自己的提案，综上所述，要让自己利益最大化，就需要拉拢4号，因为只要给4号一个金币即可：<br>   情况就变成了这样：<br>     <strong>2号</strong>     3号     <strong>4号</strong>     5号<br>     <strong>99</strong>      0       <strong>1</strong>     0</p><p>最后我们再多添加一个人这道题目的答案就出来了：<br>1号，2号，3号，4号和5号分金币的情况：</p><p>1号要使自己的提议获得半数的支持必须拉拢两个人，拉拢2号显示是不合适的，2号一定不会同意，2号知道，只要搞死了1号，有99枚金币都是自己的，（就像上面2号，3号，4号和5号分金币的情况）， 拉拢4号貌似是可以的，他已经有一个金币了，要让他支持自己需要再给他一个金币才可以，这样做并不能让自己的利益最大化， 拉拢3号是可以的，3号现在没有金币，只要给他一个就可以让他自持自己的提案， 5号跟3号情况一至，同样没有金币，只要给他一个就可以了，综上所述，要让自己利益最大化，就需要拉拢3号跟5号，因为拉拢他们两个只需要各自给一个金币即可：<br>情况就变成了这样：<br>     <strong>1号</strong>     2号     <strong>3号</strong>     4号     <strong>5号</strong><br>     <strong>98</strong>      0       <strong>1</strong>       0      <strong>1</strong></p><ol start="2"><li><p>或必须半数以上的人同意呢？</p><p>这道题是典型的逆向思维的问题，用回推法可以得到答案。过程如下：从后往前推，人数依次增加如果1-3号强盗都喂了鲨鱼，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。3号知道这一点，就会提（100,0,0）的分配方案，对4号、5号一毛不拔而将全部金币归为已有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票，他的方案即可通过。2号推到3号的方案，就会提出（98，0，1，1）的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。2号的方案会被1号所洞悉，1号并将提出（97，0，1，2，0）或（97，0，1，0，2）的方案，即放弃2号，而给3号一枚金币，同时给4号（或5号）2枚金币。由于1号的这一方案对于3号和4号（或5号）来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。这无疑是1号能够获取最大收益的方案了！</p></li></ol><h2 id="10-54张扑克牌，平均分成3份，大小王在一份的概率"><a href="#10-54张扑克牌，平均分成3份，大小王在一份的概率" class="headerlink" title="10. 54张扑克牌，平均分成3份，大小王在一份的概率"></a>10. 54张扑克牌，平均分成3份，大小王在一份的概率</h2><p>首先大王一定会在某一份中，然后要计算这一份中还要包含小王的概率。去掉大王还剩53张牌，这一份还可以分17张牌，那么每次分到小王的概率是1/53,所以总概率是17/53。</p><p><img src="https://uploadfiles.nowcoder.com/images/20200518/66153173_1589803055420_16F6C01C102793BA75D2E74EDCF64397" alt="img"></p><h2 id="11-让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。"><a href="#11-让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。" class="headerlink" title="11.让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。"></a>11.让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。</h2><p>传入参数有总钱数，分的份数，随机分还是等分。先判断钱数能不能分那么多份，这个直接用总钱数&gt;=0.01<em>份数判断就可以了。然后根据分发策略，选择随机还是等分，随机的话就给 1到总钱数-（总份数-1）</em>0.01 的随机数（总钱数以分为单位），等分的话直接除判断能不能除开，有余数就将余数加到最后一份里面。</p><h2 id="12-分布式多个机器生成id，如何保证不重复"><a href="#12-分布式多个机器生成id，如何保证不重复" class="headerlink" title="12.分布式多个机器生成id，如何保证不重复?"></a>12.分布式多个机器生成id，如何保证不重复?</h2><p>\1.     <strong>snowflake方案</strong>     ：     </p><p>​      snowflake是Twitter开源的分布式ID生成<a href>算法</a>，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着     每个节点在每毫秒可以产生 4096 个 ID     ），最后还有一个符号位，永远是0。     </p><p>​      优点     ：     </p><p>​      1.毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。     </p><p>​      2.不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。     </p><p>​      3.可以根据自身业务特性分配bit位，非常灵活。     </p><p>​      缺点     ：     </p><p>​      强依赖机器时钟，如果     机器上时钟回拨     ，会导致发号重复或者服务会处于不可用状态。     </p><p>​      \2.     <strong>用Redis生成ID：</strong>     </p><p>​      因为Redis是单线程的，也可以用来生成全局唯一ID。可以用Redis的原子操作INCR和INCRBY来实现。     </p><p>​      此外，可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis，可以初始化每台Redis的值分别是1,2,3,4,5，步长都是5，各Redis生成的ID如下：     </p><p>​      A：1,6,11,16     </p><p>​      B：2,7,12,17     </p><p>​      C：3,8,13,18     </p><p>​      D：4,9,14,19     </p><p>​      E：5,10,15,20     </p><p>​      这种方式是负载到哪台机器提前定好，未来很难做修改。3~5台服务器基本能够满足需求，都可以获得不同的ID，但步长和初始值一定需要事先确定，使用Redis集群也可以解决单点故障问题。     </p><p>​      另外，比较适合使用Redis来生成每天从0开始的流水号，如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。     </p><p>​      <strong>优点：</strong>     </p><p>​      1）不依赖于数据库，灵活方便，且性能优于数据库。     </p><p>​      2）数字ID天然<a href>排序</a>，对分页或需要<a href>排序</a>的结果很有帮助。     </p><p>​      <strong>缺点：</strong>     </p><p>​      1）如果系统中没有Redis，需要引入新的组件，增加系统复杂度。     </p><p>​      2）需要编码和配置的工作量较大。</p><h2 id="13-数据库连接池怎么设计"><a href="#13-数据库连接池怎么设计" class="headerlink" title="13.数据库连接池怎么设计?"></a>13.数据库连接池怎么设计?</h2><p>需要考虑的问题：     </p><ol><li>限制连接池中最多、可以容纳的连接数目，避免过度消耗系统资源。 </li><li>当客户请求连接，而连接池中所有连接都已被占用时，该如何处理呢？一种方式是让客户一直等待，直到有空闲连接，另一种方式是为客户分配一个新的临时连接。 </li><li>当客户不再使用连接，需要把连接重新放回连接池。 </li><li>连接池中允许处于空闲状态的连接的最大<a href>项目</a>。假定允许的最长空闲时间为十分钟，并且允许空闲状态的连接最大数目为5， </li></ol><p>​      那么当连接池中有n个(n&gt;5)连接处于空闲状态的时间超过十分钟时，     <strong>就应该把n-5个连接关闭，并且从连接池中删除，</strong>     这样才能更有效的利用系统资源。</p><h2 id="14-扫码登录"><a href="#14-扫码登录" class="headerlink" title="14.扫码登录"></a>14.扫码登录</h2><h2 id="15-砝码秤盐"><a href="#15-砝码秤盐" class="headerlink" title="15.砝码秤盐"></a>15.砝码秤盐</h2><p>140g盐,一天平,7g 、2g砝码各一个,如何只利用这些东西3次把盐分成50g和90g?</p><ul><li><p>第一次： 7g、2g砝码称出9g盐，结果盐分成9g与131g</p></li><li><p>第二次：将9g盐与7g、2g都作为砝码，结果将盐分为18g与113g （注意：这时盐已经分为三份：9g、18g、113g，还有两个砝码）</p></li><li><p>第三次：将18g盐与7g砝码发在左托盘，将2g砝码放在右托盘，然后在113g盐中取盐添置右托盘中，可获取23g盐。</p></li></ul><p>  这时盐分为9g，18g，23g与90g。  </p><p>  即三次，可以得到90g与（9+18+23）50g。</p><h2 id="16-九球称重"><a href="#16-九球称重" class="headerlink" title="16.九球称重"></a>16.九球称重</h2><blockquote><h3 id="有-9-个球，其中-8-个球质量相同，有-1-个球比较重。要求用-2-次天平，找出比较重的那个球。"><a href="#有-9-个球，其中-8-个球质量相同，有-1-个球比较重。要求用-2-次天平，找出比较重的那个球。" class="headerlink" title="有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。"></a>有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。</h3></blockquote><p> 将这些球均分成 3 个一组共 3 组，选出 2 组称重，如果 1 组比较重，那么重球在比较重的那 1 组；如果 1 组重量相等，那么重球在另外 1 组。 </p><p> 对比较重的那 1 组的 3 个球再分成 3 组，重复上面的步骤。 </p><h2 id="17-药丸称重"><a href="#17-药丸称重" class="headerlink" title="17.药丸称重"></a>17.药丸称重</h2><blockquote><h3 id="有-20-瓶药丸，其中-19-瓶药丸质量相同为-1-克，剩下一瓶药丸质量为-1-1-克。瓶子中有无数个药丸。要求用一次天平找出药丸质量-1-1-克的药瓶。"><a href="#有-20-瓶药丸，其中-19-瓶药丸质量相同为-1-克，剩下一瓶药丸质量为-1-1-克。瓶子中有无数个药丸。要求用一次天平找出药丸质量-1-1-克的药瓶。" class="headerlink" title="有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。"></a>有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。</h3></blockquote><p> 可以从药丸的数量上来制造差异：从第 i 瓶药丸中取出 i 个药丸，然后一起称重。可以知道，如果第 i 瓶药丸重 1.1 克/粒，那么称重结果就会比正常情况下重 0.1 * i 克。 </p><h2 id="18-得到-4-升的水"><a href="#18-得到-4-升的水" class="headerlink" title="18.得到 4 升的水"></a>18.得到 4 升的水</h2><blockquote><h3 id="有两个杯子，容量分别为-5-升和-3-升，水的供应不断。问怎么用这两个杯子得到-4-升的水。"><a href="#有两个杯子，容量分别为-5-升和-3-升，水的供应不断。问怎么用这两个杯子得到-4-升的水。" class="headerlink" title="有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。"></a>有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。</h3></blockquote><ul><li>1、将3升的装满倒入5升的；<br>2、再一次将3升的转满，倒入5升的，把5升装满；<br>3、3升杯里剩下的就是1升水；<br>4、倒掉5升的，把1升水倒入5升杯；<br>5、第三次加满3升杯，倒入5升杯，得到4升水。 </li></ul><h2 id="19-扔鸡蛋"><a href="#19-扔鸡蛋" class="headerlink" title="19.扔鸡蛋"></a>19.扔鸡蛋</h2><blockquote><h3 id="一栋楼有-100-层，在第-N-层或者更高扔鸡蛋会破，而第-N-层往下则不会。给-2-个鸡蛋，求-N，要求最差的情况下扔鸡蛋的次数最少"><a href="#一栋楼有-100-层，在第-N-层或者更高扔鸡蛋会破，而第-N-层往下则不会。给-2-个鸡蛋，求-N，要求最差的情况下扔鸡蛋的次数最少" class="headerlink" title="一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少"></a>一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少</h3></blockquote><p>最优解法是反向思考的经典：如果最优解法在最坏情况下需要扔X次，那第一次在第几层扔最好呢？ </p><p> 答案是：从X层扔 </p><p> 假设最优的尝试次数的x次，为什么第一次扔就要选择第x层呢？ </p><p> 这里的解释会有些烧脑，请小伙伴们坐稳扶好： </p><p> <strong>假设第一次扔在第x+1层：</strong> </p><p> 如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x层。 </p><p> 这样一来，我们总共尝试了x+1次，和假设尝试x次相悖。由此可见，第一次扔的楼层必须小于x+1层。 </p><p> <strong>假设第一次扔在第x-1层：</strong> </p><p> 如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-2层。 </p><p> 这样一来，我们总共尝试了x-2+1 = x-1次，虽然没有超出假设次数，但似乎有些过于保守。 </p><p> <strong>假设第一次扔在第x层：</strong> </p><p> 如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-1层。 </p><p> 这样一来，我们总共尝试了x-1+1 = x次，刚刚好没有超出假设次数。 </p><p> 因此，要想尽量楼层跨度大一些，又要保证不超过假设的尝试次数x，那么第一次扔鸡蛋的最优选择就是第x层。 </p><p> 那么算最坏情况，第二次你只剩下x-1次机会，从100-x层 扔</p><p>按照上面的说法，你第二次尝试的位置必然是X+（X-1）； </p><p> 以此类推我们可得： </p><p> x + (x-1) + (x-2) + … + 1 = 100 </p><p> 这个方程式不难理解： </p><p> 左边的多项式是各次扔鸡蛋的楼层跨度之和。由于假设尝试x次，所以这个多项式共有x项。 </p><p> 右边是总的楼层数100。 </p><p> 下面我们来解这个方程： </p><p> x + (x-1) + (x-2) + … + 1 = 100 转化为 </p><p> (x+1)*x/2 = 100 </p><p> 最终x向上取整，得到 x = 14 </p><p> 因此，最优解在最坏情况的尝试次数是14次，第一次扔鸡蛋的楼层也是14层。 </p><p> 最后，让我们把第一个鸡蛋没碎的情况下，所尝试的楼层数完整列举出来： </p><p> 14，27， 39， 50， 60， 69， 77， 84， 90， 95， 99， 100 </p><p> 举个栗子验证下： </p><p> 假如鸡蛋不会碎的临界点是65层，那么第一个鸡蛋扔出的楼层是14，27，50，60，69。这时候啪的一声碎了。 </p><p> 第二个鸡蛋继续，从61层开始，61，62，63，64，65，66，啪的一声碎了。 </p><p> 因此得到不会碎的临界点65层，总尝试次数是 6 + 6 = 12 &lt; 14 。 </p><p> 下面是我个人的理解：这个更像是优化版的均匀法，均匀法让你第二次尝试不超过10，但是第一次的位置无法保证（最多要9次，最好一次），这个由于每多一次尝试，楼层间隔就-1，最终使得第一次与第二次的和完全均匀（最差情况）。 </p><p> 但是核心思路是逆向思考，因为即使理解了需要两次的和均匀也很难得到第一次要在哪层楼扔。 </p><p> 一旦理解了这种方法，多少层楼你都不会怕啦~</p><p>来源：<a href="https://blog.csdn.net/qq_38316721/article/details/81351297" target="_blank" rel="noopener">https://blog.csdn.net/qq_38316721/article/details/81351297</a></p><h2 id="20-一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样"><a href="#20-一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样" class="headerlink" title="20.一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样"></a>20.一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样</h2><p>1/3<br>样本空间为（男男）（女女）（男女）（女男）<br>A＝（已知其中一个是女孩）＝）（女女）（男女）（女男）<br>B＝（另一个也是女孩）＝（女女）<br>于是P（B／A）＝P（AB）／P（A）＝（1／4）／（3／4）＝1／3</p><h2 id="21-分金条"><a href="#21-分金条" class="headerlink" title="21.分金条"></a>21.分金条</h2><p>有个商人雇用了一位手艺高超的工匠了为他做一个精致产品，工作一星期七天的代价是一条金条。商人手头上有一条金条，刚好有可以付工匠一星期的工钱。但工匠要求工钱要按每天来付。虽然他并不急着用钱，每天有钱进账，老人心里总是踏实一些。但商人家中有个规矩，金条每星期只能切二刀。后来商人想出以了个切割金条的办法，满足了工匠的要求。你知道商人是怎么切割金条才能满足工匠的吗？</p><p>切成1、2、4。这三个二进制数的组合能表示0-7中的任何一个。</p><h2 id="22-假钱问题"><a href="#22-假钱问题" class="headerlink" title="22.假钱问题"></a>22.假钱问题</h2><p><strong>老王30买了双鞋，35卖，客人花100买，老王没零钱于是向老李换了100.补给客人后，客人走远后老李突然说是假钱，于是老王补偿给了老李，问老王一共亏了多少？</strong></p><p>卖鞋赚了35-30=5<br>假钱赔了100<br>一共亏95</p><h2 id="23-取硬币问题"><a href="#23-取硬币问题" class="headerlink" title="23.取硬币问题"></a>23.取硬币问题</h2><p><strong>30枚面值不全相同的硬币摆成一排，甲、乙两个人轮流选择这排硬币的其中一端，并取走最外边的那枚硬币。如果你先取硬币，能保证得到的钱不会比对手少吗？</strong></p><p>先取者可以让自己总是取奇数位置上的硬币或者总是取偶数位置上的硬币。数一数是奇数位置上的面值总和多还是偶数位置上的面值总和多，然后总是取这些位置上的硬币就可以了。</p><h2 id="24-旅馆问题"><a href="#24-旅馆问题" class="headerlink" title="24.旅馆问题"></a>24.旅馆问题</h2><p>有三个人去住旅馆，住三间房，每一间房10元，于是他们一共付给老板30，第二天，老板觉得三间房只需要25元就够了  叫小弟退回5给三位客人，谁知小弟贪心,只退回每人1，自己偷偷拿了2，这样一来便等于那三位客人每人各花了九元，于是三个人一共花了27，再加上小弟独吞了2，总共是29。可是当初他们三个人一共付出30，那么还有剩下的1呢？</p><p>他们所消费的27元里已经包括小弟贪污的2元了，再加退还的3元=30元。：这30元现在的分布是：老板拿25元，伙计拿2元，三人各拿1元，正好！</p><h2 id="25-蓝眼睛问题"><a href="#25-蓝眼睛问题" class="headerlink" title="25.蓝眼睛问题"></a>25.蓝眼睛问题</h2><p>有个岛上住着一群人，有一天来了个游客，定了一条奇怪的规矩：所有蓝眼睛的人都必须尽快离开这个岛。每晚8点会有一个航班离岛。每个人都看得见别人眼睛的颜色，但不知道自己的（别人也不可以告知）。此外，他们不知道岛上到底有多少人是蓝眼睛的，只知道至少有一个人的眼睛是蓝色的。所有蓝眼睛的人要花几天才能离开这个岛？</p><p>c=1<br>假设岛上所有人都是聪明的，蓝眼睛的人四处观察之后，发现没有人是蓝眼睛的。但他知道至少有一人是蓝眼睛的，于是就能推导出自己一定是蓝眼睛的。因此，他会搭乘当晚的飞机离开。 </p><p>c=2<br>两个蓝眼睛的人看到对方，并不确定c是1还是2，但是由上一种情况，他们知道，如果c = 1，那个蓝眼睛的人第一晚就会离岛。因此，发现另一个蓝眼睛的人仍在岛上，他一定能推断出c = 2，也就意味着他自己也是蓝眼睛的。于是，两个蓝眼睛的人都会在第二晚离岛。</p><p>c&gt;2<br>逐步提高c时，我们可以看出上述逻辑仍旧适用。如果c = 3，那么，这三个人会立即意识到有2到3人是蓝眼睛的。如果有两人是蓝眼睛的，那么这两人会在第二晚离岛。因此，如果过了第二晚另外两人还在岛上，每个蓝眼睛的人都能推断出c = 3，因此这三人都有蓝眼睛。他们会在第三晚离岛。 </p><p>不论c为什么值，都可以套用这个模式。所以，如果有c人是蓝眼睛的，则所有蓝眼睛的人要用c晚才能离岛，且都在同一晚离开。</p><h2 id="26-疯狗问题"><a href="#26-疯狗问题" class="headerlink" title="26.疯狗问题"></a>26.疯狗问题</h2><p>有50家人家，每家一条狗。有一天警察通知，50条狗当中有病狗，行为和正常狗不一样。每人只能通过观察别人家的狗来判断自己家的狗是否生病，而不能看自己家的狗，如果判断出自己家的狗病了，就必须当天一枪打死自己家的狗。结果，第一天没有，第二天没有，第三天开始一阵枪响，问：一共死了几条狗？</p><p>死了3条（第几天枪响就有几条）。<br>从有一条不正常的狗开始，显然第一天将会听到一声枪响。这里的要点是你只需站在那条不正常狗的主人的角度考虑。<br>有两条的话思路继续，只考虑有两条不正常狗的人，其余人无需考虑。通过第一天他们了解了对方的信息。第二天杀死自己的狗。换句话说每个人需要一天的时间证明自己的狗是正常的。有三条的话，同样只考虑那三个人，其中每一个人需要两天的时间证明自己的狗是正常的狗。</p><h2 id="27-耳光问题（跟蓝眼睛一样）"><a href="#27-耳光问题（跟蓝眼睛一样）" class="headerlink" title="27.耳光问题（跟蓝眼睛一样）"></a>27.耳光问题（跟蓝眼睛一样）</h2><p>一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其他人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？</p><p>答案：有三个人戴黑帽。假设有N个人戴黑帽，当N＝1时，戴黑帽的人看见别人都为白则能肯定自己为黑。于是第一次关灯就应该有声。可以断定N＞1。对于每个戴黑帽的人来说，他能看见N-1顶黑帽，并由此假定自己为白。但等待N-1次还没有人打自己以后，每个戴黑人都能知道自己也是黑的了。所以第N次关灯就有N个人打自己。</p><h2 id="28-红球篮球"><a href="#28-红球篮球" class="headerlink" title="28.红球篮球"></a>28.红球篮球</h2><p><strong>你有两个罐子，每个罐子各有若干红色弹球和蓝色弹球，两个罐子共有50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机从中选取出一个弹球，要使取出的是红球的概率最大，一开始两个罐子应放几个红球，几个蓝球？在你的计划中，得到红球的准确几率是多少？</strong></p><p>一个罐子放1红，一个罐子放49红和50蓝，这样得到红球的概率接近3/4。</p><h2 id="29-猜数字"><a href="#29-猜数字" class="headerlink" title="29.猜数字"></a>29.猜数字</h2><p>教授选出两个从2到9的数，把它们的和告诉学生甲，把它们的积告诉学生乙，让他们轮流猜这两个数， 甲说：“我猜不出”， 乙说：“我猜不出”， 甲说：“我猜到了”， 乙说：“我也猜到了”， 问这两个数是多少？</p><p>3和4。设两个数为n1，n2，n1&gt; =n2，甲听到的数为n=n1 n2，乙听到的数为m=n1*n2，证明n1=3，n2=4是唯一解。</p><p>证明：要证以上命题为真，不妨先证n=7</p><p>1)必要性：<br> 　　i) n&gt; 5 是显然的，因为n &lt;4不可能，n=4或者n=5甲都不可能回答不知道<br> 　　ii) n&gt; 6 因为如果n=6的话，那么甲虽然不知道(不确定2 4还是3 3)但是无论是2，4还是3，3乙都不可能说不知道(m=8或者m=9的话乙说不知道是没有道理的)<br> 　　iii) n &lt;8 因为如果n&gt; =8的话，就可以将n分解成 n=4 x 和 n=6 (x-2)，那么m可以是4x也可以是6(x-2)而4x=6(x-2)的必要条件是x=6即n=10，那样n又可以分解成8 2，所以总之当n&gt; =8时，n至少可以分解成两种不同的合数之和，这样乙说不知道的时候，甲就没有理由马上说知道。以上证明了必要性。<br>2)充分性<br>当n=7时，n可以分解成2 5或3 4<br>显然2 5不符合题意，舍去，容易判断出3 4符合题意，m=12，证毕<br>于是得到n=7 m=12 n1=3 n2=4是唯一解。</p><h2 id="30-水果标签问题"><a href="#30-水果标签问题" class="headerlink" title="30.水果标签问题"></a>30.水果标签问题</h2><p><strong>3个箱子里面放了 苹果，梨子，苹果加梨子，标签全错误，只能选择查看一箱的水果来改正所有标签</strong></p><p>查看贴苹果和梨标签那一个，如果拿出来的是苹果，代表这一箱只有苹果，因为如果是苹果和梨就代表标签没错了。<br>那么剩下的两箱就是梨，苹果和梨，剩下的标签是梨，苹果，由于标签全错，所以贴着苹果的是梨，贴着梨的是苹果和梨。<br>如果拿出来的是梨，同理代表这一箱只有梨。那么剩下的两箱就是苹果，苹果和梨，剩下的标签就是苹果，梨。由于标签全错，贴着苹果的就是苹果和梨，贴着梨的就是苹果。</p><h2 id="31-便士标签问题（和水果标签一样）"><a href="#31-便士标签问题（和水果标签一样）" class="headerlink" title="31.便士标签问题（和水果标签一样）"></a>31.便士标签问题（和水果标签一样）</h2><p>假设在桌上有三个密封的盒，一个盒中有2枚银币(1银币=10便士)，一个盒中有2枚镍币(1镍币=5便士)，还有一个盒中有1枚银币和1枚镍币。这些盒子被标上10便士、 15便士和20便士，但每个标签都是错误的。允许你从一个盒中拿出1枚硬币放在盒前，看到这枚硬币，你能否说出每个盒内装的东西呢？</p><h2 id="32-吃药问题"><a href="#32-吃药问题" class="headerlink" title="32.吃药问题"></a>32.吃药问题</h2><p>某种药方要求非常严格，你每天需要同时服用A、B两种药片各一颗，不能多也不能少。这种药非常贵，你不希望有任何一点的浪费。一天，你打开装药片A的药瓶，倒出一粒药片放在手心；然后打开另一个药瓶，但不小心倒出了两粒药片。现在，你手心上有一颗药片A，两颗药片B，并且你无法区别哪个是A，哪个是B。你如何才能严格遵循药方服用药片，并且不能有任何的浪费？</p><p>把手上的三片药各自切成两半，分成两堆摆放。再取出一粒药片A，也把它切成两半，然后在每一堆里加上半片的A。现在，每一堆药片恰好包含两个半片的A和两个半片的B。一天服用其中一堆即可。</p><h2 id="33-硬币问题"><a href="#33-硬币问题" class="headerlink" title="33.硬币问题"></a>33.硬币问题</h2><p>如何用一枚硬币等概率生成一个1到3之间的随机整数？如果这枚硬币是不公正的呢？</p><p>答案：如果是公正的硬币，则投掷两次，“正反”为1，“反正”为2，“正正”为3，“反反”重来。</p><p>如果是不公正的硬币，注意到出现“正反”和“反正”的概率一样，因此令“正反反正”、“反正正反”、“正反正反”分别为1、2、3，其余情况重来。另一种更妙的办法是，投掷三次硬币，“正反反”为1，“反正反”为2，“反反正”为3，其余情况重来。</p><h2 id="34-灯管问题"><a href="#34-灯管问题" class="headerlink" title="34.灯管问题"></a>34.灯管问题</h2><p><strong>在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？</strong></p><p>打开一个开关。过10分钟后关掉开关，并打开另一个开关。进屋确认可知：<br>亮的灯是由第二次打开的开关控制；<br>摸上去发热的不发亮的灯是由第一次打开的开关控制<br>剩下的第三盏灯是由未操作过的开关控制。</p><h2 id="35-盲人问题"><a href="#35-盲人问题" class="headerlink" title="35.盲人问题"></a>35.盲人问题</h2><p>他们都各自买了两对黑袜和两对白袜，八对袜了的布质、大小完全相同，而每对袜了都有一张商标纸连着。两位盲人不小心将八对袜了混在一起。 他们每人怎样才能取回黑袜和白袜各两对呢？</p><p>每一对分开，一人拿一只，因为袜子不分左右脚</p><h2 id="36-最大钻石问题"><a href="#36-最大钻石问题" class="headerlink" title="36.最大钻石问题"></a>36.最大钻石问题</h2><p><strong>一楼到十楼的每层电梯门口都放着一颗钻石，钻石大小不一。你乘坐电梯从一楼到十楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到最大的一颗？</strong></p><p>选择前五层楼都不拿，观察各层钻石的大小，做到心中有数。后面五个楼层再选择，选择大小接近前五层楼出现过最大钻石大小的钻石。</p><h2 id="37-飞机飞行的问题"><a href="#37-飞机飞行的问题" class="headerlink" title="37.飞机飞行的问题"></a>37.飞机飞行的问题</h2><p>有N架一样的飞机停靠在同一个机场，每架飞机都只有一个油箱，每箱油可使飞机绕地球飞半圈。注意：天空没有加油站，飞机之间只是可以相互 加油。 如果使某一架飞机平安地绕地球飞一圈，并安全地回到起飞时的机场，问：至少需要出动几架飞机？ 注：路途中间没有飞机场，每架飞机都必须安全返回起飞时的机场，不许中途降落。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一共需要6架飞机。假设绕地球一圈为1，3 架飞机同时顺时针飞，在1&#x2F;8 处 油量为 3&#x2F;4 3&#x2F;4 3&#x2F;4 其中一辆給另外两加满往回飞，此时油量为1，1，到1&#x2F;4 处 油量为3&#x2F;4，3&#x2F;4， 加满一辆，另一辆往回 2&#x2F;4 ，1，可以飞到3&#x2F;4 的位置 此时油量为0</span><br><span class="line"></span><br><span class="line">3架飞机往逆时针方向飞，在7&#x2F;8 位置3&#x2F;4， 3&#x2F;4， 3&#x2F;4 ，一架给另两加满然后往回飞 1，1，0，继续飞，在3&#x2F;4 位置 油量为 3&#x2F;4， 3&#x2F;4， 0 ， 平衡一下 2&#x2F;4 ，2&#x2F;4 ，2&#x2F;4 可以把之前的飞机接回去</span><br></pre></td></tr></table></figure><h2 id="38-犯人猜颜色"><a href="#38-犯人猜颜色" class="headerlink" title="38.犯人猜颜色"></a>38.犯人猜颜色</h2><p>一百个犯人站成一纵列，每人头上随机带上黑色或白色的帽子，各人不知道自己帽子的颜色，但是能看见自己前面所有人帽子的颜色．<br> 然后从最后一个犯人开始，每人只能用同一种声调和音量说一个字：”黑”或”白”，<br> 如果说中了自己帽子的颜色，就存活，说错了就拉出去斩了，<br> 说的答案所有犯人都能听见，<br> 是否说对，其他犯人不知道，<br> 在这之前，所有犯人可以聚在一起商量策略，<br> 问如果犯人都足够聪明而且反应足够快，100个人最大存活率是多少？ </p><p> 答案：这是一道经典推理题 </p><p> 1、最后一个人如果看到奇数顶黑帽子报“黑”否则报“白”，他可能死 </p><p> 2、其他人记住这个值（实际是黑帽奇偶数），在此之后当再听到黑时，黑帽数量减一 </p><p> 3、从倒数第二人开始，就有两个信息：记住的值与看到的值，相同报“白”，不同报“黑” </p><p> 99人能100%存活，1人50%能活 </p><p> 除此以外，此题还有变种：每个犯人只能看见前面一个人帽子颜色又能最多存活多少人？ </p><p> 答案：在上题基础上，限制了条件，这时上次的方法就不管用了，此时只能约定偶数位犯人说他前一个人的帽子颜色，奇数犯人获取信息100%存活，偶数犯人50几率存活。</p><h2 id="39-猴子搬香蕉"><a href="#39-猴子搬香蕉" class="headerlink" title="39.猴子搬香蕉"></a>39.猴子搬香蕉</h2><p>一个小猴子边上有100根香蕉，它要走过50米才能到家，每次它最多搬50根香蕉，（多了就被压死了），它每走 </p><p> 1米就要吃掉一根，请问它最多能把多少根香蕉搬到家里。（提示：他可以把香蕉放下往返的走，但是必须保证它每走一米都能有香蕉吃。也可以走到n米时，放下一些香蕉，拿着n根香蕉走回去重新搬50根。） </p><p> 答案：这种试题通常有一个迷惑点，让人看不懂题目的意图。此题迷惑点在于：走一米吃一根香蕉，一共走50米，那不是把50根香蕉吃完了吗？如果要回去搬另外50根香蕉，则往回走的时候也要吃香蕉，这样每走一米需要吃掉三根香蕉，走50米岂不是需要150根香蕉？ </p><p> 其实不然，本题关键点在于：猴子搬箱子的过程其实分为两个阶段，第一阶段：来回搬，当香蕉数目大于50根时，猴子每搬一米需要吃掉三根香蕉。第二阶段：香蕉数《=50，直接搬回去。每走一米吃掉1根。 </p><p> 我们分析第一阶段：假如把100根香蕉分为两箱。一箱50根。 </p><p> 第一步，把A箱搬一米，吃一根。 </p><p> 第二步，往回走一米，吃一根。 </p><p> 第三步，把B箱搬一米，吃一根。 </p><p> 这样，把所有香蕉搬走一米需要吃掉三根香蕉。 </p><p> 这样走到第几米的时候，香蕉数刚好小于50呢？ </p><p> 100-(n<em>3)&lt;50 &amp;&amp; 100-(n-1</em>3)&gt;50 </p><p> 走到16米的时候，吃掉48根香蕉，剩52根香蕉。这步很有意思，它可以直接搬50往前走，也可以再来回搬一次，但结果都是一样的。到17米的时候，猴子还有49根香蕉。这时猴子就轻松啦。直接背着走就行。 </p><p> 第二阶段： </p><p> 走一米吃一根。 </p><p> 把剩下的50-17=33米走完。还剩49-33=16根香蕉。</p><h2 id="40-轮流拿石头"><a href="#40-轮流拿石头" class="headerlink" title="40.轮流拿石头"></a>40.轮流拿石头</h2><p>问题：一共有N颗石子（或者其他乱七八糟的东西），每次最多取M颗最少取1颗，A，B轮流取，谁最后会获胜？（假设他们每次都取最优解）。</p><p>例子：有10个石头，每人每次可以拿1-2个，轮流拿，最后一个拿的人算输，有什么必赢的方案。</p><p>先说结论：</p><p>假如A先取，N&lt;M，A获胜；</p><p>　　　　　  N&gt;M，若N能被（M + 1）整除时，A失败；</p><p>　　　　　　　　  若N不能被（M + 1）整除时，A获胜；</p><p>假如B先取，（同上）；</p><p>N&gt;M时，A要想赢，必须要在自己倒数第二次取完的时候还剩下（M + 1）颗石子（此时A和B还可以再取一次就可以分出胜负游戏就结束了），这样不论B取几颗，A都获胜！但是要怎样才能控制最后一轮的石子数量？</p><p>分两种情况分析，</p><ol><li>N不能被（M + 1）整除，A先拿走n颗石子（使得剩下的石子数量是（M + 1）的整数倍），那么下一次B拿走k颗石子时，A就拿走（M + 1）- k颗石子。这样不论B怎么拿A总能控制剩下的石子数量是（M + 1）的整数倍，那么最后一轮一定剩下（M + 1）颗石子；</li><li>N能被（M + 1）整除，A就认输吧。。。（B除非傻才会让A赢）无论A怎么拿，B可以控制石子数量（即当B拿完后总能使剩下的石子数量是（M + 1）的整数倍)，在最后一轮之前B拿完后还剩（M + 1）颗，A拿多少颗都是输。</li></ol><p><a href="https://www.cnblogs.com/StrayWolf/p/5396427.html" target="_blank" rel="noopener">https://www.cnblogs.com/StrayWolf/p/5396427.html</a></p><p> 答案：较复杂的尼姆博弈：<a href="https://blog.csdn.net/BBHHTT/article/details/80199541" target="_blank" rel="noopener">https://blog.csdn.net/BBHHTT/article/details/80199541</a></p><p>母题：有若干堆石子，每堆石子的数量是有限的，二个人依次从这些石子堆中拿取任意的石子，至少一个（不能不取），最后一个拿光石子的人胜利。</p><p>1、我们首先以一堆为例： 假设现在只有一堆石子，你的最佳选择是将所有石子全部拿走，那么你就赢了。</p><p>2、如果是两堆：假设现在有两堆石子且数量不相同，那么你的最佳选择是取走多的那堆石子中多出来的那几个，使得两堆石子数量相同，这样，不管另一个怎么取，你都可以在另一堆中和他取相同的个数，这样的局面你就是必胜。比如有两堆石子，第一堆有3个，第二堆有5个，这时候你要拿走第二堆的三个，然后两堆就都变成了3个，这时你的对手无论怎么操作，你都可以“学”他，比如他在第一堆拿走两个，你就在第二堆拿走两个，这样你就是稳赢的</p><h2 id="41-蚂蚁走树枝"><a href="#41-蚂蚁走树枝" class="headerlink" title="41. 蚂蚁走树枝"></a>41. 蚂蚁走树枝</h2><p> 问题：放N只蚂蚁在一条长度为M树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。 </p><p> 答案：这个其实就一个诀窍：蚂蚁相碰就往反方向走，可以直接看做没有发生任何事：大家都相当于独立的 </p><p>  A蚂蚁与B蚂蚁相碰后你可以看做没有发生这次碰撞，这样无论是求时间还是距离都很简单了。</p><h2 id="42-三个火枪手"><a href="#42-三个火枪手" class="headerlink" title="42.三个火枪手"></a>42.三个火枪手</h2><p>问题：彼此痛恨的甲、乙、丙三个枪手准备决斗。甲枪法最好，十发八中；乙枪法次之，十发六中；丙枪法最差，十发四中。如果三人同时***，并且每人每轮只发一枪；那么枪战后，谁活下来的机会大一些？ </p><p> 答案： </p><p> 一般人认为甲的枪法好，活下来的可能性大一些。但合乎推理的结论是，枪法最糟糕的丙活下来的几率最大。 </p><p> 那么我们先来分析一下各个枪手的策略。 </p><p> 如同田忌赛马一般，枪手甲一定要对枪手乙先***。因为乙对甲的威胁要比丙对甲的威胁更大，甲应该首先干掉乙，这是甲的最佳策略。 </p><p> 同样的道理，枪手乙的最佳策略是第一枪瞄准甲。乙一旦将甲干掉，乙和丙进行对决，乙胜算的概率自然大很多。 </p><p> 枪手丙的最佳策略也是先对甲***。乙的枪法毕竟比甲差一些，丙先把甲干掉再与乙进行对决，丙的存活概率还是要高一些。 </p><p> 我们根据分析来计算一下三个枪手在上述情况下的存活几率：<br> 第一轮：甲射乙，乙射甲，丙射甲。<br> 甲的活率为24%（40% X 60%） </p><p> 乙的活率为20%(100% - 80%) </p><p> 丙的活率为100%（无人射丙）。 </p><p> 由于丙100％存活率，因此根据上轮甲乙存活的情况来计算三人第二轮的存活几率： </p><p> 情况1：甲活乙死（24% X 80% = 19.2%）<br> 甲射丙，丙射甲：甲的活率为60%，丙的活率为20%。<br> 情况2：乙活甲死（20% X 76% = 15.2%）<br> 乙射丙，丙射乙：乙的活率为60%，丙的活率为40%。<br> 情况3：甲乙同活（24% X 20% = 4.8%）<br> 重复第一轮。<br> 情况4：甲乙同死（76% X 80% = 60.8%）<br> 枪战结束。 </p><p> 据此来计算三人活率：<br> 甲的活率为(19.2% X 60%) + (4.8% X 24%) = 12.672%<br> 乙的活率为(15.2% X 60%) + (4.8% X 20%) = 10.08%<br> 丙的活率为(19.2% X 20%) + (15.2% X 40%) + (4.8% X 100%) + (60.8% X 100%) = 75.52% </p><p> 通过对两轮枪战的详细概率计算，我们发现枪法最差的丙存活的几率最大，枪法较好的甲和乙的存活几率却远低于丙的存活几率。</p><h2 id="43-囚犯拿豆子"><a href="#43-囚犯拿豆子" class="headerlink" title="43.囚犯拿豆子"></a>43.囚犯拿豆子</h2><p>问题：有5个囚犯被判了死刑，他们请求上诉，于是法官愿意给他们一个机会。 </p><p> 犯人抽签分好顺序，按序每人从100粒豆子中随意抓取，最多可以全抓，最少可以不抓，可以和别人抓的一样多。 </p><p> 最终，抓的最多的和最少的要被处死。 </p><p> 1、他们都是非常聪明且自私的人。 </p><p> 2、他们的原则是先求保命。如果不能保命，就拉人陪葬。 </p><p> 3、100颗不必都分完。 </p><p> 4、若有重复的情况，则也算最大或最小，一并处死（中间重复不算）。 </p><p> 假设每个犯人都足够聪明，但每个犯人并不知道其他犯人足够聪明。那么，谁活下来的可能性最大？</p><p>根据题意，一号知道有五个人抓豆子，为保性命，他只要让豆子在20颗以内就可以了。但是他足够聪明的话他一定拿20颗，因为无论多拿一颗：2,3,4号的人一定会拿20颗最后死的人就会是最多的1号和最少的5号  还是少拿一颗：2,3,4号拿20个后，5号选择也拿20个拉上1234号垫背。（下面会说为什么多拿少拿也只会相差一颗） </p><p> 2号是知道1号抓了几颗豆子(20)的。那么，对于2号来说，只有2种选择：与1号一样多，或者不一样多。我们就从这里入手。 </p><p> 情况一，假如2号选择与1号的豆子数不一样多，也就是说2号选择比1号多或者比1号少。 </p><p> 我们先要证明，如果2号选择比1号多或者比1号少，那么他一定会选择比1号只多1颗或者只少1颗。 </p><p> 要证明这个并不算太难。因为每个囚犯的第一选择是先求保命，要保命就要尽量使自己的豆子数既不是最多也不是最少。当2号决定选择比1号多的时候，他已经可以保证自己不是最少，为了尽量使自己不是最多，当然比1号多出来的数量越小越好。因为这个数量如果与一号相差大于1的话，那么3号就有机会抓到的居中数，相差越大，二号成为最多的可能性也就越大。反之，当2号决定选择比1号少的时候，也是同样的道理，他会选择只比1号少1颗。既然2号只会会选择比1号多1颗或者比1号少1颗，那么1、2号的豆子数一定是2个连续的自然数，和一定是2n+1（其中1个人是n,另1人是n+1）。 </p><p> 轮到3号的时候，他可以从剩下的豆子数知道1、2号的数量和，也就不难计算出n的值。而3号也只有2个选择：n颗或者n+1颗。为什么呢？这与上面的证明是一样的道理，保命原则，取最接近的数量，这里不再赘述。 </p><p> 不过，3号选择的时候会有一个特殊情况，在这一情况下，他一定会选择较小的n，而不是较大的n+1。这一特殊情况就是，当3号知道自己选择了n后(已保证自己不是最多)，剩下的豆子数由于数量有限，4、5号中一定有人比n要少，这样自己一定可以活下来。计算的话就是 [100-(3n+1)]/2&lt;=n ，不难算出，在这个特殊情况下，n&gt;=20。也就是说，当1、2号选择了20或21颗的时候，3号只要选择20颗，就可以保证自己活下来。 </p><p> 这样一来剩下的豆子只剩39颗，4、5号至少有一人少于20颗的（这个人当然是后选的5号），这样死的将是5号和1、2号中选21颗的那个人。当然，1号、2号肯定不会有人选择21这一“倒霉”的数字（因为他们都是聪明人），这样的话，上述“特殊情况（即3号选择n）”就不会发生了。 </p><p> 综上所述，2345这四个人不难从剩下的豆子数知道前面几个人的数量总和，也就不难进而计算出n的值，而这样一来他们也只有n或者n+1这两种选择。最后的5号也是不难算出n的。在前4个人只选择了2个数字(n和n+1)的情况下，5号已是必死无疑，这时,根据“死也要拉几个垫背”的条件，5号会选择n或n+1，选择5个人一起完蛋。 </p><p> 情况二，如果2号选择了与1号不一样多的话，最终结果是5个人一起死，那么2号只有选择与1号一样多了。 </p><p> 那么1、2号的和就是2n，而3号如果选择n+1或者n -1的话，就又回到第一点的情况去了(前3个人的和是3m+1或3m+2)，于是3号也只能选择n ，当然，4号还是只能选n，最后的结果仍旧是5个人一起完蛋。 </p><p> “最后处死抓的最多和最少的囚犯”严格执行这句话的话，除非有人舍己为人，死二留三。但这是足够聪明且自私的囚犯，所以这五个聪明人的下场是全死，这道题只不过是找了一个处死所有人的借口罢了. . . . . . </p><p> 变种问题：如果每个囚犯都知道其他囚犯足够聪明，事情会怎么发展？ </p><p> 答案： </p><p> 这样的情况下囚犯一也会像我们一样推导出前面的结论，那么根据自私的规定，他会直接拿完100个，大家一起完蛋(反正结局已定) </p><h2 id="44-学生猜生日-lt-笔试高频-gt"><a href="#44-学生猜生日-lt-笔试高频-gt" class="headerlink" title="44.学生猜生日&lt;笔试高频&gt;"></a>44.学生猜生日&lt;笔试高频&gt;</h2><p>这种题目笔试中出现的次数比较多，用排除法比较好解决</p><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p> 小明和小强都是张老师的学生，张老师的生日是M月N日, </p><p> 2人都知道张老师的生日是下列10组中的一天，张老师把M值告诉了小明, </p><p> 把N值告诉了小强，张老师问他们知道他的生日是那一天吗? </p><p> 3月4日 3月5日 3月8日 </p><p> 6月4日 6月7日 </p><p> 9月1日 9月5日 </p><p> 12月1日 12月2日 12月8日 </p><p> 小明说:如果我不知道的话，小强肯定也不知道. </p><p> 小强说:本来我也不知道，但是现在我知道了. </p><p> 小明说:哦，那我也知道了. </p><p> 请根据以上对话推断出张老师的生日是哪一天? </p><p> 答案：9月1日 </p><p> 排除法： </p><p> 1.小明肯定小强不知道是哪天，排除所有月份里有单独日的月份：6月和12月&lt;因为如果小强的M是2或者7的话，小强就知道了，所以把6月7日与12月2日排除&gt;，所以小明拿到的是3或者9 </p><p> 2.小强本来不知道，所以小强拿到的不是2或者7，但是小强现在知道了，说明把6月与12月排除后，小强拿到的是1,4,8中的一个&lt;这里小强肯定没拿到5，否则他不会知道是哪天的&gt; </p><p> 3.小明现在也知道了，说明小明拿到的不是3，否则他不会知道是3月4日还是3月8日的，所以小明拿到的是9才能唯一确定生日 </p><p> 综上，答案是9月1日 </p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p> 小明和小强是赵老师的学生，张老师的生日是M月N日，张老师 </p><p> 把M值告诉小明，N值告诉小强 </p><p> 给他们六个选项 </p><p> 3月1日 3月3日 7月3日 7月5日  </p><p> 9月1日 11月7日 </p><p> 小明说:我猜不出来 </p><p> 小强说:本来我也猜不出来，但是现在我知道了 </p><p> 问:张老师生日多少 </p><p> 答案：3月1日 </p><p> 排除法： </p><p> 1.小明说猜不出来，说明小明拿到的不是单独出现的9或者11，说明老师生日只能是3月或者7月 </p><p> 2.小强原本不知道，说明小强拿到的不是单独出现的5或者7，说明老是生日是1日或3日 </p><p> 3.小强现在知道了，说明小强拿到的是1，因为如果拿到的是3，那么小强就不知道是3月3日还是7月3日了 </p><p>   综上，老师生日是3月1日  </p><h2 id="45-火车开车问题"><a href="#45-火车开车问题" class="headerlink" title="45.火车开车问题"></a>45.火车开车问题</h2><p>有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以每小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和两辆火车现时启动，从洛杉矶出发，碰到另一辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，假设洛杉矶到纽约的距离为s, 请问，这只小鸟飞行了多长距离？</p><p>那小鸟飞行的距离就是(s/(15+20))*30。 时间 * 速度</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="网络协议分层"><a href="#网络协议分层" class="headerlink" title="网络协议分层"></a>网络协议分层</h2><p>国际标准化组织 ISO 提出了 OSI 开放互连的七层计算机网络模型，从上到下分别是应用层、表示层、会话层、运输层、网络层、链路层和物理层。OSI 模型的概念清楚，理论也比较完善，但是既复杂又不实用。还有一种是 TCP/IP 体系结构，它分为四层，从上到下分别是应用层、运输层、网际层和网络接口层，不过从实质上将只有三层，因为最下面的网络接口层并没有什么具体内容。因特网的协议栈使用一种五层的模型结构，从上到下依次是<strong>应用层、运输层、网络层、链路层和物理层</strong>，其中下层是为上层提供服务的，每层执行某些动作或使用下层的服务来提高服务。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层是网络体系结构中的最高层，应用层的任务就是<strong>通过应用进程之间的交互来完成特定网络应用</strong>，这一层的数据单元叫做<strong>报文</strong>。</p><p>应用层的协议定义了<strong>应用进程之间通信和交互的规则</strong>，主要包括了域名系统 DNS、支持万维网的 HTTP 协议、支持电子邮件的 SMTP 协议、文件传输协议 FTP 等。</p><p><strong>域名解析系统 DNS</strong></p><p>DNS 被设计为一个联机分布式数据库系统，并采用客户服务器方式。DNS 使大多数名字都在本地进行解析，仅少量解析需要在互联网上通信，因此 DNS 的效率很高。由于 DNS 是分布式系统，即使单个计算机出现了故障也不会妨碍到整个 DNS 系统的正常运行。</p><p><strong>主机向本地域名服务器的查询一般都采用递归查询</strong>，递归查询指如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份向其他根域名服务器继续发出查询请求报文。递归查询的结果是要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</p><p><strong>本地域名服务器向根域名服务器查询通常采用迭代查询</strong>，迭代查询指当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉它该向哪一个域名服务器进行查询。本地域名服务器也可以采用递归查询，这取决于最初的查询请求报文设置的查询方式。</p><p><strong>文件传送协议 FTP</strong></p><p>FTP 使用 TCP 可靠的运输服务，FTP 使用客户服务器方式，一个 FTP 服务器进程可以同时为多个客户进程提供服务，在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：控制连接和数据连接，实际用于传输文件的是数据连接。</p><p><strong>电子邮件系统协议 SMTP/POP3/IMAP</strong></p><p>一个电子邮件系统有三个主要组成构件，即用户代理、邮件服务器、以及邮件协议。</p><p>从用户代理把邮件传送到邮件服务器，以及在邮件服务器之间的传送都要使用 SMTP，但用户代理从邮件服务器读取邮件时则要使用 POP3 或 IMAP 协议。</p><p>基于万维网的电子邮件使用户可以利用浏览器收发电子邮件，用户浏览器和邮件服务器之间使用 HTTP 协议，而邮件服务器之间的传送仍然使用 SMTP 协议。</p><p><strong>DHCP (Dynamic Host Configuration Protocol) 动态主机配置协议</strong></p><p>提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><ol><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li></ol><p><strong>子网掩码的作用</strong></p><p>子网掩码的作用: </p><p>1、用于将一个大的IP网络划分为若干小的子网络：</p><p>因为随着互联网的发展，越来越多的网络产生，有的网络多则几百台，有的只有区区几台，这样就浪费了很多IP地址，所以要划分子网。使用子网可以提高网络应用的效率。</p><p>2、用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上：</p><hr><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>运输层的任务就是<strong>负责向两台主机中进程之间的通信提供通用的数据传输服务</strong>，应用进程利用该服务来传送应用层报文。由于一台主机同时可以运行多个进程，因此运输层具有复用和分用的功能，复用就是多个应用层进程可以同时使用下面运输层的服务，分用就是把运输层收到的信息分别交付给上面应用层中的对应进程。</p><p>运输层主要使用两种协议：① 用户数据报协议 UDP，这是一种提供无连接的、尽最大努力交付的数据传输服务，不保证数据传输的可靠性，数据传输单位是用户数据报。② 传输控制协议 TCP，这是一种面向连接的、可靠的数据传输服务，数据传输单元是报文。</p><hr><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层负责<strong>为分组交换网上的不同主机提供通信服务</strong>，在发生数据时，网络层把数据层产生的报文或用户数据报封装成<strong>分组</strong>进行传送，由于网络层使用 IP 协议，因此分组也叫 <strong>IP 数据报</strong>。网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。</p><p>网络层的协议包括了网际协议 IP、地址解析协议 ARP、网际控制报文协议 ICMP 以及路由选择协议 RIP/OSPF/BGP-4 等。</p><p><strong>网际协议 IP</strong></p><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，一般指的是 IPv4。与 IP 协议配套使用的协议还有 ARP、ICMP 和 IGMP，IP 使用 ARP，ICMP 和 IGMP 要使用 IP。由于网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP/IP 体系中的网络层也称网际层或 IP 层。要解决 IP 地址耗尽的问题，根本方法是采用具有更大地址空间的新版本 IP 协议即 IPv6，向 IPv6 过渡可以使用双协议栈或使用隧道技术。</p><p><strong>地址解析协议 ARP</strong></p><p>由于 IP 协议使用了 ARP 协议，因此把 ARP 协议归到网络层，但 ARP 的作用是通过一个 ARP 高速缓存存储本地局域网的各主机和路由器的 IP 地址到硬件地址的映射表，以从网络层的 IP 地址解析出在数据链路层使用的硬件地址，因此也可以把 ARP 划归在数据链路层。与 ARP 对应的协议是 RARP，逆地址解析协议，作用是使只知道自己硬件地址的主机能够找出 IP 地址，但被 DHCP 协议取代。</p><p><strong>路由选择协议 RIP/OSPF/BGP-4</strong></p><p>路由选择协议有两大类：内部网关协议，如 RIP 和 OSPF；外部网关协议，如 BGP-4。</p><p>RIP 是分布式的基于距离向量的路由选择协议，只适用于小型互联网。RIP 按照固定的时间间隔与相邻路由器交换信息，交换的信息是当前路由表。OSPF 是分布式的链路状态协议，适用于大型互联网，只在链路状态发生变化时才向本自治系统中的所有路由器用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。</p><p>BGP-4 是不同自治系统的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。其目标是寻找一条能够到达目的网络且比较好的路由而不是最佳路由。</p><p><strong>网际控制报文协议 ICMP</strong></p><p>ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去，<strong>使用 ICMP 并非为了实现可靠传输</strong>，ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p><p>ICMP 的一个重要应用就是分组间探测 PING，用来测试两台主机之间的连通性，PING 使用了 ICMP 回送请求与回送回答报文。</p><p><strong>Ping</strong></p><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。应答数据包的类型字段为 0，构建新的ICMP数据包，发回给主机A，此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p><strong>Traceroute</strong><br>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文</p><ul><li><p>Traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。将TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了。如果中间的路由器不止一个，当然碰到第一个就“牺牲”。于是，返回一个 ICMP 包，也就是网络差错包，类型是时间超时。接下来，将 TTL 设置为2.。。这样，Traceroute 就拿到了所有的路由器 IP。怎么知道 UDP 有没有到达目的主机呢？Traceroute 程序会发送一份 UDP 数据报给目的主机，但它会选择一个不可能的值作为 UDP 端口号（大于 30000）。当该数据报到达时，将使目的主机的 UDP 模块产生一份“端口不可达”错误 ICMP 报文。如果数据报没有到达，则可能是超时</p></li><li><p>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。要做的工作首先是发送分组，并设置“不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包.</p></li></ul><p><strong>网际组管理协议 IGMP</strong></p><p>IP 多播使用 IGMP 协议，IGMP 并非在互联网范围内对所有多播组成员进行管理，它不知道 IP 多播组包含的成员个数也不知道这些成员都分布在哪些网络上。</p><p>IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机上的某个进程参加或推出了某个多播组。</p><hr><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>数据链路层的任务是<strong>将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻结点之间的链路上传输帧，每一帧包括数据和必要的控制信息（同步信息、地址信息、差错控制等）。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始到哪个比特结束，这样链路层就可以从帧中提取出数据部分上交给网络层。控制信息还使接收端能够检测到所收到的帧有无差错，如果有差错就简单地丢弃这个帧以免继续传送而浪费网络资源。</p><p>数据链路层的协议包括了点对点协议 PPP 和 CSMA/CD 协议等。</p><p><strong>点对点协议 PPP</strong></p><p>在通信线路质量较差的年代，使用高级数据链路控制 HDLC 作为实现可靠传输的数据链路层协议，但现在 HDLC 已经很少使用了，对于点对点的链路，简单得多的点对点协议 PPP 是目前使用得最广泛的数据链路层协议。PPP 协议的特点是简单、只检测差错而不纠正差错、不使用序号也不进行流量控制、可同时支持多种网络层协议。</p><p><strong>CSMA/CD 协议</strong></p><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><p>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</p></li><li><p>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</p></li><li><p>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</p></li></ul><p>记端到端的传播时延为 t，最先发送的站点最多经过 2t就可以知道是否发生了碰撞，称 2t 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2^k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><hr><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层的任务是尽可能地<strong>屏蔽掉传输媒体和通信手段的差异</strong>，使物理层上面的数据链路层感觉不到这些差异，使其只需考虑本层的协议和服务。</p><p>物理层所传输的数据单位是比特，发送方发送 1 或 0，接收方也接收 1 或 0，因此物理层需要考虑用多大的电压代表 1 或 0，以及接收方如何识别出发送方所发送的比特。除此之外，物理层还要确定连接电缆的插头应当有多少根引以及各引脚如何连接等问题。</p><hr><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题</p><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>建立及管理会话。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP-特点"><a href="#TCP-特点" class="headerlink" title="TCP 特点"></a>TCP 特点</h3><p><strong>TCP 是面向连接的运输层协议</strong>，一个应用进程在向另一个进程发送数据之前，两个进程必须先建立 TCP 连接，发送某些预备报文段，建立确保数据传输的参数。作为 TCP 连接建立的一部分，连接双方都将初始化与 TCP 连接相关的许多状态变量。这种连接不是电路交换网络中的端到端电路这种物理连接，而是一种逻辑连接，TCP 报文要先传送到 IP 层加上 IP 首部后，再传到数据链路层，加上链路层的首部和尾部后才离开主机发送到物理层。</p><p><strong>TCP 连接提供全双工服务</strong>，允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都有各自的发送缓存和接收缓存，用来临时存放通信数据。在发送时，应用程序把数据传送给 TCP 缓存后就可以做自己的事，而 TCP 在合适的时候会把数据发送出去。在接收时，TCP 把收到的数据放入缓存，上层应用程序会在合适的时候读取缓存数据。</p><p><strong>TCP 连接是点对点的</strong>，每一条 TCP 连接只能有两个端点，即只能是单个发送方和单个接收方之间的连接。</p><p><strong>TCP 提供可靠的交付服务</strong>，通过 TCP 连接传送的数据无差错、不丢失、不重复，按序到达。</p><p><strong>TCP 是面向字节流的</strong>，流是指流入到进程或从进程中流出的字节序列。面向字节流的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但是 TCP 把应用程序交下来的数据仅仅看成一连串无结构的字节流。TCP 不保证接收方应用程序收到的数据块和发送方应用程序发出的数据块具有对应大小的关系，但是接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。接收方应用程序必须有能力识别收到的字节流，并把它还原成有意义的应用层数据。</p><hr><h3 id="TCP-报文结构"><a href="#TCP-报文结构" class="headerlink" title="TCP 报文结构"></a>TCP 报文结构</h3><p><img src="https://uploadfiles.nowcoder.com/files/20200810/176673786_1597021487780_27194088468_4cb0141fc8_b.jpg" alt="img"></p><p>TCP 传送的数据单元是报文段，一个 TCP 报文段分为首部和数据两部分。首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项，因此 TCP 首部的最小长度是 20 字节.TCP 首部的重要字段如下：</p><p><strong>源端口和目的端口：</strong>各占 2 字节，分别写入源端口号和目的端口号，TCP 的分用功能是通过端口实现的，分用就是指运输层从 IP 层收到发送给各应用进程的数据后，把数据交付给正确的套接字的工作。</p><p><strong>序号：</strong>占 4 字节。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号，首部中的序号字段值指的是本报文段所发送的数据的第一个字节的序号。序号使用 mod2^32^ 计算，每增加到 2^31^-1 后下一个序号就又回到 0。</p><p><strong>确认号：</strong>占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，代表到序号 N-1 为止的所有数据已经正确收到。序号有 32 位长，一般情况下可以保证当序号重复使用时，旧序号的数据早已通过网络到达终点了。</p><p><strong>数据偏移：</strong>占 4 字节，实际是TCP 报文段的首部长度，指出了 TCP 报文段的数据起始处到 TCP 报文段的起始处的距离。由于首部中有长度不确定的选项字段，因此数据偏移字段是必要的。</p><p><strong>标志字段：</strong>占 6 位。URG 是紧急标志，URG=1 时告诉系统此报文段中有紧急数据，应尽快传送，而不按照原来的排队顺序传送，和紧急指针配合使用，紧急指针指出了本报文段中紧急数据的字节数和位置。ACK 是确认标志，ACK=1 时表示成功接收了报文段。SYN 是同步标志，在建立连接时用来同步序号，当 SYN=1 而 ACK=0 时，表示一个连接请求报文段，响应时 SYN 和 ACK 都为 1，因此 SYN=1 表示一个连接请求或连接响应报文。FIN 是终止标志，用来释放一个连接，当 FIN=1 时表示报文段发送方的数据已发送完毕，并要求释放连接。PSH 是推送标志，PSH=1 时接收方就不等待整个缓存填满了再向上交付而是尽快交付数据。RST 是复位标志，当 RST=1 时表示 TCP 连接出现了严重错误，必须释放连接再重新建立连接。</p><p><strong>接收窗口：</strong>占 2 字节，指的是发送本报文段一方的接收窗口，告诉对方从本报文首部的确认号算起允许对方发送的数据量。窗口值是用来限制发送方的发送窗口的，因为接收方的数据缓存空间是有限的。</p><p><strong>检验和：</strong>占 2 字节，检验范围包括首部和数据两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p><hr><h3 id="可靠传输协议-ARQ"><a href="#可靠传输协议-ARQ" class="headerlink" title="可靠传输协议 ARQ"></a>可靠传输协议 ARQ</h3><p>自动重传请求 ARQ 包括了停止等待协议、回退 N 步协议和选择重传协议，后两种结合了窗口机制，属于连续 ARQ 协议。</p><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>停止等待就是每发送完一个分组就停止发送，等待对方的确认，在收到确认之后再发送下一个分组。停止等待协议包括了三种情况：</p><p><strong>1. 无差错情况</strong></p><p>A 发送分组 M<del>1</del>，发送完后就暂停并等待 B 的确认。B 收到了 M<del>1</del> 之后就向 A 发送确认，当 A 收到确认之后就再发送下一个分组 M<del>2</del>。</p><p><strong>2. 出现差错的情况</strong></p><p>当 B 收到 M<del>1</del> 时检测出了差错就丢弃了 M<del>1</del>，其他什么也不做，也可能是 M<del>1</del> 在传输过程中丢失了，B 什么都不知道。在这两种情况下 B 都不会发送任何确认信息，解决方法是：A 只要超过一段时间没有收到确认就认为刚才发送的分组丢失了，因而重传前面发过的分组，这就叫<strong>超时重传</strong>。要实现超时重传，就要在每发送完一个分组时设置一个<strong>超时计时器</strong>，如果在超时计时器到期之间收到了对方的确认就进行撤销。</p><p>有三点需要注意：① A 在发送完一个分组后必须暂时保留已发送分组的副本在超时重传时使用，只有在收到确认后才清除副本。② 分组和确认分组都必须进行编号，这样才能明确是哪一个发送出去的分组进行了确认。③ 超时计时器设置的时间应当比数据在分组传输的平均往返时间稍长一些，如果设置过短会产生不必要的重传，如果设置过长会降低通信效率。</p><p><strong>3. 确认丢失和确认迟到</strong></p><p>B 发送的对 M<del>1</del> 的确认丢失了，A 在设定的超时重传时间内没有收到确认，并不知道是自己发送的问题还是 B 的问题，因此 A 就会超时重传。假设 B 又收到了重传分组 M<del>1</del>，此时 B 会采取两个行动：① 丢弃这个分组，不向上层交付。② 重新向 A 发送确认。</p><p>还有另一种情况就是 B 发送的确认并没有丢失但是迟到了，A 会受到重复的确认，此时 A 会收下并丢弃。通常 A 最终总是可以收到对所有发出的分组的确认，如果 A 不断重传分组但总是收不到确认，就说明通信线路质量太差，不能进行通信。</p><p>停止等待协议的优点是简单，但缺点是信道利用率太低。为了提高传输效率，发送方可以不使用停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发送完一个分组就停下来等待对方的确认。这样可以使信道上一直有数据不间断地传送，流水线传输中可能会遇到差错，解决差错的两种基本方法是回退 N 步和选择重传。</p><hr><h4 id="回退-N-步协议"><a href="#回退-N-步协议" class="headerlink" title="回退 N 步协议"></a>回退 N 步协议</h4><p>在回退 N 步即 GBN 协议中，允许发送方发送多个分组而不需要等待确认。在 GBN 中发送方看到的序号可以分为四个范围，已经发送且被确认的的序号、已经发送还未确认的序号、允许发送但还未发送的序号和不允许发送的序号。其中已经发送但还未确认的序号和允许发送但还未发送的序号可以被看作一个长度为 N 的窗口，随着协议的运行该窗口在序号空间向前滑动，因此 GBN 协议也被称为滑动窗口协议。</p><p>GBN 发送方必须响应三种类型的事件：</p><ul><li><p><strong>上层的调用</strong></p><p>当上层调用发送方法时，发送方首先检查发送窗口是否已满，即是否有 N 个已发送但未确认的分组。如果窗口未满，则产生一个分组并将其发送并更新相应变量，如果窗口已满，发送方指需将数据返回给上层，隐式说明该窗口已满。实际实现中，发送方更可能缓存而不是立即发送这些数据，或者使用同步机制允许上层在仅当窗口不满时才调用发送方法。</p></li><li><p><strong>收到一个 ACK</strong></p><p>在 GBN 协议中，对序号为 n 的分组确认采用累积确认的方式，对按序到达的最后一个分组发送确认，表明接收方已经正确接收到序号为 n 的以前且包括 n 在内的所有分组。例如发送了序号为 1~5 的五个分组，除了第三个全部收到了，那么确认序号就是 2。</p></li><li><p><strong>超时事件</strong></p><p>回退 N 步的名字来源于出现丢失和时延过长时发送方的行为，就像在停止等待协议中那样，如果超时，发送方会重传所有已经发送但还未确认过的分组。如果收到一个 ACK，但仍有已发送但未确认的分组，则计时器也会重新启动。</p></li></ul><p>在 GBN 协议中，接收方丢弃所有失序分组，即使是正确接收的也要丢弃，这样做的理由是接收方必须按序将数据交付给上层。这种做法的优点是接收缓存简单，即接收方不需要缓存任何失序分组。不过丢弃一个正确失序分组的缺点是随后对该分组的重传也许也会错误，而导致更多的重传。</p><hr><h4 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h4><p>GBN 协议潜在地允许用多个分组填充流水线，因此避免了停止等待协议中的信道利用问题，但是 GBN 本身也存在性能问题，单个分组的差错就能引起 GBN 重传大量分组，许多分组根本没有重传必要。随着信道差错率的增加，流水线会被不必要重传的分组所充斥。</p><p>选择重传即 SR 协议，通过让发送方仅重传那些它怀疑在接收方出错的分组而避免不必要的重传。这种个别的、按需重传，要求接收方逐个确认正确接收的分组，再次用窗口长度 N 来限制流水线中未完成和未被确认的分组数。与 GBN 不同的是，发送方已经收到了窗口中对某些分组的 ACK。</p><p>接收方将确认一个正确接收的分组，不管是否按序。失序分组将被缓存直到所有丢失分组都收到，这时才可以将一批分组按序交付上层。</p><hr><h3 id="TCP-可靠原理"><a href="#TCP-可靠原理" class="headerlink" title="TCP 可靠原理"></a>TCP 可靠原理</h3><p>TCP 的可靠传输包含很多机制，例如使用<strong>检验和</strong>来检测一个传输分组中的比特错误、使用<strong>定时器</strong>来用于超时重传一个分组、使用<strong>序号</strong>来检测丢失的分组和冗余副本、使用<strong>确认</strong>来告诉发送方确认的分组信息、使用<strong>否定确认</strong>来告诉发送方某个分组未被正确接收。</p><p>TCP 的发送方仅需维持已发送过但未被确认的字节的最小序号和下一个要发送的字节的序号，从这种角度看 TCP 更像一个 GBN 协议。但是 TCP 和 GBN 有一些显著的区别，许多 TCP 实现会将正确接收但失序的报文段缓存起来。当分组 n 丢失时，GBN 会重传 n 之后的所有分组，但是 TCP 至多只会重传分组 n。对 TCP 提出的一种修改意见是选择确认，它允许 TCP 接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段，从这个角度看 TCP 又像 SR 协议。<strong>因此 TCP 的差错恢复机制是一种 GBN 和 SR  的结合体</strong>。</p><p>除此之外，TCP 还使用<strong>流量控制</strong>和<strong>拥塞控制</strong>来保证可靠性。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>滑动窗口以字节为单位。发送端有一个发送窗口，窗口中的序号是允许发送的序号，窗口的后沿是已经发送并且确认的序号，窗口的前沿是不允许发送的序号。窗口的后沿可能不动（代表没有收到新的确认），也有可能前移（代表收到了新的确认），但是不会后移（不可能撤销已经确认的数据）。窗口的前沿一般是向前的，也有可能不动（表示没有收到新的请求或对方的接收窗口变小），也有可能收缩，但 TCP 强烈不建议这么做，因为发送端在收到通知前可能已经发送了很多数据，此时如果收缩窗口可能会产生错误。</p><p>滑动窗口的状态需要3个指针p1，p2 和 p3。p1 之前的序号表示已经发送并且确认的序号，p1<del>p2 的序号表示已经发送但还没有确认的序号，p2</del>p3 表示允许发送的序号，也叫可用窗口，p1~p3 表示发送窗口，p3 之后的序号表示不可发送的序号。</p><p>发送缓存用来暂时存放发送应用程序传给发送方 TCP 准备发送的数据和已经发送但还没确认的数据。接收缓存用来暂时存放按序到达的但尚未被应用程序读取的数据以及未按序到达的数据。</p><p>注意三点：① 发送窗口根据接收窗口设置，但并不总是一样大，还要根据网络的拥塞情况调整。② 对于不按序到达的数据，TCP 通常存放在接收窗口，等到字节流缺少的字节收到后再按序交付上层应用程序。③ 接收方必须有累积确认功能，可以减小传输开销，可以在合适的时候发送确认，也可以在自己有数据需要发送时捎带确认。但是接收方不能过分推迟发送确认，不能超过0.5秒。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>如果某个应用程序读取数据的速度较慢，而发送方发送得太多、太快，发送的数据就会很容易使连接的接收缓存溢出，TCP 为它的应用程序提供了流量控制以消除发送方使接收方缓存溢出的可能性。流量控制是一个速度匹配服务，即发送方的发送速率与接收方的应用程序读取速率相匹配。</p><p>TCP 通过让<strong>发送方维护一个接收窗口的变量</strong>来提供流量控制。通俗地说，接收窗口用于给发送方一个指示，该接收方还有多少可用的缓存空间，因此方法方的发送窗口不能超过接收方给出的接收窗口的数值。因为 TCP 是全双工通信，在连接两端的发送方都各自维护一个接收窗口。</p><p>当接收窗口 rwnd 减小到 0 时，就不再允许发送方发送数据了。但是可能存在一种情况，当发生了零窗口报文段不久后，发送方的接收缓存又有了一些存储空间，因此又发生了新的报文说明自己的接收窗口大小，但是这个报文可能会在传输过程中丢失。接收方就会一直等待发送方的非零窗口通知，而发送方也一直在等待接收方发送数组，形成一种死锁的状态。为了解决这个问题，TCP 为每一个连接设有一个持续计时器，只要 TCP 连接的一方收到对方的零窗口通知就启动该计时器，到期后发送一个零窗口探测报文，如果仍为 0 就重新设置计时器的时间，如果对方给出了新的窗口值就可以解决可能出现的死锁问题。</p><p>还有一种问题叫做<strong>糊涂窗口综合症</strong>，当接收方处理接收缓冲区数据很慢时，就会使应用进程间传送的有效数据很小， 极端情况下有效数据可能只有 1 字节但传输开销却有 40 字节（20字节的 IP 头以及 20 字节的 TCP 头) ，导致网络效率极低。为了解决这个问题，可以让接收方等待一段时间，使得接收缓存有足够的空间容纳一个最长报文段或者等到接收缓存已有一半的空闲空间。发送方也不要发送太小的报文，而是把数据积累成足够大的报文或达到接收方缓存空间的一半时才发送。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>网络中对资源需求超过了资源可用量的情况就叫做拥塞。当吞吐量明显小于理想的吞吐量时就出现了轻度拥塞，当吞吐量随着负载的增加反而下降时，网络就进入了拥塞状态。当吞吐量降为 0 时，网络已无法正常工作并陷入死锁状态。拥塞控制就是尽量减少注入网络的数据，减轻网络中的路由器和链路的负担。<strong>拥塞控制是一个全局性的问题，它涉及网络中的所有路由器和主机，而流量控制只是一个端到端的问题，是两个端点之间通信量的控制。</strong></p><p>根据网络层是否为运输层拥塞控制提供显式帮助可以将拥塞控制的方法区分为两种：端到端拥塞控制和网络辅助的拥塞控制。TCP 使用端到端的拥塞控制，因为 IP 层不会向端系统提供显式的网络拥塞反馈。TCP 所采取的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其向连接发送数据的速率。如果一个 TCP 发送方感知到它到目的地之间的路径上没什么拥塞则会增加发送速率，如果发送方感知到拥塞就会降低其发送速率。限制发送速率是通过拥塞窗口来实现的，它对发送方能向网络中发送流量的速率进行了限制。判断拥塞是通过超时或者连续接收到 3 个冗余 ACK 实现的。</p><p>TCP 的拥塞控制算法主要包括了慢启动、拥塞避免和快恢复。慢启动和拥塞避免是 TCP 的强制部分，差异在于对收到的 ACK 做出反应时 cwnd 增加的方式，慢启动比拥塞避免要更快地增加 cwnd 的长度。快恢复是推荐部分，对 TCP 发送方不是必需的。</p><p><strong>1. 慢启动</strong></p><p>在慢启动状态，拥塞窗口 cwnd 的值以一个 MSS 最大报文段开始并且每当传输的报文段首次被确认就增加一个 MSS。因此每经过一个 RTT 往返时间，拥塞窗口就会翻倍，发送速率也会翻倍。因此 TCP 的发送速率起始很慢，但是在慢启动阶段以指数增长。</p><p>结束慢启动有三种情况：① 如果存在一个超时指示的丢包事件，即发生了拥塞，TCP 发送方就会将 cwnd 设置为 1 并重新开始慢启动过程。它还将慢启动阈值设置为 cwnd/2，即检测到拥塞时将慢启动阈值设置为拥塞窗口的一半。② 当拥塞窗口达到慢启动阈值时就会结束慢启动而进入拥塞避免模式。③ 最后一种结束慢启动的方式是，如果检测到三个冗余的 ACK，TCP 就会执行快重传并进入快恢复状态。</p><p><strong>2. 拥塞避免</strong></p><p>一旦进入拥塞避免状态，cwnd 的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远。因此 TCP 无法再每经过一个 RTT 就将 cwnd 的值翻倍，而是采用一种较为保守的方法，每个 RTT 后只将 cwnd 的值增加一个 MSS。这能够以几种方式完成，一种通用的方法是发送方无论何时收到一个新的确认，都将 cwnd 增加一个 MSS。</p><p>当出现超时时，TCP 的拥塞避免和慢启动一样，cwnd 的值将被设置为 1，并且将慢启动阈值设置为 cwnd 的一半。</p><p><strong>3. 快恢复</strong></p><p>有时候个报文段丢失，而网络中并没有出现拥塞，如果使用慢启动算法就会降低传输效率。这时应该使用快重传来让发送方尽早知道出现了个别分组的丢失，快重传要求接收端不要等待自己发送数据时再捎带确认，而是要立即发送确认。即使收到了乱序的报文段后也要立即发出对已收到报文段的重复确认。当发送方连续收到三个冗余 ACK 后就知道出现了报文段丢失的情况，会立即重传并进入快恢复状态。</p><p>在快恢复中，会调整慢启动阈值为 cwnd 的一半，并进入拥塞避免状态。</p><hr><h3 id="TCP-连接和释放机制"><a href="#TCP-连接和释放机制" class="headerlink" title="TCP 连接和释放机制"></a>TCP 连接和释放机制</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>TCP 是全双工通信，任何一方都可以发起建立连接的请求，假设 A 是客户端，B 是服务器。</p><p>初始 A 和 B 均处于 CLOSED 状态，B 会创建传输进程控制块 TCB 并进入 LISTEND 状态，监听端口是否收到了 TCP 请求以便及时响应。</p><p>当 A 要发生数据时就向 B 发送一个连接请求报文，TCP 规定连接请求报文的 SYN=1，ACK=0，SYN 不可以携带数据，但要消耗一个序号，假设此时 A 发送的序号 seq 为 x。发送完之后 A 就进入了 SYN-SENT 同步已发送状态。</p><p>当 B 收到 A 的连接请求报文后，如果同意建立连接就会发送给 A 一个确认连接请求报文，其中 SYN=1，ACK=1，ack=x+1，seq=y，ack 的值为 A 发送的序号加 1，ACK 可以携带数据，如果不携带的话则不消耗序号。发送完之后，B进入 SYN-RCVD 同步已接收状态。</p><p>当 A 收到 B 的确认连接请求报文后，还要对该确认再进行一次确认，报文的 ACK=1，ack=y+1，seq=x+1，发送后 A 进入 ESTABLISHED 状态，当 B 接收到该报文后也进入 ESTABLISHED 状态，客户端会稍早于服务器端建立连接。</p><p><strong>三次握手的原因主要有两个目的，信息对等和防止超时。</strong></p><p>从信息对等的角度看，双方只有确定 4 类信息才能建立连接，即 A 和 B 分别确认自己和对方的发送和接收能力正常。在第二次握手后，从 B 的角度看还不能确定自己的发送能力和对方的接收能力，只有在第三次握手后才能确认。</p><p>三次握手也是防止失效连接突然到达导致脏连接，网络报文的生存时间往往会超过 TCP 请求超时时间，A 的某个超时连接请求可能会在双方释放连接之后到达 B，B 会误以为是 A 创建了新的连接请求，然后发送确认报文创建连接。因为 A 机器的状态不是 SYN_SENT，所以直接丢弃了 B 的确认数据。如果是两次握手，连接已经建立了，服务器资源被白白浪费。如果是三次握手，B 由于长时间没有收到确认信息，最终超时导致创建连接失败，因此不会出现脏连接。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当 A 已经没有要发送的数据时就会释放连接，会向 B 发送一个终止连接报文，其中 FIN=1，seq=u，u 的值为之前 A 发送的最后一个序号+1。发送完之后进入 FIN-WAIT-1 状态。</p><p>B 收到该报文后，发送给 A 一个确认报文，ACK=1，ack=u+1，seq=v，v 的值为 B 之前发送的最后一个序号+1。此时 A 进入了FIN-WAIT-2 状态，B 进入了 CLOSE-WAIT 状态，但连接并未完全释放，B 会通知高层的应用层结束 A 到 B 方向的连接，此时 TCP 处于半关闭状态。</p><p>当 B 发送完数据后准备释放连接时，就向 A 发送连接终止报文，FIN=1，同时还要重发ACK=1，ack=u+1，seq=w，seq 不是 v 的原因是在半关闭状态 B 可能又发送了一些数据，之后 B 进入 LAST-ACK 状态。</p><p>A 收到连接终止报文后还要再进行一次确认，确认报文中 ACK=1，ack=w+1，seq=u+1。发送完之后进入 TIME-WAIT 状态，等待 2MSL之后进入 CLOSED 状态，B 收到该确认后进入 CLOSED 状态，服务器端会稍早于客户端释放连接。</p><p><strong>四次挥手的原因</strong></p><p>tcp是全双工通信，服务端和客服端都能发送和接收数据。</p><p>tcp在断开连接时，需要服务端和客服端都确定对方将不再发送数据。</p><p><strong>第1次挥手</strong></p><p>由客户端向服务端发起，服务端收到信息后就能确定客户端已经停止发送数据。</p><p><strong>第2次挥手</strong></p><p>由服务端向客户端发起，客户端收到消息后就能确定服务端已经知道客户端不会再发送数据。</p><p><strong>第3次握手</strong></p><p>由服务端向客户端发起，客户端收到消息后就能确定服务端已经停止发送数据。</p><p><strong>第4次挥手</strong></p><p>由客户端向服务端发起，服务端收到信息后就能确定客户端已经知道服务端不会再发送数据。</p><p><strong>为什么不是3次挥手</strong></p><p>在客服端第1次挥手时，服务端可能还在发送数据。</p><p>所以第2次挥手和第3次挥手不能合并。</p><p><strong>大量 TIME-WAIT 的原因、导致的问题、处理</strong></p><p>在高并发短连接的 TCP 服务器上，服务器处理完请求后立刻主动正常关闭连接，这个场景下会出现大量 socket 处于 TIME-WAIT 状态。</p><p>TIME-WAIT 状态无法真正释放句柄资源，socket 使用的本地端口在默认情况下不能再被使用，会限制有效连接数量，成为性能瓶颈。</p><p>可以调小 tcp_fin_timeout 的值，将 tcp_tw_reuse 设为 1 开启重用，将 tcp_tw_recycle 设为 1 表示开启快速回收。</p><hr><h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><p>TCP 是面向连接的，而 UDP 是无连接的，发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。</p><p>TCP 保证数据的可靠传输，UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态。</p><p>TCP 是面向字节流的，UDP 是面向报文的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文既不拆分也不合并，而是保留这些报文的边界。如果报文太长，IP 层在传送时可能需要分片，如果报文太短，会使 IP 数据报首部的相对长度太大，都会降低 IP 层的效率。</p><p>TCP 有拥塞控制，UDP 没有拥塞控制，因此网络中出现的拥塞不会降低源主机的发送速率。这对某些实时应用很重要，很多实时应用如 IP 电话、实时视频会议等要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许网络有太大的时延，UDP 正好适合这种要求。</p><p>TCP 是点到点之间的一对一通信，UDP 支持一对一、一对多和多对多的交互通信。</p><p>UDP 的首部开销很小，只有 8 字节，相比 TCP 的 20 字节要短。</p><h3 id="TCP和UDP的传送信息单位的区别？"><a href="#TCP和UDP的传送信息单位的区别？" class="headerlink" title="TCP和UDP的传送信息单位的区别？"></a>TCP和UDP的传送信息单位的区别？</h3><p>16位源端口号+16位目的端口号+32位序号+32位确认号+4位头部长度（单位4字节）+6位保留+6个关键字（SYN,ACK，FIN）+16位窗口大小（指接收窗口）+16位校验和+16位紧急指针+最多40字节的选项；</p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。</p><h3 id="Close-wait作用"><a href="#Close-wait作用" class="headerlink" title="Close wait作用"></a>Close wait作用</h3><h3 id="TCP粘包？"><a href="#TCP粘包？" class="headerlink" title="TCP粘包？"></a>TCP粘包？</h3><p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>原因可能是发送方也可能是接收方造成的。</p><p>发送方原因：TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</p><p>接收方原因：TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。</p><h4 id="处理方法："><a href="#处理方法：" class="headerlink" title="处理方法："></a>处理方法：</h4><p> 最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：</p><ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。 </li><li>包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。 </li><li>包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。</li></ul><hr><h3 id="客户端发送的最后一个ACK因为某些原因丢失时："><a href="#客户端发送的最后一个ACK因为某些原因丢失时：" class="headerlink" title="客户端发送的最后一个ACK因为某些原因丢失时："></a>客户端发送的最后一个ACK因为某些原因丢失时：</h3><p>由于server端发送syn_ack报文后进入SYN_RCVD状态，就会启动tcp重传计时器，超时时就会重新发送syn_ack报文，总共发送 net.ipv4.tcp_synack_retries次；客户端在没有收到重传的syn_ack之前，发送数据给server端，由于server端的状态为SYN_RCVD状态，而不是ESTABLISHED状态，就会发送RST报文给client端，客户端就能接收到服务器侧未收到ack报文。</p><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p><img src="https://uploadfiles.nowcoder.com/files/20200810/176673786_1597021488550_u16143127921954581760fm26gp0.jpg" alt="img"></p><p><strong>4位版本</strong>：</p><p> 目前协议版本号是4，因此IP有时也称作IPV4.</p><p> <strong>4位首部长度</strong>：</p><p> 首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。</p><p> <strong>服务类型（TOS）</strong>：</p><p> 服务类型字段包括一个3bit的优先权字段（现在已经被忽略），4bit的TOS子字段和1bit未用位必须置0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。</p><p> <strong>总长度</strong>：</p><p> 总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16bit，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。</p><p> <strong>标识字段</strong>：</p><p> 标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</p><p> <strong>生存时间</strong>：</p><p> TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为 3 2或6 4），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0时，数据报就被丢弃，并发送 ICMP 报文通知源主机。</p><p> <strong>首部检验和</strong>：</p><p> 首部检验和字段是根据 I P首部计算的检验和码。它不对首部后面的数据进行计算。 ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP-概况"><a href="#HTTP-概况" class="headerlink" title="HTTP 概况"></a>HTTP 概况</h3><p>HTTP 即超文本传输协议，是 Web 的应用层协议。HTTP 由两个程序实现，一个客户程序和一个服务器程序，客户程序和服务器程序运行在不同的端系统中，通过交换 HTTP 报文进行会话。HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式，当用户请求一个 Web 页面时，浏览器向服务器发出对该页面中所包含对象的 HTTP 请求报文，服务器接收到请求并用包含这些对象的 HTTP 响应报文进行响应。</p><p><strong>HTTP 使用 TCP 作为它的支撑运输协议</strong>，HTTP 客户首先发起一个与服务器的 TCP 连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字访问 TCP。客户端的套接字接口是客户进程与 TCP 连接之间的门，服务器端的套接字接口则是服务器进程与 TCP 连接之间的门。客户向它的套接字接口发送 HTTP 请求报文并从它的套接字接口接收 HTTP 响应报文，类似的，服务器从它的套接字接口接收 HTTP 请求报文并向它的套接字接口发送 HTTP 响应报文。一旦客户向它的套接字接口发送一个 HTTP 请求报文，该报文就脱离了客户控制并进入 TCP 的控制，TCP 为 HTTP 提供可靠的数据传输服务，因此一个客户进程发出的每个 HTTP 请求报文最终都能完整地到达服务器，服务器进程发出地每个 HTTP 响应报文最终也可以完整地到达客户。这里体现了分层体系结构的优点，HTTP 协议不需要担心数据丢失，也不需要关注 TCP 从网络的数据丢失和乱序中如何恢复。</p><p><strong>HTTP 是一种无状态的协议</strong>，服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。假如某个客户在短时间内连续两次请求同一个对象，服务器并不会因为刚刚为该客户做出了响应就不再响应，而是重新进行响应。</p><hr><h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><p>依据每个请求/响应对经过一个单独的 TCP 连接还是相同的 TCP 连接发送，可以将连接划分为非持续连接和持续连接。HTTP 默认使用持续连接，但是也可以配置成使用非持续连接。</p><p><strong>非持续连接</strong></p><p>使用非持续连接时，从服务器向客户传送一个包含了一个 HTML 文件和 10  个 JPG 对象的 Web 页面步骤：</p><p>① HTTP 客户进程在端口号 80 发起一个到服务器的 TCP 连接，并经它的套接字向服务器发送一个 HTTP 请求报文。② HTTP 服务器进程经它的套接字接收请求报文，从其存储器中检索出请求对象，在一个 HTTP 响应报文中封装对象，并通过套接字向客户发送响应报文。③ HTTP 服务器进程通知 TCP 断开该 TCP 连接，直到 TCP 确认客户已经完整接收到响应报文才会实际断开连接。④ HTTP 客户接收到响应报文，客户从报文中提取出 HTML 文件，得到多个 JPG 图像的引用，并对每个引用的 JPG 图像对象重复前三个步骤。</p><p>每个 TCP 连接会在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。每个 TCP 连接只传输一个请求报文和一个响应报文，假如请求一个 HTML 文件和其中包括的 10 个 JPG 图像就要产生 11 个 TCP 连接。</p><p>在非持续连接中，每次请求文件到接收响应大约需要花费两个 RTT 加上服务器传输文件的时间，RTT 就是往返时间，指一个短分组从客户到服务器然后再返回客户所发送的时间。其中三次握手的前两个部分占用一个 RTT，三次握手的第三个确认部分向服务器发送了请求报文，服务器接收到之后做出响应，这用去了另一个 RTT。</p><p><strong>持续连接</strong></p><p>非持续连接有很多缺点。第一，必须为每个请求的对象建立和维护一个新的连接，对于每个连接，在客户和服务器中都要分配 TCP 的缓冲区和保持 TCP 变量，这给 Web 服务器带来了很大负担。第二，每一个对象需要消耗两倍的 RTT，一个用于创建 TCP，一个用于请求和接收对象。</p><p>在 HTTP1.1 中使用了持续连接，服务器在发送响应后保持该 TCP 连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。在使用持续连接的情况下，请求一个完整的 Web 页面可以使用单个持续的 TCP 连接，例如之前所说的包含一个 HTML 文件和 10  个 JPG 对象的 Web 页面就只需要一个 TCP 连接而不是 11 个。</p><hr><h3 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h3><p>HTTP 报文有两种，分为请求报文和响应报文。</p><p><strong>请求报文</strong></p><p>HTTP 请求报文的第一行叫做请求行，其后继的行叫做首部行。请求行有三个字段，包括方法、URL 和 HTTP 版本。方法包括了 GET、POST、HEAD、PUT 和 DELETE 等。绝大部分的 HTTP 请求报文使用 GET 方法，当使用 GET 方法时，在 URL 字段中会带有请求对象的标识。</p><p>首部行指明了对象所在的主机，其实已经存在 TCP 连接了，但是还需要首部行提供主机信息，这时 Web 代理高速缓存所要求的。通过包含 <code>Connection:close</code> 的首部行，可以告诉服务器不要麻烦地使用持续连接，它要求在发送完响应后就关闭连接。<code>User-agent</code> 可以用来指明用户代理，即向服务器发送请求的浏览器类型，服务器可以有效地为不同类型的用户代理发送实际相同对象的不同版本。</p><p>在首部行之后有一个空行，后面跟着的是实体。使用 GET 方法时实体为空，而使用 POST 方法时才会使用实体。当用户提交表单时，HTTP 客户通常使用 POST 方法，使用 POST 方法时用户仍可以向服务器请求一个 Web 页面，但 Web 页面的特定内容依赖于用户在表单字段中输入的内容。如果使用 POST 方法，则实体中包含的就是用户在表单字段的输入值。表单不是必须使用 POST 方法，也可以使用 GET。</p><p>HEAD 方法类似于 GET，当服务器收到一个使用 HEAD 方法的请求时，将会用一个 HTTP 报文进行响应，但是并不返回请求对象。通常开发者使用 HEAD 方法进行调试跟踪。PUT 方法常用于上传对象到指定的 Web 服务器上指定的目录，DELETE 方法允许用户或应用程序删除 Web 服务器上的对象。</p><p><strong>响应报文</strong></p><p>响应报文包括状态行、首部行和实体。状态行有三个字段，协议版本、状态码和对应的状态信息。实体是报文的主要部分，即所请求的对象本身。</p><p>服务器通过首部行来告诉浏览器一些信息。 <code>Connection:close</code> 可以告诉客户发送完报文后将关闭该 TCP 连接。<code>Date</code> 是首部行指示服务器发送响应报文的日期和时间，这个时间不是对象创建或修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文并发送的时间。<code>Server</code> 指明了服务器的类型，类似于请求报文中的 <code>User-agent</code> 。</p><p>状态码及其相应的短语指示了请求的结果，一些常见的状态码和相关短语如下：</p><table><thead><tr><th>状态码</th><th>短语</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>成功响应</td></tr><tr><td>301</td><td>Moved Permanently</td><td>请求的对象已经被永久转移了，新的 URL 定义在响应报文的 Location 首部行，客户将自动获取新的 URL。</td></tr><tr><td>302</td><td>Found</td><td>与301类似，但资源只是临时被移动，客户端应继续使用原有 URL。</td></tr><tr><td>400</td><td>Bad Request</td><td>一个通用的差错代码，标识该请求不能被服务器理解。</td></tr><tr><td>401</td><td>Unauthorized</td><td>未认证，缺乏相关权限。</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解客户端的请求，但是拒绝执行。</td></tr><tr><td>404</td><td>Not Found</td><td>被请求的文档不在服务器上，有可能因为请求 URL 出错。</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端中请求的方法被禁止，例如限制 POST 方式但使用了 GET 访问。</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求。</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求。</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求。</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>服务器不支持请求报文使用的 HTTP 协议版本。</td></tr></tbody></table><hr><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>HTTP 的无状态性简化了服务器的设计，并且提高了 Web 服务器的性能，使其可以同时处理大量的 TCP 连接。但是一个 Web 站点通常希望能够识别用户，可能是为了限制用户的访问，也可能为了把内容与用户身份关联起来，为此 HTTP 使用了 cookie，cookie 是一种客户端的会话技术，允许站点对用户进行追踪。</p><p><strong>cookie 技术有四个组件</strong></p><p>① 在 HTTP 响应报文中的一个 cookie 首部行。② 在 HTTP 请求报文中的一个 cookie 首部行。③ 在用户端系统中保留有一个 cookie 文件，并由用户的浏览器关联。④ 位于 Web 站点的一个后端数据库。cookie 的工作流程：当客户通过浏览器第一次访问某个站点时，该 Web 站点将产生一个唯一识别码，并以此作为索引在它的后端数据库中产生的一个表项。接下来服务器会用一个包含 <code>Set-cookie</code> 首部的 HTTP 响应报文对浏览器进行相应，当浏览器收到后将其添加到自己管理的 cookie 文件中，在下次访问该站点时，请求报文的首部行中就会包括这个识别码，尽管浏览器不知道客户是谁，但是可以确定是同一个客户进行了访问。</p><p><strong>cookie 和 session 的区别</strong></p><p>① cookie 只能存储 ASCII 码字符串，而 session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选session。② session 存储在服务器，而 cookie 存储在客户浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 cookie 中，可以将 cookie 值进行加密，然后在服务器进行解密。</p><p><strong>Cookie和Session的选择？</strong></p><ol><li><p>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session；</p></li><li><p>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</p></li><li><p>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</p></li></ol><hr><h3 id="Web-缓存"><a href="#Web-缓存" class="headerlink" title="Web 缓存"></a>Web 缓存</h3><p>Web 缓存器也叫代理服务器，它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体。Web 缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象副本。可以配置用户的浏览器，使得用户所有的 HTTP 请求首先指向 Web 缓存器。客户通过 Web 缓存器请求对象的步骤如下：</p><p>① 浏览器创建一个到 Web 缓存器的 TCP 连接，并向 Web 缓存器中的对象发送一个 HTTP 请求。② Web 缓存器进行检查，查看本地是否存储了该对象副本。如果有，Web 缓存器就向客户浏览器用 HTTP 响应报文返回该对象。③ 如果 Web 缓存器中没有该对象，它就打开一个与该对象的初始服务器的 TCP 连接，Web 缓存器在这个连接上发送一个请求并接受响应。④ Web 缓存器接收到响应后，在本地存储空间存储一份副本，并向客户的浏览器用 HTTP 响应报文发送该副本。</p><p>Web 缓存器既是服务器又是客户，当它接受浏览器的请求并响应时，它是一个服务器，当他向初始服务器发出请求并接收响应时，它是一个客户。在因特网上部署 Web 缓存器有两个原因，首先，Web 缓存器可以大大减少对客户请求的响应时间，特别是客户与初始服务器之间的带宽远低于客户与 Web 缓存器之间的带宽时更是如此。其次，Web 缓存器可以大大减少一个机构的接入链路到因特网的通信量，通过减少通信量，机构就不必基于增加带宽，可以降低费用。</p><hr><h3 id="输入一个-url-发生的事"><a href="#输入一个-url-发生的事" class="headerlink" title="输入一个 url 发生的事"></a>输入一个 url 发生的事</h3><p><strong>① 分析 url</strong></p><p>判断输入的 url 是否合法，如果不合法浏览器会使用默认的搜索引擎进行搜索。如果输入的是一个域名，默认会加上一个 http 前缀。</p><p><strong>② DNS 查询</strong></p><p>检查浏览器的 DNS 缓存，检查本地 hosts 文件的缓存，如果没有会向本地 DNS 服务器发送请求。</p><p>主机向本地 DNS 服务器发起请求是递归查询，如果找到则返回，否则会向根 DNS 查询。</p><p>根 DNS 查询是迭代查询，没有域名和 ip 的对应关系，而是告知可以查询的域名服务器地址。</p><p>本地 DNS 向得到的域名服务器发出请求，收到一个域名和 ip 关系，把结果返回给用户，并把结果保存到缓存中。</p><p><strong>③ TCP 建立连接</strong></p><p>拿到 ip 地址后，通过 TCP 的三次握手建立连接，按照协议规定的格式发送 HTTP 请求报文。</p><p><strong>④ 处理请求</strong></p><p>服务器收到 HTTP 请求报文后进行响应，主进程进行监听，创建子进程处理，先判断是否是重定向，如果是重定向则返回重定向地址。如果是静态资源则直接返回，否则通过 REST URL 在代码层面处理返回结果，最后返回 HTTP 响应报文。</p><p><strong>⑤ 接收响应</strong></p><p>浏览器收到 HTTP 响应报文后进行解析，首先查看响应报文在状态行的状态码，根据不同的状态码做不同的事，解析 HTML、CSS、JS 等文件。构建 DOM 树，渲染树，重绘，将像素发送 GPU 进行渲染，最后将渲染结果返回给用户并进行缓存。</p><p><strong>⑥ TCP 断开连接</strong></p><p>通过 TCP 的四次挥手断开连接，如果是 HTTP1.1 则会将连接保持一小段时间。</p><hr><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><strong>HTTP 存在的问题</strong></p><p>HTTP 没有密码加密，无法保证通信内容不被窃听，攻击者可以截取客户发送的数据并得到他的信息。</p><p>HTTP 没有报文完整性验证，无法确保通信内容在传输过程中不被改变，攻击者可以篡改客户通信内容。</p><p>HTTP 没有身份鉴别，无法让通信双方确认对方的身份，攻击者可以伪装成客户或者服务器。</p><p><strong>加密原理</strong></p><p>HTTPS 即 HTTP over SSL，在 HTTP 传输上增加了 SSL 安全性服务。SSL 是安全套接字层，通过采用机密性、数据完整性、服务器鉴别以及客户鉴别来强化 TCP，主要用于为发生在 HTTP 之上的事务提供安全性。SSL 会对数据进行加密并把加密数据送往 TCP 套接字，在接收方，SSL 读取 TCP 套接字中的数据并解密，然后把数据交给应用层。HTTPS 采用混合加密机制，使用非对称加密传输对称密钥来保证传输过程的安全性，之后使用对称加密进行通信来保证通信过程的效率。</p><p>HTTPS 的传输过程主要分为两部分：通过 SSL 握手建立安全的 HTTPS 通道和在安全的通道上进行数据传输，SSL 握手的步骤如下：</p><p>① 客户发送它支持的密码算法列表，以及一个客户的不重数，不重数就是在一个协议的生存期只使用一次的数。</p><p>② 服务器从该列表中选择一种对称加密算法（例如 AES），一种公钥加密算法（例如 RSA）和一种报文鉴别码算法。服务器把它的选择以及证书和一个服务器不重数返回给客户。</p><p>③ 客户通过 CA 提供的公钥验证该证书，验证成功后提取服务器的公钥，生产一个前主密钥 PMS，用服务器的公钥加密该 PMS，并将加密的 PMS 发送给服务器。</p><p>④ 客户和服务器独立地从 PMS 和不重数中计算出仅用于当前 SSL 会话的主密钥 MS，然后该 MS 被切片以生成两个密码和两个报文鉴别码密钥。自从以后，客户和服务器之间发送的所有报文均被加密和鉴别（使用报文鉴别码）。</p><p>⑤ 客户和服务器分别发送所有握手报文的一个报文鉴别码。这一步是为了使握手免受篡改危害，在第一步中客户提供的算法列表是以明文形式发送的，因此可能被攻击者截获并删除较强的算法。当客户发送一个级联它以及发送和接收的所有握手报文的报文鉴别码，服务器能够比较这个报文鉴别码和它已经接受和发送的握手报文的报文鉴别码，如果不一致就终止连接。类似的，客户也可以通过服务器发送的报文鉴别码来检查一致性。</p><p>第一步和第二步中的不重复数用于防止重放攻击，每个 TCP 会话使用不同的不重复数就可以使加密密钥不同，当收到重放的 SSL 记录时，该记录无法通过完整性检查，假冒的电子事务不会成功。</p><p>当结束 SSL 会话时，需要在类型字段中指出该记录是否是用于终止 SSL 会话的。通过包含这样一个字段，如果客户或服务器在收到一个关闭 SSL 记录之前突然收到了一个 TCP FIN，就知道遭受了截断攻击。</p><hr><p>作者：Sun浅雨<br>链接：<a href="https://www.nowcoder.com/discuss/472041?type=all&amp;order=time&amp;pos=&amp;page=3&amp;channel=1009&amp;source_id=search_all" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/472041?type=all&amp;order=time&amp;pos=&amp;page=3&amp;channel=1009&amp;source_id=search_all</a><br>来源：牛客网</p><h3 id="HTTP1-0、1-1、2-0之间的区别"><a href="#HTTP1-0、1-1、2-0之间的区别" class="headerlink" title="HTTP1.0、1.1、2.0之间的区别"></a><strong>HTTP1.0、1.1、2.0之间的区别</strong></h3><p> <strong>HTTP1.0：</strong>默认使用Connection:cloose，浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个<a href>客户端</a>也不记录过去的请求（无状态）。</p><p> <strong>HTTP1.1：</strong>默认使用Connection:<a href>keep</a>-alive（长连接），避免了连接建立和释放的开销；通过Content-Length字段来判断当前请求的数据是否已经全部接受。不允许同时存在两个并行的响应。</p><p> <strong>HTTP2.0：</strong>引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以并行的传输数据。</p><h3 id="http1-0和http1-1的主要区别如下："><a href="#http1-0和http1-1的主要区别如下：" class="headerlink" title="http1.0和http1.1的主要区别如下："></a><strong>http1.0和http1.1的主要区别如下：</strong></h3><p> 1、缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match）<br>​ 2、网络连接的优化：1.1支持断点续传<br>​ 3、错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态<br>​ 4、Host头处理：支持Host头域，不在以IP为请求方标志<br>​ 5、长连接：减少了建立和关闭连接的消耗和延迟。</p><h3 id="http1-1和http2-0的主要区别："><a href="#http1-1和http2-0的主要区别：" class="headerlink" title="http1.1和http2.0的主要区别："></a><strong>http1.1和http2.0的主要区别：</strong></h3><p> 1、新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式<br>​ 2、多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成 正常的请求）<br>​ 3、header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的 hearder大小<br>​ 4、服务端推送：同<a href>google</a>的SPDUY（1.0的一种升级）一样</p><h3 id="HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？"><a href="#HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？" class="headerlink" title="HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？"></a><strong>HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密<a href>算法</a>和非对称加密<a href>算法</a>不？</strong></h3><p> <strong>HTTP与HTTPS之间的区别：</strong></p><table><thead><tr><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>默认端口80</td><td>HTTPS默认使用端口443</td></tr><tr><td>明文传输、数据未加密、安全性差</td><td>传输过程ssl加密、安全性较好</td></tr><tr><td>响应速度快、消耗资源少</td><td>响应速度较慢、消耗资源多、需要用到CA证书</td></tr></tbody></table><h3 id="HTTPS链接建立的过程："><a href="#HTTPS链接建立的过程：" class="headerlink" title="HTTPS链接建立的过程："></a><strong>HTTPS链接建立的过程：</strong></h3><p> 1.首先<a href>客户端</a>先给服务器发送一个请求</p><p> 2.服务器发送一个SSL证书给<a href>客户端</a>，内容包括：证书的发布机构、有效期、所有者、签名以及公钥</p><p> 3.<a href>客户端</a>对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密<a href>算法</a>以及对称密钥进行加密</p><p> 4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给<a href>客户端</a></p><p> 5.随后<a href>客户端</a>和服务端就使用对称密钥进行信息传输</p><p><a href="https://blog.csdn.net/qq_1290259791/article/details/85939246?ops_request_misc=%7B%22request%5Fid%22%3A%22160430345319725225016168%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=160430345319725225016168&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-85939246.pc_first_rank_v2_rank_v28&utm_term=https加密&spm=1018.2118.3001.4449" target="_blank" rel="noopener">https://blog.csdn.net/qq_1290259791/article/details/85939246?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160430345319725225016168%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160430345319725225016168&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>first_rank_v2~rank_v28-1-85939246.pc_first_rank_v2_rank_v28&amp;utm_term=https%E5%8A%A0%E5%AF%86&amp;spm=1018.2118.3001.4449</a></p><h3 id="对称加密算法："><a href="#对称加密算法：" class="headerlink" title="对称加密算法："></a><strong>对称加密<a href>算法</a>：</strong></h3><p> 双方持有相同的密钥，且加密速度快，典型对称加密<a href>算法</a>：DES、AES</p><h3 id="非对称加密算法："><a href="#非对称加密算法：" class="headerlink" title="非对称加密算法："></a><strong>非对称加密<a href>算法</a>：</strong></h3><p> 密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密<a href>算法</a>有：RSA、DSA</p><h3 id="HTTP请求有哪些。get和Post区别。"><a href="#HTTP请求有哪些。get和Post区别。" class="headerlink" title="HTTP请求有哪些。get和Post区别。"></a><strong>HTTP请求有哪些。get和Post区别。</strong></h3><p><strong>HTTP请求：</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>向特定资源发送请求，查询数据，并返回实体</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改</td></tr><tr><td>PUT</td><td>向服务器上传新的内容</td></tr><tr><td>HEAD</td><td>类似GET请求，返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>DELETE</td><td>请求服务器删除指定标识的资源</td></tr><tr><td>OPTIONS</td><td>可以用来向服务器发送请求来测试服务器的功能性</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，用于测试或诊断</td></tr><tr><td>CONNECT</td><td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table><p><strong>get和Post区别：</strong></p><table><thead><tr><th>GET</th><th>POST</th><th></th></tr></thead><tbody><tr><td>可见性</td><td>数据在URL中对所有人可见</td><td>数据不会显示在URL中</td></tr><tr><td>安全性</td><td>与post相比，get的安全性较差，因为所 发送的数据是URL的一部分</td><td>安全，因为参数不会被保存在浏览器 历史或web服务器日志中</td></tr><tr><td>数据长度</td><td>受限制，最长2kb</td><td>无限制</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>multipart/form-data</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能被缓存</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="HTTP常见响应状态码，从1xx到5xx"><a href="#HTTP常见响应状态码，从1xx到5xx" class="headerlink" title="HTTP常见响应状态码，从1xx到5xx"></a><strong>HTTP常见响应状态码，从1xx到5xx</strong></h3><p> 100：Continue — 继续。<a href>客户端</a>应继续其请求。</p><p> 200：OK — 请求成功。一般用于GET与POST请求。</p><p> 301：Moved Permanently — 永久重定向。</p><p> 302：Found — 暂时重定向。</p><p> 400：Bad Request — <a href>客户端</a>请求的语法错误，服务器无法理解。</p><p> 403：Forbideen — 服务器理解请求<a href>客户端</a>的请求，但是拒绝执行此请求。</p><p> 404：Not Found — 服务器无法根据<a href>客户端</a>的请求找到资源（网页）。</p><p> 500：Internal Server Error — 服务器内部错误，无法完成请求。</p><p> 502：Bad Gateway — 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。</p><h3 id="重定向和转发区别"><a href="#重定向和转发区别" class="headerlink" title="重定向和转发区别"></a><strong>重定向和转发区别</strong></h3><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><p><strong>转发（Forword）</strong> 通过 RequestDispatcher 对象的<code>forward（HttpServletRequest request,HttpServletResponse response）</code>方法实现的。<code>RequestDispatcher</code> 可以通过<code>HttpServletRequest</code> 的 <code>getRequestDispatcher()</code>方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;login_success.jsp&quot;).forward(request, response);</span><br></pre></td></tr></table></figure><p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletRequestResponse 的 setStatus(int status)方法设置状态码。如果服务器返回 301 或者 302，则浏览器会到新的网址重新请求该资源。</p><ol><li><strong>从地址栏显示来说</strong>：forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。redirect 是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的 URL。</li><li><strong>从数据共享来说</strong>：forward：转发页面和转发到的页面可以共享 request 里面的数据。redirect：不能共享数据。</li><li><strong>从运用地方来说</strong>：forward：一般用于用户登陆的时候，根据角色转发到相应的模块。redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</li><li><strong>从效率来说</strong>：forward：高。redirect：低。</li></ol><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p>网络安全主要探讨的问题是攻击者如何攻击计算机网络，以及如何防御这些攻击，或者如何事先预防这样的攻击。</p><h3 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h3><p>计算机网络面临的威胁主要有被动攻击和主动攻击。</p><p><strong>被动攻击</strong>指攻击者从网络上窃听他人的通信内容，也叫截获。在被动攻击中，攻击者只是观察和分析某一协议数据单元 PDU 而不干扰信息流。攻击者可以通过观察 PDU 的协议控制信息部分，了解正在通信的协议的地址和身份，通过研究 PDU 的长度和发送频度，了解所交换的数据的某种性质。这种攻击又叫做流量分析。</p><p><strong>主动攻击</strong>包括：</p><ul><li><p><strong>篡改</strong></p><p>攻击者篡改网络上传输的报文，包括彻底中断传送的报文，甚至把完全伪造的报文发给接收端，这种攻击方式也叫做更改报文流。</p></li><li><p><strong>恶意程序</strong></p><p>① 计算机病毒，能够传染其他程序的程序，主要通过修改其他程序来把自身或自身的变种复制进去完成。② 计算机蠕虫，通过网络通信能把自己从一个结点发往另一个节点并且自动启动运行的程序。③ 特洛伊木马，它执行的功能并非声称的功能而是恶意程序，例如一个编译程序除了完成编译任务外还偷偷地复制源程序。④ 逻辑炸弹，当运行环境满足某种特殊条件时就会执行特殊功能的程序，例如当日期为 22 号且为周三的时候就会删除所有文件。⑤ 后门入侵，指利用系统实现中的漏洞通过网络入侵系统。⑥ 流氓软件，一种未经用户同意就在用户计算机上安装并损害用户利益的软件。</p></li><li><p><strong>拒绝服务DoS</strong></p><p>DoS 攻击使得网络、主机或其他基础设施部分不能由合法用户使用。Web 服务器、电子邮件服务器、DNS 服务器和机构网络都能够成为 DoS 攻击的目标。大多数 DoS 攻击属于以下三种情况：① 弱点攻击，指向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文，如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能会停止运行甚至崩溃。② 带宽洪泛，指攻击者向目标主机发送大量的分组，分组数量之多使得目标的接入链路变得阻塞，使合法的分组无法到达服务器。③ 连接洪泛，指攻击者在目标主机中创建大量的半开或全开 TCP 连接，主机因这些伪造的连接而陷入困境，并停止接受合法的连接。</p></li><li><p><strong>ARP欺骗</strong></p><p>在使用以太网交换机的网络中，攻击者向某个以太网交换机发送大量的伪造源 MAC 地址，以太网交换机收到这样的帧就把虚假的 MAC 源地址填入到交换表中，由于伪造的数量很大很快就填满了表，导致以太网交换机无法正常工作。</p></li></ul><p>对于被动攻击可以采用各种数据加密技术，对付主动攻击则需要将加密技术与适当的鉴别技术相结合。</p><p>安全的计算机网络具有以下特性：</p><ul><li><p><strong>机密性</strong></p><p>仅有发送方和希望的接收方能够理解报文传输的内容，因为窃听者可以截获报文，这要求报文必须进行加密，使截取而都报文无法被截获者理解。为了使网络具有保密性，需要使用各种密码技术。</p></li><li><p><strong>报文完整性</strong></p><p>通信内容在传输过程中需要被确保未被恶意篡改或意外改动。</p></li><li><p><strong>端点鉴别</strong></p><p>发送方和接收方都应该能证实通信过程中的另一方，以确信通信的另一方确实具有其声称的身份。在实际应用中，报文完整性和端点鉴别往往是不可分割的，因为假设通过了端点鉴别保证了通信双方的身份却没有通过报文鉴别保证报文的完整性是没有意义的。</p></li><li><p><strong>运行安全性</strong></p><p>几乎所有机构都有与互联网相连的网络，这些网络都因此具有潜在的安全问题。需要通过访问控制来确保网络的安全性，防火墙位于机构和公共网络之间，控制接入和来自网络的分组；入侵检测系统指需深度分组检查任务，向网络管理员发出有关可疑活动的警告。</p></li></ul><hr><h3 id="密码技术"><a href="#密码技术" class="headerlink" title="密码技术"></a>密码技术</h3><p>密码技术使发送方可以伪装数据，接收方需要从伪装的数据中恢复出初始数据，而入侵者不能从截获到的数据中获得任何信息。报文的最初形式被称为明文，在使用加密算法加密后得到的加密报文被称为密文。密码体制分为两种，对称密钥密码体制和公开密钥密码体制。</p><p>对称密钥密码体制使用相同的加密密钥和解密密钥，对称加密的运算速度快，但是安全性差，因为在密钥传输的过程中可能会被截获。数据加密标准 DES 属于对称密码密钥，这种密码的保密性仅仅取决于对密钥的保密，而算法是公开的，之后被更加安全的高级加密标准 AES 所取代。</p><p>公开密钥密码体制使用公钥进行加密，私钥进行解密，其中公钥是任何人都可以得知的，而私钥是通信双方所独有的。非对称加密的运算速度慢，但是安全性好。最常见的公钥加密算法是 RSA，它使用两个大素数 p 和 q 来生成密钥，p 和 q 的值越大，破解的难度就越大，但是执行加密和解密的时间也就越长，RSA 实验室推荐 p 和 q 的乘积为 1024 的数量级。</p><p>在使用对称密钥时，由于双方使用同样的密钥，因此在通信信道上可以进行<strong>一对一的双向保密通信</strong>，每一方既可以用该密钥加密明文并发送给对方，也可以接收密文用同一密钥解密。这种保密通信仅限于持有此密钥的双方。但在使用公开密钥时，在通信信道上可以是<strong>多对一的单向保密通信</strong>，可以同时有很多客户利用公钥对自己的报文加密后发送给某个服务器，服务器利用其私钥可以对收到的密文一一解密，但如果是反方向则是行不通的，例如在网购时很多客户都向同一个网站发送各自的信用卡信息。</p><hr><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p><strong>数字签名的作用</strong></p><p>① <strong>报文鉴别：</strong>接收者能够核实发送者对报文的签名，也就是说接收者可以确认报文发送方的身份。</p><p>② <strong>报文完整性：</strong>接收者可以确信收到的数据和发送者发送的完全一样并且没有被篡改过。</p><p>③ <strong>不可否认：</strong>发送者事后不能抵赖对报文的签名。</p><p><strong>实现原理</strong></p><p>有多种实现数字签名的方法，但采用公钥算法要比采用对称密钥算法更容易实现。为了进行签名，会首先用私钥对报文进行 D 运算得到某种不可读的密文，为了核实签名，接收方会利用发送方的公钥进行 E 运算还原出明文。任何人都可以用发送方的公钥还原出明文，因此这种通信方式并不是为了保密，而是为了进行签名和核实签名，即确认发送方的身份。</p><p>数字签名实现报文鉴别：除了发送方之外没有人持有其私钥，因此无法产生发送方才能产生的密文。</p><p>数字签名保证报文完整性：如果其他人篡改过密文，那么解密出的明文就会不可读，就知道收到的报文被篡改过。</p><p>数字签名保证不可否认：如果发送方抵赖发送过报文，接收方可以把初始报文和密文发送给公证的第三者，第三者通过公钥很容易证实发送方确实发送过报文。</p><p><strong>公钥认证</strong></p><p>攻击者可能会发送使用自己私钥加密的密文和自己的公钥来伪造发送方的身份，该问题通过 CA 解决，发送方在发送数据时也会发送 CA 签署的证书，接收方会利用 CA 的公钥来核对发送方证书的合法性并提取发送方的公钥。</p><p>CA 即认证中心，将公钥与特定的实体绑定， 它的职责就是使识别和发行证书合法化。CA 主要有两个作用：① CA 认证一个实体（一个人、一台路由器等）的真实身份。② 一旦 CA 认证了某个实体的身份，CA 会生成一个将其身份和实体的公钥绑定起来的证书，这个证书包含了这个公钥和公钥所有者全局唯一的身份标识信息（例如一个人的名字或一个 IP 地址），由 CA 对这个证书进行数字签名。</p><hr><h3 id="报文鉴别"><a href="#报文鉴别" class="headerlink" title="报文鉴别"></a>报文鉴别</h3><p>报文鉴别就是鉴别收到的报文确实是发送方发送的，而不是别人伪造或篡改的。数字签名就可以实现报文鉴别，但是数字签名有一个很大的缺点，就是对较长的报文进行数字签名时会使计算机增加非常大的负担，因为需要较长时间的运算。有一种相对简单的报文鉴别方式，就是密码散列函数。在密码学中的散列函数称为密码散列函数，最重要的特点就是：要找到两个不同的报文，它们具有相同的密码散列函数输出，在计算上是不可行的，也就是说密码散列函数实际上是一种单向函数。</p><p><strong>使用散列函数进行报文鉴别的原理</strong></p><p>通信双方需要共享一个密钥 k ，发送方生成报文 m，用 k 级联 m 生成 m+k，并使用 SHA-1 或 MD5 这样的散列函数计算 m+k 的散列值 h，这个散列值就被称为报文鉴别码 MAC。发送方会将 MAC 附加到报文 m 上，生成一个扩展报文，并将该扩展报文发送给接收方。接收方接到扩展报文后，由于知道共享密钥 k，因此可以计算出报文鉴别码，如果计算出的报文鉴别码和 h 相等就可以得出一切正常的结论。</p><p>除了共享密钥，还可以使用公钥加密。发送方可以利用自己的私钥进行散列运算，接收方利用发送方的公钥进行还原。这种方法得到的扩展报文是不为伪造且不可否认的，因为攻击者没有发送方的私钥，无法伪造出发送方发出的报文。</p><hr><h3 id="端点鉴别"><a href="#端点鉴别" class="headerlink" title="端点鉴别"></a>端点鉴别</h3><p>端点鉴别就是一个实体经过计算机网络向另一个实体证明其身份的过程，实体可以是一个人也可以是一个进程。端点鉴别主要通过鉴别协议 ap 来实现，鉴别协议通常在两个通信实体运行其他协议之前运行。鉴别协议首先建立相互满意的各方标识，仅当鉴别完成之后各方才继续下面的工作。</p><p><strong>鉴别协议 ap1.0</strong></p><p>发送方直接发送一个报文说明自己的身份，缺陷很大，攻击者可以任意伪造。</p><p><strong>鉴别协议 ap2.0</strong></p><p>发送方有一个总是用于通信的 IP 地址，接收方可以验证携带鉴别报文的 IP 数据报的源地址和发送方经常使用的 IP 地址是否匹配来进行鉴别。但存在 IP 欺骗的可能性，攻击者也可以伪造源 IP 地址。</p><p><strong>鉴别协议 ap3.0</strong></p><p>进行鉴别的经典方法是使用秘密口令，口令是鉴别者和被鉴别者之间的一个共享秘密。接收方会要求发送方提供口令来进行验证，但这种方式依旧不是安全的，因为攻击者可能会通过嗅探获得发送方的口令。一种改进想法是对口令进行加密，防止攻击者获得口令，但是这不能解决重放攻击，攻击者可以获取加密口令并不断重放。</p><p><strong>鉴别协议 ap4.0</strong></p><p>重放攻击主要是由于接收方并不知道此时发送方是否还是活跃的，ap 4.0 主要通过一个<strong>不重数</strong>来防止重放攻击。不重数就是在一个协议的生存期中只会使用一次的数，是一个不重复使用的大随机数，一旦某协议使用了一个不重数，就永远不会再使用那个数了。接收方会向发送方发送一个不重数，发送方将其加密后发回给接收方，接收方通过验证这个数字来判断发送方是否是活跃的。</p><hr><h3 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h3><p><strong>网络层</strong></p><p>网络层的安全协议是 IPsec，它并不是一个单一的协议，而是能够为两个网络实体之间的 IP 数据报提供通信安全的协议族。IPsec 并没有限定用户必须使用的加密和鉴定算法，允许通信双方选择合适的算法和参数，为保证互操作性而包含了一套加密算法，要求所有 IPsec 的实现都必须使用。许多机构都使用 IPsec 来保证虚拟专用网 VPN 的安全性。</p><p>IPsec 协议族中有两个主要协议：<strong>鉴别首部 AH 协议</strong>和<strong>封装安全有效载荷 ESP 协议</strong>。当某源 IPsec 实体向一个目的实体发发送安全数据报时，它可以使用 AH 或 ESP 协议来实现。AH 提供源鉴别和数据完整性服务，而 ESP 除了这两种服务外还可以提供机密性服务，因此使用要比 AH 广泛许多。使用 AH 或 ESP 的 IP 数据报称为 IP 安全数据报，它可以在两台主机、两台路由器或一台主机和一个路由器之间发送。IP 安全数据报有两种工作方式：① 运输方式，在整个运输层报文段的前后分别加上控制信息再加上 IP 首部，构成 IP 安全数据报。② 隧道方式，在原始的 IP 数据报的前后分别加上控制信息，构成 IP 安全数据报，这种方式使用较多。</p><p><strong>运输层</strong></p><p>运输层的安全协议主要是 SSL 安全套节字层和 TLS 运输层安全，TLS 是 SSL3.0 的修改版本。SSL 主要作用在端系统的 HTTP 和运输层之间，在 TCP 上建立起一个安全通道，为 TCP 传输的应用层数据提供安全保障。应用层使用 SSL 最多的就是 HTTP，但 SSL 并不是只用于 HTTP，而是可以用于任何应用层的协议，例如 SSL 也可以用于邮件存取的鉴别和数据加密。</p><p>SSL 提供的安全性服务包括三种：① <strong>服务器鉴别</strong>，允许用户证实服务器的身份，支持 SSL 的客户端通过验证来自服务器的证书来鉴别服务器的身份并取得服务器的公钥。② <strong>客户鉴别</strong>，SSL 可选的安全服务，允许服务器验证用户的身份。③ <strong>加密的 SSL 会话</strong>，对客户和服务器发送的所有报文进行加密，并检测报文是否被篡改。</p><hr><h3 id="防火墙和入侵检测"><a href="#防火墙和入侵检测" class="headerlink" title="防火墙和入侵检测"></a>防火墙和入侵检测</h3><p>在计算机网络中，当通信流量进入/离开网络时要执行安全检查、做记录、丢弃或转发，这些工作都有防火墙和入侵检测系统来完成。</p><p><strong>防火墙</strong></p><p>防火墙是一个硬件和软件的结合体，它将一个机构的内部网络与整个因特网隔离开，内部的属于可信网络，外部的属于不可信网络，允许一些数据分组通过而阻止另一些。它属于一种访问控制技术，通过严格控制进出网络的分组来禁止任何不必要的通信，从而减少潜在侵入的发送，从外部到内部和从内部到外部的所有流量都必须经过防火墙，只有被授权的流量才允许通过，授权与否由本地的安全策略定义，防火墙可以限制对授权流量的访问。 </p><p>防火墙分为三种：① 基于<strong>分组过滤</strong>，分组过滤器独立地检查每个数据报，然后基于管理员特定的规则决定该数据报应当允许通过还是丢弃，过滤因素通常包括 IP 源或目的地址、TCP 或 UDP 地源和目的端口、IP 数据报中的协议字段类型等。②  基于<strong>状态过滤</strong>，利用一张连接表来实际地跟踪 TCP 连接，并使用跟踪信息做出过滤决定。③ <strong>应用程序网关</strong>，这是一个应用程序特定的服务器，所有应用程序数据都必须通过它，每种程序都需要一个不同的应用网关。</p><p><strong>入侵检测系统 IDS</strong></p><p>防火墙不可能阻止所有入侵行为，入侵检测系统作为第二道防线，通过对进入网络的分组进行深度分析与检测发现异常网络行为，并进行报警以便进一步处理。IDS 可以用于检测多种攻击，包括网络映射、端口扫描、DoS 带宽洪泛攻击、病毒和蠕虫等。一个机构可以在它的机构网络中部署一个或多个 IDS 传感器，由于 IDS 不仅需要做深度分组检查，还必须要把每个过往的分组与数以万计的特征进行比较，因此会导致很大的处理量，所以一般都需要多个 IDS 传感器。IDS 系统可以大致分为基于特征的系统和基于异常的系统。</p><p><strong>基于特征的 IDS</strong> 维护了一个范围广泛的攻击特征数据库，每个特征是一个与入侵活动相关联的规则集，基于特征的 IDS 嗅探通过它的每个分组，将分组中的数据与数据库中的特征进行比较，如果匹配将产生一个警告，该警告能够发送一个电子邮件报文给网络管理员或者网络管理系统。但是基于特征的 IDS 无法应对新型攻击，并且即使与特征匹配时也可能不是一个攻击而因此产生了一个虚假警告。</p><p><strong>基于异常的 IDS</strong> 会观察正常运行的流量，并生成一个流量概况文件。它会寻找统计上不寻常的分组流，例如 ICMP 分组不寻常的百分比或端口扫描指数性突然增长。基于异常的 IDS 最大的特点就是不依赖现有攻击的以前只是，另一方面区分正常流量和统计异常流量也是一个挑战。至今大多数部署的 IDS 主要是基于特征的。</p><hr><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>多道程序环境下允许多个程序并发执行，进程就是为了更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p><p>进程就是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。系统资源指的是处理机、存储器和其他设备服务于某个进程的时间，例如把处理机资源理解为处理机的时间片才是准确的。因为进程是这些资源分配和调度的独立单位，这就决定了进程一定是一个动态的、过程性的概念。</p><p><strong>结构</strong></p><p>①进程控制块PCB：进程实体的一部分，进程存在的唯一标识，包括进程描述信息、控制和管理信息、资源分配清单和处理机相关信息。</p><p>②程序段：就被进程调度程序调度到CPU执行的程序代码段。</p><p>③数据段：进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p><p><strong>特征</strong></p><p>①动态性 进程是一次程序的执行，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。</p><p>②并发性 指多个进程同时存在于内存中，能在一段时间内同时运行。并发性是进程的重要特征，也是操作系统的重要特征。进入进程的目的就是为了使程序能与其他进程的程序并发执行，提高资源利用率。</p><p>③独立性 指进程实体是一个能独立运行、独立获得自由和独立接受调度的基本单位。</p><p>④异步性 由于进程的相互制约，会使进程具有执行的间断性，即进程按各自独立的，不可预知的速度向前推进。</p><p>⑤结构性 每个进程都配置有一个进程控制块PCB对其进行描述，从结构上看进程实体是由程序段、数据段和PCB组成的。</p><p><strong>进程的状态和转换</strong></p><p>①运行态 进程正在处理机上运行</p><p>②就绪态 进程已处于准备运行的状态，获得了除处理机外的一切资源</p><p>③阻塞态 进程正在等待某一事件而暂停运行，如等待某资源可用或等待输入/输出流</p><p>④创建态 进程正在被创建，尚未转到就绪态</p><p>⑤结束态 进程正从系统中消失，可能是正常结束或其他原因中断退出</p><p>就绪-&gt;运行：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片）</p><p>运行-&gt;就绪：处于运行态的进程在时间片用完后，不得不让出处理机。在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转为就绪态，让更高优先级的进程执行。</p><p>运行-&gt;阻塞：进程请求某一资源的使用和分配或等待某事件的发生（如IO完成），进程以系统调用的形式请求操作系统提供服务。</p><p>阻塞-&gt;就绪：进程等待的事件到来时，如IO结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞转为就绪态。</p><p><strong>进程控制</strong></p><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p><strong>进程创建</strong></p><p>允许一个进程创建另一个进程，创建者为父进程，被创建者为子进程。子进程可以继承父进程所拥有的资源，当子进程被撤销时，应将父进程的资源归还。撤销父进程时，必须同时撤销所有子进程。</p><p>①为新进程分配一个唯一的进程标识号，并申请一个空白PCB。②为进程分配资源，为新进程的程序和数据分配必要内存空间。若资源不足不会创建失败而是进入阻塞态。③初始化PCB，包括标志信息，处理机状态信息，进程优先级等。④若进程就绪队列未满，就将新进程插入就绪队列等待被调度。</p><p><strong>进程终止</strong></p><p>正常结束，表示进程任务已经完成并准备退出运行。异常结束，表示进程在运行时发生了某种异常，使程序无法继续运行，例如非法指令，IO故障等。外界干预，指进程因为外界请求而终止，例如操作系统干预或父进程请求终止等。</p><p>①根据被终止进程的标识符，检索PCB，读出该进程的状态。②若处于执行状态，终止执行，将处理机资源分配给其他进程。③若进程还有子进程，应将所有子进程终止。④将该进程的全部资源归还给父进程或操作系统。⑤将PCB从所在队列删除。</p><p><strong>进程阻塞</strong></p><p>①找到将要被阻塞进程的PCB。②如果为运行态，保护现场转为阻塞态，停止运行。③把PCB插入相应事件的等待队列。</p><p><strong>进程唤醒</strong></p><p>①在该事件的等待队列中找到进程对应的PCB。②将其从等待队列中移除，设置状态为就绪态。③将PCB插入就绪队列，等待调度程序调度。</p><p><strong>进程切换</strong></p><p>①保存处理机上下文，包括程序计数器和其他寄存器。②更新PCB信息。③把进程的PCB移入相应的队列。④选择另一个进程执行并更新其PCB。⑤更新内存管理的数据结构。⑥恢复处理机上下文。</p><p><strong>进程通信</strong></p><p>①共享存储：在通信的进程之间存在一块可以直接访问的共享空间，共享存储分为两种：低级的共享基于数据结构，高级的共享基于存储区。操作系统只负责为通信进程提供可共享的存储空间和同步互斥工具，数据交换由用户自己安排读写指令完成。</p><p>②消息传递：进程间的数据交换以格式化的消息为单位，进程提供系统提供的发送消息和接收消息两个原语进行数据交换。消息传递分为：直接通信方式，把消息挂在接收进程的消息缓存队列上。间接通信方式，发送进程把消息发送到某个中间实体，中间实体一般称作信箱，相应的通信系统为电子邮件系统。</p><p>③管道通信：消息传递的一种特殊方式，管道就是连接一个读进程和一个写进程来实现它们通信的一个共享文件。管道可以理解为共享存储的优化和发展，管道通信中存储空间优化为缓冲区，缓冲区只允许一边写入另一边读出，只要缓冲区有数据进程就能从缓冲区读出，只要有数据写进程就不会往缓冲区写数据，因此管道通信是半双工通信。</p><hr><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>引入进程的目的是为了多道程序更好的并发执行，提高资源利用率和吞吐量；引入线程的目的是为了减少程序在并发执行时的时空开销，提高操作系统的并发性能。</p><p>线程就是一种轻量级的进程，是一个基本的CPU执行单位，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是操作系统独立调度和分配的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它与同一进程下的其他线程共享进程的全部资源。</p><p><strong>线程和进程的区别</strong></p><p>①调度：进程是拥有资源的基本单位，而线程是独立调度的基本单位。在同一进程中，线程的切换不会引起进程的切换。在不同进程中线程的切换会引起进程切换。</p><p>②拥有资源：不管是传统操作系统还是有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源，只有一点运行中必不可少的资源。如果线程也是拥有资源的单位，那么切换线程就需要较大的时空开销，它的引入就没有意义。</p><p>③系统开销：创建和撤销进程涉及资源的分配和回收，操作系统的开销远大于创建或撤销线程的开销。进程切换也需要涉及CPU环境的保存和新调度到进程CPU环境的设置，但线程切换只需要保存和设置少量的寄存器容量，开销很小。</p><p>④地址空间：进程的地址空间之间互相独立，同一进程的各个线程共享进程的资源，进程内的线程对其他进程不可见。</p><p>⑤通信：进程间通信需要同步和互斥手段的辅助，保证数据一致性。线程可以直接读写进程数据段（全局变量）来进行通信。</p><p><strong>线程的实现方式</strong></p><p>①用户级线程：有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。</p><p>②内核级线程：线程管理的所有工作都由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。</p><hr><h3 id="TCP异常处理？"><a href="#TCP异常处理？" class="headerlink" title="TCP异常处理？"></a>TCP异常处理？</h3><p>tcp 异常处理，什么时候有RST？</p><p>什么时候有PSH URG 的包</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁就是指多个进程因为互相竞争资源而陷入的一种僵局，如果没有外力的作用，这些进程都无法继续向前推进。</p><p>死锁的原因包含了：</p><p>①不可剥夺资源数量的不足，如果是可剥夺资源是不会造成死锁的。</p><p>②进程的推进顺序非法，进程请求和释放资源的顺序不当，例如进程P1和P2分别占用资源R1和R2，而此时P1和P2又分别申请资源R2和R1。</p><p>③信号量的使用不当，彼此等待对方的消息。</p><p>死锁有四个必要条件：</p><p>①互斥条件，进程对资源的占用具有排他性控制，如果进程请求的资源已被占用，请求就会被阻塞。</p><p>②不可剥夺条件，当一个资源没有被使用完成前是不能被其他进程强行获取的，只有占用它的进程主动释放才可以。</p><p>③请求和保持条件，一个进程已经占有了某个资源，又要请求其他资源，而该资源被其他进程占用，请求被阻塞，但进程也不会释放自己已经占有的资源。</p><p>④循环等待条件，存在一个进程资源的循环等待链，链中每个进程已经占有的资源同时是其他进程请求的资源。</p><p><strong>预防</strong></p><p>事先预防，实现起来比较简单，但是条件严格，效率很低。</p><p>①破坏互斥条件，系统中的所有资源都允许共享，但是有的资源不能同时访问，不太现实。</p><p>②破坏不可剥夺条件，允许剥夺其他进程已经占有的资源，可能会造成前段工作的失效，如果频繁发送就会增加系统开销，严重降低系统的吞吐量。</p><p>③破坏请求和保持条件，采用预先资源分配法，一次性分配进程需要的所有资源，缺点是会严重浪费系统资源。</p><p>④破坏循环等待条件，采用顺序资源分配法， 缺点是会造成编程不便。</p><p><strong>避免</strong></p><p>同样也是事先预防，不同的是动态地根据情况来避免死锁，性能比较好。</p><p>①系统安全状态，不安全的系统可能会导致死锁，安全的系统状态不会导致死锁，如果资源分配不会进入不安全的系统状态就给进程分配资源。</p><p>②银行家算法，把操作系统视为银行家，操作系统管理的资源视为资金，进程向操作系统申请资源相当于贷款。采用预先资源分配策略，主要的数据结构是可利用的资源向量，分配矩阵，需求矩阵，最大需求矩阵。</p><p><strong>检测</strong></p><p>画出资源分配图，圆圈表示进程，框表示一类资源。进程到资源是请求边，资源到进程是分配边。然后利用死锁定理来简化资源分配图，如果S不可被完全简化那么代表是一个死锁。</p><p><strong>解除</strong></p><p>如果没有采取死锁的预防和避免，就要采用死锁的检测和解除。</p><p>①资源剥夺法：挂起某些死锁进程并剥夺其资源。</p><p>②撤销进程法：撤销一个甚至全部死锁进程并剥夺其资源。</p><p>③进程回退法：让一个或多个进程回到不至于造成死锁的状态。</p><h2 id="分页分段"><a href="#分页分段" class="headerlink" title="分页分段"></a>分页分段</h2><p>传统存储管理方式：操作系统引入了虚拟内存的概念，利用计算机的空间局部性和时间局部性原理，将程序分的一部分装入内存运行，其余部分留在外存，等需要的时候再讲外存的程序装入内存继续运行。</p><h3 id="虚拟内存实现方式："><a href="#虚拟内存实现方式：" class="headerlink" title="虚拟内存实现方式："></a>虚拟内存实现方式：</h3><p>请求分页，请求分段，请求段页式存储管理。请求分页存储管理中，将虚拟地址内存空间划分为大小相等的页块，同时内存地址空间，也划分为等大小的页块。系统维持一个页表，存储这虚拟页号到物理快块号的映射。程序中的逻辑地址由两部分组成：页号P和页内位移量W。块号*块大小加上页内偏移得到物理地址。</p><p>如果程序执行时，调用到不再内存中的虚拟页面时，发生缺页中断，将页由外存调入内存。如果内存已满，采用页面置换算法将老的淘汰，载入新的。页面置换算法常见的有FIFO,LRU。</p><p><img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201024091740786.png" alt="image-20201024091740786"></p><p>优点：没有外碎片，每个内碎片不超过页的大小。</p><p>缺点：程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。</p><h3 id="请求分段存储管理："><a href="#请求分段存储管理：" class="headerlink" title="请求分段存储管理："></a>请求分段存储管理：</h3><p>将用户程序地址空间分成若干个大小不等的段，每段能够定义一组相对完整的逻辑信息。存储分配时，以段为单位，段内地址连续，段间不连续。虚拟地址由段号和段内地址组成，虚拟地址到实存地址的变换通过段表来实现。 分页对程序猿而言是不可见的。而分段通常对程序猿而言是可见的，因而分段为组织程序和数据提供了方便。段页式存储组织是分段式和分页式结合的存储组织方法。这样可充分利用分段管理和分页管理的长处。</p><p><img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201024091751743.png" alt="image-20201024091751743"></p><p>优点：可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。</p><p>缺点：会产生碎片。</p><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统</p><p>的共享和保护，又拥有分页系统的虚拟内存功能。</p><p><img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201024091706330.png" alt="image-20201024091706330"></p><h3 id="大内核和微内核有什么区别？"><a href="#大内核和微内核有什么区别？" class="headerlink" title="大内核和微内核有什么区别？"></a>大内核和微内核有什么区别？</h3><ul><li>大内核，就是将操作系统的全部功能都放进内核里面，组成一个紧密连接整体。大内核的优点就是效率高，但是很难定位<code>bug</code>，拓展性比较差，每次需要增加新的功能，都要将新的代码和原来的内核代码重新编译。 </li><li>微内核与单体内核不同，微内核只是将操作中最核心的功能加入内核，包括<code>IPC</code>、地址空间分配和基本的调度，这些东西都在内核态运行，其他功能作为模块被内核调用，并且是在用户空间运行。微内核比较好维护和拓展，但是效率可能不高，因为需要频繁地在内核态和用户态之间切换。</li></ul><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>作者：风雨下钟山<br>链接：<a href="https://www.nowcoder.com/discuss/468422" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/468422</a><br>来源：牛客网</p><h4 id="Socket通信流程是怎样的？"><a href="#Socket通信流程是怎样的？" class="headerlink" title="Socket通信流程是怎样的？"></a>Socket通信流程是怎样的？</h4><p><img src="https://uploadfiles.nowcoder.com/images/20200806/6638786_1596672311055_5EE57B5D9BB579AAED205B35F053429B" alt="图片说明"> </p><ul><li>概括地说，就是通信的两端都建立了一个 <code>Socket</code> ，然后通过 <code>Socket</code> 对数据进行传输。通常服务器处于一个无限循环，等待<a href>客户端</a>的连接。 </li><li>对于<a href>客户端</a>，它的的过程比较简单，首先创建 <code>Socket</code>，通过<code>TCP</code>连接服务器，将 <code>Socket</code> 与远程主机的某个进程连接，然后就发送数据，或者读取响应数据，直到数据交换完毕，关闭连接，结束 <code>TCP</code> 对话。 </li><li>对于服务端，先初始化 <code>Socket</code>，建立流式套接字，与本机地址及端口进行绑定，然后通知 <code>TCP</code>，准备好接收连接，调用 <code>accept()</code> 阻塞，等待来自<a href>客户端</a>的连接。如果这时<a href>客户端</a>与服务器建立了连接，<a href>客户端</a>发送数据请求，服务器接收请求并处理请求，然后把响应数据发送给<a href>客户端</a>，<a href>客户端</a>读取数据，直到数据交换完毕。最后关闭连接，交互结束。 </li></ul><h4 id="延伸问题：从TCP连接的角度说说Socket通信流程。"><a href="#延伸问题：从TCP连接的角度说说Socket通信流程。" class="headerlink" title="延伸问题：从TCP连接的角度说说Socket通信流程。"></a>延伸问题：从<code>TCP</code>连接的角度说说Socket通信流程。</h4><p><img src="https://uploadfiles.nowcoder.com/images/20200806/6638786_1596672375547_34FD922BEF6AB289D1B71C7D84037E42" alt="图片说明"> </p><p>首先是三次握手的<code>Socket</code>交互流程。</p><ol><li>服务器调用 <code>socket()</code>、<code>bind()</code>、<code>listen()</code> 完成初始化后，调用 <code>accept()</code> 阻塞等待； </li><li><a href>客户端</a> <code>Socket</code> 对象调用 <code>connect()</code> 向服务器发送了一个 <code>SYN</code> 并阻塞； </li><li>服务器完成了第一次握手，即发送 <code>SYN</code> 和 <code>ACK</code> 应答； </li><li><a href>客户端</a>收到服务端发送的应答之后，从 <code>connect()</code> 返回，再发送一个 <code>ACK</code> 给服务器； </li><li>服务器 <code>Socket</code> 对象接收<a href>客户端</a>第三次握手 <code>ACK</code> 确认，此时服务端从 <code>accept()</code> 返回，建立连接。 </li></ol><p>接下来就是两个端的连接对象互相收发数据。</p><p><img src="https://uploadfiles.nowcoder.com/images/20200806/6638786_1596672413212_A3DEEBF7F3F9D50D1D3613B9F2A48D7B" alt="图片说明"> </p><p>然后是四次挥手的<code>Socket</code>交互流程。</p><ol><li>某个应用进程调用 <code>close()</code> 主动关闭，发送一个 <code>FIN</code>； </li><li>另一端接收到 <code>FIN</code> 后被动执行关闭，并发送 <code>ACK</code> 确认； </li><li>之后被动执行关闭的应用进程调用 <code>close()</code> 关闭 <code>Socket</code>，并也发送一个 <code>FIN</code>； </li><li>接收到这个 <code>FIN</code> 的一端向另一端 <code>ACK</code> 确认。</li></ol><h3 id="close-wait产生原因"><a href="#close-wait产生原因" class="headerlink" title="close_wait产生原因"></a>close_wait产生原因</h3><p>通常，CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的 CLOSE_WAIT 状态，那么就意味着被动关闭的一方没有及时发出 FIN 包，一般有如下几种可能：</p><ul><li>程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。</li><li>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。</li><li>BACKLOG 太大：此处的 backlog 不是 syn backlog，而是 accept 的 backlog，如果 backlog 太大的话，设想突然遭遇大访问量的话，即便响应速度不慢，也可能出现来不及消费的情况，导致多余的请求还在<a href="http://jaseywang.me/2014/07/20/tcp-queue-的一些问题/" target="_blank" rel="noopener">队列</a>里就被对方关闭了。</li></ul><p>如果你通过「netstat -ant」或者「ss -ant」命令发现了很多 CLOSE_WAIT 连接，请注意结果中的「Recv-Q」和「Local Address」字段，通常「Recv-Q」会不为空，它表示应用还没来得及接收数据，而「Local Address」表示哪个地址和端口有问题，我们可以通过「lsof -i:<PORT>」来确认端口对应运行的是什么程序以及它的进程号是多少。</PORT></p><p>如果是我们自己写的一些程序，比如用 HttpClient 自定义的蜘蛛，那么八九不离十是程序问题，如果是一些使用广泛的程序，比如 Tomcat 之类的，那么更可能是响应速度太慢或者 timeout 设置太小或者 BACKLOG 设置过大导致的故障。</p><h3 id="第二次挥手和第三次挥手能不能合并"><a href="#第二次挥手和第三次挥手能不能合并" class="headerlink" title="第二次挥手和第三次挥手能不能合并"></a>第二次挥手和第三次挥手能不能合并</h3><p>第二次挥手的目的是确认你刚才给我发的包已经收到了，第三次挥手的目标是一个新的请求，因为第一次挥手数据包过来时服务器要有两件事要做，diyijianercihuishoudehuifu第一件二次挥手的回复，第二件通过应用程序解阻塞之后才能调用close，这个应用程序有可能调用了close，也有可能没调用，只要不调用close，就没有第三次挥手，如果第一次挥手发了数据包之后，服务器是要尽快去认，应用程序里面迟迟不调用close，所以第三次挥手迟迟发不了，如果把二和三合并一起，第三次迟迟发不了，两次挥手都发不了，客户端还等着呢，所以不能合并，拆开发。</p><h3 id="那为什么会有close-wait状态呢"><a href="#那为什么会有close-wait状态呢" class="headerlink" title="那为什么会有close_wait状态呢"></a>那为什么会有close_wait状态呢</h3><p>·在服务器与客户端通信的过程中，因为服务器未关闭socket导致closed_wait的发生，当客户端不断地发送连接请求的时候，这样打开的文件描述符就会不断增加。在linux系统中，一个进程可以最大同时打开的文件描述符是有限的。通过ulimit可以查看。</p><h3 id="IO复用？"><a href="#IO复用？" class="headerlink" title="IO复用？"></a>IO复用？</h3><p>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p>1、select、poll和epoll<br>·select、poll、epoll都可以监听多个文件描述符，等待指定的超时时间，直到一个或者多个文件描述符上有事件发生时返回。返回的值就是文件描述符的数量。返回0表示没有事件发生。</p><p>·差别：<br> (1)事件集<br>  ·select有三种类型的描述符类型：readfds、writefds、exceptfds，分别对应读、写、异常条件的描述符集合。因此，select不能处理这三种事件以外的事件类型。并且，每一次select会使得内核直接对fd_set进行修改，再下一次使用select的时候需要重置fd_set。每次select返回的都是注册了的事件集合，包括了就绪和没有就绪的，程序检索就绪事件的时间复杂度为O(n)</p><p>  ·poll对select进行了改进，poll的参数是一个结构体pollfd。poll不会修改描述符，因此每次使用不需要重置pollfd。但是，poll仍然是返回注册了的事件集合，包括了就绪和没有就绪的，程序检索就绪事件的时间复杂度为O(n)。</p><p>  ·epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<br>红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事<br>件完成的描述符。使得检索的时间复杂度达到O(1)</p><p> (2)支持最大的文件描述符<br>  ·select：受到系统的限制，由&lt;sys/select.h&gt;头文件中的FD_SETSIZE宏决定，通常是1024<br>  ·poll和epoll一般为65535</p><p> (3)工作模式<br>  ·select和poll只能工作在相对来说低效的水平触发模式(LT)<br>  ·epoll可以工作在高效的边缘触发模式(ET),也可以工作在水平触发模式</p><p> (4)实现原理<br>  ·select和poll都是基于轮询的方式，每一次的调用都要扫描整个注册的文件描述符集合，并将其中就绪的文件描述符返回给用户，因此检测就绪事件的时间复杂度是O(n)<br>  ·epoll_wait是采用回调的方式，内核检测到了就绪文件描述符，就会触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪队列中，内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此epoll_wait无需轮询检测哪些事件已经就绪，其时间复杂度是O(1)<br>  ·epoll需要触发回调函数，因此更适用于连接数目多，但活动连接较少的情况。</p><h3 id="同步与异步，阻塞和非阻塞"><a href="#同步与异步，阻塞和非阻塞" class="headerlink" title="同步与异步，阻塞和非阻塞"></a>同步与异步，阻塞和非阻塞</h3><p>同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p><p>而异步则是相反，<strong><em>调用\</em>在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p><p>·阻塞是指结果返回前，当前进程直接被挂起，一直等待结果的到来； 非阻塞则立刻返回，执行后续操作</p><p>·同步阻塞：当前进程在等待时，没有执行其他操作而是被挂起<br>·同步非阻塞：线程等待的时候，执行其它操作(效率低，很有可能设计线程切换的操作)</p><p>·异步阻塞：线程在等待消息通知时被挂起<br>·异步非阻塞：线程不等待，可以去做其他事情</p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p><ol><li>LT 模式<br>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait()<br>会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</li><li>ET 模式<br>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。<br>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个<br>文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</li></ol><h3 id="工作场景"><a href="#工作场景" class="headerlink" title="工作场景"></a>工作场景</h3><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><ol><li>select 应用场景<br>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比<br>如核反应堆的控制。<br>select 可移植性更好，几乎被所有主流平台所支持。</li><li>poll 应用场景<br>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</li><li>epoll 应用场景<br>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。<br>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。<br>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在<br>内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且<br>epoll 的描述符存储在内核，不容易调试。</li></ol><h3 id="arp欺骗"><a href="#arp欺骗" class="headerlink" title="arp欺骗"></a>arp欺骗</h3><p>在使用以太网交换机的网络中，攻击者向某个以太网交换机发送大量的伪造源 MAC 地址，以太网交换机收到这样的帧就把虚假的 MAC 源地址填入到交换表中，由于伪造的数量很大很快就填满了表，导致以太网交换机无法正常工作。</p><p> 1.解决方法：利用交换机防止ARP攻击</p><p>在交换机上绑定MAC地址与IP地址，为每台主机添加一条IP地址和MAC地址对应的关系静态地址表。用户发送数据包时，若交换机获得的IP和MAC地址与之前建立的映射表匹配，则发送的包能通过，否则将丢弃该数据包，从而有效地防止ARP欺骗。</p><p>2.[DHCP snooping](<a href="https://baike.baidu.com/item/DHCP" target="_blank" rel="noopener">https://baike.baidu.com/item/DHCP</a> snooping)，网上设备可借由<a href="https://baike.baidu.com/item/DHCP" target="_blank" rel="noopener">DHCP</a>保留网络上各计算机的MAC地址，在伪造的ARP数据包发出时即可侦测到。此方式已在一些厂牌的网上设备产品所支持。</p><p>3.每台计算机的ARP一律改用静态的方式，不过这在大型的网上是不可行的，因为需要经常更新每台计算机的ARP表。</p><h3 id="SYN-flood"><a href="#SYN-flood" class="headerlink" title="SYN flood"></a>SYN flood</h3><p>Syn-Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问。</p><p>解决方法</p><p>1.无效连接监视释放</p><p>这种方法不停监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。</p><p>2.延缓TCB分配方法</p><p>从前面SYN Flood原理可以看到，消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用SYN Cache和SYN Cookie技术。</p><p>SYN Cache技术：</p><p>这种技术是在收到SYN数据报文时不急于去分配TCB，而是先回应一个SYN ACK报文，并在一个专用HASH表（Cache）中保存这种半开连接信息，直到收到正确的回应ACK报文再分配TCB。</p><p>SYN Cookie技术：</p><p>对于SYN攻击，SYN Cache虽然不分配TCB，但是为了判断后续对方发来的ACK报文中的Sequence Number的正确性，还是需要使用一些空间去保存己方生成的Sequence Number等信息，也造成了一些资源的浪费。Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（SequenceNumber-1）相同，从而决定是否分配TCB资源。</p><p>3．使用SYN Proxy防火墙</p><p>SYN Cache技术和SYN Cookie技术总的来说是一种主机保护技术，需要系统的TCP/IP协议栈的支持，而目前并非所有的操作系统支持这些技术。因此很多防火墙中都提供一种 SYN代理的功能，其主要原理是对试图穿越的SYN请求进行验证后才放行，下图描述了这种过程：</p><h3 id="DNS欺骗？"><a href="#DNS欺骗？" class="headerlink" title="DNS欺骗？"></a>DNS欺骗？</h3><p> DNS欺骗就是攻击者冒充<a href="https://baike.baidu.com/item/域名服务器/9705133" target="_blank" rel="noopener">域名服务器</a>的一种欺骗行为。 原理：如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。</p><ol><li><p>进行IP地址和MAC地址的绑定</p><p>(1)预防ARP欺骗攻击。因为DNS攻击的欺骗行为要以ARP欺骗作为开端，所以如果能有效防范或避免ARP欺骗，也就使得DNS ID欺骗攻击无从下手。例如可以通过将Gateway Router 的Ip Address和MAC Address静态绑定在一起，就可以防范ARP攻击欺骗。</p></li></ol><p>2.直接使用IP地址访问</p><p>   对个别信息安全等级要求十分严格的WEB站点尽量不要使用DNS进行解析。由于DNS欺骗攻击中不少是针对窃取客户的私密数据而来的，而多数用户访问的站点并不涉及这些隐私信息，因此当访问具有严格保密信息的站点时，可以直接使用IP地址而无需通过DNS解析，这样所有的DNS欺骗攻击可能造成的危害就可以避免了。除此，应该做好DNS Server的安全配置项目和升级DNS软件，合理限定DNS Server进行响应的IP地址区间，关闭DNS Server的递归查询项目等。</p><p>3.对DNS数据包进行监测</p><p>   在DNS欺骗攻击中，Client会接收到至少两个DNS的数据响应包，一个是真实的数据包，另一个是攻击数据包。欺骗攻击数据包为了抢在真实应答包之前回复给Client，它的信息数据结构与真实的数据包相比十分简单，只有应答域，而不包括授权域和附加域。因此，可以通过监测DNS响应包，遵循相应的原则和模型算法对这两种响应包进行分辨，从而避免虚假数据包的攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字节算法题汇总</title>
      <link href="/2020/09/28/%E5%AD%97%E8%8A%82%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2020/09/28/%E5%AD%97%E8%8A%82%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>作者：星__尘<br>链接：<a href="https://www.nowcoder.com/discuss/428158?page=2" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/428158?page=2</a><br>来源：牛客网</p><h2 id="动态规划和贪心"><a href="#动态规划和贪心" class="headerlink" title="动态规划和贪心"></a><strong><a href>动态规划</a>和贪心</strong></h2><ul><li><p><a href>算法题</a>：买卖股票的最佳时机（只能有一次买卖，可以最多两次买卖，不限次数） </p><p>股票问题通用解法详解参考： <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/</a> </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缓存优化</title>
      <link href="/2020/09/09/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"/>
      <url>/2020/09/09/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2020/09/09/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200909163600765.png" alt="image-20200909163600765"></p><p>caffeine</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 帖子列表缓存</span><br><span class="line">private LoadingCache&lt;String, List&lt;DiscussPost&gt;&gt; postListCache;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 帖子总数缓存</span><br><span class="line">private LoadingCache&lt;Integer, Integer&gt; postRowsCache;</span><br><span class="line"></span><br><span class="line">@PostConstruct</span><br><span class="line">public void init() &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化帖子列表缓存</span><br><span class="line">    postListCache &#x3D; Caffeine.newBuilder()</span><br><span class="line">            .maximumSize(maxSize)</span><br><span class="line">            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)</span><br><span class="line">            .build(new CacheLoader&lt;String, List&lt;DiscussPost&gt;&gt;() &#123;</span><br><span class="line">                @Nullable</span><br><span class="line">                @Override</span><br><span class="line">                public List&lt;DiscussPost&gt; load(@NonNull String key) throws Exception &#123;</span><br><span class="line">                    if (key &#x3D;&#x3D; null || key.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        throw new IllegalArgumentException(&quot;参数错误!&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String[] params &#x3D; key.split(&quot;:&quot;);</span><br><span class="line">                    if (params &#x3D;&#x3D; null || params.length !&#x3D; 2) &#123;</span><br><span class="line">                        throw new IllegalArgumentException(&quot;参数错误!&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    int offset &#x3D; Integer.valueOf(params[0]);</span><br><span class="line">                    int limit &#x3D; Integer.valueOf(params[1]);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 二级缓存: Redis -&gt; mysql</span><br><span class="line"></span><br><span class="line">                    logger.debug(&quot;load post list from DB.&quot;);</span><br><span class="line">                    return discussPostMapper.selectDiscussPosts(0, offset, limit, 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#x2F;&#x2F; 初始化帖子总数缓存</span><br><span class="line">    postRowsCache &#x3D; Caffeine.newBuilder()</span><br><span class="line">            .maximumSize(maxSize)</span><br><span class="line">            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)</span><br><span class="line">            .build(new CacheLoader&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                @Nullable</span><br><span class="line">                @Override</span><br><span class="line">                public Integer load(@NonNull Integer key) throws Exception &#123;</span><br><span class="line">                    logger.debug(&quot;load post rows from DB.&quot;);</span><br><span class="line">                    return discussPostMapper.selectDiscussPostRows(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>热帖排行</title>
      <link href="/2020/09/09/%E7%83%AD%E5%B8%96%E6%8E%92%E8%A1%8C/"/>
      <url>/2020/09/09/%E7%83%AD%E5%B8%96%E6%8E%92%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>Quartz</p><p>配置-&gt;数据库-&gt;调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 刷新帖子分数任务</span><br><span class="line">@Bean</span><br><span class="line">public JobDetailFactoryBean postScoreRefreshJobDetail() &#123;</span><br><span class="line">    JobDetailFactoryBean factoryBean &#x3D; new JobDetailFactoryBean();</span><br><span class="line">    factoryBean.setJobClass(PostScoreRefreshJob.class);</span><br><span class="line">    factoryBean.setName(&quot;postScoreRefreshJob&quot;);</span><br><span class="line">    factoryBean.setGroup(&quot;communityJobGroup&quot;);</span><br><span class="line">    factoryBean.setDurability(true);</span><br><span class="line">    factoryBean.setRequestsRecovery(true);</span><br><span class="line">    return factoryBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SimpleTriggerFactoryBean postScoreRefreshTrigger(JobDetail postScoreRefreshJobDetail) &#123;</span><br><span class="line">    SimpleTriggerFactoryBean factoryBean &#x3D; new SimpleTriggerFactoryBean();</span><br><span class="line">    factoryBean.setJobDetail(postScoreRefreshJobDetail);</span><br><span class="line">    factoryBean.setName(&quot;postScoreRefreshTrigger&quot;);</span><br><span class="line">    factoryBean.setGroup(&quot;communityTriggerGroup&quot;);</span><br><span class="line">    factoryBean.setRepeatInterval(1000 * 60 * 5);</span><br><span class="line">    factoryBean.setJobDataMap(new JobDataMap());</span><br><span class="line">    return factoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>帖子分数刷新的任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class PostScoreRefreshJob implements Job, CommunityConstant &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(PostScoreRefreshJob.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private LikeService likeService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ElasticsearchService elasticsearchService;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 牛客纪元</span><br><span class="line">    private static final Date epoch;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            epoch &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).parse(&quot;2014-08-01 00:00:00&quot;);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;初始化牛客纪元失败!&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        String redisKey &#x3D; RedisKeyUtil.getPostScoreKey();</span><br><span class="line">        BoundSetOperations operations &#x3D; redisTemplate.boundSetOps(redisKey);</span><br><span class="line"></span><br><span class="line">        if (operations.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            logger.info(&quot;[任务取消] 没有需要刷新的帖子!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;[任务开始] 正在刷新帖子分数: &quot; + operations.size());</span><br><span class="line">        while (operations.size() &gt; 0) &#123;</span><br><span class="line">            this.refresh((Integer) operations.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(&quot;[任务结束] 帖子分数刷新完毕!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void refresh(int postId) &#123;</span><br><span class="line">        DiscussPost post &#x3D; discussPostService.findDiscussPostById(postId);</span><br><span class="line"></span><br><span class="line">        if (post &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;该帖子不存在: id &#x3D; &quot; + postId);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 是否精华</span><br><span class="line">        boolean wonderful &#x3D; post.getStatus() &#x3D;&#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; 评论数量</span><br><span class="line">        int commentCount &#x3D; post.getCommentCount();</span><br><span class="line">        &#x2F;&#x2F; 点赞数量</span><br><span class="line">        long likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_POST, postId);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 计算权重</span><br><span class="line">        double w &#x3D; (wonderful ? 75 : 0) + commentCount * 10 + likeCount * 2;</span><br><span class="line">        &#x2F;&#x2F; 分数 &#x3D; 帖子权重 + 距离天数</span><br><span class="line">        double score &#x3D; Math.log10(Math.max(w, 1))</span><br><span class="line">                + (post.getCreateTime().getTime() - epoch.getTime()) &#x2F; (1000 * 3600 * 24);</span><br><span class="line">        &#x2F;&#x2F; 更新帖子分数</span><br><span class="line">        discussPostService.updateScore(postId, score);</span><br><span class="line">        &#x2F;&#x2F; 同步搜索数据</span><br><span class="line">        post.setScore(score);</span><br><span class="line">        elasticsearchService.saveDiscussPost(post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算帖子分数</p><p>log(评论数<em>10+点赞数</em>2)+现在时间-牛客纪元</p><p>点赞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    public String like(int entityType, int entityId, int entityUserId, int postId) &#123;</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if(entityType &#x3D;&#x3D; ENTITY_TYPE_POST) &#123;</span><br><span class="line">    &#x2F;&#x2F; 计算帖子分数</span><br><span class="line">    String redisKey &#x3D; RedisKeyUtil.getPostScoreKey();</span><br><span class="line">    redisTemplate.opsForSet().add(redisKey, postId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>评论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算帖子分数</span><br><span class="line">String redisKey &#x3D; RedisKeyUtil.getPostScoreKey();</span><br><span class="line">redisTemplate.opsForSet().add(redisKey, discussPostId);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kafka系统通知</title>
      <link href="/2020/09/08/Kafka%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/"/>
      <url>/2020/09/08/Kafka%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2020/09/08/Kafka%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908222307315.png" alt="image-20200908222307315"></p><p>Event</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Event &#123;</span><br><span class="line"></span><br><span class="line">    private String topic;</span><br><span class="line">    private int userId;</span><br><span class="line">    private int entityType;</span><br><span class="line">    private int entityId;</span><br><span class="line">    private int entityUserId;</span><br><span class="line">    private Map&lt;String, Object&gt; data &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EventProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理事件</span><br><span class="line">    public void fireEvent(Event event) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将事件发布到指定的主题</span><br><span class="line">        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public class EventConsumer implements CommunityConstant &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(EventConsumer.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MessageService messageService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ElasticsearchService elasticsearchService;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;wk.image.command&#125;&quot;)</span><br><span class="line">    private String wkImageCommand;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;wk.image.storage&#125;&quot;)</span><br><span class="line">    private String wkImageStorage;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;qiniu.key.access&#125;&quot;)</span><br><span class="line">    private String accessKey;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;qiniu.key.secret&#125;&quot;)</span><br><span class="line">    private String secretKey;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;qiniu.bucket.share.name&#125;&quot;)</span><br><span class="line">    private String shareBucketName;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ThreadPoolTaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    @KafkaListener(topics &#x3D; &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;)</span><br><span class="line">    public void handleCommentMessage(ConsumerRecord record) &#123;</span><br><span class="line">        if (record &#x3D;&#x3D; null || record.value() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息的内容为空!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Event event &#x3D; JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">        if (event &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息格式错误!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 发送站内通知</span><br><span class="line">        Message message &#x3D; new Message();</span><br><span class="line">        message.setFromId(SYSTEM_USER_ID);</span><br><span class="line">        message.setToId(event.getEntityUserId());</span><br><span class="line">        message.setConversationId(event.getTopic());</span><br><span class="line">        message.setCreateTime(new Date());</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; content &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        content.put(&quot;userId&quot;, event.getUserId());</span><br><span class="line">        content.put(&quot;entityType&quot;, event.getEntityType());</span><br><span class="line">        content.put(&quot;entityId&quot;, event.getEntityId());</span><br><span class="line"></span><br><span class="line">        if (!event.getData().isEmpty()) &#123;</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; entry : event.getData().entrySet()) &#123;</span><br><span class="line">                content.put(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        message.setContent(JSONObject.toJSONString(content));</span><br><span class="line">        messageService.addMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 消费发帖事件</span><br><span class="line">    @KafkaListener(topics &#x3D; &#123;TOPIC_PUBLISH&#125;)</span><br><span class="line">    public void handlePublishMessage(ConsumerRecord record) &#123;</span><br><span class="line">        if (record &#x3D;&#x3D; null || record.value() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息的内容为空!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Event event &#x3D; JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">        if (event &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息格式错误!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DiscussPost post &#x3D; discussPostService.findDiscussPostById(event.getEntityId());</span><br><span class="line">        elasticsearchService.saveDiscussPost(post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 消费删帖事件</span><br><span class="line">    @KafkaListener(topics &#x3D; &#123;TOPIC_DELETE&#125;)</span><br><span class="line">    public void handleDeleteMessage(ConsumerRecord record) &#123;</span><br><span class="line">        if (record &#x3D;&#x3D; null || record.value() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息的内容为空!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Event event &#x3D; JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">        if (event &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息格式错误!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elasticsearchService.deleteDiscussPost(event.getEntityId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 触发评论事件</span><br><span class="line">Event event &#x3D; new Event()</span><br><span class="line">        .setTopic(TOPIC_COMMENT)</span><br><span class="line">        .setUserId(hostHolder.getUser().getId())</span><br><span class="line">        .setEntityType(comment.getEntityType())</span><br><span class="line">        .setEntityId(comment.getEntityId())</span><br><span class="line">        .setData(&quot;postId&quot;, discussPostId);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 触发点赞事件</span><br><span class="line">if (likeStatus &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    Event event &#x3D; new Event()</span><br><span class="line">            .setTopic(TOPIC_LIKE)</span><br><span class="line">            .setUserId(hostHolder.getUser().getId())</span><br><span class="line">            .setEntityType(entityType)</span><br><span class="line">            .setEntityId(entityId)</span><br><span class="line">            .setEntityUserId(entityUserId)</span><br><span class="line">            .setData(&quot;postId&quot;, postId);</span><br><span class="line">    eventProducer.fireEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 触发关注事件</span><br><span class="line">Event event &#x3D; new Event()</span><br><span class="line">        .setTopic(TOPIC_FOLLOW)</span><br><span class="line">        .setUserId(hostHolder.getUser().getId())</span><br><span class="line">        .setEntityType(entityType)</span><br><span class="line">        .setEntityId(entityId)</span><br><span class="line">        .setEntityUserId(entityId);</span><br><span class="line">eventProducer.fireEvent(event);</span><br></pre></td></tr></table></figure><p>显示系统通知（我们只要评论，赞和关注)</p><p><img src="/2020/09/08/Kafka%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200909105702853.png" alt="image-20200909105702853"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;notice&#x2F;list&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">public String getNoticeList(Model model) &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询评论类通知</span><br><span class="line">    Message message &#x3D; messageService.findLatestNotice(user.getId(), TOPIC_COMMENT);</span><br><span class="line">    if (message !&#x3D; null) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; messageVO &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        messageVO.put(&quot;message&quot;, message);</span><br><span class="line"></span><br><span class="line">        String content &#x3D; HtmlUtils.htmlUnescape(message.getContent());</span><br><span class="line">        Map&lt;String, Object&gt; data &#x3D; JSONObject.parseObject(content, HashMap.class);</span><br><span class="line"></span><br><span class="line">        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));</span><br><span class="line">        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));</span><br><span class="line">        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));</span><br><span class="line">        messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));</span><br><span class="line"></span><br><span class="line">        int count &#x3D; messageService.findNoticeCount(user.getId(), TOPIC_COMMENT);</span><br><span class="line">        messageVO.put(&quot;count&quot;, count);</span><br><span class="line"></span><br><span class="line">        int unread &#x3D; messageService.findNoticeUnreadCount(user.getId(), TOPIC_COMMENT);</span><br><span class="line">        messageVO.put(&quot;unread&quot;, unread);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;commentNotice&quot;, messageVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询点赞类通知</span><br><span class="line">    message &#x3D; messageService.findLatestNotice(user.getId(), TOPIC_LIKE);</span><br><span class="line">    if (message !&#x3D; null) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; messageVO &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        messageVO.put(&quot;message&quot;, message);</span><br><span class="line"></span><br><span class="line">        String content &#x3D; HtmlUtils.htmlUnescape(message.getContent());</span><br><span class="line">        Map&lt;String, Object&gt; data &#x3D; JSONObject.parseObject(content, HashMap.class);</span><br><span class="line"></span><br><span class="line">        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));</span><br><span class="line">        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));</span><br><span class="line">        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));</span><br><span class="line">        messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));</span><br><span class="line"></span><br><span class="line">        int count &#x3D; messageService.findNoticeCount(user.getId(), TOPIC_LIKE);</span><br><span class="line">        messageVO.put(&quot;count&quot;, count);</span><br><span class="line"></span><br><span class="line">        int unread &#x3D; messageService.findNoticeUnreadCount(user.getId(), TOPIC_LIKE);</span><br><span class="line">        messageVO.put(&quot;unread&quot;, unread);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;likeNotice&quot;, messageVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询关注类通知</span><br><span class="line">    message &#x3D; messageService.findLatestNotice(user.getId(), TOPIC_FOLLOW);</span><br><span class="line">    if (message !&#x3D; null) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; messageVO &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        messageVO.put(&quot;message&quot;, message);</span><br><span class="line"></span><br><span class="line">        String content &#x3D; HtmlUtils.htmlUnescape(message.getContent());</span><br><span class="line">        Map&lt;String, Object&gt; data &#x3D; JSONObject.parseObject(content, HashMap.class);</span><br><span class="line"></span><br><span class="line">        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));</span><br><span class="line">        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));</span><br><span class="line">        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));</span><br><span class="line"></span><br><span class="line">        int count &#x3D; messageService.findNoticeCount(user.getId(), TOPIC_FOLLOW);</span><br><span class="line">        messageVO.put(&quot;count&quot;, count);</span><br><span class="line"></span><br><span class="line">        int unread &#x3D; messageService.findNoticeUnreadCount(user.getId(), TOPIC_FOLLOW);</span><br><span class="line">        messageVO.put(&quot;unread&quot;, unread);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;followNotice&quot;, messageVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询未读消息数量</span><br><span class="line">    int letterUnreadCount &#x3D; messageService.findLetterUnreadCount(user.getId(), null);</span><br><span class="line">    model.addAttribute(&quot;letterUnreadCount&quot;, letterUnreadCount);</span><br><span class="line">    int noticeUnreadCount &#x3D; messageService.findNoticeUnreadCount(user.getId(), null);</span><br><span class="line">    model.addAttribute(&quot;noticeUnreadCount&quot;, noticeUnreadCount);</span><br><span class="line"></span><br><span class="line">    return &quot;&#x2F;site&#x2F;notice&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>点赞关注</title>
      <link href="/2020/09/07/%E7%82%B9%E8%B5%9E%E5%85%B3%E6%B3%A8/"/>
      <url>/2020/09/07/%E7%82%B9%E8%B5%9E%E5%85%B3%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>点赞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public String like(int entityType, int entityId, int entityUserId, int postId) &#123;</span><br><span class="line">       User user &#x3D; hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 点赞</span><br><span class="line">       likeService.like(user.getId(), entityType, entityId, entityUserId);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 数量</span><br><span class="line">       long likeCount &#x3D; likeService.findEntityLikeCount(entityType, entityId);</span><br><span class="line">       &#x2F;&#x2F; 状态</span><br><span class="line">       int likeStatus &#x3D; likeService.findEntityLikeStatus(user.getId(), entityType, entityId);</span><br><span class="line">       &#x2F;&#x2F; 返回的结果</span><br><span class="line">       ....</span><br><span class="line">       ....</span><br></pre></td></tr></table></figure><p>关注</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;follow&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String follow(int entityType, int entityId) &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">    followService.follow(user.getId(), entityType, entityId);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;unfollow&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String unfollow(int entityType, int entityId) &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">    followService.unfollow(user.getId(), entityType, entityId);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;followees&#x2F;&#123;userId&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">public String getFollowees(@PathVariable(&quot;userId&quot;) int userId, Page page, Model model) &#123;</span><br><span class="line">    User user &#x3D; userService.findUserById(userId);</span><br><span class="line">    if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;该用户不存在!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(&quot;user&quot;, user);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;followers&#x2F;&#123;userId&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">public String getFollowers(@PathVariable(&quot;userId&quot;) int userId, Page page, Model model) &#123;</span><br><span class="line">    User user &#x3D; userService.findUserById(userId);</span><br></pre></td></tr></table></figure><p>关注列表</p><p>粉丝列表</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>点赞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void like(int userId, int entityType, int entityId, int entityUserId) &#123;</span><br><span class="line">    redisTemplate.execute(new SessionCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            String entityLikeKey &#x3D; RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">            String userLikeKey &#x3D; RedisKeyUtil.getUserLikeKey(entityUserId);</span><br><span class="line"></span><br><span class="line">            boolean isMember &#x3D; operations.opsForSet().isMember(entityLikeKey, userId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            if (isMember) &#123;</span><br><span class="line">                operations.opsForSet().remove(entityLikeKey, userId);</span><br><span class="line">                operations.opsForValue().decrement(userLikeKey);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                operations.opsForSet().add(entityLikeKey, userId);</span><br><span class="line">                operations.opsForValue().increment(userLikeKey);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询某实体点赞的数量</span><br><span class="line">public long findEntityLikeCount(int entityType, int entityId) &#123;</span><br><span class="line">    String entityLikeKey &#x3D; RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">    return redisTemplate.opsForSet().size(entityLikeKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询某人对某实体的点赞状态</span><br><span class="line">public int findEntityLikeStatus(int userId, int entityType, int entityId) &#123;</span><br><span class="line">    String entityLikeKey &#x3D; RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">    return redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? 1 : 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关注</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void follow(int userId, int entityType, int entityId) &#123;</span><br><span class="line">    redisTemplate.execute(new SessionCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            String followeeKey &#x3D; RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">            String followerKey &#x3D; RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());</span><br><span class="line">            operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">            return operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void unfollow(int userId, int entityType, int entityId) &#123;</span><br><span class="line">    redisTemplate.execute(new SessionCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            String followeeKey &#x3D; RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">            String followerKey &#x3D; RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            operations.opsForZSet().remove(followeeKey, entityId);</span><br><span class="line">            operations.opsForZSet().remove(followerKey, userId);</span><br><span class="line"></span><br><span class="line">            return operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>发布帖子</title>
      <link href="/2020/09/07/%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90/"/>
      <url>/2020/09/07/%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><p><img src="/2020/09/07/%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200907224007422.png" alt="image-20200907224007422"></p><p><img src="/2020/09/07/%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200907225126398.png" alt="image-20200907225126398"></p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>发布帖子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String addDiscussPost(String title, String content) &#123;</span><br><span class="line">        User user &#x3D; hostHolder.getUser();</span><br><span class="line">        if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return CommunityUtil.getJSONString(403, &quot;你还没有登录哦!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DiscussPost post &#x3D; new DiscussPost();</span><br><span class="line">        post.setUserId(user.getId());</span><br><span class="line">        post.setTitle(title);</span><br><span class="line">        post.setContent(content);</span><br><span class="line">        post.setCreateTime(new Date());</span><br><span class="line">        discussPostService.addDiscussPost(post);</span><br></pre></td></tr></table></figure><p>帖子详情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;detail&#x2F;&#123;discussPostId&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">public String getDiscussPost(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Model model, Page page) &#123;</span><br><span class="line">    &#x2F;&#x2F; 帖子</span><br><span class="line">    DiscussPost post &#x3D; discussPostService.findDiscussPostById(discussPostId);</span><br><span class="line">    model.addAttribute(&quot;post&quot;, post);</span><br><span class="line">    &#x2F;&#x2F; 作者</span><br><span class="line">    User user &#x3D; userService.findUserById(post.getUserId());</span><br><span class="line">    model.addAttribute(&quot;user&quot;, user);</span><br><span class="line">    &#x2F;&#x2F; 点赞数量</span><br><span class="line">    long likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);</span><br><span class="line">    model.addAttribute(&quot;likeCount&quot;, likeCount);</span><br><span class="line">    &#x2F;&#x2F; 点赞状态</span><br><span class="line">    int likeStatus &#x3D; hostHolder.getUser() &#x3D;&#x3D; null ? 0 :</span><br><span class="line">            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);</span><br><span class="line">    model.addAttribute(&quot;likeStatus&quot;, likeStatus);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 评论分页信息</span><br><span class="line">    page.setLimit(5);</span><br><span class="line">    page.setPath(&quot;&#x2F;discuss&#x2F;detail&#x2F;&quot; + discussPostId);</span><br><span class="line">    page.setRows(post.getCommentCount());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 评论: 给帖子的评论</span><br><span class="line">    &#x2F;&#x2F; 回复: 给评论的评论</span><br><span class="line">    &#x2F;&#x2F; 评论列表</span><br><span class="line">    List&lt;Comment&gt; commentList &#x3D; commentService.findCommentsByEntity(</span><br><span class="line">            ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());</span><br><span class="line">    &#x2F;&#x2F; 评论VO列表</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; commentVoList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (commentList !&#x3D; null) &#123;</span><br><span class="line">        for (Comment comment : commentList) &#123;</span><br><span class="line">            &#x2F;&#x2F; 评论VO</span><br><span class="line">            Map&lt;String, Object&gt; commentVo &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F; 评论</span><br><span class="line">            commentVo.put(&quot;comment&quot;, comment);</span><br><span class="line">            &#x2F;&#x2F; 作者</span><br><span class="line">            commentVo.put(&quot;user&quot;, userService.findUserById(comment.getUserId()));</span><br><span class="line">            &#x2F;&#x2F; 点赞数量</span><br><span class="line">            likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">            commentVo.put(&quot;likeCount&quot;, likeCount);</span><br><span class="line">            &#x2F;&#x2F; 点赞状态</span><br><span class="line">            likeStatus &#x3D; hostHolder.getUser() &#x3D;&#x3D; null ? 0 :</span><br><span class="line">                    likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">            commentVo.put(&quot;likeStatus&quot;, likeStatus);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 回复列表</span><br><span class="line">            List&lt;Comment&gt; replyList &#x3D; commentService.findCommentsByEntity(</span><br><span class="line">                    ENTITY_TYPE_COMMENT, comment.getId(), 0, Integer.MAX_VALUE);</span><br><span class="line">            &#x2F;&#x2F; 回复VO列表</span><br><span class="line">            List&lt;Map&lt;String, Object&gt;&gt; replyVoList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            if (replyList !&#x3D; null) &#123;</span><br><span class="line">                for (Comment reply : replyList) &#123;</span><br><span class="line">                    Map&lt;String, Object&gt; replyVo &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">                    &#x2F;&#x2F; 回复</span><br><span class="line">                    replyVo.put(&quot;reply&quot;, reply);</span><br><span class="line">                    &#x2F;&#x2F; 作者</span><br><span class="line">                    replyVo.put(&quot;user&quot;, userService.findUserById(reply.getUserId()));</span><br><span class="line">                    &#x2F;&#x2F; 回复目标</span><br><span class="line">                    User target &#x3D; reply.getTargetId() &#x3D;&#x3D; 0 ? null : userService.findUserById(reply.getTargetId());</span><br><span class="line">                    replyVo.put(&quot;target&quot;, target);</span><br><span class="line">                    &#x2F;&#x2F; 点赞数量</span><br><span class="line">                    likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, reply.getId());</span><br><span class="line">                    replyVo.put(&quot;likeCount&quot;, likeCount);</span><br><span class="line">                    &#x2F;&#x2F; 点赞状态</span><br><span class="line">                    likeStatus &#x3D; hostHolder.getUser() &#x3D;&#x3D; null ? 0 :</span><br><span class="line">                            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, reply.getId());</span><br><span class="line">                    replyVo.put(&quot;likeStatus&quot;, likeStatus);</span><br><span class="line"></span><br><span class="line">                    replyVoList.add(replyVo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            commentVo.put(&quot;replys&quot;, replyVoList);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 回复数量</span><br><span class="line">            int replyCount &#x3D; commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">            commentVo.put(&quot;replyCount&quot;, replyCount);</span><br><span class="line"></span><br><span class="line">            commentVoList.add(commentVo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(&quot;comments&quot;, commentVoList);</span><br><span class="line"></span><br><span class="line">    return &quot;&#x2F;site&#x2F;discuss-detail&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加评论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">comment.setUserId(hostHolder.getUser().getId());</span><br><span class="line">comment.setStatus(0);</span><br><span class="line">comment.setCreateTime(new Date());</span><br><span class="line">commentService.addComment(comment);</span><br></pre></td></tr></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过滤敏感词</title>
      <link href="/2020/09/07/%E8%BF%87%E6%BB%A4%E6%95%8F%E6%84%9F%E8%AF%8D/"/>
      <url>/2020/09/07/%E8%BF%87%E6%BB%A4%E6%95%8F%E6%84%9F%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>树结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private class TrieNode &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 关键词结束标识</span><br><span class="line">    private boolean isKeywordEnd &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 子节点(key是下级字符,value是下级节点)</span><br><span class="line">    private Map&lt;Character, TrieNode&gt; subNodes &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public boolean isKeywordEnd() &#123;</span><br><span class="line">        return isKeywordEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKeywordEnd(boolean keywordEnd) &#123;</span><br><span class="line">        isKeywordEnd &#x3D; keywordEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 添加子节点</span><br><span class="line">    public void addSubNode(Character c, TrieNode node) &#123;</span><br><span class="line">        subNodes.put(c, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取子节点</span><br><span class="line">    public TrieNode getSubNode(Character c) &#123;</span><br><span class="line">        return subNodes.get(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个敏感词添加到前缀树中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将一个敏感词添加到前缀树中</span><br><span class="line">private void addKeyword(String keyword) &#123;</span><br><span class="line">    TrieNode tempNode &#x3D; rootNode;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; keyword.length(); i++) &#123;</span><br><span class="line">        char c &#x3D; keyword.charAt(i);</span><br><span class="line">        TrieNode subNode &#x3D; tempNode.getSubNode(c);</span><br><span class="line"></span><br><span class="line">        if (subNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 初始化子节点</span><br><span class="line">            subNode &#x3D; new TrieNode();</span><br><span class="line">            tempNode.addSubNode(c, subNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 指向子节点,进入下一轮循环</span><br><span class="line">        tempNode &#x3D; subNode;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置结束标识</span><br><span class="line">        if (i &#x3D;&#x3D; keyword.length() - 1) &#123;</span><br><span class="line">            tempNode.setKeywordEnd(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public String filter(String text) &#123;</span><br><span class="line">    if (StringUtils.isBlank(text)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指针1</span><br><span class="line">    TrieNode tempNode &#x3D; rootNode;</span><br><span class="line">    &#x2F;&#x2F; 指针2</span><br><span class="line">    int begin &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 指针3</span><br><span class="line">    int position &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 结果</span><br><span class="line">    StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    while (position &lt; text.length()) &#123;</span><br><span class="line">        char c &#x3D; text.charAt(position);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 跳过符号</span><br><span class="line">        if (isSymbol(c)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 若指针1处于根节点,将此符号计入结果,让指针2向下走一步</span><br><span class="line">            if (tempNode &#x3D;&#x3D; rootNode) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 无论符号在开头或中间,指针3都向下走一步</span><br><span class="line">            position++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 检查下级节点</span><br><span class="line">        tempNode &#x3D; tempNode.getSubNode(c);</span><br><span class="line">        if (tempNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 以begin开头的字符串不是敏感词</span><br><span class="line">            sb.append(text.charAt(begin));</span><br><span class="line">            &#x2F;&#x2F; 进入下一个位置</span><br><span class="line">            position &#x3D; ++begin;</span><br><span class="line">            &#x2F;&#x2F; 重新指向根节点</span><br><span class="line">            tempNode &#x3D; rootNode;</span><br><span class="line">        &#125; else if (tempNode.isKeywordEnd()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 发现敏感词,将begin~position字符串替换掉</span><br><span class="line">            sb.append(REPLACEMENT);</span><br><span class="line">            &#x2F;&#x2F; 进入下一个位置</span><br><span class="line">            begin &#x3D; ++position;</span><br><span class="line">            &#x2F;&#x2F; 重新指向根节点</span><br><span class="line">            tempNode &#x3D; rootNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 检查下一个字符</span><br><span class="line">            position++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将最后一批字符计入结果</span><br><span class="line">    sb.append(text.substring(begin));</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>登录注册</title>
      <link href="/2020/09/06/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/"/>
      <url>/2020/09/06/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="涉及数据库"><a href="#涉及数据库" class="headerlink" title="涉及数据库"></a>涉及数据库</h2><p>user</p><p><img src="/2020/09/06/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200906203352925.png" alt="image-20200906203352925"></p><p>LoginTicket</p><p><img src="/2020/09/06/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200906215039799.png" alt="image-20200906215039799"></p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map &#x3D; userService.register(user);</span><br></pre></td></tr></table></figure><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String login(String username, String password, String code, boolean rememberme,</span><br><span class="line">                       Model model, HttpServletResponse response,</span><br><span class="line">                       @CookieValue(&quot;kaptchaOwner&quot;) String kaptchaOwner)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map &#x3D; userService.login(username, password, expiredSeconds);</span><br></pre></td></tr></table></figure><h3 id="kaptcha"><a href="#kaptcha" class="headerlink" title="kaptcha"></a>kaptcha</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void getKaptcha(HttpServletResponse response&#x2F;*, HttpSession session*&#x2F;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 生成验证码</span><br><span class="line">        String text &#x3D; kaptchaProducer.createText();</span><br><span class="line">        BufferedImage image &#x3D; kaptchaProducer.createImage(text);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将验证码存入session</span><br><span class="line">        &#x2F;&#x2F; session.setAttribute(&quot;kaptcha&quot;, text);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 验证码的归属</span><br><span class="line">        String kaptchaOwner &#x3D; CommunityUtil.generateUUID();</span><br><span class="line">        Cookie cookie &#x3D; new Cookie(&quot;kaptchaOwner&quot;, kaptchaOwner);</span><br><span class="line">        cookie.setMaxAge(60);</span><br><span class="line">        cookie.setPath(contextPath);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        &#x2F;&#x2F; 将验证码存入Redis</span><br><span class="line">        String redisKey &#x3D; RedisKeyUtil.getKaptchaKey(kaptchaOwner);</span><br><span class="line">        redisTemplate.opsForValue().set(redisKey, text, 60, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将突图片输出给浏览器</span><br><span class="line">        response.setContentType(&quot;image&#x2F;png&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            OutputStream os &#x3D; response.getOutputStream();</span><br><span class="line">            ImageIO.write(image, &quot;png&quot;, os);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            logger.error(&quot;响应验证码失败:&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>验证码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (StringUtils.isNotBlank(kaptchaOwner)) &#123;</span><br><span class="line">    String redisKey &#x3D; RedisKeyUtil.getKaptchaKey(kaptchaOwner);</span><br><span class="line">    kaptcha &#x3D; (String) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) &#123;</span><br><span class="line">    model.addAttribute(&quot;codeMsg&quot;, &quot;验证码不正确!&quot;);</span><br><span class="line">    return &quot;&#x2F;site&#x2F;login&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="UserService"><a href="#UserService" class="headerlink" title="UserService"></a>UserService</h3><p>注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; register(User user)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User u &#x3D; userMapper.selectByName(user.getUsername());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册用户</span><br><span class="line">user.setSalt(CommunityUtil.generateUUID().substring(0, 5));</span><br><span class="line">user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt()));</span><br><span class="line">user.setType(0);</span><br><span class="line">user.setCreateTime(new Date());</span><br><span class="line">userMapper.insertUser(user);</span><br></pre></td></tr></table></figure><p>登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; login(String username, String password, long expiredSeconds)</span><br><span class="line">&#123;</span><br><span class="line">        ....</span><br><span class="line">        Cookie cookie &#x3D; new Cookie(&quot;ticket&quot;, map.get(&quot;ticket&quot;).toString());</span><br><span class="line">        cookie.setPath(contextPath);</span><br><span class="line">        cookie.setMaxAge(expiredSeconds);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        return &quot;redirect:&#x2F;index&quot;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 验证账号</span><br><span class="line">&#x2F;&#x2F; 验证密码</span><br><span class="line">&#x2F;&#x2F; 生成登录凭证</span><br><span class="line">&#x2F;&#x2F; 生成登录凭证</span><br><span class="line">LoginTicket loginTicket &#x3D; new LoginTicket();</span><br><span class="line">loginTicket.setUserId(user.getId());</span><br><span class="line">loginTicket.setTicket(CommunityUtil.generateUUID());</span><br><span class="line">loginTicket.setStatus(0);</span><br><span class="line">loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));</span><br><span class="line">String redisKey &#x3D; RedisKeyUtil.getTicketKey(loginTicket.getTicket());</span><br><span class="line">redisTemplate.opsForValue().set(redisKey, loginTicket);</span><br><span class="line"></span><br><span class="line">map.put(&quot;ticket&quot;, loginTicket.getTicket());</span><br><span class="line">return map;</span><br></pre></td></tr></table></figure><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AlphaInterceptor implements HandlerInterceptor</span><br><span class="line">WebMvcConfig implements WebMvcConfigurer</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 从cookie中获取凭证</span><br><span class="line">    String ticket &#x3D; CookieUtil.getValue(request, &quot;ticket&quot;);</span><br><span class="line"></span><br><span class="line">    if (ticket !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 查询凭证</span><br><span class="line">        LoginTicket loginTicket &#x3D; userService.findLoginTicket(ticket);</span><br><span class="line">        &#x2F;&#x2F; 检查凭证是否有效</span><br><span class="line">        if (loginTicket !&#x3D; null &amp;&amp; loginTicket.getStatus() &#x3D;&#x3D; 0 &amp;&amp; loginTicket.getExpired().after(new Date())) &#123;</span><br><span class="line">            &#x2F;&#x2F; 根据凭证查询用户</span><br><span class="line">            User user &#x3D; userService.findUserById(loginTicket.getUserId());</span><br><span class="line">            &#x2F;&#x2F; 在本次请求中持有用户</span><br><span class="line">            hostHolder.setUser(user);</span><br><span class="line">            &#x2F;&#x2F; 构建用户认证的结果,并存入SecurityContext,以便于Security进行授权.</span><br><span class="line">            Authentication authentication &#x3D; new UsernamePasswordAuthenticationToken(</span><br><span class="line">                    user, user.getPassword(), userService.getAuthorities(user.getId()));</span><br><span class="line">            SecurityContextHolder.setContext(new SecurityContextImpl(authentication));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line">    if (user !&#x3D; null &amp;&amp; modelAndView !&#x3D; null) &#123;</span><br><span class="line">        modelAndView.addObject(&quot;loginUser&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry.addInterceptor(loginTicketInterceptor)</span><br><span class="line">        .excludePathPatterns(&quot;&#x2F;**&#x2F;*.css&quot;, &quot;&#x2F;**&#x2F;*.js&quot;, &quot;&#x2F;**&#x2F;*.png&quot;, &quot;&#x2F;**&#x2F;*.jpg&quot;, &quot;&#x2F;**&#x2F;*.jpeg&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些不常见的面试算法题</title>
      <link href="/2020/08/06/%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2020/08/06/%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li><p>平衡二叉搜索树插入算法</p></li><li><p>对于给定的数据，找出比这个数大的最小回文数（正反读都一样的数），如 12310 -&gt; 12321</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">leetcode 564</span><br><span class="line">public class hello &#123;&#x2F;&#x2F;100 999</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str&#x3D;&quot;271&quot;;</span><br><span class="line"></span><br><span class="line">        int len&#x3D;str.length();</span><br><span class="line">        char[] s&#x3D;str.toCharArray();</span><br><span class="line">        int flag&#x3D;0,i;</span><br><span class="line">        for(i&#x3D;len&#x2F;2-1;i&gt;&#x3D;0;--i)&#123;</span><br><span class="line">            if(s[i]&gt;s[len-1-i])&#123;flag&#x3D;1;break;&#125;</span><br><span class="line">            else if(s[i]&lt;s[len-1-i])&#123; flag&#x3D;-1;break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag!&#x3D;1)&#123;&#x2F;&#x2F;前半串要加1</span><br><span class="line">            &#x2F;&#x2F;s[(len-1)&#x2F;2]++;</span><br><span class="line">            for(i&#x3D;(len-1)&#x2F;2;i&gt;&#x3D;0;--i)&#123;&#x2F;&#x2F;199 191 999</span><br><span class="line">                s[i]++;</span><br><span class="line">                if(s[i]&gt;&#39;9&#39;)&#123;</span><br><span class="line">                    s[i]&#x3D;&#39;0&#39;;</span><br><span class="line">                &#125;else break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(s[0]&#x3D;&#x3D;&#39;0&#39;)&#123;&#x2F;&#x2F;999 9999</span><br><span class="line">                s[0]&#x3D;&#39;1&#39;;</span><br><span class="line">                len++;</span><br><span class="line">                s[len&#x2F;2]&#x3D;&#39;0&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i&#x3D;0;i&lt;len&#x2F;2;++i)</span><br><span class="line">            System.out.print((s[i])+&quot; &quot;);</span><br><span class="line">        for(i&#x3D;(len+1)&#x2F;2-1;i&gt;&#x3D;0;--i)</span><br><span class="line">            System.out.println(s[i]+&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对一个奇数位升序，偶数位降序的链表，进行排序，例如 1-&gt;100-&gt;20-&gt;80-&gt;40-&gt;30</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇偶拆分 反转 合并链表</span><br></pre></td></tr></table></figure></li><li><p>从一个数 l 一直 与 操作到 r ，怎么做最快，复杂度最小</p></li><li><p>输出交错后的链表(比如链表a-b-c-d-e,交错后输出为a-e-b-d-c)</p></li><li><p>请对3个有序数组进行归并排序</p></li></ol><ol start="7"><li><p>掷骰子走路，1～6，给定的输入n，走到第n个格子有多少种走法</p></li><li><p>青蛙跳格子，数组里元素表示该位置石头个数，每次跳3-5格，问跳出数组最少踩多少石头</p></li><li><p>.给一个正整数，表示成一个或多个不同的正整数的和，输出所有的解决方案</p></li><li><p>找出数组里出现次数大于n/k的数</p></li><li><p>给一个矩阵，从右上角往左下角一层一层斜着遍历</p></li><li><p>一个int数组，找出两个异或最大的数字，时间要求O(n)</p></li><li><p>四个int数组，从每个数组里边挑一个数，加起来等于指定数，要求打印出所有非重复的组合，要求最大n2</p></li><li><p>查找有序数组中一个目标值出现的第一次位置，没有找到返回 -1</p></li><li><p>二分查找在升序数组中找出绝对值最小的那个数</p></li><li><p>给定一个包含大写英文字母和数字的句子，找出这个句子所包含的最大的十六进制整数，返回这个整数的值。数据保证该整数在int表示范围内</p></li><li><p>字符串数组两个字符串的最小距离</p></li><li><p>实现洗牌算法</p></li><li><p>单链表高位在前、低位在后，大数计算</p></li><li><p>阶乘</p></li><li><p>合并数组</p></li><li><p>一道矩阵相乘</p></li><li><p>求连续子序列乘积为完全平方数的最大长度</p></li><li><p>定一个升序数组，可能会有重复的数字，将数组里的数平方后，有多少不同的数</p></li><li><p>:两个大数字符串求和输出字符串</p></li><li><p>任意数组中的第一个缺失的正整数</p></li><li><p>字符串反转</p></li><li><p>.给你一个数组和一个target，找出和是target整数倍的连续子串</p></li><li><p>I am student 返回 student am I 不用split</p></li><li><p>给一个分数n/m，如果这个分数是无线循环小数，找出循环位。</p></li><li><p>排序数组，平方后，数组当中有多少不同的数字（相同算一个）</p></li><li><p>一个数据先递增再递减，找出数组不重复的个数，比如 [1, 3, 9, 1]，结果为3，不能使用额外空间，复杂度o(n)</p></li><li><p>某一个大文件被拆成了N个小文件，每个小文件编号从0至N-1，相应大小分别记为S(i)。给定磁盘空间为C，试实现一个函数从N个文件中连续选出若干个文件拷贝到磁盘中，使得磁盘剩余空间最小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ol><ol start="34"><li><p>给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3</p></li><li><p>算法题，一个有序数组，从随机一位截断，把前段放在后边，如 4 5 6 7 1 2 3求中位数</p></li><li><p>链表实现一个栈</p></li><li><p>求完全二叉树的节点个数，小于O(n)，并分析复杂度</p></li><li><p>写一个函数，求平方根，函数参数为目标数字和精度，测试案例 fn(4.1,0.001) fn(501.1,0.001) fn(0.045,0.001)</p></li><li><p>给定一个 0-4随机数生成器 如何生成0-6随机数</p></li><li><p>中文数字转阿拉伯数字，字符串处理问题</p><p>中文数字格式：一万三千五百四十一      </p><p>阿拉伯数字格式：13541      </p><p>中文数字中要分单位和数字分别处理，可以用两个数组分别保存中文数字和中文单位，每次循环扫描给的中文数字，去匹配对应的数字。中文数字数字可以用数组下标对应数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">   static char[] cnArr &#x3D; &#123;&#39;零&#39;,&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;&#125;;</span><br><span class="line">   static char[] chArr &#x3D; &#123;&#39;十&#39;, &#39;百&#39;, &#39;千&#39;, &#39;万&#39;, &#39;亿&#39;&#125;;</span><br><span class="line">public static int chineseNumToArabicNum(String chineseNum) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    int temp &#x3D; 1;&#x2F;&#x2F;存放一个单位的数字如：十万</span><br><span class="line">    int count &#x3D; 0;&#x2F;&#x2F;判断是否有表示单位的文字</span><br><span class="line">    for (int i &#x3D; 0; i &lt; chineseNum.length(); i++) &#123;</span><br><span class="line">        boolean b &#x3D; true;&#x2F;&#x2F;判断是否是单位</span><br><span class="line">        char c &#x3D; chineseNum.charAt(i);</span><br><span class="line">        for (int j &#x3D; 0; j &lt; cnArr.length; j++) &#123;&#x2F;&#x2F;非单位，即数字</span><br><span class="line">            if (c &#x3D;&#x3D; cnArr[j]) &#123;</span><br><span class="line">                if (count !&#x3D; 0) &#123;&#x2F;&#x2F;添加下一个单位之前，先把上一个单位值添加到结果中</span><br><span class="line">                    result +&#x3D; temp;</span><br><span class="line">                    temp &#x3D; 1;</span><br><span class="line">                    count &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 下标+1，就是对应的值</span><br><span class="line">                temp &#x3D; j;</span><br><span class="line">                b &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (b) &#123;&#x2F;&#x2F;单位&#123;&#39;十&#39;,&#39;百&#39;,&#39;千&#39;,&#39;万&#39;,&#39;亿&#39;&#125;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; chArr.length; j++) &#123;</span><br><span class="line">                if (c &#x3D;&#x3D; chArr[j]) &#123;</span><br><span class="line">                    switch (j) &#123;</span><br><span class="line">                        case 0:</span><br><span class="line">                            temp *&#x3D; 10;</span><br><span class="line">                            break;</span><br><span class="line">                        case 1:</span><br><span class="line">                            temp *&#x3D; 100;</span><br><span class="line">                            break;</span><br><span class="line">                        case 2:</span><br><span class="line">                            temp *&#x3D; 1000;</span><br><span class="line">                            break;</span><br><span class="line">                        case 3:</span><br><span class="line">                            temp *&#x3D; 10000;</span><br><span class="line">                            break;</span><br><span class="line">                        case 4:</span><br><span class="line">                            temp *&#x3D; 100000000;</span><br><span class="line">                            break;</span><br><span class="line">                        default:</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &#x3D;&#x3D; chineseNum.length() - 1) &#123;&#x2F;&#x2F;遍历到最后一个字符</span><br><span class="line">            result +&#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三个线程循环打印ABC**</p></li><li><pre><code>public class hello {    //1-&gt;100-&gt;20-&gt;80-&gt;40-&gt;30    1-&gt;20-30-&gt;40-&gt;80-&gt;100    static class ListNode    {        int val;        ListNode(int x)        {            val=x;        }        ListNode next;    }    public static void main(String[] args) {        ListNode l1=new ListNode(1);        ListNode l2=new ListNode(100);        ListNode l3=new ListNode(20);        ListNode l4=new ListNode(80);        l1.next=l2;        l2.next=l3;        l3.next=l4;        l4.next=null;//        while(l1!=null)//        {//            System.out.println(l1.val);//            l1=l1.next;//        }        help(l1);        while(l1!=null)        {            System.out.println(l1.val);            l1=l1.next;        }    }    public static ListNode help(ListNode head)    {        if(head==null || head.next==null)        {            return head;        }        ListNode h1=head,t1=head;        ListNode h2=head.next,t2=h2;        while(t1.next!=null &amp;&amp; t2.next!=null)        {            t1.next=t2.next;            t1=t1.next;            t2.next=t1.next;            t2=t2.next;        }        t1.next=null;        ListNode temp=reverse(h2);        ListNode res=mergeTwoLists(temp,h1);        return res;    }    public static ListNode reverse(ListNode head)    {       if(head==null || head.next==null) return head;       ListNode temp=reverse(head.next);       head.next.next=head;       head.next=null;       return temp;    }    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {        if(l1==null) return l2;        if(l2==null) return l1;        ListNode dummy=new ListNode(0);        ListNode curr=dummy;        ListNode p=l1,q=l2;        while(p!=null&amp;&amp;q!=null)        {            int x=p.val;            int y=q.val;            if(x&lt;y)            {                curr.next=p;                p=p.next;            }            else            {                curr.next=q;                q=q.next;            }            curr=curr.next;        }        if(p!=null) curr.next=p;        if(q!=null) curr.next=q;        return dummy.next;    }}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">43. **平方后，数组当中有多少不同的数字**</span><br></pre></td></tr></table></figure>public class Solution {public int diffSquareNum(int nums[]) {    int n = nums.length;    if(n == 0 || nums == null){        return 0;    }    int sum = 0;    int left = 0;    int right = n - 1;    while(left &lt;= right){        if(nums[left] + nums[right] == 0){            sum++;            int temp = nums[left];            //这里开始去掉后面重复的数字            while(left &lt;= right &amp;&amp; nums[left] == temp)                left++;            while(left &lt;= right &amp;&amp; nums[right] == -temp)                right--;        }        else if(nums[left] + nums[right] &lt; 0){            sum++;            int temp = nums[left];            while(left &lt;= right &amp;&amp; nums[left] == temp)                left++;        }        else {            sum++;            int temp = nums[right];            while(left &lt;= right &amp;&amp; nums[right] == temp)                right--;        }    }    return sum;}}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">43</span><br><span class="line"></span><br><span class="line">给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，</span><br></pre></td></tr></table></figure>public class hello {public static void main(String[] args) {char[] c={&apos;a&apos;,&apos;c&apos;,&apos;b&apos;,&apos;d&apos;};String s=&quot;tbcacbdata&quot;;int res=help(c,s);System.out.println(res);}public static int help(char[] ch,String s){    if(ch.length &gt; s.length()){        return -1;    }    for(int i = 0; i &lt;= s.length() - ch.length+1; i++){        //每次匹配长度为m的子串        if(matchs(ch,s.substring(i,i+ch.length)))            return i;    }    return -1;}private static boolean matchs(char[] ch,String s){    for(int i = 0; i &lt; s.length();i++){        //返回-1说明字符串中不包含这个字符        if(s.indexOf(ch[i]) == -1)            return false;    }    return true;}</code></pre></li></ol><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">44.一个有序数组，从随机一位截断，把前段放在后边，如 4 5 6 7 1 2 3求中位数</span><br></pre></td></tr></table></figure><p>public class findNumInRotateArr {</p><pre><code>public static double minNumberInRotateArray(int[] nums) {    if (nums == null || nums.length == 0) {        return 0;    }    int left = 0;    int right = nums.length - 1;    while (left &lt; right) {        int mid = left + ((right - left) &gt;&gt; 1);        if (nums[mid] &lt; nums[right]) {            right = mid;        } else if (nums[mid] &gt; nums[right]) {            left = mid + 1;        } else {            right--;        }    }    int size = nums.length;    if (size % 2 == 1) {        return nums[(left + size / 2) % size];    } else {        return (double) (nums[(left + size / 2) % size] + nums[(left + (size - 1) / 2) % size]) / 2;    }}public static void main(String[] args) {    int[] arr = {6, 7, 8, 1, 2, 3, 4, 5};    System.out.println(minNumberInRotateArray(arr));}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">45.给定一个未排序的整数数组，找出最长连续序列的长度。</span><br><span class="line"></span><br><span class="line">要求算法的时间复杂度为 *O(n)*。</span><br></pre></td></tr></table></figure><p>输入: [100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">46.高考成绩2000万数据，分数0-750，如何快速知道你的排名，如何知道任一分数排名 ---&gt;桶排序</span><br><span class="line"></span><br><span class="line">桶[排序]()    (Bucket sort)的工作的原理：假设输入数据   服从均匀分布   ，将数据分到有限数量的桶里，每个桶再分别[排序]()（有可能再使用别的[排序]()[算法]()或是以递归方式继续使用桶[排序]()进行排）。   </span><br><span class="line"></span><br><span class="line">​    [算法]()描述：   </span><br><span class="line"></span><br><span class="line">​    设置一个定量的数组当作空桶；   </span><br><span class="line"></span><br><span class="line">​    遍历输入数据，并且把数据一个一个放到对应的桶里去；   </span><br><span class="line"></span><br><span class="line">​    对每个不是空的桶进行[排序]()；   </span><br><span class="line"></span><br><span class="line">​    从不是空的桶里把排好序的数据拼接起来。</span><br></pre></td></tr></table></figure><p>public class Solution {<br>    public ArrayList<Integer> bucketSort(int[] scores){<br>      //先确定最大最小值，来确定范围<br>      int max = Integer.MIN_VALUE;<br>      int min = Integer.MAX_VALUE;<br>      for(int i = 0; i &lt; scores.length;i++){<br>          max = Math.max(max,scores[i]);<br>          min = Math.min(min,scores[i]);<br>      }<br>      //计算出桶数<br>      //int bucketNum = (max - min)/scores.length + 1;<br>      //这里直接给出751个桶<br>      int bucketNum = 751;<br>      ArrayList&lt;ArrayList<Integer>&gt; list = new ArrayList&lt;&gt;(bucketNum);<br>      for(int i = 0; i &lt; bucketNum; i++){<br>          list.add(new ArrayList<Integer>());<br>      }</Integer></Integer></Integer></p><pre><code>  //将每个元素放入桶  for(int i = 0; i &lt; scores.length;i++){      //本题中这里放元素也可以简化      //list.get((scores[i] - min)/bucketNum).add(scores[i]);      list.get(scores[i]).add(scores[i]);  }  //桶内排序,本题中可以省略这一步  for(int i = 0; i&lt; list.size();i++){      Collections.sort(list.get(i));  }   return list;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">47.</span><br><span class="line"></span><br><span class="line">**最大栈（最小栈）**</span><br></pre></td></tr></table></figure><p>使用辅助栈：<br>public class MaxStack{<br>    private Stack<Integer> stack;<br>    private Stack<Integer> helper;<br>    public MaxStack(){<br>        stack = new Stack&lt;&gt;();<br>        helper = new Stack&lt;&gt;();<br>    }<br>    public void push(int x) {<br>        if(helper.isEmpty() || helper.peek() &lt;= x){<br>            helper.push(x);<br>        }<br>        stack.push(x);<br>    }<br>    public void pop(){<br>        if(stack.peek() == helper.peek()){<br>            helper.pop();<br>        }<br>        stack.pop();<br>    }<br>    public int peek(){<br>        if(!helper.isEmpty()){<br>            return stack.peek();<br>        }<br>        throw new RuntimeException(“栈中元素为空”);</Integer></Integer></p><pre><code>}public int getMax(){    if(!helper.isEmpty()){        return helper.peek();    }    throw new RuntimeException(&quot;最大值栈中元素为空&quot;);}</code></pre><p>}<br>用最大值标记，存入数据栈中，空间复杂度降到O(1)<br>public class MaxStack {<br>    private Stack<Integer> stack;<br>    public MaxStack(){<br>        stack = new Stack&lt;&gt;();<br>    }<br>    int max = Integer.MIN_VALUE;<br>    public void push(int x){<br>        if(max &lt;= x){<br>            if(!stack.isEmpty()){<br>                stack.push(max);<br>            }<br>            max = x;<br>        }<br>        stack.push(x);<br>    }<br>    public void pop(){<br>        if(stack.peek() == max){<br>            stack.pop();<br>            max = stack.pop();<br>        }else{<br>            stack.pop();<br>        }<br>    }<br>    public int getMax(){<br>        return max;<br>    }<br>}</Integer></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">48. 链表实现一个栈</span><br></pre></td></tr></table></figure><p>public class ListNode{<br>    int val;<br>    ListNode next;<br>    ListNode(int val){<br>        this.val =val;<br>    }<br>}<br>public class ListToStack{<br>    public ListToStack(){<br>        ListNode head;<br>    }<br>    public void push(int x){<br>        ListNode node = new ListNode(x);<br>        node.next = head.next;<br>        head.next = node;<br>    }<br>    public int pop(){<br>        ListNode node = head.next;<br>        head.next = node.next;<br>        node.next = null;<br>        return node.val;<br>    }<br>    public int peek(){<br>        return head.next.val;<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 48.一个形如 123456789101112……的字符串，输入一个n（很大很大），输出字符串第n个字符</span><br><span class="line"></span><br><span class="line">## 49.版本数字比较，比如&quot;1.10.0&quot;版本比&quot;1.8.1&quot;版本新，不允许使用split等函数</span><br><span class="line"></span><br><span class="line">## 50.中缀表达式转后缀</span><br><span class="line"></span><br><span class="line">1、任何中缀表达式都由运算数，运算符，括号（大，中，小），这三部分组成。</span><br><span class="line"></span><br><span class="line">2、从中缀表达式的左边开始扫描（脑中自己想像的），若遇到运算数时，则直接将其输出（不压入堆栈）。</span><br><span class="line"></span><br><span class="line">3、若遇到左括号，则将其压栈。</span><br><span class="line"></span><br><span class="line">4、若遇到右括号，表达括号内的中缀表达式已经扫描完毕。这时需将栈顶的运算符依次弹出并输出，直至遇到左括号[左括号弹出但不输出]。</span><br><span class="line"></span><br><span class="line">5、若遇到的是运算符：a、如果该运算符的优先级大于栈顶运算符的优先级时，将其压栈</span><br><span class="line"></span><br><span class="line">​                  b、如果该运算符的优先级小于栈顶运算符的优先级时，将栈顶运算符弹出并输出，接着和新的栈顶运算 符比较，若大于，则将其压栈，若小于，继续将栈顶运算符弹出并输出......(一直递归下去，直至运算符大于栈顶云算符为止)。</span><br><span class="line"></span><br><span class="line">6、最后一步，若扫描到中缀表达式的末尾[即扫描结束]，若堆栈中还有存留的运算符依次弹出并输出即可。</span><br></pre></td></tr></table></figure><p>public class hello {//100 999</p><pre><code>public static void calculate(String string) {    Stack&lt;String&gt; operator = new Stack&lt;&gt;();//操作符栈    List&lt;String&gt; list = new ArrayList&lt;&gt;();//结果集    char[] s = string.toCharArray();    //遍历表达式    // 1+(2-4*3)    // 1 2 4 3 * - +    // 1+(2-4*3)*5    // 1 2 4 3 * - +5-    for (int i = 0; i &lt; s.length; i++) {        if (s[i] == &apos; &apos;)            continue;        if (s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;){            StringBuilder stringBuilder = new StringBuilder();            while (i &lt; s.length &amp;&amp; s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;){                stringBuilder.append(s[i]);                i++;            }            i--;            list.add(stringBuilder.toString());        }//正则表达式匹配数字，对应思路1        else if (s[i] == &apos;(&apos;){//对应思路2            operator.push(String.valueOf(s[i]));        }else if (s[i] == &apos;)&apos;){//对应思路3            while (!operator.peek().equals(&quot;(&quot;)){                list.add(operator.pop());            }            operator.pop();        }else{//对应思路4            while (!operator.isEmpty() &amp;&amp; priority(operator.peek()) &gt;= priority(String.valueOf(s[i]))){                list.add(operator.pop());            }            operator.push(String.valueOf(s[i]));        }    }    // 1+(2-4*3)  1 2 4 3 * - +    // 1+(2*4-3)  1 2 4 * 3 - +    while (!operator.isEmpty())        list.add(operator.pop());    System.out.println(list.size());</code></pre><p>//        Stack<Integer> nums = new Stack&lt;&gt;();<br>//        for (int i = 0; i &lt; list.size(); i++) {<br>//            if (list.get(i).equals(“+”)){<br>//                nums.push(nums.pop() + nums.pop());<br>//            }else if (list.get(i).equals(“-“)){<br>//                nums.push(-(nums.pop() - nums.pop()));<br>//            }else if (list.get(i).equals(“*”)){<br>//                nums.push(nums.pop() * nums.pop());<br>//            }else if (list.get(i).equals(“/“)){<br>//                int num1 = nums.pop();<br>//                int num2 = nums.pop();<br>//                nums.push(num2 / num1);<br>//            } else<br>//                nums.push(Integer.parseInt(list.get(i)));<br>//        }<br>//<br>//        return nums.pop();//弹出栈中元素返回结果<br>    }<br>    //计算符优先级<br>    private static int priority(String oper){<br>        if (oper.equals(“+”) || oper.equals(“-“))<br>            return 0;<br>        else if (oper.equals(“*”) || oper.equals(“/“))<br>            return 1;<br>        else return -1;<br>    }<br>    public static void main(String[] args) {<br>    String s=”1+(2*4-3)”;<br>    calculate(s);<br>    }<br>}</Integer></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 51.滑动窗口</span><br><span class="line"></span><br><span class="line">某一个大文件被拆成了N个小文件，每个小文件编号从0至N-1，相应大小分别记为S(i)。给定磁盘空间为C，试实现一个函数从N个文件中连续选出若干个文件拷贝到磁盘中，使得磁盘剩余空间最小。 </span><br><span class="line"></span><br><span class="line">滑动窗口   ：每次记录窗口内的总和，和小于C，记录剩余空间，再窗口右端右移，和大于C，就窗口左端右移，小于C情况下比较剩余空间取最小值。</span><br></pre></td></tr></table></figure><p>public class Solution {<br>    public int[] findMin(int[] s,int c){<br>        int i = 0;<br>        int j = 0;<br>        int minValue = Integer.MAX_VALUE;<br>        int sum = 0;<br>        int left = 0;<br>        int right = 0;<br>        while(j &lt;= s.length){<br>            if(sum &lt;= c){<br>               j++;<br>               sum += s[j];<br>               minValue = Math.min(minValue,c - sum);<br>               if(minValue == c - sum){<br>                   left = i;<br>                   right = j;<br>               }<br>            }else{<br>                i++;<br>                sum -= s[i];<br>            }<br>        }<br>        int nums = new int[right - left];<br>        for(int k = left;k &lt; right;k++){<br>            nums[k - left] = s[k];<br>        }<br>        return nums;<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">52.求有序链表的中位数</span><br></pre></td></tr></table></figure><p>public class Test {<br>    //【快慢指针————求一个有序链表的中位数】<br>    public static double sortedListMedian(ListNode head) {<br>        if(head == null)<br>            System.out.println(“链表不能为空！”);<br>        ListNode slow = head, fast = head;<br>        while(fast.next != null &amp;&amp; fast.next.next != null) {<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        }<br>        if(fast.next == null)       //说明链表有奇数个节点，此时slow正好是中位数<br>            return slow.val * 1.0;<br>        else                        //说明链表有偶数个节点，此时(slow+slow.next)/2是中位数<br>            return (slow.val + slow.next.val) / 2.0;<br>    }</p><pre><code>//返回由一个数组生成的链表的头结点private static ListNode makeListByArray(int[] array) {    ListNode dummyHead = new ListNode(-1);    ListNode cur = dummyHead;    for (int i = 0; i &lt; array.length; i++) {        cur.next = new ListNode(array[i]);        cur = cur.next;    }    return dummyHead.next;}//主函数public static void main(String[] args) {    int[] array = {0,1,2,3,4,5};    ListNode head = makeListByArray(array);    double ans = sortedListMedian(head);    System.out.println(ans);}</code></pre><p>}</p><p>// 链表节点定义<br>class ListNode {<br>    int val;<br>    ListNode next;</p><pre><code>public ListNode(int val, ListNode next) {    this.val = val;    this.next = next;}public ListNode(int val) {    this(val,null);}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">53.**题目：合并K个有序数组</span><br></pre></td></tr></table></figure><p>输入: [[1,2,3], [1,2]]<br>输出: [1,1,2,2,3]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 O(N log k) 的时间复杂度内完成：*N* 是所有数组包含的整数总数量。***k\* 是数组的个数**。</span><br><span class="line"></span><br><span class="line">解法：N个数组进行两两合并，合并后的数组再继续执行合并过程，最后合成N*M的有序数组。可以认为合并这个递归过程发生了logN次，每一次合并的过程都是N*M个数合并，所以每一次合并的时间复杂度为N*M,总的时间复杂度就是N*M*logN</span><br></pre></td></tr></table></figure><p>public class hello {//100 999</p><pre><code>public static void main(String[] args) {    int[][] arr={{1,2,3},{5,6},{3,4},{1,3}};    int[] res=mergekSortedArrays(arr);    System.out.println(res);}public static int[] mergekSortedArrays(int[][] arrays) {    // write your code here    if(arrays == null || arrays.length == 0)        return null;    return helper(arrays, 0, arrays.length-1);}private static int[] helper(int[][] arrays, int l, int r){    int mid = l + (r-l)/2;    if(l&lt;r)    {        int[] left = helper(arrays, l, mid);        int[] right = helper(arrays, mid+1, r);        return merge2Arrays(left, right);    }    return arrays[l];}private static int[] merge2Arrays(int[] a, int[] b){    int[] res = new int[a.length + b.length];    int i=0, j=0;    for(int k=0; k&lt;res.length; k++){        if(i &gt;= a.length)            res[k] = b[j++];        else if(j &gt;= b.length)            res[k] = a[i++];        else if(a[i] &lt; b[j])            res[k] = a[i++];        else            res[k] = b[j++];    }    return res;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class Solution {<br>    /**<br>     * @param arrays: k sorted integer arrays<br>     * @return: a sorted array<br>     */<br>    public int[] mergekSortedArrays(int[][] arrays) {<br>        // write your code here<br>            if(arrays == null || arrays.length == 0)<br>                return null;</p><pre><code>        return helper(arrays, 0, arrays.length-1);}private int[] helper(int[][] arrays, int l, int r){    if(l == r)        return arrays[l];    if(l + 1 == r)        return merge2Arrays(arrays[l], arrays[r]);    int mid = l + (r-l)/2;    int[] left = helper(arrays, l, mid);    int[] right = helper(arrays, mid+1, r);    return merge2Arrays(left, right);}private int[] merge2Arrays(int[] a, int[] b){    int[] res = new int[a.length + b.length];    int i=0, j=0;    for(int k=0; k&lt;res.length; k++){        if(i &gt;= a.length)            res[k] = b[j++];        else if(j &gt;= b.length)            res[k] = a[i++];        else if(a[i] &lt; b[j])            res[k] = a[i++];        else            res[k] = b[j++];    }    return res;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">54.无序数组有多少个和为K的子数组</span><br></pre></td></tr></table></figure><p>双指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">55.因子分解</span><br><span class="line"></span><br><span class="line">给一个正数N，求这个N的所有的因子分解；</span><br><span class="line"></span><br><span class="line">N &#x3D; 12；</span><br><span class="line"></span><br><span class="line">Ans &#x3D; &#123;12&#125;,&#123;6,2&#125;,&#123;3,4&#125;,&#123;3,2,2&#125;</span><br><span class="line"></span><br><span class="line">解法：递归</span><br></pre></td></tr></table></figure><p>package backtracking;</p><p>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.List;</p><p>// <a href="https://leetcode.com/problems/factor-combinations/" target="_blank" rel="noopener">https://leetcode.com/problems/factor-combinations/</a><br>public class FactorCombinations {</p><p>  public static void main(String[] args) {<br>    FactorCombinations obj = new FactorCombinations();<br>    int n = 12;<br>    List&lt;List<Integer>&gt; resultList = obj.getFactors(12);<br>    System.out.println(Arrays.toString(resultList.toArray()));<br>  }</Integer></p><p>  public List&lt;List<Integer>&gt; getFactors(int n) {<br>    List&lt;List<Integer>&gt; resultList = new ArrayList&lt;List<Integer>&gt;();<br>    // DFS<br>    dfs(resultList, new ArrayList<Integer>(), n, 2);<br>    //dfs1(resultList, new ArrayList<Integer>(), n, 2);</Integer></Integer></Integer></Integer></Integer></p><pre><code>return resultList;</code></pre><p>  }</p><p>  private void dfs(List&lt;List<Integer>&gt; resultList, List<Integer> list, int n, int start) {<br>    // exit<br>    if (n == 1) {<br>      if (list.size() &gt; 1) {<br>        resultList.add(new ArrayList<Integer>(list));<br>      }</Integer></Integer></Integer></p><pre><code>  return;}for (int i = start; i &lt;= n; i++) {  if (n % i == 0) {    list.add(i);    dfs(resultList, list, n / i, i);    list.remove(list.size() - 1);  }}</code></pre><p>  }</p><p>}</p><p>```</p><p>56.有一个日志文件，记录用户登录抖音、登出抖音的时间，求每一时刻在线人数 </p><p>   格式为uid login_time logout_time  </p><p>   输入: logs = [[1, 0, 5], [2, 0, 6], [3, 0, 3], [4, 1, 2], [5, 1, 3], [6, 2, 3], [7, 3, 4], [8, 4, 6]]  </p><p>   输出: [3, 5, 5, 3, 3, 2, 0]（我只写了O(N*M),要求时间复杂夫O(N),还没想到解法，面试官最后说可以用<a href>动态规划</a>）</p><ol start="57"><li>String的ip地址转int？</li></ol><p><a href="https://www.nowcoder.com/jump/super-jump/word?word=算法题" target="_blank" rel="noopener">算法题</a>，实现 一个IP地址（10.101.102.103）转成int类型数据。 （IP地址是32个比特，int也是32个比特）</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>投票法</title>
      <link href="/2020/08/05/%E6%8A%95%E7%A5%A8%E6%B3%95/"/>
      <url>/2020/08/05/%E6%8A%95%E7%A5%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一半"><a href="#一半" class="headerlink" title="一半"></a>一半</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int majorityElement(int[] nums) &#123;</span><br><span class="line">    int major&#x3D;nums[0];</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line">    for(int num:nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if(major&#x3D;&#x3D;num)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(count&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            major&#x3D;num;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return major;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3"><a href="#1-3" class="headerlink" title="1/3"></a>1/3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; majorityElement(int[] nums) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">        首先可以明确的一点是，这样的元素可能有0个、1个、或者2个，再没有别的情况了. </span><br><span class="line">        然后，求众数I 里的 Boyer-Moore 算法思路在这里依然可用，但需要些改动：</span><br><span class="line">        1) 满足条件的元素最多有两个，那么需要两组变量. count, major变成了</span><br><span class="line">           count1, major1; count2, major2;</span><br><span class="line">        2) 选出的两个元素，需要验证它们的出现次数是否真的满足条件.</span><br><span class="line">        **&#x2F;</span><br><span class="line">        List&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if(nums.length &lt; 1) return ret;</span><br><span class="line">        int count1 &#x3D; 0, count2 &#x3D; 0;</span><br><span class="line">        int major1 &#x3D; nums[0], major2 &#x3D; nums[0];</span><br><span class="line">        for(int num : nums) &#123;</span><br><span class="line">            if(num &#x3D;&#x3D; major1)</span><br><span class="line">                count1++;</span><br><span class="line">            else if(num &#x3D;&#x3D; major2)</span><br><span class="line">                count2++;</span><br><span class="line">            else if(count1 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                count1 &#x3D; 1;</span><br><span class="line">                major1 &#x3D; num;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(count2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                count2 &#x3D; 1;</span><br><span class="line">                major2 &#x3D; num;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count1 &#x3D; 0;</span><br><span class="line">        count2 &#x3D; 0;</span><br><span class="line">        for(int num : nums) &#123;</span><br><span class="line">            if(num &#x3D;&#x3D; major1)</span><br><span class="line">                count1++;</span><br><span class="line">            else if(num &#x3D;&#x3D; major2)</span><br><span class="line">                count2++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count1 &gt; nums.length&#x2F;3)</span><br><span class="line">            ret.add(major1);</span><br><span class="line">        if(major1 !&#x3D; major2 &amp;&amp; count2 &gt; nums.length&#x2F;3)</span><br><span class="line">            ret.add(major2);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="n-k"><a href="#n-k" class="headerlink" title="n/k"></a>n/k</h2><p>左神的代码写的很好，时间复杂度是O(N*K)，额外空间复杂度O(K)，用map集合保存K个不同的值。一、如果map的大小不超过K，遍历到相同的，value加1，不同的，添加进去。用map.containskey判断是否在容器中，比用数组方便。<br>二、如果map大小达到K，遍历到相同的，所有键的值减1，如果值变成0，要删除。这时候引出一全体键值都减1的函数，左神用了遍历map，如果要删除的键放进一个链表里。<br>三、判断map中剩下的值出现次数是否大于N/K</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class hello &#123;&#x2F;&#x2F;100 999</span><br><span class="line">    public static void printKMajor(int[] arr, int K) &#123;</span><br><span class="line">        if (K &lt; 2) &#123;</span><br><span class="line">            System.out.println(&quot;the value of K is invalid.&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; cands &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i !&#x3D; arr.length; i++) &#123;</span><br><span class="line">            if (cands.containsKey(arr[i])) &#123;</span><br><span class="line">                cands.put(arr[i], cands.get(arr[i]) + 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (cands.size() &#x3D;&#x3D; K - 1) &#123;</span><br><span class="line">                    allCandsMinusOne(cands);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cands.put(arr[i], 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; reals &#x3D; getReals(arr, cands);</span><br><span class="line">        boolean hasPrint &#x3D; false;</span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; set : cands.entrySet()) &#123;</span><br><span class="line">            Integer key &#x3D; set.getKey();</span><br><span class="line">            if (reals.get(key) &gt; arr.length &#x2F; K) &#123;</span><br><span class="line">                hasPrint &#x3D; true;</span><br><span class="line">                System.out.print(key + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(hasPrint ? &quot;&quot; : &quot;no such number.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void allCandsMinusOne(HashMap&lt;Integer, Integer&gt; map) &#123;</span><br><span class="line">        List&lt;Integer&gt; removeList &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; set : map.entrySet()) &#123;</span><br><span class="line">            Integer key &#x3D; set.getKey();</span><br><span class="line">            Integer value &#x3D; set.getValue();</span><br><span class="line">            if (value &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                removeList.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (Integer removeKey : removeList) &#123;</span><br><span class="line">            map.remove(removeKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HashMap&lt;Integer, Integer&gt; getReals(int[] arr,</span><br><span class="line">                                                     HashMap&lt;Integer, Integer&gt; cands) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; reals &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i !&#x3D; arr.length; i++) &#123;</span><br><span class="line">            int curNum &#x3D; arr[i];</span><br><span class="line">            if (cands.containsKey(curNum)) &#123;</span><br><span class="line">                reals.put(curNum,reals.getOrDefault(curNum,0)+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return reals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123; 1, 2, 3, 1, 1, 2, 1 &#125;;</span><br><span class="line">        int K &#x3D; 4;</span><br><span class="line">        printKMajor(arr, K);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树相关操作</title>
      <link href="/2020/07/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/07/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static TreeNode stringToTreeNode(String input) &#123;</span><br><span class="line">    input &#x3D; input.trim();</span><br><span class="line">    if (input.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] parts &#x3D; input.split(&quot;,&quot;);</span><br><span class="line">    String item &#x3D; parts[0];</span><br><span class="line">    TreeNode root &#x3D; new TreeNode(Integer.parseInt(item));</span><br><span class="line">    Queue&lt;TreeNode&gt; nodeQueue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    nodeQueue.add(root);</span><br><span class="line">    int index &#x3D; 1;</span><br><span class="line">    while(!nodeQueue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node &#x3D; nodeQueue.remove();</span><br><span class="line"></span><br><span class="line">        if (index &#x3D;&#x3D; parts.length) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        item &#x3D; parts[index++];</span><br><span class="line">        item &#x3D; item.trim();</span><br><span class="line">        if (!item.equals(&quot;null&quot;)) &#123;</span><br><span class="line">            int leftNumber &#x3D; Integer.parseInt(item);</span><br><span class="line">            node.left &#x3D; new TreeNode(leftNumber);</span><br><span class="line">            nodeQueue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (index &#x3D;&#x3D; parts.length) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        item &#x3D; parts[index++];</span><br><span class="line">        item &#x3D; item.trim();</span><br><span class="line">        if (!item.equals(&quot;null&quot;)) &#123;</span><br><span class="line">            int rightNumber &#x3D; Integer.parseInt(item);</span><br><span class="line">            node.right &#x3D; new TreeNode(rightNumber);</span><br><span class="line">            nodeQueue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内部类</title>
      <link href="/2020/07/24/Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2020/07/24/Java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>内部类可对同一包中其他类隐藏，内部类方法可以访问定义这个内部类的作用域中的数据，包括 private 数据。</p><p>内部类是一个编译器现象，与虚拟机无关。编译器会把内部类转换成常规的类文件，用 $ 分隔外部类名与内部类名，其中匿名内部类使用数字编号，虚拟机对此一无所知。</p><p><strong>静态内部类：</strong> 属于外部类，只加载一次。作用域仅在包内，可通过 <code>外部类名.内部类名</code> 直接访问，类内只能访问外部类所有静态属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class ClassOuter &#123;</span><br><span class="line">    private int noStaticInt &#x3D; 1;</span><br><span class="line">    private static int STATIC_INT &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    public void fun() &#123;</span><br><span class="line">        System.out.println(&quot;外部类方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class InnerClass &#123;</span><br><span class="line">        &#x2F;&#x2F;static int num &#x3D; 1; 此时编辑器会报错 非静态内部类则不能有静态成员</span><br><span class="line">        public void fun()&#123;</span><br><span class="line">            &#x2F;&#x2F;非静态内部类的非静态成员可以访问外部类的非静态变量。</span><br><span class="line">            System.out.println(STATIC_INT);</span><br><span class="line">            System.out.println(noStaticInt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class StaticInnerClass &#123;</span><br><span class="line">        static int NUM &#x3D; 1;&#x2F;&#x2F;静态内部类可以有静态成员</span><br><span class="line">        public void fun()&#123;</span><br><span class="line">            System.out.println(STATIC_INT);</span><br><span class="line">            &#x2F;&#x2F;System.out.println(noStaticInt); 此时编辑器会报 不可访问外部类的非静态变量错</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestInnerClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;非静态内部类 创建方式1</span><br><span class="line">        ClassOuter.InnerClass innerClass &#x3D; new ClassOuter().new InnerClass();</span><br><span class="line">        &#x2F;&#x2F;非静态内部类 创建方式2</span><br><span class="line">        ClassOuter outer &#x3D; new ClassOuter();</span><br><span class="line">        ClassOuter.InnerClass inner &#x3D; outer.new InnerClass();</span><br><span class="line">        &#x2F;&#x2F;静态内部类的创建方式</span><br><span class="line">        ClassOuter.StaticInnerClass staticInnerClass &#x3D; new ClassOuter.StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员内部类：</strong> 属于外部类的每个对象，随对象一起加载。不可以定义静态成员和方法，可访问外部类的所有内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    private double radius &#x3D; 0;</span><br><span class="line">    public static int count &#x3D;1;</span><br><span class="line">    public Circle(double radius) &#123;</span><br><span class="line">        this.radius &#x3D; radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    class Draw &#123;     &#x2F;&#x2F;内部类</span><br><span class="line">        public void drawSahpe() &#123;</span><br><span class="line">            System.out.println(radius);  &#x2F;&#x2F;外部类的private成员</span><br><span class="line">            System.out.println(count);   &#x2F;&#x2F;外部类的静态成员</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>局部内部类：</strong> 定义在方法内，不能声明访问修饰符，只能定义实例成员变量和实例方法，作用范围仅在声明类的代码块中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        class Inner&#123;</span><br><span class="line">            public void fun()&#123;</span><br><span class="line">                System.out.println(&quot;HelloWorld&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        new Inner().fun();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        new test().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名内部类：</strong> 只用一次的没有名字的类，可以简化代码，创建的对象类型相当于 new 的类的子类类型。用于实现事件监听和其他回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public interface Product &#123;</span><br><span class="line">    public double getPrice();</span><br><span class="line">    public String  getName();</span><br><span class="line">&#125;</span><br><span class="line">public class test1 &#123;</span><br><span class="line">    public void test (Product p)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(p.getName()+&quot;--------&quot;+p.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String [ ] args )</span><br><span class="line">    &#123;</span><br><span class="line">        test1 as&#x3D; new test1 ();</span><br><span class="line">        as.test(new Product( )&#x2F;&#x2F;此处实现接口并实现抽象方法</span><br><span class="line">        &#123;</span><br><span class="line">            public double getPrice( )&#x2F;&#x2F;实现方法</span><br><span class="line">            &#123;</span><br><span class="line">                return 8888;</span><br><span class="line">            &#125;</span><br><span class="line">            public String getName( )&#x2F;&#x2F;实现方法</span><br><span class="line">            &#123;</span><br><span class="line">                return &quot;I can do it &quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类在方法中声明，可以访问方法中的临时变量吗-为什么"><a href="#匿名内部类在方法中声明，可以访问方法中的临时变量吗-为什么" class="headerlink" title="匿名内部类在方法中声明，可以访问方法中的临时变量吗 为什么"></a>匿名内部类在方法中声明，可以访问方法中的临时变量吗 为什么</h4><ol><li><p>原因是：因为局部变量和匿名内部类的生命周期不同。</p><p>匿名内部类是创建后是存储在堆中的，而方法中的局部变量是存储在Java栈中，当方法执行完毕后，就进行退栈，同时局部变量也会消失。那么此时匿名内部类还有可能在堆中存储着，那么匿名内部类要到哪里去找这个局部变量呢？</p><p>为了解决这个问题编译器为自动地帮我们在匿名内部类中创建了一个局部变量的备份，也就是说即使方法执结束，匿名内部类中还有一个备份，自然就不怕找不到了。</p><p>但是问题又来了。如果局部变量中的a不停的在变化。那么岂不是也要让备份的a变量无时无刻的变化。为了保持局部变量与匿名内部类中备份域保持一致。编译器不得不规定死这些局部域必须是常量，一旦赋值不能再发生变化了。所以为什么匿名内部类应用外部方法的域必须是常量域的原因所在了。</p><p>特别注意：<strong>在Java8中已经去掉要对final的修饰限制，但其实只要在匿名内部类使用了，该变量还是会自动变为final类型（只能使用，不能赋值）。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MVCC剖析</title>
      <link href="/2020/07/22/MVCC%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/22/MVCC%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（<code>row_id</code>并不是必要的，我们创建的表中有主键或者非NULL唯一键时都不会包含<code>row_id</code>列）：</p><ul><li><code>trx_id</code>：每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值给<code>trx_id</code>隐藏列。</li><li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><p>可以将这些<code>undo日志</code>都连起来，串成一个链表</p><p>为了判断一下版本链中的哪个版本是当前事务可见的，还有一个<code>ReadView</code>的概念，这个<code>ReadView</code>中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，我们把这个列表命名为为<code>m_ids</code>。这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见:</p><ul><li>如果被访问版本的<code>trx_id</code>属性值小于<code>m_ids</code>列表中最小的事务id，表明生成该版本的事务在生成<code>ReadView</code>前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值大于<code>m_ids</code>列表中最大的事务id，表明生成该版本的事务在生成<code>ReadView</code>后才生成，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值在<code>m_ids</code>列表中最大的事务id和最小事务id之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p><code>READ COMMITTED</code> — 每次读取数据前都生成一个ReadView</p><p><code>REPEATABLE READ</code> —在第一次读取数据时生成一个ReadView</p><p>比方说我们的表<code>t</code>现在只包含一条记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | c      |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 刘备   |</span><br><span class="line">+----+--------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>假设插入该记录的事务id为<code>80</code>，那么此刻该条记录的示意图如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf19851d3dce6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vemvvn1db6h431ekvsp158m19.png-15kB"></p><p>假设之后两个<code>id</code>分别为<code>100</code>、<code>200</code>的事务对这条记录进行<code>UPDATE</code>操作，操作流程如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198519aee7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vfo4g814h019mj1jqb1ggu72o3j.png-106.5kB"></p><blockquote><p>小贴士： 能不能在两个事务中交叉更新同一条记录呢？哈哈，这是不可以滴，第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。本篇文章不是讨论锁的，有关锁的更多细节我们之后再说。</p></blockquote><p>每次对记录进行改动，都会记录一条<code>undo日志</code>，每条<code>undo日志</code>也都有一个<code>roll_pointer</code>属性（<code>INSERT</code>操作对应的<code>undo日志</code>没有该属性，因为该记录并没有更早的版本），可以将这些<code>undo日志</code>都连起来，串成一个链表，所以现在的情况就像下图一样：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198524e1b34?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vfrv111j4guetptcts1qgp40.png-57.1kB"></p><p>对该记录每次更新后，都会将旧值放到一条<code>undo日志</code>中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被<code>roll_pointer</code>属性连接成一个链表，我们把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id，这个信息很重要，我们稍后就会用到。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>对于使用<code>READ UNCOMMITTED</code>隔离级别的事务来说，直接读取记录的最新版本就好了，对于使用<code>SERIALIZABLE</code>隔离级别的事务来说，使用加锁的方式来访问记录。对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，就需要用到我们上边所说的<code>版本链</code>了，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。所以设计<code>InnoDB</code>的大叔提出了一个<code>ReadView</code>的概念，这个<code>ReadView</code>中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，我们把这个列表命名为为<code>m_ids</code>。这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>如果被访问版本的<code>trx_id</code>属性值小于<code>m_ids</code>列表中最小的事务id，表明生成该版本的事务在生成<code>ReadView</code>前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值大于<code>m_ids</code>列表中最大的事务id，表明生成该版本的事务在生成<code>ReadView</code>后才生成，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值在<code>m_ids</code>列表中最大的事务id和最小事务id之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本，如果最后一个版本也不可见的话，那么就意味着该条记录对该事务不可见，查询结果就不包含该记录。</p><p>在<code>MySQL</code>中，<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的的一个非常大的区别就是它们生成<code>ReadView</code>的时机不同，我们来看一下。</p><p>READ COMMITTED — 每次读取数据前都生成一个ReadView</p><p><code>REPEATABLE READ</code> —在第一次读取数据时生成一个ReadView</p><h4 id="READ-COMMITTED-—-每次读取数据前都生成一个ReadView"><a href="#READ-COMMITTED-—-每次读取数据前都生成一个ReadView" class="headerlink" title="READ COMMITTED — 每次读取数据前都生成一个ReadView"></a>READ COMMITTED — 每次读取数据前都生成一个ReadView</h4><p>比方说现在系统里有两个<code>id</code>分别为<code>100</code>、<code>200</code>的事务在执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;关羽&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;张飞&#39; WHERE id &#x3D; 1;</span><br><span class="line">复制代码</span><br><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>小贴士： 事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。</p></blockquote><p>此刻，表<code>t</code>中<code>id</code>为<code>1</code>的记录得到的版本链表如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf19852d16845?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vgdl0j1c9d16rbelo1deh17324d.png-42.2kB"></p><p>假设现在有一个使用<code>READ COMMITTED</code>隔离级别的事务开始执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;刘备&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个<code>SELECT1</code>的执行过程如下：</p><ul><li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[100, 200]</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>c</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;关羽&#39;</code>，该版本的<code>trx_id</code>值也为<code>100</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>m_ids</code>列表中最小的事务id<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;刘备&#39;</code>的记录。</li></ul><p>之后，我们把事务id为<code>100</code>的事务提交一下，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;关羽&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;张飞&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后再到事务id为<code>200</code>的事务中更新一下表<code>t</code>中<code>id</code>为1的记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;赵云&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;诸葛亮&#39; WHERE id &#x3D; 1;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此刻，表<code>t</code>中<code>id</code>为<code>1</code>的记录的版本链就长这样：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198532476f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vgrt5jeh2itl5e41ocl944q.png-57.6kB"></p><p>然后再到刚才使用<code>READ COMMITTED</code>隔离级别的事务中继续查找这个id为<code>1</code>的记录，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200均未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;刘备&#39;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 100提交，Transaction 200未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;张飞&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个<code>SELECT2</code>的执行过程如下：</p><ul><li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[200]</code>（事务id为<code>100</code>的那个事务已经提交了，所以生成快照时就没有它了）。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>c</code>的内容是<code>&#39;诸葛亮&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;赵云&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，比<code>m_ids</code>列表中最小的事务id<code>200</code>还要小，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;张飞&#39;</code>的记录。</li></ul><p>以此类推，如果之后事务id为<code>200</code>的记录也提交了，再此在使用<code>READ COMMITTED</code>隔离级别的事务中查询表<code>t</code>中<code>id</code>值为<code>1</code>的记录时，得到的结果就是<code>&#39;诸葛亮&#39;</code>了，具体流程我们就不分析了。总结一下就是：使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p><h4 id="REPEATABLE-READ-—在第一次读取数据时生成一个ReadView"><a href="#REPEATABLE-READ-—在第一次读取数据时生成一个ReadView" class="headerlink" title="REPEATABLE READ —在第一次读取数据时生成一个ReadView"></a>REPEATABLE READ —在第一次读取数据时生成一个ReadView</h4><p>对于使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个<code>ReadView</code>，之后的查询就不会重复生成了。我们还是用例子看一下是什么效果。</p><p>比方说现在系统里有两个<code>id</code>分别为<code>100</code>、<code>200</code>的事务在执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;关羽&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;张飞&#39; WHERE id &#x3D; 1;</span><br><span class="line">复制代码</span><br><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此刻，表<code>t</code>中<code>id</code>为<code>1</code>的记录得到的版本链表如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf19852d16845?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vgdl0j1c9d16rbelo1deh17324d.png-42.2kB"></p><p>假设现在有一个使用<code>REPEATABLE READ</code>隔离级别的事务开始执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;刘备&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个<code>SELECT1</code>的执行过程如下：</p><ul><li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[100, 200]</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>c</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;关羽&#39;</code>，该版本的<code>trx_id</code>值也为<code>100</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>m_ids</code>列表中最小的事务id<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;刘备&#39;</code>的记录。</li></ul><p>之后，我们把事务id为<code>100</code>的事务提交一下，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;关羽&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;张飞&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后再到事务id为<code>200</code>的事务中更新一下表<code>t</code>中<code>id</code>为1的记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;赵云&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;诸葛亮&#39; WHERE id &#x3D; 1;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此刻，表<code>t</code>中<code>id</code>为<code>1</code>的记录的版本链就长这样：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198532476f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vgrt5jeh2itl5e41ocl944q.png-57.6kB"></p><p>然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个id为<code>1</code>的记录，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200均未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;刘备&#39;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 100提交，Transaction 200未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值仍为&#39;刘备&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个<code>SELECT2</code>的执行过程如下：</p><ul><li>因为之前已经生成过<code>ReadView</code>了，所以此时直接复用之前的<code>ReadView</code>，之前的<code>ReadView</code>中的<code>m_ids</code>列表就是<code>[100, 200]</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>c</code>的内容是<code>&#39;诸葛亮&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;赵云&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，而<code>m_ids</code>列表中是包含值为<code>100</code>的事务id的，所以该版本也不符合要求，同理下一个列<code>c</code>的内容是<code>&#39;关羽&#39;</code>的版本也不符合要求。继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，<code>80</code>小于<code>m_ids</code>列表中最小的事务id<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;刘备&#39;</code>的记录。</li></ul><p>也就是说两次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是<code>&#39;刘备&#39;</code>，这就是<code>可重复读</code>的含义。如果我们之后再把事务id为<code>200</code>的记录提交了，之后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个id为<code>1</code>的记录，得到的结果还是<code>&#39;刘备&#39;</code>，具体执行过程大家可以自己分析一下。</p><h3 id="MVCC总结"><a href="#MVCC总结" class="headerlink" title="MVCC总结"></a>MVCC总结</h3><p>从上边的描述中我们可以看出来，所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行普通的<code>SEELCT</code>操作时访问记录的版本链的过程，这样子可以使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是生成<code>ReadView</code>的时机不同，<code>READ COMMITTD</code>在每一次进行普通<code>SELECT</code>操作前都会生成一个<code>ReadView</code>，而<code>REPEATABLE READ</code>只在第一次进行普通<code>SELECT</code>操作前生成一个<code>ReadView</code>，之后的查询操作都重复这个<code>ReadView</code>就好了</p><p>作者：小孩子4919<br>链接：<a href="https://juejin.im/post/5c9b1b7df265da60e21c0b57" target="_blank" rel="noopener">https://juejin.im/post/5c9b1b7df265da60e21c0b57</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="为什么MVCC不能解决幻读？"><a href="#为什么MVCC不能解决幻读？" class="headerlink" title="为什么MVCC不能解决幻读？"></a>为什么MVCC不能解决幻读？</h3><p><a href="https://blog.csdn.net/weixin_42907817/article/details/107121470" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42907817/article/details/107121470</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Semaphore剖析</title>
      <link href="/2020/07/18/Semaphore%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/18/Semaphore%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>可以看到公平共享锁和非公平共享锁的区别就在是否需要判断队列中是否有已经等待的线程。公平共享锁需要先判断，非公平共享锁直接插队，尽管前面已经有线程在等待。</p><p>非公平锁acquire，内部重写，如果state&lt;0 会被阻塞，如果成功，会扣取state值</p><p>acquire state减一 release加一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化10个信号量在信号包中，让ABCD4个线程分别去获取</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Semaphore semaphore &#x3D; new Semaphore(10,false);</span><br><span class="line">        SemaphoreTest(semaphore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void SemaphoreTest(final Semaphore semaphore) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;线程A初始获取了4个信号量，然后分3次释放了这4个信号量</span><br><span class="line">        Thread threadA &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire(8);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get 1 semaphore&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; release 1 semaphore&quot;);</span><br><span class="line">                    semaphore.release(3);</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; release 1 semaphore&quot;);</span><br><span class="line">                    semaphore.release(5);</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.setName(&quot;threadA&quot;);</span><br><span class="line">        &#x2F;&#x2F;线程B初始获取了5个信号量，然后分2次释放了这5个信号量</span><br><span class="line">        Thread threadB &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;B start&quot;);</span><br><span class="line">                    semaphore.acquire(6);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get 6 semaphore&quot;);</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; release 6 semaphore&quot;);</span><br><span class="line">                    semaphore.release(6);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadB.setName(&quot;threadB&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;线程C初始获取了4个信号量，然后分1次释放了这4个信号量</span><br><span class="line">        Thread threadC &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;C start&quot;);</span><br><span class="line">                    semaphore.acquire(2);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get 2 semaphore&quot;);</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; release 2 semaphore&quot;);</span><br><span class="line">                    semaphore.release(2);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        threadC.setName(&quot;threadC&quot;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        Thread.sleep(1);</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        threadC.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring相关问题</title>
      <link href="/2020/07/17/Spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/17/Spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h3><h4 id="Q1：IoC-是什么？"><a href="#Q1：IoC-是什么？" class="headerlink" title="Q1：IoC 是什么？"></a>Q1：IoC 是什么？</h4><p>IoC 即控制反转，简单来说就是把原来代码里需要实现的对象创建、依赖反转给容器来帮忙实现，需要创建一个容器并且需要一种描述让容器知道要创建的对象间的关系，在 Spring 中管理对象及其依赖关系是通过 Spring 的 IoC 容器实现的。</p><p>IoC 的实现方式有依赖注入和依赖查找，由于依赖查找使用的很少，因此 IoC 也叫做依赖注入。依赖注入指对象被动地接受依赖类而不用自己主动去找，对象不是从容器中查找它依赖的类，而是在容器实例化对象时主动将它依赖的类注入给它。假设一个 Car 类需要一个 Engine 的对象，那么一般需要需要手动 new 一个 Engine，利用 IoC 就只需要定义一个私有的 Engine 类型的成员变量，容器会在运行时自动创建一个 Engine 的实例对象并将引用自动注入给成员变量。</p><hr><h4 id="Q2：IoC-容器初始化过程？"><a href="#Q2：IoC-容器初始化过程？" class="headerlink" title="Q2：IoC 容器初始化过程？"></a>Q2：IoC 容器初始化过程？</h4><p><strong>基于 XML 的容器初始化</strong></p><p>当创建一个 ClassPathXmlApplicationContext 时，构造方法做了两件事：① 调用父容器的构造方法为容器设置好 Bean 资源加载器。② 调用父类的 <code>setConfigLocations</code> 方法设置 Bean 配置信息的定位路径。</p><p>ClassPathXmlApplicationContext 通过调用父类 AbstractApplicationContext 的 <code>refresh</code> 方法启动整个 IoC 容器对 Bean 定义的载入过程，<code>refresh</code> 是一个模板方法，规定了 IoC 容器的启动流程。在创建 IoC 容器前如果已有容器存在，需要把已有的容器销毁，保证在 <code>refresh</code> 方法后使用的是新创建的 IoC 容器。</p><p>容器创建后通过 <code>loadBeanDefinitions</code> 方法加载 Bean 配置资源，该方法做两件事：① 调用资源加载器的方法获取要加载的资源。② 真正执行加载功能，由子类 XmlBeanDefinitionReader 实现。加载资源时首先解析配置文件路径，读取配置文件的内容，然后通过 XML 解析器将 Bean 配置信息转换成文档对象，之后按照 Spring Bean 的定义规则对文档对象进行解析。</p><p>Spring IoC 容器中注册解析的 Bean 信息存放在一个 HashMap 集合中，key 是字符串，值是 BeanDefinition，注册过程中需要使用 synchronized 保证线程安全。当配置信息中配置的 Bean 被解析且被注册到 IoC 容器中后，初始化就算真正完成了，Bean 定义信息已经可以使用且可被检索。Spring IoC 容器的作用就是对这些注册的 Bean 定义信息进行处理和维护，注册的 Bean 定义信息是控制反转和依赖注入的基础。</p><p><strong>基于注解的容器初始化</strong></p><p>分为两种：① 直接将注解 Bean 注册到容器中，可以在初始化容器时注册，也可以在容器创建之后手动注册，然后刷新容器使其对注册的注解 Bean 进行处理。② 通过扫描指定的包及其子包的所有类处理，在初始化注解容器时指定要自动扫描的路径。</p><hr><h4 id="Q3：依赖注入的实现方法有哪些？"><a href="#Q3：依赖注入的实现方法有哪些？" class="headerlink" title="Q3：依赖注入的实现方法有哪些？"></a>Q3：依赖注入的实现方法有哪些？</h4><p><strong>构造方法注入：</strong> IoC Service Provider 会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。这种方法的优点是在对象构造完成后就处于就绪状态，可以马上使用。缺点是当依赖对象较多时，构造方法的参数列表会比较长，构造方法无法被继承，无法设置默认值。对于非必需的依赖处理可能需要引入多个构造方法，参数数量的变动可能会造成维护的困难。</p><p><strong>setter 方法注入：</strong> 当前对象只需要为其依赖对象对应的属性添加 setter 方法，就可以通过 setter 方法将依赖对象注入到被依赖对象中。setter 方法注入在描述性上要比构造方法注入强，并且可以被继承，允许设置默认值。缺点是无法在对象构造完成后马上进入就绪状态。</p><p><strong>接口注入：</strong> 必须实现某个接口，接口提供方法来为其注入依赖对象。使用少，因为它强制要求被注入对象实现不必要接口，侵入性强。</p><hr><h4 id="Q4：依赖注入的相关注解？"><a href="#Q4：依赖注入的相关注解？" class="headerlink" title="Q4：依赖注入的相关注解？"></a>Q4：依赖注入的相关注解？</h4><p><code>@Autowired</code>：自动按类型注入，如果有多个匹配则按照指定 Bean 的 id 查找，查找不到会报错。</p><p><code>@Qualifier</code>：在自动按照类型注入的基础上再按照 Bean 的 id 注入，给变量注入时必须搭配 <code>@Autowired</code>，给方法注入时可单独使用。</p><p><code>@Resource</code> ：直接按照 Bean 的 id 注入，只能注入 Bean 类型。</p><p><code>@Value</code> ：用于注入基本数据类型和 String 类型。</p><hr><h4 id="Q5：依赖注入的过程？"><a href="#Q5：依赖注入的过程？" class="headerlink" title="Q5：依赖注入的过程？"></a>Q5：依赖注入的过程？</h4><p><code>getBean</code> 方法获取 Bean 实例，该方***调用 <code>doGetBean</code> ，<code>doGetBean</code> 真正实现从 IoC 容器获取 Bean 的功能，也是触发依赖注入的地方。</p><p>具体创建 Bean 对象的过程由 ObjectFactory 的 <code>createBean</code> 完成，该方法主要通过 <code>createBeanInstance</code> 方法生成 Bean 包含的 Java 对象实例和 <code>populateBean</code> 方法对 Bean 属性的依赖注入进行处理。</p><p>在 <code>populateBean</code>方法中，注入过程主要分为两种情况：① 属性值类型不需要强制转换时，不需要解析属性值，直接进行依赖注入。② 属性值类型需要强制转换时，首先解析属性值，然后对解析后的属性值进行依赖注入。依赖注入的过程就是将 Bean 对象实例设置到它所依赖的 Bean 对象属性上，真正的依赖注入是通过 <code>setPropertyValues</code> 方法实现的，该方法使用了委派模式。</p><p>BeanWrapperImpl 类负责对完成初始化的 Bean 对象进行依赖注入，对于非集合类型属性，使用 JDK 反射，通过属性的 setter 方法为属性设置注入后的值。对于集合类型的属性，将属性值解析为目标类型的集合后直接赋值给属性。</p><p>当容器对 Bean 的定位、载入、解析和依赖注入全部完成后就不再需要手动创建对象，IoC 容器会自动为我们创建对象并且注入依赖。</p><hr><h4 id="Q6：Bean-的生命周期？"><a href="#Q6：Bean-的生命周期？" class="headerlink" title="Q6：Bean 的生命周期？"></a>Q6：Bean 的生命周期？</h4><p>在 IoC 容器的初始化过程中会对 Bean 定义完成资源定位，加载读取配置并解析，最后将解析的 Bean 信息放在一个 HashMap 集合中。当 IoC 容器初始化完成后，会进行对 Bean 实例的创建和依赖注入过程，注入对象依赖的各种属性值，在初始化时可以指定自定义的初始化方法。经过这一系列初始化操作后 Bean 达到可用状态，接下来就可以使用 Bean 了，当使用完成后会调用 destroy 方法进行销毁，此时也可以指定自定义的销毁方法，最终 Bean 被销毁且从容器中移除。</p><p>XML 方式通过配置 bean 标签中的 init-Method 和 destory-Method 指定自定义初始化和销毁方法。 </p><p>注解方式通过 <code>@PreConstruct</code> 和 <code>@PostConstruct</code> 注解指定自定义初始化和销毁方法。</p><hr><h4 id="Q7：Bean-的作用范围？"><a href="#Q7：Bean-的作用范围？" class="headerlink" title="Q7：Bean 的作用范围？"></a>Q7：Bean 的作用范围？</h4><p>通过 scope 属性指定 bean 的作用范围，包括：</p><p>① singleton：单例模式，是默认作用域，不管收到多少 Bean 请求每个容器中只有一个唯一的 Bean 实例。</p><p>② prototype：原型模式，和 singleton 相反，每次 Bean 请求都会创建一个新的实例。</p><p>③ request：每次 HTTP 请求都会创建一个新的 Bean 并把它放到 request 域中，在请求完成后 Bean 会失效并被垃圾收集器回收。</p><p>④ session：和 request 类似，确保每个 session 中有一个 Bean 实例，session 过期后 bean 会随之失效。</p><p>⑤ global session：当应用部署在 Portlet 容器时，如果想让所有 Portlet 共用全局存储变量，那么该变量需要存储在 global session 中。</p><hr><h4 id="Q8：如何通过-XML-方式创建-Bean？"><a href="#Q8：如何通过-XML-方式创建-Bean？" class="headerlink" title="Q8：如何通过 XML 方式创建 Bean？"></a>Q8：如何通过 XML 方式创建 Bean？</h4><p>默认无参构造方法，只需要指明 bean 标签中的 id 和 class 属性，如果没有无参构造方***报错。</p><p>静态工厂方法，通过 bean 标签中的 class 属性指明静态工厂，factory-method 属性指明静态工厂方法。</p><p>实例工厂方法，通过 bean 标签中的 factory-bean 属性指明实例工厂，factory-method 属性指明实例工厂方法。</p><hr><h4 id="Q9：如何通过注解创建-Bean？"><a href="#Q9：如何通过注解创建-Bean？" class="headerlink" title="Q9：如何通过注解创建 Bean？"></a>Q9：如何通过注解创建 Bean？</h4><p><code>@Component</code> 把当前类对象存入 Spring 容器中，相当于在 xml 中配置一个 bean 标签。value 属性指定 bean 的 id，默认使用当前类的首字母小写的类名。</p><p><code>@Controller</code>，<code>@Service</code>，<code>@Repository</code> 三个注解都是 <code>@Component</code>  的衍生注解，作用及属性都是一模一样的。只是提供了更加明确语义，<code>@Controller</code> 用于表现层，<code>@Service</code>用于业务层，<code>@Repository</code>用于持久层。如果注解中有且只有一个 value 属性要赋值时可以省略 value。</p><p>如果想将第三方的类变成组件又没有源代码，也就没办法使用 <code>@Component</code> 进行自动配置，这种时候就要使用 <code>@Bean</code> 注解。被 <code>@Bean</code> 注解的方法返回值是一个对象，将会实例化，配置和初始化一个新对象并返回，这个对象由 Spring 的 IoC 容器管理。name 属性用于给当前 <code>@Bean</code>  注解方法创建的对象指定一个名称，即 bean 的 id。当使用注解配置方法时，如果方法有参数，Spring 会去容器查找是否有可用 bean对象，查找方式和 <code>@Autowired</code> 一样。</p><hr><h4 id="Q10：如何通过注解配置文件？"><a href="#Q10：如何通过注解配置文件？" class="headerlink" title="Q10：如何通过注解配置文件？"></a>Q10：如何通过注解配置文件？</h4><p><code>@Configuration</code> 用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解，value 属性用于指定配置类的字节码。</p><p><code>@ComponentScan</code> 用于指定 Spring 在初始化容器时要扫描的包。basePackages 属性用于指定要扫描的包。</p><p><code>@PropertySource</code> 用于加载 <code>.properties</code> 文件中的配置。value 属性用于指定文件位置，如果是在类路径下需要加上 classpath。</p><p><code>@Import</code> 用于导入其他配置类，在引入其他配置类时可以不用再写 <code>@Configuration</code> 注解。有 <code>@Import</code> 的是父配置类，引入的是子配置类。value 属性用于指定其他配置类的字节码。</p><hr><h4 id="Q11：BeanFactory、FactoryBean-和-ApplicationContext-的区别？"><a href="#Q11：BeanFactory、FactoryBean-和-ApplicationContext-的区别？" class="headerlink" title="Q11：BeanFactory、FactoryBean 和 ApplicationContext 的区别？"></a>Q11：BeanFactory、FactoryBean 和 ApplicationContext 的区别？</h4><p>BeanFactory 是一个 Bean 工厂，使用简单工厂模式，是 Spring IoC 容器顶级接口，可以理解为含有 Bean 集合的工厂类，作用是管理 Bean，包括实例化、定位、配置对象及建立这些对象间的依赖。BeanFactory 实例化后并不会自动实例化 Bean，只有当 Bean 被使用时才实例化与装配依赖关系，属于延迟加载，适合多例模式。</p><p>FactoryBean 是一个工厂 Bean，使用了工厂方法模式，作用是生产其他 Bean 实例，可以通过实现该接口，提供一个工厂方法来自定义实例化 Bean 的逻辑。FactoryBean 接口由 BeanFactory 中配置的对象实现，这些对象本身就是用于创建对象的工厂，如果一个 Bean 实现了这个接口，那么它就是创建对象的工厂 Bean，而不是 Bean 实例本身。</p><p>ApplicationConext 是 BeanFactory 的子接口，扩展了 BeanFactory 的功能，提供了支持国际化的文本消息，统一的资源文件读取方式，事件传播以及应用层的特别配置等。容器会在初始化时对配置的 Bean 进行预实例化，Bean 的依赖注入在容器初始化时就已经完成，属于立即加载，适合单例模式，一般推荐使用。</p><h4 id="Q12-Sping中的单例bean是否可以依赖多例bean"><a href="#Q12-Sping中的单例bean是否可以依赖多例bean" class="headerlink" title="Q12: Sping中的单例bean是否可以依赖多例bean"></a>Q12: Sping中的单例bean是否可以依赖多例bean</h4><h4 id="Q13-Sping启动过程"><a href="#Q13-Sping启动过程" class="headerlink" title="Q13: Sping启动过程"></a>Q13: Sping启动过程</h4><h4 id="Q13-Bean的销毁"><a href="#Q13-Bean的销毁" class="headerlink" title="Q13: Bean的销毁"></a>Q13: Bean的销毁</h4><h4 id="Q14：spring中哪里用到了工厂模式"><a href="#Q14：spring中哪里用到了工厂模式" class="headerlink" title="Q14：spring中哪里用到了工厂模式"></a>Q14：spring中哪里用到了工厂模式</h4><h4 id="Q15-Spring如何解决循环依赖（三级缓存）（必考）"><a href="#Q15-Spring如何解决循环依赖（三级缓存）（必考）" class="headerlink" title="Q15: Spring如何解决循环依赖（三级缓存）（必考）"></a>Q15: Spring如何解决循环依赖（三级缓存）（必考）</h4><h4 id="Q16-Spring的后置处理器"><a href="#Q16-Spring的后置处理器" class="headerlink" title="Q16: Spring的后置处理器"></a>Q16: Spring的后置处理器</h4><h4 id="Q17-Spring的-Transactional如何实现的（必考）"><a href="#Q17-Spring的-Transactional如何实现的（必考）" class="headerlink" title="Q17: Spring的@Transactional如何实现的（必考）"></a>Q17: Spring的@Transactional如何实现的（必考）</h4><h4 id="Q18-Spring的事务传播级别"><a href="#Q18-Spring的事务传播级别" class="headerlink" title="Q18: Spring的事务传播级别"></a>Q18: Spring的事务传播级别</h4><h4 id="Q19-拦截器，监听器和过滤器区别"><a href="#Q19-拦截器，监听器和过滤器区别" class="headerlink" title="Q19: 拦截器，监听器和过滤器区别"></a>Q19: 拦截器，监听器和过滤器区别</h4><h4 id="Q20-Springboot起步依赖有什么好处，为什么使用MyBatis不适用数据库连接池"><a href="#Q20-Springboot起步依赖有什么好处，为什么使用MyBatis不适用数据库连接池" class="headerlink" title="Q20: Springboot起步依赖有什么好处，为什么使用MyBatis不适用数据库连接池"></a>Q20: Springboot起步依赖有什么好处，为什么使用MyBatis不适用数据库连接池</h4><hr><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h4 id="Q1：AOP-是什么？"><a href="#Q1：AOP-是什么？" class="headerlink" title="Q1：AOP 是什么？"></a>Q1：AOP 是什么？</h4><p>AOP 即面向切面编程，简单地说就是将代码中重复的部分抽取出来，在需要执行的时候使用动态代理技术，在不修改源码的基础上对方法进行增强。</p><p>Spring 根据类是否实现接口来判断动态代理方式，如果实现接口会使用 JDK 的动态代理，核心是 InvocationHandler 接口和 Proxy 类，如果没有实现接口会使用 CGLib 动态代理，CGLib 是在运行时动态生成某个类的子类，如果某个类被标记为 final，不能使用 CGLib 。</p><p>JDK 动态代理主要通过重组字节码实现，首先获得被代理对象的引用和所有接口，生成新的类必须实现被代理类的所有接口，动态生成Java 代码后编译新生成的 <code>.class</code> 文件并重新加载到 JVM 运行。JDK 代理直接写 Class 字节码，CGLib 是采用 ASM 框架写字节码，生成代理类的效率低。但是 CGLib 调用方法的效率高，因为 JDK 使用反射调用方法，CGLib 使用 FastClass 机制为代理类和被代理类各生成一个类，这个类会为代理类或被代理类的方法生成一个 index，这个 index 可以作为参数直接定位要调用的方法。</p><p>常用场景包括权限认证、自动缓存、错误处理、日志、调试和事务等。</p><hr><h4 id="Q2：AOP-的相关注解有哪些？"><a href="#Q2：AOP-的相关注解有哪些？" class="headerlink" title="Q2：AOP 的相关注解有哪些？"></a>Q2：AOP 的相关注解有哪些？</h4><p><code>@Aspect</code>：声明被注解的类是一个切面 Bean。</p><p><code>@Before</code>：前置通知，指在某个连接点之前执行的通知。</p><p><code>@After</code>：后置通知，指某个连接点退出时执行的通知（不论正常返回还是异常退出）。</p><p><code>@AfterReturning</code>：返回后通知，指某连接点正常完成之后执行的通知，返回值使用returning属性接收。</p><p><code>@AfterThrowing</code>：异常通知，指方法抛出异常导致退出时执行的通知，和<code>@AfterReturning</code>只会有一个执行，异常使用throwing属性接收。</p><hr><h4 id="Q3：AOP-的相关术语有什么？"><a href="#Q3：AOP-的相关术语有什么？" class="headerlink" title="Q3：AOP 的相关术语有什么？"></a>Q3：AOP 的相关术语有什么？</h4><p><code>Aspect</code>：切面，一个关注点的模块化，这个关注点可能会横切多个对象。</p><p><code>Joinpoint</code>：连接点，程序执行过程中的某一行为，即业务层中的所有方法。。</p><p><code>Advice</code>：通知，指切面对于某个连接点所产生的动作，包括前置通知、后置通知、返回后通知、异常通知和环绕通知。</p><p><code>Pointcut</code>：切入点，指被拦截的连接点，切入点一定是连接点，但连接点不一定是切入点。</p><p><code>Proxy</code>：代理，Spring AOP 中有 JDK 动态代理和 CGLib 代理，目标对象实现了接口时采用 JDK 动态代理，反之采用 CGLib 代理。</p><p><code>Target</code>：代理的目标对象，指一个或多个切面所通知的对象。</p><p><code>Weaving</code> ：织入，指把增强应用到目标对象来创建代理对象的过程。</p><hr><h4 id="Q4：AOP-的过程？"><a href="#Q4：AOP-的过程？" class="headerlink" title="Q4：AOP 的过程？"></a>Q4：AOP 的过程？</h4><p>Spring AOP 由 BeanPostProcessor 后置处理器开始，这个后置处理器是一个***，可以监听容器触发的 Bean 生命周期事件，向容器注册后置处理器以后，容器中管理的 Bean 就具备了接收 IoC 容器回调事件的能力。BeanPostProcessor 的调用发生在 Spring IoC 容器完成 Bean 实例对象的创建和属性的依赖注入后，为 Bean 对象添加后置处理器的入口是 <code>initializeBean</code> 方法。</p><p>Spring 中 JDK 动态代理通过 JdkDynamicAopProxy 调用 Proxy 的 <code>newInstance</code> 方法来生成代理类，JdkDynamicAopProxy 也实现了 InvocationHandler 接口，<code>invoke</code> 方法的具体逻辑是先获取应用到此方法上的拦截器链，如果有拦截器则创建 MethodInvocation 并调用其 <code>proceed</code> 方法，否则直接反射调用目标方法。因此 Spring AOP 对目标对象的增强是通过拦截器实现的。</p><hr><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h4 id="Q1：Spring-MVC-的处理流程？"><a href="#Q1：Spring-MVC-的处理流程？" class="headerlink" title="Q1：Spring MVC 的处理流程？"></a>Q1：Spring MVC 的处理流程？</h4><p><img src="https://camo.githubusercontent.com/f5433f5b67095bda3ba5a96079a21411e3d58292/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f31302f313636666434353738373339343139323f773d3130313526683d34363626663d7765627026733d3335333532" alt="SpringMVC 原理"></p><p>Web 容器启动时会通知 Spring 初始化容器，加载 Bean 的定义信息并初始化所有单例 Bean，然后遍历容器中的 Bean，获取每一个 Controller 中的所有方法访问的 URL，将 URL 和对应的 Controller 保存到一个 Map 集合中。</p><p>所有的请求会转发给 DispatcherServlet 前端处理器处理，DispatcherServlet 会请求 HandlerMapping 找出容器中被 <code>@Controler</code> 注解修饰的 Bean 以及被 <code>@RequestMapping</code> 修饰的方法和类，生成 Handler 和 HandlerInterceptor 并以一个 HandlerExcutionChain 处理器执行链的形式返回。</p><p>之后 DispatcherServlet 使用 Handler 找到对应的 HandlerApapter，通过 HandlerApapter 调用 Handler 的方法，将请求参数绑定到方法的形参上，执行方法处理请求并得到 ModelAndView。</p><p>最后 DispatcherServlet 根据使用 ViewResolver 试图解析器对得到的 ModelAndView 逻辑视图进行解析得到 View 物理视图，然后对视图渲染，将数据填充到视图中并返回给客户端。</p><hr><h4 id="Q2：Spring-MVC-有哪些组件？"><a href="#Q2：Spring-MVC-有哪些组件？" class="headerlink" title="Q2：Spring MVC 有哪些组件？"></a>Q2：Spring MVC 有哪些组件？</h4><p><code>DispatcherServlet</code>：SpringMVC 中的前端控制器，是整个流程控制的核心，负责接收请求并转发给对应的处理组件。</p><p><code>Handler</code>：处理器，完成具体业务逻辑，相当于 Servlet 或 Action。</p><p><code>HandlerMapping</code>：完成 URL 到 Controller 映射，DispatcherServlet 通过 HandlerMapping 将不同请求映射到不同 Handler。</p><p><code>HandlerInterceptor</code>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</p><p><code>HandlerExecutionChain</code>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor。</p><p><code>HandlerAdapter</code>：处理器适配器，Handler执行业务方法前需要进行一系列操作，包括表单数据验证、数据类型转换、将表单数据封装到JavaBean等，这些操作都由 HandlerAdapter 完成。DispatcherServlet 通过 HandlerAdapter 来执行不同的 Handler。</p><p><code>ModelAndView</code>：装载模型数据和视图信息，作为 Handler 处理结果返回给 DispatcherServlet。</p><p><code>ViewResolver</code>：视图解析器，DispatcherServlet 通过它将逻辑视图解析为物理视图，最终将渲染的结果响应给客户端。</p><hr><h4 id="Q3：Spring-MVC-的相关注解？"><a href="#Q3：Spring-MVC-的相关注解？" class="headerlink" title="Q3：Spring MVC 的相关注解？"></a>Q3：Spring MVC 的相关注解？</h4><p><code>@Controller</code>：在类定义处添加，将类交给IoC容器管理。</p><p><code>@RequtestMapping</code>：将URL请求和业务方法映射起来，在类和方法定义上都可以添加该注解。<code>value</code> 属性指定URL请求的实际地址，是默认值。<code>method</code> 属性限制请求的方法类型，包括GET、POST、PUT、DELETE等。如果没有使用指定的请求方法请求URL，会报405 Method Not Allowed 错误。<code>params</code> 属性限制必须提供的参数，如果没有会报错。</p><p><code>@RequestParam</code>：如果 Controller 方法的形参和 URL 参数名一致可以不添加注解，如果不一致可以使用该注解绑定。<code>value</code> 属性表示HTTP请求中的参数名。<code>required</code> 属性设置参数是否必要，默认false。<code>defaultValue</code> 属性指定没有给参数赋值时的默认值。</p><p><code>@PathVariable</code>：Spring MVC 支持 RESTful 风格 URL，通过 <code>@PathVariable</code> 完成请求参数与形参的绑定。</p><h4 id="Q4-Spring-MVC如何进行类型转换？"><a href="#Q4-Spring-MVC如何进行类型转换？" class="headerlink" title="Q4: Spring MVC如何进行类型转换？"></a>Q4: Spring MVC如何进行类型转换？</h4><h4 id="Q5：mybatis的xml有什么标签？"><a href="#Q5：mybatis的xml有什么标签？" class="headerlink" title="Q5：mybatis的xml有什么标签？"></a>Q5：mybatis的xml有什么标签？</h4><hr><h3 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h3><h4 id="Q1：ORM-是什么？"><a href="#Q1：ORM-是什么？" class="headerlink" title="Q1：ORM 是什么？"></a>Q1：ORM 是什么？</h4><p>ORM 即 Object-Relational Mapping ，表示对象关系映射，映射的不只是对象的值还有对象之间的关系，通过 ORM 就可以把对象映射到关系型数据库中。操作实体类就相当于操作数据库表，可以不再重点关注 SQL 语句。</p><hr><h4 id="Q2：JPA-如何使用？"><a href="#Q2：JPA-如何使用？" class="headerlink" title="Q2：JPA 如何使用？"></a>Q2：JPA 如何使用？</h4><p>只需要持久层接口继承 JpaRepository 即可，泛型参数列表中第一个参数是实体类类型，第二个参数是主键类型。</p><p>运行时通过 <code>JdkDynamicAopProxy</code> 的 <code>invoke</code> 方法创建了一个动态代理对象 <code>SimpleJpaRepository</code>，<code>SimpleJpaRepository</code> 中封装了 JPA 的操作，通过 <code>hibernate</code>（封装了JDBC）完成数据库操作。</p><hr><h4 id="Q3：JPA-实体类相关注解有哪些？"><a href="#Q3：JPA-实体类相关注解有哪些？" class="headerlink" title="Q3：JPA 实体类相关注解有哪些？"></a>Q3：JPA 实体类相关注解有哪些？</h4><p><code>@Entity</code>：表明当前类是一个实体类。</p><p><code>@Table</code> ：关联实体类和数据库表。</p><p><code>@Column</code> ：关联实体类属性和数据库表中字段。</p><p><code>@Id</code> ：声明当前属性为数据库表主键对应的属性。</p><p><code>@GeneratedValue</code>： 配置主键生成策略。</p><p><code>@OneToMany</code> ：配置一对多关系，mappedBy 属性值为主表实体类在从表实体类中对应的属性名。</p><p><code>@ManyToOne</code> ：配置多对一关系，targetEntity 属性值为主表对应实体类的字节码。</p><p><code>@JoinColumn</code>：配置外键关系，name 属性值为外键名称，referencedColumnName 属性值为主表主键名称。</p><hr><h4 id="Q4：对象导航查询是什么？"><a href="#Q4：对象导航查询是什么？" class="headerlink" title="Q4：对象导航查询是什么？"></a>Q4：对象导航查询是什么？</h4><p>通过 get 方法查询一个对象的同时，通过此对象可以查询它的关联对象。</p><p>对象导航查询一到多默认使用延迟加载的形式， 关联对象是集合，因此使用立即加载可能浪费资源。</p><p>对象导航查询多到一默认使用立即加载的形式， 关联对象是一个对象，因此使用立即加载。</p><p>如果要改变加载方式，在实体类注解配置加上 fetch 属性即可，LAZY 表示延迟加载，EAGER 表示立即加载。</p><hr><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h4 id="Q1：Mybatis-的优缺点？"><a href="#Q1：Mybatis-的优缺点？" class="headerlink" title="Q1：Mybatis 的优缺点？"></a>Q1：Mybatis 的优缺点？</h4><p><strong>优点</strong></p><p>相比 JDBC 减少了大量代码量，减少冗余代码。</p><p>使用灵活，SQL 语句写在 XML 里，从程序代码中彻底分离，降低了耦合度，便于管理。</p><p>提供 XML 标签，支持编写动态 SQL 语句。</p><p>提供映射标签，支持对象与数据库的 ORM 字段映射关系。</p><p><strong>缺点</strong></p><p>SQL 语句编写工作量较大，尤其是字段和关联表多时。</p><p>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><hr><h4 id="Q2：Mybatis-的-XML-文件有哪些标签属性？"><a href="#Q2：Mybatis-的-XML-文件有哪些标签属性？" class="headerlink" title="Q2：Mybatis 的 XML 文件有哪些标签属性？"></a>Q2：Mybatis 的 XML 文件有哪些标签属性？</h4><p><code>select</code>、<code>insert</code>、<code>update</code>、<code>delete</code> 标签分别对应查询、添加、更新、删除操作。</p><p><code>parameterType</code>  属性表示参数的数据类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型，当有多个参数时可以使用 <code>#{argn}</code> 的形式表示第 n 个参数。除了基本数据类型都要以全限定类名的形式指定参数类型。</p><p><code>resultType</code>  表示返回的结果类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型。还可以使用把返回结果封装为复杂类型的 <code>resultMap</code> 。</p><hr><h4 id="Q3：Mybatis-的一级缓存是什么？"><a href="#Q3：Mybatis-的一级缓存是什么？" class="headerlink" title="Q3：Mybatis 的一级缓存是什么？"></a>Q3：Mybatis 的一级缓存是什么？</h4><p>一级缓存是 SqlSession 级别，默认开启且不能关闭。</p><p>操作数据库时需要创建 SqlSession 对象，对象中有一个 HashMap 存储缓存数据，不同 SqlSession 之间缓存数据区域互不影响。</p><p>一级缓存的作用域是 SqlSession 范围的，在同一个 SqlSession 中执行两次相同的 SQL 语句时，第一次执行完毕会将结果保存在缓存中，第二次查询直接从缓存中获取。</p><p>如果 SqlSession 执行了 DML 操作（insert、update、delete），Mybatis 必须将缓存清空保证数据有效性。 </p><hr><h4 id="Q4：Mybatis-的二级缓存是什么？"><a href="#Q4：Mybatis-的二级缓存是什么？" class="headerlink" title="Q4：Mybatis 的二级缓存是什么？"></a>Q4：Mybatis 的二级缓存是什么？</h4><p>二级缓存是Mapper 级别，默认关闭。</p><p>使用二级缓存时多个 SqlSession 使用同一个 Mapper 的 SQL 语句操作数据库，得到的数据会存在二级缓存区，同样使用 HashMap 进行数据存储，相比于一级缓存，二级缓存范围更大，多个 SqlSession 可以共用二级缓存，作用域是 Mapper 的同一个 namespace，不同 SqlSession 两次执行相同的 namespace 下的 SQL 语句，参数也相等，则第一次执行成功后会将数据保存在二级缓存中，第二次可直接从二级缓存中取出数据。</p><p>要使用二级缓存，需要在全局配置文件中配置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code> ，再在对应的映射文件中配置一个 <code>&lt;cache/&gt;</code> 标签。</p><hr><h4 id="Q5：Mybatis-和-的区别？"><a href="#Q5：Mybatis-和-的区别？" class="headerlink" title="Q5：Mybatis  #{} 和 ${} 的区别？"></a>Q5：Mybatis  <code>#{}</code> 和 <code>${}</code> 的区别？</h4><p>使用 <code>${}</code>  相当于使用字符串拼接，存在 SQL 注入的风险。</p><p>使用 <code>#{}</code> 相当于使用占位符，可以防止 SQL 注入，不支持使用占位符的地方就只能使用 <code>${}</code> ，典型情况就是动态参数。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>@resource与 @autowired</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没错，注解的本质就是一个继承了 Annotation 接口的接口。</span><br></pre></td></tr></table></figure><h3 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h3><p>Spring Boot启动流程以及生命周期</p><p><a href="https://blog.csdn.net/u011277123/article/details/104476683" target="_blank" rel="noopener">https://blog.csdn.net/u011277123/article/details/104476683</a></p><p>.Spring和Springboot的区别</p><p>SpringBoot的SPI机制是如何实现的</p><p>Springboot启动流程</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>RESTful 和SOAP</p><p>SOA和微服务的区别</p><p>springboot的优点</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何在主线程捕获子线程的异常</title>
      <link href="/2020/07/17/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%8D%95%E8%8E%B7%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/07/17/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%8D%95%E8%8E%B7%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>  通过对线程调用setUncaughtExceptionHandler，对处理器实现Thread.UncaughtExceptionHandler的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class test extends Thread&#123;</span><br><span class="line">    public static class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">        public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;MyUncaughtExceptionHandler do something...&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;errorMsg:&quot; + e.getMessage());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static class ChildTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;  Thread.currentThread().setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;do something&quot;);</span><br><span class="line"></span><br><span class="line">            throw new RuntimeException(&quot;ChildTask异常&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Thread t&#x3D; new Thread(new ChildTask());</span><br><span class="line">            t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</span><br><span class="line">            t.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>守护线程与非守护线程</title>
      <link href="/2020/07/17/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/07/17/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程中会同时存在二种线程：也就是守护线程和非守护线程，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。</p><p>将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。但是必须在thread.start()之前设置</p><h2 id="Main线程结束，其他线程一样可以正常运行。"><a href="#Main线程结束，其他线程一样可以正常运行。" class="headerlink" title="Main线程结束，其他线程一样可以正常运行。"></a>Main线程结束，其他线程一样可以正常运行。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class ParentTest</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;parent thread begin &quot;);</span><br><span class="line">        </span><br><span class="line">        ChildThread t1 &#x3D; new ChildThread(&quot;thread1&quot;);</span><br><span class="line">        ChildThread t2 &#x3D; new ChildThread(&quot;thread2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;parent thread over &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class ChildThread extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    private String name &#x3D; null;</span><br><span class="line"> </span><br><span class="line">    public ChildThread(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(this.name + &quot;--child thead begin&quot;);</span><br><span class="line"> </span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(this.name + &quot;--child thead over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">--程序运行结果如下:</span><br><span class="line">parent thread begin </span><br><span class="line">parent thread over </span><br><span class="line">thread2--child thead begin</span><br><span class="line">thread1--child thead begin</span><br><span class="line">thread2--child thead over</span><br><span class="line">thread1--child thead over</span><br></pre></td></tr></table></figure><h2 id="Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程"><a href="#Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程" class="headerlink" title="Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程"></a>Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class ParentTest</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;parent thread begin &quot;);</span><br><span class="line">        </span><br><span class="line">        ChildThread t1 &#x3D; new ChildThread(&quot;thread1&quot;);</span><br><span class="line">        ChildThread t2 &#x3D; new ChildThread(&quot;thread2&quot;);</span><br><span class="line">        t1.setDaemon(true);</span><br><span class="line">        t2.setDaemon(true);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;parent thread over &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ChildThread extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    private String name &#x3D; null;</span><br><span class="line">    public ChildThread(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(this.name + &quot;--child thead begin&quot;);</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this.name + &quot;--child thead over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> 执行结果如下：</span><br><span class="line">parent thread begin</span><br><span class="line">parent thread over</span><br><span class="line">thread1--child thead begin</span><br><span class="line">thread2--child thead begin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java中如何正常终止线程</title>
      <link href="/2020/07/17/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E6%AD%A3%E5%B8%B8%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/07/17/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E6%AD%A3%E5%B8%B8%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="使用退出标志"><a href="#使用退出标志" class="headerlink" title="使用退出标志"></a>使用退出标志</h2><p>使线程正常退出，也就是当 run() 方法完成后线程中止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class test extends Thread&#123;</span><br><span class="line">    public volatile boolean state &#x3D; false;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(!state)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;state的值：&quot;+state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test t&#x3D;new test();</span><br><span class="line">        t.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.state&#x3D;true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;state的值：false</span><br><span class="line">&#x2F;&#x2F;state的值：true</span><br></pre></td></tr></table></figure><h2 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt()"></a>Interrupt()</h2><p>interrupt() 方法并不像在 for 循环语句中使用 break 语句那样干脆，马上就停止循环。调用 interrupt() 方法仅仅是在当前线程中打一个停止的标记，并不是真的停止线程。</p><p>也就是说，线程中断并不会立即终止线程，而是通知目标线程，有人希望你终止。至于目标线程收到通知后会如何处理，则完全由目标线程自行决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class test extends Thread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            test t &#x3D; new test();</span><br><span class="line">            t.start();</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;super.run();</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; 2000; i++) &#123;</span><br><span class="line">            System.out.println(&quot;i&#x3D;&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确使用</p><p>Thread.currentThread().isInterrupted()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class test extends Thread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            test t &#x3D; new test();</span><br><span class="line">            t.start();</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;super.run();</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; 2000; i++) &#123;</span><br><span class="line">            if(Thread.currentThread().isInterrupted())</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;i&#x3D;&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-stop-终止线程"><a href="#使用-stop-终止线程" class="headerlink" title="使用 stop() 终止线程"></a>使用 stop() 终止线程</h2><p>为什么弃用stop：</p><ol><li>调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。</li><li>调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序列化和反序列化</title>
      <link href="/2020/07/16/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/07/16/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>[TOC]<br>当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。</p><p>好处:</p><p>一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SerialDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        &#x2F;&#x2F;序列化</span><br><span class="line">        FileOutputStream fos &#x3D; new FileOutputStream(&quot;object.out&quot;);</span><br><span class="line">        ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);</span><br><span class="line">        User user1 &#x3D; new User(&quot;xuliugen&quot;, &quot;123456&quot;, &quot;male&quot;);</span><br><span class="line">        oos.writeObject(user1);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">        &#x2F;&#x2F;反序列化</span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(&quot;object.out&quot;);</span><br><span class="line">        ObjectInputStream ois &#x3D; new ObjectInputStream(fis);</span><br><span class="line">        User user2 &#x3D; (User) ois.readObject();</span><br><span class="line">        System.out.println(user2.getUserName()+ &quot; &quot; + </span><br><span class="line">            user2.getPassword() + &quot; &quot; + user2.getSex());</span><br><span class="line">        &#x2F;&#x2F;反序列化的输出结果为：xuliugen 123456 male</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private String userName;</span><br><span class="line">    private String password;</span><br><span class="line">    private String sex;</span><br><span class="line">    &#x2F;&#x2F;全参构造方法、get和set方法省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/5/4/16a82df8ad1e3584?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/5/4/16a82df8ad0910e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CyclicBarrier剖析</title>
      <link href="/2020/07/16/CyclicBarrier%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/16/CyclicBarrier%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。<br>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，<br>直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>dowait();-&gt;reentrantlock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierExample &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">        final int totalThread &#x3D; 10;</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; totalThread; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">        System.out.print(&quot;before..&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;after..&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before..before..before..before..before..before..before..before..before..before..after..after</span><br><span class="line">..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>JDK 的思路就是：首先，每个 CyclicBarrier 都有一个 Lock，想执行 await 方法，就必须获得这把锁.设置一个计数器，线程每调用一次计数器，就减一，并使用  Condition 阻塞线程。当计数器是0的时候，就唤醒所有线程，并尝试执行构造函数中的任务。由于 CyclicBarrier 是可重复执行的，所以，就需要重置计数器。</p><p>CyclicBarrier 还有一个重要的点，就是 generation 的概念，由于每一个线程可以使用多个 CyclicBarrier，每个 CyclicBarrier 又都可以唤醒线程，那么就需要用代来控制，如果代不匹配，就需要重新休眠。有一个 “代” 的概念，因为 CyclicBarrier 是可以复用的，那么每次所有的线程通过了栅栏，就表示一代过去了.</p><p>而他和 CountDownLatch 的区别在于，CountDownLatch 只能使用一次就 over 了，CyclicBarrier 能使用多次，可以说功能类似，CyclicBarrier 更强大一点。并且 CyclicBarrier 携带了一个在栅栏处可以执行的任务。更加灵活。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch剖析</title>
      <link href="/2020/07/16/CountDownLatch%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/16/CountDownLatch%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>用来控制一个线程等待多个线程。<br>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方<br>法而在等待的线程就会被唤醒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">       final int totalThread &#x3D; 10;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(&quot;run..&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看看这个类的结构：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/16317a37eda063fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p><p>该类是一个独立的类，没有继承别的类，有一个内部类 Sync，这个类继承了 AQS 抽象类，其实，在之前的文章中，我们说过，AQS 是 JUC 所有锁的实现，定义了锁的基本操作。这个内部类重写了 tryAcquireShared 方法和 tryReleaseShared 方法。</p><p>然后呢？我们看看构造方法。</p><h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;</span><br><span class="line">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">    this.sync &#x3D; new Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部实现还是继承了 AQS 的 Sync 类。</p><p>Sync 构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sync(int count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br><span class="line">protected final void setState(int newState) &#123;</span><br><span class="line">    state &#x3D; newState;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * The synchronization state.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><p>设置了这个 State 变量，我们之前分析过 AQS 的源码，这个变量可以说是 AQS 实现的核心，通过控制这个变量，能够实现共享共享锁或者独占锁。</p><p>那么，如果让我们来设计这个CountDownLatch ，我们该如何设计呢？</p><p>事实上，很简单，我们只需要对 state 变量进行减 1 操作，直到这个变量变成 0，我们就唤醒主线程。</p><p>不知道 Doug Lea 是不是这么设计的？我们去看看。</p><h3 id="await-方法"><a href="#await-方法" class="headerlink" title="await 方法"></a>await 方法</h3><p>主线程会调用这个方法，让自己阻塞，直到被唤醒。</p><p>看看这个方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">       sync.acquireSharedInterruptibly(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">           throws InterruptedException &#123;</span><br><span class="line">       if (Thread.interrupted())</span><br><span class="line">           throw new InterruptedException();</span><br><span class="line">       if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">           doAcquireSharedInterruptibly(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>await 方法调用的是 Syn的  acquireSharedInterruptibly 方法，如果返回值不是大于等于 0 ，说明当前线程不能获取锁，那么就调用 doAcquireSharedInterruptibly 方法。这个方法内部会将当前线程挂起，直到 state 变成 0，才会被唤醒。</p><p>而 <strong>tryAcquireShared</strong> 方法是需要子类自己实现的。我们看看 CountDown 是如何实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return (getState() &#x3D;&#x3D; 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>很简单，就是获取 state 变量，也就是构造方法中设置的参数。</p><p> doAcquireSharedInterruptibly方法的是如何将当前线程挂起的呢？</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个 node 对象，对象中有个属性就是当前线程对象。并将这个 node 添加进队列尾部。</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    &#x2F;&#x2F; 中断失败标记</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到这个 node 的上一个节点</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F; 如果上一个节点是 head，说明他前面已经没有线程阻挡他获取锁了。</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                &#x2F;&#x2F; 获取锁的状态</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                &#x2F;&#x2F; 如果大于等于0，说明可以获取锁</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 将包装当前线程的 node 设置为 head.</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    &#x2F;&#x2F; 设置他的 next 是 null，让 GC 回收</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    &#x2F;&#x2F; 没有发生错误，不必执行下面的取消操作</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果他的前面的节点的状态时 -1，那么当前线程就需要等待。</span><br><span class="line">            &#x2F;&#x2F; 调用 parkAndCheckInterrupt 等待，如果等待过程中被中断了，抛出异常</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)  </span><br><span class="line">            &#x2F;&#x2F; 如果发生了中断异常，则取消获取锁。</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的代码写了很多注释，总的来说，逻辑如下：</p><ol><li>将当前线程包装成一个 Node 对象，加入到 AQS 的队列尾部。</li><li>如果他前面的 node 是 head ，便可以尝试获取锁了。</li><li>如果不是，则阻塞等待，调用的是 LockSupport.park(this);</li></ol><p><strong>CountDown 的 await 方法就是通过 AQS 的锁机制让主线程阻塞等待。而锁的实现就是通过构造器中设置的 state 变量来控制的。当 state 是 0 的时候，就可以获取锁。然后执行后面的逻辑。</strong></p><p>知道了 await 方法，CountDown 方法应该能猜个大概了。</p><h3 id="countDown-方法"><a href="#countDown-方法" class="headerlink" title="countDown 方法"></a>countDown 方法</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>调用了  AQS 需要子类实现 tryReleaseShared 方法。看看 CountDownLatch 是怎么实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F; Decrement count; signal when transition to zero</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line">        if (c &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc &#x3D; c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>该方法很简单，就是将 state 变量减 1，只要减过之后， state 不是 0，就返回 fasle。</strong></p><p>回到 releaseShared 方法中，当 tryReleaseShared 返回值是 true 时，也就是 state 是 0，就需要执行 doReleaseShared 方法 ，唤醒阻塞在 CountDown 上的线程了。</p><p>唤醒代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">            int ws &#x3D; h.waitStatus;</span><br><span class="line">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>只要队列中 head 节点不是 null，且和 tail 不相等，并且状态是 -1，使用 CAS 将状态修改成 0，如果成功，唤醒当前线程。当前线程就会在 doAcquireSharedInterruptibly 方法中苏醒，再次尝试获取锁，只要他的上一个节点是 head，也就是没有人和他争抢锁，并且 state 是 0，就能够成功获取到锁，继续执行下面的逻辑，不再继续阻塞。</p><p>而我们 CountDownLatch 的主线程也就可以被唤醒从而继续执行了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，CountDownLatch 还是比较简单的。说白了就是通过共享锁实现的。在我们的代码中，只有一个线程会阻塞，那就是我们的主线程， 其余的线程就是在不停的释放 state 变量，直到为 0。从 AQS 的角度来讲，整个工作流程如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/16317a37edbaecf8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p><p>简单的一个流程图，CountDownLatch 就是通过使用 AQS 的机制来实现<code>倒计时门栓</code>的。</p><p>作者：莫那·鲁道<br>链接：<a href="https://juejin.im/post/5ae754dd6fb9a07abc29b2ce" target="_blank" rel="noopener">https://juejin.im/post/5ae754dd6fb9a07abc29b2ce</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>String、StringBuffer、StringBuilder</title>
      <link href="/2020/07/14/String%E3%80%81StringBuffer%E3%80%81StringBuilder/"/>
      <url>/2020/07/14/String%E3%80%81StringBuffer%E3%80%81StringBuilder/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>String 被声明为 final，因此它不可被继承。<br>在 Java 8 中，String 内部使用 char 数组存储数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">&#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">private final char value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">&#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">private final byte[] value;</span><br><span class="line">&#x2F;** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. *&#x2F;</span><br><span class="line">private final byte coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value<br>数组的方法，因此可以保证 String 不可变。</p><h2 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h2><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法<br>进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回<br>这个新字符串的引用。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PriorityQueue源码剖析</title>
      <link href="/2020/07/13/PriorityQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/PriorityQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>Java的集合框架，PriorityQueue源码解析等…</strong></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面以Java <em>ArrayDeque</em>为例讲解了<em>Stack</em>和<em>Queue</em>，其实还有一种特殊的队列叫做<em>PriorityQueue</em>，即优先队列。<strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（*natural ordering*），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于C++的仿函数）。</p><p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p><a href="https://camo.githubusercontent.com/ac0678ef35b8a6cbfca531e2ca645ff2a50e9baf/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f626173652e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ac0678ef35b8a6cbfca531e2ca645ff2a50e9baf/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f626173652e706e67" alt="PriorityQueue"></a></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leftNo &#x3D; parentNo*2+1</span><br><span class="line">rightNo &#x3D; parentNo*2+2</span><br><span class="line">parentNo &#x3D; (nodeNo-1)&#x2F;2</span><br></pre></td></tr></table></figure><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em>。</p><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h3><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><p><a href="https://camo.githubusercontent.com/e7333c5724af6ee4e4fdff70862f9a31a906e361/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f6f666665722e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/e7333c5724af6ee4e4fdff70862f9a31a906e361/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f6f666665722e706e67" alt="add"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;offer(E e)</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e &#x3D;&#x3D; null)&#x2F;&#x2F;不允许放入null元素</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    int i &#x3D; size;</span><br><span class="line">    if (i &gt;&#x3D; queue.length)</span><br><span class="line">        grow(i + 1);&#x2F;&#x2F;自动扩容</span><br><span class="line">    size &#x3D; i + 1;</span><br><span class="line">    if (i &#x3D;&#x3D; 0)&#x2F;&#x2F;队列原来为空，这是插入的第一个元素</span><br><span class="line">        queue[0] &#x3D; e;</span><br><span class="line">    else</span><br><span class="line">        siftUp(i, e);&#x2F;&#x2F;调整</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;siftUp()</span><br><span class="line">private void siftUp(int k, E x) &#123;</span><br><span class="line">    while (k &gt; 0) &#123;</span><br><span class="line">        int parent &#x3D; (k - 1) &gt;&gt;&gt; 1;&#x2F;&#x2F;parentNo &#x3D; (nodeNo-1)&#x2F;2</span><br><span class="line">        Object e &#x3D; queue[parent];</span><br><span class="line">        if (comparator.compare(x, (E) e) &gt;&#x3D; 0)&#x2F;&#x2F;调用比较器的比较方法</span><br><span class="line">            break;</span><br><span class="line">        queue[k] &#x3D; e;</span><br><span class="line">        k &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] &#x3D; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h3 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h3><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong>。</p><p><a href="https://camo.githubusercontent.com/bd7715e17d75c967a49a0df6cc399e544a8cc80c/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f7065656b2e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/bd7715e17d75c967a49a0df6cc399e544a8cc80c/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f7065656b2e706e67" alt="peek"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;peek()</span><br><span class="line">public E peek() &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0)</span><br><span class="line">        return null;</span><br><span class="line">    return (E) queue[0];&#x2F;&#x2F;0下标处的那个元素就是最小的那个</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h3><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><a href="https://camo.githubusercontent.com/dbe221333180c2a9693d46afd4b79cc485569f30/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f706f6c6c2e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/dbe221333180c2a9693d46afd4b79cc485569f30/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f706f6c6c2e706e67" alt="poll"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0)</span><br><span class="line">        return null;</span><br><span class="line">    int s &#x3D; --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result &#x3D; (E) queue[0];&#x2F;&#x2F;0下标处的那个元素就是最小的那个</span><br><span class="line">    E x &#x3D; (E) queue[s];</span><br><span class="line">    queue[s] &#x3D; null;</span><br><span class="line">    if (s !&#x3D; 0)</span><br><span class="line">        siftDown(0, x);&#x2F;&#x2F;调整</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素（也就是最小的那个元素）。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;siftDown()</span><br><span class="line">private void siftDown(int k, E x) &#123;</span><br><span class="line">    int half &#x3D; size &gt;&gt;&gt; 1;</span><br><span class="line">    while (k &lt; half) &#123;</span><br><span class="line">    &#x2F;&#x2F;首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span><br><span class="line">        int child &#x3D; (k &lt;&lt; 1) + 1;&#x2F;&#x2F;leftNo &#x3D; parentNo*2+1</span><br><span class="line">        Object c &#x3D; queue[child];</span><br><span class="line">        int right &#x3D; child + 1;</span><br><span class="line">        if (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">            c &#x3D; queue[child &#x3D; right];</span><br><span class="line">        if (comparator.compare(x, (E) c) &lt;&#x3D; 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] &#x3D; c;&#x2F;&#x2F;然后用c取代原来的值</span><br><span class="line">        k &#x3D; child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] &#x3D; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</p><p><a href="https://camo.githubusercontent.com/6511a83152577db51c77d1448facc75da6fd2a17/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f72656d6f7665322e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6511a83152577db51c77d1448facc75da6fd2a17/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f72656d6f7665322e706e67" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;remove(Object o)</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">&#x2F;&#x2F;通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span><br><span class="line">    int i &#x3D; indexOf(o);</span><br><span class="line">    if (i &#x3D;&#x3D; -1)</span><br><span class="line">        return false;</span><br><span class="line">    int s &#x3D; --size;</span><br><span class="line">    if (s &#x3D;&#x3D; i) &#x2F;&#x2F;情况1</span><br><span class="line">        queue[i] &#x3D; null;</span><br><span class="line">    else &#123;</span><br><span class="line">        E moved &#x3D; (E) queue[s];</span><br><span class="line">        queue[s] &#x3D; null;</span><br><span class="line">        siftDown(i, moved);&#x2F;&#x2F;情况2</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stack&amp;Queue源码剖析</title>
      <link href="/2020/07/13/Stack-Queue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/Stack-Queue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Stack-amp-Queue概述"><a href="#Stack-amp-Queue概述" class="headerlink" title="Stack &amp; Queue概述"></a>Stack &amp; Queue概述</h2><p>Java里有一个叫做<em>Stack</em>的类，却没有叫做<em>Queue</em>的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>；既然<em>Queue</em>只是一个接口，当需要使用队列时也就首选<em>ArrayDeque</em>了（次选是<em>LinkedList</em>）。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><em>Queue<em>接口继承自Collection接口，除了最基本的Collection的方法之外，它还支持额外的</em>insertion</em>, <em>extraction</em>和<em>inspection</em>操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现（没有则返回null）。</p><table><thead><tr><th></th><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td><td>offer(e)</td></tr><tr><td>Remove</td><td>remove()</td><td>poll()</td></tr><tr><td>Examine</td><td>element()</td><td>peek()</td></tr></tbody></table><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><code>Deque</code>是”double ended queue”, 表示双向的队列，英文读作”deck”. Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现（没有则返回null）。</p><p><em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<em>Deque</em>与<em>Queue</em>相对应的接口：</p><p>当把<code>Deque</code>当做FIFO的<code>queue</code>来使用时，元素是从<code>deque</code>的尾部添加，从头部进行删除的； 所以<code>deque</code>的部分方法是和<code>queue</code>是等同的。具体如下：</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>add(e)</code></td><td><code>addLast(e)</code></td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td><code>offer(e)</code></td><td><code>offerLast(e)</code></td><td>向队尾插入元素，失败则返回<code>false</code></td></tr><tr><td><code>remove()</code></td><td><code>removeFirst()</code></td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td><code>poll()</code></td><td><code>pollFirst()</code></td><td>获取并删除队首元素，失败则返回<code>null</code></td></tr><tr><td><code>element()</code></td><td><code>getFirst()</code></td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除队首元素，失败则返回<code>null</code></td></tr></tbody></table><p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>push(e)</code></td><td><code>addFirst(e)</code></td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>offerFirst(e)</code></td><td>向栈顶插入元素，失败则返回<code>false</code></td></tr><tr><td><code>pop()</code></td><td><code>removeFirst()</code></td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>pollFirst()</code></td><td>获取并删除栈顶元素，失败则返回<code>null</code></td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则返回<code>null</code></td></tr></tbody></table><p><em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现。</p><p>由于官方更推荐使用<em>AarryDeque</em>用作栈和队列。从名字可以看出<em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p><p><a href="https://camo.githubusercontent.com/fd346bba6c6485031d222ba6c3b16c592846e0c4/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f626173652e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/fd346bba6c6485031d222ba6c3b16c592846e0c4/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f626173652e706e67" alt="ArrayDeque"></a></p><p>上图中我们看到，<strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以<code>head</code>不一定总等于0，<code>tail</code>也不一定总是比<code>head</code>大。</p><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h3><p><code>addFirst(E e)</code>的作用是在<em>Deque</em>的首端插入元素，也就是在<code>head</code>的前面插入元素，在空间足够且下标没有越界的情况下，只需要将<code>elements[--head] = e</code>即可。</p><p><a href="https://camo.githubusercontent.com/04f331e67b3d429fe7d1570885e6ac32b8a0ba70/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f61646446697273742e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/04f331e67b3d429fe7d1570885e6ac32b8a0ba70/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f61646446697273742e706e67" alt="addFirst"></a></p><p>实际需要考虑：1.空间是否够用，以及2.下标是否越界的问题。上图中，如果<code>head</code>为<code>0</code>之后接着调用<code>addFirst()</code>，虽然空余空间还够用，但<code>head</code>为<code>-1</code>，下标越界了。下列代码很好的解决了这两个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;addFirst(E e)</span><br><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    if (e &#x3D;&#x3D; null)&#x2F;&#x2F;不允许放入null</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[head &#x3D; (head - 1) &amp; (elements.length - 1)] &#x3D; e;&#x2F;&#x2F;2.下标是否越界</span><br><span class="line">    if (head &#x3D;&#x3D; tail)&#x2F;&#x2F;1.空间是否够用</span><br><span class="line">        doubleCapacity();&#x2F;&#x2F;扩容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，<code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。因为<code>elements.length</code>必需是<code>2</code>的指数倍，<code>elements - 1</code>就是二进制低位全<code>1</code>，跟<code>head - 1</code>相与之后就起到了取模的作用，如果<code>head - 1</code>为负数（其实只可能是-1），则相当于对其取相对于<code>elements.length</code>的补码。</p><p>下面再说说扩容函数<code>doubleCapacity()</code>，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：</p><p><a href="https://camo.githubusercontent.com/1d720a181a6ca38a00d311025d96a3daf776b176/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f646f75626c6543617061636974792e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1d720a181a6ca38a00d311025d96a3daf776b176/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f646f75626c6543617061636974792e706e67" alt="doubleCapacity"></a></p><p>图中我们看到，复制分两次进行，第一次复制<code>head</code>右边的元素，第二次复制<code>head</code>左边的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;doubleCapacity()</span><br><span class="line">private void doubleCapacity() &#123;</span><br><span class="line">    assert head &#x3D;&#x3D; tail;</span><br><span class="line">    int p &#x3D; head;</span><br><span class="line">    int n &#x3D; elements.length;</span><br><span class="line">    int r &#x3D; n - p; &#x2F;&#x2F; head右边元素的个数</span><br><span class="line">    int newCapacity &#x3D; n &lt;&lt; 1;&#x2F;&#x2F;原空间的2倍</span><br><span class="line">    if (newCapacity &lt; 0)</span><br><span class="line">        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span><br><span class="line">    Object[] a &#x3D; new Object[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, 0, r);&#x2F;&#x2F;复制右半部分，对应上图中绿色部分</span><br><span class="line">    System.arraycopy(elements, 0, a, r, p);&#x2F;&#x2F;复制左半部分，对应上图中灰色部分</span><br><span class="line">    elements &#x3D; (E[])a;</span><br><span class="line">    head &#x3D; 0;</span><br><span class="line">    tail &#x3D; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h3><p><code>addLast(E e)</code>的作用是在<em>Deque</em>的尾端插入元素，也就是在<code>tail</code>的位置插入元素，由于<code>tail</code>总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用<code>doubleCapacity()</code>进行扩容。</p><p><a href="https://camo.githubusercontent.com/d70399fc026fabaebd445cf59a6e4d5bd1024e76/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f6164644c6173742e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d70399fc026fabaebd445cf59a6e4d5bd1024e76/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f6164644c6173742e706e67" alt="addLast"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    if (e &#x3D;&#x3D; null)&#x2F;&#x2F;不允许放入null</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[tail] &#x3D; e;&#x2F;&#x2F;赋值</span><br><span class="line">    if ( (tail &#x3D; (tail + 1) &amp; (elements.length - 1)) &#x3D;&#x3D; head)&#x2F;&#x2F;下标越界处理</span><br><span class="line">        doubleCapacity();&#x2F;&#x2F;扩容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a>pollFirst()</h3><p><code>pollFirst()</code>的作用是删除并返回<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于<code>ArrayDeque</code>中不允许放入<code>null</code>，当<code>elements[head] == null</code>时，意味着容器为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public E pollFirst() &#123;</span><br><span class="line">    E result &#x3D; elements[head];</span><br><span class="line">    if (result &#x3D;&#x3D; null)&#x2F;&#x2F;null值意味着deque为空</span><br><span class="line">        return null;</span><br><span class="line">    elements[h] &#x3D; null;&#x2F;&#x2F;let GC work</span><br><span class="line">    head &#x3D; (head + 1) &amp; (elements.length - 1);&#x2F;&#x2F;下标越界处理</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast()"></a>pollLast()</h3><p><code>pollLast()</code>的作用是删除并返回<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public E pollLast() &#123;</span><br><span class="line">    int t &#x3D; (tail - 1) &amp; (elements.length - 1);&#x2F;&#x2F;tail的上一个位置是最后一个元素</span><br><span class="line">    E result &#x3D; elements[t];</span><br><span class="line">    if (result &#x3D;&#x3D; null)&#x2F;&#x2F;null值意味着deque为空</span><br><span class="line">        return null;</span><br><span class="line">    elements[t] &#x3D; null;&#x2F;&#x2F;let GC work</span><br><span class="line">    tail &#x3D; t;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="peekFirst"><a href="#peekFirst" class="headerlink" title="peekFirst()"></a>peekFirst()</h3><p><code>peekFirst()</code>的作用是返回但不删除<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素，直接返回<code>elements[head]</code>即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E peekFirst() &#123;</span><br><span class="line">    return elements[head]; &#x2F;&#x2F; elements[head] is null if deque empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="peekLast"><a href="#peekLast" class="headerlink" title="peekLast()"></a>peekLast()</h3><p><code>peekLast()</code>的作用是返回但不删除<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E peekLast() &#123;</span><br><span class="line">    return elements[(tail - 1) &amp; (elements.length - 1)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap-ConcurrentHashMap面试必问</title>
      <link href="/2020/07/13/HashMap-ConcurrentHashMap%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE/"/>
      <url>/2020/07/13/HashMap-ConcurrentHashMap%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>众所周知，HashMap的底层结构是<strong>数组和链表</strong>组成的，不过在jdk1.7和jdk1.8中具体实现略有不同。</p><h3 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><p>先看图<a href="https://camo.githubusercontent.com/51e51a0e34f51ceda409cac151e34156169e3d53/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432626537373935382e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/51e51a0e34f51ceda409cac151e34156169e3d53/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432626537373935382e6a7067" alt="img"></a></p><p>再看看1.7的实现<a href="https://camo.githubusercontent.com/d113e661f95ade8a9c24b0f347c8cb4fdc2417f6/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432626664366162612e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d113e661f95ade8a9c24b0f347c8cb4fdc2417f6/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432626664366162612e6a7067" alt="img"></a></p><p>介绍成员变量：</p><ul><li>初始化桶大小，因为底层是数组，所以这是数组默认的大小。</li><li>桶最大值。</li><li>默认的负载因子（0.75）</li><li>table真正存放数据的数组。</li><li>map存放数量的大小</li><li>桶大小，可在构造函数时显式指定。</li><li>负载因子，可在构造函数时显式指定。</li></ul><h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public HashMap() &#123;</span><br><span class="line">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); &#x2F;&#x2F; 桶和负载因子</span><br><span class="line">&#125;</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    threshold &#x3D; initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给定的默认容量为16，负载因子为0.75.</li><li>Map在使用过程中不断的往里面存放数据，当数量达到了<code>16 * 0.75 = 12</code>就需要将当前16的容量进行扩容，而扩容这个过程涉及到rehash（重新哈希）、复制数据等操作，所有非常消耗性能。</li><li>因此通常建议能提前预估HashMap的大小最好，尽量的减少扩容带来的额外性能损耗。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Ideally, under random hashCodes, the frequency of</span><br><span class="line"></span><br><span class="line">nodes in bins follows a Poisson distribution</span><br><span class="line">(http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Poisson_distribution) with a</span><br><span class="line">parameter of about 0.5 on average for the default resizing</span><br><span class="line">threshold of 0.75, although with a large variance because of</span><br><span class="line">resizing granularity. Ignoring variance, the expected</span><br><span class="line">occurrences of list size k are (exp(-0.5) * pow(0.5, k) &#x2F;</span><br><span class="line">factorial(k)). The first values are:</span><br><span class="line">0: 0.60653066</span><br><span class="line">1: 0.30326533</span><br><span class="line">2: 0.07581633</span><br><span class="line">3: 0.01263606</span><br><span class="line">4: 0.00157952</span><br><span class="line">5: 0.00015795</span><br><span class="line">6: 0.00001316</span><br><span class="line">7: 0.00000094</span><br><span class="line">8: 0.00000006</span><br><span class="line">more: less than 1 in ten million</span><br><span class="line">注意wiki链接中的关键字：Poisson_distribution</span><br><span class="line">泊淞分布啊</span><br></pre></td></tr></table></figure><p>简单翻译一下就是在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布，同时给出了桶中元素个数和概率的对照表。</p><p>从上面的表中可以看到当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</p><p>好了，再深挖就要挖到统计学那边去了，就此打住，重申一下使用hash容器请尽量指定初始容量，且是2的幂次方。</p><p>关于泊淞分布的知识请看</p><p><a href="http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html#comment-356111" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html#comment-356111</a></p><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Entry&lt;K,V&gt;[] table &#x3D; (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p>如何定义呢？<a href="https://camo.githubusercontent.com/d4896d60a3183274a1e559b0a66a29ffedfb7a44/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633038653639332e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d4896d60a3183274a1e559b0a66a29ffedfb7a44/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633038653639332e6a7067" alt="img"></a></p><p>Entry是Hashmap中的一个内部类，从他的成员变量很容易看出：</p><ul><li>key就是写入时的键</li><li>value自然就是值</li><li>开始的时候就提到HashMap是由数组和链表组成，所以这个next就是用于实现链表结构</li><li>hash存放的是当前key的hashcode</li></ul><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold); &#x2F;&#x2F; 判断数组是否需要初始化</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return putForNullKey(value); &#x2F;&#x2F; 判断key是否为空</span><br><span class="line">    int hash &#x3D; hash(key); &#x2F;&#x2F; 计算hashcode</span><br><span class="line">    int i &#x3D; indexFor(hash, table.length); &#x2F;&#x2F; 计算桶</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123; &#x2F;&#x2F; 遍历判断链表中的key和hashcode是否相等，等就替换</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i); &#x2F;&#x2F; 没有就添加新的呗</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前数组是否需要初始化</li><li>如果key为空，则put一个空值进去</li><li>根据key计算hashcode</li><li>根据计算的hashcode定位index的桶</li><li>如果桶是一个链表，则需要遍历判断里面的hashcode、key是否和传入的key相等，如果相等则进行覆盖，并返回原来的值</li><li>如果桶是空的，说明当前位置没有数据存入，此时新增一个Entry对象写入当前位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;&#x2F;&#x2F; 是否扩容</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;</span><br><span class="line">        bucketIndex &#x3D; indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];</span><br><span class="line">    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当调用addEntry写入Entry时需要判断是否需要扩容</li><li>如果需要就进行两倍扩充，并将当前的key重新hash并定位。</li><li>而在createEntry中会将当前位置的桶传入到新建的桶中，如果当前桶油值就会在位置形成链表。</li></ul><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null) &#x2F;&#x2F; 判断key是否为空</span><br><span class="line">        return getForNullKey(); &#x2F;&#x2F; 为空，就返回空值</span><br><span class="line">    Entry&lt;K,V&gt; entry &#x3D; getEntry(key); &#x2F;&#x2F; get entry</span><br><span class="line">    return null &#x3D;&#x3D; entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key); &#x2F;&#x2F;根据key和hashcode</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];</span><br><span class="line">         e !&#x3D; null;</span><br><span class="line">         e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先根据key计算hashcode，然后定位具体的桶</li><li>判断该位置是否为链表</li><li>不是链接就根据key和hashcode是否相等来返回值</li><li>为链表则需要遍历直到key和hashcode相等就返回值</li><li>啥都没得，就返回null</li></ul><h3 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p>不知道 1.7 的实现大家看出需要优化的点没有？</p><p>其实一个很明显的地方就是链表</p><p><strong>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。</strong></p><p><a href="https://camo.githubusercontent.com/1bd19ba02d0aa93cf7d6c947c0672cafe7e478fd/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633163316364372e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1bd19ba02d0aa93cf7d6c947c0672cafe7e478fd/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633163316364372e6a7067" alt="img"></a></p><p>看看成员变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line">&#x2F;**</span><br><span class="line"> * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line"> * by either of the constructors with arguments.</span><br><span class="line"> * MUST be a power of two &lt;&#x3D; 1&lt;&lt;30.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * The load factor used when none specified in constructor.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Holds cached entrySet(). Note that AbstractMap fields are used</span><br><span class="line"> * for keySet() and values().</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * The number of key-value mappings contained in this map.</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient int size;</span><br></pre></td></tr></table></figure><ul><li><code>TREEIFY_THRESHOLD</code> 用于判断是否需要将链表转换为红黑树的阈值。</li><li>HashEntry 修改为 Node。</li><li>Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 <code>key value hashcode next</code> 等数据。</li></ul><h4 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h4><p><a href="https://camo.githubusercontent.com/068bac3f602c768691b1def1d91a114c457dac95/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633337383039302e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/068bac3f602c768691b1def1d91a114c457dac95/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633337383039302e6a7067" alt="img"></a></p><ul><li>判断当前桶是否为空，空的就需要初始化（resize中会判断是否进行初始化）</li><li>根据当前key的hashcode定位到具体的桶中并判断是否为空，为空则表明没有Hash冲突，就直接在当前位置创建一个新桶</li><li>如果当前桶油值（Hash冲突），那么就要比较当前桶中的key、key的hashcode与写入的key是否相等，相等就赋值给e，在第8步的时候会统一进行赋值及返回</li><li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据</li><li>如果是个链表，就需要将当前的key、value封装称一个新节点写入到当前桶的后面形成链表。</li><li>接着判断当前链表的大小是否大于预设的阈值，大于就要转换成为红黑树</li><li>如果在遍历过程中找到key相同时直接退出遍历。</li><li>如果<code>e != null</code>就相当于存在相同的key，那就需要将值覆盖。</li><li>最后判断是否需要进行扩容。</li></ul><h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先将key hash之后取得所定位的桶</li><li>如果桶为空，则直接返回null</li><li>否则判断桶的第一个位置（有可能是链表、红黑树）的key是否为查询的key，是就直接返回value</li><li>如果第一个不匹配，则判断它的下一个是红黑树还是链表</li><li>红黑树就按照树的查找方式返回值</li><li>不然就按照链表的方式遍历匹配返回值</li></ul><p><strong>从这两个核心方法（get/put）可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 <code>O(logn)</code>。</strong></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            map.put(UUID.randomUUID().toString(), &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>HashMap扩容的时候会调用resize()方法，就是这里的并发操作容易在一个桶上形成环形链表</li><li>这样当获取一个不存在的key时，计算出的index正好是环形链表的下标就会出现死循环。</li><li>但是1.7的头插法造成的问题，1.8改变了插入顺序，就解决了这个问题，但是为了内存可见性等安全性，还是需要ConCurrentHashMap</li></ul><p><a href="https://camo.githubusercontent.com/b7a084415c8a08d4fa15227227a863eb649f994e/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633465646535342e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/b7a084415c8a08d4fa15227227a863eb649f994e/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633465646535342e6a7067" alt="img"></a></p><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><p>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator &#x3D; map.entrySet().iterator();</span><br><span class="line">        while (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next &#x3D; entryIterator.next();</span><br><span class="line">            System.out.println(&quot;key&#x3D;&quot; + next.getKey() + &quot; value&#x3D;&quot; + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator &#x3D; map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String key &#x3D; iterator.next();</span><br><span class="line">            System.out.println(&quot;key&#x3D;&quot; + key + &quot; value&#x3D;&quot; + map.get(key));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>建议使用第一种，同时可以把key value取出。</li><li>第二种还需要通过key取一次key，效率较低。</li></ul><h2 id="ConCurrentHashMap"><a href="#ConCurrentHashMap" class="headerlink" title="ConCurrentHashMap"></a>ConCurrentHashMap</h2><h3 id="jdk1-7-1"><a href="#jdk1-7-1" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><p><a href="https://camo.githubusercontent.com/ecc8e454cddfede7ac97cfd212b0a13682f1b53a/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633563653935632e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ecc8e454cddfede7ac97cfd212b0a13682f1b53a/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633563653935632e6a7067" alt="img"></a></p><ul><li>Segment数组</li><li>HashEntry组成</li><li>和HashMap一样，仍然是数组加链表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span><br><span class="line"> *&#x2F;</span><br><span class="line">final Segment&lt;K,V&gt;[] segments;</span><br><span class="line">transient Set&lt;K&gt; keySet;</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line">       private static final long serialVersionUID &#x3D; 2249069246763182397L;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span><br><span class="line">       transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">       transient int count;</span><br><span class="line">       transient int modCount;</span><br><span class="line">       transient int threshold;</span><br><span class="line">       final float loadFactor;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/a55002a94ff6ed86b32ed1475168147d72e3aacc/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633633356336392e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/a55002a94ff6ed86b32ed1475168147d72e3aacc/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633633356336392e6a7067" alt="img"></a></p><ul><li>唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</li><li>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。</li><li>不会像HashTable那样不管是put还是get操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。</li><li>每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</li></ul><h4 id="put-2"><a href="#put-2" class="headerlink" title="put"></a>put</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    if (value &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck</span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment</span><br><span class="line">        s &#x3D; ensureSegment(j);</span><br><span class="line">    return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过key定位到Segment，之后在对应的Segment中进行具体的put</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">        int index &#x3D; (tab.length - 1) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class="line">            if (e !&#x3D; null) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue &#x3D; e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value &#x3D; value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                e &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (node !&#x3D; null)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                int c &#x3D; count + 1;</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                else</span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count &#x3D; c;</span><br><span class="line">                oldValue &#x3D; null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虽然HashEntry中的value是用volatile关键字修饰的，但是并不能保证并发的原子性，所以put操作仍然需要加锁处理。</li><li>首先第一步的时候会尝试获取锁，如果获取失败肯定就是其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</li></ul><p><a href="https://camo.githubusercontent.com/71f965d21a47f284830a21fac13f956ca08fe757/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636333633938322e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/71f965d21a47f284830a21fac13f956ca08fe757/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636333633938322e6a7067" alt="img"></a></p><ul><li>尝试获取自旋锁</li><li>如果重试的次数达到了<code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li></ul><p><a href="https://camo.githubusercontent.com/95b3b80b9d412127883290166fcd4b612d4b36f1/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636432356333372e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/95b3b80b9d412127883290166fcd4b612d4b36f1/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636432356333372e6a7067" alt="img"></a></p><ul><li>将当前的Segment中的table通过key的hashcode定位到HashEntry</li><li>遍历该HashEntry，如果不为空则判断传入的key和当前遍历的key是否相等，相等则覆盖旧的value</li><li>不为空则需要新建一个HashEntry并加入到Segment中，同时会先判断是否需要扩容</li><li>最后会解除在1中所获取当前Segment的所。</li></ul><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; &#x2F;&#x2F; manually integrate access methods to reduce overhead</span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    int h &#x3D; hash(key);</span><br><span class="line">    long u &#x3D; (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) !&#x3D; null &amp;&amp;</span><br><span class="line">        (tab &#x3D; s.table) !&#x3D; null) &#123;</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; h &amp;&amp; key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</li><li>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</li><li>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</li></ul><h3 id="jdk1-8-1"><a href="#jdk1-8-1" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p><strong>那就是查询遍历链表效率太低。</strong></p><p><a href="https://camo.githubusercontent.com/28bb34f51a46357d1636147c6290b5098592250b/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636533333739352e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/28bb34f51a46357d1636147c6290b5098592250b/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636533333739352e6a7067" alt="img"></a></p><p><strong>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性</strong></p><p><a href="https://camo.githubusercontent.com/683f45273cb02892783747659b250bc58ba66a8d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636565626530322e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/683f45273cb02892783747659b250bc58ba66a8d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636565626530322e6a7067" alt="img"></a></p><ul><li>也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。</li><li>其中的 <code>val next</code> 都用了 volatile 修饰，保证了可见性。</li></ul><h4 id="put-3"><a href="#put-3" class="headerlink" title="put"></a>put</h4><p><a href="https://camo.githubusercontent.com/865ef617cb35cbbb2da99fc73313df2c909b498d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636663333239332e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/865ef617cb35cbbb2da99fc73313df2c909b498d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636663333239332e6a7067" alt="img"></a></p><ul><li>根据key计算出hashcode</li><li>判断是否需要进行初始化</li><li>f即为当前key定位出的Node，如果为空表示当前位置可以写入数据，利用CAS尝试写入，失败则自旋保证成功。</li><li>如果当前位置的<code>hashcode == MOVED == -1</code>，则需要进行扩容</li><li>如果都不满足，则利用synchronized锁写入数据</li><li>如果数量大于<code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ul><h4 id="get-2"><a href="#get-2" class="headerlink" title="get"></a>get</h4><p><a href="https://camo.githubusercontent.com/c7a73630d6aa169d98cae7209f604c12414c9541/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432643232633663622e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/c7a73630d6aa169d98cae7209f604c12414c9541/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432643232633663622e6a7067" alt="img"></a></p><ul><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值。</li></ul><p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code>），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>套路：</p><ul><li>谈谈你理解的 HashMap，讲讲其中的 get put 过程。</li><li>1.8 做了什么优化？</li><li>是线程安全的嘛？</li><li>不安全会导致哪些问题？</li><li>如何解决？有没有线程安全的并发容器？</li><li>ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？<h2 id="源码图"><a href="#源码图" class="headerlink" title="源码图"></a>源码图</h2><img src="https://img-blog.csdnimg.cn/20200713192652430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="img"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TreeMap(Set)源码剖析</title>
      <link href="/2020/07/13/TreeMap-Set-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/TreeMap-Set-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>基于红黑树实现的 TreeMap 提供了平均和最差时间复杂度均为 O(log<del>n</del>) 的增删改查操作，该集合最大的特点就是 Key 的有序性。TreeMap 继承了 SortedMap 和 NavigableMap，SortedMap 表示 Key 是有序不可重复的，支持获取头尾 Key-Value 元素，或者根据 Key 指定范围获取子集合等。插入的 Key 必须实现 Comparable 接口或提供额外的 Comparator 比较器，所以 Key 不允许为 null。NavigableMap 继承了 SortedMap，根据指定的搜索条件返回最匹配的 Key-Value 元素。</p><p>不同于 HashMap 的是 TreeMap 并非一定要重写 hashCode 和 equals 方法来达到 Key 去重的目的。HashMap 是依靠 hashCode 和 equals 来去重的，而 TreeMap 依靠 Comparable 或 Comparator 来实现去重。 TreeMap 对 Key 进行排序时，如果比较器不为空就会优先使用比较器的 compare 方法，如果比较器为空就会使用 Key 实现的自然排序 Comparable 接口的 compareTo 方法，如果两者都不满足就会抛出异常。</p><p>TreeMap 通过 put 和 deleteEntry 实现红黑树增加和删除节点的操作。插入新节点的规则有三个：① 需要调整的新节点总是红色的。② 如果插入新节点的父节点是黑色的，不需要调整。③ 如果插入新节点的父节点是红色的，由于红黑树中不能出现相邻的红色，则进入循环判断，通过重新着色或左右旋转来调整。TreeMap 的插入操作就是按照 Key 的对比往下遍历，大于比较节点值的向右查找，小于的向左查找，先按照二叉查找树的特性操作，无需关心节点颜色与树的平衡，后续会重新着色和旋转，保持红黑树的特性。</p><p>TreeMap 是线程不安全的集合，在多线程操作时需要添加互斥机制，或者把对象放在 Collections.synchronizedMap() 中实现同步。在 JDK 7 之后的 HashMap、TreeSet、ConcurrentHashMap 也都是使用红黑树的方式管理节点。如果只是对单个元素进行排序，使用 TreeSet 即可。TreeSet 的底层就是 TreeMap，Value 共享一个静态的 Object 对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LinkedHashMap(Set)源码剖析</title>
      <link href="/2020/07/13/LinkedHashMap-Set-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/LinkedHashMap-Set-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>Java的集合框架，TreeSet &amp; TreeMap源码解析等…</strong></p><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>概括的说，<code>LinkedHashMap</code> 继承自<code>HashMap</code>，实现了<code>Map&lt;K,V&gt;</code>接口。其内部还维护了一个<strong>双向链表</strong>，在每次<strong>插入数据，或者访问、修改数据</strong>时，<strong>会增加节点、或调整链表的节点顺序</strong>。以决定迭代时输出的顺序。</p><p>默认情况，遍历时的顺序是<strong>按照插入节点的顺序</strong>。这也是其与<code>HashMap</code>最大的区别。<br>也可以在构造时传入<code>accessOrder</code>参数，使得其遍历顺序<strong>按照访问的顺序</strong>输出。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><code>LinkedHashMap</code>的节点<code>Entry&lt;K,V&gt;</code>继承自<code>HashMap.Node&lt;K,V&gt;</code>，在其基础上扩展了一下。改成了一个<strong>双向链表</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时类里有两个成员变量<code>head tail</code>,分别指向内部双向链表的表头、表尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;双向链表的头结点</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;双向链表的尾节点</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h3><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在<br>每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未<br>使用的节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">       LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">       if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">           LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">               (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">           p.after &#x3D; null;</span><br><span class="line">           if (b &#x3D;&#x3D; null)</span><br><span class="line">               head &#x3D; a;</span><br><span class="line">           else</span><br><span class="line">               b.after &#x3D; a;</span><br><span class="line">           if (a !&#x3D; null)</span><br><span class="line">               a.before &#x3D; b;</span><br><span class="line">           else</span><br><span class="line">               last &#x3D; b;</span><br><span class="line">           if (last &#x3D;&#x3D; null)</span><br><span class="line">               head &#x3D; p;</span><br><span class="line">           else &#123;</span><br><span class="line">               p.before &#x3D; last;</span><br><span class="line">               last.after &#x3D; p;</span><br><span class="line">           &#125;</span><br><span class="line">           tail &#x3D; p;</span><br><span class="line">           ++modCount;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h3><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。<br>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    static class LRUCache&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt;</span><br><span class="line">    &#123;</span><br><span class="line">     private static final int MAX_ENTRIES&#x3D;3;</span><br><span class="line">     protected  boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</span><br><span class="line">     &#123;</span><br><span class="line">         return size()&gt;MAX_ENTRIES;</span><br><span class="line">     &#125;</span><br><span class="line">     LRUCache()</span><br><span class="line">     &#123;</span><br><span class="line">         super(MAX_ENTRIES,0.75f,true);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LRUCache&lt;Integer, String&gt; cache &#x3D; new LRUCache&lt;&gt;();</span><br><span class="line">        cache.put(1, &quot;a&quot;);</span><br><span class="line">        cache.put(2, &quot;b&quot;);</span><br><span class="line">        cache.put(3, &quot;c&quot;);</span><br><span class="line">        cache.get(1);</span><br><span class="line">        cache.put(4, &quot;d&quot;);</span><br><span class="line">        System.out.println(cache.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>前面已经说过<em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashSet&lt;E&gt;</span><br><span class="line">    extends HashSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#x2F;&#x2F; LinkedHashSet里面有一个LinkedHashMap</span><br><span class="line">    public LinkedHashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        map &#x3D; new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    public boolean add(E e) &#123;&#x2F;&#x2F;简单的方法转换</span><br><span class="line">        return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashSet源码剖析</title>
      <link href="/2020/07/13/HashSet%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/HashSet%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>HashSet 的是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，HashMap 的 Key 值即 HashSet 存储的元素，所有 Key 都使用相同的 Value ，一个 static final 修饰的变量名为 PRESENT 的 Object 类型的对象。使用 Key 保证集合元素的唯一性，但它不保证集合元素的有序性。由于 HashSet 的底层是 HashMap 实现的，HashMap 是线程不安全的，因此 HashSet 也是线程不安全的。</p><p>HashSet 判断元素是否相同时，对于基本类型的包装类，直接按值进行比较。对于引用数据类型，会先比较 hashCode 返回值是否相同，如果不同则代表不是同一个对象，如果相同则继续比较 equals 方法返回值是否相同，都相同说明是同一个对象。</p><p>TreeSet 的是使用 TreeMap 实现的，底层为树结构，在添加新元素到集合中时，按照某种比较规则将其插入合适的位置，保证插入后的集合仍然是有序的。LinkedHashSet 继承自 HashSet，内部使用链表维护了元素插入的顺序。</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList源码剖析</title>
      <link href="/2020/07/13/LinkedList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/LinkedList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（<em>Queue</em>），同时又可以看作一个栈（<em>Stack</em>）。这样看来，<em>LinkedList</em>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，一方面是因为Java官方已经声明不建议使用<em>Stack</em>类，更遗憾的是，Java里根本没有一个叫做<em>Queue</em>的类（它是个接口名字）。关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>（当作栈或队列使用时）有着更好的性能。</p><p><a href="https://camo.githubusercontent.com/af8b89b4d140940680305ab75b62b457c384fee3/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f626173652e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/af8b89b4d140940680305ab75b62b457c384fee3/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f626173652e706e67" alt="LinkedList"></a></p><p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p><h2 id="LinkedLists实现"><a href="#LinkedLists实现" class="headerlink" title="LinkedLists实现"></a>LinkedLists实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟<em>List</em>接口相关的函数，而将<em>Queue</em>和<em>Stack</em>以及<em>Deque</em>相关的知识放在下一节讲。双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候<code>first</code>和<code>last</code>都指向<code>null</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  transient int size &#x3D; 0;</span><br><span class="line">  transient Node&lt;E&gt; first;</span><br><span class="line">  transient Node&lt;E&gt; last;</span><br><span class="line">&#x2F;&#x2F; Node是私有的内部类</span><br><span class="line">  private static class Node&lt;E&gt; &#123;</span><br><span class="line">      E item;</span><br><span class="line">      Node&lt;E&gt; next;</span><br><span class="line">      Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">          this.item &#x3D; element;</span><br><span class="line">          this.next &#x3D; next;</span><br><span class="line">          this.prev &#x3D; prev;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getFirst-，getLast"><a href="#getFirst-，getLast" class="headerlink" title="getFirst()，getLast()"></a>getFirst()，getLast()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public E getFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E getLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeFirst-，removeLast-，remove-e-，remove-index"><a href="#removeFirst-，removeLast-，remove-e-，remove-index" class="headerlink" title="removeFirst()，removeLast()，remove(e)，remove(index)"></a>removeFirst()，removeLast()，remove(e)，remove(index)</h3><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p><p><a href="https://camo.githubusercontent.com/20a94f0e8e77cbbf0c70264439b940cf1e64ff23/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f72656d6f76652e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/20a94f0e8e77cbbf0c70264439b940cf1e64ff23/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f72656d6f76652e706e67" alt="remove"></a></p><p>删除元素 - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判读的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">    E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line"></span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 第一个元素</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next &#x3D; next;</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 最后一个元素</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev &#x3D; prev;</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item &#x3D; null; &#x2F;&#x2F; GC</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remove(int index)</code>使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除head元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    first &#x3D; next;</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除last元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public E removeLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;</span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    last &#x3D; prev;</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p><em>add()\</em>方法有两个版本，一个是<code>add(E e)</code>，该方法在*LinkedList*的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last &#x3D; newNode;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/4831538ace9fd84081b890f29bd06e0500fa9703/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f6164642e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/4831538ace9fd84081b890f29bd06e0500fa9703/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f6164642e706e67" alt="img"></a></p><p><code>add(int index, E element)</code>, 当index==size时，等同于add(E e); 如果不是，则分两步：1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    if (index &#x3D;&#x3D; size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    else</span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>node(int index)</code>函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3><p>addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a &#x3D; c.toArray();</span><br><span class="line">    int numNew &#x3D; a.length;</span><br><span class="line">    if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    if (index &#x3D;&#x3D; size) &#123;</span><br><span class="line">        succ &#x3D; null;</span><br><span class="line">        pred &#x3D; last;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        succ &#x3D; node(index);</span><br><span class="line">        pred &#x3D; succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Object o : a) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">        if (pred &#x3D;&#x3D; null)</span><br><span class="line">            first &#x3D; newNode;</span><br><span class="line">        else</span><br><span class="line">            pred.next &#x3D; newNode;</span><br><span class="line">        pred &#x3D; newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (succ &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; pred;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pred.next &#x3D; succ;</span><br><span class="line">        succ.prev &#x3D; pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size +&#x3D; numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2020/07/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class bubbleSort &#123;</span><br><span class="line">    public static int[] BubbleSort(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    swap(arr, j, j + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;21, 34, 56, 11, 2&#125;;</span><br><span class="line">        BubbleSort(arr);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void quickSort(int arr[], int left, int right) &#123;</span><br><span class="line">        if (left &gt;&#x3D; right) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int index &#x3D; partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, index - 1);</span><br><span class="line">        quickSort(arr, index + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int partition(int[] arr, int left, int right) &#123;</span><br><span class="line">        int key &#x3D; arr[left];</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            while (right &gt; left &amp;&amp; arr[right] &gt;&#x3D; key) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[left] &#x3D; arr[right];</span><br><span class="line">            while (right &gt; left &amp;&amp; arr[left] &lt; key) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[right] &#x3D; arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] &#x3D; key;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 测试案例</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;49, 38, 65, 97, 76, 13, 27, 49&#125;;</span><br><span class="line"></span><br><span class="line">        quickSort(arr, 0, arr.length - 1);</span><br><span class="line"></span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            System.out.print(i + &quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class InsertSort &#123;</span><br><span class="line">    public static int[] insertSort(int[] arr) &#123;</span><br><span class="line">        int temp, j;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            temp &#x3D; arr[i];</span><br><span class="line">            for (j &#x3D; i - 1; j &gt;&#x3D; 0 &amp;&amp; temp &lt; arr[j]; j--) &#123;</span><br><span class="line">                arr[j + 1] &#x3D; arr[j];</span><br><span class="line">            &#125;&#x2F;&#x2F; 1 2 2 5 2</span><br><span class="line">            arr[j + 1] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F;  Set&lt;Integer&gt; set&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">        int[] arr &#x3D; &#123;3, 1, 2, 5&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static int[] sort(int[] a,int low,int high)&#123;</span><br><span class="line">        int mid &#x3D; (low+high)&#x2F;2;</span><br><span class="line">        if(low&lt;high)&#123;</span><br><span class="line">            sort(a,low,mid);</span><br><span class="line">            sort(a,mid+1,high);</span><br><span class="line">            &#x2F;&#x2F;左右归并</span><br><span class="line">            merge(a,low,mid,high);</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void merge(int[] a, int low, int mid, int high) &#123;</span><br><span class="line">        int[] temp &#x3D; new int[high-low+1];</span><br><span class="line">        int i&#x3D; low;</span><br><span class="line">        int j &#x3D; mid+1;</span><br><span class="line">        int k&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F; 把较小的数先移到新数组中</span><br><span class="line">        while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;high)&#123;</span><br><span class="line">            if(a[i]&lt;a[j])&#123;</span><br><span class="line">                temp[k++] &#x3D; a[i++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp[k++] &#x3D; a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把左边剩余的数移入数组</span><br><span class="line">        while(i&lt;&#x3D;mid)&#123;</span><br><span class="line">            temp[k++] &#x3D; a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把右边边剩余的数移入数组</span><br><span class="line">        while(j&lt;&#x3D;high)&#123;</span><br><span class="line">            temp[k++] &#x3D; a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把新数组中的数覆盖nums数组</span><br><span class="line">        for(int x&#x3D;0;x&lt;temp.length;x++)&#123;</span><br><span class="line">            a[x+low] &#x3D; temp[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr&#x3D;&#123;2,1,5,4&#125;;</span><br><span class="line">        sort(arr,0,arr.length-1);</span><br><span class="line">        for(int a:arr)</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line">    public static void heapSort(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; arr.length &#x2F; 2 - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">            downjust(arr, i, arr.length);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; :&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; arr.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            swap(arr, i, 0);</span><br><span class="line">            downjust(arr, 0, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void downjust(int[] arr, int low, int high) &#123;</span><br><span class="line">        int i &#x3D; low, j &#x3D; i * 2 + 1, temp &#x3D; arr[i];</span><br><span class="line">        while (j &lt; high) &#123;</span><br><span class="line">            if (j + 1 &lt; high &amp;&amp; arr[j] &lt; arr[j + 1])</span><br><span class="line">                j++;</span><br><span class="line">            if (arr[j] &gt; temp) &#123;</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">                i &#x3D; j;</span><br><span class="line">                j &#x3D; i * 2 + 1;</span><br><span class="line">            &#125; else break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums &#x3D; &#123;110, 16, 7, 3, 20, 17, 8&#125;;</span><br><span class="line">        heapSort(nums);</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            System.out.print(num + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class SelectSort &#123;</span><br><span class="line">    &#x2F;&#x2F;选择排序：每次从待排序的元素中选出最小值</span><br><span class="line">    &#x2F;&#x2F;选择排序：每次从待排序的元素中选出最小值  </span><br><span class="line">    public static void selectionSort(int[] arr)&#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; arr.length - 1; i++)&#123;</span><br><span class="line">            int min &#x3D; i;</span><br><span class="line">            for(int j &#x3D; i + 1; j &lt; arr.length; j++)&#123;</span><br><span class="line">                &#x2F;&#x2F;将a[i]和a[i+1...N-1]中的最小元素交换</span><br><span class="line">                if(arr[j] &lt; arr[min])&#123;&#x2F;&#x2F;升序排列</span><br><span class="line">                    min &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(min !&#x3D; i)&#123;</span><br><span class="line">                int temp &#x3D; arr[i];</span><br><span class="line">                arr[i] &#x3D; arr[min];</span><br><span class="line">                arr[min] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array &#x3D; &#123;3,2,4,1,5,0&#125;;</span><br><span class="line">        selectionSort(array);</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class shellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;1,8,3,4,2,0,5,6,3,2,8,9&#125;;</span><br><span class="line">        shell(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 希尔排序</span><br><span class="line">     * @param arr 要排序的数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void shell(int[] arr)&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;希尔排序实际上是直接插入排序的升级版本，在直接插入排序的算法中，如果越到后面突然出现某个比较小的值</span><br><span class="line">        &#x2F;&#x2F;这个时候排序的步骤就越长，希尔排序就是为了解决这个问题，先大致的排一下，然后拍的过程中用的是直接插入排序算法</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;首先计算步长</span><br><span class="line">        for(int d &#x3D; arr.length&#x2F;2;d&gt;0;d &#x3D; d&#x2F;2)&#123;</span><br><span class="line">            &#x2F;&#x2F;开始直接排序算法</span><br><span class="line">            &#x2F;&#x2F;先来一轮直接排序</span><br><span class="line">            for(int i &#x3D; d;i &lt; arr.length;i++)&#123;</span><br><span class="line">                &#x2F;&#x2F;然后开始交换</span><br><span class="line">                for(int j &#x3D; i - d;j &gt;&#x3D;0; j &#x3D; j-d)&#123;</span><br><span class="line">                    if(arr[j] &gt; arr[j+d])&#123;</span><br><span class="line">                        int temp &#x3D; arr[j];</span><br><span class="line">                        arr[j] &#x3D; arr[j+d];</span><br><span class="line">                        arr[j+d] &#x3D; temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images2018.cnblogs.com/blog/1032108/201807/1032108-20180724193606939-1891336874.jpg" alt></p><h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h2><p> 笔试时，遇到一个算法题：差不多是 在n个不同的数中随机取出不重复的m个数。洗牌算法是将原来的数组进行打散，使原数组的某个数在打散后的数组中的每个位置上等概率的出现，刚好可以解决该问题。</p><p>该算法是经典洗牌算法。它的proof如下：</p><p>对于arr[i],洗牌后在第n-1个位置的概率是1/n（第一次交换的随机数为i）<br>在n-2个位置概率是[(n-1)/n] * [1/(n-1)] = 1/n，（第一次交换的随机数不为i，第二次为arr[i]所在的位置（注意，若i=n-1，第一交换arr[n-1]会被换到一个随机的位置））<br>在第n-k个位置的概率是[(n-1)/n] * [(n-2)/(n-1)] <em>…</em> [(n-k+1)/(n-k+2)] *[1/(n-k+1)] = 1/n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">该算法的基本思想和 Fisher 类似，每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。</span><br><span class="line">算法步骤为：</span><br><span class="line">    1. 建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；</span><br><span class="line">    2. 生成一个从 0 到 n - 1 的随机数 x；</span><br><span class="line">    3. 输出 arr 下标为 x 的数值，即为第一个随机数；</span><br><span class="line">    4. 将 arr 的尾元素和下标为 x 的元素互换；</span><br><span class="line">    5. 同2，生成一个从 0 到 n - 2 的随机数 x；</span><br><span class="line">    6. 输出 arr 下标为 x 的数值，为第二个随机数；</span><br><span class="line">    7. 将 arr 的倒数第二个元素和下标为 x 的元素互换；</span><br><span class="line">……</span><br><span class="line">如上，直到输出 m 个数为止</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class hello &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] arr &#x3D; &#123;5,1,2,6,7,8,93,67,8,3,86,4,6,8,45,86&#125;;</span><br><span class="line">        flushArr(arr);</span><br><span class="line">        for(int num : arr)&#123;</span><br><span class="line">            System.out.print(num + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void flushArr(int[] arr)&#123;</span><br><span class="line">        for (i &#x3D; arr.length - 1; i &gt; 0; i--)</span><br><span class="line">        &#123;  </span><br><span class="line">            &#x2F;&#x2F;随机数生成器，范围[0, i]  </span><br><span class="line">            int rand &#x3D; (new Random()).nextInt(i+1);  </span><br><span class="line"></span><br><span class="line">            int temp &#x3D; arr[i];  </span><br><span class="line">            arr[i] &#x3D; arr[rand];  </span><br><span class="line">            arr[rand] &#x3D; temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int createRandom(int end)&#123;</span><br><span class="line">        return (new Random().nextInt(end));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最短路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[1,1,0,1],</span><br><span class="line"> [1,0,1,0],</span><br><span class="line"> [1,1,1,1],</span><br><span class="line"> [1,0,1,1]]</span><br><span class="line"> 1 表示可以经过某个位置，求解从 (0, 0) 位置到 (tr, tc) 位置的最短路径长度。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">static int min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">   static class Pair&#123;</span><br><span class="line">       int key;</span><br><span class="line">       int value;</span><br><span class="line">       public Pair(int key,int value) &#123;</span><br><span class="line">           this.key&#x3D;key;</span><br><span class="line">           this.value&#x3D;value;</span><br><span class="line">       &#125;</span><br><span class="line">       public int getKey() &#123;</span><br><span class="line">           return (int) this.key;</span><br><span class="line">       &#125;</span><br><span class="line">       public int getValue() &#123;</span><br><span class="line">           return (int) this.value;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       int [][]grids&#x3D; &#123;&#123;1,2&#125;,</span><br><span class="line">                       &#123;1,1&#125;&#125;;</span><br><span class="line">       minPathLength(grids, 1, 1);</span><br><span class="line">       System.out.println(min);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   public static void minPathLength(int[][] grids, int tr, int tc) &#123;</span><br><span class="line">       final int[][] direction &#x3D; &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">       int[][] s&#x3D;new int[2][2];</span><br><span class="line">       for(int i&#x3D;0;i&lt;2;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           for(int j&#x3D;0;j&lt;2;j++)</span><br><span class="line">           &#123;</span><br><span class="line">               s[i][j]&#x3D;300;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       s[0][0]&#x3D;1;</span><br><span class="line"></span><br><span class="line">       final int m &#x3D; grids.length, n &#x3D; grids[0].length;</span><br><span class="line">       Queue&lt;Pair&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">       queue.add(new Pair(0, 0));</span><br><span class="line">       int pathLength &#x3D; 0;</span><br><span class="line">       while (!queue.isEmpty()) &#123;</span><br><span class="line">           int size &#x3D; queue.size();</span><br><span class="line">           while (size-- &gt; 0) &#123;</span><br><span class="line">               Pair cur &#x3D; queue.poll();</span><br><span class="line">               int cr &#x3D; cur.getKey(), cc &#x3D; cur.getValue();</span><br><span class="line">               grids[cr][cc] &#x3D; 0; &#x2F;&#x2F; 标记</span><br><span class="line">               for (int[] d : direction) &#123;</span><br><span class="line">                   int nr &#x3D; cr + d[0], nc &#x3D; cc + d[1];</span><br><span class="line">                   if (nr &lt; 0 || nr &gt;&#x3D; m || nc &lt; 0 || nc &gt;&#x3D; n || s[nr][nc]&lt;&#x3D;s[cr][cc]+grids[nr][nc]) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   s[nr][nc]&#x3D;s[cr][cc]+grids[nr][nc];</span><br><span class="line">                   queue.add(new Pair(nr, nc));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       min&#x3D;Math.min(min,s[1][1]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="不同的数字"><a href="#不同的数字" class="headerlink" title="不同的数字"></a>不同的数字</h2><p>一个有序数组，有重复的数，平方后，数组当中有多少不同的数字,例子，[-1，3，3]，返回结果 2.</p><p>例子，[-1，-1，1，1]，返回结果 1. nums = {-2,-1,0,1,2,3} 返回4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int findDiff(int[] nums) &#123;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    int left &#x3D; 0;</span><br><span class="line">    int right &#x3D; nums.length - 1;</span><br><span class="line">    int pre &#x3D; - 1;</span><br><span class="line">   </span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        if (Math.abs(nums[left]) &gt; Math.abs(nums[right])) &#123;</span><br><span class="line">            if (pre !&#x3D; Math.abs(nums[left]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                pre &#x3D; Math.abs(nums[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (pre !&#x3D; abs(nums[right]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                pre &#x3D; abs(nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-hard"><a href="#leetcode-hard" class="headerlink" title="leetcode hard"></a>leetcode hard</h2><p>股票问题</p><p>4 中位数</p><p>10 正则匹配</p><p>23 合并K个</p><p>41 缺失第一个正数</p><p>44 通配符匹配</p><p>124 二叉树最大路径和</p><p>146 LRU</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>敲击url后发生了什么</title>
      <link href="/2020/07/10/%E6%95%B2%E5%87%BBurl%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/10/%E6%95%B2%E5%87%BBurl%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="https://camo.githubusercontent.com/c6bda910351aff0fc39247088fde335ab5bbf3c8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f2545352539302538342545372541372538442545372542442539312545372542422539432545382541462542372545362542312538322545372539342541382545352538382542302545372539412538342545352538442538462545382541452541452e6a7067" alt="各种网络请求用到的协议"></p><h3 id="DHCP-配置主机信息"><a href="#DHCP-配置主机信息" class="headerlink" title="DHCP 配置主机信息"></a>DHCP 配置主机信息</h3><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。<br>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。<br>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。<br>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。<br>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报<br>文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP<br>地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。<br>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了<br>MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。<br>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并<br>在其 IP 转发表中安装默认网关。</p><h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><p>浏览器会把输入的域名解析成对应的IP，其过程如下：</p><p>1.查找浏览器缓存：因为浏览器一般会缓存DNS记录一段时间，不同浏览器的时间可能不一样，一般2-30分钟不等，浏览器去查找这些缓存，如果有缓存，直接返回IP，否则下一步。</p><p>2.查找系统缓存：浏览器缓存中找不到IP之后，浏览器会进行系统调用（windows中是gethostbyname），查找本机的hosts文件，如果找到，直接返回IP，否则下一步。</p><p>3.查找路由器缓存：如果1,2步都查询无果，则需要借助网络，路由器一般都有自己的DNS缓存，将前面的请求发给路由器，查找ISP 服务商缓存 DNS的服务器，如果查找到IP则直接返回，没有的话继续查找。</p><p>4.递归查询：如果以上步骤还找不到，则ISP的DNS服务器就会进行递归查询，所谓递归查询就是如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步查询。（本地域名服务器地址是通过DHPC协议获取地址，DHPC是负责分配IP地址的）</p><p>5.迭代查询：本地域名服务器采用迭代查询，它先向一个根域名服务器查询。本地域名服务器向根域名服务器的查询一般都是采用迭代查询。所谓迭代查询就是当根域名服务器收到本地域名服务器发出的查询请求报文后，要么告诉本地域名服务器下一步应该查询哪一个域名服务器，然后本地域名服务器自己进行后续的查询。（而不是替代本地域名服务器进行后续查询）。</p><p>本例子中：根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.net的IP地址。本地域名服务器向顶级域名服务器dns.net进行查询。顶级域名服务器dns.net告诉本地域名服务器，下一次应查询的权限域名服务器dns.csdn.net的IP地址。本地域名服务器向权限域名服务器dns.csdn.net进行查询。权限域名服务器dns.csdn.net告诉本地域名服务器，所查询的主机<a href="http://www.csdn.net的IP地址。本地域名服务器最后把结果告诉主机。" target="_blank" rel="noopener">www.csdn.net的IP地址。本地域名服务器最后把结果告诉主机。</a></p><ol><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h3 id="浏览器与目标服务器建立TCP连接"><a href="#浏览器与目标服务器建立TCP连接" class="headerlink" title="浏览器与目标服务器建立TCP连接"></a>浏览器与目标服务器建立TCP连接</h3><ol><li><p>主机浏览器通过DNS解析得到了目标服务器的IP地址后，与服务器建立TCP连接。</p></li><li><p>TCP3次握手连接：浏览器所在的客户机向服务器发出连接请求报文（SYN标志为1）；服务器接收报文后，同意建立连接，向客户机发出确认报文（SYN，ACK标志位均为1）；客户机接收到确认报文后，再次向服务器发出报文，确认已接收到确认报文；此处客户机与服务器之间的TCP连接建立完成，开始通信。</p><p><img src="/2020/07/10/%E6%95%B2%E5%87%BBurl%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201116150659656.png" alt="image-20201116150659656"></p></li></ol><h3 id="服务器处理请求，发回响应"><a href="#服务器处理请求，发回响应" class="headerlink" title="服务器处理请求，发回响应"></a>服务器处理请求，发回响应</h3><h3 id="浏览器渲染解析"><a href="#浏览器渲染解析" class="headerlink" title="浏览器渲染解析"></a>浏览器渲染解析</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP和UDP相关问题</title>
      <link href="/2020/07/10/TCP%E5%92%8CUDP%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/10/TCP%E5%92%8CUDP%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>TCP提供可靠的、面向连接的运输服务。在传输数据之前必须三次握手建立连接，数据传输结束之后，4次挥手释放连接，而且在数据传递时，又有确认应答、超时重传、流量控制、拥塞控制等机制保证传送数据的可靠性。TCP经常用于对网络通信质量有很高要求的地方，如文件传输，邮件发送，远程登录等场景。SMTP、TELNET、HTTP、FTP</p><p>   UDP在传送数据之前不需要建立连接，目的主机收到UDP报文后，不需要给出确认。UDP不提供可靠交付，一般用于即时通信，如语音、视频、直播等。RIP(路由选择协议)，DNS</p><h2 id="什么是TCP的三次握手？"><a href="#什么是TCP的三次握手？" class="headerlink" title="什么是TCP的三次握手？"></a>什么是TCP的三次握手？</h2><p><img src="https://img-blog.csdnimg.cn/20200710095751436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="img"></p><p>假设 A 为客户端，B 为服务器端。</p><p>最初客户端和服务端都处于 CLOSED(关闭) 状态。ACK为确认值，ack为确认编号</p><p>一开始，服务器首先创建传输控制块TCB，然后处于 LISTEN(监听) 状态，等待客户端的连接请求。</p><p>· 第一次握手：A 的 TCP 客户端进程创建传输控制块 TCB、向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。</p><p>· 第二次握手：B 收到连接请求报文后，向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，己选择一个初始序号 seq = y，确认号 ack = x + 1。（请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。）这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。</p><p>· 第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。(这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。)这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</p><h2 id="为什么是三次握手？"><a href="#为什么是三次握手？" class="headerlink" title="为什么是三次握手？"></a>为什么是三次握手？</h2><p><strong>三次握手的原因主要有两个目的，信息对等和防止超时。</strong></p><p>从信息对等的角度看，双方只有确定 4 类信息才能建立连接，即 A 和 B 分别确认自己和对方的发送和接收能力正常。在第二次握手后，从 B 的角度看还不能确定自己的发送能力和对方的接收能力，只有在第三次握手后才能确认。</p><p>防止超时。三次握手也是防止失效连接突然到达导致脏连接，网络报文的生存时间往往会超过 TCP 请求超时时间，A 的某个超时连接请求可能会在双方释放连接之后到达 B，B 会误以为是 A 创建了新的连接请求，然后发送确认报文创建连接。如果是两次握手，连接已经建立了，服务器资源被白白浪费。如果是三次握手，B 由于长时间没有收到确认信息，最终超时导致创建连接失败，因此不会出现脏连接。</p><h2 id="四次挥手？"><a href="#四次挥手？" class="headerlink" title="四次挥手？"></a>四次挥手？</h2><p><img src="https://img-blog.csdnimg.cn/20200710100009759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="img"></p><p>由于TCP连接是全双工的，因此每个方向都必须单独关闭。当一方数据发送任务完成之后，可以发送FIN来终止这个方向的连接。而另一方可以继续发送数据。</p><p>· 客户端发送请求释放连接报文，FIN=1,seq=u;客户端进入FIN-WAIT-1状态；</p><p>· 服务器收到请求，发送确认报文。ACK=1,seq=v,ack=u+1;服务器进入CLOSE-WAIT状态。客户端收到后进入终止等待2FIN-WAIT-2;</p><p>· 服务器发送完数据之后，向客户端发送请求释放连接报文，FIN=1,ACK=1,seq=w,ack=u+1;进入LAST-ACK状态</p><p>·客户端收到请求后，发送确认报文，ACK=1,seq=u+1,ack=w+1。客户端进入TIME-WAIT状态，等待2MSL后进如CLOSED状态，服务器收到确认后进如CLOSED状态。</p><h2 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h2><p>第一点原因是为了保证被动关闭方可以进入 CLOSED 状态。MSL 是最大报文段寿命，等待 2MSL 可以保证 A 发送的最后一个确认报文能被 B 接收，如果该报文丢失，B 没有收到就会超时重传之前的 FIN+ACK 报文，而如果 A 在发送确认报文后就立即释放连接就无法收到 B 超时重传的报文，因而也不会再一次发送确认报文段，B 就无法正常进入 CLOSED 状态。</p><p>第二点原因是 2MSL 时间之后，本连接中的所有报文就都会从网络中消失，可以防止已失效连接的请求数据包与正常连接的请求数据包混淆而发生异常。</p><p>除此之外，TCP 还设有一个保活计时器，用于解决客户端主机故障的问题，服务器每收到一次客户的数据就重新设置保活计时器，时间为 2 小时。如果 2 小时内没有收到就间隔 75 秒发送一次探测报文，连续 10 次都没有响应后就关闭连接。</p><h2 id="TCP是怎么保证可靠的？"><a href="#TCP是怎么保证可靠的？" class="headerlink" title="TCP是怎么保证可靠的？"></a>TCP是怎么保证可靠的？</h2><p>TCP 的可靠传输包含很多机制，例如使用<strong>检验和</strong>来检测一个传输分组中的比特错误、使用<strong>定时器</strong>来用于超时重传一个分组、使用<strong>序号</strong>来检测丢失的分组和冗余副本、使用<strong>确认</strong>来告诉发送方确认的分组信息、使用<strong>否定确认</strong>来告诉发送方某个分组未被正确接收。除此之外，TCP 还使用<strong>流量控制</strong>和<strong>拥塞控制</strong>来保证可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ICMP及其应用</title>
      <link href="/2020/07/09/ICMP%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2020/07/09/ICMP%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ICMP 报文是封装在 IP 包里面的。ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><h2 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h2><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。<br>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时<br>间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p>ping 命令执行的时候，源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。最重要的是两个，第一个是类型字段，对于请求数据包而言该字段为 8；另外一个是顺序号，主要用于区分连续 ping 的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加 1。</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。应答数据包的类型字段为 0，构建新的ICMP数据包，发回给主机A，此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><h2 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h2><p>（<em>ip</em>可以传输的最大的数据报,）</p><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。<br>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文</p><ul><li><p>Traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。将TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了。如果中间的路由器不止一个，当然碰到第一个就“牺牲”。于是，返回一个 ICMP 包，也就是网络差错包，类型是时间超时。接下来，将 TTL 设置为2.。。这样，Traceroute 就拿到了所有的路由器 IP。怎么知道 UDP 有没有到达目的主机呢？Traceroute 程序会发送一份 UDP 数据报给目的主机，但它会选择一个不可能的值作为 UDP 端口号（大于 30000）。当该数据报到达时，将使目的主机的 UDP 模块产生一份“端口不可达”错误 ICMP 报文。如果数据报没有到达，则可能是超时</p></li><li><p>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。要做的工作首先是发送分组，并设置“不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果</p></li></ul><p>中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包，</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis高可用</title>
      <link href="/2020/07/05/redis%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>/2020/07/05/redis%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>Redis多副本（主从）</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6EJvicazJ6KzImNoKH1nofWM9rqIR6VUWeDxJHhJHIQgDFF9Hb5kRnGkNicM7KGfpad5VnUo0pOQjm2Fw7TGUs0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>Redis 多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。</p><p>优点：</p><p>1、高可靠性，一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行。另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题。</p><p>2、读写分离策略，从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</p><p>缺点：</p><p>1、故障恢复复杂，如果没有RedisHA系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其他从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐。</p><p>2、主库的写能力受到单机的限制，可以考虑分片</p><p>3、主库的存储能力受到单机的限制，可以考虑Pika</p><p>4、原生复制的弊端在早期的版本也会比较突出，如：Redis复制中断后，Slave会发起psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于COW机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘IO和CPU（压缩）资源消耗；发送数GB大小的备份文件导致服务器出口带宽暴增，阻塞请求。建议升级到最新版本。</p><p><strong>Redis Sentinel（哨兵）</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6EJvicazJ6KzImNoKH1nofWM9rqIR6VUW1ibIW7Go066hNFQF5jUpkv5NN8RIA4McUSyRPVb82OTnpnWnmKyrDbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>Redis Sentinel是社区版本推出的原生高可用解决方案，Redis Sentinel部署架构主要包括两部分：Redis Sentinel集群和Redis数据集群，其中Redis Sentinel集群是由若干Sentinel节点组成的分布式集群。可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel的节点数量要满足2n+1（n&gt;=1）的奇数个。</p><p>优点：</p><p>1、Redis Sentinel集群部署简单</p><p>2、能够解决Redis主从模式下的高可用切换问题</p><p>3、很方便实现Redis数据节点的线形扩展，轻松突破Redis自身单线程瓶颈，可极大满足对Redis大容量或高性能的业务需求。</p><p>4、可以实现一套Sentinel监控一组Redis数据节点或多组数据节点</p><p>缺点：</p><p>1、部署相对Redis 主从模式要复杂一些，原理理解更繁琐</p><p>2、资源浪费，Redis数据节点中slave节点作为备份节点不提供服务</p><p>3、Redis Sentinel主要是针对Redis数据节点中的主节点的高可用切换，对Redis的数据节点做失败判定分为主观下线和客观下线两种，对于Redis的从节点有对节点做主观下线操作，并不执行故障转移。</p><p>4、不能解决读写分离问题，实现起来相对复杂</p><p>建议：</p><p>1、如果监控同一业务，可以选择一套Sentinel集群监控多组Redis数据节点的方案，反之选择一套Sentinel监控一组Redis数据节点的方案</p><p>2、sentinel monitor <master-name> <ip> <port> <quorum> 配置中的<quorum>建议设置成Sentinel节点的一半加1，当Sentinel部署在多个IDC的时候，单个IDC部署的Sentinel数量不建议超过（Sentinel数量 – quorum）。</quorum></quorum></port></ip></master-name></p><p>3、合理设置参数，防止误切，控制切换灵敏度控制</p><ol><li>quorum</li><li>down-after-milliseconds 30000</li><li>failover-timeout 180000</li><li>maxclient</li><li>timeout</li></ol><p>4、部署的各个节点服务器时间尽量要同步，否则日志的时序性会混乱</p><p>5、Redis建议使用pipeline和multi-keys操作，减少RTT次数，提高请求效率</p><p>6、自行搞定配置中心（zookeeper），方便客户端对实例的链接访问</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6EJvicazJ6KzImNoKH1nofWM9rqIR6VUWNSEC8dvIoHtWlm4OyK3KxaXc4sSzibK0nFC4hNKhhsPXibrQibFwLOglA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>Redis Cluster是社区版推出的Redis分布式集群解决方案，主要解决Redis分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster能起到很好的负载均衡的目的。Redis Cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p><p>优点：</p><p>1、无中心架构</p><p>2、数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p><p>3、可扩展性，可线性扩展到1000多个节点，节点可动态添加或删除。</p><p>4、高可用性，部分节点不可用时，集群仍可用。通过增加Slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升。</p><p>5、降低运维成本，提高系统的扩展性和可用性。</p><p>缺点：</p><p>1、Client实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅JedisCluster相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</p><p>2、节点会因为某些原因发生阻塞（阻塞时间大于clutser-node-timeout），被判断下线，这种failover是没有必要的。</p><p>3、数据通过异步复制,不保证数据的强一致性。</p><p>4、多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</p><p>5、Slave在集群中充当“冷备”，不能缓解读压力，当然可以通过SDK的合理设计来提高Slave资源的利用率。</p><p>6、key批量操作限制，如使用mset、mget目前只支持具有相同slot值的key执行批量操作。对于映射为不同slot值的key由于keys 不支持跨slot查询，所以执行mset、mget、sunion等操作支持不友好。</p><p>7、key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个key分布于不同的节点上时无法使用事务功能。</p><p>8、key作为数据分区的最小粒度，因此不能将一个很大的键值对象如hash、list等映射到不同的节点。</p><p>9、不支持多数据库空间，单机下的redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0。</p><p>10、复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p><p>11、避免产生hot-key，导致主库节点成为系统的短板。</p><p>12、避免产生big-key，导致网卡撑爆、慢查询等。</p><p>13、重试时间应该大于cluster-node-time时间</p><p>14、Redis Cluster不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis写入和删除的原理</title>
      <link href="/2020/07/05/redis%E5%86%99%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2020/07/05/redis%E5%86%99%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/ea15a1e0d43d" target="_blank" rel="noopener">https://www.jianshu.com/p/ea15a1e0d43d</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis相关问题剖析</title>
      <link href="/2020/07/05/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/05/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Redis-学习笔记"><a href="#Redis-学习笔记" class="headerlink" title="Redis 学习笔记"></a>Redis 学习笔记</h1><h2 id="初识-Redis"><a href="#初识-Redis" class="headerlink" title="初识 Redis"></a>初识 Redis</h2><p>Redis 是一种基于键值对的 NoSQL 数据库，Redis 中的值可以是由 string、hash、list、set、zset 等多种数据结构和算法组成，因此 Redis 可以满足很多应用场景。Redis 将所有数据都存放在内存中，所以它的读写能力也非常高。Redis 还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会丢失。除了这些功能，Redis 还提供了键过期、发布订阅、事务、流水线、Lua 等附加功能。</p><h3 id="Redis-的特性"><a href="#Redis-的特性" class="headerlink" title="Redis 的特性"></a>Redis 的特性</h3><p><strong>速度快</strong></p><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用多路I/O复用模型，非阻塞IO；</p><p><strong>基于键值对的数据结构服务器</strong></p><p>与很多键值对数据库不同的是，Redis 中的值不仅可以是字符串，还可以是具体的数据结构，这样不仅能应用于多种场景开发，也可以提高开发效率。Redis 的全称是 REmote Dictionary Server，它主要提供五种数据结构：字符串、哈希、列表、集合、有序集合，同时在字符串的基础上演变出了位图和 HyperLogLog 两种数据结构，随着 LBS 基于位置服务的发展，Redis 3.2 加入了有关 GEO 地理信息定位的功能。</p><p><strong>丰富的功能</strong></p><p>① 提供了键过期功能，可以实现缓存。② 提供了发布订阅功能，可以实现消息系统。③ 支持 Lua 脚本，可以创造新的 Redis 命令。④ 提供了简单的事务功能，能在一定程度商保证事务特性。⑤ 提供了流水线功能，这样客户端能将一批命令一次性传到 Redis，减少了网络开销。⑤IO多路复用</p><p><strong>持久化</strong></p><p>通常来说数据放在内存中是不安全的，一旦发生断电或故障数据就可能丢失，因此 Redis 提供了两种持久化方式 RDB 和 AOF 将内存的数据保存到硬盘中。</p><p><strong>对单线程的理解？</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/10378860-f024bea7843b5e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507/format/webp" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/10378860-50aff3db93e8df4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/657/format/webp" alt="img"></p><p>redis的IO复用是基于单线程的，但它的一些模块，比如删除过期缓存是多线程的</p><h3 id="Redis-的使用场景"><a href="#Redis-的使用场景" class="headerlink" title="Redis 的使用场景"></a>Redis 的使用场景</h3><p><strong>缓存</strong></p><p>缓存机制几乎在所有大型网站都有使用，合理使用缓存不仅可以加快数据的访问速度，而且能够有效降低后端数据源的压力。Redis 提供了键值过期时间设置，并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。</p><p><strong>排行榜系统</strong></p><p>排行榜系统几乎存在于所有网站，Redis 提供了列表和有序集合数据结构，合理使用这些数据结构可以方便构建各各种排行榜系统。</p><p><strong>计数器应用</strong></p><p>计数器在网站中的作用很重要，例如视频网站有播放数、电商网站有浏览数，为了保证数据实时性，每一次播放和浏览都要做加 1 的操作，如果并发量很大对于传统关系型数据库的性能是很大的挑战。Redis 天然支持计数功能而且性能也非常好。</p><p><strong>社交网络</strong></p><p>粉丝、共同好友/喜好、推送、下拉刷新等是社交网络的必备功能，由于社交网站的访问量通常很大，而且关系型数据不太适合保存这种类型的数据，Redis 提供的数据结构可以相对容易地实现这些功能。</p><p><strong>消息队列系统</strong></p><p>消息队列系统是一个大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis 提供了发布订阅和阻塞队列的功能，对于一般的消息队列功能基本可以满足。</p><p><strong>Redis 不适合非常大的数据量，成本非常高，也不适合冷数据，会浪费内存。</strong></p><hr><h2 id="API-的理解和使用"><a href="#API-的理解和使用" class="headerlink" title="API 的理解和使用"></a>API 的理解和使用</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串类型是 Redis 最基础的数据结构，键都是字符串类型，而且其他几种数据结构都是在字符串类型的基础上构建的。字符串类型的值可以实际可以是字符串（简单的字符串、复杂的字符串如 JSON、XML）、数字（整形、浮点数）、甚至二进制（图片、音频、视频），但是值最大不能超过 512 MB。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><strong>设置值</strong></p><p><code>set key value [ex seconds] [px millseconds] [nx|xx]</code></p><ul><li>ex seconds：为键设置秒级过期时间，跟 setex 效果一样</li><li>px millseconds：为键设置毫秒级过期时间</li><li>nx：键必须不存在才可以设置成功，用于添加，跟 setnx 效果一样。由于 Redis 的单线程命令处理机制，如果多个客户端同时执行，则只有一个客户端能设置成功，可以用作分布式锁的一种实现。</li><li>xx：键必须存在才可以设置成功，用于更新</li></ul><p><strong>获取值</strong></p><p><code>get key</code>，如果不存在返回 nil</p><p><strong>批量设置值</strong></p><p><code>mset key value [key value...]</code></p><p><strong>批量获取值</strong></p><p><code>mget key [key...]</code></p><p>批量操作命令可以有效提高开发效率，假如没有 mget，执行 n 次 get 命令需要 n 次网络时间 + n 次命令时间，使用 mget 只需要 1 次网络时间 + n 次命令时间。</p><p>Redis 可以支持每秒数万的读写操作，但这指的是 Redis 服务端的处理能力，对于客户端来说一次命令处理命令时间还有网络时间。因为 Redis 的处理能力已足够高，对于开发者来说，网络可能会成为性能瓶颈。</p><p><strong>计数</strong></p><p><code>incr key</code></p><p>incr 命令用于对值做自增操作，返回结果分为三种：① 值不是整数返回错误。② 值是整数，返回自增后的结果。③ 值不存在，按照值为 0 自增，返回结果 1。除了 incr 命令，还有自减 decr、自增指定数字 incrby、自减指定数组 decrby、自增浮点数 incrbyfloat。</p><hr><h4 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h4><p><strong>追加值</strong></p><p>append key  value，可以向字符串尾部追加值</p><p><strong>字符串长度</strong></p><p><code>strlen key</code></p><p><strong>设置并返回原值</strong></p><p><code>getset key value</code></p><p><strong>设置指定位置的字符</strong></p><p><code>setrange key offset value</code></p><p><strong>获取部分字符串</strong></p><p><code>getrange key start end</code>，start 和 end分别是开始和结束的偏移量，偏移量从 0 开始计算。</p><hr><h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><p>字符串类型的内部编码有三种:</p><ul><li>int：8 个字节的长整形</li><li>embstr：小于等于 39 个字节的字符串</li><li>raw：大于 39 个字节的字符串</li></ul><hr><h4 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h4><p><strong>缓存功能</strong></p><p>Redis 作为缓存层，MySQL 作为存储层，首先从 Redis 获取数据，如果没有获取到就从 MySQL 获取，并将结果写回到 Redis，添加过期时间。</p><p><strong>计数</strong></p><p>Redis 可以实现快速计数功能，例如视频每播放一次就用 incy 把播放数加 1。</p><p><strong>共享 Session</strong></p><p>一个分布式 Web 服务将用户的 Session 信息保存在各自服务器，但会造成一个问题，出于负载均衡的考虑，分布式服务会将用户的访问负载到不同服务器上，用户刷新一次可能会发现需要重新登陆。为解决该问题，可以使用 Redis 将用户的 Session 进行集中管理，在这种模式下只要保证 Redis 是高可用和扩展性的，每次用户更新或查询登录信息都直接从 Redis 集中获取。</p><p><strong>限速</strong></p><p>例如为了短信接口不被频繁访问会限制用户每分钟获取验证码的次数或者网站限制一个 IP 地址不能在一秒内访问超过 n 次。可以使用键过期策略和自增计数实现。</p><hr><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>哈希类型是指键值本身又是一个键值对结构，哈希类型中的映射关系叫做 field-value，这里的 value 是指 field 对于的值而不是键对于的值。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><strong>设置值</strong></p><p><code>hset key field value</code>，如果设置成功会返回 1，反之会返回 0，此外还提供了 hsetnx 命令，作用和 setnx 类似，只是作用于由键变为 field。</p><p><strong>获取值</strong></p><p><code>hget key field</code>，如果不存在会返回 nil。</p><p><strong>删除 field</strong></p><p><code>hdel key field [field...]</code>，会删除一个或多个 field，返回结果为删除成功 field 的个数。</p><p><strong>计算 field 个数</strong></p><p><code>hlen key</code></p><p><strong>批量设置或获取 field-value</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field...]</span><br><span class="line">hmset key field value [field value...]</span><br></pre></td></tr></table></figure><p>hmset 需要的参数是 key 和多对 field-value，hmget 需要的参数是 key 和多个 field。</p><p><strong>判断 field 是否存在</strong></p><p><code>hexists key field</code>，存在返回 1，否则返回  0。</p><p><strong>获取所有的 field</strong></p><p><code>hkeys key</code>，返回指定哈希键的所有 field。</p><p><strong>获取所有 value</strong></p><p><code>hvals key</code>，获取指定键的所有 value。</p><p><strong>获取所有的 field-value</strong></p><p><code>hgetall key</code>，获取指定键的所有 field-value。</p><p><strong>计数</strong></p><p><code>hincrby key field</code> 和 <code>hincrbyfloat key field</code>，作用和 incrby 和 incrbyfloat 一样，作用域是 field。</p><p><strong>计算 value 的字符串长度</strong></p><p>hstrlen key field</p><hr><h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><p>哈希类型的内部编码有两种：</p><ul><li>ziplist 压缩列表：当哈希类型元素个数和值小于配置值（默认 512 个和 64 字节）时会使用 ziplist 作为内部实现，使用更紧凑的结构实现多个元素的连续存储，在节省内存方面比 hashtable 更优秀。</li><li>hashtable 哈希表：当哈希类型无法满足 ziplist 的条件时会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度都为 O(1)。</li></ul><hr><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>缓存用户信息，有三种实现：</p><ul><li><p>原生字符串类型：每个属性一个键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set user:1:name tom</span><br><span class="line">set user:1:age 23</span><br><span class="line">set user:1:city xi&#39;an</span><br></pre></td></tr></table></figure><p>优点：简单直观，每个属性都支持更新操作。</p><p>缺点：占用过多的键，内存占用量较大，用户信息内聚性差，一般不会在生产环境使用。</p></li><li><p>序列化字符串类型：将用户信息序列化后用一个键保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set user:1 serialize(userInfo)</span><br></pre></td></tr></table></figure><p>优点：编程简单，如果合理使用序列化可以提高内存使用率。</p><p>缺点：序列化和反序列化有一定开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到 Redis。</p></li><li><p>哈希类型：每个用户属性使用一对 field-value，但只用一个键保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset user:1 name tom age 23 city xi&#39;an</span><br></pre></td></tr></table></figure><p>优点：简单直观，如果合理使用可以减少内存空间使用。</p><p>缺点：要控制哈希在 ziplist 和 hashtable 两种内部编码的转换，hashtable 会消耗更多内存。</p></li></ul><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表类型是用来存储多个有序的字符串，列表中的每个字符串称为元素，一个列表最多可以存储 2^32^-1 个元素。可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发中有很多应用场景。</p><p>列表类型有两个特点：① 列表中的元素是有序的，可以通过索引下标获取某个元素或者某个范围内的元素列表。② 列表中的元素可以重复。</p><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><p><strong>添加操作</strong></p><p>从右边插入元素：<code>rpush key value [value...]</code></p><p>从左到右获取列表的所有元素：<code>lrange 0 -1</code></p><p>从左边插入元素：<code>lpush key value [value...]</code></p><p>向某个元素前或者后插入元素：<code>linsert key before|after pivot value</code>，会在列表中找到等于 pivot 的元素，在其前或后插入一个新的元素 value。</p><p><strong>查找</strong></p><p>获取指定范围内的元素列表：<code>lrange key start end</code>，索引从左到右的范围是 0<del>N-1，从右到左是 -1</del>-N，lrange 中的 end 包含了自身。</p><p>获取列表指定索引下标的元素：<code>lindex key index</code>，获取最后一个元素可以使用 <code>lindex key -1</code>。</p><p>获取列表长度：<code>llen key</code></p><p><strong>删除</strong></p><p>从列表左侧弹出元素：<code>lpop key</code></p><p>从列表右侧弹出元素：<code>rpop key</code></p><p>删除指定元素：<code>lrem key count value</code>，如果 count 大于 0，从左到右删除最多 count 个元素，如果 count 小于 0，从右到左删除最多个 count 绝对值个元素，如果 count 等于 0，删除所有。</p><p>按照索引范围修剪列表：<code>ltrim key start end</code>，只会保留 start ~ end 范围的元素。</p><p><strong>修改</strong></p><p>修改指定索引下标的元素：<code>lset key index newValue</code>。</p><p><strong>阻塞操作</strong></p><p>阻塞式弹出：<code>blpop/brpop key [key...] timeout</code>，timeout 表示阻塞时间。</p><p>当列表为空时，如果 timeout = 0，客户端会一直阻塞，如果在此期间添加了元素，客户端会立即返回。</p><p>如果是多个键，那么brpop会从左至右遍历键，一旦有一个键能弹出元素，客户端立即返回。</p><p>如果多个客户端对同一个键执行 brpop，那么最先执行该命令的客户端可以获取弹出的值。</p><hr><h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><p>列表的内部编码有两种：</p><ul><li>ziplist 压缩列表：跟哈希的 zipilist 相同，元素个数和大小小于配置值（默认 512 个和 64 字节）时使用。</li><li>linkedlist 链表：当列表类型无法满足 ziplist 的条件时会使用linkedlist。</li></ul><p>Redis 3.2 提供了 quicklist 内部编码，它是以一个 ziplist 为节点的 linkedlist，它结合了两者的优势，为列表类提供了一种更为优秀的内部编码实现。</p><hr><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p><strong>消息队列</strong></p><p>Redis 的 lpush + brpop 即可实现阻塞队列，生产者客户端使用 lpush 从列表左侧插入元素，多个消费者客户端使用 brpop 命令阻塞式地抢列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</p><p><strong>文章列表</strong></p><p>每个用户有属于自己的文章列表，现在需要分页展示文章列表，就可以考虑使用列表。因为列表不但有序，同时支持按照索引范围获取元素。每篇文章使用哈希结构存储，例如每篇文章有三个属性，title、timestamp 和 content：</p><p><code>hmset article:k title t timestamp 147651524 content c</code>。</p><p>向用户文章列表添加文章，<code>user:{id}:articles</code> 作为用户文章列表的键：</p><p><code>lpush user:k:articles article:k</code>。</p><p>分页获取用户文章列表，例如以下伪代码获取用户 id = 1 的前 10 篇文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">articles &#x3D; lrange user:1:articles 0 9</span><br><span class="line">for article in &#123;articles&#125;</span><br><span class="line">hgetall &#123;article&#125;</span><br></pre></td></tr></table></figure><p>使用列表类型保存和获取文章列表存在两个问题：① 如果每次分页获取的文章个数较多，需要执行多次 hgetall 操作，此时可以考虑使用 Pipeline 批量获取，或者考虑将文章数据序列化为字符串类型，使用 mget 批量获取。② 分页获取文章列表时，lrange 命令在列表两端性能较好，但如果列表大，获取中间范围的元素性能会变差，可以考虑将列表做二级拆分，或使用 Redis3.2 的 quicklist。</p><hr><p><strong>lpush + lpop = 栈</strong></p><p><strong>lpush + rpop  = 队列</strong></p><p><strong>lpush + ltrim = 优先集合</strong></p><p><strong>lpush + brpop = 消息队列</strong></p><hr><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合类型也是用来保存多个字符串元素，和列表不同的是集合不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。一个集合最多可以存储 2^32^-1 个元素。Redis 除了支持集合内的增删改查，还支持多个集合取交集、并集、差集。</p><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><p><strong>集合内操作</strong></p><p><strong>添加元素</strong></p><p><code>sadd key element [element...]</code>，返回结果为添加成功的元素个数。</p><p><strong>删除元素</strong></p><p><code>srem key element [element...]</code>，返回结果为成功删除的元素个数。</p><p><strong>计算元素个数</strong></p><p><code>scard key</code>，时间复杂度为 O(1)，会直接使用 Redis 内部的遍历。</p><p><strong>判断元素是否在集合中</strong></p><p><code>sismember key element</code>，如果存在返回 1，否则返回 0。</p><p><strong>随机从集合返回指定个数个元素</strong></p><p><code>srandmember key [count]</code>，如果不指定 count 默认为 1。</p><p><strong>从集合随机弹出元素</strong></p><p><code>spop key</code>，可以从集合中随机弹出一个元素。</p><p><strong>获取所有元素</strong></p><p><code>smembers key</code></p><hr><p><strong>集合间操作</strong></p><p><strong>求多个集合的交集</strong></p><p><code>sinter key [key...]</code></p><p><strong>求多个集合的并集</strong></p><p><code>sunion key [key...]</code></p><p><strong>求多个集合的差集</strong></p><p><code>sdiff key [key...]</code></p><p><strong>保存交集、并集、差集的结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key [key...]</span><br><span class="line">sunionstore destination destination key [key...]</span><br><span class="line">sdiffstore destination key [key...]</span><br></pre></td></tr></table></figure><p>集合间的运算在元素较多的情况下会比较耗时，所以 Redis 提供了这三个指令将集合间交集、并集、差集的结果保存在 destination key 中。</p><hr><h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><p>集合类型的内部编码有两种：</p><ul><li>intset 整数集合：当集合中的元素个数小于配置值（默认 512 个时），,且都是整数时，使用 intset。</li><li>hashtable 哈希表：当集合类型无法满足 intset 条件时使用 hashtable。当某个元素不为整数时，也会使用 hashtable。</li></ul><hr><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>集合类型比较典型的使用场景是标签，例如一个用户可能与娱乐、体育比较感兴趣，另一个用户可能对例时、新闻比较感兴趣，这些兴趣点就是标签。这些数据对于用户体验以及增强用户黏度比较重要。</p><p><strong>给用户添加标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2 tag5</span><br><span class="line">sadd user:2:tags tag3 tag4 tag5</span><br><span class="line">...</span><br><span class="line">sadd user:k:tags tagx tagy tagz</span><br></pre></td></tr></table></figure><p><strong>给标签添加用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd tag:1:users user:1 user:3</span><br><span class="line">sadd tag:2:users user:1 user:4 user:5</span><br><span class="line">...</span><br><span class="line">sadd tag:k:users user:x user:y ...</span><br></pre></td></tr></table></figure><p>用户和标签的关系维护应该在一个事务内执行，防止部分命令失败造成的数据不一致。</p><p><strong>删除用户标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem user:1:tags tag1 tag5</span><br></pre></td></tr></table></figure><p><strong>删除标签下的用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem tag:1:users user:1</span><br></pre></td></tr></table></figure><p>删除也同样应该放在一个事务中。</p><p><strong>求两个用户共同感兴趣的标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinter user:1:tags user:2:tags</span><br></pre></td></tr></table></figure><p><strong>sadd = 标签</strong></p><p><strong>spop/srandmember = 生成随机数，比如抽奖</strong></p><p><strong>sadd + sinter = 社交需求</strong></p><hr><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>有序集合保留了集合不能有重复成员的特性，不同的是可以排序。但是它和列表使用索引下标作为排序依据不同的是，他给每个元素设置一个分数（score）作为排序的依据。有序集合提供了获取指定分数和元素查询范围、计算成员排名等功能。</p><table><thead><tr><th>数据结构</th><th>是否允许元素重复</th><th>是否有序</th><th>有序实现方式</th><th>应用场景</th></tr></thead><tbody><tr><td>列表</td><td>是</td><td>是</td><td>下标</td><td>时间轴，消息队列</td></tr><tr><td>集合</td><td>否</td><td>否</td><td>/</td><td>标签，社交</td></tr><tr><td>有序集合</td><td>否</td><td>是</td><td>分值</td><td>排行榜，社交</td></tr></tbody></table><h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><p><strong>集合内</strong></p><p><strong>添加成员</strong></p><p><code>zadd key score member [score member...]</code>，返回结果是成功添加成员的个数</p><p>Redis 3.2 为 zadd 命令添加了 nx、xx、ch、incr 四个选项：</p><ul><li>nx：member 必须不存在才可以设置成功，用于添加</li><li>xx：member 必须存在才能设置成功，用于更新</li><li>ch：返回此次操作后，有序集合元素和分数变化的个数</li><li>incr：对 score 做增加，相当于 zincrby</li></ul><p>zadd 的时间复杂度为 O(log<del>n</del>)，sadd 的时间复杂度为 O(1)。</p><p><strong>计算成员个数</strong></p><p><code>zcard key</code>，时间复杂度为 O(1)。</p><p><strong>计算某个成员的分数</strong></p><p><code>zscore key member</code> ，如果不存在则返回 nil。</p><p><strong>计算成员排名</strong></p><p><code>zrank key member</code>，从低到高返回排名</p><p><code>zrevrank key member</code>，从高到低返回排名</p><p><strong>删除成员</strong></p><p><code>zrem key member [member...]</code>，返回结果是成功删除的个数。</p><p><strong>增加成员的分数</strong></p><p><code>zincrby key increment member</code></p><p><strong>返回指定排名范围的成员</strong></p><p><code>zrange key start end [withscores]</code></p><p><code>zrevrange key start end [withscores]</code></p><p>zrange 从低到高返回，zrevrange 从高到底返回，如果加上 withscores 选项同时会返回成员的分数。</p><p><strong>返回指定分数范围的成员</strong></p><p><code>zrangebyscore key min max [withscores] [limit offset count]</code></p><p><code>zrevrangebyscore key min max [withscores] [limit offset count]</code></p><p>zrangebyscore 从低到高返回，zrevrangebyscore 从高到底返回，如果加上 withscores 选项同时会返回成员的分数。[limit offset count] 可以限制输出的起始位置和个数。</p><p><strong>返回指定分数范围成员个数</strong></p><p><code>zcount key min max</code></p><p><strong>删除指定排名内的升序元素</strong></p><p><code>zremrangebyrank key start end</code></p><p><strong>删除指定分数范围内的成员</strong></p><p><code>zremrangebyscore key min max</code></p><hr><p><strong>集合间的操作</strong></p><p><strong>交集</strong></p><p><code>zinterstore destination numkeys key [key...] [weights weight [weight...]] [aggregate sum|min|max]</code></p><ul><li><p>destination：交集结果保存到这个键</p></li><li><p>numkeys：要做交集计算键的个数</p></li><li><p>key [key…]：需要做交集计算的键</p></li><li><p>weights weight [weight…]：每个键的权重，默认 1</p></li><li><p>aggregate sum|min|max：计算交集后，分值可以按和、最小值、最大值汇总，默认 sum</p></li></ul><p><strong>并集</strong></p><p><code>zunionstore destination numkeys key [key...] [weights weight [weight...]] [aggregate sum|min|max]</code></p><hr><h4 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h4><p>有序集合的内部编码有两种：</p><ul><li>ziplist 压缩列表：当有序集合元素个数和值小于配置值（默认128 个和 64 字节）时会使用 ziplist 作为内部实现。</li><li>skiplist 跳跃表：当 ziplist 不满足条件时使用，因为此时 ziplist 的读写效率会下降。</li></ul><hr><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>有序集合的典型使用场景就是排行榜系统。</p><p>例如用户 mike 上传了一个视频并添加了 3 个赞，可以使用有序集合的 zadd 和 zincrby：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd user:ranking:2020_06_19 3 mike</span><br></pre></td></tr></table></figure><p>如果之后再获得一个赞，可以使用 zincrby：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zincrby user:ranking:2020_06_19 1 mike</span><br></pre></td></tr></table></figure><p>例如需要将用户 tom 从榜单删除，可以使用 zrem：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem user:ranking:2020_06_19 tom</span><br></pre></td></tr></table></figure><p>展示获取赞数最多的十个用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrange user:ranking:2020_06_19 0 9</span><br></pre></td></tr></table></figure><p>展示用户信息及用户分数，将用户名作为键后缀，将用户信息保存在哈希类型中，至于用户分数和排名可以使用 zscore 和 zrank：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hgetall user:info:tom</span><br><span class="line">zscore user:ranking:2020_06_19 tom</span><br><span class="line">zrank user:ranking:2020_06_19 tom</span><br></pre></td></tr></table></figure><hr><h3 id="键管理"><a href="#键管理" class="headerlink" title="键管理"></a>键管理</h3><h4 id="单个键管理"><a href="#单个键管理" class="headerlink" title="单个键管理"></a>单个键管理</h4><p><strong>键重命名</strong></p><p><code>rename key newkey</code></p><p>如果 rename 前键已经存在，那么它的值也会被覆盖。</p><p>为了防止强行覆盖，Redis 提供了 renamenx 命令，确保只有 newkey 不存在时才被覆盖。由于重命名键期间会执行 del 命令删除旧的键，如果键对应值比较大会存在阻塞的可能。</p><p><strong>随机返回一个键</strong></p><p><code>random key</code></p><p><strong>键过期</strong></p><p><code>expire key seconds</code>：键在 seconds 秒后过期</p><p><code>expireat key timestamp</code>：键在秒级时间戳 timestamp 后过期</p><p>如果过期时间为负值，键会被立即删除，和 del 命令一样。</p><p>persist 命令可以将键的过期时间清除。</p><p>对于字符串类型键，执行 set 命令会去掉过期时间，set 命令对应的函数 setKey 最后执行了 removeExpire 函数去掉了过期时间。</p><p>Redis 不支持二级数据结构（例如哈希、列表）内部元素的过期功能，例如不能对列表类型的一个元素设置过期时间。</p><p>setex 命令作为 set + expire 的组合，不单是原子执行并且减少了一次网络通信的时间。</p><p><strong>键迁移</strong></p><ul><li><p>move</p><p><code>move key db</code></p><p>move 命令用于在 Redis 内部进行数据迁移，<code>move key db</code> 就是把指定的键从源数据库移动到目标数据库中。</p></li><li><p>dump + restore</p><p><code>dump key</code></p><p><code>restore key ttl value</code></p><p>可以实现在不同的 Redis 势力之间进行数据迁移，分为两步：</p><p>① 在源 Redis 上，dump 命令会将键值序列化，格式采用 RDB 格式。</p><p>② 在目标 Redis 上，restore 命令将上面序列化的值进行复原，ttl 参数代表过期时间， ttl = 0 则没有过期时间。</p><p>整个迁移并非原子性的，而是通过客户端分步完成，并且需要两个客户端。</p></li><li><p>migrate</p><p>实际上 migrate 命令就是将 dump、restore、del 三个命令进行组合，从而简化了操作流程。migrate 具有原子性，且支持多个键的迁移，有效提高了迁移效率。实现过程和 dump + restore 类似，有三点不同：</p><p>① 整个过程是原子执行，不需要在多个 Redis 实例开启客户端。</p><p>② 数据传输直接在源 Redis 和目标 Redis 完成。</p><p>③ 目标 Redis 完成 restore 后会发送 OK 给源 Redis，源 Redis 接收后会根据 migrate 对应的选项来决定是否在源 Redis 上删除对应的键。</p></li></ul><table><thead><tr><th>命令</th><th>作用域</th><th>原子性</th><th>支持多个键</th></tr></thead><tbody><tr><td>move</td><td>Redis 实例内部</td><td>是</td><td>否</td></tr><tr><td>dump + restore</td><td>Redis 实例之间</td><td>否</td><td>否</td></tr><tr><td>migrate</td><td>Redis 实例之间</td><td>是</td><td>是</td></tr></tbody></table><hr><h4 id="遍历键"><a href="#遍历键" class="headerlink" title="遍历键"></a>遍历键</h4><p><strong>全量遍历键</strong></p><p><code>keys pattern</code></p><p><code>*</code>代表匹配任意字符，<code>?</code> 匹配一个字符，<code>[]</code> 匹配部分字符，例如 <code>[1,3]</code> 匹配 1 和 3， <code>[1-3]</code> 匹配 1 到 3 的任意数字，<code>\</code>用来做转义。</p><p><code>keys *</code> 遍历所有的键，一般不在生产环境使用，在以下情况可以使用：</p><p>① 在一个不对外提供服务的 Redis 从节点上执行，不会阻塞客户端的请求，但会影响主从复制。</p><p>② 如果确定键值总数比较少可以执行。</p><hr><p><strong>渐进式遍历</strong></p><p>Redis 从 2.8 版本后提供了一个新的命令 scan，能有效解决 keys 存在的问题。和 keys 遍历所有键不同，scan 采用渐进式遍历的方式解决阻塞问题，每次 scan 的时间复杂度为 O(1)，但是要真正实现 keys 的功能可能需要执行多次 scan。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan cursor [match pattern] [count number]</span><br></pre></td></tr></table></figure><p>cursor 是必须参数，代表一个游标，第一次遍历从 0 开始，每次 scan 完会返回当前游标的值，直到值为 0 表示遍历结束。</p><p>match pattern 是可选参数，作用是模式匹配。</p><p>count number 是可选参数，作用是表明每次要遍历的键个数，默认值为 10。</p><p>除了 scan 外，Redis 提供了面向哈希、集合、有序集合的扫描遍历命令，解决了 hgetall、smembers、zrange 可能产生的阻塞问题，对应命令分别为 hscan、sscan、zscan。</p><p>渐进式遍历可以有效解决 keys 命令可能产生的阻塞问题，但是如果在 scan 过程中有键的变化，那么遍历效果可能会遇到问题：新增的键没有被遍历到，遍历了重复的键等情况。</p><hr><h4 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h4><p><strong>切换数据库</strong></p><p><code>select dbIndex</code></p><p>Redis 中默认配置有 16 个数据库，例如 select 0 将切换到第一个数据库，数据库之间的数据是隔离的。</p><p><strong>flushdb/flushall</strong></p><p>用于清除数据库，flushdb 只清除当前数据库，flushall 会清除所有数据库。如果当前数据库键值数量比较多，flushdb/flushall 存在阻塞 Redis 的可能性。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redis 提供 5 种数据结构，每种数据结构都有多种内部编码实现。</p><p>纯内存存储、IO 多路复用计数、单线程架构是造就 Redis 高性能的三个因素。</p><p>由于 Redis 的单线程结构，所以需要每个命令能被快速执行完，否则会存在阻塞的可能。</p><p>批量操作（例如 mget、mset、hmset 等）能够有效提高命令执行的效率，但要注意每次批量操作的个数和字节数。</p><p>persist 命令可以删除任意类型键的过期时间，但 set 也会删除字符串类型键的过期时间。</p><p>move、dump + restore、migrate 是 Redis 发展过程中三种迁移键的方式，其中 move 命令基本废弃，migrate 命令用原子性的方式实现了 dump + restore，并且支持批量操作，是 Redis Cluster 实现水平扩容的重要工具。</p><p>scan 命令可以解决 keys 命令可能带来的阻塞问题，同时 Redis 还提供了 hscan、sscan、zscan 渐进式遍历 hash、set、zset。</p><hr><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的<br>Redis会将一个事务中的所有命令序列化，然后按顺序执行。<br>1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。<br>2.如果在一个事务中的<strong>命令</strong>出现错误，那么<strong>所有的命令</strong>都不会执行；<br>3.如果在一个事务中出现<strong>运行错误</strong>，那么<strong>正确的命令</strong>会被执行。<br>注：redis的discard只是结束本次事务,正确命令造成的影响仍然存在.</p><p>1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。<br>2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。<br>3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。<br>4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</p><hr><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>Bitmaps 本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。</p><p>Bitmaps 单独提供了一套命令，所以在 Redis 使用 Bitmaps 和使用字符串的方法不太相同，可以把 Bitmaps 看作一个以位为单位的数组，数组的每个单元只能存储 0 和 1，数组的下标叫做偏移量。</p><h4 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h4><p>例：将每个独立用户是否访问过网站存放在 Bitmaps 中，将访问过的用户记作 1，没有访问过的记作 0，偏移量作为用户的 id。</p><p><strong>设置值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure><p>设置键的第 offset 个位的值，假设有 20 个用户，id 为 0、5、11、15、19 的用户对网站进行了访问，那么初始化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setbit unique:users:2020-06-20 0 1</span><br><span class="line">setbit unique:users:2020-06-20 5 1</span><br><span class="line">setbit unique:users:2020-06-20 11 1</span><br><span class="line">setbit unique:users:2020-06-20 15 1</span><br><span class="line">setbit unique:users:2020-06-20 19 1</span><br></pre></td></tr></table></figure><p>很多应用的用户 id 直接以一个指定数字开头，例如 10000，直接将用户 id 与 Bitmaps 的偏移量对应势必会造成一定浪费，通常做法是每次做 setbit 操作时将用户 id 减去这个指定数字。在第一次初始化 Bitmaps 时，如果偏移量非常大，那么整个初始化过程会执行比较慢，可能造成阻塞。</p><p><strong>获取值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure><p>获取键的第 offset 个位的值，例如获取 id 为 8 的用户是否在 2020-06-20 这天访问过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit unique:users:2020-06-20 8</span><br></pre></td></tr></table></figure><p><strong>获取指定范围值为 1 的个数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure><p>例如获取 2020-06-20 这天访问过的用户数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount unique:users:2020-06-20</span><br></pre></td></tr></table></figure><p>start 和 end 代表起始和结束字节数。</p><p><strong>Bitmaps 间的运算</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop op destkey key [key...]</span><br></pre></td></tr></table></figure><p>bitop 是一个复合操作，它可以做交集、并集、非、异或并将结果保存到 destkey 中。</p><p>例如计算 2020-06-20 和 2020-06-21 都访问过网站的用户数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitop and unique:users:and:2020-06-20_21 unique:users:2020-06-20 unique:users:2020-06-21</span><br><span class="line">bitcount unique:users:and:2020-06-20_21</span><br></pre></td></tr></table></figure><p>例如计算 2020-06-20 和 2020-06-21 任意一天访问过网站的用户数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitop or unique:users:or:2020-06-20_21 unique:users:2020-06-20 unique:users:2020-06-21</span><br><span class="line">bitcount unique:users:or:2020-06-20_21</span><br></pre></td></tr></table></figure><p><strong>计算第一个值为 tartgetBit 的偏移量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitops key targetBit [start] [end]</span><br></pre></td></tr></table></figure><p>例如计算 2020-06-20 当前访问网站的最小用户 id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitops unique:users:2019-06-20 1</span><br></pre></td></tr></table></figure><p>假设网站的活跃用户量很大，使用 Bitmaps 相比 set 可以节省很多内存，但如果活跃用户很少就会浪费内存。</p><hr><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>HyperLogLog 不是一种新的数据结构，实际也是字符串类型，是一种基数算法。提供 HyperLogLog 可以利用极小的内存空间完成独立总数的统计，数据集可以是 IP、Email、ID 等。</p><p><strong>添加</strong></p><p><code>pfadd key element [element...]</code>，如果添加成功会返回 1</p><p><strong>计算独立用户数</strong></p><p><code>pfcount key [key...]</code></p><p><strong>合并</strong></p><p><code>pfmerge destkey sourcekey [sourcekey...]</code></p><p>HyperLogLog 内存占用量非常小，但是存在错误率，开发者在进行数据结构选型时只需要确认如下两条：</p><ul><li>只为了计算独立总数，不需要获取单条数据。</li><li>可以容忍一定误差率，毕竟 HyperLogLog 在内存占用量上有很大优势。</li></ul><hr><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>Redis 提供了基于发布/订阅模式的消息机制，此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel）发送消息，订阅该频道的每个客户端都可以收到该消息。</p><h4 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h4><p><strong>发布消息</strong></p><p><code>publish channel message</code>，返回结果为订阅者的个数。</p><p><strong>订阅消息</strong></p><p><code>subscribe channel [channel..]</code>，订阅者可以订阅一个或多个频道。</p><p>客户端在执行订阅命令后会进入订阅状态，只能接收 subscribe、psubscribe、unsubscribe、punsubscribe 的四个命令。新开启的订阅客户端，无法收到该频道之前的消息，因为 Redis 不会对法捕的消息进行持久化。</p><p>和很多专业的消息队列系统如 Kafka、RocketMQ 相比，Redis 的发布订阅略显粗糙，例如无法实现消息堆积和回溯，但胜在足够简单，如果当前场景可以容忍这些缺点，也是一个不错的选择。</p><p><strong>取消订阅</strong></p><p><code>unsubscribe [channel [channel...]]</code></p><p>客户端可以通过 unsubscribe 命令取消对指定频道的订阅，取消成功后不会再收到该频道的发布消息。</p><p><strong>按照模式订阅和取消订阅</strong></p><p><code>psubscribe pattern [pattern...]</code></p><p><code>punsubscribe pattern [pattern...]</code></p><p>这两种命令支持 glob 风格，例如订阅所有以 it 开头的频道：<code>psubscribe it*</code></p><p><strong>查询订阅</strong></p><p>查看活跃的频道：<code>pubsub channels [pattern]</code>，活跃频道是指当前频道至少有一个订阅者。</p><p>查看频道订阅数：<code>pubsub numsub [channel ...]</code></p><p>查看模式订阅数：<code>pubsub numpat</code></p><hr><h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><p>聊天室、公告牌、服务之间利用消息解耦都可以使用发布订阅模式，以服务器解耦为例：视频管理系统负责管理视频信息，用户通过各种客户端获取视频信息。</p><p>假如视频管理员在视频管理系统中对视频信息进行了更新，希望及时通知给视频服务端，就可以采用发布订阅模式，发布视频信息变化的消息到指定频道，视频服务订阅这个频道及时更新视频信息，通过这种方式实现解耦。</p><p>视频服务订阅 video:changes 频道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe video:changes</span><br></pre></td></tr></table></figure><p>视频管理系统发布消息到 video:changes 频道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish video:changes &quot;video1,video3,video5&quot;</span><br></pre></td></tr></table></figure><p>视频服务收到消息，对视频信息进行更新..</p><hr><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>Redis 3.2 版本提供了 GEO 地理信息定位功能，支持存储地理位置信息用来实现诸如附近位置、摇一摇这一类依赖于地理位置信息的功能。</p><p><strong>增加地理位置信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member...]</span><br></pre></td></tr></table></figure><p>longitude、latitude、member 分别是该地理位置的经度、纬度、成员。</p><p>例如添加北京的地理位置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd cities:locations 116.28 39.55 beijing</span><br></pre></td></tr></table></figure><p>返回结果表示成功添加的个数，如果需要更新地理位置信息仍然可以使用 geoadd 命令，返回结果为 0。</p><p><strong>获取地理位置信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getpos key member [member...]</span><br></pre></td></tr></table></figure><p><strong>获取两个地理位置的距离</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure><p>其中 unit 代表返回结果的单位，包含 m 米、km 公里、mi 英里、ft 英尺。</p><p><strong>删除地理位置信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member</span><br></pre></td></tr></table></figure><p>GEO 没有提供删除成员的命令，但由于它底层是 zset，可以使用 zrem 删除。</p><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>慢查询中有两个重要参数 slowlog-log-slower-than 和 slowlog-max-len。</p><p>慢查询不包括命令网络传输和排队时间。</p><p>有必要将慢查询定期存放。</p><p>Pipeline 可以有效减少 RTT 次数，但每次 Pipeline 的命令数量不能无节制。</p><p>Redis 可以使用 Lua 脚本创造出原子、高效、自定义命令组合。</p><p>Bitmaps 可以用来做独立用户统计，有效节省内存。</p><p>Bitmaps 中 setbit 一个大的偏移量，由于申请大量内存会导致阻塞。</p><p>HyperLogLog 虽然在统计独立总量时存在一定误差，但是节省的内存量十分惊人。</p><p>Redis 的发布订阅相比许多专业消息队列系统功能较弱，不具备息堆积和回溯能力，但胜在足够简单。</p><p>Redis 3.2 提供了 GEO 功能，用来实现基于地理位置信息的应用，底层实现是 zset。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p><p>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p><p><img src="https://img-blog.csdnimg.cn/20191213103148681.png" alt="img"></p><p>使用SETNX完成同步锁的流程及事项如下：</p><p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</p><p>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p><p>释放锁，使用DEL命令将锁数据删除</p><h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>​    <strong>描述：</strong></p><p>​    缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p><p>   <strong>解决方案：</strong></p><ol><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ol><li><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol></li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p><strong>解决方案</strong></p><ol><li>设置热点数据永远不过期。</li><li>加互斥锁，互斥锁</li></ol><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>2）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="image"></p><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p><p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md" target="_blank" rel="noopener">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">**缓存穿透**是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</span><br><span class="line"></span><br><span class="line">**解决方案**</span><br><span class="line"></span><br><span class="line">1. 接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</span><br><span class="line">2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</span><br><span class="line">3. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</span><br><span class="line"></span><br><span class="line">**附加**</span><br><span class="line"></span><br><span class="line">对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</span><br><span class="line">Bitmap： 典型的就是哈希表</span><br><span class="line">缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</span><br><span class="line"></span><br><span class="line">布隆过滤器（推荐）</span><br><span class="line"></span><br><span class="line">就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</span><br><span class="line">它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</span><br><span class="line">Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</span><br><span class="line">Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。</span><br><span class="line">Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</span><br></pre></td></tr></table></figure><p>is 对象的个数，在极端情况下可能会造成连接泄露，而连接池的形式可以有效的保护和控制资源的使用。</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>直连</td><td>简单方便，适用于少量长期连接的场景。</td><td>存在每次连接关闭 TCP 连接的开销，资源无法控制可能出现连接泄露，Jedis 对象线程不安全</td></tr><tr><td>连接池</td><td>无需每次连接都生成 Jedis 对象降低开销，使用连接池的形式保护和控制资源的使用</td><td>相对于直连比较麻烦，尤其在资源的管理上需要很多参数来保证，一旦规划不合理也会出现问题</td></tr></tbody></table><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p><strong>快照（snapshotting）持久化（RDB）</strong></p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。默认的文件名为dump.rdb。</p><p><strong>1、save触发方式</strong></p><p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：</p><p><img src="https://pics1.baidu.com/feed/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg?token=7ed4cf784a82d04e60b8dc72cf7e3c24&s=EDBAA5565D1859C85444707E02005071" alt="img"></p><p>执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p><p><strong>2、bgsave触发方式</strong></p><p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p><p><img src="https://pics5.baidu.com/feed/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg?token=a72f072d65d2de548d71bb459cd0bf4f&s=05AAFE168FF04C8A10FD2DEE0300E032" alt="img"></p><p>具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</p><p><strong>3、自动触发</strong></p><p>自动触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：</p><p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><img src="https://pics5.baidu.com/feed/1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg?token=22f387ba78130c6115420059481b2393&s=EF48A15796784D8816E1D9EB03007024" alt="img"></p><p><strong>AOF（append-only file）持久化</strong></p><p>与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p><strong>RDB 的优势和劣势</strong></p><p>①、优势</p><p>（1）RDB，全量备份，非常适合用于进行备份和灾难恢复。</p><p>（2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p><p>（3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p><p>②、劣势</p><p>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p><p><strong>AOF 的优势和劣势</strong></p><p>(1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。</p><p>（2）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p><p><strong>5、缺点</strong></p><p>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p><p>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p><p><strong>相关 issue</strong> ：<a href="https://github.com/Snailclimb/JavaGuide/issues/783" target="_blank" rel="noopener">783：Redis 的 AOF 方式</a></p><hr><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(transaction)功能。</p><blockquote><p>MULTI<br>OK<br>INCR foo<br>QUEUED<br>INCR bar<br>QUEUED<br>EXEC</p></blockquote><p>1) (integer) 1<br>2) (integer) 1<br>Copy to clipboardErrorCopied<br>使用 MULTI命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了EXEC命令将执行所有命令。</p><p>Redis官网相关介绍 <a href="https://redis.io/topics/transactions" target="_blank" rel="noopener">https://redis.io/topics/transactions</a> 如下：</p><p>redis事务</p><p>但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： 1. 原子性，2. 隔离性，3. 持久性，4. 一致性。</p><p>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；<br>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；<br>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。<br>一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；<br>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</p><p>Redis官网也解释了自己为啥不支持回滚。简单来说就是Redis开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p><p>redis roll back</p><p>你可以将Redis中的事务就理解为 ：Redis事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</p><h3 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h3><p>文件事件处理器包括分别是<strong>套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器</strong>。使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。<br>I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br><strong>工作原理：</strong><br>1)I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br>尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字.<br><img src="https://img-blog.csdnimg.cn/20190429094050254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0J1dHRlcmZseV9yZXN0aW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>redis 提供 6种数据淘汰策略：</p><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从<strong>已设置过期时间</strong>的数据集（server.db[i].expires）中随机移除key</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-eviction：当内存不足以容纳新写入数据时，新写入操作会报错，无法写入新数据，一般不采用</li></ul><h3 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h3><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p><table><thead><tr><th>对比参数</th><th>Redis</th><th align="center">Memcached</th></tr></thead><tbody><tr><td>类型</td><td>1. 支持内存 2. 非关系型数据库</td><td align="center">1. 支持内存 2. 键值对形式 3. 缓存形式</td></tr><tr><td><strong>数据存储类型</strong></td><td>1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】</td><td align="center">只支持简单的key-value</td></tr><tr><td><strong>持久化支持</strong></td><td>1. RDB 2. AOF</td><td align="center">不支持</td></tr><tr><td><strong>集群模式</strong></td><td>原生支持 cluster 模式，可以实现主从复制，读写分离</td><td align="center">没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td></tr><tr><td>内存管理机制</td><td>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td><td align="center">Memcached 的数据则会一直在内存中，Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</td></tr></tbody></table><ul><li>存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。</li><li>数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。</li><li>用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>value的大小：<strong><em>\</em>redis可以达到1GB，而memcache只有1MB**</strong>。</li></ul><h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p><p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p><ol><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li></ol><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。<br>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="高并发情况下，对于Redis的更新操作有哪些注意事项？"><a href="#高并发情况下，对于Redis的更新操作有哪些注意事项？" class="headerlink" title="高并发情况下，对于Redis的更新操作有哪些注意事项？"></a>高并发情况下，对于Redis的更新操作有哪些注意事项？</h3><p>操作：先更新数据库，再删除缓存<br>正常的情况是这样的：  </p><ul><li>1、 先操作数据库，成功</li><li>2、再删除缓存，也成功</li><li>3、 如果原子性被破坏了：第一步成功(操作数据库)，第二步失败(删除缓存)，会导致数据库里是新数据，而缓存里是旧数据。</li></ul><p>如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。<br>如果在高并发的场景下，出现数据库与缓存数据不一致的概率特别低，也不是没有：缓存刚好失效//线程A查询数据库，得一个旧值//线程B将新值写入数据库//线程B删除缓存//线程A将查到的旧值写入缓存<br>要达成上述情况，还是说一句概率特别低,因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。对于这种策略，其实是一种设计模式：Cache Aside Pattern<br><strong>解决删除缓存失败的解决思路</strong>：将需要删除的key发送到消息队列中—自己消费消息，获得需要删除的key—不断重试删除操作，直到成功</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>Redis每次按key获取一个值的时候，都会更新value中的<strong>lru字段</strong>为当前秒级别的时间戳。</p><p>Redis初始的实现算法很简单，随机从dict中取出五个key,淘汰一个lru字段值最小的。</p><p>在3.0的时候，又改进了一版算法：</p><ul><li>首先第一次随机选取的key都会放入一个pool中(pool的大小为16)，pool中的key是按lru大小顺序排列的。</li><li>接下来每次随机选取的key <strong>lru值必须小于pool中最小的lru</strong>才会继续放入，直到将pool放满。</li><li>放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。</li><li><strong><em>\</em>淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰**</strong>。</li></ul><h3 id="Redis的IO复用"><a href="#Redis的IO复用" class="headerlink" title="Redis的IO复用"></a>Redis的IO复用</h3><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p><p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件： 1. 文件事件; 2. 时间事件。</p><p>时间事件不需要多花时间了解，我们接触最多的还是 <strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p><p>《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。</p><blockquote><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。</p><p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote><p>可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p><img src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png" alt="img"></p><h4 id="master结点挂了"><a href="#master结点挂了" class="headerlink" title="master结点挂了"></a>master结点挂了</h4><p>raft选举出新的leader</p><h3 id="节点间通信机制"><a href="#节点间通信机制" class="headerlink" title="节点间通信机制"></a>节点间通信机制</h3><p>支撑N个redis master node，每个master node都可以挂载多个slave node</p><p>读写分离的架构，对于每个master来说，写就写到master，然后读就从mater对应的slave去读</p><p>高可用，因为每个master都有salve节点，那么如果mater挂掉，redis cluster这套机制，就会自动将某个slave切换成master</p><h3 id="hash-slot"><a href="#hash-slot" class="headerlink" title="hash slot"></a>hash slot</h3><p>redis cluster有固定的16384个hash slot，对每个key计算CRC16值，然后对16384取模，可以获取key对应的hash slot</p><p>redis cluster中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot</p><h3 id="gossip？"><a href="#gossip？" class="headerlink" title="gossip？"></a>gossip？</h3><p>gossip协议包含多种消息，包括ping，pong，meet，fail，等等</p><p>Redis 集群是去中心化的，彼此之间状态同步靠 gossip 协议通信，集群的消息有以下几种类型：</p><ul><li><strong>Meet</strong> 通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群。</li><li><strong>Ping</strong> 节点每秒会向集群中其他节点发送 ping 消息，消息中带有自己已知的两个节点的地址、槽、状态信息、最后一次通信时间等。</li><li><strong>Pong</strong> 节点收到 ping 消息后会回复 pong 消息，消息中同样带有自己已知的两个节点信息。</li><li><strong>Fail</strong> 节点 ping 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。</li></ul><p><img src="https://pic3.zhimg.com/80/v2-0e5e3f73c7cc427a688c6d45cf1f445a_hd.jpg" alt="img"></p><h4 id="redis键的删除策略"><a href="#redis键的删除策略" class="headerlink" title="redis键的删除策略"></a>redis键的删除策略</h4><p>问题：如果一个键过期了，那么它什么时候会被删除呢？有三个答案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在过期时间来临时，立即执行对键的删除操作 .。</span><br></pre></td></tr></table></figure><p>这种过期策略对内存友好，但对CPU是非常不友好的。因为还要主动设定定时器并主动删除，即通过CPU换内存（CPU主动删除了内存中的数据嘛，CPU忙，内存空闲）。可以想象一下在大数据大并发的时候，这种机制是多么灾难</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">惰性删除(Lazy Expiration)：redis内部不会监视记录是否过期，但是每次从键空间获取键时，检查记录是否过期。这种技术被称为lazy（惰性）expiration。</span><br></pre></td></tr></table></figure><p>与定时删除相反，此删除机制对内存是不友好的对CPU是友好的，惰性删除不会主动去删除已到期(expire)的键，而是等有需要调用的时候再判断，即内存换CPU（内存中有大量残留数据）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定期删除：每隔一段时间，对redis数据库进行一次检查，删除里面的过期键</span><br></pre></td></tr></table></figure><p>属于前两种方法的折中.但要注意操作检查执行的时间和频率，如果删除操作做的太频繁，或者检查执行的时间太长，定期策略就会退化成定时策略。</p><p>Redis服务器实际使用的是惰性删除和定期删除策略两种策略，配合使用两种策略和在使用CPU和内存找到平衡点。</p><h4 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h4><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p>有几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.先更新redis再更新db</span><br><span class="line">2.先更新db再更新redis</span><br><span class="line">3.先更新DB再删除redis</span><br><span class="line">4.先删除redis再更新DB</span><br><span class="line">5.延迟双删</span><br><span class="line">6.延迟删除等变种</span><br></pre></td></tr></table></figure><h4 id="1-先更新redis再更新db"><a href="#1-先更新redis再更新db" class="headerlink" title="1.先更新redis再更新db"></a>1.先更新redis再更新db</h4><p>按下面步骤会有问题,AB是两个线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A_update_redis</span><br><span class="line">B_update_redis</span><br><span class="line">B_update_db</span><br><span class="line">A_update_db</span><br></pre></td></tr></table></figure><p>最终db是a值但是redis是b值，不一致</p><h4 id="2-先更新db再更新redis"><a href="#2-先更新db再更新redis" class="headerlink" title="2.先更新db再更新redis"></a>2.先更新db再更新redis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A_update_db</span><br><span class="line">B_update_db</span><br><span class="line">B_update_redis</span><br><span class="line">A_update_redis</span><br></pre></td></tr></table></figure><p>最终db是b值但是redis是a值</p><h4 id="3-先更新DB再删除redis"><a href="#3-先更新DB再删除redis" class="headerlink" title="3.先更新DB再删除redis"></a>3.先更新DB再删除redis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A_update_db</span><br><span class="line">B_update_db</span><br><span class="line">B_rm_redis</span><br><span class="line">A_rm_redis</span><br></pre></td></tr></table></figure><p>是不是不明白。想不出来怎么不一致了？<br> 不是这样的，没这么简单，第二次rm_redis就会保证后面的redis和db是一致的<br> 实际是下面这种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A_get_data</span><br><span class="line">redis_cache_miss</span><br><span class="line">A_get_db</span><br><span class="line">B_update_db</span><br><span class="line">B_rm_redis</span><br><span class="line">(此时如果拿db是b值，但是redis没有值)</span><br><span class="line">A_update_redis</span><br></pre></td></tr></table></figure><p>依赖于A_update_redis在B_update_db之后，极端情况<br> 此时redis是old，db是new</p><h4 id="4-先删除redis再更新DB"><a href="#4-先删除redis再更新DB" class="headerlink" title="4.先删除redis再更新DB"></a>4.先删除redis再更新DB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A_rm_redis</span><br><span class="line">B_get_data</span><br><span class="line">B_redis_miss</span><br><span class="line">B_get_db</span><br><span class="line">B_update_redis</span><br><span class="line">A_update_db</span><br></pre></td></tr></table></figure><p>此时redis是old值，db是new值</p><h4 id="5-延迟双删"><a href="#5-延迟双删" class="headerlink" title="5.延迟双删"></a>5.延迟双删</h4><p>即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm_redis</span><br><span class="line">update_db</span><br><span class="line">sleep xxx ms</span><br><span class="line">rm_redis</span><br></pre></td></tr></table></figure><p>这样叫做双删，最后一次sleep一段时间再rm_redis保证再次读请求回溯打到db，用最新值写redis</p><p>作者：赤子心_d709<br>链接：<a href="https://www.jianshu.com/p/125bba448cdd" target="_blank" rel="noopener">https://www.jianshu.com/p/125bba448cdd</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>I/O 多路复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跳跃表</title>
      <link href="/2020/07/05/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
      <url>/2020/07/05/%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>[TOC]</p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。上层结点都有指向下层结点的指针，从上往下每一层链表节点数递减。比如第一层有两个，第二层有四个，以此类推。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/27/16f4745348536f87?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="跳跃表-三级索引-寻找42"></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>看懂了跳跃表的数据结构，那么就很容易理解节点的插入操作了，基本上两步操作就可以实现：在最底层的数据链表中插入数据，然后调整索引；</p><p>其中每一层的索引链表中是否需要增加新增的节点，其实并没有什么标准答案，我们尽量做到索引的平均分布即可，常用的就是【随机判断】决定是否需要新增或调整索引，当有新节点插入的时候，通过概率算法判断这个节点需要插入到几级节点中。</p><p>比如：</p><ul><li>底层数据链表有 N 个元素，随机选择 N/2 个元素作为 1 级索引，随机选择 N/4 个元素作为 2 级索引…一直到顶层索引；</li><li>新插入数据节点，1/2 概率不插入任何一级索引，1/4 概率返回需要插入 1 级索引，1/8 概率返回需要插入到 2 级索引，以此类推；</li><li>这里要注意一点，插入 2 级索引的时候，同时也需要插入 1 级索引；也就是插入 n 级索引的时候，同时也要插入 1~( n-1 ) 级索引。</li></ul><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>通过一个bit数组来存储特定数据的一种数据结构,每一个bit位都能独立包含信息,bit是数据的最小存储单元,因此能大量节省空间</p><p>按下标从数组的高位(左)向低位(右)取值,bit数组起始值全为0,从左到右取下标(下标从0开始),数组的每个元素值就是一个下标值.将元素对应的下标在bit位上的值改为1</p><p>举例:数组[2,5,3,8] 起始000000000 元素2对应下标2,<br>将左到右的下标2的值改为1 –&gt; 001000000————————————————</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql相关</title>
      <link href="/2020/07/05/sql%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/07/05/sql%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="左连接和内联的区别"><a href="#左连接和内联的区别" class="headerlink" title="左连接和内联的区别"></a>左连接和内联的区别</h2><p><strong>左连接：左边有的，右边没有的为null</strong></p><p><strong>右连接：左边没有的，右边有的为null</strong></p><p><strong>内连接：显示左边右边共有的</strong></p><p><img src="https://img-blog.csdnimg.cn/20200705154749515.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200705154850251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>左连接</p><p><img src="https://img-blog.csdnimg.cn/20200705155226877.png" alt="在这里插入图片描述"></p><p>内连接</p><p><img src="https://img-blog.csdnimg.cn/20200705155007995.png" alt="在这里插入图片描述"></p><p>右连接</p><p><img src="https://img-blog.csdnimg.cn/20200705154938172.png" alt="在这里插入图片描述"></p><h2 id="like和in关键字"><a href="#like和in关键字" class="headerlink" title="like和in关键字"></a>like和in关键字</h2><p>LIKE：</p><p>当无法确切知道所要查找的值，而是知道所要查找的数据符合的模式时，可以使用LIKE 子句进行匹配。一般来说，LIKE 子句仅在字符串类型时使用，但对数字类型数据是不能使用 LIKE 子句的。</p><p>不在 LIKE子句中使用时， 就不具有特殊的含义，仅表示其本身的值。</p><p>IN：</p><p>当确切知道所要查找的内容，且为多个值时，可以使用 IN 子句来进行数据比较</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一条SQL查询语句的执行过程</title>
      <link href="/2020/07/05/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/07/05/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>输入下面一条SQL语句，我们来分析下这条语句在MySQL内部的执行过程。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190109110912557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bjd2wxMjA2,size_16,color_FFFFFF,t_70" alt="img"></p><p>体来说，MySQL 可以分为 Server 层和存储引擎两部分。</p><p>Server 层包括：连接器、查询缓存、分析器、优化器、执行器等，涵盖了 MySQL 的大多数核心服务功能，以及所有的内置函数（如：日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如：存储过程、触发器、视图等等。</p><p>存储引擎层负责：数据的存储和提取。其架构是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。从MySQL5.5.5版本开始默认的是InnoDB，但是在建表时可以通过 engine = MyISAM 来指定存储引擎。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p><p>从图中可以看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。</p><h2 id="1、连接器"><a href="#1、连接器" class="headerlink" title="1、连接器"></a>1、连接器</h2><p> 第一步，要首先连接上数据库，这个时候使用的就是连接器。</p><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功创建以后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://img-blog.csdnimg.cn/20190109112901965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bjd2wxMjA2,size_16,color_FFFFFF,t_70" alt="img"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p><p><strong>数据库中的长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接指的是每次执行完很少的几次查询就断开连接，下次查询时再重新建立一个。</strong></p><p>但是如果连接都使用长连接的话，你可能会发现，有时候 MySQL 占用内存涨的特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才会释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象上看就是 MySQL 异常重启了。</p><p>那么怎么解决这个问题呢？下面提供两种解决方案：</p><blockquote><p>1、<strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，释放资源，之后要查询的时候再重连。 </p><p>2、如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过<strong>执行 mysql_reset_connection 来重新初始化连接资源</strong>。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p></blockquote><h2 id="2、查询缓存"><a href="#2、查询缓存" class="headerlink" title="2、查询缓存"></a>2、查询缓存</h2><p>连接建立完成后，就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p><p><strong>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果都会以key-value 对的形式，被直接缓存到内存中。其中，\</strong>key 是查询的语句，value 是查询的结果*<em>。如果你的查询能够直接在缓存中找到 key，那么这个 value 就会直接返回给客户端。*</em></p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><ul><li><p><strong>但是大多数情况下不建议使用查询缓存 —&gt; 因为查询缓存往往弊大于利</strong></p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你刚费劲存的结果还没来得及使用就被一个更新给清空了。</p></li></ul><p>对于更新压力大的数据库而言，查询缓存的命中率就会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>默认的 SQL 语句是不缓存的，可以显示的指定查询缓存：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10;</span><br></pre></td></tr></table></figure><p>需要说明的是：MySQL 8.0版本已经将查询缓存功能删除了。</p><h2 id="3、分析器"><a href="#3、分析器" class="headerlink" title="3、分析器"></a>3、分析器</h2><p>如果没有命中查询缓存，就要开始正真执行语句了。首先，MySQL 需要知道你要做什么，因此要对 SQL 语句做解析。</p><p>分析器先会做“词法分析”。MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>做完了这些识别以后，就要做“语法分析”。语法分析根据语法规则，判断输入的这个 SQL语句是否满足 MySQL 的语法规范。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID=1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; <span class="keyword">check</span> the <span class="keyword">manual</span> that corresponds <span class="keyword">to</span> your MySQL <span class="keyword">server</span> <span class="keyword">version</span> <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> <span class="keyword">use</span> near <span class="string">'elect * from t where ID=1'</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><h2 id="4、优化器"><a href="#4、优化器" class="headerlink" title="4、优化器"></a>4、优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始之前还要经过优化器的处理。</p><p>优化器是在表里有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而<strong>优化器的作用就是决定选择使用哪一个方案</strong>。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h2 id="5、执行器"><a href="#5、执行器" class="headerlink" title="5、执行器"></a>5、执行器</h2><p> MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。</p><p>如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): <span class="keyword">SELECT</span> command denied <span class="keyword">to</span> <span class="keyword">user</span> <span class="string">'b'</span>@<span class="string">'localhost'</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">'T'</span></span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行流程是这样的：</p><p>1、调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</p><p>2、调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行；</p><p>3、执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p><strong>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>隔离级别serilizable</title>
      <link href="/2020/07/05/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABserilizable/"/>
      <url>/2020/07/05/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABserilizable/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="如何实现的"><a href="#如何实现的" class="headerlink" title="如何实现的"></a>如何实现的</h2><p>在SERIALIZABLE级别下，不会使用mysql的mvcc机制，而是在每一个select请求下获得读锁，在每一个update操作下尝试获得写锁。</p><p>对于insert、update、delete，InnoDB会自动给涉及的数据加写锁；对于一般的Select语句，InnoDB不会加任何锁</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2020/07/04/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2020/07/04/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-使用互斥锁-mutex-key"><a href="#1-使用互斥锁-mutex-key" class="headerlink" title="1.使用互斥锁(mutex key)"></a>1.使用互斥锁(mutex key)</h3><p>业界比较常用的做法，是使用mutex。简单地来说。</p><p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">String value = redis.get(key);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//代表缓存值过期</span></span><br><span class="line"><span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line"><span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//代表设置成功</span></span><br><span class="line">value = db.get(key);</span><br><span class="line">redis.set(key, value, expire_secs);</span><br><span class="line">redis.del(key_mutex);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">sleep(<span class="number">50</span>);</span><br><span class="line">get(key);</span><br><span class="line"><span class="comment">//重试</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-zookeeper"><a href="#2-zookeeper" class="headerlink" title="2.zookeeper"></a>2.zookeeper</h3><p>创建一个锁目录 /lock；<br>当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；<br>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是<br>则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；<br>执行业务代码，完成后，删除对应的子节点。</p><h3 id="3-Redis-的-RedLock-算法"><a href="#3-Redis-的-RedLock-算法" class="headerlink" title="3.Redis 的 RedLock 算法"></a>3.Redis 的 RedLock 算法</h3><p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。<br>尝试从 N 个互相独立 Redis 实例获取锁；<br>计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，那<br>么就认为锁获取成功了；<br>如果锁获取失败，就到每个实例上释放锁。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>①redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能</p><p>②zk分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小</p><p>③另外一点就是，如果是redis获取锁的那个客户端bug了或者挂了，那么只能等待超时时间之后才能释放锁；而zk的话，因为创建的是临时znode，只要客户端挂了，znode就没了，此时就自动释放锁</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZGC和Shenandoah</title>
      <link href="/2020/07/04/ZGC%E5%92%8CShenandoah/"/>
      <url>/2020/07/04/ZGC%E5%92%8CShenandoah/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h2><p>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际是非常少的。那么其他阶段是怎么做到可以并发执行的呢？</p><p>ZGC主要新增了两项技术，一个是<strong>着色指针Colored Pointer</strong>，另一个是<strong>读屏障Load Barrier</strong>。</p><p><strong>着色指针Colored Pointer</strong><br> ZGC利用指针的64位中的几位表示Finalizable、Remapped、Marked1、Marked0（ZGC仅支持64位平台），以标记该指向内存的存储状态。相当于在对象的指针上标注了对象的信息。注意，这里的指针相当于Java术语当中的引用。</p><p>在这个被指向的内存发生变化的时候（内存在Compact被移动时），颜色就会发生变化。</p><p>在G1的时候就说到过，Compact阶段是需要STW，否则会影响用户线程执行。那么怎么解决这个问题呢？</p><p><strong>读屏障Load Barrier</strong> 由于着色指针的存在，在程序运行时访问对象的时候，可以轻易知道对象在内存的存储状态（通过指针访问对象），若请求读的内存在被着色了。那么则会触发读屏障。读屏障会更新指针再返回结果，此过程有一定的耗费，从而达到与用户线程并发的效果。</p><p>把这两项技术联合下理解，引用R大（RednaxelaFX）的话</p><blockquote><p>与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。</p></blockquote><p>链接：<a href="https://juejin.im/post/5bade237e51d450ea401fd71" target="_blank" rel="noopener">https://juejin.im/post/5bade237e51d450ea401fd71</a></p><h2 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h2><p>相比 G1 内存布局同样基于 Region，默认回收策略也是优先处理回收价值最大的 Region。但在管理堆内存方面，与 G1 有不同：① 支持并发整理，G1 的回收阶段不能与用户线程并发。②默认不使用分代收集，不会有专门的新生代 Region 或老年代 Region。③ 摒弃了在 G1 中耗费大量内存和计算资源去维护的记忆集，改用名为连接矩阵的全局数据结构来记录跨 Region 的引用关系。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/2020/07/04/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2020/07/04/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong><em>对于socket流而言,数据的流向经历两个阶段：\</em></strong></p><ul><li>第一步通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li><li>第二步把数据从内核缓冲区复制到应用进程缓冲区。</li></ul><p>recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中</p><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p><blockquote><p>blocking IO的特点就是在IO执行的两个阶段都被block了。</p></blockquote><h2 id="非阻塞式-I-O"><a href="#非阻塞式-I-O" class="headerlink" title="非阻塞式 I/O"></a>非阻塞式 I/O</h2><p>应用进程可以继续执行，但是需要不断的执行系统调用来获知I/O 是否完成，这种方式称为轮询（polling）。</p><blockquote><p><strong>此时的非阻塞IO只是应用到等待数据上,当真正有数据到达执行recvfrom的时候,还是同步阻塞IO来的</strong></p></blockquote><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>同步异步指的是被调用者结果返回时通知线程的一种机制，阻塞非阻塞指的是调用结果返回前 线程的状态，是挂起还是继续处理其他任务。</p><h2 id="I-O-复用"><a href="#I-O-复用" class="headerlink" title="I/O 复用"></a>I/O 复用</h2><p>主要有 三种机制，分别是select  poll epoll  ，让它们等待数据，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p><p>好处:<br>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，<br>那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开<br>销更小。<br><img src="https://img-blog.csdnimg.cn/20200715094639319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="img"></p><p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval</span><br><span class="line">*timeout);</span><br></pre></td></tr></table></figure><p>有三种类型的描述符类型：readfds、writefds、exceptdfs，分别对应读、写、异常条件的描述符集合。fd_set 使用<br>数组实现，数组大小使用 FD_SETSIZE 定义。</p><p><strong>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</strong></p><p>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fd_set fd_in, fd_out;</span><br><span class="line">struct timeval tv;</span><br><span class="line">&#x2F;&#x2F; Reset the sets</span><br><span class="line">FD_ZERO( &amp;fd_in );</span><br><span class="line">FD_ZERO( &amp;fd_out );</span><br><span class="line">&#x2F;&#x2F; Monitor sock1 for input events</span><br><span class="line">FD_SET( sock1, &amp;fd_in );</span><br><span class="line">&#x2F;&#x2F; Monitor sock2 for output events</span><br><span class="line">FD_SET( sock2, &amp;fd_out );</span><br><span class="line">&#x2F;&#x2F; Find out which socket has the largest numeric value as select requires it</span><br><span class="line">int largest_sock &#x3D; sock1 &gt; sock2 ? sock1 : sock2;</span><br><span class="line">&#x2F;&#x2F; Wait up to 10 seconds</span><br><span class="line">tv.tv_sec &#x3D; 10;</span><br><span class="line">tv.tv_usec &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; Call the select</span><br><span class="line">int ret &#x3D; select( largest_sock + 1, &amp;fd_in, &amp;fd_out, NULL, &amp;tv );</span><br><span class="line">&#x2F;&#x2F; Check if select actually succeed</span><br><span class="line">if ( ret &#x3D;&#x3D; -1 )</span><br><span class="line">&#x2F;&#x2F; report error and abort</span><br><span class="line">else if ( ret &#x3D;&#x3D; 0 )</span><br><span class="line">&#x2F;&#x2F; timeout; no event detected</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if ( FD_ISSET( sock1, &amp;fd_in ) )</span><br><span class="line">&#x2F;&#x2F; input event on sock1</span><br><span class="line">if ( FD_ISSET( sock2, &amp;fd_out ) )</span><br><span class="line">&#x2F;&#x2F; output event on sock2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>int poll(struct pollfd *fds, unsigned int nfds, int timeout);</p><p>poll 的机制与 select 类似，与 select 在本质上没有多大差别，但是 poll 没有最大文件描述符数量的限制。poll改变了fds集合的描述方式，使用了pollfd结构而不是select的fd_set结构 .pollfd 使用链表实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The structure for two events</span><br><span class="line">struct pollfd fds[2];</span><br><span class="line">&#x2F;&#x2F; Monitor sock1 for input</span><br><span class="line">fds[0].fd &#x3D; sock1;</span><br><span class="line">fds[0].events &#x3D; POLLIN;</span><br><span class="line">&#x2F;&#x2F; Monitor sock2 for output</span><br><span class="line">fds[1].fd &#x3D; sock2;</span><br><span class="line">fds[1].events &#x3D; POLLOUT;</span><br><span class="line">&#x2F;&#x2F; Wait 10 seconds</span><br><span class="line">int ret &#x3D; poll( &amp;fds, 2, 10000 );</span><br><span class="line">&#x2F;&#x2F; Check if poll actually succeed</span><br><span class="line">if ( ret &#x3D;&#x3D; -1 )</span><br><span class="line">&#x2F;&#x2F; report error and abort</span><br><span class="line">else if ( ret &#x3D;&#x3D; 0 )</span><br><span class="line">&#x2F;&#x2F; timeout; no event detected</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; If we detect the event, zero it out so we can reuse the structure</span><br><span class="line">if ( fds[0].revents &amp; POLLIN )</span><br><span class="line">fds[0].revents &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; input event on sock1</span><br><span class="line">if ( fds[1].revents &amp; POLLOUT )</span><br><span class="line">fds[1].revents &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; output event on sock2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ol><li><p>功能<br> select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p><p>select 会修改描述符，而 poll 不会；<br>select 的描述符类型使用数组实现，大小默认为 1024，因此默认只能监听 1024 个描述符。而 poll 的描述符类型使用链表实现，没有描述符数量的限制；<br>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。<br>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</p></li><li><p>速度<br> select 和 poll 速度都比较慢。<br> select 和 poll 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。<br> select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用<br> 轮询的方式来找到 I/O 完成的描述符。</p></li><li><p>可移植性<br> 几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p></li></ol><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure><p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<br>红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事<br>件完成的描述符。<br>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获<br>得事件完成的描述符。</p><p>epoll 仅适用于 Linux OS。<br>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和<br>poll 的不确定情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Create the epoll descriptor. Only one is needed per app, and is used to monitor all</span><br><span class="line">sockets.</span><br><span class="line">&#x2F;&#x2F; The function argument is ignored (it was not before, but now it is), so put your favorite</span><br><span class="line">number here</span><br><span class="line">int pollingfd &#x3D; epoll_create( 0xCAFE );</span><br><span class="line">if ( pollingfd &lt; 0 )</span><br><span class="line">&#x2F;&#x2F; report error</span><br><span class="line">&#x2F;&#x2F; Initialize the epoll structure in case more members are added in future</span><br><span class="line">struct epoll_event ev &#x3D; &#123; 0 &#125;;</span><br><span class="line">&#x2F;&#x2F; Associate the connection class instance with the event. You can associate anything</span><br><span class="line">&#x2F;&#x2F; you want, epoll does not use this information. We store a connection class pointer,</span><br><span class="line">pConnection1</span><br><span class="line">ev.data.ptr &#x3D; pConnection1;</span><br><span class="line">&#x2F;&#x2F; Monitor for input, and do not automatically rearm the descriptor after the event</span><br><span class="line">ev.events &#x3D; EPOLLIN | EPOLLONESHOT;</span><br><span class="line">&#x2F;&#x2F; Add the descriptor into the monitoring list. We can do it even if another thread is</span><br><span class="line">&#x2F;&#x2F; waiting in epoll_wait - the descriptor will be properly added</span><br><span class="line">if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) !&#x3D; 0 )</span><br><span class="line">&#x2F;&#x2F; report error</span><br><span class="line">&#x2F;&#x2F; Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may</span><br><span class="line">happen)</span><br><span class="line">struct epoll_event pevents[ 20 ];</span><br><span class="line">&#x2F;&#x2F; Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into</span><br><span class="line">epoll_event array</span><br><span class="line">int ready &#x3D; epoll_wait( pollingfd, pevents, 20, 10000 );</span><br><span class="line">&#x2F;&#x2F; Check if epoll actually succeed</span><br><span class="line">if ( ret &#x3D;&#x3D; -1 )</span><br><span class="line">&#x2F;&#x2F; report error and abort</span><br><span class="line">else if ( ret &#x3D;&#x3D; 0 )</span><br><span class="line">&#x2F;&#x2F; timeout; no event detected</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; Check if any events detected</span><br><span class="line">for ( int i &#x3D; 0; i &lt; ret; i++ )</span><br><span class="line">&#123;</span><br><span class="line">if ( pevents[i].events &amp; EPOLLIN )</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; Get back our connection pointer</span><br><span class="line">Connection * c &#x3D; (Connection*) pevents[i].data.ptr;</span><br><span class="line">c-&gt;handleReadEvent();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p><p>   <strong>水平触发:</strong>如果文件描述符已经就绪可以非阻塞的执行IO操作了,此时会触发通知.允许在任意时刻重复检测IO的状态.select,poll就属于水平触发.</p><p>   <strong>边缘触发:</strong>如果文件描述符自上次状态改变后有新的IO活动到来,此时会触发通知.在收到一个IO事件通知后要尽可能多的执行IO操作,因为如果在一次通知中没有执行完IO那么就需要等到下一次新的IO活动到来才能获取到就绪的描述符.信号驱动式IO就属于边缘触发.</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>IO复用？<br>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。<br>select、poll和epoll ·select、poll、epoll都可以监听多个文件描述符，等待指定的超时时间，直到一个或者多个文件描述符上有事件发生时返回。返回的值就是文件描述符的数量。返回0表示没有事件发生。<br>·差别： </p><ul><li>事件集和工作原理 ： select有三种类型的描述符类型：readfds、writefds、exceptfds，分别对应读、写、异常条件的描述符集合。因此，select不能处理这三种事件以外的事件类型。并且，每一次select会使得内核直接对fd_set进行修改，再下一次使用select的时候需要重置fd_set。每次select返回的都是注册了的事件集合，包括了就绪和没有就绪的，程序检索就绪事件的时间复杂度为O(n)<br>poll对select进行了改进，poll的参数是一个结构体pollfd。poll不会修改描述符，因此每次使用不需要重置pollfd。但是，poll仍然是返回注册了的事件集合，包括了就绪和没有就绪的，程序检索就绪事件的时间复杂度为O(n)。<br>·epoll_ctl() 用于向内核注册新的描述符或者是改变某个描述符的状态。已注册的描述符在内核中会被维护在一棵 红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事 件完成的描述符。使得检索的时间复杂度达到O(1)</li><li>支持最大的文件描述符 ： select：受到系统的限制，由&lt;sys/select.h&gt;头文件中的FD_SETSIZE宏决定，通常是1024 ·poll和epoll一般为65535 </li><li>工作模式 ·select和poll只能工作在相对来说低效的水平触发模式(LT) ·epoll可以工作在高效的边缘触发模式(ET),也可以工作在水平触发模式</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>　Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>公平锁和非公平锁</title>
      <link href="/2020/07/04/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/"/>
      <url>/2020/07/04/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li></ul><p>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><ul><li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点.因为通常情况下挂起的线程重新开始与它真正开始运行，二者之间会产生严重的延时。</li><li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对象头由什么构成</title>
      <link href="/2020/07/04/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%94%B1%E4%BB%80%E4%B9%88%E6%9E%84%E6%88%90/"/>
      <url>/2020/07/04/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%94%B1%E4%BB%80%E4%B9%88%E6%9E%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>对象布局</p><p>在JVM中，对象在内存中的布局分为3块：</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>主要用于储存对象自身的运行时数据，例如对象的hashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程的ID、偏向时间戳</p><h3 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h3><p>而类型指针用于标识JVM通过这个指针来确定这个对象是哪个类的实例。</p><p><img src="https://pic1.zhimg.com/80/v2-e47232518a4e042f31a9e0eb6a48f88c_1440w.jpg" alt="img"></p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>它存储着对象真正的有效信息(程序代码中定义的各种类型的字段内容)，无论是从父类继承来的字段还是子类中定义的</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>它并没有什么特殊的含义，仅仅只是起占位符的作用。原因呢是因为JVM要求对象的起始地址必须是8个字节的整数倍(对象的大小必须是8个字节的整数倍)</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sleep和wait的区别</title>
      <link href="/2020/07/04/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/04/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>1.sleep() 方法正在执行的线程主动让出 cpu（然后 cpu 就可以去执行其他任务），在 sleep 指定时间后 cpu 再回到该线程继续往下执行（注意：sleep 方法只让出了 cpu，而并不会释放同步资源锁）；wait() 是 Object 的方法，调用会放弃对象锁，进入等待队列，待调用 notify()/notifyAll() 唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态。（注意：notify 的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说 notify 只是让之前调用 wait 的线程有权利重新参与线程的调度）；</p><p>2.sleep() 方法可以在任何地方使用，而 wait() 方法则只能在同步方法或同步块中使用；</p><h2 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h2><p><strong>wait、notify原理</strong></p><p>在前面以经说到对象锁的本质，重量级锁模式时对象头是一个指向互斥量的指针，实际上互斥量就是一个监视器锁（ObjectMonitor）的数据结构，此时对象的hashCode、分代年龄等信息都会保存到对应的ObjectMonitor中，ObjectMonitor还有一些属性如recursion记录本锁被重入的次数，EntrySet记录想获取本锁的线程集合，WaitSet记录等待本锁的线程，TheOwner记录拥有本锁的线程对象。如下：</p><p><img src="https://img2018.cnblogs.com/blog/1743446/201907/1743446-20190729174119167-1716466123.png" alt="img"></p><p>（图片来源于网络）</p><p>几个线程一起竞争对象的锁（EntrySet），只有一个能成功（acquire），成功的线程记录在The Owner中。调用wait、notify运行流程如下：</p><p>​    （1） 现有一个对象o，锁正在被线程 t1 持有，调用wait()方法后，线程 t1 将会被”晾到” (实际上仅仅是记录到) Wait Set 结构中。</p><p>​    （2）然后将会有另一个线程 t2 获取到锁，The Owner记录的变成了 t2 线程。</p><p>​    （3）t2 线程不需要 o的锁时，调用o.notify()/o.notifyAll()方法，对象o就会告诉 Wait Set结构中记录的线程们：你们又可以来竞争我啦，我的锁现在没被人持有。</p><p><strong>简单的说就是：wait是对象通知持有自己锁的线程释放我的锁，notify()/notifyAll()就是对象通知刚刚被自己晾在一边的线程又可以来竞争我的锁了。</strong>我想到了一个比较贴切的比喻：</p><p>​    客人（线程）来拜访主人（对象），必须获得主人的时间权（锁），且主人同时只能接待一人（互斥）。</p><p>​    正在客厅接待一名客人时，因为一些原因主人必须先接待另一位客人，这时主人请当前客人去另一间房里等待，让出自己的时间权（wait方法）</p><p>​    主人在客厅接待另一位客人，接待完毕后，让前一位（也可能有几位）在另一间房等待的客人再来到客厅，继续接待（notify/notifyAll方法）</p><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起并释放锁。当其他线程的运行使得这个条件满足时，其它线程<br>会调用 notify() 。<br>它们都属于 Object 的一部分，而不属于 Thread。只能用在同步方法或者同步控制块中使用，</p><p>notify不会释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"T1 start!"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"T1 end!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"T2 start!"</span>);</span><br><span class="line">                    object.notify();</span><br><span class="line">                    System.out.println(<span class="string">"T2 end!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T1 start!</span><br><span class="line">T2 start!</span><br><span class="line">T2 end!</span><br><span class="line">T1 end!</span><br></pre></td></tr></table></figure><h3 id="和condition的对比"><a href="#和condition的对比" class="headerlink" title="和condition的对比"></a>和condition的对比</h3><ol><li>\1. lock不再用synchronize把同步代码包装起来；</li><li>\2. 阻塞需要另外一个对象condition；</li><li>\3. 同步和唤醒的对象是condition而不是lock，对应的方法是await和signal，而不是wait和notify。</li></ol><h2 id="notify和notifyAll区别，什么时候用，什么时候唤醒一个线程，什么时候唤醒多个线程，举个例子？"><a href="#notify和notifyAll区别，什么时候用，什么时候唤醒一个线程，什么时候唤醒多个线程，举个例子？" class="headerlink" title="notify和notifyAll区别，什么时候用，什么时候唤醒一个线程，什么时候唤醒多个线程，举个例子？"></a>notify和notifyAll区别，什么时候用，什么时候唤醒一个线程，什么时候唤醒多个线程，举个例子？</h2>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程的区别和相关问题</title>
      <link href="/2020/07/03/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/03/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念。</p><p>· 线程：是进程的一个执行单元，是独立运行的基本单位。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>•开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源。线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>· 调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程</p><p>中的线程时，会引起进程切换。</p><p>· 通信方面</p><p>进程有独立的地址空间，线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p><h2 id="进程的内存空间"><a href="#进程的内存空间" class="headerlink" title="进程的内存空间"></a>进程的内存空间</h2><p>内核态内存空间、用户态的堆栈（一般8M，从高地址向低地址增长）、数据段、进程代码段</p><p>进程间通信方式</p><p>进程间通信方式：管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket等</p><ul><li>管道:无名管道, 半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。只能用于父子进程和兄弟进程。</li><li>FIFO：也称为命名管道，去除了管道只能在父子进程中使用的限制。</li><li>消息队列</li></ul><p>1.消息队列存放于内核中，可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</p><p>2.避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</p><p>3.读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</p><ul><li>信号量是一个计数器，用于实现进程间的互斥与同步。信号量基于操作系统的 PV 操作。每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li><li>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li><li>套接字：与其它通信机制不同的是，它可用于不同机器间的进程通信。</li></ul><h2 id="进程同步方式？"><a href="#进程同步方式？" class="headerlink" title="进程同步方式？"></a>进程同步方式？</h2><p>1.临界区</p><p>对临界资源进行访问的那段代码称为临界区。</p><p>2.同步与互斥</p><p>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</p><p>互斥：多个进程在同一时刻只有一个进程能进入临界区。</p><p>3.信号量：</p><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><p>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</p><p>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</p><h2 id="线程共享和线程私有的"><a href="#线程共享和线程私有的" class="headerlink" title="线程共享和线程私有的"></a>线程共享和线程私有的</h2><p>线程共享的有：进程代码段、进程共有数据等</p><p>线程私有的：线程ID、寄存器的值、线程的栈</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>就绪，运行，阻塞。</p><p>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。运行缺少资源会变为阻塞。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>B树和B+树的区别?</title>
      <link href="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><img src="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" class><p><img src="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201103195345798.png" alt="image-20201103195345798"></p><p>B Tree 指的是 Balance Tree，也就是平衡树，相当于是一棵多叉查找树，对于一棵 m 阶的 B 树具有如下特性：</p><p>1、根节点至少有两个孩子。</p><p>2、每个中间节点都包含 k - 1 个元素和 k 个孩子，其中 ceil(m/2) &lt;= k &lt;= m。</p><p>3、每个节点中的元素从小到大排列，节点当中的 k - 1 个元素正好是 k 个孩子包含的元素的值域划分。</p><p>4、每一个叶子节点都包含 k - 1 个元素，其中 ceil(m/2) &lt;= k &lt;= m。</p><p>5、所有的叶子节点都位于同一侧。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><img src="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" class><p><img src="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201103195404475.png" alt="image-20201103195404475"></p><p>对于一棵 m 阶的 B+ 树具有如下特性：</p><p>1、根节点至少有两个孩子。</p><p>2、每个中间节点都包含 k  个元素和 k 个孩子，其中 ceil(m/2) &lt;= k &lt;= m。</p><p>3、一个节点中的 key 从左到右非递减排列</p><p>4、所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树剖析</title>
      <link href="/2020/07/03/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/03/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>红黑树是自平衡的二叉查找树</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03bae101f8c99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>性质1：每个节点要么是红色，要么是黑色。</p><p>性质2：根节点永远是黑色的。</p><p>性质3：所有的叶子节点都是空节点（即null），并且是黑色的。</p><p>性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点。）</p><p>性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>红黑树的插入主要分两步：</p><ul><li><p>首先和二叉查找树的插入一样，查找、插入</p></li><li><p>然后调整结构，保证满足红黑树状态</p><ul><li><p>对结点进行重新着色</p></li><li><p>以及对树进行相关的旋转操作</p></li></ul></li></ul><p>一般情况下，红黑树中新插入的节点都是红色的。因为我们从性质5中知道，当前红黑树中从根节点到每个叶子节点的黑色节点数量是一样的，此时假如新的黑色节点的话，必然破坏规则，但加入红色节点却不一定，除非其父节点就是红色节点，因此加入红色节点，破坏规则的可能性小一些。</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>LL</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03baf6b875784?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>LR（插入节点的父节点是左节点，插入节点是右节点）</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03bbc0efb78e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>RR</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03be147552958?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>RL</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03bd41c1d7d63?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>  IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查.<br>  ngnix中,用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器.<br>  java中TreeMap，jdk1.8的hashmap的实现.</p><h2 id="与平衡树的区别"><a href="#与平衡树的区别" class="headerlink" title="与平衡树的区别"></a>与平衡树的区别</h2><p>1.红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。红黑树放弃了追求完全平衡，追求大致平衡</p><p>2.平衡二叉树,每次插入新节点之后需要旋转的次数不能预知。</p><h2 id="平衡树的概念"><a href="#平衡树的概念" class="headerlink" title="平衡树的概念"></a>平衡树的概念</h2><p>平衡二叉树必须是排序二叉树</p><p>左子树和右子树的深度之差的绝对值不超过1。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>平台无关性、机器码、字节码、与C++区别</title>
      <link href="/2020/07/03/%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2020/07/03/%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="无关性"><a href="#无关性" class="headerlink" title="无关性:"></a>无关性:</h2><p><strong>在一个计算机上编译得到的字节码文件（就是.class文件），可以复制到任何一个安装了Java运行环境的计算机上直接运行。然后字节码文件由虚拟机负责解释执行，即Java虚拟机将字节码翻译成本地计算机的机器码，然后将机器码交给本地的操作系统运行。</strong></p><p> C/C++程序是依赖平台的：C/C++源程序所在的特定平台对其源文件进行编译、链接，生成机器指令，即<strong>根据当前平台的机器指令生成可执行文件</strong> 不能保证在所有平台上都能正确的运行，其原因是不同平台可能具有不同的机器指令</p><p>Java在计算机的操作系统上又提供了一个Java运行环境——JRE,只要平台提供了Java运行环境，Java编写的软件就可以在其上运行。</p><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h2><p>机器码是电脑的CPU可直接解读的数据，通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。</p><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>字节码（Bytecode）是一种包含执行程序的<strong>二进制文件</strong>。<strong>字节码是一种中间码</strong>，在运行时通过JVM（JAVA虚拟机）做一次转换生成机器指令，因此能够更好的跨平台运行。</p><h2 id="与C-区别"><a href="#与C-区别" class="headerlink" title="与C++区别"></a>与C++区别</h2><p>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持<br>面向过程。<br>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。<br>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。<br>Java 支持自动垃圾回收，而 C++ 需要手动回收。<br>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编代码通常意味着机器的母语(所谓的机器语言)的人类可读形式</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nio、Bio、Aio</title>
      <link href="/2020/07/03/Nio%E3%80%81Bio%E3%80%81Aio/"/>
      <url>/2020/07/03/Nio%E3%80%81Bio%E3%80%81Aio/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>BIO （Blocking I/O）：同步阻塞I/O模式。</strong></p><p><strong>NIO （New I/O）：同步非阻塞模式。</strong></p><p><strong>AIO （Asynchronous I/O）：异步非阻塞I/O模型。</strong></p><p><strong>同步</strong></p><p>同步就是发起一个调用后，<strong>被调用者</strong>未处理完请求之前，调用不返回。</p><p>通俗的例子描述同步就像:</p><blockquote><p>你打电话问书店老板有没有《葵花宝典》这本书的时候，如果是同步机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。</p></blockquote><p><strong>异步</strong></p><p>异步就是发起一个调用后，立刻得到<strong>被调用者</strong>的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常<strong>依靠事件，回调</strong>等机制来通知调用者其返回结果。</p><p>通俗的例子描述异步就像:</p><blockquote><p>而异步机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调</p></blockquote><p>此处参照知乎上关于此问题的回答：<a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">www.zhihu.com/question/19…</a></p><p>再次总结一下同步与异步：</p><blockquote><p>同步与异步最大的区别就是<strong>被调用方</strong>的<strong>执行方式</strong>和<strong>返回时机</strong>，同步指的是<strong>被调用方</strong>做完事情之后再返回，异步指的是<strong>被调用方</strong>先返回，然后再做事情，做完之后再想办法通知调用方</p></blockquote><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p><strong>阻塞</strong></p><p>阻塞就是发起一个请求，<strong>调用者</strong>一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</p><p><strong>非阻塞</strong></p><p>非阻塞就是发起一个请求，<strong>调用者</strong>不用一直等着结果返回，可以先去干其他事情。</p><p>还是上面买书的例子:</p><blockquote><p>你打电话问书店老板有没有《葵花宝典》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</p></blockquote><h2 id="同步、异步和阻塞、非阻塞的区别"><a href="#同步、异步和阻塞、非阻塞的区别" class="headerlink" title="同步、异步和阻塞、非阻塞的区别"></a>同步、异步和阻塞、非阻塞的区别</h2><p>阻塞和同步不是一回事，同步，异步与阻塞，非阻塞针对的对象是不一样的，<strong>阻塞,非阻塞是说的调用者，同步，异步说的是被调用者</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Bio</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class test implements Runnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     test t&#x3D;new test();</span><br><span class="line">     Thread t1&#x3D;new Thread(t);</span><br><span class="line">     t1.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Socket client&#x3D;new Socket(InetAddress.getLocalHost(),8888);</span><br><span class="line">            BufferedReader bufferedReader &#x3D; new BufferedReader</span><br><span class="line">                    (new InputStreamReader</span><br><span class="line">                            (client.getInputStream()));</span><br><span class="line">            System.out.println(&quot;值: &quot;+bufferedReader.readLine());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerSocket serverSocket&#x3D;new ServerSocket(8888);</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                Socket socket&#x3D;serverSocket.accept();</span><br><span class="line">                try (PrintWriter out &#x3D; new PrintWriter(socket.getOutputStream());) &#123;</span><br><span class="line">                    out.println(&quot;Hello world!&quot;);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>服务器端启动 ServerSocket，端口 0 表示自动绑定一个空闲端口。</p></li><li><p>调用 accept 方法，阻塞等待客户端连接。</p></li><li><p>利用 Socket 模拟了一个简单的客户端，只进行连接、读取、打印。</p></li><li><p>当连接建立后，启动一个单独线程负责回复客户端请求。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/14/1697c8d55677ce94?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li></ul><p>Nio</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class NioExample extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try (Selector selector &#x3D; Selector.open();</span><br><span class="line">             ServerSocketChannel serverSocket &#x3D; ServerSocketChannel.open();)</span><br><span class="line">        &#123;&#x2F;&#x2F; 创建 Selector 和 Channel</span><br><span class="line">            serverSocket.bind(new InetSocketAddress(InetAddress.getLocalHost(), 8888));</span><br><span class="line">            serverSocket.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F; 注册到 Selector，并说明关注点</span><br><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                selector.select();&#x2F;&#x2F; 阻塞等待就绪的 Channel，这是关键点之一</span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys &#x3D; selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter &#x3D; selectedKeys.iterator();</span><br><span class="line">                while (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key &#x3D; iter.next();</span><br><span class="line">                    &#x2F;&#x2F; 生产系统中一般会额外进行就绪状态检查</span><br><span class="line">                    sayHelloWorld((ServerSocketChannel) key.channel());</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sayHelloWorld(ServerSocketChannel server) throws IOException &#123;</span><br><span class="line">        try (SocketChannel client &#x3D; server.accept();) &#123;</span><br><span class="line">            client.write(Charset.defaultCharset().encode(&quot;Hello world!&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 省略了与前面类似的 main</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        NioExample server &#x3D; new NioExample();</span><br><span class="line">        server.start();</span><br><span class="line">        try (Socket client &#x3D; new Socket(InetAddress.getLocalHost(), 8888)) &#123;</span><br><span class="line">            BufferedReader bufferedReader &#x3D; new BufferedReader(new InputStreamReader(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，通过 Selector.open() 创建一个 Selector，作为类似调度员的角色。</p><p>然后，创建一个 ServerSocketChannel，并且向 Selector 注册，通过指定 SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。注意：为什么我们要明确配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会抛出 IllegalBlockingModeException 异常。</p><p>Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒。</p><p>在 sayHelloWorld 方法中，通过 SocketChannel 和 Buffer 进行数据操作，在本例中是发送了一段字符串。</p><p>可以看到，在前面两个样例中，IO 都是同步阻塞模式，所以需要多线程以实现多任务处理。而 NIO 则是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。下面这张图对这种实现思路进行了形象地说明</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/14/1697c8d556639922?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><a href="https://juejin.im/post/5c8aea1df265da2de33f6a09" target="_blank" rel="noopener">https://juejin.im/post/5c8aea1df265da2de33f6a09</a></p><p><a href="https://juejin.im/post/5d19820c6fb9a07ea42094e2#heading-4" target="_blank" rel="noopener">https://juejin.im/post/5d19820c6fb9a07ea42094e2#heading-4</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>值传递和引用传递</title>
      <link href="/2020/07/03/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
      <url>/2020/07/03/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="值传递："><a href="#值传递：" class="headerlink" title="值传递："></a>值传递：</h2><p><strong>在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容</strong></p><p>来看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">valueCrossTest</span><span class="params">(<span class="keyword">int</span> age,<span class="keyword">float</span> weight)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"传入的age："</span>+age);</span><br><span class="line">     System.out.println(<span class="string">"传入的weight："</span>+weight);</span><br><span class="line">     age=<span class="number">33</span>;</span><br><span class="line">     weight=<span class="number">89.5f</span>;</span><br><span class="line">     System.out.println(<span class="string">"方法内重新赋值后的age："</span>+age);</span><br><span class="line">     System.out.println(<span class="string">"方法内重新赋值后的weight："</span>+weight);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">25</span>;</span><br><span class="line">        <span class="keyword">float</span> w=<span class="number">77.5f</span>;</span><br><span class="line">        valueCrossTest(a,w);</span><br><span class="line">        System.out.println(<span class="string">"方法执行后的age："</span>+a);</span><br><span class="line">        System.out.println(<span class="string">"方法执行后的weight："</span>+w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传入的age：<span class="number">25</span></span><br><span class="line">传入的weight：<span class="number">77.5</span></span><br><span class="line"></span><br><span class="line">方法内重新赋值后的age：<span class="number">33</span></span><br><span class="line">方法内重新赋值后的weight：<span class="number">89.5</span></span><br><span class="line"></span><br><span class="line">方法执行后的age：<span class="number">25</span></span><br><span class="line">方法执行后的weight：<span class="number">77.5</span></span><br></pre></td></tr></table></figure><p>从上面的打印结果可以看到：<br>a和w作为实参传入valueCrossTest之后，无论在方法内做了什么操作，最终a和w都没变化。</p><p>这是什么造型呢？！！</p><p>下面我们根据上面学到的知识点，进行详细的分析：</p><p>首先程序运行时，调用main()方法，此时JVM为main()方法往虚拟机栈中压入一个栈帧，即为当前栈帧，用来存放main()中的局部变量表(包括参数)、操作栈、方法出口等信息，如a和w都是main()方法中的局部变量，因此可以断定，a和w是躺着mian方法所在的栈帧中<br>如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669e46bb87ca5be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>而当执行到valueCrossTest()方法时，JVM也为其往虚拟机栈中压入一个栈，即为当前栈帧，用来存放valueCrossTest()中的局部变量等信息，因此age和weight是躺着valueCrossTest方法所在的栈帧中，而他们的值是从a和w的值copy了一份副本而得，如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669e46bb8aa7c65?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>。<br>因而可以a和age、w和weight对应的内容是不一致的，所以当在方法内重新赋值时，实际流程如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669e46be8b5eaf0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>也就是说，age和weight的改动，只是改变了当前栈帧（valueCrossTest方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，mian方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出a和w时，依然是初始化时的内容。<br>因此：<br><strong>值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。</strong></p><h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p><strong>引用传递指的是在方法调用时，实参的地址通过方法调用被传递给相应的形参，对形参的操作会影响的真实内容。</strong></p><p>先定义一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">         <span class="keyword">private</span> String name;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> name;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们写个函数测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PersonCrossTest</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"传入的person的name："</span>+person.getName());</span><br><span class="line">         person.setName(<span class="string">"我是张小龙"</span>);</span><br><span class="line">         System.out.println(<span class="string">"方法内重新赋值后的name："</span>+person.getName());</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">//测试</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p=<span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">"我是马化腾"</span>);</span><br><span class="line">        p.setAge(<span class="number">45</span>);</span><br><span class="line">        PersonCrossTest(p);</span><br><span class="line">        System.out.println(<span class="string">"方法执行后的name："</span>+p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传入的person的name：我是马化腾</span><br><span class="line">方法内重新赋值后的name：我是张小龙</span><br><span class="line">方法执行后的name：我是张小龙</span><br></pre></td></tr></table></figure><p>可以看出，person经过personCrossTest()方法的执行之后，内容发生了改变，这印证了上面所说的<strong>“引用传递”</strong>，对形参的操作，改变了实际对象的内容。</p><p>那么，到这里就结题了吗？<br>不是的，没那么简单，<br>能看得到想要的效果<br>是因为刚好选对了例子而已！！！</p><p>下面我们对上面的例子稍作修改，加上一行代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PersonCrossTest</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"传入的person的name："</span>+person.getName());</span><br><span class="line">        person=<span class="keyword">new</span> Person();<span class="comment">//加多此行代码</span></span><br><span class="line">        person.setName(<span class="string">"我是张小龙"</span>);</span><br><span class="line">        System.out.println(<span class="string">"方法内重新赋值后的name："</span>+person.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传入的person的name：我是马化腾</span><br><span class="line">方法内重新赋值后的name：我是张小龙</span><br><span class="line">方法执行后的name：我是马化腾</span><br></pre></td></tr></table></figure><p>为什么这次的输出和上次的不一样了呢？<br>看出什么问题了吗？</p><p>按照上面讲到JVM内存模型可以知道，对象和数组是存储在Java堆区的，而且堆区是共享的，因此程序执行到main（）方法中的下列代码时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p=<span class="keyword">new</span> Person();</span><br><span class="line">p.setName(<span class="string">"我是马化腾"</span>);</span><br><span class="line">p.setAge(<span class="number">45</span>);</span><br><span class="line">PersonCrossTest(p);</span><br></pre></td></tr></table></figure><p>JVM会在堆内开辟一块内存，用来存储p对象的所有内容，同时在main（）方法所在线程的栈区中创建一个引用p存储堆区中p对象的真实地址，如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669e46be94a3fd8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>当执行到PersonCrossTest()方法时，因为方法内有这么一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person=<span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>JVM需要在堆内另外开辟一块内存来存储new Person()，假如地址为“xo3333”，那此时形参person指向了这个地址，假如真的是引用传递，那么由上面讲到：<strong>引用传递中形参实参指向同一个对象，形参的操作会改变实参对象的改变</strong>。</p><p>可以推出：实参也应该指向了新创建的person对象的地址，所以在执行PersonCrossTest()结束之后，最终输出的应该是后面创建的对象内容。</p><p>然而实际上，最终的输出结果却跟我们推测的不一样，最终输出的仍然是一开始创建的对象的内容。</p><p>由此可见：<strong>引用传递，在Java中并不存在。</strong></p><p>但是有人会疑问：为什么第一个例子中，在方法内修改了形参的内容，会导致原始对象的内容发生改变呢？</p><p>这是因为：<strong>无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669e46be89ea9fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>有图可以看出，方法内的形参person和实参p并无实质关联，它只是由p处copy了一份指向对象的地址，此时：</p><p><strong>p和person都是指向同一个对象</strong>。</p><p>因此在第一个例子中，对形参p的操作，会影响到实参对应的对象内容。而在第二个例子中，当执行到new Person()之后，JVM在堆内开辟一块空间存储新对象，并且把person改成指向新对象的地址，此时：</p><p><strong>p依旧是指向旧的对象，person指向新对象的地址。</strong></p><p>所以此时<strong>对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系</strong>。</p><h1 id="Java中基本数据类型和包装类型的区别"><a href="#Java中基本数据类型和包装类型的区别" class="headerlink" title="Java中基本数据类型和包装类型的区别"></a>Java中基本数据类型和包装类型的区别</h1><p>1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址；基本类型不是<br>2、包装类型是引用的传递；基本类型是值的传递<br>3、声明方式不同：<br>        基本数据类型不需要new关键字；<br>        包装类型需要new在堆内存中进行new来分配内存空间<br>4、存储位置不同：<br>        基本数据类型直接将值保存在值栈中；<br>        包装类型是把对象放在堆中，然后通过对象的引用来调用他们 </p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="/2020/07/03/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2020/07/03/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="cloneable"><a href="#cloneable" class="headerlink" title="cloneable"></a>cloneable</h2><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类<br>实例的 clone() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CloneExample &#123;</span><br><span class="line">  private int a;</span><br><span class="line">  private int b;</span><br><span class="line">&#125;</span><br><span class="line">CloneExample e1 &#x3D; new CloneExample();</span><br><span class="line">&#x2F;&#x2F; CloneExample e2 &#x3D; e1.clone(); &#x2F;&#x2F; &#39;clone()&#39; has protected access in &#39;java.lang.Object&#39;</span><br></pre></td></tr></table></figure><p>正确：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CloneExample implements Cloneable &#123;</span><br><span class="line">  private int a;</span><br><span class="line">  private int b;</span><br><span class="line">  @Override</span><br><span class="line">  public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">  return super.clone();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/14/6610661def48e619bd53667d83d96094?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="/clone-qian.png"></p><p>我们举个clone产生的浅拷贝的例子，我们定义一个对象中的对象，然后尝试拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Address implements Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不是好的方式</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class CustUser implements Cloneable&#123;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line">    private Address address;</span><br><span class="line">    private String[] cars;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException&#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了CustUser和Address。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void testShallowCopy() throws CloneNotSupportedException &#123;</span><br><span class="line">       Address address&#x3D; new Address();</span><br><span class="line">       address.setName(&quot;北京天安门&quot;);</span><br><span class="line">       CustUser custUser &#x3D; new CustUser();</span><br><span class="line">       custUser.setAddress(address);</span><br><span class="line">       custUser.setLastName(&quot;李&quot;);</span><br><span class="line">       custUser.setFirstName(&quot;雷&quot;);</span><br><span class="line">       String[] cars &#x3D; new String[]&#123;&quot;别克&quot;,&quot;路虎&quot;&#125;;</span><br><span class="line">       custUser.setCars(cars);</span><br><span class="line"></span><br><span class="line">       CustUser custUserCopy&#x3D;(CustUser) custUser.clone();</span><br><span class="line">       custUserCopy.setFirstName(&quot;梅梅&quot;);</span><br><span class="line">       custUserCopy.setLastName(&quot;韩&quot;);</span><br><span class="line">       custUserCopy.getAddress().setName(&quot;北京颐和园&quot;);</span><br><span class="line">       custUserCopy.getCars()[0]&#x3D;&quot;奥迪&quot;;</span><br><span class="line"></span><br><span class="line">       log.info(&quot;&#123;&#125;&quot;,custUser);</span><br><span class="line">       log.info(&quot;&#123;&#125;&quot;,custUserCopy);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>浅拷贝我们只调用了CustUser的clone方法。看下输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CustUser(firstName&#x3D;雷, lastName&#x3D;李, address&#x3D;Address(name&#x3D;北京颐和园), cars&#x3D;[奥迪, 路虎])</span><br><span class="line"></span><br><span class="line">CustUser(firstName&#x3D;梅梅, lastName&#x3D;韩, address&#x3D;Address(name&#x3D;北京颐和园), cars&#x3D;[奥迪, 路虎])</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们可以看到拷贝之后的Address变化会影响到被拷贝的对象。</p><p>上面的例子我们还要关注两个点：第一点String是不可变的。不管是拷贝还是赋值，String都是不可变的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public  class Singleton implements  Cloneable</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int[] arr &#x3D;new int[1];</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Singleton s&#x3D; (Singleton)super.clone();</span><br><span class="line">        s.arr&#x3D;this.arr.clone();</span><br><span class="line">        return s;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Singleton s1&#x3D;new Singleton();</span><br><span class="line">        Singleton s2&#x3D;(Singleton) s1.clone();</span><br><span class="line">        s1.x&#x3D;1;</span><br><span class="line">        s2.x&#x3D;2;</span><br><span class="line">        s1.arr[0]&#x3D;1;</span><br><span class="line">        s2.arr[0]&#x3D;3;</span><br><span class="line">        System.out.println(s1.x+&quot; &quot;+s2.x);</span><br><span class="line">        System.out.println(s1.arr[0]+&quot; &quot;+s2.arr[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/14/5c30e76c9d63860ac430dfd2ddfbdd4f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="/clone-深.png"></p><p>用序列化进行深拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369285298572941L</span>;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 邮件</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDesc personDesc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 将该对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。所以利用这个特性可以实现对象的深拷贝</span></span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 将流序列化成对象</span></span><br><span class="line">            ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">            person = (Person) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDesc.setDesc(desc);</span><br><span class="line">    &#125;</span><br><span class="line">  ...省略...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDesc</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">872390113109L</span>; </span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化一个对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"平头哥"</span>,<span class="number">20</span>,<span class="string">"123456@qq.com"</span>,<span class="string">"我的公众号是：平头哥的技术博文"</span>);</span><br><span class="line">        <span class="comment">// 复制对象</span></span><br><span class="line">        Person person1 = (Person) person.clone();</span><br><span class="line">        <span class="comment">// 改变 person1 的属性值</span></span><br><span class="line">        person1.setName(<span class="string">"我是平头哥的克隆对象"</span>);</span><br><span class="line">        <span class="comment">// 修改 person age 的值</span></span><br><span class="line">        person1.setAge(<span class="number">22</span>);</span><br><span class="line">        person1.setDesc(<span class="string">"我已经关注了平头哥的技术博文公众号"</span>);</span><br><span class="line">        System.out.println(<span class="string">"person对象："</span>+person);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"person1对象："</span>+person1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个对象多少个字节</title>
      <link href="/2020/07/03/%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82/"/>
      <url>/2020/07/03/%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AAAAA &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BBBBB &#123;</span><br><span class="line">  int a &#x3D; 1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CCCCC &#123;</span><br><span class="line">  long a &#x3D; 1l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DDDDD &#123;</span><br><span class="line">   String s &#x3D; &quot;Hello&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针压缩：</p><ul><li><p>A对象只包含一个对象头，大小占12字节，不是8的倍数，需要4字节进行填充，一共占16字节</p></li><li><p>B对象包含一个对象头和int类型，12+4=16，正好是8的倍数，不需要填充。</p></li><li><p>C对象包含一个对象头和long类型，12+8=20，不是8的倍数，需要4个字节进行填充，占24字节</p></li><li><p>D对象包含一个对象头和引用类型，12+4=16，正好是8的倍数，不需要填充</p><p><a href="https://blog.csdn.net/qlmmys/article/details/53213857" target="_blank" rel="noopener">https://blog.csdn.net/qlmmys/article/details/53213857</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反射机制及其优缺点</title>
      <link href="/2020/07/02/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>/2020/07/02/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个属性和方法，这种功能称为java语言的反射机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内</span><br><span class="line">容保存着 Class 对象。也可以使用Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</span><br></pre></td></tr></table></figure><p>类对象 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：<br><strong>Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</strong><br><strong>Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</strong><br><strong>Constructor ：可以用 Constructor 创建新的对象。</strong></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</p><p>方便性: 可以写在配置文件里，直接修改配置文件就行了</p><p>spring.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class&#x3D;reflection.Service1</span><br><span class="line">method&#x3D;doService1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line"> </span><br><span class="line">    @SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;从spring.txt中获取类名称和方法名称</span><br><span class="line">        File springConfigFile &#x3D; new File(&quot;e:\\project\\j2se\\src\\spring.txt&quot;);</span><br><span class="line">        Properties springConfig&#x3D; new Properties();</span><br><span class="line">        springConfig.load(new FileInputStream(springConfigFile));</span><br><span class="line">        String className &#x3D; (String) springConfig.get(&quot;class&quot;);</span><br><span class="line">        String methodName &#x3D; (String) springConfig.get(&quot;method&quot;);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;根据类名称获取类对象</span><br><span class="line">        Class clazz &#x3D; Class.forName(className);</span><br><span class="line">        &#x2F;&#x2F;根据方法名称，获取方法对象</span><br><span class="line">        Method m &#x3D; clazz.getMethod(methodName);</span><br><span class="line">        &#x2F;&#x2F;获取构造器</span><br><span class="line">        Constructor c &#x3D; clazz.getConstructor();</span><br><span class="line">        &#x2F;&#x2F;根据构造器，实例化出对象</span><br><span class="line">        Object service &#x3D; c.newInstance();</span><br><span class="line">        &#x2F;&#x2F;调用对象的指定方法</span><br><span class="line">        m.invoke(service);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些<br>非反射操作低得多。</p><p>内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使<br>用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。</p><h3 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            String className = <span class="string">"charactor.Hero"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class pClass1=Class.forName(className);</span><br><span class="line">                Class pClass2=Hero<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                Class pClass3=<span class="keyword">new</span> Hero().getClass();</span><br><span class="line">                System.out.println(pClass1==pClass2);</span><br><span class="line">                System.out.println(pClass1==pClass3);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import charactor.Hero;</span><br><span class="line">public class TestReflection &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;传统的使用new的方式创建对象</span><br><span class="line">        Hero h1 &#x3D;new Hero();</span><br><span class="line">        h1.name &#x3D; &quot;teemo&quot;;</span><br><span class="line">        System.out.println(h1);</span><br><span class="line">          </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;使用反射的方式创建对象</span><br><span class="line">            String className &#x3D; &quot;charactor.Hero&quot;;</span><br><span class="line">            &#x2F;&#x2F;类对象</span><br><span class="line">            Class pClass&#x3D;Class.forName(className);</span><br><span class="line">            &#x2F;&#x2F;构造器</span><br><span class="line">            Constructor c&#x3D; pClass.getConstructor();</span><br><span class="line">            &#x2F;&#x2F;通过构造器实例化</span><br><span class="line">            Hero h2&#x3D; (Hero) c.newInstance();</span><br><span class="line">            h2.name&#x3D;&quot;gareen&quot;;</span><br><span class="line">            System.out.println(h2);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>对于private修饰的成员，需要使用setAccessible(true)才能访问和修改。不在此知识点讨论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestReflection &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            Hero h &#x3D;new Hero();</span><br><span class="line">            &#x2F;&#x2F;使用传统方式修改name的值为garen</span><br><span class="line">            h.name &#x3D; &quot;garen&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;获取类Hero的名字叫做name的字段</span><br><span class="line">                Field f1&#x3D; h.getClass().getDeclaredField(&quot;name&quot;);</span><br><span class="line">                &#x2F;&#x2F;修改这个字段的值</span><br><span class="line">                f1.set(h, &quot;teemo&quot;);</span><br><span class="line">                &#x2F;&#x2F;打印被修改后的值</span><br><span class="line">                System.out.println(h.name);</span><br><span class="line">                 </span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getField和getDeclaredField的区别</span><br><span class="line">这两个方法都是用于获取字段</span><br><span class="line">getField 只能获取public的，包括从父类继承来的字段。</span><br><span class="line">getDeclaredField 可以获取本类所有的字段，包括private的，但是不能获取继承来的字段。 (注： 这里只能获取到private的字段，但并不能访问该private字段的值,除非加上setAccessible(true))</span><br></pre></td></tr></table></figure><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">    public int damage;</span><br><span class="line">    public int id;</span><br><span class="line">     </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Hero()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    public Hero(String string) &#123;</span><br><span class="line">        name &#x3D;string;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hero [name&#x3D;&quot; + name + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isDead() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public void attackHero(Hero h2) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestReflection &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h &#x3D; new Hero();</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取这个名字叫做setName，参数类型是String的方法</span><br><span class="line">            Method m &#x3D; h.getClass().getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">            &#x2F;&#x2F; 对h对象，调用这个方法</span><br><span class="line">            m.invoke(h, &quot;盖伦&quot;);</span><br><span class="line">            &#x2F;&#x2F; 使用传统的方式，调用getName方法</span><br><span class="line">            System.out.println(h.getName());</span><br><span class="line"> </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>==、equals、hashcode</title>
      <link href="/2020/07/02/%E3%80%81equals%E3%80%81hashcode/"/>
      <url>/2020/07/02/%E3%80%81equals%E3%80%81hashcode/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。<br>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x &#x3D; new Integer(1);</span><br><span class="line">Integer y &#x3D; new Integer(1);</span><br><span class="line">System.out.println(x.equals(y)); &#x2F;&#x2F; true</span><br><span class="line">System.out.println(x &#x3D;&#x3D; y); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><h2 id="为什么重写equals需要重写hashcode？"><a href="#为什么重写equals需要重写hashcode？" class="headerlink" title="为什么重写equals需要重写hashcode？"></a>为什么重写equals需要重写hashcode？</h2><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，如果不重写hashcode的话，会导致等价的两个对象散列值不相同 (由于默认的hashcode方法是根据对象的内存地址经哈希算法得来的，故两者的hashcode不一定相等) 。因此在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何排查内存泄漏</title>
      <link href="/2020/07/02/%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>/2020/07/02/%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>内存泄漏：你用new申请了一块内存，后来很长时间都不再使用了（按理应该释放），但是因为一直被某个或某些实例所持有导致 GC 不能回收，也就是该被释放的对象没有释放。</p><p>各种连接，threadlocal,单例模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">单例模式。不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露，考虑下面的例子：</span><br><span class="line">　　class A&#123;</span><br><span class="line"></span><br><span class="line">　　public A()&#123;</span><br><span class="line"></span><br><span class="line">　　  B.getInstance().setA(this);</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　....</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#x2F;&#x2F;B类采用单例模式</span><br><span class="line"></span><br><span class="line">　　class B&#123;</span><br><span class="line"></span><br><span class="line">　　private A a;</span><br><span class="line"></span><br><span class="line">　　private static B instance&#x3D;new B();</span><br><span class="line"></span><br><span class="line">　　public B()&#123;&#125;</span><br><span class="line"></span><br><span class="line">　　public static B getInstance()&#123;</span><br><span class="line"></span><br><span class="line">　　return instance;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　public void setA(A a)&#123;</span><br><span class="line"></span><br><span class="line">　　this.a&#x3D;a;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#x2F;&#x2F;getter...</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>首先通过“虚拟机进程状况工具：jps”找出正在运行的虚拟机进程，最主要是找出这个进程在本地虚拟机的唯一ID（LVMID，Local Virtual Machine Identifier），因为在后面的排查过程中都是需要这个LVMID来确定要监控的是哪一个虚拟机进程。<br>同时，对于本地虚拟机进程来说，LVMID与操作系统的进程ID（PID，Process Identifier）是一致的，使用Windows的任务管理器或Unix的ps命令也可以查询到虚拟机进程的LVMID。<br>jps命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure><p>使用命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用jps：jps -l</span><br><span class="line">使用ps：ps aux | grep tomat</span><br></pre></td></tr></table></figure><p>找到你需要监控的ID（假设为20954），再利用“虚拟机统计信息监视工具：jstat”监视虚拟机各种运行状态信息。<br>jstat命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [ option vmid [interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure><p>使用命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 20954 1000</span><br></pre></td></tr></table></figure><p>意思是每1000毫秒查询一次，一直查。gcutil的意思是已使用空间站总空间的百分比。<br>结果如下图：</p><p>jstat执行结果<br>查询结果表明：这台服务器的新生代Eden区（E，表示Eden）使用了28.30%（最后）的空间，两个Survivor区（S0、S1，表示Survivor0、Survivor1）分别是0和8.93%，老年代（O，表示Old）使用了87.33%。程序运行以来共发生Minor GC（YGC，表示Young GC）101次，总耗时1.961秒，发生Full GC（FGC，表示Full GC）7次，Full GC总耗时3.022秒，总的耗时（GCT，表示GC Time）为4.983秒。</p><p>2.2 找出导致频繁Full GC的原因<br>分析方法通常有两种：<br>1）把堆dump下来再用MAT等工具进行分析，但dump堆要花较长的时间，并且文件巨大，再从服务器上拖回本地导入工具，这个过程有些折腾，不到万不得已最好别这么干。<br>2）更轻量级的在线分析，使用“Java内存影像工具：jmap”生成堆转储快照（一般称为headdump或dump文件）。<br>jmap命令格式：<br>jmap [ option ] vmid<br>使用命令如下：<br>jmap -histo:live 20954<br>查看存活的对象情况，如下图所示：</p><p>存活对象<br>按照一位IT友的说法，数据不正常，十有八九就是泄露的。在我这个图上对象还是挺正常的。</p><p>我在网上找了一位博友的不正常数据，如下：</p><p>image.png<br>可以看出HashTable中的元素有5000多万，占用内存大约1.5G的样子。这肯定不正常。</p><p>2.3 定位到代码<br>定位带代码，有很多种方法，比如前面提到的通过MAT查看Histogram即可找出是哪块代码。——我以前是使用这个方法。 也可以使用BTrace，我没有使用过。</p><p>举例：</p><p>一台生产环境机器每次运行几天之后就会莫名其妙的宕机，分析日志之后发现在tomcat刚启动的时候内存占用比较少，但是运行个几天之后内存占用越来越大，通过jmap命令可以查询到一些大对象引用没有被及时GC，这里就要求解决内存泄露的问题。</p><p>Java的内存泄露多半是因为对象存在无效的引用，对象得不到释放，如果发现Java应用程序占用的内存出现了泄露的迹象，那么我们一般采用下面的步骤分析：</p><ol><li>用工具生成java应用程序的heap dump（如jmap）</li><li>使用Java heap分析工具（如MAT），找出内存占用超出预期的嫌疑对象</li><li>根据情况，分析嫌疑对象和其他对象的引用关系。</li><li>分析程序的源代码，找出嫌疑对象数量过多的原因。</li></ol><p>以下一步步的按照项目实例来操作，去解决内存泄露的问题。</p><p>1.登录linux服务器，获取tomcat的pid，命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160907153739493" alt="img"></p><p>2.利用jmap初步分析内存映射，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live 3514 | head -7</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160907162814112" alt="img"></p><p>第2行是我们业务系统的对象，通过这个对象的引用可以初步分析出到底是哪里出现了引用未被垃圾回收收集，通知开发人员优化相关代码。</p><p>3.如果上面一步还无法定位到关键信息，那么需要拿到heap dump，生成离线文件，做进一步分析，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format&#x3D;b,file&#x3D;heap.hprof 3514</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160907162941232" alt="img"></p><p>4.拿到heap dump文件，利用eclipse插件MAT来分析heap profile。</p><p>a. 安装MAT插件</p><p>b. 在eclipse里切换到Memory Analysis视图</p><p>c. 用MAT打开heap profile文件。</p><p><img src="https://img-blog.csdn.net/20160907163118749" alt="img"></p><p>直接看到下面Action窗口，有4种Action来分析heap profile，介绍其中最常用的2种:</p><p>- <strong>Histogram</strong>：这个使用的最多，跟上面的jmap -histo 命令类似，只是在MAT里面可以用GUI来展示应用系统各个类产生的实例。</p><p><img src="https://img-blog.csdn.net/20160907163309052" alt="img"></p><p>Shllow Heap排序后发现 Cms_Organization 这个类占用的内存比较多（没有得到及时GC），查看引用：</p><p><img src="https://img-blog.csdn.net/20160907163424065" alt="img"></p><p>分析引用栈，找到无效引用，打开源码：</p><p><img src="https://img-blog.csdn.net/20160907163540520" alt="img"></p><p>有问题的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class RefreshCmsOrganizationStruts implements Runnable&#123;</span><br><span class="line"> </span><br><span class="line">private final static Logger logger &#x3D; Logger.getLogger(RefreshCmsOrganizationStruts.class);</span><br><span class="line"></span><br><span class="line">private List&lt;Cms_Organization&gt; organizations;</span><br><span class="line"> </span><br><span class="line">private OrganizationDao organizationDao &#x3D; (OrganizationDao) WebContentBean</span><br><span class="line">.getInstance().getBean(&quot;organizationDao&quot;);</span><br><span class="line">public RefreshCmsOrganizationStruts(List&lt;Cms_Organization&gt; organizations) &#123;</span><br><span class="line">this.organizations &#x3D; organizations;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void run() &#123;</span><br><span class="line">Iterator&lt;Cms_Organization&gt; iter &#x3D; organizations.iterator();</span><br><span class="line">Cms_Organization organization &#x3D; null;</span><br><span class="line">while (iter.hasNext()) &#123;</span><br><span class="line">organization &#x3D; iter.next();</span><br><span class="line">synchronized (organization) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">organizationDao.refreshCmsOrganizationStrutsInfo(organization.getOrgaId());</span><br><span class="line">organizationDao.refreshCmsOrganizationResourceInfo(organization.getOrgaId());</span><br><span class="line">organizationDao.sleep();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">logger.debug(&quot;RefreshCmsOrganizationStruts organization &#x3D; &quot; + organization.getOrgaId(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析源码，定时任务定时调用，每次调用生成10个线程处理，而它又使用了非线程安全的List对象，导致List对象无法被GC收集，所以这里将List替换为CopyOnWriteArrayList 。</p><p><strong>Dominator Tree</strong>：这个使用的也比较多，显示大对象的占用率</p><p><img src="https://img-blog.csdn.net/20160907164212086" alt="img"></p><p>同样的打开源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class CategoryCacheJob extends QuartzJobBean implements StatefulJob &#123;</span><br><span class="line"></span><br><span class="line">private static final Logger LOGGER &#x3D; Logger.getLogger(CategoryCacheJob.class);</span><br><span class="line"></span><br><span class="line">public static Map&lt;String,List&lt;Cms_Category&gt;&gt; cacheMap &#x3D; new java.util.HashMap&lt;String,List&lt;Cms_Category&gt;&gt;();</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 缓存编目树开始 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">MongoBaseDao mongoBaseDao &#x3D; (MongoBaseDao) BeanLocator.getInstance().getBean(&quot;mongoBaseDao&quot;);</span><br><span class="line">MongoOperations mongoOperations &#x3D; mongoBaseDao.getMongoOperations();</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">LOGGER.info(&quot;1.缓存基础教育编目树&quot;);</span><br><span class="line">Query query &#x3D; Query.query(Criteria.where(&quot;isDel&quot;).is(&quot;0&quot;).and(&quot;categoryType&quot;).is(&quot;F&quot;));</span><br><span class="line">query.sort().on(&quot;orderNo&quot;, Order.ASCENDING);</span><br><span class="line">List&lt;Cms_Category&gt; list &#x3D; mongoOperations.find(query, Cms_Category.class);</span><br><span class="line">String key &#x3D; query.toString().replaceAll(&quot;\\&#123;|\\&#125;|\\p&#123;Cntrl&#125;|\\p&#123;Space&#125;&quot;, &quot;&quot;);</span><br><span class="line">key +&#x3D; &quot;_CategoryCacheJob&quot;;</span><br><span class="line">cacheMap.put(key, list);</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;LOGGER.info(&quot;2.缓存职业教育编目树&quot;);</span><br><span class="line">Query query2 &#x3D; Query.query(Criteria.where(&quot;isDel&quot;).is(&quot;0&quot;).and(&quot;categoryType&quot;).in(&quot;JMP&quot;,&quot;JHP&quot;));</span><br><span class="line">query2.sort().on(&quot;orderNo&quot;, Order.ASCENDING);</span><br><span class="line">List&lt;Cms_Category&gt; list2 &#x3D; mongoOperations.find(query2, Cms_Category.class);</span><br><span class="line">String key2 &#x3D; query2.toString().replaceAll(&quot;\\&#123;|\\&#125;|\\p&#123;Cntrl&#125;|\\p&#123;Space&#125;&quot;, &quot;&quot;);</span><br><span class="line">key2 +&#x3D; &quot;_CategoryCacheJob&quot;;</span><br><span class="line">cacheMap.put(key2, list2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;LOGGER.info(&quot;3.缓存专题教育编目树&quot;);</span><br><span class="line">Query query3 &#x3D; Query.query(Criteria.where(&quot;isDel&quot;).is(&quot;0&quot;).and(&quot;categoryType&quot;).is(&quot;JS&quot;));</span><br><span class="line">query3.sort().on(&quot;orderNo&quot;, Order.ASCENDING);</span><br><span class="line">List&lt;Cms_Category&gt; list3 &#x3D; mongoOperations.find(query3, Cms_Category.class);</span><br><span class="line">String key3 &#x3D; query3.toString().replaceAll(&quot;\\&#123;|\\&#125;|\\p&#123;Cntrl&#125;|\\p&#123;Space&#125;&quot;, &quot;&quot;);</span><br><span class="line">key3 +&#x3D; &quot;_CategoryCacheJob&quot;;</span><br><span class="line">cacheMap.put(key3, list3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 缓存编目树结束 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125; catch(Exception ex) &#123;</span><br><span class="line">LOGGER.error(ex.getMessage(), ex);</span><br><span class="line">LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 缓存编目树出错 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存泄漏的原因分析，总结出来只有一条：<strong>存在无效的引用</strong></p><p><a href="https://blog.csdn.net/fishinhouse/article/details/80781673" target="_blank" rel="noopener">https://blog.csdn.net/fishinhouse/article/details/80781673</a></p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.8新特性</title>
      <link href="/2020/07/02/JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/07/02/JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>lambda表达式允许你通过表达式来代替功能接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression 或 (parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(cpt);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"========================="</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt2 = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line">TreeSet&lt;Integer&gt; set2 = <span class="keyword">new</span> TreeSet&lt;&gt;(cpt2);</span><br></pre></td></tr></table></figure><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>Stream操作的三个步骤</p><ul><li><p>创建stream</p></li><li><p>中间操作（过滤、map）</p></li><li><p>终止操作</p><p>stream的创建：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1，校验通过Collection 系列集合提供的stream()或者paralleStream()</span><br><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">Strean&lt;String&gt; stream1 &#x3D; list.stream();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.通过Arrays的静态方法stream()获取数组流</span><br><span class="line">String[] str &#x3D; new String[10];</span><br><span class="line">Stream&lt;String&gt; stream2 &#x3D; Arrays.stream(str);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.通过Stream类中的静态方法of</span><br><span class="line">Stream&lt;String&gt; stream3 &#x3D; Stream.of(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4.创建无限流</span><br><span class="line">&#x2F;&#x2F; 迭代</span><br><span class="line">Stream&lt;Integer&gt; stream4 &#x3D; Stream.iterate(0,(x) -&gt; x+2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成</span><br><span class="line">Stream.generate(() -&gt;Math.random());</span><br></pre></td></tr></table></figure><p>Stream的中间操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 筛选 过滤  去重</span><br><span class="line">   *&#x2F;</span><br><span class="line">  emps.stream()</span><br><span class="line">          .filter(e -&gt; e.getAge() &gt; 10)</span><br><span class="line">          .limit(4)</span><br><span class="line">          .skip(4)</span><br><span class="line">          &#x2F;&#x2F; 需要流中的元素重写hashCode和equals方法</span><br><span class="line">          .distinct()</span><br><span class="line">          .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   *  生成新的流 通过map映射</span><br><span class="line">   *&#x2F;</span><br><span class="line">  emps.stream()</span><br><span class="line">          .map((e) -&gt; e.getAge())</span><br><span class="line">          .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   *  自然排序  定制排序</span><br><span class="line">   *&#x2F;</span><br><span class="line">  emps.stream()</span><br><span class="line">          .sorted((e1 ,e2) -&gt; &#123;</span><br><span class="line">              if (e1.getAge().equals(e2.getAge()))&#123;</span><br><span class="line">                  return e1.getName().compareTo(e2.getName());</span><br><span class="line">              &#125; else&#123;</span><br><span class="line">                  return e1.getAge().compareTo(e2.getAge());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>Stream的终止操作：</p><p>reduce:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> *  reduce ：规约操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">List&lt;Integer&gt; list &#x3D; Arrays.asList(1,2,3,4,5,6,7,8,9,10);</span><br><span class="line">Integer count2 &#x3D; list.stream()</span><br><span class="line">        .reduce(0, (x, y) -&gt; x + y);</span><br><span class="line">System.out.println(count2);</span><br><span class="line"></span><br><span class="line">Optional&lt;Double&gt; sum &#x3D; emps.stream()</span><br><span class="line">        .map(Employee::getSalary)</span><br><span class="line">        .reduce(Double::sum);</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><p>collect操作：Collect-将流转换为其他形式，接收一个Collection接口的实现，用于给Stream中元素做汇总的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  collect：收集操作</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; ageList &#x3D; emps.stream()</span><br><span class="line">        .map(Employee::getAge)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">ageList.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="接口中可以定义默认实现方法和静态方法"><a href="#接口中可以定义默认实现方法和静态方法" class="headerlink" title="接口中可以定义默认实现方法和静态方法"></a>接口中可以定义默认实现方法和静态方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Interface &#123;</span><br><span class="line">    default  String getName()&#123;</span><br><span class="line">        return &quot;zhangsan&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String getName2()&#123;</span><br><span class="line">        return &quot;zhangsan&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对static的理解</title>
      <link href="/2020/07/02/%E5%AF%B9static%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/07/02/%E5%AF%B9static%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="能否被重写"><a href="#能否被重写" class="headerlink" title="能否被重写"></a>能否被重写</h2><p>语法上子类允许出现和父类只有方法体不一样其他都一模一样的static方法，但是在父类引用指向子类对象时，通过父类引用调用的依然是父类的static方法，而不是子类的static方法。<br>即：语法上static支持重写，但是运行效果上达不到多态目的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;  </span><br><span class="line">        static void a( )&#123;System.out.println(&quot;A&quot;);  &#125;  </span><br><span class="line">                 void b( )&#123;System.out.println(&quot;B&quot;); &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">public class  Inherit extends Base&#123;  </span><br><span class="line">          static void a( )&#123;System.out.println(&quot;C&quot;);  &#125;  </span><br><span class="line">                  void b( )&#123;System.out.println(&quot;D&quot;); &#125;  </span><br><span class="line">           public static void main(String args[])&#123;  </span><br><span class="line">                    Base b&#x3D;new Base();  </span><br><span class="line">                    Base  c&#x3D;new Inherit();  </span><br><span class="line">                    b.a();  </span><br><span class="line">                    b.b();  </span><br><span class="line">                    c.a();  </span><br><span class="line">                    c.b();  </span><br><span class="line">         &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h2><p>​    1.静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来<br> 访问它。静态变量在内存中只存在一份。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">  private int x; &#x2F;&#x2F; 实例变量</span><br><span class="line">  private static int y; &#x2F;&#x2F; 静态变量</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">  &#x2F;&#x2F; int x &#x3D; A.x; &#x2F;&#x2F; Non-static field &#39;x&#39; cannot be referenced from a static context</span><br><span class="line">  A a &#x3D; new A();</span><br><span class="line">  int x &#x3D; a.x;</span><br><span class="line">  int y &#x3D; A.y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>静态方法<br> 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class A &#123;</span><br><span class="line">public static void func1()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; public abstract static void func2(); &#x2F;&#x2F; Illegal combination of modifiers: &#39;abstract&#39;</span><br><span class="line">and &#39;static&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>静态语句块<br> 静态语句块在类初始化时运行一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println(&quot;123&quot;);</span><br><span class="line">&#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">  A a1 &#x3D; new A();</span><br><span class="line">  A a2 &#x3D; new A();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure></li><li><p>静态内部类</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">  class InnerClass &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  static class StaticInnerClass &#123;</span><br><span class="line"> &#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; InnerClass innerClass &#x3D; new InnerClass(); &#x2F;&#x2F; &#39;OuterClass.this&#39; cannot be</span><br><span class="line">   referenced from a static context</span><br><span class="line">  OuterClass outerClass &#x3D; new OuterClass();</span><br><span class="line">  InnerClass innerClass &#x3D; outerClass.new InnerClass();</span><br><span class="line">  StaticInnerClass staticInnerClass &#x3D; new StaticInnerClass();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.初始化顺序</p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺<br>序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static String staticField &#x3D; &quot;静态变量&quot;;</span><br><span class="line">  static &#123;</span><br><span class="line">  System.out.println(&quot;静态语句块&quot;);</span><br><span class="line">&#125;</span><br><span class="line">  public String field &#x3D; &quot;实例变量&quot;;</span><br><span class="line"> &#123;</span><br><span class="line">  System.out.println(&quot;普通语句块&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后才是构造函数的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public InitialOrderTest() &#123;</span><br><span class="line">  System.out.println(&quot;构造函数&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>修饰符(public&amp;protect&amp;default&amp;private)、接口，抽象类</title>
      <link href="/2020/07/02/%E4%BF%AE%E9%A5%B0%E7%AC%A6public-protect-default-private/"/>
      <url>/2020/07/02/%E4%BF%AE%E9%A5%B0%E7%AC%A6public-protect-default-private/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><img src="/2020/07/02/%E4%BF%AE%E9%A5%B0%E7%AC%A6public-protect-default-private/1.png" class title="如图% } Java 中有三个访问权限修饰符：private、protected 以及 public，**如果不加访问修饰符，表示包级可见**。 可以对类或类中的成员（字段以及方法）加上访问修饰符。 **protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。** &lt;figure class&#x3D;highlight plain&gt;&lt;table&gt;&lt;tr&gt;&lt;td class&#x3D;gutter&gt;&lt;pre&gt;&lt;span class&#x3D;line&gt;1&lt;&#x2F;span&gt;&lt;br&gt;&lt;span class&#x3D;line&gt;2&lt;&#x2F;span&gt;&lt;br&gt;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;td class&#x3D;code&gt;&lt;pre&gt;&lt;span class&#x3D;line&gt;类可见表示其它类可以用这个类创建实例对象。&lt;&#x2F;span&gt;&lt;br&gt;&lt;span class&#x3D;line&gt;成员可见表示其它类可以用这个类的实例对象访问到该成员；&lt;&#x2F;span&gt;&lt;br&gt;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&lt;&#x2F;figure&gt; ## 抽象类与接口 ### 抽象类 **抽象类用来描述一种类型应该具备的基本特征与功能。** （犬科均会吼叫，但属于犬科的狼与狗其吼叫内容不同。所以犬科规定了有吼叫功能，但并不明确吼叫的细节。吼叫的细节应该由狼与狗这样的犬科子类重写吼叫的方法具体实现。） **抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。** ### 接口 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了（default）。 **接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。接口的变量默认都是 static 和 final 的。** ### 比较 * 从设计层面上看，**抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所** **有父类对象**。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具 有 IS-A 关系。 * 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 * 接口的变量只能是 static 和 final 类型的，而抽象类的变量没有这种限制。 * 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 {% asset_img 2.png"><img src="/2020/07/02/%E4%BF%AE%E9%A5%B0%E7%AC%A6public-protect-default-private/3.png" class><h3 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h3><p>使用接口：<br>1.需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；<br>2.需要使用多重继承。<br>使用抽象类：<br>1.需要在几个相关的类中共享代码。<br>2.需要能控制继承来的成员的访问权限，而不是都为 public。<br>3.需要继承非静态和非常量字段。<br>在很多情况下，<strong>接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并</strong><br><strong>且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象三大特性的理解?</title>
      <link href="/2020/07/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/07/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>将数据和基于数据的操作封装在一起，数据被保护在抽象数据类型的内部，只保留一些对外的接口使其与外部发生联系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> gender;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> gender == <span class="number">0</span> ? <span class="string">"man"</span> : <span class="string">"woman"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">    System.out.println(name + <span class="string">" is working very hard!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(name + <span class="string">" can't work any more!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非<br>private 的属性和方法。<br>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。<br>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态分为编译时多态和运行时多态：</p><ul><li><p>编译时多态主要指方法的重载</p></li><li><p>运行时多态指的是 <strong>对象引用所指向的具体类型在运行期间才确定</strong></p></li></ul><p>运行时多态有三个条件：<br>  1.继承<br>  2.重写<br>  3.向上转型</p><p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且<br>在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，<br>会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Instument is playing..."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Wind is playing..."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Percussion is playing..."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   List&lt;Instrument&gt; instruments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   instruments.add(<span class="keyword">new</span> Wind());</span><br><span class="line">   instruments.add(<span class="keyword">new</span> Percussion());</span><br><span class="line">   <span class="keyword">for</span>(Instrument instrument : instruments) &#123;</span><br><span class="line">   instrument.play();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wind is playing...</span><br><span class="line">Percussion is playing...</span><br></pre></td></tr></table></figure><h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><p>重写（Override）<br>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。<br>为了满足里式替换原则，重写有以下三个限制：<br><strong>1.子类方法的访问权限必须大于等于父类方法；</strong><br><strong>2.子类方法的返回类型必须是父类方法返回类型或为其子类型。</strong><br><strong>3.子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</strong><br>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有查找到再到父类中查看，看是否有继承来的方<br>法。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p><p>this.func(this)<br>super.func(this)<br>this.func(super)<br>super.func(super)</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Error和Exception</title>
      <link href="/2020/07/02/Error%E5%92%8CException/"/>
      <url>/2020/07/02/Error%E5%92%8CException/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Throwable 用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM<br>无法处理的错误，Exception 分为两种：</p><ul><li><p>非运行时异常 ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复,IOEXception,SQLException,SocketException；</p></li><li><p>运行时异常 ：是程序运行时发错误，例如除 0 会引发 Arithmetic [əˈrɪθmətɪk] Exception，此时程序崩溃并且无法恢复，RuntimeException及其子类。如IndexOutOfBounds ,ArrayIndexOutOfBounds </p></li></ul><img src="/2020/07/02/Error%E5%92%8CException/1.png" class title="如图">]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDK和JRE</title>
      <link href="/2020/07/02/JDK%E5%92%8CJRE/"/>
      <url>/2020/07/02/JDK%E5%92%8CJRE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>JDK（Java Development Kit）：是 Java 开发工具包，，包括了 JRE、Java 工具(比如一些编译调试工具)和 Java 基础类库。</p><p>JRE（ Java Runtime Environment）：是 Java 的运行环境，包含 <strong>JVM 标准实现及 Java 核心类库</strong>。</p><p>(JDK同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。)</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>B树、B+树、红黑树</title>
      <link href="/2020/07/01/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2020/07/01/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="B树与B-树的区别？"><a href="#B树与B-树的区别？" class="headerlink" title="B树与B+树的区别？"></a>B树与B+树的区别？</h2><ol><li><p>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为页的大小是固定的，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。 </p></li><li><p>因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。</p></li></ol><h2 id="B-树与红黑树的区别？"><a href="#B-树与红黑树的区别？" class="headerlink" title="B+树与红黑树的区别？"></a>B+树与红黑树的区别？</h2><p>但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个</p><p>原因</p><p>（一）更少的查找次数</p><p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。</p><p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p><p>（二）利用磁盘预读特性</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h2 id="为什么说红黑树没能充分利用磁盘预读功能"><a href="#为什么说红黑树没能充分利用磁盘预读功能" class="headerlink" title="为什么说红黑树没能充分利用磁盘预读功能?"></a>为什么说红黑树没能充分利用磁盘预读功能?</h2><p>红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。<br>也就是说，使用红黑树（平衡二叉树）结构的话，每次磁盘预读中的很多数据是用不上的数据。因此，它没能利用好磁盘预读的提供的数据。然后又由于深度大（较B树而言），所以进行的磁盘IO操作更多。</p><h3 id="redis为什么采用跳表而不是红黑树？？"><a href="#redis为什么采用跳表而不是红黑树？？" class="headerlink" title="redis为什么采用跳表而不是红黑树？？"></a>redis为什么采用跳表而不是红黑树？？</h3><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。<br>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。<br>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。<br>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。<br>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现阻塞队列</title>
      <link href="/2020/07/01/%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
      <url>/2020/07/01/%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-什么是阻塞队列？"><a href="#1-什么是阻塞队列？" class="headerlink" title="1. 什么是阻塞队列？"></a>1. 什么是阻塞队列？</h2><p><strong>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</strong>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><h2 id="2-相关方法"><a href="#2-相关方法" class="headerlink" title="2.相关方法"></a>2.相关方法</h2><p>两个锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notFull</span><br><span class="line">notEmpty</span><br></pre></td></tr></table></figure><p>put方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;add方法实现，间接调用了offer(e)</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        if (offer(e))</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;offer方法</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">     checkNotNull(e);&#x2F;&#x2F;检查元素是否为null</span><br><span class="line">     final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">     lock.lock();&#x2F;&#x2F;加锁</span><br><span class="line">     try &#123;</span><br><span class="line">         if (count &#x3D;&#x3D; items.length)&#x2F;&#x2F;判断队列是否满</span><br><span class="line">             return false;</span><br><span class="line">         else &#123;</span><br><span class="line">             enqueue(e);&#x2F;&#x2F;添加元素到队列</span><br><span class="line">             return true;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;入队操作</span><br><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前数组</span><br><span class="line">    final Object[] items &#x3D; this.items;</span><br><span class="line">    &#x2F;&#x2F;通过putIndex索引对数组进行赋值</span><br><span class="line">    items[putIndex] &#x3D; x;</span><br><span class="line">    &#x2F;&#x2F;索引自增，如果已是最后一个位置，重新设置 putIndex &#x3D; 0;</span><br><span class="line">    if (++putIndex &#x3D;&#x3D; items.length)</span><br><span class="line">        putIndex &#x3D; 0;</span><br><span class="line">    count++;&#x2F;&#x2F;队列中元素数量加1</span><br><span class="line">    &#x2F;&#x2F;唤醒调用take()方法的线程，执行元素获取操作。</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的add方法和offer方法实现比较简单，其中需要注意的是enqueue(E x)方法，其方法内部通过putIndex索引直接将元素添加到数组items中，这里可能会疑惑的是当putIndex索引大小等于数组长度时，需要将putIndex重新设置为0，这是因为当前队列执行元素获取时总是从队列头部获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">checkNotNull(e); <span class="comment">// 不允许元素为空</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">lock.lockInterruptibly(); <span class="comment">// 加锁，保证调用put方法的时候只有1个线程</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (count == items.length) <span class="comment">// 如果队列满了，阻塞当前线程，while用来防止假唤醒</span></span><br><span class="line">notFull.await(); <span class="comment">// 线程阻塞并被挂起，同时释放锁</span></span><br><span class="line">insert(e); <span class="comment">// 调用insert方法</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock(); <span class="comment">// 释放锁，让其他线程可以调用put方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法是一个阻塞的方法，如果队列元素已满，那么当前线程将会被notFull条件对象挂起加到等待队列中，直到队列有空档才会唤醒执行添加操作。但如果队列没有满，那么就直接调用enqueue(e)方法将元素加入到数组队列中。到此我们对三个添加方法即put，offer，add都分析完毕，其中offer，add在正常情况下都是无阻塞的添加，而put方法是阻塞添加。<br>————————————————</p><p>删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//判断队列是否为null，不为null执行dequeue()方法，否则返回null</span></span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//删除队列头元素并返回</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//拿到当前数组的数据</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="comment">//获取要删除的对象</span></span><br><span class="line">      E x = (E) items[takeIndex];</span><br><span class="line">      将数组中takeIndex索引位置设置为<span class="keyword">null</span></span><br><span class="line">      items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//takeIndex索引加1并判断是否与数组长度相等，</span></span><br><span class="line">      <span class="comment">//如果相等说明已到尽头，恢复为0</span></span><br><span class="line">      <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">          takeIndex = <span class="number">0</span>;</span><br><span class="line">      count--;<span class="comment">//队列个数减1</span></span><br><span class="line">      <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">          itrs.elementDequeued();<span class="comment">//同时更新迭代器中的元素数据</span></span><br><span class="line">      <span class="comment">//删除了元素说明队列有空位，唤醒notFull条件对象添加线程，执行添加操作</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手撕代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS是什么?</title>
      <link href="/2020/07/01/AQS%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/01/AQS%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>AQS全称是AbstractQueuedSynchronizer，即抽象同步队列。下面看一下AQS的类图结构：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/21/16c151e53fa38334?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>为了方便下面几个关键点的理解，大家先<strong>熟悉一下AQS的类图结构</strong>。</p><p>AQS 队列同步器是<strong>用来构建锁或其他同步组件的基础框架</strong>，它使用一个 volatile int state 变量作为共享资源。如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。</p><p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，对同步状态进行更改需要使用同步器提供的 3个方法 <code>getState</code>、<code>setState</code> 和 <code>compareAndSetState</code> ，它们保证状态改变是安全的。</p><h2 id="state-状态的维护"><a href="#state-状态的维护" class="headerlink" title="state 状态的维护"></a>state 状态的维护</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在AQS中维持了一个单一的共享状态state，来实现同步器同步。看一下state的相关代码如下：</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="state源码"><a href="#state源码" class="headerlink" title="state源码"></a>state源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line">   * The synchronization state.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private volatile int state;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Returns the current value of synchronization state.</span><br><span class="line">   * This operation has memory semantics of a &#123;@code volatile&#125; read.</span><br><span class="line">   * @return current state value</span><br><span class="line">   *&#x2F;</span><br><span class="line">  protected final int getState() &#123;</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Sets the value of synchronization state.</span><br><span class="line">   * This operation has memory semantics of a &#123;@code volatile&#125; write.</span><br><span class="line">   * @param newState the new state value</span><br><span class="line">   *&#x2F;</span><br><span class="line">  protected final void setState(int newState) &#123;</span><br><span class="line">      state &#x3D; newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Atomically sets synchronization state to the given updated</span><br><span class="line">   * value if the current state value equals the expected value.</span><br><span class="line">   * This operation has memory semantics of a &#123;@code volatile&#125; read</span><br><span class="line">   * and write.</span><br><span class="line">   *</span><br><span class="line">   * @param expect the expected value</span><br><span class="line">   * @param update the new value</span><br><span class="line">   * @return &#123;@code true&#125; if successful. False return indicates that the actual</span><br><span class="line">   *         value was not equal to the expected value.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">      &#x2F;&#x2F; See below for intrinsics setup to support this</span><br><span class="line">      return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="state-源码设计几个回答要点："><a href="#state-源码设计几个回答要点：" class="headerlink" title="state 源码设计几个回答要点："></a>state 源码设计几个回答要点：</h3><ul><li>state用volatile修饰，保证多线程中的可见性。</li><li>getState()和setState()方法采用final修饰，限制AQS的子类重写它们两。</li><li>compareAndSetState（）方法采用乐观锁思想的CAS算法，也是采用final修饰的，不允许子类重写。</li></ul><h2 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h2><p>谈到CLH队列，我们结合以上state状态，先来看一下<strong>AQS原理图</strong>：</p><img src="/2020/07/01/AQS%E6%98%AF%E4%BB%80%E4%B9%88/1.jpg" class title="this is AQS"><p>CLH(Craig, Landin, and Hagersten locks) 同步队列 是一个FIFO双向队列，其内部通过节点head和tail记录队首和队尾元素，队列元素的类型为Node。</p><p><strong>AQS依赖它来完成同步状态state的管理，当前线程如果获取同步状态失败时，AQS则会调用addWaiter方法，CAS的方式将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程</strong>，<strong>CAS设置失败会采用死循环的方式</strong>。当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><p>CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），condition队列的后续节点（nextWaiter）如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/31/16c4545ea0b027b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>waitStatus几种状态状态：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/7/31/16c454d3d62d9108?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>我们再看一下CLH队列入列以及出列的代码：</p><h3 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h3><p>CLH队列入列就是<strong>tail指向新节点、新节点的prev指向当前最后的节点，当前最后一个节点的next指向当前节点</strong>。addWaiter方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造Node</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">  Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">        &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure（快速尝试添加尾节点）</span><br><span class="line">        Node pred &#x3D; tail;</span><br><span class="line">        if (pred !&#x3D; null) &#123;</span><br><span class="line">            node.prev &#x3D; pred;</span><br><span class="line">            &#x2F;&#x2F;CAS设置尾节点</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next &#x3D; node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;多次尝试</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>由以上代码可得，addWaiter设置尾节点失败的话，调用enq(Node node)方法设置尾节点，enq方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   private Node enq(final Node node) &#123;</span><br><span class="line">        &#x2F;&#x2F;死循环尝试，知道成功为止</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node t &#x3D; tail;</span><br><span class="line">            &#x2F;&#x2F;tail 不存在，设置为首节点</span><br><span class="line">            if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    tail &#x3D; head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node.prev &#x3D; t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next &#x3D; node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="出列"><a href="#出列" class="headerlink" title="出列"></a>出列</h3><p>首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点。可以看一下以下两段源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  Node h &#x3D; head;</span><br><span class="line">  if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">  unparkSuccessor(h);</span><br><span class="line">复制代码</span><br><span class="line"> private void unparkSuccessor(Node node) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">         * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">         * fails or if status is changed by waiting thread.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int ws &#x3D; node.waitStatus;</span><br><span class="line">        if (ws &lt; 0)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Thread to unpark is held in successor, which is normally</span><br><span class="line">         * just the next node.  But if cancelled or apparently null,</span><br><span class="line">         * traverse backwards from tail to find the actual</span><br><span class="line">         * non-cancelled successor.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Node s &#x3D; node.next;</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">            s &#x3D; null;</span><br><span class="line">            for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">                if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                    s &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s !&#x3D; null)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="CLH核心几个回答要点"><a href="#CLH核心几个回答要点" class="headerlink" title="CLH核心几个回答要点"></a>CLH核心几个回答要点</h3><ul><li>双向链表入列出列</li><li>CAS算法设置尾节点+死循环自旋。</li></ul><p><strong>CAS算法，可以看一下我工作实战中仿造CAS算法解决并发问题的实现</strong> <a href="https://juejin.im/post/5d0616ade51d457756536791" target="_blank" rel="noopener">juejin.im/post/5d0616…</a></p><h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2><h3 id="ConditionObject简介"><a href="#ConditionObject简介" class="headerlink" title="ConditionObject简介"></a>ConditionObject简介</h3><p>我们都知道，synchronized控制同步的时候，可以配合<strong>Object的wait()、notify()，notifyAll()</strong> 系列方法可以实现等待/通知模式。而Lock呢？它提供了条件Condition接口，配合<strong>await(),signal(),signalAll()</strong> 等方法也可以实现等待/通知机制。<strong>ConditionObject实现了Condition接口</strong>，给AQS提供<strong>条件变量的支持</strong> 。</p><h3 id="Condition队列与CLH队列的那些事"><a href="#Condition队列与CLH队列的那些事" class="headerlink" title="Condition队列与CLH队列的那些事"></a>Condition队列与CLH队列的那些事</h3><p>我们先来看一下图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/30/16c4214fad310ccf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>ConditionObject队列与CLH队列的爱恨情仇：</strong></p><ul><li>调用了await()方法的线程，会被加入到conditionObject等待队列中，并且唤醒CLH队列中head节点的下一个节点。</li><li>线程在某个ConditionObject对象上调用了singnal()方法后，等待队列中的firstWaiter会被加入到AQS的CLH队列中，等待被唤醒。</li><li>当线程调用unLock()方法释放锁时，CLH队列中的head节点的下一个节点(在本例中是firtWaiter)，会被唤醒。</li></ul><p><strong>区别：</strong></p><ul><li>ConditionObject对象都维护了一个单独的<strong>等待队列</strong> ，AQS所维护的CLH队列是<strong>同步队列</strong>，它们节点类型相同，都是Node。</li></ul><h2 id="独占与共享模式。"><a href="#独占与共享模式。" class="headerlink" title="独占与共享模式。"></a>独占与共享模式。</h2><p>AQS支持两种同步模式:独占式和共享式。</p><ul><li><p>Exclusive</p><p>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><p><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p></li></ul><p><strong>独占模式</strong>表示锁只会被一个线程占用，其他线程必须等到持有锁的线程释放锁后才能获取锁，同一时间只能有一个线程获取到锁。</p><p><strong>共享模式</strong>表示多个线程获取同一个锁有可能成功</p><p>独占模式通过 acquire 和 release 方法获取和释放锁，共享模式通过 acquireShared 和 releaseShared</p><p><img src="https://img-blog.csdnimg.cn/20200305231339850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxaW50ZXJuZXQ=,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200305231413792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxaW50ZXJuZXQ=,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h3><p>获取同步状态时，调用 <code>acquire</code> 方法，维护一个同步队列，使用 <code>tryAcquire</code> 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 <code>addWaiter</code> 方法加入到同步队列的尾部，在队列中自旋。之后调用 <code>acquireQueued</code> 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞，被阻塞线程的唤醒主要依靠前驱节点的出队或被中断实现，移出队列或停止自旋的条件是前驱节点是头结点且成功获取了同步状态。</p><p>释放同步状态时，同步器调用 <code>tryRelease</code> 方法释放同步状态，然后调用 <code>unparkSuccessor</code> 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。</p><p>同一时刻仅有一个线程持有同步状态，如<strong>ReentrantLock</strong>。又可分为公平锁和非公平锁。</p><p><strong>公平锁：</strong> 按照线程在队列中的排队顺序，有礼貌的，先到者先拿到锁。</p><p><strong>非公平锁：</strong> 当线程要获取锁时，无视队列顺序直接去抢锁，不讲道理的，谁抢到就是谁的。</p><p><strong>acquire(int arg)是独占式获取同步状态的方法</strong>，我们来看一下源码：</p><ul><li><strong>acquire(long arg)方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  public final void acquire(long arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>addWaiter方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造Node</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">  Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">        &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure（快速尝试添加尾节点）</span><br><span class="line">        Node pred &#x3D; tail;</span><br><span class="line">        if (pred !&#x3D; null) &#123;</span><br><span class="line">            node.prev &#x3D; pred;</span><br><span class="line">            &#x2F;&#x2F;CAS设置尾节点</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next &#x3D; node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;多次尝试</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>acquireQueued(final Node node, long arg)方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> final boolean acquireQueued(final Node node, long arg) &#123;</span><br><span class="line">        boolean failed &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted &#x3D; false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p &#x3D; node.predecessor();</span><br><span class="line">                if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>selfInterrupt()方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">     Thread.currentThread().interrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>结合源代码，可得acquire(int arg)方法流程图，如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/30/16c42890d2ec5e01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h3><p>多个线程可同时执行，如Semaphore/CountDownLatch等都是共享式的产物。</p><p>获取同步状态时，调用 <code>acquireShared</code> 方法，该方法调用 <code>tryAcquireShared</code> 方法尝试获取同步状态，返回值为 int 类型，返回值不小于于 0 表示能获取同步状态。因此在共享式获取锁的自旋过程中，成功获取同步状态并退出自旋的条件就是该方法的返回值不小于0。</p><p>释放同步状态时，调用 <code>releaseShared</code> 方法，释放后会唤醒后续处于等待状态的节点。它和独占式的区别在于 <code>tryReleaseShared</code> 方法必须确保同步状态安全释放，通过循环 CAS 保证，因为释放同步状态的操作会同时来自多个线程。</p><p><strong>acquireShared(long arg)是共享式获取同步状态的方法</strong>，可以看一下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  public final void acquireShared(long arg) &#123;</span><br><span class="line">        if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>由上可得，先调用tryAcquireShared(int arg)方法尝试获取同步状态，如果获取失败，调用<strong>doAcquireShared(int arg)自旋方式获取同步状态</strong>，方法源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> private void doAcquireShared(long arg) &#123;</span><br><span class="line">        final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">        boolean failed &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted &#x3D; false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p &#x3D; node.predecessor();</span><br><span class="line">                if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                    long r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                        if (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed &#x3D; false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><a href="https://www.javadoop.com/" target="_blank" rel="noopener">https://www.javadoop.com/</a></p><h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><p>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）<br>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。<br>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p><p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">isHeldExclusively()&#x2F;&#x2F;该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">tryAcquire(int)&#x2F;&#x2F;独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br><span class="line">tryRelease(int)&#x2F;&#x2F;独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br><span class="line">tryAcquireShared(int)&#x2F;&#x2F;共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">tryReleaseShared(int)&#x2F;&#x2F;共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p><p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2 id="自定义同步器。"><a href="#自定义同步器。" class="headerlink" title="自定义同步器。"></a>自定义同步器。</h2><p>基于以上分析，我们都知道<strong>state，CLH队列，ConditionObject队列</strong> 等这些关键点，你要实现自定义锁的话，首先需要确定你要实现的是<strong>独占锁还是共享锁，定义原子变量state的含义，再定义一个内部类去继承AQS，重写对应的模板方法</strong>。</p><p>我们来看一下基于 AQS 实现的不可重入的独占锁的demo，来自《Java并发编程之美》：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class NonReentrantLock implements Lock,Serializable&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;内部类,自定义同步器</span><br><span class="line">    static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        &#x2F;&#x2F;是否锁已经被持有</span><br><span class="line">        public boolean isHeldExclusively() &#123;</span><br><span class="line">            return getState() &#x3D;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果state为0 则尝试获取锁</span><br><span class="line">        public boolean tryAcquire(int arg) &#123;</span><br><span class="line">            assert arg&#x3D;&#x3D; 1 ;</span><br><span class="line">            &#x2F;&#x2F;CAS设置状态,能保证操作的原子性，当前为状态为0,操作成功状态改为1</span><br><span class="line">            if(compareAndSetState(0, 1))&#123;</span><br><span class="line">                &#x2F;&#x2F;设置当前独占的线程</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;尝试释放锁，设置state为0</span><br><span class="line">        public boolean tryRelease(int arg) &#123;</span><br><span class="line">            assert arg &#x3D;&#x3D;1;</span><br><span class="line">            &#x2F;&#x2F;如果同步器同步器状态等于0,则抛出监视器非法状态异常</span><br><span class="line">            if(getState() &#x3D;&#x3D; 0)</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#x2F;&#x2F;设置独占锁的线程为null</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            &#x2F;&#x2F;设置同步状态为0</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回Condition,每个Condition都包含了一个Condition队列</span><br><span class="line">        Condition newCondition()&#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个Sync来做具体的工作</span><br><span class="line">    private final Sync sync&#x3D; new Sync ();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isLocked() &#123;</span><br><span class="line">        return sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">        @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>NonReentrantLockDemoTest:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class NonReentrantLockDemoTest &#123;</span><br><span class="line"></span><br><span class="line">    private static NonReentrantLock nonReentrantLock &#x3D; new NonReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                nonReentrantLock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    nonReentrantLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/31/16c45d2d8320a2c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>作者：Jay_huaxiao<br>链接：<a href="https://juejin.im/post/5d34502cf265da1baf7d27aa" target="_blank" rel="noopener">https://juejin.im/post/5d34502cf265da1baf7d27aa</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Lock lock&#x3D;new ReentrantLock();</span><br><span class="line">        Condition a&#x3D;lock.newCondition();</span><br><span class="line">        Thread t1&#x3D;new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">             lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;wo shi t1 aaa&quot;);</span><br><span class="line"></span><br><span class="line">                    a.signal();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2&#x3D;new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;wo shi t2 &quot;);</span><br><span class="line">                    a.await();</span><br><span class="line">                    System.out.println(&quot;wo shi t2 aaaa&quot;);</span><br><span class="line"></span><br><span class="line">                    a.signal();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t3&#x3D;new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">&#x2F;&#x2F;                    Thread.sleep(2000);</span><br><span class="line">                    System.out.println(&quot;wo shi t3&quot;);</span><br><span class="line">                    a.await();</span><br><span class="line">                    System.out.println(&quot;wo shi t3 aaaa&quot;);</span><br><span class="line">                    a.signal();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class MyLock implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    private Helper helper&#x3D;new Helper();</span><br><span class="line"></span><br><span class="line">    private class Helper extends AbstractQueuedSynchronizer&#123;</span><br><span class="line">        &#x2F;&#x2F;获取锁</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">            int state&#x3D;getState();</span><br><span class="line">            if(state&#x3D;&#x3D;0)&#123;</span><br><span class="line">                &#x2F;&#x2F;利用CAS原理修改state</span><br><span class="line">                if(compareAndSetState(0,arg))&#123;</span><br><span class="line">                    &#x2F;&#x2F;设置当前线程占有资源</span><br><span class="line">                    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(getExclusiveOwnerThread()&#x3D;&#x3D;Thread.currentThread())&#123;</span><br><span class="line">                setState(getState()+arg);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;释放锁</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryRelease(int arg) &#123;</span><br><span class="line">            int state&#x3D;getState()-arg;</span><br><span class="line">            boolean flag&#x3D;false;</span><br><span class="line">            &#x2F;&#x2F;判断释放后是否为0</span><br><span class="line">            if(state&#x3D;&#x3D;0)&#123;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">                setState(state);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            setState(state);&#x2F;&#x2F;存在线程安全吗？重入性的问题，当前已经独占了资源()state</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Condition newConditionObjecct()&#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        helper.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        helper.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return helper.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return helper.tryAcquireNanos(1,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        helper.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return helper.newConditionObjecct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cookie和Session剖析</title>
      <link href="/2020/06/30/Cookie%E5%92%8CSession%E5%89%96%E6%9E%90/"/>
      <url>/2020/06/30/Cookie%E5%92%8CSession%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="为什么要有Cookie？"><a href="#为什么要有Cookie？" class="headerlink" title="为什么要有Cookie？"></a>为什么要有Cookie？</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来</p><p>保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上</p><p>用途：</p><p>· 会话状态管理（如用户登录状态、购物车）</p><p>· 浏览器行为跟踪（如跟踪分析用户行为等）</p><h2 id="Cookie创建过程？"><a href="#Cookie创建过程？" class="headerlink" title="Cookie创建过程？"></a>Cookie创建过程？</h2><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务<br>器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><h2 id="Cookie分类"><a href="#Cookie分类" class="headerlink" title="Cookie分类"></a>Cookie分类</h2><p>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</p><p>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session?"></a>Session?</h2><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p><strong>session 认证流程：</strong></p><ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul><p><strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong></p><p>在对安全性要求极高的场景下，例如转账等操作，除了使用 Session管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h2 id="Session和Cookie区别？"><a href="#Session和Cookie区别？" class="headerlink" title="Session和Cookie区别？"></a>Session和Cookie区别？</h2><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选<br>Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加<br>密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信<br>息都存储到 Session 中。</li></ul><h2 id="Cookie和Session的选择？"><a href="#Cookie和Session的选择？" class="headerlink" title="Cookie和Session的选择？"></a>Cookie和Session的选择？</h2><ol><li><p>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session；</p></li><li><p>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</p></li><li><p>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</p></li></ol><h2 id="Cookie的不可跨域名性？"><a href="#Cookie的不可跨域名性？" class="headerlink" title="Cookie的不可跨域名性？"></a>Cookie的不可跨域名性？</h2><p>一个cookie只能用于一个域名(有效的二级域名，比如 shop.com)，不能够发给其它的域名。Cookie跨域指的是允许不同的二级域名间共享</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token?"></a>Token?</h2><ol><li>把用户的用户名和密码发到后端</li><li>后端进行校验，校验成功会生成token, 把token发送给客户端</li><li>客户端自己保存token, 再次请求就要在Http协议的请求头中带着token去访问服务端，和在服务端保存的token信息进行比对校验。</li></ol><ul><li><strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</strong></li><li><strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</strong></li><li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/29/16f523a04d9c745f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h2><ul><li><p>Session 是一种<strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息</strong>。而 Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></p></li><li><p>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。<strong>如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</strong></p></li><li><p>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。</p></li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><p>JWT 的 Header 通常包含两个字段，分别是：typ(type) 和 alg(algorithm)。</p><ul><li>typ：token的类型，这里固定为 JWT</li><li>alg：使用的 hash 算法，例如：HMAC SHA256 或者 RSA</li></ul><p>一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对他进行编码后是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; base64.b64encode(json.dumps(&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;))</span><br><span class="line">&#39;eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9&#39;</span><br></pre></td></tr></table></figure><h5 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h5><p>JWT 中的 Payload 其实就是真实存储我们需要传递的信息的部分，例如正常我们会存储些用户 ID、用户名之类的。此外，还包含一些例如发布人、过期日期等的元数据。</p><p>但是，这部分和 Header 部分不一样的地方在于这个地方可以加密，而不是简单得直接进行 BASE64 编码。但是这里我为了解释方便就直接使用 BASE64 编码，需要注意的是，这里的 BASE64 编码稍微有点不一样，切确得说应该是 Base64UrlEncoder，和 Base64 编码的区别在于会忽略最后的 padding（=号），然后 ‘-‘ 会被替换成’_’。</p><p>举个例子，例如我们的 Payload 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;user_id&quot;:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure><p>那么直接 Base64 的话应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; base64.urlsafe_b64encode(&#39;&#123;&quot;user_id&quot;:&quot;zhangsan&quot;&#125;&#39;)</span><br><span class="line">&#39;eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ&#x3D;&#x3D;&#39;</span><br></pre></td></tr></table></figure><p>然后去掉 = 号，最后应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ&#39;</span><br></pre></td></tr></table></figure><h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>Signature 部分其实就是对我们前面的 Header 和 Payload 部分进行签名，保证 Token 在传输的过程中没有被篡改或者损坏，签名的算法也很简单，但是，为了加密，所以除了 Header 和 Payload 之外，还多了一个密钥字段，完整算法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    Signature &#x3D; HMACSHA256(</span><br><span class="line">        base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">        base64UrlEncode(payload),</span><br><span class="line">        secret)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>还是以前面的例子为例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    base64UrlEncode(header)  &#x3D;》 eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9</span><br><span class="line">    base64UrlEncode(payload) &#x3D;》 eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>secret 就设为：”secret”, 那最后出来的签名应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    &gt;&gt;&gt; import hmac</span><br><span class="line">    &gt;&gt;&gt; import hashlib</span><br><span class="line">    &gt;&gt;&gt; import base64</span><br><span class="line">    &gt;&gt;&gt; dig &#x3D; hmac.new(&#39;secret&#39;,     &gt;&gt;&gt; msg&#x3D;&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ&quot;, </span><br><span class="line">               digestmod&#x3D;</span><br><span class="line">    &gt;&gt;&gt; base64.b64encode(dig.digest())</span><br><span class="line">    &#39;ec7IVPU-ePtbdkb85IRnK4t4nUVvF2bBf8fGhJmEwSs&#x3D;&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>将上面三个部分组装起来就组成了我们的 JWT token了，所以我们的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#123;&#39;user_id&#39;: &#39;zhangsan&#39;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>的 token 就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ.ec7IVPU-ePtbdkb85IRnK4t4nUVvF2bBf8fGhJmEwSs</span><br></pre></td></tr></table></figure><ol><li><p>在头部信息中声明加密算法和常量， 然后把header使用json转化为字符串</p></li><li><p>在载荷中声明用户信息，同时还有一些其他的内容；再次使用json 把载荷部分进行转化，转化为字符串</p></li><li><p>使用在header中声明的加密算法和每个项目随机生成的secret来进行加密， 把第一步分字符串和第二部分的字符串进行加密， 生成新的字符串。词字符串是独一无二的。</p></li><li><p>解密的时候，只要客户端带着JWT来发起请求，服务端就直接使用secret进行解密。</p></li></ol><h2 id="JWT与token的联系"><a href="#JWT与token的联系" class="headerlink" title="JWT与token的联系"></a>JWT与token的联系</h2><p>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</p><p>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用的状态码</title>
      <link href="/2020/06/30/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2020/06/30/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>{asset_img 1.png 表格}</p><ul><li><p>200：一切正常</p></li><li><p>204 No content：一切正常，但响应头后没有 body 数据</p></li><li><p>206：这种响应是在客户端表明自己只需要目标URL上的部分资源的时候返回的.这种情况经常发生在客户端继续请求一个未完成的下载的时候</p></li></ul><p>​      (状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range:       bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。)</p><ul><li><p>301：永久性重定向</p></li><li><p>302：临时重定向</p><p>301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI</p></li><li><p>303：跟302相似，只是对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI</p></li><li><p>304：“304 Not Modified”，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。</p></li><li><p>307：临时重定向，与302类似，只是强制要求使用POST方法</p></li><li><p>400  Bad Request：请求报文语法有误，服务器无法识别</p></li><li><p>401：请求需要认证</p></li><li><p>403 Forbidden：请求的对应资源禁止被访问</p></li><li><p>404 Not Found：服务器无法找到对应资源</p></li><li><p>500 Internal Server Error：服务器内部错误</p></li><li><p>“502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</p></li><li><p>503 Service Unavailable：服务器正忙</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是DHCP以及DHCP是怎么工作的</title>
      <link href="/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFDHCP%E4%BB%A5%E5%8F%8ADHCP%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
      <url>/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFDHCP%E4%BB%A5%E5%8F%8ADHCP%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p><strong>DHCP (Dynamic Host Configuration Protocol) 动态主机配置协议提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信</strong></p><p><strong>息。</strong></p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><ol><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP</li></ol><p>中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继</p><p>代理。</p><ol start="2"><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客</li></ol><p>户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是TCP粘包</title>
      <link href="/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFTCP%E7%B2%98%E5%8C%85/"/>
      <url>/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFTCP%E7%B2%98%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>原因可能是发送方也可能是接收方造成的。</p><p>发送方原因：TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</p><p>接收方原因：TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。</p><h2 id="处理方法："><a href="#处理方法：" class="headerlink" title="处理方法："></a>处理方法：</h2><p>1.发送方关闭Nagle算法。</p><p>2.接收方：接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层循环读取所有的数据，根据报文的长度判断每个包开始和结束的位置。</p><p>分包机制一般有两个通用的解决方法：</p><ol><li><p>特殊字符控制；</p></li><li><p>在包头首都添加数据包的长度</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP和UDP传输的报文段和用户数据报的差异</title>
      <link href="/2020/06/30/TCP%E5%92%8CUDP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
      <url>/2020/06/30/TCP%E5%92%8CUDP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><img src="/2020/06/30/TCP%E5%92%8CUDP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%AE%E5%BC%82/1.png" class title="TCP"><p>16位源端口号+16位目的端口号+32位序号+32位确认号+4位头部长度（单位4字节）+6位保留+6个关键字（SYN,ACK，FIN）+16位窗口大小（指接收窗口）+16位校验和+16位紧急指针+最多40字节的选项；</p><img src="/2020/06/30/TCP%E5%92%8CUDP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%AE%E5%BC%82/2.png" class title="UDP"><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是CSMA/CD</title>
      <link href="/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFCSMA-CD/"/>
      <url>/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFCSMA-CD/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><p>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</p></li><li><p>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</p></li><li><p>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</p></li></ul><p>记端到端的传播时延为 t，最先发送的站点最多经过 2t就可以知道是否发生了碰撞，称 2t 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2^k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引相关疑问</title>
      <link href="/2020/06/30/%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E7%96%91%E9%97%AE/"/>
      <url>/2020/06/30/%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E7%96%91%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/24/1710a4ae8e0c0464?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="创立索引的语句"><a href="#创立索引的语句" class="headerlink" title="创立索引的语句"></a>创立索引的语句</h2><p>1.添加PRIMARY KEY（主键索引）<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD PRIMARY KEY ( <code>column</code> )<br>2.添加UNIQUE(唯一索引)<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD UNIQUE (<br><code>column</code><br>)<br>3.添加INDEX(普通索引)<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column</code> )<br>4.添加FULLTEXT(全文索引)<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD FULLTEXT ( <code>column</code>)<br>5.添加多列索引<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column1</code>, <code>column2</code>, <code>column3</code> )</p><h2 id="索引为abc且查询条件为a-xxx-order-by-b时能用上哪个索引？"><a href="#索引为abc且查询条件为a-xxx-order-by-b时能用上哪个索引？" class="headerlink" title="索引为abc且查询条件为a=xxx order by b时能用上哪个索引？"></a>索引为abc且查询条件为a=xxx order by b时能用上哪个索引？</h2><h2 id="为什么是最左匹配"><a href="#为什么是最左匹配" class="headerlink" title="为什么是最左匹配"></a>为什么是最左匹配</h2><p><img src="https://img-blog.csdnimg.cn/20190401113210176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxOTE3MTA5,size_16,color_FFFFFF,t_70" alt="img"></p><p>1.简单说下什么是最左匹配原则<br>顾名思义：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。<br>例如：b = 2 如果建立(a,b)顺序的索引，是匹配不到(a,b)索引的；但是如果查询条件是a = 1 and b = 2或者a=1(又或者是b = 2 and b = 1)就可以，因为优化器会自动调整a,b的顺序。再比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。</p><p>2.最左匹配原则的原理<br>最左匹配原则都是针对联合索引来说的，所以我们有必要了解一下联合索引的原理。了解了联合索引，那么为什么会有最左匹配原则这种说法也就理解了。</p><p>我们都知道索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。<br>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的</p><p><img src="https://img2018.cnblogs.com/blog/1281680/201901/1281680-20190117145740508-758737271.png" alt="img"><br>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p><p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a&gt;1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p><h2 id="查询在什么时候不走（预期中的）索引"><a href="#查询在什么时候不走（预期中的）索引" class="headerlink" title="查询在什么时候不走（预期中的）索引?"></a>查询在什么时候不走（预期中的）索引?</h2><h2 id="order-by原理？"><a href="#order-by原理？" class="headerlink" title="order by原理？"></a>order by原理？</h2><h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><p>1.有or必全有索引;<br>2.复合索引未用左列字段;<br>3.like以%开头;<br>4.where中索引列有运算;<br>5.where中索引列使用了函数;<br>6.如果mysql觉得全表扫描更快时（数据少）</p><h2 id="索引有哪几种"><a href="#索引有哪几种" class="headerlink" title="索引有哪几种"></a>索引有哪几种</h2><ol><li><p>B+Tree 索引</p></li><li><p>哈希索引</p><p>存储引擎对所有的索引列计算出一个哈希码，哈希码索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p></li><li><p>全文索引</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create fulltext index content_tag_fulltext</span><br><span class="line">    on fulltext_test(content,tag);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from fulltext_test </span><br><span class="line">    where match(content,tag) against(&#39;xxx xxx&#39;);</span><br></pre></td></tr></table></figure></li><li><p>空间数据索引</p></li></ol><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>联合索引是指对表上的多个列进行索引，联合索引也是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2.</p><p><img src="https://img-blog.csdn.net/20180807153551287?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtMTA2MDg5MTI2NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h2 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h2><p>顾名思义是最左优先，以最左边的为起点任何连续的索引都能匹配上.(A,B,C) 这样3列，mysql会首先匹配A，然后再B，C.</p><p>如果用(B,C)这样的数据来检索的话，就会找不到A使得索引失效。</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引包含所有需要查询的字段的值,不需要回表操作。<br>具有以下优点：<br>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。<br>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以<br>不使用系统调用（通常比较费时）。<br>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</p><h2 id="什么情况下不应该用索引？"><a href="#什么情况下不应该用索引？" class="headerlink" title="什么情况下不应该用索引？"></a>什么情况下不应该用索引？</h2><h4 id="1-被频繁更新的字段应该慎重建立索引"><a href="#1-被频繁更新的字段应该慎重建立索引" class="headerlink" title="1.被频繁更新的字段应该慎重建立索引"></a>1.被频繁更新的字段应该慎重建立索引</h4><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><h4 id="2-不被经常查询的字段没有必要建立索引"><a href="#2-不被经常查询的字段没有必要建立索引" class="headerlink" title="2.不被经常查询的字段没有必要建立索引"></a>2.不被经常查询的字段没有必要建立索引</h4><h4 id="3-尽可能的考虑建立联合索引而不是单列索引"><a href="#3-尽可能的考虑建立联合索引而不是单列索引" class="headerlink" title="3.尽可能的考虑建立联合索引而不是单列索引"></a>3.尽可能的考虑建立联合索引而不是单列索引</h4><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p><h4 id="4-注意避免冗余索引"><a href="#4-注意避免冗余索引" class="headerlink" title="4.注意避免冗余索引"></a>4.注意避免冗余索引</h4><p>冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><h4 id="5-考虑在字符串类型的字段上使用前缀索引代替普通索引"><a href="#5-考虑在字符串类型的字段上使用前缀索引代替普通索引" class="headerlink" title="5.考虑在字符串类型的字段上使用前缀索引代替普通索引"></a>5.考虑在字符串类型的字段上使用前缀索引代替普通索引</h4><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p><h2 id="适合创建索引条件"><a href="#适合创建索引条件" class="headerlink" title="适合创建索引条件"></a>适合创建索引条件</h2><h4 id="1-不为NULL的字段"><a href="#1-不为NULL的字段" class="headerlink" title="1.不为NULL的字段"></a>1.不为NULL的字段</h4><p>索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为NULL，建议使用0,1,true,false这样语义较为清晰的短值或短字符作为替代。</p><h4 id="2-被频繁查询的字段"><a href="#2-被频繁查询的字段" class="headerlink" title="2.被频繁查询的字段"></a>2.被频繁查询的字段</h4><p>我们创建索引的字段应该是查询操作非常频繁的字段。</p><h4 id="3-被作为条件查询的字段"><a href="#3-被作为条件查询的字段" class="headerlink" title="3.被作为条件查询的字段"></a>3.被作为条件查询的字段</h4><p>被作为WHERE条件查询的字段，应该被考虑建立索引。</p><h4 id="4-被经常频繁用于连接的字段"><a href="#4-被经常频繁用于连接的字段" class="headerlink" title="4.被经常频繁用于连接的字段"></a>4.被经常频繁用于连接的字段</h4><p>经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p><h3 id="创建联合索引应该注意什么？"><a href="#创建联合索引应该注意什么？" class="headerlink" title="创建联合索引应该注意什么？"></a>创建联合索引应该注意什么？</h3><p>1.最左匹配</p><p>2.选择性最大的</p><p>3.频繁查询</p><h2 id="场景提"><a href="#场景提" class="headerlink" title="场景提"></a>场景提</h2><p>mysql场景题，userid order time(时间戳) </p><p>  (1)查询某一用户某一天的订单 </p><p>  (2)查询某一天的订单 </p><p>  (3)查询 某一用户某几天的订单 </p><p>  (3)查询某几天的订单</p><p>  怎么建立索引，sql语句</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聚簇索引和非聚簇索引</title>
      <link href="/2020/06/30/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
      <url>/2020/06/30/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="聚集索引（聚簇索引）："><a href="#聚集索引（聚簇索引）：" class="headerlink" title="聚集索引（聚簇索引）："></a>聚集索引（聚簇索引）：</h3><p>以innodb作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。这种以主键作为B+树索引的键值而构建的B+树索引，我们称之为聚集索引。 </p><h3 id="非聚集索引（非聚簇索引）："><a href="#非聚集索引（非聚簇索引）：" class="headerlink" title="非聚集索引（非聚簇索引）："></a>非聚集索引（非聚簇索引）：</h3><p>以主键以外的列值作为键值构建的B+树索引，我们称之为非聚集索引。非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。</p><p><img src="/2020/06/30/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630104400532.png" alt="image-20200630104400532"></p><p><img src="file:///C:/Users/77406/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一条SQL语句执行很慢的原因有哪些</title>
      <link href="/2020/06/30/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
      <url>/2020/06/30/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>slow_query_log  ：是否开启慢查询日志，1表示开启，0表示关闭。</p><p>long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables  like &#39;%slow_query_log%&#39;;</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                         |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                           |</span><br><span class="line">| slow_query_log_file | &#x2F;home&#x2F;WDPM&#x2F;MysqlData&#x2F;mysql&#x2F;DB-Server-slow.log |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; set global slow_query_log&#x3D;1;</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; show variables like &#39;%slow_query_log%&#39;;</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                         |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| slow_query_log      | ON                                            |</span><br><span class="line">| slow_query_log_file | &#x2F;home&#x2F;WDPM&#x2F;MysqlData&#x2F;mysql&#x2F;DB-Server-slow.log |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>关于慢查询的参数slow_query_log_file ，它指定慢查询日志文件的存放路径，系统默认会给一个缺省的文件host_name-slow.log（如果没有指定参数slow_query_log_file的话）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;slow_query_log_file&#39;;</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                         |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| slow_query_log_file | &#x2F;home&#x2F;WDPM&#x2F;MysqlData&#x2F;mysql&#x2F;DB-Server-slow.log |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢？ 这个是由参数long_query_time控制，默认情况下long_query_time的值为10秒，可以使用命令修改，也可以在my.cnf参数里面修改。关于运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，在mysql源码里是判断大于long_query_time，而非大于等于。从MySQL 5.1开始，long_query_time开始以微秒记录SQL语句运行时间，之前仅用秒为单位记录。如果记录到表里面，只会记录整数部分，不会记录微秒部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;long_query_time%&#39;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; set global long_query_time&#x3D;4;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; show variables like &#39;long_query_time&#39;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在MySQL里面执行下面SQL语句，然后我们去检查对应的慢查询日志，就会发现类似下面这样的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sleep(3);</span><br><span class="line">+----------+</span><br><span class="line">| sleep(3) |</span><br><span class="line">+----------+</span><br><span class="line">|        0 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (3.00 sec)</span><br><span class="line"> </span><br><span class="line">[root@DB-Server ~]# more &#x2F;tmp&#x2F;mysql_slow.log</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;mysqld, Version: 5.6.20-enterprise-commercial-advanced-log (MySQL Enterprise Server - Advanced Edition (Commercial)). started with:</span><br><span class="line">Tcp port: 0  Unix socket: (null)</span><br><span class="line">Time                 Id Command    Argument</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;mysqld, Version: 5.6.20-enterprise-commercial-advanced-log (MySQL Enterprise Server - Advanced Edition (Commercial)). started with:</span><br><span class="line">Tcp port: 0  Unix socket: (null)</span><br><span class="line">Time                 Id Command    Argument</span><br><span class="line"># Time: 160616 17:24:35</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:     5</span><br><span class="line"># Query_time: 3.002615  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 0</span><br><span class="line">SET timestamp&#x3D;1466069075;</span><br><span class="line">select sleep(3);</span><br></pre></td></tr></table></figure><p><img src="https://images2015.cnblogs.com/blog/73542/201606/73542-20160617103137557-2127639925.png" alt="image"></p><h3 id="Show-status"><a href="#Show-status" class="headerlink" title="Show status"></a>Show status</h3><ul><li><p>查看select语句的执行数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show [global] status like &#39;com_select&#39;;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#39;table_locks_waited&#39;;</span><br></pre></td></tr></table></figure><p>重构查询方式</p><ol><li><p>切分大查询<br> 一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要<br> 的查询。</p></li><li><p>分解大连接查询<br> 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p><p>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查<br>询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。<br>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。<br>减少锁竞争；<br>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。<br>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进<br>行查询，这可能比随机的连接要更高效。</p></li></ol><h3 id="show-profile-SQL耗时出现在哪个环节"><a href="#show-profile-SQL耗时出现在哪个环节" class="headerlink" title="show profile(SQL耗时出现在哪个环节)"></a>show profile(SQL耗时出现在哪个环节)</h3><h4 id="开启-profiles"><a href="#开启-profiles" class="headerlink" title="开启 profiles"></a>开启 profiles</h4><ul><li>查看是否开启</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">"%profiling%"</span>;</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>开启</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling = <span class="number">1</span>;</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h4><ul><li>先执行要分析的<code>SQL</code>语句</li><li>执行<code>show profiles;</code>会出现如下结果<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80YmNmZjk4Mi1hMzU1LTQwZTYtYjMxZi00ZjJhZDExY2NjMDcucG5n?x-oss-process=image/format,png" alt="img"></li><li>分析以上截图某一条<code>SQL</code>语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile type1,type2.. <span class="keyword">for</span> <span class="keyword">query</span> Query_ID</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>比如我们分析截图中的第<code>5</code>条<code>SQL</code>语句</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile cpu,<span class="keyword">block</span> io <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9mODlkZDliMy1hZmY2LTRjYjgtYjUyMy03ZjU2NDM2ZGYzZTcucG5n?x-oss-process=image/format,png" alt="img"></p><h4 id="show-profile返回结果字段含义"><a href="#show-profile返回结果字段含义" class="headerlink" title="show profile返回结果字段含义"></a>show profile返回结果字段含义</h4><ul><li>Status ： sql 语句执行的状态</li><li>Duration: sql 执行过程中每一个步骤的耗时</li><li>CPU_user: 当前用户占有的 cpu</li><li>CPU_system: 系统占有的 cpu</li><li>Block_ops_in : I/O 输入</li><li>Block_ops_out : I/O 输出</li></ul><h4 id="show-profile-type-选项"><a href="#show-profile-type-选项" class="headerlink" title="show profile type 选项"></a>show profile type 选项</h4><ul><li>all：显示所有的性能开销信息</li><li>block io：显示块 IO 相关的开销信息</li><li>context switches: 上下文切换相关开销</li><li>cpu：显示 CPU 相关的信息</li><li>ipc：显示发送和接收相关的开销信息</li><li>memory：显示内存相关的开销信息</li><li>page faults：显示页面错误相关开销信息</li><li>source：显示和 Source_function、Source_file、Source_line 相关的开销信息</li><li>swaps：显示交换次数的相关信息</li></ul><h4 id="status出现以下情况的建议"><a href="#status出现以下情况的建议" class="headerlink" title="status出现以下情况的建议"></a>status出现以下情况的建议</h4><ul><li>Sending data</li></ul><blockquote><p><code>解释</code>：从server端发送数据到客户端，也有可能是接收存储引擎层返回的数据，再发送给客户端，数据量很大时尤其经常能看见。<br><code>备注</code>：Sending Data不是网络发送，是从硬盘读取，发送到网络是Writing to net。<code>建议</code>：通过索引或加上LIMIT，减少需要扫描并且发送给客户端的数据量</p></blockquote><ol><li>减少请求的数据量<br>只返回必要的列：最好不要使用 SELECT * 语句。<br>  只返回必要的行：使用 LIMIT 语句来限制返回的数据。<br>  缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存<br>  带来的查询性能提升将会是非常明显的。</li></ol><ul><li>Sorting result</li></ul><blockquote><p>正在对结果进行排序，类似Creating sort index，不过是正常表，而不是在内存表中进行排序。<br><code>建议</code>：创建适当的索引</p></blockquote><ul><li>Table lock</li></ul><blockquote><p>表级锁，没什么好说的，要么是因为MyISAM引擎表级锁，要么是其他情况显式锁表</p></blockquote><ul><li>create sort index</li></ul><blockquote><p>当前的SELECT中需要用到临时表在进行ORDER BY排序<br><code>建议</code>：创建适当的索引</p></blockquote><ul><li>Creating tmp table</li></ul><blockquote><p>创建临时表。先拷贝数据到临时表，用完后再删除临时表。消耗内存，数据来回拷贝删除，消耗时间，<code>建议</code>：优化索引</p></blockquote><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><h2 id="一、开始装逼：分类讨论"><a href="#一、开始装逼：分类讨论" class="headerlink" title="一、开始装逼：分类讨论"></a>一、开始装逼：分类讨论</h2><p>一条 SQL 语句执行的很慢，那是每次执行都很慢呢？还是大多数情况下是正常的，偶尔出现很慢呢？所以我觉得，我们还得分以下两种情况来讨论。</p><p>1、大多数情况是正常的，只是偶尔会出现很慢的情况。</p><p>2、在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。</p><p>针对这两种情况，我们来分析下可能是哪些原因导致的。</p><h2 id="二、针对偶尔很慢的情况"><a href="#二、针对偶尔很慢的情况" class="headerlink" title="二、针对偶尔很慢的情况"></a>二、针对偶尔很慢的情况</h2><p>一条 SQL 大多数情况正常，偶尔才能出现很慢的情况，针对这种情况，我觉得这条SQL语句的书写本身是没什么问题的，而是其他原因导致的，那会是什么原因呢？</p><h3 id="1、数据库在刷新脏页我也无奈啊"><a href="#1、数据库在刷新脏页我也无奈啊" class="headerlink" title="1、数据库在刷新脏页我也无奈啊"></a>1、数据库在刷新脏页我也无奈啊</h3><p>当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在<strong>内存</strong>中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到<strong>磁盘</strong>中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到<strong>磁盘</strong>中去。</p><p>不过，redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，<strong>就会导致我们平时正常的SQL语句突然执行的很慢</strong>，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。</p><h3 id="2、拿不到锁我能怎么办"><a href="#2、拿不到锁我能怎么办" class="headerlink" title="2、拿不到锁我能怎么办"></a>2、拿不到锁我能怎么办</h3><p>这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，我也没办法啊。</p><p>如果要判断是否真的在等待锁，我们可以用 <strong>show processlist</strong>这个命令来查看当前的状态哦，这里我要提醒一下，有些命令最好记录一下，反正，我被问了好几个命令，都不知道怎么写，呵呵。</p><p>下来我们来访分析下第二种情况，我觉得第二种情况的分析才是最重要的</p><h2 id="三、针对一直都这么慢的情况"><a href="#三、针对一直都这么慢的情况" class="headerlink" title="三、针对一直都这么慢的情况"></a>三、针对一直都这么慢的情况</h2><p>如果在数据量一样大的情况下，这条 SQL 语句每次都执行的这么慢，那就就要好好考虑下你的 SQL 书写了，下面我们来分析下哪些原因会导致我们的 SQL 语句执行的很不理想。</p><p>我们先来假设我们有一个表，表里有下面两个字段,分别是主键 id，和两个普通字段 c 和 d。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE &#96;t&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;c&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;d&#96; int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><h3 id="1、扎心了，没用到索引"><a href="#1、扎心了，没用到索引" class="headerlink" title="1、扎心了，没用到索引"></a>1、扎心了，没用到索引</h3><p>没有用上索引，我觉得这个原因是很多人都能想到的，例如你要查询这条语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where 100 &lt;c and c &lt; 100000;</span><br></pre></td></tr></table></figure><p><strong>（1）、字段没有索引</strong></p><p>刚好你的 c 字段上没有索引，那么抱歉，只能走全表扫描了，你就体验不会索引带来的乐趣了，所以，这回导致这条查询语句很慢。</p><p><strong>（2）、字段有索引，但却没有用索引</strong></p><p>好吧，这个时候你给 c 这个字段加上了索引，然后又查询了一条语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c - 1 &#x3D; 1000;</span><br></pre></td></tr></table></figure><p>我想问大家一个问题，这样子在查询的时候会用索引查询吗？</p><p>答是不会，如果我们在字段的左边做了运算，那么很抱歉，在查询的时候，就不会用上索引了，所以呢，大家要注意这种<strong>字段上有索引，但由于自己的疏忽，导致系统没有使用索引</strong>的情况了。</p><p>正确的查询应该如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c &#x3D; 1000 + 1;</span><br></pre></td></tr></table></figure><p>有人可能会说，右边有运算就能用上索引？难道数据库就不会自动帮我们优化一下，自动把 c - 1=1000 自动转换为 c = 1000+1。</p><p>不好意思，确实不会帮你，所以，你要注意了。</p><p><strong>（3）、函数操作导致没有用上索引</strong></p><p>如果我们在查询的时候，对字段进行了函数操作，也是会导致没有用上索引的，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) &#x3D; 1000;</span><br></pre></td></tr></table></figure><p>这里我只是做一个例子，假设函数 pow 是求 c 的 n 次方，实际上可能并没有 pow(c,2)这个函数。其实这个和上面在左边做运算也是很类似的。</p><p>所以呢，一条语句执行都很慢的时候，可能是该语句没有用上索引了，不过具体是啥原因导致没有用上索引的呢，你就要会分析了，我上面列举的三个原因，应该是出现的比较多的吧。</p><h3 id="2、呵呵，数据库自己选错索引了"><a href="#2、呵呵，数据库自己选错索引了" class="headerlink" title="2、呵呵，数据库自己选错索引了"></a>2、呵呵，数据库自己选错索引了</h3><p>我们在进行查询操作的时候，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where 100 &lt; c and c &lt; 100000;</span><br></pre></td></tr></table></figure><p>我们知道，主键索引和非主键索引是有区别的，主键索引存放的值是<strong>整行字段的数据</strong>，而非主键索引上存放的值不是整行字段的数据，而且存放<strong>主键字段的值</strong>。不大懂的可以看我这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485127&idx=2&sn=b9bbaa8cd34f3eb71c28169395f5d06a&scene=21#wechat_redirect" target="_blank" rel="noopener">面试小知识：MySQL索引相关</a>   里面有说到主键索引和非主键索引的区别</p><p>也就是说，我们如果走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。</p><p>好吧扯了这么多，其实我就是想告诉你，就算你在 c 字段上有索引，系统也并不一定会走 c 这个字段上的索引，而是有可能会直接扫描扫描全表，找出所有符合 100 &lt; c and c &lt; 100000 的数据。</p><p><strong>为什么会这样呢？</strong></p><p>其实是这样的，系统在执行这条语句的时候，会进行预测：究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？显然，扫描行数越少当然越好了，因为扫描行数越少，意味着I/O操作的次数越少。</p><p>如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走两次索引。而且，我们也不知道符合 100 c &lt; and c &lt; 10000 这个条件的数据有多少行，万一这个表是全部数据都符合呢？这个时候意味着，走 c 索引不仅扫描的行数是 n，同时还得每行数据走两次索引。</p><p><strong>所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？</strong></p><p>判断来源于系统的预测，也就是说，如果要走 c 字段索引的话，系统会预测走 c 字段索引大概需要扫描多少行。如果预测到要扫描的行数很多，它可能就不走索引而直接扫描全表了。</p><p>那么问题来了，<strong>系统是怎么预测判断的呢？</strong>这里我给你讲下系统是怎么判断的吧，虽然这个时候我已经写到脖子有点酸了。</p><p>系统是通过<strong>索引的区分度</strong>来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。我们也把区分度称之为<strong>基数</strong>，即区分度越高，基数越大。所以呢，基数越大，意味着符合 100 &lt; c and c &lt; 10000 这个条件的行数越少。</p><p>所以呢，一个索引的基数越大，意味着走索引查询越有优势。</p><p><strong>那么问题来了，怎么知道这个索引的基数呢？</strong></p><p>系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过<strong>采样</strong>的方式，来预测索引的基数的。</p><p><strong>扯了这么多，重点的来了</strong>，居然是采样，那就有可能出现<strong>失误</strong>的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。<strong>然后就呵呵，系统就不走 c 索引了，直接走全部扫描了</strong>。</p><p>所以呢，说了这么多，得出结论：<strong>由于统计的失误，导致系统没有走索引，而是走了全表扫描</strong>，而这，也是导致我们 SQL 语句执行的很慢的原因。</p><blockquote><p>这里我声明一下，系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用临时表、是否需要排序等也是会影响系统的选择的。</p></blockquote><p>不过呢，我们有时候也可以通过强制走索引的方式来查询，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t force index(a) where c &lt; 100 and c &lt; 100000;</span><br></pre></td></tr></table></figure><p>我们也可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from t;</span><br></pre></td></tr></table></figure><p>来查询索引的基数和实际是否符合，如果和实际很不符合的话，我们可以重新来统计索引的基数，可以用这条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table t;</span><br></pre></td></tr></table></figure><p>来重新统计分析。</p><p><strong>既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引哦</strong>，这也可能是 SQL 执行的很慢的一个原因。</p><p>好吧，就先扯这么多了，你到时候能扯出这么多，我觉得已经很棒了，下面做一个总结。</p><p><strong>四、总结</strong></p><p>以上是我的总结与理解，最后一个部分，我怕很多人不大懂<strong>数据库居然会选错索引</strong>，所以我详细解释了一下，下面我对以上做一个总结。</p><p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p><p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p><p>(2)、执行的时候，遇到锁，如表锁、行锁。</p><p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p><p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p><p>(2)、数据库选错了索引。</p><p>大家如果有补充的，也是可以留言区补充一波哦。</p><p> explain 每个列代表什么含义（关于优化级别 ref 和 all，什么时候应该用到index却没用到，关于extra列出现了usetempory 和 filesort分别的原因和如何着手优化等） </p><p> show profile 怎么使用。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>reentranlock底层原理</title>
      <link href="/2020/06/30/reentranlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2020/06/30/reentranlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><p>首先<code>ReentrantLock</code>继承自父类<code>Lock</code>，然后有<code>3</code>个内部类，其中中有一个抽象内部类Sync继承AQS，两个内部类NonfairSync和FairSync继承了Sync(Sync重写tryRelease），重写了lock()方法和tryAcquire()方法，分别实现了非公平锁和公平锁。<br><img src="https://uploadfiles.nowcoder.com/files/20191214/592649258_1576325730428_2019121410495622.png" alt="在这里插入图片描述"><br>ReentrantLock默认为非公平锁，如果想创建公平锁，可给构造方法传入参数true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code>有两个构造方法，无参构造方法默认是创建<strong>非公平锁</strong>，而传入<code>true</code>为参数的构造方法创建的是<strong>公平锁</strong>。</p><h3 id="非公平锁的实现原理"><a href="#非公平锁的实现原理" class="headerlink" title="非公平锁的实现原理"></a>非公平锁的实现原理</h3><p>当我们使用无参构造方法构造的时候即<code>ReentrantLock lock = new ReentrantLock()</code>，创建的就是非公平锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者传入false参数 创建的也是非公平锁</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="lock方法获取锁"><a href="#lock方法获取锁" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol><li><code>lock</code>方法调用<code>CAS</code>方法设置<code>state</code>的值，如果<code>state</code>等于期望值<code>0</code>(代表锁没有被占用)，那么就将<code>state</code>更新为<code>1</code>(代表该线程获取锁成功)，然后执行<code>setExclusiveOwnerThread</code>方法直接将该线程设置成锁的所有者。如果<code>CAS</code>设置<code>state</code>的值失败，即<code>state</code>不等于<code>0</code>，代表锁正在被占领着，则执行<code>acquire(1)</code>，即下面的步骤。</li><li><code>nonfairTryAcquire</code>方法首先调用<code>getState</code>方法获取<code>state</code>的值，如果<code>state</code>的值为<code>0</code>(之前占领锁的线程刚好释放了锁)，那么用<code>CAS</code>设置<code>state</code>的值，设置成功则将该线程设置成锁的所有者，并且返回<code>true</code>。如果<code>state</code>的值不为<code>0</code>，那就<strong>调用<code>getExclusiveOwnerThread</code>方法查看占用锁的线程是不是自己</strong>，如果是的话那就直接将<code>state + 1</code>，然后返回<code>true</code>。如果<code>state</code>不为<code>0</code>且锁的所有者又不是自己，那就返回<code>false</code>，<strong>然后线程会进入到同步队列中</strong>。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">作者：冠状病毒biss</span><br><span class="line">链接：https:&#x2F;&#x2F;www.nowcoder.com&#x2F;discuss&#x2F;355081?type&#x3D;post&amp;order&#x3D;time&amp;pos&#x3D;&amp;page&#x3D;1&amp;channel&#x3D;0&amp;source_id&#x3D;search_post</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">弊端：可能导致排队的线程一直无法得到CPU资源的饥饿现象</span><br><span class="line">public void lock() &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line">1.调用NofairSync中的lock方法</span><br><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))&#x2F;&#x2F;AQS类的方法 使用CAS算法更新state的值</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());&#x2F;&#x2F;若更新成功设置当前线程为独占线程c</span><br><span class="line">    else</span><br><span class="line">        acquire(1);&#x2F;&#x2F;若CAS更新失败，执行是AQS类的acquire()方法</span><br><span class="line">&#125;</span><br><span class="line">2.AQS中的acquire()方法</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">if (!tryAcquire(arg) &amp;&amp;&#x2F;&#x2F;尝试获取锁 失败则调用addWaiter方法创建结点并追加到队列尾部</span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&#x2F;&#x2F;然后调用acquireQueued阻塞或者自旋尝试获取锁</span><br><span class="line">    selfInterrupt();&#x2F;&#x2F;在 acquireQueued 中，如果线程是因为中断而退出的阻塞状态会返回true</span><br><span class="line">    &#125;</span><br><span class="line">   3.Nofair中的tryAcquire()重写</span><br><span class="line">   protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;如果当前state值为0 并CAS操作成功 独占锁 返回true</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F;否则判断当前线程是否是持有锁的那个独占线程</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;&#x2F;&#x2F;相当于重入锁</span><br><span class="line">        int nextc &#x3D; c + acquires;&#x2F;&#x2F;是将state值更新</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; 假如超过最大可重入次数</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;&#x2F;&#x2F;state不为0，并且不是那个持有锁的线程 返回false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryRelease锁的释放"><a href="#tryRelease锁的释放" class="headerlink" title="tryRelease锁的释放"></a>tryRelease锁的释放</h4><ol><li>判断当前线程是不是锁的所有者，如果是则进行步骤<code>2</code>，如果不是则抛出异常。</li><li>判断此次释放锁后<code>state</code>的值是否为0，如果是则代表<strong>锁没有重入</strong>，然后将锁的所有者设置成<code>null</code>且返回<code>true</code>，然后执行步骤<code>3</code>，如果不是则<strong>代表锁发生了重入</strong>执行步骤<code>4</code>。</li><li>现在锁已经释放完，即<code>state=0</code>，唤醒同步队列中的后继节点进行锁的获取。</li><li>锁还没有释放完，即<code>state!=0</code>，不唤醒同步队列。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169aad4a8e578933?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;子类重写的tryRelease方法，需要等锁的state&#x3D;0，即tryRelease返回true的时候，才会去唤醒其</span><br><span class="line">    &#x2F;&#x2F;它线程进行尝试获取锁。</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F;状态的state减去releases</span><br><span class="line">    int c &#x3D; getState() - releases;</span><br><span class="line">    &#x2F;&#x2F;判断锁的所有者是不是该线程</span><br><span class="line">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">        &#x2F;&#x2F;如果所的所有者不是该线程 则抛出异常 也就是锁释放的前提是线程拥有这个锁，</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;如果该线程释放锁之后 状态state&#x3D;0，即锁没有重入，那么直接将将锁的所有者设置成null</span><br><span class="line">    &#x2F;&#x2F;并且返回true，即代表可以唤醒其他线程去获取锁了。如果该线程释放锁之后state不等于0，</span><br><span class="line">    &#x2F;&#x2F;那么代表锁重入了，返回false，代表锁还未正在释放，不用去唤醒其他线程。</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        free &#x3D; true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="公平锁的实现原理"><a href="#公平锁的实现原理" class="headerlink" title="公平锁的实现原理"></a>公平锁的实现原理</h3><h4 id="lock方法获取锁-1"><a href="#lock方法获取锁-1" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol><li>获取状态的<code>state</code>的值，如果<code>state=0</code>即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，执行步骤<code>2</code>。如果<code>state!=0</code>则代表锁正在被其它线程占用，执行步骤<code>3</code>。</li><li><strong>判断同步队列是否存在线程(节点)，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。</strong></li><li><strong>判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中</strong></li></ol><p>通过步骤<code>2</code><strong>实现了锁获取的公平性，即锁的获取按照先来先得的顺序，后来的不能抢先获取锁，非公平锁和公平锁也正是通过这个区别来实现了锁的公平性。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169aaf5a27ee58d5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;同步队列中有线程 且 锁的所有者不是当前线程那么将线程加入到同步队列的尾部，</span><br><span class="line">    &#x2F;&#x2F;保证了公平性，也就是先来的线程先获得锁，后来的不能抢先获取。</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    &#x2F;&#x2F;判断状态state是否等于0，等于0代表锁没有被占用，不等于0则代表锁被占用着。</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;调用hasQueuedPredecessors方法判断同步队列中是否有线程在等待，如果同步队列中没有</span><br><span class="line">        &#x2F;&#x2F;线程在等待 则当前线程成为锁的所有者，如果同步队列中有线程在等待，则继续往下执行</span><br><span class="line">        &#x2F;&#x2F;这个机制就是公平锁的机制，也就是先让先来的线程获取锁，后来的不能抢先获取。</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断当前线程是否为锁的所有者，如果是，那么直接更新状态state，然后返回true。</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果同步队列中有线程存在 且 锁的所有者不是当前线程，则返回false。</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="tryRelease锁的释放-1"><a href="#tryRelease锁的释放-1" class="headerlink" title="tryRelease锁的释放"></a>tryRelease锁的释放</h4><p>公平锁的释放和非公平锁的释放一样，这里就不重复。<br> 公平锁和非公平锁的公平性是在<strong>获取锁</strong>的时候体现出来的，释放的时候都是一样释放的。</p><h3 id="ReentrantLock的等待-通知机制"><a href="#ReentrantLock的等待-通知机制" class="headerlink" title="ReentrantLock的等待/通知机制"></a>ReentrantLock的等待/通知机制</h3><p>我们知道关键字<code>Synchronized</code> + <code>Object</code>的<code>wait</code>和<code>notify</code>、<code>notifyAll</code>方法能实现<strong>等待/通知</strong>机制，那么<code>ReentrantLock</code>是否也能实现这样的等待/通知机制，答案是：可以。<br> <code>ReentrantLock</code>通过<code>Condition</code>对象，也就是<strong>条件队列</strong>实现了和<code>wait</code>、<code>notify</code>、<code>notifyAll</code>相同的语义。 线程执行<code>condition.await()</code>方法，将节点1从同步队列转移到条件队列中。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b3432b128105d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>线程执行<code>condition.signal()</code>方法，将节点1从条件队列中转移到同步队列。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b3411b74cfff1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>因为只有在同步队列中的线程才能去获取锁，所以通过<code>Condition</code>对象的<code>wait</code>和<code>signal</code>方法能实现等待/通知机制。<br> 代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">Condition condition &#x3D; lock.newCondition();</span><br><span class="line">public void await() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;线程获取锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">        condition.await(); &#x2F;&#x2F;调用await()方法 会释放锁，和Object.wait()效果一样。</span><br><span class="line">        System.out.println(&quot;线程被唤醒----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(&quot;线程释放锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void signal() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(1000);  &#x2F;&#x2F;休眠1秒钟 等等一个线程先执行</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;另外一个线程获取到锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">        condition.signal();</span><br><span class="line">        System.out.println(&quot;唤醒线程----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(&quot;另外一个线程释放锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Test t &#x3D; new Test();</span><br><span class="line">    Thread t1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            t.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            t.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程获取锁----Thread-0</span><br><span class="line">另外一个线程获取到锁----Thread-1</span><br><span class="line">唤醒线程----Thread-1</span><br><span class="line">另外一个线程释放锁----Thread-1</span><br><span class="line">线程被唤醒----Thread-0</span><br><span class="line">线程释放锁----Thread-0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>执行的流程大概是这样，线程<code>t1</code>先获取到锁，输出了”线程获取锁—-Thread-0”，然后线程<code>t1</code>调用<code>await</code>方法，调用这个方法的结果就是<strong>线程<code>t1</code>释放了锁进入等待状态，等待唤醒</strong>，接下来线程<code>t2</code>获取到锁，然输出了”另外一个线程获取到锁—-Thread-1”，同时线程<code>t2</code>调用<code>signal</code>方法，调用这个方法的结果就是<strong>唤醒一个在条件队列(Condition)的线程，然后线程<code>t1</code>被唤醒，而这个时候线程<code>t2</code>并没有释放锁，线程<code>t1</code>也就没法获得锁，等线程<code>t2</code>继续执行输出”唤醒线程—-Thread-1”之后线程<code>t2</code>释放锁且输出”另外一个线程释放锁—-Thread-1”，这时候线程<code>t1</code>获得锁，继续往下执行输出了<code>线程被唤醒----Thread-0</code>，然后释放锁输出”线程释放锁—-Thread-0”</strong>。</p><p>如果想单独唤醒部分线程应该怎么做呢？这时就有必要使用多个<code>Condition</code>对象了，因为<code>ReentrantLock</code>支持创建多个<code>Condition</code>对象，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;为了减少篇幅 仅给出伪代码</span><br><span class="line">ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">Condition condition &#x3D; lock.newCondition();</span><br><span class="line">Condition condition1 &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程1 调用condition.await() 线程进入到条件队列</span><br><span class="line">condition.await();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程2 调用condition1.await() 线程进入到条件队列</span><br><span class="line">condition1.await();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程32 调用condition.signal() 仅唤醒调用condition中的线程，不会影响到调用condition1。</span><br><span class="line">condition1.await();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就实现了部分唤醒的功能。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><h3 id="和synchronized的对比"><a href="#和synchronized的对比" class="headerlink" title="和synchronized的对比"></a>和synchronized的对比</h3><ol><li>锁的实现<br>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li><li>性能<br>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</li><li>等待可中断<br>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<br>ReentrantLock 可中断，而 synchronized 不行。</li><li>公平锁<br>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<br>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</li><li>锁绑定多个条件<br>一个 ReentrantLock 可以同时绑定多个 Condition 对象。<br>使用选择<br>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一<br>种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没<br>有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</li></ol><p>作者：薛8<br>链接：<a href="https://juejin.im/post/5c95df97e51d4551d06d8e8e" target="_blank" rel="noopener">https://juejin.im/post/5c95df97e51d4551d06d8e8e</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">https://www.javadoop.com/post/AbstractQueuedSynchronizer</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用explain关键字</title>
      <link href="/2020/06/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8explain%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/06/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8explain%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析你的查询语句或是表结构的性能瓶颈。</p><h2 id="explain执行计划包含的信息"><a href="#explain执行计划包含的信息" class="headerlink" title="explain执行计划包含的信息"></a>explain执行计划包含的信息</h2><p><img src="https://img-blog.csdn.net/20170509232741017?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>其中最重要的字段为：id、type、key、rows、Extra</strong></p><p>id:select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p><p>type : 访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是<strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p><p>key : 使用的索引</p><p>rows : 扫描的行数</p><p>Extra:不适合在其他字段中显示，但是十分重要的额外信息(例如覆盖索引等等)</p><table><thead><tr><th>指标名</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>表示 SELECT 子句或操作表的顺序，执行顺序从大到小执行，当 id 一样时，执行顺序从上往下。</td></tr><tr><td>select_type</td><td>表示查询中每个 SELECT 子句的类型，例如 SIMPLE 表示不包含子查询、表连接或其他复杂语法的简单查询，PRIMARY 表示复杂查询的最外层查询，SUBQUERY 表示在 SELECT 或 WHERE 列表中包含了子查询。</td></tr><tr><td>type</td><td>表示访问类型，性能由差到好为：ALL 全表扫描、index 索引全扫描、range 索引范围扫描、ref 返回匹配某个单独值得所有行，常见于使用非唯一索引或唯一索引的非唯一前缀进行的查找，也经常出现在 join 操作中、eq_ref 唯一性索引扫描，对于每个索引键只有一条记录与之匹配、const 当 MySQL 对查询某部分进行优化，并转为一个常量时，使用这些访问类型，例如将主键或唯一索引置于 WHERE 列表就能将该查询转为一个 const、system 表中只有一行数据或空表，只能用于 MyISAM 和 Memory 表、NULL 执行时不用访问表或索引就能得到结果。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是consts 最好。</td></tr><tr><td>possible_keys</td><td>表示查询时可能用到的索引，但不一定使用。列出大量可能索引时意味着备选索引数量太多了。</td></tr><tr><td>key</td><td>显示 MySQL 在查询时实际使用的索引，如果没有使用则显示为 NULL。</td></tr><tr><td>key_len</td><td>表示使用到索引字段的长度，可通过该列计算查询中使用的索引的长度，对于确认索引有效性以及多列索引中用到的列数目很重要。</td></tr><tr><td>ref</td><td>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</td></tr><tr><td>rows</td><td>表示 MySQL 根据表统计信息及索引选用情况，估算找到所需记录所需要读取的行数。</td></tr><tr><td>Extra</td><td>表示额外信息，例如 Using temporary 表示需要使用临时表存储结果集，常见于排序和分组查询。Using filesort 表示无法利用索引完成的文件排序，这是 ORDER BY 的结果，可以通过合适的索引改进性能。Using index 表示只需要使用索引就可以满足查询表得要求，说明表正在使用覆盖索引。</td></tr></tbody></table><h2 id="各字段详解"><a href="#各字段详解" class="headerlink" title="各字段详解"></a>各字段详解</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序<br>三种情况：<br>1、id相同：执行顺序由上至下</p><p><img src="https://img-blog.csdn.net/20170509234043416?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>2、id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p><p><img src="https://img-blog.csdn.net/20170510223451835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3、id相同又不同（两种情况同时存在）：id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p><p><img src="https://img-blog.csdn.net/20170510224901726?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>查询的类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询</p><p>1、SIMPLE：简单的select查询，查询中不包含子查询或者union<br>2、PRIMARY：查询中包含任何复杂的子部分，最外层查询则被标记为primary<br>3、SUBQUERY：在select 或 where列表中包含了子查询<br>4、DERIVED：在from列表中包含的子查询被标记为derived（衍生），mysql或递归执行这些子查询，把结果放在零时表里<br>5、UNION：若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived<br>6、UNION RESULT：从union表获取结果的select</p><p><img src="https://img-blog.csdn.net/20170510231953999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>一般来说，好的sql查询至少达到range级别，最好能达到ref</p><p>1、system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计</p><p>2、const：表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const</p><p><img src="https://img-blog.csdn.net/20170511215148532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3、eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描。</p><p>注意：ALL全表扫描的表记录最少的表如t1表</p><p><img src="https://img-blog.csdn.net/20170512143354425?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>4、ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体</p><p><img src="https://img-blog.csdn.net/20170512150131136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>5、range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、&lt;、&gt;、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引</p><p><img src="https://img-blog.csdn.net/20170512151841933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>6、index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常为ALL块，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取）</p><p><img src="https://img-blog.csdn.net/20170512152255874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>7、ALL：Full Table Scan，遍历全表以找到匹配的行</p><p><img src="https://img-blog.csdn.net/20170512152537516?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>查询涉及到的字段上存在索引，则该索引将被列出，但不一定被查询实际使用</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>实际使用的索引，如果为NULL，则没有使用索引。<br>查询中如果使用了覆盖索引，则该索引仅出现在key列表中</p><p><img src="https://img-blog.csdn.net/20170512155222855?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示索引中使用的字节数，查询中使用的索引的长度（最大可能长度），并非实际使用长度，理论上长度越短越好。key_len是根据表定义计算而得的，不是通过表内检索出的</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>显示索引的那一列被使用了，如果可能，是一个常量const。</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>不适合在其他字段中显示，但是十分重要的额外信息</p><p>1、Using filesort ：<br>mysql对数据使用一个外部的索引排序，而不是按照表内的索引进行排序读取。也就是说mysql无法利用索引完成的排序操作成为“文件排序”</p><p><img src="https://img-blog.csdn.net/20170515175218264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>由于索引是先按email排序、再按address排序，所以查询时如果直接按address排序，索引就不能满足要求了，mysql内部必须再实现一次“文件排序”</p><p>2、Using temporary：<br>使用临时表保存中间结果，也就是说mysql在对查询结果排序时使用了临时表，常见于order by 和 group by</p><p><img src="https://img-blog.csdn.net/20170515180947413?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3、Using index：<br>表示相应的select操作中使用了覆盖索引（Covering Index），避免了访问表的数据行，效率高</p><p><img src="https://img-blog.csdn.net/20170515182415063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">如果同时出现Using where，表明索引被用来执行索引键值的查找（参考上图）<br>如果没用同时出现Using where，表明索引用来读取数据而非执行查找动作</p><p>覆盖索引（Covering Index）：也叫索引覆盖。就是select列表中的字段，只用从索引中就能获取，不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。<br>注意：<br>a、如需使用覆盖索引，select列表中的字段只取出需要的列，不要使用select *<br>b、如果将所有字段都建索引会导致索引文件过大，反而降低crud性能</p><p>4、Using where ：<br>使用了where过滤</p><p>5、Using join buffer ：<br>使用了链接缓存</p><p>6、Impossible WHERE：<br>where子句的值总是false，不能用来获取任何元祖</p><p><img src="https://img-blog.csdn.net/20170515183331598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>7、select tables optimized away：<br>在没有group by子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT（*）操作，不必等到执行阶段在进行计算，查询执行计划生成的阶段即可完成优化</p><p>8、distinct：<br>优化distinct操作，在找到第一个匹配的元祖后即停止找同样值得动作</p><h2 id="综合Case"><a href="#综合Case" class="headerlink" title="综合Case"></a>综合Case</h2><p><img src="https://img-blog.csdn.net/20170516093515092?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>执行顺序<br>1（id = 4）、【select id, name from t2】：select_type 为union，说明id=4的select是union里面的第二个select。</p><p>2（id = 3）、【select id, name from t1 where address = ‘11’】：因为是在from语句中包含的子查询所以被标记为DERIVED（衍生），where address = ‘11’ 通过复合索引idx_name_email_address就能检索到，所以type为index。</p><p>3（id = 2）、【select id from t3】：因为是在select中包含的子查询所以被标记为SUBQUERY。</p><p>4（id = 1）、【select d1.name, … d2 from … d1】：select_type为PRIMARY表示该查询为最外层查询，table列被标记为 “derived3”表示查询结果来自于一个衍生表（id = 3 的select结果）。</p><p>5（id = NULL）、【 … union … 】：代表从union的临时表中读取行的阶段，table列的 “union 1, 4”表示用id=1 和 id=4 的select结果进行union操作。<br>————————————————<br>版权声明：本文为CSDN博主「走慢一点点」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wuseyukui/article/details/71512793" target="_blank" rel="noopener">https://blog.csdn.net/wuseyukui/article/details/71512793</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前缀树的场景以及实现</title>
      <link href="/2020/06/29/%E5%89%8D%E7%BC%80%E6%A0%91%E7%9A%84%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/06/29/%E5%89%8D%E7%BC%80%E6%A0%91%E7%9A%84%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>trie 树也称为字典树、单词查找树，最大的特点就是共享<strong>字符串的公共前缀</strong>来达到节省空间的目的了。例如，字符串 “abc”和”abd”构成的 trie 树如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lffcJ72RwSZzf9UxWSPuqWByjiaHHSIQFU2ZNCkAnAKoOib8TSWjW8ZwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><h3 id="trie-树来实现敏感词过滤"><a href="#trie-树来实现敏感词过滤" class="headerlink" title="trie 树来实现敏感词过滤"></a>trie 树来实现敏感词过滤</h3><p>三个敏感词：”de”, “bca”, “bcf” 建立一颗 trie 树</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027l7SvJibyl5wONF8oPM2Ua4xKlgEpPDFYZicicqibOskxvnribWILm3TuFZkA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>接着我们可以采用三个指针来遍历</p><p>1、首先指针 p1 指向 root，指针 p2 和 p3 指向字符串第一个字符</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lDl8BH9p53bggbEDaZmxU5fGjTurE6VamdybAWHMqNqsxnib3ZfRMcZw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>2、然后从字符串的 a 开始，检测有没有以 a 作为前缀的敏感词，直接判断 p1 的孩子节点中是否有 a 这个节点就可以了，显然这里没有。接着把指针 p2 和 p3 向右移动一格。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027l9s7FxaxdiaSreteIAa3ITSqu3691kXWMPC7FKZyWTAI7ibOXyj2WvOicw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>3、然后从字符串 b 开始查找，看看是否有以 b 作为前缀的字符串，p1 的孩子节点中有 b，这时，<strong>我们把 p1 指向节点 b，p2 向右移动一格，不过，p3不动。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lECEqictiaiaEK7g1AyBT44iaP6wTb7JcArqNu8mhOy1U4GqulcUJ8zaMVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>4、判断 p1 的孩子节点中是否存在 p2 指向的字符c，显然有。我们把 p1 指向节点 c，p2 向右移动一格，p3不动。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027liaPbDjQlcyJ3IDs1QMjoRvNBmkxl1BC5traDHIHwsGeBZkeX22KMBwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>5、判断 p1 的孩子节点中是否存在 p2 指向的字符d，这里没有。这意味着，<strong>不存在以字符b作为前缀的敏感词</strong>。这时我们把p2和p3都移向字符c，p1 还是还原到最开始指向 root。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027ldHazFSFXC1h1VGwTjlqkAJb40EL2NVNCDGbko01F3Lv9c5uxkXBXfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>6、和前面的步骤一样，判断有没以 c 作为前缀的字符串，显然这里没有，所以把 p2 和 p3 移到字符 d。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lNfHacf2TMLSg2BmvqYlb9klTg1TOhd2iacOjv9TB7OMm0eRhUFvEt9g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>7、然后从字符串 d 开始查找，看看是否有以 d 作为前缀的字符串，p1 的孩子节点中有 d，这时，<strong>我们把 p1 指向节点 b，p2 向右移动一格，不过，p3和刚才一样不动。</strong>（看到这里，我猜你已经懂了）</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027l2D8TFoo007qFT8ZiagibsLvFcIs8888shb0q4ApuhAibfSSytpQiayrq5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>8、判断 p1 的孩子节点中是否存在 p2 指向的字符e，显然有。我们把 p1 指向节点 e，<strong>并且，这里e是最后一个节点了，查找结束，所以存在敏感词de</strong>，即 p3 和 p2 这个区间指向的就是敏感词了，把 p2 和 p3 指向的区间那些字符替换成 *。并且把 p2 和 p3 移向字符 f。如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lqNuh2DLKx9LecEZaS1aRfYDbIWZficQGpoibrqMbe6br8UohHsoMTCcA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>9、接着还是重复同样的步骤，知道 p3 指向最后一个字符。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>面试官：可以说说时间复杂度吗？</p><p>小秋：如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。</p><p>如果让你来 构建 trie 树，你会用什么数据结构来实现？</p><p>小秋：我一般使用 Java，我会采用 HashMap 来实现，因为一个节点的字节点个数未知，采用 HashMap 可以动态拓展，而且可以在 O(1) 复杂度内判断某个子节点是否存在。</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>77406@LAPTOP-VEMP0J78 MINGW64 ~/Desktop</title>
      <link href="/2020/06/29/77406-LAPTOP-VEMP0J78-MINGW64-Desktop/"/>
      <url>/2020/06/29/77406-LAPTOP-VEMP0J78-MINGW64-Desktop/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ORM是什么</title>
      <link href="/2020/06/29/ORM%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2020/06/29/ORM%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ORM:(Object/Relation Mapping): 对象/关系映射<br>ORM的实现思想：<br>将关系数据库中表中的记录映射成为对象，以对象的形式展现，程序员可以把对数据库的操作转化为对对象的操作。</p><p><img src="https://images2018.cnblogs.com/blog/1351833/201805/1351833-20180501180203283-1149901647.png" alt="img"></p><h2 id="为什么是mybatis是半ORM"><a href="#为什么是mybatis是半ORM" class="headerlink" title="为什么是mybatis是半ORM"></a>为什么是mybatis是半ORM</h2><p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring两种代理</title>
      <link href="/2020/06/28/spring%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86/"/>
      <url>/2020/06/28/spring%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、原理区别："><a href="#一、原理区别：" class="headerlink" title="一、原理区别："></a>一、原理区别：</h2><p>我们了解到，“代理”的目的是构造一个和被代理的对象有同样行为的对象，一个对象的行为是在类中定义的，对象只是类的实例。所以构造代理，不一定非得通过持有、包装对象这一种方式。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>JDK动态代理</p><p>通过 <code>Proxy</code> 类的 <code>newInstance</code> 方法获取一个动态代理对象，需要传入三个参数，被代理对象的类加载器、被代理对象实现的接口，以及一个 <code>InvocationHandler</code> 调用处理器来指明具体的逻辑，相比静态代理的优势是接口中声明的所有方法都被转移到 <code>InvocationHandler</code> 的 <code>invoke</code> 方法集中处理。</p><p>CGLiB动态代理：</p><p>JDK 动态代理要求实现被代理对象的接口，而 CGLib 要求代理类去继承目标类，如果一个类是 final 类则不能使用 CGLib 代理。两种代理都在运行期生成字节码，JDK 动态代理直接写字节码，而 CGLib 动态代理使用 ASM 框架写字节码。 JDK 动态代理调用代理方法通过反射机制实现，而 GCLib 动态代理通过 FastClass 机制直接调用方法，它为代理类和被代理类各生成一个类</p><h2 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h2><p>jdk只能针对接口不能针对类实现代理。</p><p>CGLib通过继承方式实现代理。所以类或方法最好不要声明成final，对于final类或方法，是无法继承的。</p><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><p>用户管理接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.lf.shejimoshi.proxy.entity;</span><br><span class="line">&#x2F;&#x2F;用户管理接口</span><br><span class="line">public interface UserManager &#123;</span><br><span class="line">    &#x2F;&#x2F;新增用户抽象方法</span><br><span class="line">    void addUser(String userName,String password);</span><br><span class="line">    &#x2F;&#x2F;删除用户抽象方法</span><br><span class="line">    void delUser(String userName);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户管理接口实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.lf.shejimoshi.proxy.entity;</span><br><span class="line">&#x2F;&#x2F;用户管理实现类,实现用户管理接口</span><br><span class="line">public class UserManagerImpl implements UserManager&#123;</span><br><span class="line">    &#x2F;&#x2F;重写新增用户方法</span><br><span class="line">    @Override</span><br><span class="line">    public void addUser(String userName, String password) &#123;</span><br><span class="line">        System.out.println(&quot;调用了新增的方法！&quot;);</span><br><span class="line">        System.out.println(&quot;传入参数为 userName: &quot;+userName+&quot; password: &quot;+password);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;重写删除用户方法</span><br><span class="line">    @Override</span><br><span class="line">    public void delUser(String userName) &#123;</span><br><span class="line">        System.out.println(&quot;调用了删除的方法！&quot;);</span><br><span class="line">        System.out.println(&quot;传入参数为 userName: &quot;+userName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK动态代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.lf.shejimoshi.proxy.jdk;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">import com.lf.shejimoshi.proxy.entity.UserManager;</span><br><span class="line">import com.lf.shejimoshi.proxy.entity.UserManagerImpl;</span><br><span class="line">&#x2F;&#x2F;JDK动态代理实现InvocationHandler接口</span><br><span class="line">public class JdkProxy implements InvocationHandler &#123;</span><br><span class="line">    private Object target ;&#x2F;&#x2F;需要代理的目标对象</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;JDK动态代理，监听开始！&quot;);</span><br><span class="line">        Object result &#x3D; method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;JDK动态代理，监听结束！&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;定义获取代理对象方法</span><br><span class="line">    private Object getJDKProxy(Object targetObject)&#123;</span><br><span class="line">        &#x2F;&#x2F;为目标对象target赋值</span><br><span class="line">        this.target &#x3D; targetObject;</span><br><span class="line">        &#x2F;&#x2F;JDK动态代理只能针对实现了接口的类进行代理，newProxyInstance 函数所需参数就可看出</span><br><span class="line">        return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JdkProxy jdkProxy &#x3D; new JdkProxy();&#x2F;&#x2F;实例化JDKProxy对象</span><br><span class="line">        UserManager user &#x3D; (UserManager) jdkProxy.getJDKProxy(new UserManagerImpl());&#x2F;&#x2F;获取代理对象</span><br><span class="line">        user.addUser(&quot;admin&quot;, &quot;123123&quot;);&#x2F;&#x2F;执行新增方法</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK动态代理运行结果</p><p>Cglib动态代理（需要导入两个jar包，asm-5.2.jar,cglib-3.2.5.jar。版本自行选择）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;cglib&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另一个版本的代码 https:&#x2F;&#x2F;www.cnblogs.com&#x2F;wyq1995&#x2F;p&#x2F;10945034.html</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.lf.shejimoshi.proxy.cglib;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">import com.lf.shejimoshi.proxy.entity.UserManager;</span><br><span class="line">import com.lf.shejimoshi.proxy.entity.UserManagerImpl;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Cglib动态代理，实现MethodInterceptor接口</span><br><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    private Object target;&#x2F;&#x2F;需要代理的目标对象</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;重写拦截方法</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] arr, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;Cglib动态代理，监听开始！&quot;);</span><br><span class="line">        Object invoke &#x3D; method.invoke(target, arr);&#x2F;&#x2F;方法执行，参数：target 目标对象 arr参数数组</span><br><span class="line">        System.out.println(&quot;Cglib动态代理，监听结束！&quot;);</span><br><span class="line">        return invoke;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;定义获取代理对象方法</span><br><span class="line">    public Object getCglibProxy(Object objectTarget)&#123;</span><br><span class="line">        &#x2F;&#x2F;为目标对象target赋值</span><br><span class="line">        this.target &#x3D; objectTarget;</span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">        &#x2F;&#x2F;设置父类,因为Cglib是针对指定的类生成一个子类，所以需要指定父类</span><br><span class="line">        enhancer.setSuperclass(objectTarget.getClass());</span><br><span class="line">        enhancer.setCallback(this);&#x2F;&#x2F; 设置回调 </span><br><span class="line">        Object result &#x3D; enhancer.create();&#x2F;&#x2F;创建并返回代理对象</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CglibProxy cglib &#x3D; new CglibProxy();&#x2F;&#x2F;实例化CglibProxy对象</span><br><span class="line">        UserManager user &#x3D;  (UserManager) cglib.getCglibProxy(new UserManagerImpl());&#x2F;&#x2F;获取代理对象</span><br><span class="line">        user.delUser(&quot;admin&quot;);&#x2F;&#x2F;执行删除方法</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cglib动态代理运行结果</p><p><img src="https://images2017.cnblogs.com/blog/985411/201801/985411-20180111010415222-40358282.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mybatis相关疑惑</title>
      <link href="/2020/06/28/mybatis%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91/"/>
      <url>/2020/06/28/mybatis%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="mybatis中-和-的区别"><a href="#mybatis中-和-的区别" class="headerlink" title="mybatis中#和$的区别"></a>mybatis中#和$的区别</h2><p><strong>#{parameterName}</strong></p><p><strong>${parameterName}</strong></p><p>首先，我们说一下这两种引用参数时的区别，<strong>使用#</strong>{parameterName}引用参数的时候，Mybatis会<strong>把这个参数认为是一个字符串，并自动加上’’</strong>，例如传入参数是“Smith”，那么在下面SQL中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from emp where name = #&#123;employeeName&#125;</span><br></pre></td></tr></table></figure><p>使用的时候就会转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * <span class="keyword">from</span> emp where name = <span class="string">'Smith'</span>;</span><br></pre></td></tr></table></figure><p>同时<strong>使用${parameterName}的</strong>时候在下面SQL中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * <span class="keyword">from</span> emp where name = $&#123;employeeName&#125;</span><br></pre></td></tr></table></figure><p>就会直接转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * <span class="keyword">from</span> emp where name = Smith</span><br></pre></td></tr></table></figure><p>简单说<strong>#{}是经过预编译的,是安全的</strong>。</p><p>而<strong>${}</strong>是未经过预编译的,<strong>仅仅是取变量的值,是非安全的,存在SQL注入</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&#123;&#125; 这种取值是编译好SQL语句再取值</span><br><span class="line">$&#123;&#125; 这种是取值以后再去编译SQL语句</span><br></pre></td></tr></table></figure><p>下面我们用一个实际的例子看看分别使用和是否可以防止SQL注入。</p><p><strong>首先是使用#{}：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用#&#123;&#125; --&gt;</span><br><span class="line">  &lt;select id=<span class="string">"selectUser"</span> parameterType=<span class="string">"String"</span> </span><br><span class="line">    resultType=<span class="string">"com.mybatis.po.MyUser"</span>&gt;</span><br><span class="line">    select * from user where account = #&#123;account&#125; and password = #&#123;password&#125;</span><br><span class="line">  &lt;<span class="regexp">/select&gt;</span></span><br></pre></td></tr></table></figure><p>分别测试正常传参和拼接传参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用#&#123;&#125; 正常传参</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; parameter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parameter.put(<span class="string">"account"</span>, );</span><br><span class="line">    parameter.put(<span class="string">"password"</span>, password);</span><br><span class="line">    MyUser mu = ss.selectOne(<span class="string">"com.mybatis.mapper.UserMapper.selectUser"</span>, parameter);</span><br><span class="line">    System.out.println(<span class="string">"返回结果："</span> + mu);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用#&#123;&#125; 拼接传参</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; parameter_1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parameter_1.put(<span class="string">"account"</span>, <span class="string">"201301001"</span>);</span><br><span class="line">    parameter_1.put(<span class="string">"password"</span>, <span class="string">"111111"</span> + <span class="string">"or account = 'admin' "</span>);</span><br><span class="line">    MyUser mu_1 = ss.selectOne(<span class="string">"com.mybatis.mapper.UserMapper.selectUser"</span>, parameter_1);</span><br><span class="line">    System.out.println(<span class="string">"返回结果："</span> + mu_1);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2020/06/28/mybatis%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200628154136546.png" alt="image-20200628154136546"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = ? and password = ? </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt; Parameters: <span class="number">201301001</span>(<span class="built_in">String</span>), <span class="number">111111</span>(<span class="built_in">String</span>)</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - &lt;==      Total: <span class="number">1</span></span><br><span class="line">返回结果：MyUser [id=<span class="number">17</span>, account=<span class="number">201301001</span>, password=<span class="number">111111</span>, name=蒙奇D路飞]</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = ? and password = ? </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt; Parameters: <span class="number">201301001</span>(<span class="built_in">String</span>), <span class="number">111111</span> or account = <span class="string">'admin'</span> (<span class="built_in">String</span>)</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - &lt;==      Total: <span class="number">0</span></span><br><span class="line">返回结果：<span class="literal">null</span></span><br></pre></td></tr></table></figure><p>很明显，使用<strong>#{}</strong>的时候，即使传入了恶意参数，<strong>#{}</strong>只会将其作为一个占位符的参数，如上面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = ? and password = ? </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt; Parameters: <span class="number">201301001</span>(<span class="built_in">String</span>), <span class="number">111111</span> or account = <span class="string">'admin'</span> (<span class="built_in">String</span>)</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - &lt;==      Total: <span class="number">0</span></span><br><span class="line">转换为实际的SQL语句：select * <span class="keyword">from</span> user where account = <span class="string">'201301001'</span> and password = <span class="string">'111111 or account = '</span>admin<span class="string">''</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where account = <span class="string">'201301001'</span> and password = <span class="string">'111111 or account = '</span>admin<span class="string">''</span> </span><br><span class="line">select * from user where account = <span class="number">201301001</span> and password = <span class="number">111111</span> or account = <span class="string">'admin'</span></span><br></pre></td></tr></table></figure><p>现在是使用<strong>${}</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用$&#123;&#125; --&gt;</span><br><span class="line">  &lt;select id=<span class="string">"selectUser2"</span> parameterType=<span class="string">"String"</span> </span><br><span class="line">    resultType=<span class="string">"com.mybatis.po.MyUser"</span>&gt;</span><br><span class="line">    select * <span class="keyword">from</span> user where account = $&#123;account&#125; and password = $&#123;password&#125;</span><br><span class="line">  &lt;<span class="regexp">/select&gt;</span></span><br></pre></td></tr></table></figure><p>分别测试正常传参和拼接传参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用$&#123;&#125; 正常传参</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; parameter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parameter.put(<span class="string">"account"</span>, <span class="string">"201301001"</span>);</span><br><span class="line">    parameter.put(<span class="string">"password"</span>, <span class="string">"111111"</span>);</span><br><span class="line">    MyUser mu = ss.selectOne(<span class="string">"com.mybatis.mapper.UserMapper.selectUser2"</span>,parameter);</span><br><span class="line">    System.out.println(<span class="string">"返回结果："</span> + mu);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用$&#123;&#125; 拼接传参</span></span><br><span class="line">   <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; parameter2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   parameter2.put(<span class="string">"account"</span>, <span class="string">"201301001"</span>);</span><br><span class="line">   parameter2.put(<span class="string">"password"</span>, <span class="string">"111111"</span> + <span class="string">" or account = 'admin' "</span>);</span><br><span class="line">   MyUser mu2 = ss.selectOne(<span class="string">"com.mybatis.mapper.UserMapper.selectUser2"</span>, parameter2);</span><br><span class="line">   System.out.println(<span class="string">"返回结果："</span> + mu2);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2020/06/28/mybatis%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200628154158333.png" alt="image-20200628154158333"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = <span class="number">201301001</span> and password = <span class="number">111111</span> </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - ==&gt; Parameters: </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - &lt;==      Total: <span class="number">1</span></span><br><span class="line">返回结果：MyUser [id=<span class="number">17</span>, account=<span class="number">201301001</span>, password=<span class="number">111111</span>, name=蒙奇D路飞]</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = <span class="number">201301001</span> and password = <span class="number">111111</span> or account = <span class="string">'admin'</span> </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - ==&gt; Parameters: </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - &lt;==      Total: <span class="number">2</span></span><br><span class="line">返回结果：[MyUser [id=<span class="number">1</span>, account=admin, password=<span class="number">111111</span>, name=管理员], MyUser [id=<span class="number">17</span>, account=<span class="number">201301001</span>, password=<span class="number">111111</span>, name=蒙奇D路飞]]</span><br></pre></td></tr></table></figure><p>很明显，使用<strong>${}</strong>将参数拼接后在编译成SQL语句，不能防止SQL注入，查询出了有关account=admin的额外信息，这是很危险的。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>count(*)、count(1)、count(某字段)的区别</title>
      <link href="/2020/06/28/count-%E3%80%81count-1-%E3%80%81count-%E6%9F%90%E5%AD%97%E6%AE%B5-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/06/28/count-%E3%80%81count-1-%E3%80%81count-%E6%9F%90%E5%AD%97%E6%AE%B5-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><strong>count(*)：所有行进行统计，包括NULL行.COUNT(*)不单会进行全表扫描，也会对表的每个字段进行扫描。<br>count(1)：所有行进行统计，包括NULL行.其实就可以想成表中有这么一个字段,这个字段就是固定值1,count(1),就是计算一共有多少个1<br>count(column)：对column中非Null进行统计</strong></p><p>执行效率：<br>列名为主键，count(列名)会比count(1)快  </p><p>列名不为主键，count(1)会比count(列名)快  </p><p>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）  </p><p>如果有主键，则 select count（主键）的执行效率是最优的  </p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池底层&amp;四种类型&amp;参数含义</title>
      <link href="/2020/06/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B-%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/"/>
      <url>/2020/06/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B-%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>线程池底层都是通过 ThreadPoolExecutor 来实现的</p><h2 id="线程池的执行过程"><a href="#线程池的执行过程" class="headerlink" title="线程池的执行过程"></a>线程池的执行过程</h2><p>这里用一个图来说明线程池的执行流程</p><p><img src="https://upload-images.jianshu.io/upload_images/11183270-a01aea078d7f4178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>任务被提交到线程池，会先判断当前线程数量是否小于corePoolSize，如果小于则创建线程来执行提交的任务，否则将任务放入workQueue队列，如果workQueue满了，则判断当前线程数量是否小于maximumPoolSize,如果小于则创建线程执行任务，否则就会调用handler，以表示线程池拒绝接收任务。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>参数介绍</p><table><thead><tr><th align="left">参数</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td align="left">corePoolSize</td><td>int</td><td>核心线程数</td></tr><tr><td align="left">maximumPoolSize</td><td>int</td><td>最大线程数</td></tr><tr><td align="left">keepAliveTime</td><td>long</td><td>存活时间</td></tr><tr><td align="left">unit</td><td>TimeUnit</td><td>时间单位</td></tr><tr><td align="left">workQueue</td><td>BlockingQueue</td><td>存放线程的队列</td></tr><tr><td align="left">threadFactory</td><td>ThreadFactory</td><td>创建线程的工厂</td></tr><tr><td align="left">handler</td><td>RejectedExecutionHandler</td><td>多余的的线程处理器（拒绝策略）</td></tr></tbody></table><h3 id="核心线程数corePoolSize"><a href="#核心线程数corePoolSize" class="headerlink" title="核心线程数corePoolSize"></a>核心线程数corePoolSize</h3><p>这个参数表示线程池中的基本线程数量也就是核心线程数量。</p><h3 id="最大线程数maximumPoolSize-ˈmaeksɪməm"><a href="#最大线程数maximumPoolSize-ˈmaeksɪməm" class="headerlink" title="最大线程数maximumPoolSize[ˈmæksɪməm]"></a>最大线程数maximumPoolSize[ˈmæksɪməm]</h3><p>这个参数是线程池中允许创建的最大线程数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当使用有界队列时，且队列存放的任务满了，那么线程池会创建新的线程（最大不会超过这个参数所设置的值）。需要注意的是，**当使用无界队列时，这个参数是无效的。</span><br></pre></td></tr></table></figure><h3 id="线程存活时间keepAliveTime"><a href="#线程存活时间keepAliveTime" class="headerlink" title="线程存活时间keepAliveTime"></a>线程存活时间keepAliveTime</h3><p>这个就是非核心线程空闲时可以存活的时间，一旦超过这个时间，线程就会被销毁。</p><h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3><p>keepAliveTime的单位。</p><h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><p>当前线程数超过corePoolSize时，新的任务会处在等待状态，并存在workQueue中，BlockingQueue是一个先进先出的阻塞式队列实现，底层实现会涉及Java并发的AQS机制，有关于AQS的相关知识，我会单独写一篇，敬请期待。</p><h3 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h3><p>创建线程的工厂类，通常我们会自顶一个threadFactory设置线程的名称，这样我们就可以知道线程是由哪个工厂类创建的，可以快速定位。</p><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>线程池执行拒绝策略，当线数量达到maximumPoolSize大小，并且workQueue也已经塞满了任务的情况下，线程池会调用handler拒绝策略来处理请求。</p><p>系统默认的拒绝策略有以下几种：</p><ol><li>AbortPolicy：为线程池默认的拒绝策略，该策略直接抛异常处理。</li><li>DiscardPolicy：直接抛弃不处理。</li><li>DiscardOldestPolicy：丢弃队列中最老的任务。</li><li>CallerRunsPolicy：将任务分配给当前执行execute方法线程来处理。</li></ol><p>我们还可以自定义拒绝策略，只需要实现RejectedExecutionHandler接口即可，友好的拒绝策略实现有如下：</p><ol><li>将数据保存到数据，待系统空闲时再进行处理</li><li>将数据用日志进行记录，后由人工处理</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现有一个线程池，参数corePoolSize = 5，maximumPoolSize = 10，BlockingQueue阻塞队列长度为5，此时有4个任务同时进来，问：线程池会创建几条线程？</p><p>如果4个任务还没处理完，这时又同时进来2个任务，问：线程池又会创建几条线程还是不会创建？</p><p>如果前面6个任务还是没有处理完，这时又同时进来5个任务，问：线程池又会创建几条线程还是不会创建？</p><p><strong>线程池corePoolSize=5，线程初始化时不会自动创建线程，所以当有4个任务同时进来时，执行execute方法会新建【4】条线程来执行任务；</strong></p><p><strong>前面的4个任务都没完成，现在又进来2个队列，会新建【1】条线程来执行任务，这时poolSize=corePoolSize，还剩下1个任务，线程池会将剩下这个任务塞进阻塞队列中，等待空闲线程执行；</strong></p><p><strong>如果前面6个任务还是没有处理完，这时又同时进来了5个任务，此时还没有空闲线程来执行新来的任务，所以线程池继续将这5个任务塞进阻塞队列，但发现阻塞队列已经满了，核心线程也用完了，还剩下1个任务不知道如何是好，于是线程池只能创建【1】条“临时”线程来执行这个任务了；</strong></p><p><strong>这里创建的线程用“临时”来描述还是因为它们不会长期存在于线程池，它们的存活时间为keepAliveTime，此后线程池会维持最少corePoolSize数量的线程。</strong></p><h2 id="IO密集型和CPU密集型"><a href="#IO密集型和CPU密集型" class="headerlink" title="IO密集型和CPU密集型"></a>IO密集型和CPU密集型</h2><p>CPU密集型任务应配置尽可能小的线程，如配置CPU数目+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*CPU数目。</p><h3 id="线程池大小的设置"><a href="#线程池大小的设置" class="headerlink" title="线程池大小的设置"></a>线程池大小的设置</h3><h4 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h4><p>一个服务器有八个cpu，处理请求5ms，io操作200ms，理想情况下应该开什么线程？1s会处理多少请求？</p><p>8* U_cpu *(1+200/5)</p><ul><li><p>计算密集型任务：</p><p>N = N_cpu + 1</p><ul><li>加 1 的原因：当有一个线程偶尔故障时，额外的那个线程可以立即补上，保证CPU时钟不会被浪费</li></ul></li><li><p>包含 I/O 或其他阻塞操作：</p><p>N = N_cpu * U_cpu * (1 + W / C)</p><ul><li><p>N_cpu：CPU 的个数</p></li><li><p>U_cpu：目标 CPU 利用率</p></li><li><p>W / C：等待时间 (Wait) / 计算时间 (Compute)</p></li><li><p>获取 CPU 数目的方法：<code>int N_CPUS = Runtime.getRuntime().availableProcessors();</code></p></li></ul></li></ul><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><blockquote><p>假设要求一个系统的 TPS（Transaction Per Second 或者 Task Per Second）至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s</p></blockquote><p>如何设计线程个数，使得可以在1s内处理完20个Transaction？</p><p>20/(1/4)=80</p><h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><blockquote><p>计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？</p></blockquote><p>线程数 = 8 * (1 + 100/5) = 168 (个)</p><blockquote><p> 那如果DB的 QPS（Query Per Second）上限是1000，此时这个线程数又该设置为多大呢？</p></blockquote><p>一个线程每秒处理的任务数 1000/105,168个线程168*（1000/105）=1600QPS </p><p>168*(1000/1600)=105</p><h4 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h4><p>任务处理时间 100ms，服务器 4 核 8G 如何设计线程池达到 1000qps？任务是 90ms 在 IO，10ms 在计算的情况下怎么弄？全在计算呢？</p><p>一个线程一秒处理10个任务 10QPS  1000/10=100个线程   4*(1+90/10)=40个线程 </p><p>8 *(90/10+1）</p><h2 id="四种类型"><a href="#四种类型" class="headerlink" title="四种类型"></a>四种类型</h2><h3 id="1-FixedThreadPool"><a href="#1-FixedThreadPool" class="headerlink" title="1.FixedThreadPool"></a>1.FixedThreadPool</h3><p>所有任务只能使用固定大小的线程，超出的线程会在队列中等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>FixedThreadPool</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>都设置为参数nThreads，<code>keepAliveTime</code>为0L，表示多余的线程立刻终止，因为不会产生多余的线程它的任务队列采用的是LinkedBlockingQueue。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/3/1615a7fcb4af71c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>创建线程池的方法，在我们的程序中只需要，后面其他种类的同理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 参数是要线程池的线程最大值</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-CachedThreadPool"><a href="#2-CachedThreadPool" class="headerlink" title="2.CachedThreadPool"></a>2.CachedThreadPool</h3><p>一个任务创建一个线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code>的<code>corePoolSize</code>是0，<code>maximumPoolSize</code>是Integer.MAX_VALUE，也就是说<code>CachedThreadPool</code>没有核心线程，全部都是非核心线程，并且没有上限。<code>keepAliveTime</code>是60秒，就是说空闲线程等待新任务60秒，超时则销毁。此处用到的队列是阻塞队列<code>SynchronousQueue</code>[ˈsɪŋkrənəs],这个队列没有缓冲区，所以其中最多只能存在一个元素,有新的任务则阻塞等待。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616e2b8b89d971c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="3-SingleThreadExecutor"><a href="#3-SingleThreadExecutor" class="headerlink" title="3.SingleThreadExecutor"></a>3.SingleThreadExecutor</h3><p>相当于大小为 1 的 FixedThreadPool。其创建源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到总线程数和核心线程数都是1，所以就只有一个核心线程。该线程池才用链表阻塞队列<code>LinkedBlockingQueue</code>，先进先出原则，所以保证了任务的按顺序逐一进行。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616e43b53271671?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="4-ScheduledThreadPool"><a href="#4-ScheduledThreadPool" class="headerlink" title="4.ScheduledThreadPool"></a>4.ScheduledThreadPool</h3><p><code>ScheduledThreadPool</code>是一个能实现定时和周期性任务的线程池，它的创建源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里创建了<code>ScheduledThreadPoolExecutor</code>，继承自<code>ThreadPoolExecutor</code>，主要用于定时延时或者定期处理任务。<code>ScheduledThreadPoolExecutor</code>的构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">        super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">              new DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看出<code>corePoolSize</code>是传进来的固定值，<code>maximumPoolSize</code>无限大，因为采用的队列<code>DelayedWorkQueue</code>是无解的，所以<code>maximumPoolSize</code>参数无效。该线程池执行如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616e5ded43058a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>当执行<code>scheduleAtFixedRate</code>或者<code>scheduleWithFixedDelay</code>方法时，会向<code>DelayedWorkQueue</code>添加一个实现<code>RunnableScheduledFuture</code>接口的<code>ScheduledFutureTask</code>(任务的包装类)，并会检查运行的线程是否达到<code>corePoolSize</code>。如果没有则新建线程并启动<code>ScheduledFutureTask</code>，然后去执行任务。如果运行的线程达到了<code>corePoolSize</code>时，则将任务添加到<code>DelayedWorkQueue</code>中。<code>DelayedWorkQueue</code>会将任务进行排序，先要执行的任务会放在队列的前面。在跟此前介绍的线程池不同的是，当执行完任务后，会将<code>ScheduledFutureTask</code>中的<code>time</code>变量改为下次要执行的时间并放回到<code>DelayedWorkQueue</code>中。</p><h3 id="5-代码"><a href="#5-代码" class="headerlink" title="5.代码"></a>5.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化10个信号量在信号包中，让ABCD4个线程分别去获取</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F; ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(5);</span><br><span class="line">       &#x2F;&#x2F; ExecutorService threadPool &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">       &#x2F;&#x2F; ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 6; i++) &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;current thread name: &quot; + Thread.currentThread().getName());</span><br><span class="line">                Object object &#x3D; null;</span><br><span class="line">               &#x2F;&#x2F; System.out.print(&quot;result## &quot;+object.toString());</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化10个信号量在信号包中，让ABCD4个线程分别去获取</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService &#x3D; Executors.newScheduledThreadPool(1);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;current Time&quot; + System.currentTimeMillis());</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);</span><br><span class="line">        &#125;, 1, 3, TimeUnit.SECONDS);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-对比"><a href="#6-对比" class="headerlink" title="6.对比"></a>6.对比</h3><p>FixedThreadPool 适用于处理CPU密集型的任务，尽可能的少的分配线程，即适用执行长期的任务。</p><p>CachedThreadPool用于并发执行大量短期的小任务。</p><p>SingleThreadExecutor适用于串行执行任务的场景，一个任务一个任务地执行。</p><p>newScheduledThreadPool 周期性执行任务的场景，需要限制线程数量的场景</p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><h3 id="Abort-策略"><a href="#Abort-策略" class="headerlink" title="Abort 策略"></a>Abort 策略</h3><p>默认策略，新任务提交时直接抛出异常RejectedExecutionException，该异常可由调用者捕获。</p><h3 id="CallerRuns-策略"><a href="#CallerRuns-策略" class="headerlink" title="CallerRuns 策略:"></a>CallerRuns 策略:</h3><p>不会在线程池的线程中执行新的任务，而是在调用exector的线程中运行新的任务。</p><h3 id="Discard策略"><a href="#Discard策略" class="headerlink" title="Discard策略:"></a>Discard策略:</h3><p>直接丢弃新提交的任务；</p><h3 id="DiscardOlds策略"><a href="#DiscardOlds策略" class="headerlink" title="DiscardOlds策略:"></a>DiscardOlds策略:</h3><p>如果执行器没有关闭，队列头的任务将会被丢弃，然后执行器重新尝试执行任务（如果失败，则重复这一过程）；</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package concurrency.pool;</span><br><span class="line"> </span><br><span class="line">import java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line">import java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by li on 2016&#x2F;7&#x2F;2.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SaturationPolicy &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 线程池工作队列已满时，在不同饱和策略下表现</span><br><span class="line">     * @param handler 线程池工作队列饱和策略</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void policy(RejectedExecutionHandler handler)&#123;</span><br><span class="line">        &#x2F;&#x2F;基本线程2个，最大线程数为3，工作队列容量为5</span><br><span class="line">        ThreadPoolExecutor exec &#x3D; new ThreadPoolExecutor(2,3,0l, TimeUnit.MILLISECONDS,new LinkedBlockingDeque&lt;&gt;(5));</span><br><span class="line">        if (handler !&#x3D; null)&#123;</span><br><span class="line">            exec.setRejectedExecutionHandler(handler);&#x2F;&#x2F;设置饱和策略</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            exec.submit(new Task());&#x2F;&#x2F;提交任务</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        policy(new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">&#x2F;&#x2F;        policy((new ThreadPoolExecutor.CallerRunsPolicy()));</span><br><span class="line">&#x2F;&#x2F;        policy(new ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">&#x2F;&#x2F;        policy(new ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;自定义任务</span><br><span class="line">    static class Task implements Runnable &#123;</span><br><span class="line">        private static int count &#x3D; 0;</span><br><span class="line">        private int id &#x3D; 0;&#x2F;&#x2F;任务标识</span><br><span class="line">        public Task() &#123;</span><br><span class="line">            id &#x3D; ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public  void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);&#x2F;&#x2F;休眠3秒</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(&quot;线程被中断&quot; + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot; 任务：&quot; + id + &quot;\t 工作线程: &quot;+ Thread.currentThread().getName() + &quot; 执行完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有哪些工作队列"><a href="#有哪些工作队列" class="headerlink" title="有哪些工作队列"></a>有哪些工作队列</h2><h3 id="SynchronousQueue-ˈsɪŋkrənəs-："><a href="#SynchronousQueue-ˈsɪŋkrənəs-：" class="headerlink" title="SynchronousQueue [ˈsɪŋkrənəs]："></a>SynchronousQueue [ˈsɪŋkrənəs]：</h3><p>是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;2个核心线程最大线程为3的线程池</span><br><span class="line">        Executor executors &#x3D; new ThreadPoolExecutor(</span><br><span class="line">                2, 3, 30, TimeUnit.SECONDS,</span><br><span class="line">                new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                new RejectHandler());</span><br><span class="line">        execute(executors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void execute(Executor executors) &#123;</span><br><span class="line">        executors.execute(new NameRunnable(1));</span><br><span class="line">        executors.execute(new NameRunnable(2));</span><br><span class="line">        executors.execute(new NameRunnable(3));</span><br><span class="line">        executors.execute(new NameRunnable(4));</span><br><span class="line">        executors.execute(new NameRunnable(5));</span><br><span class="line">        executors.execute(new NameRunnable(6));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class NameRunnable implements Runnable &#123;</span><br><span class="line">        private int name;</span><br><span class="line"></span><br><span class="line">        public NameRunnable(int name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(name + &quot; is running... &quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + &quot; is end !!! &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;***</span><br><span class="line">     * 拒绝的Runnable</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static class RejectHandler implements RejectedExecutionHandler &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;</span><br><span class="line">            NameRunnable name &#x3D; (NameRunnable) r;</span><br><span class="line"></span><br><span class="line">            System.out.print(name.getName() + &quot; is rejected ^^\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200127233842102.png" alt="在这里插入图片描述"></p><h3 id="ArrayBlockingQueue："><a href="#ArrayBlockingQueue：" class="headerlink" title="ArrayBlockingQueue："></a>ArrayBlockingQueue：</h3><p>ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;2个核心线程最大线程为3的线程池,阻塞队列大小为2</span><br><span class="line">Executor executors &#x3D; new ThreadPoolExecutor(</span><br><span class="line">               2, 3, 30, TimeUnit.SECONDS,</span><br><span class="line">               new ArrayBlockingQueue&lt;&gt;(2),</span><br><span class="line">               new RejectHandler());</span><br><span class="line">       execute(executors);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200127234739185.png" alt="在这里插入图片描述"></p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;2个核心线程最大线程为3的线程池,阻塞队列大小为2</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Executor executors &#x3D; new ThreadPoolExecutor(</span><br><span class="line">                2, 6, 30, TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingQueue&lt;&gt;(2),</span><br><span class="line">                new RejectHandler());</span><br><span class="line">        execute(executors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void execute(Executor executors) &#123;</span><br><span class="line">        executors.execute(new NameRunnable(1));</span><br><span class="line">        executors.execute(new NameRunnable(2));</span><br><span class="line">        executors.execute(new NameRunnable(3));</span><br><span class="line">        executors.execute(new NameRunnable(4));</span><br><span class="line">        executors.execute(new NameRunnable(5));</span><br><span class="line">        executors.execute(new NameRunnable(6));</span><br><span class="line">        executors.execute(new NameRunnable(7));</span><br><span class="line">        executors.execute(new NameRunnable(8));</span><br><span class="line">        executors.execute(new NameRunnable(9));</span><br><span class="line">        executors.execute(new NameRunnable(10));</span><br><span class="line">        executors.execute(new NameRunnable(11));</span><br><span class="line">        executors.execute(new NameRunnable(12));</span><br><span class="line">        executors.execute(new NameRunnable(13));</span><br><span class="line">        executors.execute(new NameRunnable(14));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200128001009488.png" alt="在这里插入图片描述"></p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。</p><h2 id="如何优雅关闭线程池"><a href="#如何优雅关闭线程池" class="headerlink" title="如何优雅关闭线程池"></a>如何优雅关闭线程池</h2><h4 id="run和start"><a href="#run和start" class="headerlink" title="run和start"></a>run和start</h4><p><strong>线程的run()方法是由java虚拟机直接调用的，如果我们没有启动线程（没有调用线程的start()方法）而是在应用代码中直接调用run()方法，那么这个线程的run()方法其实运行在当前线程（即run()方法的调用方所在的线程）之中，而不是运行在其自身的线程中，从而违背了创建线程的初衷；</strong></p><p>下面是一个用来说明start()方法和run()方法的区别的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class WelcomThread extends Thread &#123;</span><br><span class="line">    &#x2F;&#x2F;在该方法中实现线程的任务逻辑</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;获取当前正在执行的线程名称</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">1234567</span><br><span class="line">public class TestDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread welcome &#x3D; new WelcomThread();  &#x2F;&#x2F;创建线程（动态规划）</span><br><span class="line">        welcome.run();  &#x2F;&#x2F;直接调用run()方法</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">         Thread welcome1 &#x3D; new WelcomThread();  &#x2F;&#x2F;创建线程</span><br><span class="line">         welcome1.start();  &#x2F;&#x2F;启动线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">main</span><br><span class="line">Thread-1</span><br></pre></td></tr></table></figure><h4 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a>Runnable vs Callable</h4><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是<strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 *<em><code>Runnable</code> 接口*</em>，这样代码看起来会更加简洁。</p><p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。（<code>Executors.callable（Runnable task</code>）或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Runnable.java</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 被线程执行，没有返回值也无法抛出异常</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line">Callable.java</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 计算结果，或在无法这样做时抛出异常。</span><br><span class="line">     * @return 计算得出的结果</span><br><span class="line">     * @throws 如果无法计算结果，则抛出异常</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a>execute() vs submit()</h4><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><p>我们以<strong><code>AbstractExecutorService</code></strong>接口中的一个 <code>submit</code> 方法为例子来看看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>我们再来看看<code>execute()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="shutdown-VS-shutdownNow"><a href="#shutdown-VS-shutdownNow" class="headerlink" title="shutdown()VS shutdownNow()"></a>shutdown()VS shutdownNow()</h4><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h4 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a>isTerminated() VS isShutdown()</h4><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap解析</title>
      <link href="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁<br>（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发<br>度更高（并发度就是 Segment 的个数）。Segment 继承自 ReentrantLock。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">   final int hash;</span><br><span class="line">   final K key;</span><br><span class="line">   volatile V value;</span><br><span class="line">   volatile HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁<br>（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发<br>度更高（并发度就是 Segment 的个数）。<br><strong>Segment 继承自 ReentrantLock。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line">   private static final long serialVersionUID &#x3D; 2249069246763182397L;</span><br><span class="line">   static final int MAX_SCAN_RETRIES &#x3D;</span><br><span class="line">   Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;</span><br><span class="line">   transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">   transient int count;</span><br><span class="line">   transient int modCount;</span><br><span class="line">   transient int threshold;</span><br><span class="line">   final float loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br></pre></td></tr></table></figure><img src="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/1.png" class title="如图"><p>HashEntry跟HashMap差不多的，但是不同点是，他使用volatile去修饰了他的数据Value还有下一个节点next。</p><h2 id="并发度高的原因"><a href="#并发度高的原因" class="headerlink" title="并发度高的原因"></a>并发度高的原因</h2><p>原理上来说，ConcurrentHashMap 采用了<strong>分段锁</strong>技术，其中 Segment 继承于 ReentrantLock。</p><p>不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>concurrentHashMap的put 方法首先定位到 某个Segment，调用segment的put方法在对应的segment做插入操作。segment put实现过程：</p><ol><li>获取锁，保证put操作的线程安全；</li><li>定位到HashEntry数组中具体的HashEntry；</li></ol><p>然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，在扩容的时候，首先创建一个容量是原来容量两倍的数组，将原数组的元素再散列后插入到新的数组里。为了高效，ConcurrentHashMap只对某个Segment进行扩容，不会对整个容器扩容。第二步定位添加元素的位置，然后将其放入数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ConcurrentHashMap#put</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">　　Segment&lt;K,V&gt; s;</span><br><span class="line">　　if (value &#x3D;&#x3D; null)</span><br><span class="line">　　　　throw new NullPointerException();</span><br><span class="line">　　int hash &#x3D; hash(key);&#x2F;&#x2F;根据散列函数，计算出key值的散列值</span><br><span class="line">　　int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;&#x2F;&#x2F;这个操作就是定位Segment的数组下标，jdk1.7之前是segmentFor返回Segment，1.7之后直接就取消了这个方法，直接计算数组下标，然后通过偏移量底层操作获取Segment</span><br><span class="line">　　if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck</span><br><span class="line">　　　　　　(segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment</span><br><span class="line">　　　　s &#x3D; ensureSegment(j);&#x2F;&#x2F;通过便宜量定位不到就调用ensureSegment方法定位Segment</span><br><span class="line">　　return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过key定位到Segment，之后在对应的Segment中进行具体的put</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">        int index &#x3D; (tab.length - 1) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class="line">            if (e !&#x3D; null) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue &#x3D; e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value &#x3D; value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                e &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (node !&#x3D; null)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                int c &#x3D; count + 1;</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                else</span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count &#x3D; c;</span><br><span class="line">                oldValue &#x3D; null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get 逻辑比较简单，只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p><p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值,<strong>整个过程都不需要加锁</strong>。。</p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。<br>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>相对于HashMap的resize，ConcurrentHashMap的rehash原理类似，但是Doug Lea为rehash做了一定的优化，避免让所有的节点都进行复制操作：由于扩容是基于2的幂指来操作，假设扩容前某HashEntry对应到Segment中数组的index为i，数组的容量为capacity，那么扩容后该HashEntry对应到新数组中的index只可能为i或者i+capacity，因此大多数HashEntry节点在扩容前后index可以保持不变。基于此，rehash方法中会定位第一个后续所有节点在扩容后index都保持不变的节点，然后将这个节点之前的所有节点重排即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">void rehash() &#123;</span><br><span class="line">HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;</span><br><span class="line">int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">if (oldCapacity &gt;&#x3D; MAXIMUM_CAPACITY)</span><br><span class="line">return;</span><br><span class="line"> </span><br><span class="line">&#x2F;*</span><br><span class="line"> * Reclassify nodes in each list to new Map.  Because we are</span><br><span class="line"> * using power-of-two expansion, the elements from each bin</span><br><span class="line"> * must either stay at same index, or move with a power of two</span><br><span class="line"> * offset. We eliminate unnecessary node creation by catching</span><br><span class="line"> * cases where old nodes can be reused because their next</span><br><span class="line"> * fields won&#39;t change. Statistically, at the default</span><br><span class="line"> * threshold, only about one-sixth of them need cloning when</span><br><span class="line"> * a table doubles. The nodes they replace will be garbage</span><br><span class="line"> * collectable as soon as they are no longer referenced by any</span><br><span class="line"> * reader thread that may be in the midst of traversing table</span><br><span class="line"> * right now.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;*</span><br><span class="line"> * 其实这个注释已经解释的很清楚了，主要就是因为扩展是按照2的幂次方</span><br><span class="line"> * 进行扩展的，所以扩展前在同一个桶中的元素，现在要么还是在原来的</span><br><span class="line"> * 序号的桶里，或者就是原来的序号再加上一个2的幂次方，就这两种选择。</span><br><span class="line"> * 所以原桶里的元素只有一部分需要移动，其余的都不要移动。该函数为了</span><br><span class="line"> * 提高效率，就是找到最后一个不在原桶序号的元素，那么连接到该元素后面</span><br><span class="line"> * 的子链表中的元素的序号都是与找到的这个不在原序号的元素的序号是一样的</span><br><span class="line"> * 那么就只需要把最后一个不在原序号的元素移到新桶里，那么后面跟的一串</span><br><span class="line"> * 子元素自然也就连接上了，而且序号还是相同的。在找到的最后一个不在</span><br><span class="line"> * 原桶序号的元素之前的元素就需要逐个的去遍历，加到和原桶序号相同的新桶上</span><br><span class="line"> * 或者加到偏移2的幂次方的序号的新桶上。这个都是新创建的元素，因为</span><br><span class="line"> * 只能在表头插入元素。这个原因可以参考</span><br><span class="line"> * 《探索 ConcurrentHashMap 高并发性的实现机制》中的讲解</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line">HashEntry&lt;K,V&gt;[] newTable &#x3D; HashEntry.newArray(oldCapacity&lt;&lt;1);</span><br><span class="line">threshold &#x3D; (int)(newTable.length * loadFactor);</span><br><span class="line">int sizeMask &#x3D; newTable.length - 1;</span><br><span class="line">for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">&#x2F;&#x2F; We need to guarantee that any existing reads of old Map can</span><br><span class="line">&#x2F;&#x2F;  proceed. So we cannot yet null out each bin.</span><br><span class="line">HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];</span><br><span class="line"> </span><br><span class="line">if (e !&#x3D; null) &#123;</span><br><span class="line">HashEntry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">int idx &#x3D; e.hash &amp; sizeMask;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;  Single node on list</span><br><span class="line">if (next &#x3D;&#x3D; null)</span><br><span class="line">newTable[idx] &#x3D; e;</span><br><span class="line"> </span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; Reuse trailing consecutive sequence at same slot</span><br><span class="line">HashEntry&lt;K,V&gt; lastRun &#x3D; e;</span><br><span class="line">int lastIdx &#x3D; idx;</span><br><span class="line">for (HashEntry&lt;K,V&gt; last &#x3D; next;</span><br><span class="line"> last !&#x3D; null;</span><br><span class="line"> last &#x3D; last.next) &#123;</span><br><span class="line">int k &#x3D; last.hash &amp; sizeMask;</span><br><span class="line">&#x2F;&#x2F; 这里就是遍历找到最后一个不在原桶序号处的元素</span><br><span class="line">if (k !&#x3D; lastIdx) &#123;</span><br><span class="line">lastIdx &#x3D; k;</span><br><span class="line">lastRun &#x3D; last;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 把最后一个不在原桶序号处的元素赋值到新桶中</span><br><span class="line">&#x2F;&#x2F; 由于链表本身的特性，那么该元素后面的元素也都能连接过来</span><br><span class="line">&#x2F;&#x2F; 并且能保证后面的这些元素在新桶中的序号都是和该元素是相等的</span><br><span class="line">&#x2F;&#x2F; 因为上面的遍历就是确保了该元素后面的元素的序号都是和这个元素</span><br><span class="line">&#x2F;&#x2F; 的序号是相等的。不然遍历中还会重新赋值lastIdx</span><br><span class="line">newTable[lastIdx] &#x3D; lastRun;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Clone all remaining nodes</span><br><span class="line">&#x2F;&#x2F; 这个就是把上面找到的最后一个不在原桶序号处的元素之前的元素赋值到</span><br><span class="line">&#x2F;&#x2F; 新桶上，注意都是把元素添加到新桶的表头处</span><br><span class="line">for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;</span><br><span class="line">int k &#x3D; p.hash &amp; sizeMask;</span><br><span class="line">HashEntry&lt;K,V&gt; n &#x3D; newTable[k];</span><br><span class="line">newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(p.key, p.hash,</span><br><span class="line"> n, p.value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">table &#x3D; newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-8他的数据结构"><a href="#1-8他的数据结构" class="headerlink" title="1.8他的数据结构"></a>1.8他的数据结构</h2><p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p><p>跟HashMap很像，也把之前的HashEntry改成了Node，但是作用不变，把值和next采用了volatile去修饰，保证了可见性，并且也引入了红黑树，在链表大于一定值的时候会转换（默认是8）。</p><p>① 取消分段锁机制，进一步降低冲突概率。② 引入红黑树结构，同一个哈希槽上的元素个数超过一定阈值后，单向链表改为红黑树结构。③ 使用了更加优化的方式统计集合内的元素数量。具体优化表现在：在 put、resize 和 size 方法中设计元素总数的更新和计算都避免了锁，使用 CAS 代替。</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><p>①根据 key 计算出 hashcode，判断是否需要进行初始化。 。</p><p>②<code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p><p>③如果都不满足，则利用 synchronized 锁写入数据。</p><p>④如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        int binCount &#x3D; 0;</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">                tab &#x3D; initTable();</span><br><span class="line">            else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                    break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                synchronized (f) &#123;</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123;</span><br><span class="line">                            binCount &#x3D; 1;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal &#x3D; e.val;</span><br><span class="line">                                    if (!onlyIfAbsent)</span><br><span class="line">                                        e.val &#x3D; value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                    pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount &#x3D; 2;</span><br><span class="line">                            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) !&#x3D; null) &#123;</span><br><span class="line">                                oldVal &#x3D; p.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    p.val &#x3D; value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (binCount !&#x3D; 0) &#123;</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    if (oldVal !&#x3D; null)</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><img src="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/2.png" class title="如图"><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p><code>get</code> 同样不需要同步</p><p>1.根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p><p>2.如果是红黑树那就按照树的方式获取值。</p><p>3.就不满足那就按照链表的方式遍历获取值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">      int h &#x3D; spread(key.hashCode());</span><br><span class="line">      if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">          (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;</span><br><span class="line">          if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;</span><br><span class="line">              if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))</span><br><span class="line">                  return e.val;</span><br><span class="line">          &#125;</span><br><span class="line">          else if (eh &lt; 0)</span><br><span class="line">              return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">          while ((e &#x3D; e.next) !&#x3D; null) &#123;</span><br><span class="line">              if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                  ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                  return e.val;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><img src="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/3.png" class title="如图"><h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><h2 id="扩容时候遇到put操作怎么办"><a href="#扩容时候遇到put操作怎么办" class="headerlink" title="扩容时候遇到put操作怎么办"></a>扩容时候遇到put操作怎么办</h2><p>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索</p><p><strong>ForwardingNode</strong>： 是临时节点，这个节点会出现在扩容的时候，不存储实际的数据数据。</p><p>这是一个真正的辅助类，该类仅仅只存活在ConcurrentHashMap扩容操作时。只是一个标志节点，并且指向nextTable，它提供find方法而已。该类也是集成Node节点，其hash为-1，key、value、next均为null。如下：</p><pre><code>static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; {    final Node&lt;K,V&gt;[] nextTable;    ForwardingNode(Node&lt;K,V&gt;[] tab) {        super(MOVED, null, null, null);        this.nextTable = tab;    }    Node&lt;K,V&gt; find(int h, Object k) {    // loop to avoid arbitrarily deep recursion on forwarding nodes    outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) {        Node&lt;K,V&gt; e; int n;        if (k == null || tab == null || (n = tab.length) == 0 ||                (e = tabAt(tab, (n - 1) &amp; h)) == null)            return null;        for (;;) {            int eh; K ek;            if ((eh = e.hash) == h &amp;&amp;                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))                return e;            if (eh &lt; 0) {                if (e instanceof ForwardingNode) {                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;                    continue outer;                }                else                    return e.find(h, k);            }            if ((e = e.next) == null)                return null;        }    }}}</code></pre><p>如果Hash桶被迁移到新的table中，会在旧的table插入一个ForwardingNode临时节点，内部会指向新的table。</p><p>当读操作碰到ForwardingNode，会通过ForwardingNode内部的nextTable找到新的table，继续读。</p><p>当写操作碰到ForwadingNode，加入帮助扩容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span><br><span class="line">private final void tryPresize(int size) &#123;</span><br><span class="line">    &#x2F;&#x2F; c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span><br><span class="line">    int c &#x3D; (size &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span><br><span class="line">    int sc;</span><br><span class="line">    while ((sc &#x3D; sizeCtl) &gt;&#x3D; 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab &#x3D; table; int n;</span><br><span class="line">        &#x2F;&#x2F; 这个 if 分支和之前说的初始化数组的代码基本上是一样的</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            n &#x3D; (sc &gt; c) ? sc : c;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (table &#x3D;&#x3D; tab) &#123;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        table &#x3D; nt;</span><br><span class="line">                        sc &#x3D; n - (n &gt;&gt;&gt; 2); &#x2F;&#x2F; 0.75 * n</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    sizeCtl &#x3D; sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (c &lt;&#x3D; sc || n &gt;&#x3D; MAXIMUM_CAPACITY)</span><br><span class="line">            break;</span><br><span class="line">        else if (tab &#x3D;&#x3D; table) &#123;</span><br><span class="line">            int rs &#x3D; resizeStamp(n);</span><br><span class="line">            if (sc &lt; 0) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||</span><br><span class="line">                    transferIndex &lt;&#x3D; 0)</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span><br><span class="line">                &#x2F;&#x2F; 此时 nextTab 不为 null</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span><br><span class="line">            &#x2F;&#x2F; 调用 transfer 方法，此时 nextTab 参数为 null</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap解析</title>
      <link href="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>内部包含了一个 Entry 类型的数组 table,1.8之后改成Node。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;transient Entry[] table;</span><br><span class="line">  transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当<br>成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结<br>果相同的 Entry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//key的hash值，put和get的时候都需要用到它来确定元素在数组中的位置</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="comment">//指向单链表的下一个节点</span></span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="keyword">this</span>.hash = hash;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><img src="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/2.png" class title="流程图"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法，会先调用一个hash()方法，得到当前key的一个hash值，</span></span><br><span class="line"><span class="comment">//用于确定当前key应该存放在数组的哪个下标位置</span></span><br><span class="line"><span class="comment">//这里的 hash方法，我们姑且先认为是key.hashCode()，其实不是的，一会儿细讲</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把hash值和当前的key，value传入进来</span></span><br><span class="line"><span class="comment">//这里onlyIfAbsent如果为true，表明不能修改已经存在的值，因此我们传入false</span></span><br><span class="line"><span class="comment">//evict只有在方法 afterNodeInsertion(boolean evict) &#123; &#125;用到，可以看到它是一个空实现，因此不用关注这个参数</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">//判断table是否为空，如果空的话，会先调用resize扩容</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">n = (tab = resize()).length;</span><br><span class="line"><span class="comment">//根据当前key的hash值找到它在数组中的下标，判断当前下标位置是否已经存在元素，</span></span><br><span class="line"><span class="comment">//若没有，则把key、value包装成Node节点，直接添加到此位置。</span></span><br><span class="line"><span class="comment">// i = (n - 1) &amp; hash 是计算下标位置的，为什么这样算，后边讲</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">//如果当前位置已经有元素了，分为三种情况。</span></span><br><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">//1.当前位置元素的hash值等于传过来的hash，并且他们的key值也相等，</span></span><br><span class="line"><span class="comment">//则把p赋值给e，跳转到①处，后续需要做值的覆盖处理</span></span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">e = p;</span><br><span class="line"><span class="comment">//2.如果当前是红黑树结构，则把它加入到红黑树 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//3.说明此位置已存在元素，并且是普通链表结构，则采用尾插法，把新节点加入到链表尾部</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果头结点的下一个节点为空，则插入新节点</span></span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果在插入的过程中，链表长度超过了8，则转化为红黑树</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line"><span class="comment">//插入成功之后，跳出循环，跳转到①处</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若在链表中找到了相同key的话，直接退出循环，跳转到①处</span></span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">p = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//① </span></span><br><span class="line"><span class="comment">//1.说明发生了碰撞，e代表的是旧值，因此节点位置不变，但是需要替换为新值</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">V oldValue = e.value;</span><br><span class="line"><span class="comment">//用新值替换旧值，并返回旧值。</span></span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">e.value = value;</span><br><span class="line"><span class="comment">//看方法名字即可知，这是在node被访问之后需要做的操作。其实此处是一个空实现，</span></span><br><span class="line"><span class="comment">//只有在 LinkedHashMap才会实现，用于实现根据访问先后顺序对元素进行排序，hashmap不提供排序功能</span></span><br><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="comment">//void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span></span><br><span class="line">afterNodeAccess(e);</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fail-fast机制</span></span><br><span class="line">++modCount;</span><br><span class="line"><span class="comment">//如果当前数组中的元素个数超过阈值，则扩容</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">resize();</span><br><span class="line"><span class="comment">//同样的空实现</span></span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hash方法"><a href="#Hash方法" class="headerlink" title="Hash方法"></a>Hash方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">两个值进行与运算，结果会趋向于<span class="number">0</span>；或运算，结果会趋向于<span class="number">1</span>；而只有异或运算，<span class="number">0</span>和<span class="number">1</span>的比例可以达到<span class="number">1</span>:<span class="number">1</span>的平衡状态。（非呢？别扯犊子了，两个值怎么做非运算。。。）</span><br><span class="line">所以，异或运算之后，可以让结果的随机性更大，而随机性大了之后，哈希碰撞的概率当然就更小了</span><br></pre></td></tr></table></figure><p>这里，会先判断key是否为空，若为空则返回0。这也说明了hashMap是支持key传 null 的。若非空，则先计算key的hashCode值，赋值给h，然后把h右移16位，并与原来的h进行异或处理。为什么要这样做，这样做有什么好处呢？</p><p>可以看到，其实相当于，我们把高16位值和当前h的低16位进行了混合，这样可以尽量保留高16位的特征，从而降低哈希碰撞的概率。</p><p>思考一下，为什么这样做，就可以降低哈希碰撞的概率呢？先别着急，我们需要结合 i = (n - 1) &amp; hash 这一段运算来理解。</p><p> <strong>i = (n - 1) &amp; hash</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y :       10110010</span><br><span class="line">x-1 :     00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure><p>这个性质和 y 对 x 取模效果是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y :   10110010</span><br><span class="line">x :   00010000</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><ul><li>首先将key hash之后取得所定位的桶</li><li>如果桶为空，则直接返回null</li><li>否则判断桶的第一个位置（有可能是链表、红黑树）的key是否为查询的key，是就直接返回value</li><li>如果第一个不匹配，则判断它的下一个是红黑树还是链表</li><li>红黑树就按照树的查找方式返回值</li><li>不然就按照链表的方式遍历匹配返回值<img src="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/3.png" class title="流程图"></li></ul><h3 id="为什么HashMap链表会形成死循环"><a href="#为什么HashMap链表会形成死循环" class="headerlink" title="为什么HashMap链表会形成死循环"></a>为什么HashMap链表会形成死循环</h3><p>准确的讲应该是 JDK1.7 的 HashMap 链表会有死循环的可能，因为JDK1.7是采用的头插法，在多线程环境下有可能会使链表形成环状，从而导致死循环。JDK1.8做了改进，用的是尾插法，不会产生死循环。</p><h3 id="JDK7与JDK8中HashMap的不同点"><a href="#JDK7与JDK8中HashMap的不同点" class="headerlink" title="JDK7与JDK8中HashMap的不同点"></a>JDK7与JDK8中HashMap的不同点</h3><ul><li><p>JDK8中使用了红黑树</p></li><li><p>JDK7中链表的插入使用的头插法（扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致CPU飙升），JDK8中链表使用的尾插法（JDK8中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法</p></li></ul><h2 id="那为啥用16不用别的呢？"><a href="#那为啥用16不用别的呢？" class="headerlink" title="那为啥用16不用别的呢？"></a>那为啥用16不用别的呢？</h2><p>因为在使用是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。</p><p>只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。这是为了<strong>实现均匀分布</strong>。</p><h2 id="为什么是0-75？"><a href="#为什么是0-75？" class="headerlink" title="为什么是0.75？"></a>为什么是0.75？</h2><p>HashMap负载因子为什么是0.75？<br>HashMap有一个初始容量大小，默认是16<br>static final int DEAFULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16<br>为了减少冲突概率，当HashMap的数组长度达到一个临界值就会触发扩容，把所有元素rehash再放回容器中，这是一个非常耗时的操作。<br>而这个临界值由负载因子和当前的容量大小来决定：<br>DEFAULT_INITIAL_CAPACITY<em>DEFAULT_LOAD_FACTOR<br>即默认情况下数组长度是16</em>0.75=12时，触发扩容操作。<br>所以使用hash容器时尽量预估自己的数据量来设置初始值。<br>那么，为什么负载因子要默认为0.75，在HashMap注释中有这么一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Ideally, under random hashCodes, the frequency of</span><br><span class="line">\* nodes in bins follows a Poisson distribution</span><br><span class="line">\* (http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Poisson_distribution) with a</span><br><span class="line">\* parameter of about 0.5 on average for the default resizing</span><br><span class="line">\* threshold of 0.75, although with a large variance because of</span><br><span class="line">\* resizing granularity. Ignoring variance, the expected</span><br><span class="line">\* occurrences of list size k are (exp(-0.5) * pow(0.5, k) &#x2F;</span><br><span class="line">\* factorial(k)). The first values are:</span><br><span class="line">*</span><br><span class="line">\* 0:  0.60653066</span><br><span class="line">\* 1:  0.30326533</span><br><span class="line">\* 2:  0.07581633</span><br><span class="line">\* 3:  0.01263606</span><br><span class="line">\* 4:  0.00157952</span><br><span class="line">\* 5:  0.00015795</span><br><span class="line">\* 6:  0.00001316</span><br><span class="line">\* 7:  0.00000094</span><br><span class="line">\* 8:  0.00000006</span><br><span class="line">\* more: less than 1 in ten million</span><br></pre></td></tr></table></figure><p>在理想情况下，使用随机哈希吗，节点出现的频率在hash桶中遵循泊松分布，同时给出了桶中元素的个数和概率的对照表。<br>从上表可以看出当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为负载因子，每个碰撞位置的链表长度超过8个是几乎不可能的。<br>hash容器指定初始容量尽量为2的幂次方。<br>HashMap负载因子为0.75是空间和时间成本的一种折中。</p><h2 id="什么时候变成红黑树"><a href="#什么时候变成红黑树" class="headerlink" title="什么时候变成红黑树"></a>什么时候变成红黑树</h2><p>一个是链表长度到8,一个是数组长度到64.</p><h2 id="HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？"><a href="#HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？" class="headerlink" title="HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？"></a>HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？</h2><p>1.Hashtable</p><p>2.ConcurrentHashMap</p><p>不过出于线程并发度的原因，我都会舍弃前两者使用最后的ConcurrentHashMap，他的性能和效率明显高于前两者。</p><h2 id="Hashtable效率低"><a href="#Hashtable效率低" class="headerlink" title="Hashtable效率低"></a>Hashtable效率低</h2><p>他在对数据操作的时候都会上锁，所以效率比较低下。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p><strong>resize 方法：扩容数组</strong>,分为两个部分，一个是扩容数组，一个是重新规划长度。</p><p>重新规划长度和阈值，如果长度发生了变化，部分数据节点也要重新排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 HashMap实行了懒加载, 新建HashMap时不会对table进行赋值, 而是到第一次插入时, 进行resize时构建table;</span><br><span class="line">2 当HashMap.size 大于 threshold时, 会进行resize;threshold的值我们在上一次分享中提到过: 当第一次构建时, 如果没有指定HashMap.table的初始长度, 就用默认值16, 否则就是指定的值; 然后不管是第一次构建还是后续扩容, threshold &#x3D; table.length * loadFactor;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr &#x3D; threshold;</span><br><span class="line">        int newCap, newThr &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;如果原table不为空</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果原容量已经达到最大容量了，无法进行扩容，直接返回</span><br><span class="line">            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;设置新容量为旧容量的两倍</span><br><span class="line">            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                &#x2F;&#x2F;阈值也变为原来的两倍</span><br><span class="line">                newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">        * 从构造方法我们可以知道</span><br><span class="line">        * 如果没有指定initialCapacity, 则不会给threshold赋值, 该值被初始化为0</span><br><span class="line">    * 如果指定了initialCapacity, 该值被初始化成大于initialCapacity的最小的2的次幂</span><br><span class="line">* 这里这种情况指的是原table为空，并且在初始化的时候指定了容量，</span><br><span class="line">* 则用threshold作为table的实际大小</span><br><span class="line">*&#x2F;</span><br><span class="line">        else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">            newCap &#x3D; oldThr;</span><br><span class="line">        &#x2F;&#x2F;构造方法中没有指定容量，则使用默认值</span><br><span class="line">        else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 计算指定了initialCapacity情况下的新的 threshold</span><br><span class="line">        if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold &#x3D; newThr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**从以上操作我们知道, 初始化HashMap时, </span><br><span class="line">    *  如果构造函数没有指定initialCapacity, 则table大小为16</span><br><span class="line">    *  如果构造函数指定了initialCapacity, 则table大小为threshold,</span><br><span class="line">    *  即大于指定initialCapacity的最小的2的整数次幂</span><br><span class="line">    </span><br><span class="line">    *  从下面开始, 初始化table或者扩容, 实际上都是通过新建一个table来完成</span><br><span class="line">    *&#x2F; </span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table &#x3D; newTab;</span><br><span class="line">        if (oldTab !&#x3D; null) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                  &#x2F;** 这里注意, table中存放的只是Node的引用,这里将oldTab[j]&#x3D;null只是清除旧表的引用, </span><br><span class="line">                   * 但是真正的node节点还在, 只是现在由e指向它</span><br><span class="line">                   *&#x2F;</span><br><span class="line">                    oldTab[j] &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F;桶中只有一个节点，直接放入新桶中</span><br><span class="line">                    if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                    &#x2F;&#x2F;桶中为红黑树，则对树进行拆分，对树的操作有机会再讲</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    &#x2F;&#x2F;桶中为链表，对链表进行拆分</span><br><span class="line">                    else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    &#x2F;&#x2F;下面为对链表的拆分，我们单独来讲一下。</span><br><span class="line">                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next &#x3D; e.next;</span><br><span class="line">                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                    loHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; e;</span><br><span class="line">                                loTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                    hiHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; e;</span><br><span class="line">                                hiTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                        if (loTail !&#x3D; null) &#123;</span><br><span class="line">                            loTail.next &#x3D; null;</span><br><span class="line">                            newTab[j] &#x3D; loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                            hiTail.next &#x3D; null;</span><br><span class="line">                            newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>重新规划长度</strong></p><p>①  判断原来的table是否为空，是的话判断: 如果原容量大于等于最大容量，那么将阈值设为 Integer 的最大值，并且 return 终止扩容，由于 size 不可能超过该值因此之后不会再发生扩容。如果 size 超出扩容阈值，把 table 容量增加为之前的2倍。否则 把 table 容量增加为之前的2倍。</p><p>② 判断oldThr&gt;0, 如果是hashmap传入指定的initialCapacity，这个初始值会给到oldThr.</p><p>③ 否则的话 传入默认的容量和负载因子</p><p><strong>重新排列数据节点</strong></p><p>① 如果节点为 null 值则不进行处理。② 否则如果节点没有next节点，那么重新计算其散列值然后存入新的 table 数组中。③ 如果节点为 TreeNode 节点，那么调用 split 方法进行处理，该方法用于对红黑树调整，如果太小会退化回链表。④ 如果节点是链表节点，需要将链表拆分为 超出旧容量的链表和未超出容量的链表。对于<code>hash &amp; oldCap == 0</code> 的部分不需要做处理，反之需要放到新的下标位置上，新下标 = 旧下标 + 旧容量。</p><p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capacity : 00010000</span><br><span class="line">new capacity : 00100000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   old:</span><br><span class="line">   10: 0000 1010</span><br><span class="line">   15: 0000 1111</span><br><span class="line">    &amp;: 0000 1010    </span><br><span class="line">    </span><br><span class="line">   new:</span><br><span class="line">   10: 0000 1010</span><br><span class="line">   31: 0001 1111</span><br><span class="line">    &amp;: 0000 1010    </span><br><span class="line"></span><br><span class="line">从上面的示例可以很轻易的看出, 两次indexFor()的差别只是第二次参与位于比第一次左边有一位从0变为1, 而这个变化的1刚好是oldCap, 那么只需要判断原key的hash这个位上是否为1: 若是1, 则需要移动至oldCap + i的槽位, 若为0, 则不需要移动;</span><br></pre></td></tr></table></figure><p>对于一个 Key<br>它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；<br>如果为 1，那么得到的结果为原来的结果 +16。</p><p><strong>线程不安全：</strong>Java 7 扩容时 resize 方法调用的 transfer 方法中使用头插法迁移元素，多线程会导致 Entry 链表形成环形数据结构，Entry 节点的 next 永远不为空，引起死循环。Java 8 在 resize 方法中完成扩容，并且改用了尾插法，不会产生死循环的问题，但是在多线程的情况下还是可能会导致数据覆盖的问题，因此依旧线程不安全。</p><h2 id="为啥Hashtable-是不允许键或值为-null-的，HashMap-的键值则都可以为-null？"><a href="#为啥Hashtable-是不允许键或值为-null-的，HashMap-的键值则都可以为-null？" class="headerlink" title="为啥Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null？"></a>为啥Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null？</h2><p>Hashtable使用的是<strong>安全失败机制（fail-safe）</strong>，这种机制会使你此次读到的数据不一定是最新的数据。</p><p>如果你使用null值，就会使得其无法判断对应的key是不存在还是为空</p><h2 id="和HashTable的对比"><a href="#和HashTable的对比" class="headerlink" title="和HashTable的对比"></a>和HashTable的对比</h2><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p>fail-fast的字面意思是“快速失败”。在迭代器遍历元素的过程中，需要比较操作前后 modCount 是否改变，如果改变了说明集合结构被改变，需要抛出ConcurrentModificationException,防止继续遍历。</p><h2 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h2><p>当我们对集合结构上做出改变的时候，fail-fast机制就会抛出异常。但是，对于采用fail-safe机制来说，就不会抛出异常(大家估计看到safe两个字就知道了)。</p><p>这是因为，当集合的结构被改变的时候，fail-safe机制会在复制原集合的一份数据出来，然后在复制的那份数据遍历。</p><p>因此，虽然fail-safe不会抛出异常，但存在以下缺点：</p><p>1.复制时需要额外的空间和时间上的开销。</p><p>2.不能保证遍历的是最新内容</p><h2 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h2><p>resize方法</p><pre><code>void resize(int newCapacity) {    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    if (oldCapacity == MAXIMUM_CAPACITY) {        threshold = Integer.MAX_VALUE;        return;    }    Entry[] newTable = new Entry[newCapacity];    boolean oldAltHashing = useAltHashing;    useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;            (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);    boolean rehash = oldAltHashing ^ useAltHashing;//判断是否需要对原node重新hash定位table的index    transfer(newTable, rehash); //扩容核心方法    table = newTable;    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);}</code></pre><p>JDK7的transfer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新table的容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//遍历原table</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            <span class="comment">//保存下一次循环的 Entry&lt;K,V&gt;</span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                <span class="comment">//通过e的key值计算e的hash值</span></span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//得到e在新table中的插入位置</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">//采用链头插入法将e插入i位置，最后得到的链表相对于原table正好是头尾相反的</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            <span class="comment">//下一次循环</span></span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容时 <code>resize</code> 调用 <code>transfer</code> 使用头插法迁移元素，每个线程都会生成newTable (newTable 是局部变量)，但原先 table 中的 Entry <a href>链表</a>是共享的.假设两个线程，线程1挂起，线程二执行迁移完成，此时线程1继续执行，本来是用e遍历table，用next保存下一个结点，但这样顺序就颠倒了。</p><p>JDK8 在 <code>resize</code> 方法中完成扩容，并改用尾插法，不会产生死循环，但并发下仍可能丢失数据。可用 ConcurrentHashMap 或 <code>Collections.synchronizedMap</code> 包装同步集合</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>换电脑了迁移hexo博客(Win-&gt;MAC)</title>
      <link href="/2020/06/26/%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E8%BF%81%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/06/26/%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E8%BF%81%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>1.找到自己Windows的hexo根目录</p><p>2.在 Mac安装git和node.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先在自己电脑上装好node和git（首先确保brew安装好了）</span><br><span class="line">brew install git</span><br><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>3.安装hexo</p><p>用node.js来安装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo g</span><br></pre></td></tr></table></figure><p>4.初始化hexo目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">新建一个hexo目录，</span><br><span class="line"></span><br><span class="line">mkdir bolg</span><br><span class="line"></span><br><span class="line">cd blog</span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line">在用hexo s测试是否成功，打开localhost:4000查看本地</span><br></pre></td></tr></table></figure><p>5.生成SSH密钥，关联github</p><p>先查看本地的SSH key: cd ~/.ssh<br>(我是新mac电脑，所以没有的，直接生成密钥）<br>$ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a>“    后面那个是注册邮箱</p><p>进入.ssh文件夹： cd ~/.ssh，然后打开里面的 id_rsa.pub文件，里面的内容就是 SSH key，复制全部内容；</p><p>网页打开 github 的设置：Settings -&gt; SSH and GPG keys，点击绿色的按钮 New SSH key，然后在输入框中输入刚才复制的内容；</p><p>保存后，github 会向你的邮箱发送一个验证链接（记得要去登录邮箱验证，不然之后的 hexo d 部署会一直不成功的！）；</p><p>测试一下是否成功：ssh <a href="mailto:git@github.com">git@github.com</a>，<br>看到以下即成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PTY allocation request failed on channel <span class="number">0</span></span><br><span class="line">Hi gjincai! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">Connection to github.com closed.</span></span><br></pre></td></tr></table></figure><p>6.文件配置转移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windows 下的博客根目录 hexo，复制该目录下的：_config.yml, scaffolds, source, themes,<span class="keyword">package</span>.json；</span><br><span class="line">mac 下的博客根目录 hexo，把刚才复制的内容，直接覆盖替换相同的文件文件夹。</span><br></pre></td></tr></table></figure><p> 7.设置个人信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname”</span><br><span class="line">git config --global user.email youremail@example.com</span><br></pre></td></tr></table></figure><p>到这就好了，和往常一样hexo g        hexo d发布文章吧！</p><p>结果会提示ERROR Deployer not found: git</p><p>安装以下再尝试：npm install hexo-deployer-git –save（若提示有关权限不足的，加sudo，反正我是遇到了）</p><p>之后就能正常发布文章了！nice</p>]]></content>
      
      
      <categories>
          
          <category> hexo相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis缓存穿透、击穿、雪崩等</title>
      <link href="/2020/06/26/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%AD%89/"/>
      <url>/2020/06/26/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h2><p>正常情况下，查询的数据都存在，如果请求一个不存在的数据，也就是缓存和数据库都查不到这个数据，每次都会去数据库查询，这种查询不存在数据的现象我们称为缓存穿透</p><h3 id="穿透带来的问题"><a href="#穿透带来的问题" class="headerlink" title="穿透带来的问题"></a>穿透带来的问题</h3><p>如果每次都拿一个不存在的id去查询数据库，可能会导致你的数据库压力增大</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>缓存空值<br> 之所以发生穿透，是因为缓存中没有存储这些数据的key，从而每次都查询数据库<br>我们可以为这些key在缓存中设置对应的值为null，后面查询这个key的时候就不用查询数据库了<br>当然为了健壮性，我们要对这些key设置过期时间，以防止真的有数据</li><li>BloomFilter<br>BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中<br>我们把有数据的key都放到BloomFilter中，每次查询的时候都先去BloomFilter判断，如果没有就直接返回null<br>注意BloomFilter没有删除操作，对于删除的key，查询就会经过BloomFilter然后查询缓存再查询数据库，所以BloomFilter可以结合缓存空值用，对于删除的key，可以在缓存中缓存null</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>在高并发的情况下，大量的请求同时查询同一个key时，此时这个key正好失效了，就会导致同一时间，这些请求都会去查询数据库，这样的现象我们称为缓存击穿</p><h3 id="击穿带来的问题"><a href="#击穿带来的问题" class="headerlink" title="击穿带来的问题"></a>击穿带来的问题</h3><p>会造成某一时刻数据库请求量过大</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>1.使用互斥锁(mutex key)</strong></p><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p><p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">String value = redis.get(key);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//代表缓存值过期</span></span><br><span class="line"><span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line"><span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//代表设置成功</span></span><br><span class="line">value = db.get(key);</span><br><span class="line">redis.set(key, value, expire_secs);</span><br><span class="line">redis.del(key_mutex);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">sleep(<span class="number">50</span>);</span><br><span class="line">get(key);</span><br><span class="line"><span class="comment">//重试</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.”永远不过期”**</p><p>这里的“永远不过期”包含两层意思：</p><p>(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。</p><p>(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期</p><p>从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">V v = redis.get(key);</span><br><span class="line">String value = v.getValue();</span><br><span class="line"><span class="keyword">long</span> timeout = v.getTimeout();</span><br><span class="line"><span class="keyword">if</span> (v.timeout &lt;= System.currentTimeMillis()) &#123;</span><br><span class="line"><span class="comment">// 异步更新后台异常执行  </span></span><br><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String keyMutex = <span class="string">"mutex:"</span> + key;</span><br><span class="line"><span class="keyword">if</span> (redis.setnx(keyMutex, <span class="string">"1"</span>)) &#123;</span><br><span class="line"><span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">redis.expire(keyMutex, <span class="number">3</span> * <span class="number">60</span>);</span><br><span class="line">String dbValue = db.get(key);</span><br><span class="line">redis.set(key, dbValue);</span><br><span class="line">redis.delete(keyMutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了</p><h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效</li><li>ehcache本地缓存 + Hystrix限流&amp;降级<br>ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵<br>使用 Hystrix进行限流 &amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑</li><li>在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了</li><li>热点数据永不过期，参考上文</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阻塞、同步、乐观悲观相关概念</title>
      <link href="/2020/06/25/%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E4%B9%90%E8%A7%82%E6%82%B2%E8%A7%82%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/06/25/%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E4%B9%90%E8%A7%82%E6%82%B2%E8%A7%82%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>当某个任务在执行过程中发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；</p><h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><p>当某个任务在执行过程中发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直处于等待状态。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>当多个任务要发生时，这些任务必须逐个地进行，一个任务的执行会导致整个流程的暂时等待，这些事件不是并发地执行的；</p><h2 id="非同步"><a href="#非同步" class="headerlink" title="非同步"></a>非同步</h2><p>当多个任务要发生时，这些任务可以并发地执行，一个任务的执行不会导致整个流程的暂时等待。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。</p><p>共享锁【Shared lock】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p><p>排他锁【Exclusive lock】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改</p><p>乐观锁和悲观锁？在数据库里如何实现？   </p><p>​    乐观锁，是基于版本号，给每个记录添加一个版本号，当更新数据只有版本号相同才会更新   </p><p>​    悲观锁，使用数据库自己的锁，先将自动提交关闭，再开启一个事务，对要更新的数据进行select … for update，可以使得其他也想更新同一个数据的事务阻塞等待。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized的相关性质</title>
      <link href="/2020/06/24/synchronized%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/"/>
      <url>/2020/06/24/synchronized%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="对象布局"><a href="#对象布局" class="headerlink" title="对象布局"></a>对象布局</h2><p><img src="/2020/06/24/synchronized%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201108194840943.png" alt="image-20201108194840943"></p><p>对象填充，是将一个对象大小不足 8 个字节的倍数时，使用 0 填充补齐，为了更高效效率的读取数据，64 java 虚拟机，一次读取是 64 bit（8 字节）。 // monitor也是class, 其实例会存储在堆中，MarkWord中保存的是它的指针</p><p><strong>Mark Word</strong>：默认存储对象的 HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以 Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化。</p><p><img src="/2020/06/24/synchronized%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201108195403335.png" alt="image-20201108195403335"></p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h3 id="Array-Length"><a href="#Array-Length" class="headerlink" title="Array Length"></a>Array Length</h3><p>数组长度只在数组类型的对象中存在。用于记录数组的长度。避免获取数组长度时，动态计算。以空间换时间</p><h2 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h2><p><strong>反编译后,synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头).当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/30/16315cd5fa7cf91c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="对象，对象监视器，同步队列和线程状态的关系"></p><p>`<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png" alt="synchronized关键字原理"></p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>1.同步一个代码块</p><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.同步一个方法</p><p>作用于同一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.同步一个类</p><p>作用于整个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.同步一个静态方法</p><p>整个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和volatile的对比"><a href="#和volatile的对比" class="headerlink" title="和volatile的对比"></a>和volatile的对比</h2><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。<br>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成<br>私有数据对待，也就可以将它们的锁进行消除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String concatString(String s1, String s2, String s3) &#123;</span><br><span class="line">  return s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连<br>续 append() 操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String concatString(String s1, String s2, String s3) &#123;</span><br><span class="line">  StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">  sb.append(s1);</span><br><span class="line">  sb.append(s2);</span><br><span class="line">  sb.append(s3);</span><br><span class="line">  return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line"> StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"> sb.append(s1);</span><br><span class="line"> sb.append(s2);</span><br><span class="line"> sb.append(s3);</span><br><span class="line"> <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次就可以了。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>当轻量级锁膨胀到重量级锁之后，意味着线程只能被挂起阻塞来等待唤醒了。每一个对象中都有一个Monitor监视器，而Monitor依赖操作系统的 MutexLock(互斥锁)来实现的, 线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能。<br> monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。而且当一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。我们可以简单的理解为，在加重量级锁的时候会执行monitorenter指令，解锁时会执行monitorexit指令。</p><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。</p><p>另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。</p><h3 id="自适应自旋"><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a>自适应自旋</h3><p>在 JDK1.7 开始，引入了自适应自旋锁，修改自旋锁次数的JVM参数被取消，虚拟机不再支持由用户配置自旋锁次数，而是由虚拟机自动调整。自适应意味着自旋的次数不是固定不变的，而是根据前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>轻量级锁在加锁过程中，用到了自旋锁。</p><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。自旋锁的思想是让一个线程在请求一个共享数据的锁时自旋一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。<br>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行循环操作占用 CPU 时间，它只适用于共享数据的<br>锁定状态很短的场景。<br>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数<br>及锁的拥有者的状态来决定。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>自旋锁的目标是降低线程切换的成本。</p><blockquote><p><strong>加锁</strong></p></blockquote><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中<strong>创建用于存储锁记录的空间</strong>，并将对象头中的Mark Word复制到锁记录中，官方称为<strong>Displaced Mark Word</strong>。然后线程尝试使用CAS<strong>将对象头中的Mark Word替换为指向锁记录的指针</strong>。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><blockquote><p><strong>解锁</strong></p></blockquote><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗</strong>。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，同时使用 CAS 操作将线程 ID 记录到 Mark Word中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。<br>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定<br>状态或者轻量级锁状态。</p><h2 id="synchronized和volatile的比较"><a href="#synchronized和volatile的比较" class="headerlink" title="synchronized和volatile的比较"></a>synchronized和volatile的比较</h2><p>1.volatile本质是告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取，synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p><p>2.volatile仅能用在变量级别，而synchronized可以使用在变量、方法、类级别。</p><p>3.volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</p><p>4.volatile不会造成线程阻塞，synchronized可能会造成线程阻塞。</p><p>5.volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化。</p><h2 id="发生异常时自动释放锁"><a href="#发生异常时自动释放锁" class="headerlink" title="发生异常时自动释放锁"></a>发生异常时自动释放锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">syntest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" start"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">         count++;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">" count: "</span>+count);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">                System.out.println(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        syntest s=<span class="keyword">new</span> syntest();</span><br><span class="line">        Runnable r=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                s.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如题， 发生异常的时候，synchronized锁释放，线程t2得以执行</p><p>但是要注意的是，对于显式锁， 如ReentrantLock，在发生异常的时候，必须要手动释放锁。 </p><p>如果执行的代码段有可能发生异常，我们通常要这样处理, 需要在finally里面释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//可能发生异常的代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="comment">//释放IO资源</span></span><br><span class="line">    io.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reetest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" count: "</span> + count);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        reetest s=<span class="keyword">new</span> reetest();</span><br><span class="line">        Runnable r=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                s.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和Lock的区别"><a href="#和Lock的区别" class="headerlink" title="和Lock的区别"></a>和Lock的区别</h2><ol><li><p>来源：<br>lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；</p></li><li><p>异常是否释放锁：<br>synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）</p></li><li><p>是否响应中断<br>lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；</p></li><li><p>是否知道获取锁<br>Lock可以通过trylock来知道有没有获取锁，而synchronized不能；</p></li><li><p>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</p></li><li><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p></li><li><p>synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度，</p></li></ol><h2 id="轻量级锁什么时候升级为重量级锁？"><a href="#轻量级锁什么时候升级为重量级锁？" class="headerlink" title="轻量级锁什么时候升级为重量级锁？"></a>轻量级锁什么时候升级为重量级锁？</h2><p>我们必须给线程空循环设置一个次数，当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为<strong>重量级锁</strong>。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。</p><h2 id="偏向锁升级为轻量级"><a href="#偏向锁升级为轻量级" class="headerlink" title="偏向锁升级为轻量级"></a>偏向锁升级为轻量级</h2><p>轻量级锁由偏向锁升级而来，偏向锁运行在一个线程同步块时，第二个线程加入锁竞争的时候，偏向锁就会升级为轻量级锁。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k。首先将位数组进行初始化，每个都设为0。对于添加进来的新元素，将新元素经过k个hash函数，产生k个hash值，将hash值对应的位都置为1。查询某元素是否存在集合中的时候，同样的方法将某元素通过哈希映射到位数组上的k个点。如果k个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果k个点都为1，则该元素可能存在集合中。此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。因为k个点中的某个点有可能是因为其他元素hash得到的，这是误判率存在的原因</p><img src="/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1.png" class title="布隆过滤器">]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CAS</title>
      <link href="/2020/06/24/CAS/"/>
      <url>/2020/06/24/CAS/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="阻塞同步和非阻塞同步"><a href="#阻塞同步和非阻塞同步" class="headerlink" title="阻塞同步和非阻塞同步"></a>阻塞同步和非阻塞同步</h2><p>阻塞同步需要线程阻塞和唤醒所带来的性能问题，它属于一种悲观的并发策略，无论共享数据是否真的会出现竞争，它都要进行加锁。</p><p><strong>cmpxchg</strong></p><h2 id="CAS是什么"><a href="#CAS是什么" class="headerlink" title="CAS是什么"></a>CAS是什么</h2><p>它是乐观并发策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则不断地重试，直到成功。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。**</span><br></pre></td></tr></table></figure><p>CAS 表示 Compare And Swap，比较并交换，CAS 主要需要三个操作数，分别是内存中存放的实际值V、旧的预期值 A 和准备设置的新值 B。CAS 指令执行时，当且仅当 V 符合 A 时，处理器才会用 B 更新 V 的值，否则它就不执行更新。但不管是否更新都会返回 V 的旧值，这些处理过程是原子操作，执行期间不会被其他线程打断。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。<br>以下代码使用了 AtomicInteger 执行了自增的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示<br>操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt()<br>来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。<br>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">   var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</span><br><span class="line">J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版</span><br><span class="line">本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统</span><br><span class="line">的互斥同步可能会比原子类更高效。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>volatile的性质</title>
      <link href="/2020/06/24/volatile%E7%9A%84%E6%80%A7%E8%B4%A8/"/>
      <url>/2020/06/24/volatile%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="说说你对volatile关键字的理解"><a href="#说说你对volatile关键字的理解" class="headerlink" title="说说你对volatile关键字的理解"></a>说说你对volatile关键字的理解</h2><p>就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性：</p><p>1 . 保证了不同线程对该变量操作的可见性;</p><p>2 . 禁止指令重排序</p><h2 id="volatile关键字如何保证可见性的？"><a href="#volatile关键字如何保证可见性的？" class="headerlink" title="volatile关键字如何保证可见性的？"></a>volatile关键字如何保证可见性的？</h2><p>要知道volatile是如何保证可见性的需要先了解下有关CPU缓存的概念。我们知道<strong>CPU的运算速度</strong>要比<strong>内存的读写速度</strong>快很多，这就造成了内存无法跟上CPU的情况。为了解决这类问题，出现了针对CPU的缓存协议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intel开发了缓存一致性协议，也就是MESI协议</span><br><span class="line"></span><br><span class="line">①当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，那么他会发出信号通知其他CPU将该变量的缓存行设置为无效状态。</span><br><span class="line"></span><br><span class="line">②当其他CPU使用这个变量时，首先会去嗅探是否有对该变量更改的信号，当发现这个变量的缓存行已经无效时，会从新从内存中读取这个变量。</span><br></pre></td></tr></table></figure><p>了解了上面的内容，就可以很容易的理解volatile是如何实现的了。</p><ol><li>被 volatile 修饰的共享变量，在翻译成为机器码的过程中为其<code>赋值操作</code>添加特殊机器码指令前缀<code>Lock xxxx</code></li><li>当CPU发现这个指令时，立即做两件事：<ul><li>使本CPU的缓存写入内存</li><li>上面的写入动作也会引起别的CPU中的缓存无效，</li></ul></li></ol><p><strong>volatile关键字的变量写操作时，强制缓存和主存同步，其他线程读时候发现缓存失效，就去读主存，由此保证了变量的可见性。</strong></p><h2 id="volatile关键字如何保证有序性的？"><a href="#volatile关键字如何保证有序性的？" class="headerlink" title="volatile关键字如何保证有序性的？"></a>volatile关键字如何保证有序性的？</h2><p>在JMM的逻辑实现中，当操作一个变量 执行为变量赋值 时，JVM会检查此变量是否是被volatile修饰的，如果是的话，JVM会为该变量添加内存屏障。保证该变量操作之前的操作不会乱序到其后</p><ol><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1583231-26cc583714507e7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/778/format/webp" alt="img"></p><h2 id="volatile可以保证原子性么？"><a href="#volatile可以保证原子性么？" class="headerlink" title="volatile可以保证原子性么？"></a>volatile可以保证原子性么？</h2><p>例如我们常碰到的i++的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 1; &#x2F;&#x2F;原子性操作，不用使用volatile也不会出现线程安全问题。</span><br><span class="line">复制代码</span><br><span class="line">volatile int i &#x3D; 0;</span><br><span class="line">i++; &#x2F;&#x2F;非原子性操作</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果我们开启200个线程并发执行<code>i++</code>这行代码，每个线程中只执行一遍。如果volatile可以保证原子性的话，那么i的最终结果应该是200；而实际上我们发现这个值是会小于200的，原因是什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; i++ 其可以被拆解为</span><br><span class="line">1、线程读取i</span><br><span class="line">2、temp &#x3D; i + 1</span><br><span class="line">3、i &#x3D; temp</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li><p>例如当 i=5 的时候A,B两个线程同时读入了 i 的值</p></li><li><p>然后A线程执行了 <code>temp = i + 1</code>的操作， 要注意，此时的 i 的值还没有变化，然后B线程也执行了<code>temp = i + 1</code>的操作，注意，此时A，B两个线程保存的 i 的值都是5，temp 的值都是6</p></li><li><p>然后A线程执行了 <code>i = temp</code> （6）的操作，此时i的值会立即刷新到主存并通知其他线程保存的 i 值失效， 此时B线程需要重新读取 i 的值那么此时B线程保存的 i 就是6</p></li><li><p>同时B线程保存的 temp 还仍然是6， 然后B线程执行 <code>i=temp</code> （6），所以导致了计算结果比预期少了1。<br>链接：<a href="https://juejin.im/post/5e01b9aa518825126f373b58" target="_blank" rel="noopener">https://juejin.im/post/5e01b9aa518825126f373b58</a></p></li></ol><p>   自增语句由 4 条字节码指令构成的，依次为 <code>getstatic</code>、<code>iconst_1</code>、<code>iadd</code>、<code>putstatic</code>，当 <code>getstatic</code> 把 i 取到操作栈顶时，volatile 保证了 i 值在此刻正确，但在执行 <code>iconst_1</code>、<code>iadd</code> 时，其他线程可能已经改变了 i 值，操作栈顶的值就变成了脏数据，所以 <code>putstatic</code> 后就可能把较小的值同步回了主内存。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic &#x2F;&#x2F; 获取静态变量race，并将值压入栈顶</span><br><span class="line">iconst_1  &#x2F;&#x2F; 将int值1推送至栈顶</span><br><span class="line">iadd      &#x2F;&#x2F; 将栈顶两个int型数值相加并将结果压入栈顶</span><br><span class="line">putstatic &#x2F;&#x2F; 为静态变量race赋值</span><br></pre></td></tr></table></figure><h2 id="volatile底层的实现机制？"><a href="#volatile底层的实现机制？" class="headerlink" title="volatile底层的实现机制？"></a>volatile底层的实现机制？</h2><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p><p>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</p><p>lock addl把rsp寄存器的值加0，因为数据就是</p><p>1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置 </p><p>2.将当前处理器缓存行的数据写回到系统内存。</p><p>3.这个写回内存的操作会使其他在CPU里缓存了该内存地址的数据无效。</p><h2 id="有了mesi还要volatile吗？"><a href="#有了mesi还要volatile吗？" class="headerlink" title="有了mesi还要volatile吗？"></a>有了mesi还要volatile吗？</h2><p>在Java中，volatile是个很高层面的规范，保证了指令不会被重排序+对volatile变量的写使得当前cpu缓存中的所有变量写回到主存中，从而保证了内存可见性。</p><p>还是有用的，就算在实现了mesi的cpu上，volatile一样不可或缺。除了禁止指令重排序的作用外，由于mesi只是保证了L1-3 的cache之间的可见性，但是cpu和L1之间</p><p>还有像storebuffer之类的缓存，而volatile规范保证了对它修饰的变量的写指令会使得当前cpu所有缓存写到被mesi保证可见性的L1-3cache中。</p><p>因为 MESI只是保证了多核cpu的独占cache(L1,L2,L3)之间的一致性，但是cpu的并不是直接把数据写入L1 cache的，中间还可能有store buffer或者invalid queue等</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal的原理</title>
      <link href="/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>ThreadLocal 用于提供线程局部变量，在多线程环境可以保证各个线程里的变量独立于其它线程里的变量。</strong></p><p>也就是说 ThreadLocal 可以为每个线程创建一个【单独的变量副本】，相当于线程的 private static 类型变量。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String strLabel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLabel = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        strLabel = <span class="string">"main"</span>;</span><br><span class="line">        threadLabel.set(<span class="string">"main"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                strLabel = <span class="string">"child"</span>;</span><br><span class="line">                threadLabel.set(<span class="string">"child"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保证线程执行完毕</span></span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"strLabel = "</span> + strLabel);</span><br><span class="line">        System.out.println(<span class="string">"threadLabel = "</span> + threadLabel.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strLabel = child</span><br><span class="line">threadLabel = main</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal-set"><a href="#ThreadLocal-set" class="headerlink" title="ThreadLocal.set()"></a>ThreadLocal.set()</h3><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/6.png" alt="img"></p><p><code>ThreadLocal</code>中的<code>set</code>方法原理如上图所示，很简单，主要是判断<code>ThreadLocalMap</code>是否存在，然后使用<code>ThreadLocal</code>中的<code>set</code>方法进行数据处理。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> `ThreadLocalMap`(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>主要的核心逻辑还是在<code>ThreadLocalMap</code>中的，一步步往下看，后面还有更详细的剖析。</p><h3 id="ThreadLocalMap-Hash算法"><a href="#ThreadLocalMap-Hash算法" class="headerlink" title="ThreadLocalMap Hash算法"></a>ThreadLocalMap Hash算法</h3><p>既然是<code>Map</code>结构，那么<code>ThreadLocalMap</code>当然也要实现自己的<code>hash</code>算法来解决散列表数组冲突问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>中<code>hash</code>算法很简单，这里<code>i</code>就是当前key在散列表中对应的数组下标位置。</p><p>这里最关键的就是<code>threadLocalHashCode</code>值的计算，<code>ThreadLocal</code>中有一个属性为<code>HASH_INCREMENT = 0x61c88647</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> `<span class="title">ThreadLocalMap</span>` </span>&#123;</span><br><span class="line">        `ThreadLocalMap`(`ThreadLocal`&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>每当创建一个<code>ThreadLocal</code>对象，这个``ThreadLocal<code>.nextHashCode</code> 这个值就会增长 <code>0x61c88647</code> 。</p><p>这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p><p>我们自己可以尝试下：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/8.png" alt="img"></p><p>可以看到产生的哈希码分布很均匀，这里不去细纠<strong>斐波那契</strong>具体算法，感兴趣的可以自行查阅相关资料。</p><h3 id="ThreadLocalMapHash冲突"><a href="#ThreadLocalMapHash冲突" class="headerlink" title="ThreadLocalMapHash冲突"></a>ThreadLocalMapHash冲突</h3><blockquote><p><strong>注明：</strong> 下面所有示例图中，<strong>绿色块</strong><code>Entry</code>代表<strong>正常数据</strong>，<strong>灰色块</strong>代表<code>Entry</code>的<code>key</code>值为<code>null</code>，<strong>已被垃圾回收</strong>。<strong>白色块</strong>表示<code>Entry</code>为<code>null</code>。</p></blockquote><p>虽然<code>ThreadLocalMap</code>中使用了<strong>黄金分隔数来</strong>作为<code>hash</code>计算因子，大大减少了<code>Hash</code>冲突的概率，但是仍然会存在冲突。</p><p><code>HashMap</code>中解决冲突的方法是在数组上构造一个<strong>链表</strong>结构，冲突的数据挂载到链表上，如果链表长度超过一定数量则会转化成<strong>红黑树</strong>。</p><p>而<code>ThreadLocalMap</code>中并没有链表结构，所以这里不能适用<code>HashMap</code>解决冲突的方式了。</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/7.png" alt="img"></p><p>如上图所示，如果我们插入一个<code>value=27</code>的数据，通过<code>hash</code>计算后应该落入第4个槽位中，而槽位4已经有了<code>Entry</code>数据。</p><p>此时就会线性向后查找，一直找到<code>Entry</code>为<code>null</code>的槽位才会停止查找，将当前元素放入此槽位中。当然迭代过程中还有其他的情况，比如遇到了<code>Entry</code>不为<code>null</code>且<code>key</code>值相等的情况，还有<code>Entry</code>中的<code>key</code>值为<code>null</code>的情况等等都会有不同的处理，后面会一一详细讲解。</p><p>这里还画了一个<code>Entry</code>中的<code>key</code>为<code>null</code>的数据（<strong>Entry=2的灰色块数据</strong>），因为<code>key</code>值是<strong>弱引用</strong>类型，所以会有这种数据存在。在<code>set</code>过程中，如果遇到了<code>key</code>过期的<code>Entry</code>数据，实际上是会进行一轮<strong>探测式清理</strong>操作的，具体操作方式后面会讲到。</p><h3 id="ThreadLocalMap-set"><a href="#ThreadLocalMap-set" class="headerlink" title="ThreadLocalMap.set()"></a>ThreadLocalMap.set()</h3><h4 id="ThreadLocalMap-set-原理图解"><a href="#ThreadLocalMap-set-原理图解" class="headerlink" title="ThreadLocalMap.set()原理图解"></a>ThreadLocalMap.set()原理图解</h4><p>看完了<code>ThreadLocal</code> <strong>hash算法</strong>后，我们再来看<code>set</code>是如何实现的。</p><p>往<code>ThreadLocalMap</code>中<code>set</code>数据（<strong>新增</strong>或者<strong>更新</strong>数据）分为好几种情况，针对不同的情况我们画图来说说明。</p><p><strong>第一种情况：</strong> 通过<code>hash</code>计算后的槽位对应的<code>Entry</code>数据为空：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/9.png" alt="img"></p><p>这里直接将数据放到该槽位即可。</p><p><strong>第二种情况：</strong> 槽位数据不为空，<code>key</code>值与当前<code>ThreadLocal</code>通过<code>hash</code>计算获取的<code>key</code>值一致：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/10.png" alt="img"></p><p>这里直接更新该槽位的数据。</p><p><strong>第三种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code>Entry</code>为<code>null</code>的槽位之前，没有遇到<code>key</code>过期的<code>Entry</code>：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/11.png" alt="img"></p><p>遍历散列数组，线性往后查找，如果找到<code>Entry</code>为<code>null</code>的槽位，则将数据放入该槽位中，或者往后遍历过程中，遇到了<strong>key值相等</strong>的数据，直接更新即可。</p><p><strong>第四种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code>Entry</code>为<code>null</code>的槽位之前，遇到<code>key</code>过期的<code>Entry</code>，如下图，往后遍历过程中，一到了<code>index=7</code>的槽位数据<code>Entry</code>的<code>key=null</code>：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/12.png" alt="img"></p><p>散列数组下标为7位置对应的<code>Entry</code>数据<code>key</code>为<code>null</code>，表明此数据<code>key</code>值已经被垃圾回收掉了，此时就会执行<code>replaceStaleEntry()</code>方法，该方法含义是<strong>替换过期数据的逻辑</strong>，以<strong>index=7</strong>位起点开始遍历，进行探测式数据清理工作。</p><p>初始化探测式清理过期数据扫描的开始位置：<code>slotToExpunge = staleSlot = 7</code></p><p>以当前<code>staleSlot</code>开始 向前迭代查找，找其他过期的数据，然后更新过期数据起始扫描下标<code>slotToExpunge</code>。<code>for</code>循环迭代，直到碰到<code>Entry</code>为<code>null</code>结束。</p><p>如果找到了过期的数据，继续向前迭代，直到遇到<code>Entry=null</code>的槽位才停止迭代，如下图所示，<strong>slotToExpunge被更新为0</strong>：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/13.png" alt="img"></p><p>以当前节点(<code>index=7</code>)向前迭代，检测是否有过期的<code>Entry</code>数据，如果有则更新<code>slotToExpunge</code>值。碰到<code>null</code>则结束探测。以上图为例<code>slotToExpunge</code>被更新为0。</p><p>上面向前迭代的操作是为了更新探测清理过期数据的起始下标<code>slotToExpunge</code>的值，这个值在后面会讲解，它是用来判断当前过期槽位<code>staleSlot</code>之前是否还有过期元素。</p><p>接着开始以<code>staleSlot</code>位置(index=7)向后迭代，<strong>如果找到了相同key值的Entry数据：</strong></p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/14.png" alt="img"></p><p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>元素，找到后更新<code>Entry</code>的值并交换<code>staleSlot</code>元素的位置(<code>staleSlot</code>位置为过期元素)，更新<code>Entry</code>数据，然后开始进行过期<code>Entry</code>的清理工作，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f3ba9af057e1e?w=1336&h=361&f=png&s=63049" alt="Yu4oWT.png"></p><p><strong>向后遍历过程中，如果没有找到相同key值的Entry数据：</strong></p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/15.png" alt="img"></p><p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>元素，直到<code>Entry</code>为<code>null</code>则停止寻找。通过上图可知，此时<code>table</code>中没有<code>key</code>值相同的<code>Entry</code>。</p><p>创建新的<code>Entry</code>，替换<code>table[stableSlot]</code>位置：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/16.png" alt="img"></p><p>替换完成后也是进行过期元素清理工作，清理工作主要是有两个方法：<code>expungeStaleEntry()</code>和<code>cleanSomeSlots()</code>，具体细节后面会讲到，请继续往后看。</p><h4 id="ThreadLocalMap-set-源码详解"><a href="#ThreadLocalMap-set-源码详解" class="headerlink" title="ThreadLocalMap.set()源码详解"></a>ThreadLocalMap.set()源码详解</h4><p>上面已经用图的方式解析了<code>set()</code>实现的原理，其实已经很清晰了，我们接着再看下源码：</p><p><code>java.lang.ThreadLocal</code>.<code>ThreadLocalMap.set()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这里会通过<code>key</code>来计算在散列表中的对应位置，然后以当前<code>key</code>对应的桶的位置向后查找，找到可以使用的桶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entry[] tab = table;</span><br><span class="line"><span class="keyword">int</span> len = tab.length;</span><br><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>什么情况下桶才是可以使用的呢？</p><ol><li><code>k = key</code> 说明是替换操作，可以使用</li><li>碰到一个过期的桶，执行替换逻辑，占用过期桶</li><li>查找过程中，碰到桶中<code>Entry=null</code>的情况，直接使用</li></ol><p>接着就是执行<code>for</code>循环遍历，向后查找，我们先看下<code>nextIndex()</code>、<code>prevIndex()</code>方法实现：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/17.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>接着看剩下<code>for</code>循环中的逻辑：</p><ol><li>遍历当前<code>key</code>值对应的桶中<code>Entry</code>数据为空，这说明散列数组这里没有数据冲突，跳出<code>for</code>循环，直接<code>set</code>数据到对应的桶中</li><li>如果<code>key</code>值对应的桶中<code>Entry</code>数据不为空</li><li>1 如果<code>k = key</code>，说明当前<code>set</code>操作是一个替换操作，做替换逻辑，直接返回</li><li>2 如果<code>key = null</code>，说明当前桶位置的<code>Entry</code>是过期数据，执行<code>replaceStaleEntry()</code>方法(核心方法)，然后返回</li><li><code>for</code>循环执行完毕，继续往下执行说明向后迭代的过程中遇到了<code>entry</code>为<code>null</code>的情况</li><li>1 在<code>Entry</code>为<code>null</code>的桶中创建一个新的<code>Entry</code>对象</li><li>2 执行<code>++size</code>操作</li><li>调用<code>cleanSomeSlots()</code>做一次启发式清理工作，清理散列数组中<code>Entry</code>的<code>key</code>过期的数据</li><li>1 如果清理工作完成后，未清理到任何数据，且<code>size</code>超过了阈值(数组长度的2/3)，进行<code>rehash()</code>操作</li><li>2 <code>rehash()</code>中会先进行一轮探测式清理，清理过期<code>key</code>，清理完成后如果<strong>size &gt;= threshold - threshold / 4</strong>，就会执行真正的扩容逻辑(扩容逻辑往后看)</li></ol><p>接着重点看下<code>replaceStaleEntry()</code>方法，<code>replaceStaleEntry()</code>方法提供替换过期数据的功能，我们可以对应上面<strong>第四种情况</strong>的原理图来再回顾下，具体代码如下：</p><p><code>java.lang.ThreadLocal.ThreadLocalMap.replaceStaleEntry()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(`ThreadLocal`&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line">slotToExpunge`表示开始探测式清理过期数据的开始下标，默认从当前的`staleSlot`开始。以当前的`staleSlot`开始，向前迭代查找，找到没有过期的数据，`<span class="keyword">for</span>`循环一直碰到`Entry`为`<span class="keyword">null</span>`才会结束。如果向前找到了过期数据，更新探测清理过期数据的开始下标为i，即`slotToExpunge=i</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">     (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">     i = prevIndex(i, len))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)&#123;</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>接着开始从<code>staleSlot</code>向后查找，也是碰到<code>Entry</code>为<code>null</code>的桶结束。 如果迭代过程中，<strong>碰到k == key</strong>，这说明这里是替换逻辑，替换新数据并且交换当前<code>staleSlot</code>位置。如果<code>slotToExpunge == staleSlot</code>，这说明<code>replaceStaleEntry()</code>一开始向前查找过期数据时并未找到过期的<code>Entry</code>数据，接着向后查找过程中也未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的index，即<code>slotToExpunge = i</code>。最后调用<code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code>进行启发式过期数据清理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">    e.value = value;</span><br><span class="line"></span><br><span class="line">    tab[i] = tab[staleSlot];</span><br><span class="line">    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>cleanSomeSlots()</code>和<code>expungeStaleEntry()</code>方法后面都会细讲，这两个是和清理相关的方法，一个是过期<code>key</code>相关<code>Entry</code>的启发式清理(<code>Heuristically scan</code>)，另一个是过期<code>key</code>相关<code>Entry</code>的探测式清理。</p><p><strong>如果k != key</strong>则会接着往下走，<code>k == null</code>说明当前遍历的<code>Entry</code>是一个过期数据，<code>slotToExpunge == staleSlot</code>说明，一开始的向前查找数据并未找到过期的<code>Entry</code>。如果条件成立，则更新<code>slotToExpunge</code> 为当前位置，这个前提是前驱节点扫描时未发现过期数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">    slotToExpunge = i;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>往后迭代的过程中如果没有找到<code>k == key</code>的数据，且碰到<code>Entry</code>为<code>null</code>的数据，则结束当前的迭代操作。此时说明这里是一个添加的逻辑，将新的数据添加到<code>table[staleSlot]</code> 对应的<code>slot</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>最后判断除了<code>staleSlot</code>以外，还发现了其他过期的<code>slot</code>数据，就要开启清理数据的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap过期key的探测式清理流程"><a href="#ThreadLocalMap过期key的探测式清理流程" class="headerlink" title="ThreadLocalMap过期key的探测式清理流程"></a>ThreadLocalMap过期key的探测式清理流程</h3><p>上面我们有提及<code>ThreadLocalMap</code>的两种过期<code>key</code>数据清理方式：<strong>探测式清理</strong>和<strong>启发式清理</strong>。</p><p>我们先讲下探测式清理，也就是<code>expungeStaleEntry</code>方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的<code>Entry</code>设置为<code>null</code>，沿途中碰到未过期的数据则将此数据<code>rehash</code>后重新在<code>table</code>数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的<code>Entry=null</code>的桶中，使<code>rehash</code>后的<code>Entry</code>数据距离正确的桶的位置更近一些。操作逻辑如下：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/18.png" alt="img"></p><p>如上图，<code>set(27)</code> 经过hash计算后应该落到<code>index=4</code>的桶中，由于<code>index=4</code>桶已经有了数据，所以往后迭代最终数据放入到<code>index=7</code>的桶中，放入后一段时间后<code>index=5</code>中的<code>Entry</code>数据<code>key</code>变为了<code>null</code></p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/19.png" alt="img"></p><p>如果再有其他数据<code>set</code>到<code>map</code>中，就会触发<strong>探测式清理</strong>操作。</p><p>如上图，执行<strong>探测式清理</strong>后，<code>index=5</code>的数据被清理掉，继续往后迭代，到<code>index=7</code>的元素时，经过<code>rehash</code>后发现该元素正确的<code>index=4</code>，而此位置已经已经有了数据，往后查找离<code>index=4</code>最近的<code>Entry=null</code>的节点(刚被探测式清理掉的数据：index=5)，找到后移动<code>index= 7</code>的数据到<code>index=5</code>中，此时桶的位置离正确的位置<code>index=4</code>更近了。</p><p>经过一轮探测式清理后，<code>key</code>过期的数据会被清理掉，没过期的数据经过<code>rehash</code>重定位后所处的桶位置理论上更接近<code>i= key.hashCode &amp; (tab.len - 1)</code>的位置。这种优化会提高整个散列表查询性能。</p><p>接着看下<code>expungeStaleEntry()</code>具体流程，我们还是以先原理图后源码讲解的方式来一步步梳理：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/20.png" alt="img"></p><p>我们假设<code>expungeStaleEntry(3)</code> 来调用此方法，如上图所示，我们可以看到<code>ThreadLocalMap</code>中<code>table</code>的数据情况，接着执行清理操作：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/21.png" alt="img"></p><p>第一步是清空当前<code>staleSlot</code>位置的数据，<code>index=3</code>位置的<code>Entry</code>变成了<code>null</code>。然后接着往后探测：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/22.png" alt="img"></p><p>执行完第二步后，index=4的元素挪到index=3的槽位中。</p><p>继续往后迭代检查，碰到正常数据，计算该数据位置是否偏移，如果被偏移，则重新计算<code>slot</code>位置，目的是让正常数据尽可能存放在正确位置或离正确位置更近的位置</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/23.png" alt="img"></p><p>在往后迭代的过程中碰到空的槽位，终止探测，这样一轮探测式清理工作就完成了，接着我们继续看看具体<strong>实现源代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这里我们还是以<code>staleSlot=3</code> 来做示例说明，首先是将<code>tab[staleSlot]</code>槽位的数据清空，然后设置<code>size--</code> 接着以<code>staleSlot</code>位置往后迭代，如果遇到<code>k==null</code>的过期数据，也是清空该槽位数据，然后<code>size--</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">    e.value = <span class="keyword">null</span>;</span><br><span class="line">    tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">&#125; Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>如果<code>key</code>没有过期，重新计算当前<code>key</code>的下标位置是不是当前槽位下标位置，如果不是，那么说明产生了<code>hash</code>冲突，此时以新计算出来正确的槽位位置往后迭代，找到最近一个可以存放<code>entry</code>的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">    tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">        h = nextIndex(h, len);</span><br><span class="line"></span><br><span class="line">    tab[h] = e;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这里是处理正常的产生<code>Hash</code>冲突的数据，经过迭代后，有过<code>Hash</code>冲突数据的<code>Entry</code>位置会更靠近正确位置，这样的话，查询的时候 效率才会更高。</p><h3 id="ThreadLocalMap扩容机制"><a href="#ThreadLocalMap扩容机制" class="headerlink" title="ThreadLocalMap扩容机制"></a>ThreadLocalMap扩容机制</h3><p>在``ThreadLocalMap.set()<code>方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中</code>Entry<code>的数量已经达到了列表的扩容阈值</code>(len*2/3)<code>，就开始执行</code>rehash()`逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>接着看下<code>rehash()</code>具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这里首先是会进行探测式清理工作，从<code>table</code>的起始位置往后清理，上面有分析清理的详细流程。清理完成之后，<code>table</code>中可能有一些<code>key</code>为<code>null</code>的<code>Entry</code>数据被清理掉，所以此时通过判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold* 3/4</code> 来决定是否扩容。</p><p>我们还记得上面进行<code>rehash()</code>的阈值是<code>size &gt;= threshold</code>，所以当面试官套路我们<code>ThreadLocalMap</code>扩容机制的时候 我们一定要说清楚这两个步骤：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/24.png" alt="img"></p><p>接着看看具体的<code>resize()</code>方法，为了方便演示，我们以<code>oldTab.len=8</code>来举例：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/25.png" alt="img"></p><p>扩容后的<code>tab</code>的大小为<code>oldLen * 2</code>，然后遍历老的散列表，重新计算<code>hash</code>位置，然后放到新的<code>tab</code>数组中，如果出现<code>hash</code>冲突则往后寻找最近的<code>entry</code>为<code>null</code>的槽位，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到新的<code>tab</code>中了。重新计算<code>tab</code>下次扩容的<strong>阈值</strong>，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap-get-详解"><a href="#ThreadLocalMap-get-详解" class="headerlink" title="ThreadLocalMap.get()详解"></a>ThreadLocalMap.get()详解</h3><p>上面已经看完了<code>set()</code>方法的源码，其中包括<code>set</code>数据、清理数据、优化数据桶的位置等操作，接着看看<code>get()</code>操作的原理。</p><h4 id="ThreadLocalMap-get-图解"><a href="#ThreadLocalMap-get-图解" class="headerlink" title="ThreadLocalMap.get()图解"></a>ThreadLocalMap.get()图解</h4><p><strong>第一种情况：</strong> 通过查找<code>key</code>值计算出散列表中<code>slot</code>位置，然后该<code>slot</code>位置中的<code>Entry.key</code>和查找的<code>key</code>一致，则直接返回：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/26.png" alt="img"></p><p><strong>第二种情况：</strong> <code>slot</code>位置中的<code>Entry.key</code>和要查找的<code>key</code>不一致：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/27.png" alt="img"></p><p>我们以<code>get(ThreadLocal1)</code>为例，通过<code>hash</code>计算后，正确的<code>slot</code>位置应该是4，而<code>index=4</code>的槽位已经有了数据，且<code>key</code>值不等于``ThreadLocal<code>1</code>，所以需要继续往后迭代查找。</p><p>迭代到<code>index=5</code>的数据时，此时<code>Entry.key=null</code>，触发一次探测式数据回收操作，执行<code>expungeStaleEntry()</code>方法，执行完后，<code>index 5,8</code>的数据都会被回收，而<code>index 6,7</code>的数据都会前移，此时继续往后迭代，到<code>index = 6</code>的时候即找到了<code>key</code>值相等的<code>Entry</code>数据，如下图所示：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/28.png" alt="img"></p><h4 id="ThreadLocalMap-get-源码详解"><a href="#ThreadLocalMap-get-源码详解" class="headerlink" title="ThreadLocalMap.get()源码详解"></a>ThreadLocalMap.get()源码详解</h4><p><code>java.lang.ThreadLocal.ThreadLocalMap.getEntry()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(`ThreadLocal`&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(`ThreadLocal`&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap过期key的启发式清理流程"><a href="#ThreadLocalMap过期key的启发式清理流程" class="headerlink" title="ThreadLocalMap过期key的启发式清理流程"></a>ThreadLocalMap过期key的启发式清理流程</h3><p>上面多次提及到<code>ThreadLocalMap</code>过期可以的两种清理方式：<strong>探测式清理(expungeStaleEntry())\</strong>、<strong>启发式清理(cleanSomeSlots())</strong></p><p>探测式清理是以当前<code>Entry</code> 往后清理，遇到值为<code>null</code>则结束清理，属于<strong>线性探测清理</strong>。</p><p>而启发式清理被作者定义为：<strong>Heuristically scan some cells looking for stale entries</strong>.</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/29.png" alt="img"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>我们使用<code>ThreadLocal</code>的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。</p><p>为了解决这个问题，JDK中还有一个<code>InheritableThreadLocal</code>类，我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; ThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">        ThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">        ThreadLocal.set(<span class="string">"父类数据:threadLocal"</span>);</span><br><span class="line">        inheritableThreadLocal.set(<span class="string">"父类数据:inheritableThreadLocal"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程获取父类`ThreadLocal`数据："</span> + `ThreadLocal`.get());</span><br><span class="line">                System.out.println(<span class="string">"子线程获取父类inheritableThreadLocal数据："</span> + inheritableThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子线程获取父类`ThreadLocal`数据：<span class="keyword">null</span></span><br><span class="line">子线程获取父类inheritableThreadLocal数据：父类数据:inheritableThreadLocalCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>实现原理是子线程是通过在父线程中通过调用<code>new Thread()</code>方法来创建子线程，<code>Thread#init</code>方法在<code>Thread</code>的构造方法中被调用。在<code>init</code>方法中拷贝父线程数据到子线程中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>但<code>InheritableThreadLocal</code>仍然有缺陷，一般我们做异步化处理都是使用的线程池，而<code>InheritableThreadLocal</code>是在<code>new Thread</code>中的<code>init()</code>方法给赋值的，而线程池是线程复用的逻辑，所以这里会存在问题。</p><p>当然，有问题出现就会有解决问题的方案，阿里巴巴开源了一个<code>TransmittableThreadLocal</code>组件就可以解决这个问题，这里就不再延伸，感兴趣的可自行查阅资料。</p><h2 id="怎么解决内存泄漏"><a href="#怎么解决内存泄漏" class="headerlink" title="怎么解决内存泄漏"></a>怎么解决内存泄漏</h2><p>当使用ThreadLocal保存一个value时，会在ThreadLocalMap中的数组插入一个Entry对象，按理说key-value都应该以强引用保存在Entry对象中，但在ThreadLocalMap的实现中，key被保存到了WeakReference对象中。这就导致了一个问题，ThreadLocal在没有外部强引用时，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><p>解决：使用remove</p><p>调用remove方法，肯定会删除对应的Entry对象</p><img src="/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/1.png" class title="内存模型"><h2 id="为什么要用弱引用"><a href="#为什么要用弱引用" class="headerlink" title="为什么要用弱引用"></a>为什么要用弱引用</h2><p>那换做强引用分析： <code>ThreadLocal</code>对象被两个强引用指向</p><ul><li>强引用： threadlocal1</li><li>强引用： Entry.key</li></ul><p>当我们断开程序中的强引用 <code>threadlocal1</code>时。<code>ThreadLocal</code>对象仍然被强引用<code>Entry.key</code>指向，不会回收，这就造成，<code>ThreadLocal</code>对象与 <code>value</code>都成为了脏数据。</p><h2 id="弱引用带来哪些问题"><a href="#弱引用带来哪些问题" class="headerlink" title="弱引用带来哪些问题"></a>弱引用带来哪些问题</h2><p>不管软引用还是强引用，都可能出现内存泄漏问题，弱引用反而将内存泄漏的程度降低**</p><p>利用弱引用的<strong>Entry会有key为null这个特征</strong>，可以识别哪些是不用的数据，进行清理操作，弱引用 反而提高了ThreadLocal的安全性。事实上当调用<code>ThreadLocal</code>的<code>get(),set(),reomve()</code>方法，都会清除掉线程<code>ThreadLocalMap</code>中所有Entry中Key为null的Value，并将整个Entry设置为null，利于下次内存回收。</p><h2 id="ThreadLocal可能存在哪些问题？"><a href="#ThreadLocal可能存在哪些问题？" class="headerlink" title="ThreadLocal可能存在哪些问题？"></a>ThreadLocal可能存在哪些问题？</h2><p>线程复用会产生脏数据，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用。如果没有调用 remove 清理与线程相关的 ThreadLocal 信息，那么假如下一个线程没有调用 set 设置初始值就可能 get 到重用的线程信息。</p><p>ThreadLocal 还存在内存泄漏的问题，由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放。因此需要及时调用 remove 方法进行清理操作。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的设计原则</title>
      <link href="/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><p><strong>开闭原则：</strong>面向对象设计中最基础的设计原则，指一个软件实体（类、模块、方法等）应该对扩展开放，对修改关闭。它强调用抽象构建框架，用实现扩展细节，提高代码的可复用性和可维护性。例如在版本更新时尽量不修改源代码，但可以增加新功能。</p><p><strong>单一职责原则：</strong>一个类、接口或方法只负责一个职责，可以提高代码可读性和可维护性，降低代码复杂度以及变更引起的风险。</p><p><strong>依赖倒置原则：</strong>程序应该依赖于抽象类或接口，而不是具体的实现类。可以降低代码的耦合度，提高系统的稳定性。</p><p><strong>接口隔离原则：</strong>将不同功能定义在不同接口中实现接口隔离，避免了类依赖它不需要的接口，减少了接口之间依赖的冗余性和复杂性。</p><p><strong>里氏替换原则：</strong>对开闭原则的补充，规定了任何父类可以出现的地方子类都一定可以出现，可以约束继承泛滥，加键程序健壮性。</p><p><strong>迪米特原则：</strong>也叫最少知道原则，每个模块对其他模块都要尽可能少的了解和依赖，可以降低代码耦合度。</p><p><strong>合成/聚合原则：</strong>尽量使用组合(has a)或聚合(contains a)而不是继承关系达到软件复用的目的，可以使系统更加灵活，降低耦合度。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型</title>
      <link href="/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
      <url>/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><strong>静态代理：代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hr</span> <span class="keyword">implements</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我需要找招聘一个员工"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hr hr;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hr = <span class="keyword">new</span> Hr();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hr.findWorker();</span><br><span class="line">        System.out.println(<span class="string">"找到了员工"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Company company=<span class="keyword">new</span> Proxy();</span><br><span class="line">        company.findWorker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理：</strong>动态代理在程序运行时才创建具体的代理类，代理类和被代理类的关系在运行前是不确定的。动态代理的适用性更强，主要分为 JDK 动态代理和 CGLib 动态代理。</p><p> JDK 动态代理：通过 Proxy类的 newInstance 方法获取一个动态代理对象，需要传入三个参数，被代理对象的类加载器、被代理对象实现的接口，以及一个 InvocationHandler 调用处理器实例来指明具体的逻辑，相比静态代理最大的优势是接口中声明的所有方法都被转移到 InvocationHandler 中的 invoke 方法集中处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hr hr = <span class="keyword">new</span> Hr();</span><br><span class="line">        Company proxyHr = (Company) Proxy.newProxyInstance(hr.getClass().getClassLoader(), hr.getClass().getInterfaces(), (proxy, method, args1) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"接收代理请求"</span>);</span><br><span class="line">            Object obj = method.invoke(hr, args1);</span><br><span class="line">            System.out.println(<span class="string">"找到了员工，完成请求"</span>);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;);</span><br><span class="line">        proxyHr.findWorker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VMWARE+Centos8配置静态IP地址</title>
      <link href="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/"/>
      <url>/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/1.png" class title="第一步"><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/2.png" class title="第二步"><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/3.png" class title="第三步"><p>打开网络和共享中心—&gt;更改适配器配置—–&gt;右键VMware Network Adapter—&gt;属性—-&gt;双击IPv4—&gt;</p><p>设置IP地址 以及网关</p><p>网关地址必须和vmwareNAT设置的一致，IP保持同一网段内即可</p><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/4.png" class title="如图所示"><p>重启虚拟机</p><p>使用root 用户修改 linux网络配置</p><p>su root</p><p>vi /etc/sysconfig/network-scripts/ifcfg-ens33</p><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/5.png" class title="如图所示"><p>重启网卡</p><p>nmcli c reload</p><p>配置到这里可以实现本机与虚拟机之间的通信了</p><p>虚拟机连接外网</p><p>如果你本机可以连接外网，但是虚拟机ping baidu.com 返回错误信息了，需要绑定DNS</p><p>vi /etc/resolv.conf （没有此文件新建一个即可）</p><p>nameserver 网关地址</p><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/6.png" class title="如图所示"><blockquote><p>链接：<a href="https://www.jianshu.com/p/6801da089cf2" target="_blank" rel="noopener">https://www.jianshu.com/p/6801da089cf2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker search报错解决方法</title>
      <link href="/2020/06/14/docker-search%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/14/docker-search%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ docker search sameersbn</span><br><span class="line">Error response from daemon: Get https:<span class="comment">//index.docker.io/v1/search?q=sameersbn&amp;n=25: dial tcp: lookup index.docker.io on 192.168.65.1:53: read udp 192.168.65.2:45190-&gt;192.168.65.1:53: i/o timeout</span></span><br></pre></td></tr></table></figure><p>解决方法:</p><p>通过dig @114.114.114.114 registry-1.docker.io找到可用ip</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ dig @<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span> registry-<span class="number">1</span>.docker.io</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG <span class="number">9.8</span><span class="number">.3</span>-P1 &lt;&lt;&gt;&gt; @<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span> registry-<span class="number">1</span>.docker.io</span><br><span class="line">; (<span class="number">1</span> server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: <span class="number">47220</span></span><br><span class="line">;; flags: qr rd ra; QUERY: <span class="number">1</span>, ANSWER: <span class="number">8</span>, AUTHORITY: <span class="number">4</span>, ADDITIONAL: <span class="number">9</span></span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: <span class="number">0</span>, flags:; udp: <span class="number">4096</span></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;registry-<span class="number">1</span>.docker.io.        IN    A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">54.164</span><span class="number">.230</span><span class="number">.151</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">35.169</span><span class="number">.231</span><span class="number">.249</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">34.205</span><span class="number">.207</span><span class="number">.96</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">34.200</span><span class="number">.28</span><span class="number">.105</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">52.204</span><span class="number">.202</span><span class="number">.231</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">54.152</span><span class="number">.209</span><span class="number">.167</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">52.22</span><span class="number">.181</span><span class="number">.254</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">52.54</span><span class="number">.216</span><span class="number">.153</span></span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">1827</span>.awsdns-<span class="number">36</span>.co.uk.</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">1168</span>.awsdns-<span class="number">18</span>.org.</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">513</span>.awsdns-<span class="number">00</span>.net.</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">421</span>.awsdns-<span class="number">52</span>.com.</span><br><span class="line"></span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">ns-<span class="number">421</span>.awsdns-<span class="number">52</span>.com.    <span class="number">148245</span>    IN    A    <span class="number">205.251</span><span class="number">.193</span><span class="number">.165</span></span><br><span class="line">ns-<span class="number">421</span>.awsdns-<span class="number">52</span>.com.    <span class="number">149402</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5301</span>:a500::<span class="number">1</span></span><br><span class="line">ns-<span class="number">513</span>.awsdns-<span class="number">00</span>.net.    <span class="number">149549</span>    IN    A    <span class="number">205.251</span><span class="number">.194</span><span class="number">.1</span></span><br><span class="line">ns-<span class="number">513</span>.awsdns-<span class="number">00</span>.net.    <span class="number">149549</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5302</span>:<span class="number">100</span>::<span class="number">1</span></span><br><span class="line">ns-<span class="number">1168</span>.awsdns-<span class="number">18</span>.org.    <span class="number">148917</span>    IN    A    <span class="number">205.251</span><span class="number">.196</span><span class="number">.144</span></span><br><span class="line">ns-<span class="number">1168</span>.awsdns-<span class="number">18</span>.org.    <span class="number">148917</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5304</span>:<span class="number">9000</span>::<span class="number">1</span></span><br><span class="line">ns-<span class="number">1827</span>.awsdns-<span class="number">36</span>.co.uk. <span class="number">148040</span>    IN    A    <span class="number">205.251</span><span class="number">.199</span><span class="number">.35</span></span><br><span class="line">ns-<span class="number">1827</span>.awsdns-<span class="number">36</span>.co.uk. <span class="number">148040</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5307</span>:<span class="number">2300</span>::<span class="number">1</span></span><br><span class="line"></span><br><span class="line">;; Query time: <span class="number">60</span> msec</span><br><span class="line">;; SERVER: 114.114.114.114#53(114.114.114.114)</span><br><span class="line">;; WHEN: Mon Aug <span class="number">20</span> <span class="number">22</span>:<span class="number">36</span>:<span class="number">29</span> <span class="number">2018</span></span><br><span class="line">;; MSG SIZE  rcvd: <span class="number">493</span></span><br></pre></td></tr></table></figure><p>尝试修改<code>/etc/hosts</code>强制<code>docker.io</code>相关的域名解析到其它可用IP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">54.164</span><span class="number">.230</span><span class="number">.151</span> registry-<span class="number">1</span>.docker.io</span><br></pre></td></tr></table></figure><p>保存后重试，成功！！</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker的安装和基本用法</title>
      <link href="/2020/06/14/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2020/06/14/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Centos安装命令"><a href="#Centos安装命令" class="headerlink" title="Centos安装命令"></a>Centos安装命令</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:<span class="comment">//get.docker.com | bash -s docker --mirror Aliyun</span></span><br></pre></td></tr></table></figure><h2 id="Docker基本用法"><a href="#Docker基本用法" class="headerlink" title="Docker基本用法"></a>Docker基本用法</h2><p>启动docker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>停止docker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p>docker搜索镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p>docker拉取镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull  mysql</span><br></pre></td></tr></table></figure><p>docker启动容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>查看正在运行容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>删除容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm id</span><br></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi id</span><br></pre></td></tr></table></figure><p>查看镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(行为型)</title>
      <link href="/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
      <url>/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CurrentConditionsDisplay implements Observer &#123;</span><br><span class="line">    public CurrentConditionsDisplay(Subject weatherData) &#123;</span><br><span class="line">        weatherData.registerObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(float temp) &#123;</span><br><span class="line">        System.out.println(&quot;Current temp: &quot;+temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StatisticsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">        weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Statistics temp: "</span>+temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            o.update(temperature);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">        CurrentConditionsDisplay currentConditionsDisplay = <span class="keyword">new</span></span><br><span class="line">                CurrentConditionsDisplay(weatherData);</span><br><span class="line">        StatisticsDisplay statisticsDisplay = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">0</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeOrTea</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        boil();</span><br><span class="line">        brew();</span><br><span class="line">        pour();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pour</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"boil"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">CaffeOrTea</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Coffee.brew"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">CaffeOrTea</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Tea.brew"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CaffeeOrTea c=<span class="keyword">new</span> Coffee();</span><br><span class="line">        c.prepare();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>定义一系列算法，封装每个算法，并使它们可以互换。</p><p>设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Quack!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gaga</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Gaga!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> QuackBehavior quackBehavior;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (quackBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">  quackBehavior.quack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.quackBehavior = quackBehavior;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Duck duck = <span class="keyword">new</span> Duck();</span><br><span class="line">    duck.setQuackBehavior(<span class="keyword">new</span> Squeak());</span><br><span class="line">    duck.performQuack();</span><br><span class="line">    duck.setQuackBehavior(<span class="keyword">new</span> Quack());</span><br><span class="line">    duck.performQuack();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(创建型)</title>
      <link href="/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
      <url>/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Ⅰ-懒汉式-线程不安全"><a href="#Ⅰ-懒汉式-线程不安全" class="headerlink" title="Ⅰ 懒汉式-线程不安全"></a>Ⅰ 懒汉式-线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton get <span class="title">uniqueInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅱ-饿汉式-线程安全"><a href="#Ⅱ-饿汉式-线程安全" class="headerlink" title="Ⅱ 饿汉式-线程安全"></a>Ⅱ 饿汉式-线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s =<span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton get <span class="title">uniqueInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅲ-懒汉式-线程安全"><a href="#Ⅲ-懒汉式-线程安全" class="headerlink" title="Ⅲ 懒汉式-线程安全"></a>Ⅲ 懒汉式-线程安全</h2><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待,这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton get <span class="title">uniqueInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅳ-双重校验锁-线程安全"><a href="#Ⅳ-双重校验锁-线程安全" class="headerlink" title="Ⅳ 双重校验锁-线程安全"></a>Ⅳ 双重校验锁-线程安全</h2><p>第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了<br>加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实<br>是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址<br>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在<br>多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用<br>getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被<br>初始化。<br>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    s=<span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> s;</span><br><span class="line">    &#125;                                                                                                                                                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅴ-静态内部类实现"><a href="#Ⅴ-静态内部类实现" class="headerlink" title="Ⅴ 静态内部类实现"></a>Ⅴ 静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE=<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来<br>实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">  Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// do something with the product</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂方法</p><p>多个工厂，一种抽象产品。例如一个麦当劳店，可以生产多种汉堡，一个肯德基店，也可以生产多种汉堡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">作者：冠状病毒biss</span><br><span class="line">链接：https:<span class="comment">//www.nowcoder.com/discuss/438905?type=all&amp;order=time&amp;pos=&amp;page=1&amp;channel=666&amp;source_id=search_all</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Hamburger <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCFactory</span> <span class="keyword">implements</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MCHamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCFactory</span> <span class="keyword">implements</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KFCHamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃麦当劳汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃肯德基汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HamburgerFactory mcFactory=<span class="keyword">new</span> MCFactory();</span><br><span class="line">    Hamburger hamburger=mcFactory.build();</span><br><span class="line">    hamburger.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>股票问题</title>
      <link href="/2020/06/13/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/06/13/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>股票问题（1）</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min=prices[<span class="number">0</span>],max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            max=Math.max(max,prices[i]-min);</span><br><span class="line">            min=Math.min(min,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>股票问题（2）</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="comment">//    能挣钱就卖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(prices[i]&gt;=prices[i-<span class="number">1</span>])</span><br><span class="line">          &#123;</span><br><span class="line">              ans+=(prices[i]-prices[i-<span class="number">1</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>股票问题 (3)</p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: [3,3,5,0,0,3,1,4]<br>输出: 6<br>解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        对于任意一天考虑四个变量:</span></span><br><span class="line"><span class="comment">        fstBuy: 在该天第一次买入股票可获得的最大收益 </span></span><br><span class="line"><span class="comment">        fstSell: 在该天第一次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secBuy: 在该天第二次买入股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secSell: 在该天第二次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        分别对四个变量进行相应的更新, 最后secSell就是最大</span></span><br><span class="line"><span class="comment">        收益值(secSell &gt;= fstSell)</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">int</span> fstBuy = Integer.MIN_VALUE, fstSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> secBuy = Integer.MIN_VALUE, secSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            fstBuy = Math.max(fstBuy, -p);</span><br><span class="line">            fstSell = Math.max(fstSell, fstBuy + p);</span><br><span class="line">            secBuy = Math.max(secBuy, fstSell - p);</span><br><span class="line">            secSell = Math.max(secSell, secBuy + p); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>股票(4)</p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: [2,4,1], k = 2<br>输出: 2<br>解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        当k大于等于数组长度一半时, 问题退化为贪心问题此时采用 买卖股票的最佳时机 II</span></span><br><span class="line"><span class="comment">        的贪心方法解决可以大幅提升时间性能, 对于其他的k, 可以采用 买卖股票的最佳时机 III</span></span><br><span class="line"><span class="comment">        的方法来解决, 在III中定义了两次买入和卖出时最大收益的变量, 在这里就是k租这样的</span></span><br><span class="line"><span class="comment">        变量, 即问题IV是对问题III的推广, t[i][0]和t[i][1]分别表示第i比交易买入和卖出时</span></span><br><span class="line"><span class="comment">        各自的最大收益</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= prices.length/<span class="number">2</span>) <span class="keyword">return</span> greedy(prices);</span><br><span class="line">        <span class="keyword">int</span>[][] t = <span class="keyword">new</span> <span class="keyword">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            t[i][<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            t[<span class="number">0</span>][<span class="number">0</span>] = Math.max(t[<span class="number">0</span>][<span class="number">0</span>], -p);</span><br><span class="line">            t[<span class="number">0</span>][<span class="number">1</span>] = Math.max(t[<span class="number">0</span>][<span class="number">1</span>], t[<span class="number">0</span>][<span class="number">0</span>] + p);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                t[i][<span class="number">0</span>] = Math.max(t[i][<span class="number">0</span>], t[i-<span class="number">1</span>][<span class="number">1</span>] - p);</span><br><span class="line">                t[i][<span class="number">1</span>] = Math.max(t[i][<span class="number">1</span>], t[i][<span class="number">0</span>] + p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t[k-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>])</span><br><span class="line">                max += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/2020/05/31/ArrayList/"/>
      <url>/2020/05/31/ArrayList/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>[TOC]</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>需要使用 grow() 方法进行扩容，新容量的大小为 oldCapacity + (oldCapacity &gt;&gt; 1) ，也就是旧容量的 1.5 倍。<br>扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建<br>ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">      &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">      int oldCapacity &#x3D; elementData.length;</span><br><span class="line">      int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">      if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">          newCapacity &#x3D; minCapacity;</span><br><span class="line">      if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">          newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">      &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">      elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看<br>出 ArrayList 删除元素的代价是非常高的。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行<br>序列化。<br>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData; &#x2F;&#x2F; non-private to simplify nested class access</span><br></pre></td></tr></table></figure><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p><h2 id="与Vector比较"><a href="#与Vector比较" class="headerlink" title="与Vector比较"></a>与Vector比较</h2><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean add(E e) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + 1);</span><br><span class="line">    elementData[elementCount++] &#x3D; e;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized E get(int index) &#123;</span><br><span class="line">    if (index &gt;&#x3D; elementCount)</span><br><span class="line">    throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 ArrayList的比较</p><p>①Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步<br>操作完全可以由程序员自己来控制；<br>②Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</p><h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><h3 id="synchronizedList"><a href="#synchronizedList" class="headerlink" title="synchronizedList"></a>synchronizedList</h3><p>在SynchronizedList内部维护了一个普通对象Collection，还有排斥锁mutex.创建出synchronizedList之后，再操作List的时候，就会对方法上锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; synList &#x3D; Collections.synchronizedList(arrayList);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.add(e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.remove(o);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean containsAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.containsAll(coll);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; coll) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.addAll(coll);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean removeAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.removeAll(coll);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean retainAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.retainAll(coll);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">    synchronized (mutex) &#123;c.clear();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。<br>写操作需要加锁，防止并发写入时导致写入数据丢失。<br>写操作结束之后需要把原始数组指向新的复制数组。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：<br>①内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；<br>②数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。<br>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>底层<strong>通过双向链表实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个链表存储了 first 和 last 指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h3 id="与-ArrayList-的比较"><a href="#与-ArrayList-的比较" class="headerlink" title="与 ArrayList 的比较"></a>与 ArrayList 的比较</h3><ol><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h3 id="3-1-先从-ArrayList-的构造函数说起"><a href="#3-1-先从-ArrayList-的构造函数说起" class="headerlink" title="3.1. 先从 ArrayList 的构造函数说起"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_31-先从-arraylist-的构造函数说起" target="_blank" rel="noopener">3.1. 先从 ArrayList 的构造函数说起</a></h3><p><strong>ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">            <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">            <span class="comment">//创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">    *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p><h3 id="一步一步分析-ArrayList-扩容机制"><a href="#一步一步分析-ArrayList-扩容机制" class="headerlink" title="一步一步分析 ArrayList 扩容机制"></a>一步一步分析 ArrayList 扩容机制</h3><p>这里以无参构造函数创建的 ArrayList 为例分析</p><ul><li>初始化出来的容量为0，添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，具体的逻辑是如果minCapacity为0，则将其初始化为10</li><li>随后调用ensureExplicitCapacity()，它会根据minCapacity判断容量是否足够，如果不够，调用grow方法进行扩容，具体扩容的逻辑是旧容量的 1.5 倍。</li><li>然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，如果新容量大于 MAX_ARRAY_SIZE,比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</li><li>扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建<br>ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</li></ul><h4 id="先来看-add-方法"><a href="#先来看-add-方法" class="headerlink" title="先来看 add 方法"></a>先来看 <code>add</code> 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h4 id="再来看看-ensureCapacityInternal-方法"><a href="#再来看看-ensureCapacityInternal-方法" class="headerlink" title="再来看看 ensureCapacityInternal() 方法"></a>再来看看 <code>ensureCapacityInternal()</code> 方法</h4><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p><h4 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity() 方法"></a><code>ensureExplicitCapacity()</code> 方法</h4><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>我们来仔细分析一下：</p><ul><li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><h4 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow() 方法"></a><code>grow()</code> 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p><ul><li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li><li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li><li>以此类推······</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h3 id="3-3-System-arraycopy-和-Arrays-copyOf-方法"><a href="#3-3-System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="3.3. System.arraycopy() 和 Arrays.copyOf()方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_33-systemarraycopy-和-arrayscopyof方法" target="_blank" rel="noopener">3.3. <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</a></h3><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p><h4 id="3-3-1-System-arraycopy-方法"><a href="#3-3-1-System-arraycopy-方法" class="headerlink" title="3.3.1. System.arraycopy() 方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_331-systemarraycopy-方法" target="_blank" rel="noopener">3.3.1. <code>System.arraycopy()</code> 方法</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>我们写一个简单的方法测试以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraycopyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        System.arraycopy(a, <span class="number">2</span>, a, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        a[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 99 2 3 0 0 0 0 0Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="3-3-2-Arrays-copyOf-方法"><a href="#3-3-2-Arrays-copyOf-方法" class="headerlink" title="3.3.2. Arrays.copyOf()方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_332-arrayscopyof方法" target="_blank" rel="noopener">3.3.2. <code>Arrays.copyOf()</code>方法</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"> <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayscopyOfTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] b = Arrays.copyOf(a, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"b.length"</span>+b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="3-3-3-两者联系和区别"><a href="#3-3-3-两者联系和区别" class="headerlink" title="3.3.3. 两者联系和区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_333-两者联系和区别" target="_blank" rel="noopener">3.3.3. 两者联系和区别</a></h4><p><strong>联系：</strong></p><p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong></p><p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机面试问题</title>
      <link href="/2020/05/31/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/2020/05/31/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p>在垃圾回收过程中经常涉及到对对象的挪动（比如上文提到的对象在Survivor 0和Survivor 1之间的复制），进而导致需要对对象引用进行更新。为了保证引用更新的正确性，Java将暂停所有其他的线程，这种情况被称为“Stop-The-World”，导致系统全局停顿</p><h3 id="JDBC和双亲委派模型关系"><a href="#JDBC和双亲委派模型关系" class="headerlink" title="JDBC和双亲委派模型关系"></a>JDBC和双亲委派模型关系</h3><h3 id="JVM-中一次完整的-GC-流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的-JVM-参数"><a href="#JVM-中一次完整的-GC-流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的-JVM-参数" class="headerlink" title="JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数"></a>JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数</h3><h5 id="一次完整的gc过程"><a href="#一次完整的gc过程" class="headerlink" title="一次完整的gc过程"></a>一次完整的gc过程</h5><p>gc是通过垃圾收集器来实现的，现代垃圾收集器大部分都是基于分代收集理论设计的，也就是将对象划分为新生代，老年代。其中新生代分为Eden区和两块Survivor区，比例为8：1：1。<br>每次分配内存都只会使用Eden区和一块Survivor区，对象默认是放在Eden区，但是如果对象太大了，Eden区放不下，那么就会放入到老年代中，当发生gc时，就会把存活对象放到另一块Survivor上，如果这块survivor区不够，那么依赖老年代进行担保，假设这块为s0区，另一块是s1区。下一次Eden区满的时候，进行一次MinorGc，会将Eden区和S0区存活的对象放到s1中，如果s1，放不下就会放到老年代中。然后循环往复，始终保证s0和s1中又一个区域是空的，一个对象默认最多经历15次gc，一旦超过15次gc就会放入到老年代中。但是如果在Survivor空间中，相同年龄的对象超过Survivor空间的一半，并不会等到对象的年龄到达15才进入老年代，这些相同年龄的对象会直接进入到老年代中</p><h5 id="对象晋升到老年代一共有四种情况"><a href="#对象晋升到老年代一共有四种情况" class="headerlink" title="对象晋升到老年代一共有四种情况"></a>对象晋升到老年代一共有四种情况</h5><ol><li>对象太大，Eden放不下</li><li>存放存活对象的Survivor区太小，不足以存下存活对象</li><li>经历超过默认15次gc或者设定的</li><li>Survivor空间中相同年龄的所有对象综合大于等于Survivor空间的一半，那么这些对象就会直接进入到老年代中</li></ol><h3 id="cms怎么解决内存碎片的问题（full-gc）"><a href="#cms怎么解决内存碎片的问题（full-gc）" class="headerlink" title="cms怎么解决内存碎片的问题（full gc）"></a>cms怎么解决内存碎片的问题（full gc）</h3><blockquote><ul><li>增大Xmx或者减少Xmn </li><li>在应用访问量最低的时候，在程序中主动调用System.gc()，比如每天凌晨。 </li><li>在应用启动并完成所有初始化工作后，主动调用System.gc()，它可以将初始化的数据压缩到一个单独的chunk中，以腾出更多的连续内存空间给新生代晋升使用。 </li><li>CMS收集器提供了一个-XX：+UseCMS-CompactAtFullCollection开关参数（默认是开启的，此参数从<br>JDK 9开始废弃），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个<br>内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的。这样空间碎片问题是解<br>决了，但停顿时间又会变长，因此虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBefore-<br>Compaction（此参数从JDK 9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量<br>由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表<br>示每次进入Full GC时都进行碎片整理）。</li></ul></blockquote><h3 id="new一个object对象，然后再赋值给一个静态变量，然后问这个过程在JVM内存是什么个过程"><a href="#new一个object对象，然后再赋值给一个静态变量，然后问这个过程在JVM内存是什么个过程" class="headerlink" title="new一个object对象，然后再赋值给一个静态变量，然后问这个过程在JVM内存是什么个过程"></a>new一个object对象，然后再赋值给一个静态变量，然后问这个过程在JVM内存是什么个过程</h3><p>（回答会把创建的实例对象放到堆内存区域，然后再把指向对象的内存地址赋值给符号引用，让这个符号引用指向对应的堆内存区域)?</p><p>如果我要设置一个内存缓冲区，让垃圾收集器不对其进行操作怎么办</p><p> 代码实现每五分钟一次Minor GC，如果要FullGC呢?</p><p>类加载，class.forname 和 classloader的区别，双亲委派原则。被问到不使用双亲委派原则，如何自定义java.lang.Integer会怎么样（我自定义过 java.lang.Integer，使用直接抛出异常，说包违法）。可能还是不够深入。</p><p>方法区会不会 OOM</p><p><strong>Class.forName 是否会初始化类</strong> （这里我智障了，振振有词地说 说不会初始化……感觉要凉。。） </p><p>使用类加载器和Class.forName来获取class的时候，是否进行了初始化？</p><p>实际上使用类加载器来加载class的时候，只是加载该类，没有初始化，但是Class.forName就初始化了的</p><p>如果初始化一个类，首先是运行里面的静态代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package classLoader;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class A&#123;</span><br><span class="line">public A()&#123;</span><br><span class="line">System.out.println(&quot;创建类的时候运行这段代码&quot;);</span><br><span class="line">&#125;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;这里是类静态代码块，初始化类的时候就会运行一次&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class ClassLoaderT &#123;</span><br><span class="line">public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">&#x2F;&#x2F;首先是获得类加载器</span><br><span class="line">ClassLoader cl&#x3D;ClassLoader.getSystemClassLoader();</span><br><span class="line">cl.loadClass(&quot;classLoader.A&quot;);&#x2F;&#x2F;这里根据全类名来查找这个类，所以如果只是输入&quot;A&quot;就会报错。</span><br><span class="line">System.out.println(&quot;-----------------------------&quot;);</span><br><span class="line">Class.forName(&quot;classLoader.A&quot;);这里根据全类名来查找这个类，所以如果只是输入&quot;A&quot;就会报错。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台：</p><p><img src="https://img-blog.csdnimg.cn/20190628122703735.png" alt="img"></p><h3 id="Full-GC-发生的条件、怎么设置永久代和堆的大小、怎么减少-Full-GC-、JVM-调优"><a href="#Full-GC-发生的条件、怎么设置永久代和堆的大小、怎么减少-Full-GC-、JVM-调优" class="headerlink" title="Full GC 发生的条件、怎么设置永久代和堆的大小、怎么减少 Full GC 、JVM 调优"></a><strong>Full GC 发生的条件、怎么设置永久代和堆的大小、怎么减少 Full GC 、JVM 调优</strong></h3><p>-XX:PermSize 和 -XX:MaxPermSize：指定JVM中的永久代(方法区)的大小。</p><p>-Xms 和 -Xmx (-XX:InitialHeapSize 和 -XX:MaxHeapSize)：指定JVM初始占用的堆内存和最大堆内存。</p><p><img src="https://images2015.cnblogs.com/blog/285763/201611/285763-20161118115316810-1826109116.png" alt="img"></p><h3 id="为什么用元空间替代了永久代，元空间里面的对象是会被回收的吗？"><a href="#为什么用元空间替代了永久代，元空间里面的对象是会被回收的吗？" class="headerlink" title="为什么用元空间替代了永久代，元空间里面的对象是会被回收的吗？"></a>为什么用元空间替代了永久代，元空间里面的对象是会被回收的吗？</h3><p><img src="https://img2018.cnblogs.com/blog/285763/201912/285763-20191205135008326-1042628756.png" alt="img"></p><p><strong>原因一</strong>：因为直接内存，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作。而非直接内存，也就是堆内存中的数据，如果要作IO操作，会先复制到直接内存，再利用本地IO处理。</p><ul><li>从数据流的角度，非直接内存是下面这样的作用链：本地IO –&gt; 直接内存 –&gt; 非直接内存 –&gt; 直接内存 –&gt; 本地IO</li><li>而直接内存是：本地IO –&gt; 直接内存 –&gt; 本地IO</li></ul><p><strong>原因二</strong>：整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError。</p><ul><li>可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。</li><li><code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</li></ul><p><strong>原因三：</strong></p><p>可以在GC不进行暂停的情况下并发地释放类数据。</p><h3 id="gc引用计数法的缺点，除了循环引用，说一到两个"><a href="#gc引用计数法的缺点，除了循环引用，说一到两个" class="headerlink" title="gc引用计数法的缺点，除了循环引用，说一到两个"></a><strong>gc引用计数法的缺点，除了循环引用，说一到两个</strong></h3><p>  想了很多，跨代引用都想了，最后说不出来，提示我可以从【设计gc<a href>算法</a>需要考虑什么因素】上来回答，想不出来 </p><p>  他说了可以考虑stw、访问局部性、堆大小（这个没听清楚），然后问我局部访问性知道吗，我以为是jvm里的新知识就说了不知道，然后他解释了一下，我才知道噢原来就是os的局部性原理。。。 </p><p>  然后他问你觉得引用计数***影响到哪几点，面试官看我没反应就说ok，然后跟我解释了，主要是一个链式更新、堆的使用效率的问题，引用计数法优点在于他是实时删除的。 </p><p>  其实到这里我心态已经崩了，只想退出面试间 😔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用技术除了循环依赖问题（可以通过弱引用解决），最大的问题就是开销大，因为他要计算实时计算局部信息，导致整个系统的吞吐量降低，优点是几乎是实时的，这也从侧面说明了，吞吐量和延迟是不可兼得的，但是局部性原理和堆大小不知道跟这个有啥关系。可能是需要实时计算引用关系，导致cache平繁被刷新从而导致程序访问的时候命中率底？</span><br></pre></td></tr></table></figure><p><strong>追问不同的类加载器加载同一个类是隔离还是共享</strong></p><p>答了隔离，他大概觉得我说的没有底气，就跟我解释了为什么是隔离的（除bug）。</p><p>类的全称是相同的，类加载器相同.这里的初始化可以理解为,类加载的最后一步(调用<code>&lt;clinit&gt;</code>),如果是两个不同的ClassLoad加载的话那么<code>&lt;clinit&gt;</code>会被执行两次,加载的<code>Class</code>对象在方法区(永久代),并且会对应两个<code>Class</code>对象.</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型(一)</title>
      <link href="/2020/05/30/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/05/30/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-内存模型的定义"><a href="#1-内存模型的定义" class="headerlink" title="1.内存模型的定义"></a>1.内存模型的定义</h2><p>Java 内存模型试图来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，又在CPU里加了好几层高速缓存。</p><p>在Java内存模型里，对上述的优化又进行了一些抽象。JMM规定所有变量都是存在主存中的，每个线程又包含自己的工作内存，也就是CPU上的寄存器或者高速缓存。所以线程的操作都只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</p><img src="/2020/05/30/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/JMM.png" class title="this is} ## 2.内存间交互操作 {% asset_img 1.png 操作"><p>read：把一个变量的值从主内存传输到工作内存中<br>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中<br>use：把工作内存中一个变量的值传递给执行引擎<br>assign：把一个从执行引擎接收到的值赋给工作内存的变量<br>store：把工作内存的一个变量的值传送到主内存中<br>write：在 store 之后执行，把 store 得到的值放入主内存的变量中<br>lock：作用于主内存的变量<br>unlock</p><h2 id="3-内存模型三大特性"><a href="#3-内存模型三大特性" class="headerlink" title="3.内存模型三大特性"></a>3.内存模型三大特性</h2><p>1.原子性：</p><p><strong>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。</strong></p><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int<br>类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的<br>64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以<br>不具备原子性。</p><p>2.可见性</p><p><strong>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。</strong>Java 内存模型是通过在变量修改后将新<br>值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引<br>用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><p>3.有序性</p><p>有序性是指：<strong>在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因</strong><br><strong>为发生了指令重排序。</strong>在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程<br>程序的执行，却会影响到多线程并发执行的正确性。<br>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test1</title>
      <link href="/2020/05/25/test1/"/>
      <url>/2020/05/25/test1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> hexo相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/05/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/05/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>##第一章</p><p>内容</p><hr><p>##第二章</p><p>##<a href="https://blog.csdn.net/xjm850552586/article/details/84101345?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/25/hello-world/"/>
      <url>/2020/05/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
