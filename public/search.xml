<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kafka的集群选举、分区再平衡、数据同步</title>
      <link href="/2020/11/04/kafka%E7%9A%84%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE%E3%80%81%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
      <url>/2020/11/04/kafka%E7%9A%84%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE%E3%80%81%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka怎么保证顺序消费</title>
      <link href="/2020/11/04/kafka%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9/"/>
      <url>/2020/11/04/kafka%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka消息堆积</title>
      <link href="/2020/11/04/kafka%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF/"/>
      <url>/2020/11/04/kafka%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何保证消费的幂等性</title>
      <link href="/2020/11/04/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>/2020/11/04/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper在kafka中的作用</title>
      <link href="/2020/11/04/zookeeper%E5%9C%A8kafka%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2020/11/04/zookeeper%E5%9C%A8kafka%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Zookeeper-在-Kafka-中的作用"><a href="#Zookeeper-在-Kafka-中的作用" class="headerlink" title="Zookeeper 在 Kafka 中的作用"></a>Zookeeper 在 Kafka 中的作用</h2><h3 id="1、Broker注册"><a href="#1、Broker注册" class="headerlink" title="1、Broker注册"></a>1、Broker注册</h3><p><strong>Broker是分布式部署并且相互之间相互独立，但是需要有一个注册系统能够将整个集群中的Broker管理起来</strong>，此时就使用到了Zookeeper。在Zookeeper上会有一个专门<strong>用来进行Broker服务器列表记录</strong>的节点：</p><p>/brokers/ids</p><p>每个Broker在启动时，都会到Zookeeper上进行注册，即到/brokers/ids下创建属于自己的节点，如/brokers/ids/[0…N]。</p><p>Kafka使用了全局唯一的数字来指代每个Broker服务器，不同的Broker必须使用不同的Broker ID进行注册，创建完节点后，<strong>每个Broker就会将自己的IP地址和端口信息记录</strong>到该节点中去。其中，Broker创建的节点类型是临时节点，一旦Broker宕机，则对应的临时节点也会被自动删除。</p><p>kafka的元数据都存放在zk上面,由zk来管理</p><h3 id="2、Topic注册"><a href="#2、Topic注册" class="headerlink" title="2、Topic注册"></a>2、Topic注册</h3><p>在Kafka中，同一个<strong>Topic的消息会被分成多个分区</strong>并将其分布在多个Broker上，<strong>这些分区信息及与Broker的对应关系</strong>也都是由Zookeeper在维护，由专门的节点来记录，如：</p><p>/borkers/topics</p><p>Kafka中每个Topic都会以/brokers/topics/[topic]的形式被记录，如/brokers/topics/login和/brokers/topics/search等。Broker服务器启动后，会到对应Topic节点（/brokers/topics）上注册自己的Broker ID并写入针对该Topic的分区总数，如/brokers/topics/login/3-&gt;2，这个节点表示Broker ID为3的一个Broker服务器，对于”login”这个Topic的消息，提供了2个分区进行消息存储，同样，这个分区节点也是临时节点。</p><h3 id="3、生产者负载均衡"><a href="#3、生产者负载均衡" class="headerlink" title="3、生产者负载均衡"></a>3、生产者负载均衡</h3><p>由于同一个Topic消息会被分区并将其分布在多个Broker上，因此，<strong>生产者需要将消息合理地发送到这些分布式的Broker上</strong>，那么如何实现生产者的负载均衡，Kafka支持传统的四层负载均衡，也支持Zookeeper方式实现负载均衡。</p><p>(1) 四层负载均衡，根据生产者的IP地址和端口来为其确定一个相关联的Broker。通常，一个生产者只会对应单个Broker，然后该生产者产生的消息都发往该Broker。这种方式逻辑简单，每个生产者不需要同其他系统建立额外的TCP连接，只需要和Broker维护单个TCP连接即可。但是，其无法做到真正的负载均衡，因为实际系统中的每个生产者产生的消息量及每个Broker的消息存储量都是不一样的，如果有些生产者产生的消息远多于其他生产者的话，那么会导致不同的Broker接收到的消息总数差异巨大，同时，生产者也无法实时感知到Broker的新增和删除。</p><p>(2) 使用Zookeeper进行负载均衡，由于每个Broker启动时，都会完成Broker注册过程，生产者会通过该节点的变化来动态地感知到Broker服务器列表的变更，这样就可以实现动态的负载均衡机制。</p><h3 id="4、消费者负载均衡"><a href="#4、消费者负载均衡" class="headerlink" title="4、消费者负载均衡"></a>4、消费者负载均衡</h3><p>与生产者类似，Kafka中的消费者同样需要进行负载均衡来实现多个消费者合理地从对应的Broker服务器上接收消息，每个消费者分组包含若干消费者，<strong>每条消息都只会发送给分组中的一个消费者</strong>，不同的消费者分组消费自己特定的Topic下面的消息，互不干扰。</p><h3 id="5、分区-与-消费者-的关系"><a href="#5、分区-与-消费者-的关系" class="headerlink" title="5、分区 与 消费者 的关系"></a>5、分区 与 消费者 的关系</h3><p><strong>消费组 (Consumer Group)：</strong><br> consumer group 下有多个 Consumer（消费者）。<br> 对于每个消费者组 (Consumer Group)，Kafka都会为其分配一个全局唯一的Group ID，Group 内部的所有消费者共享该 ID。订阅的topic下的每个分区只能分配给某个 group 下的一个consumer(当然该分区还可以被分配给其他group)。<br> 同时，Kafka为每个消费者分配一个Consumer ID，通常采用”Hostname:UUID”形式表示。</p><p>在Kafka中，规定了<strong>每个消息分区 只能被同组的一个消费者进行消费</strong>，因此，需要在 Zookeeper 上记录 消息分区 与 Consumer 之间的关系，每个消费者一旦确定了对一个消息分区的消费权力，需要将其Consumer ID 写入到 Zookeeper 对应消息分区的临时节点上，例如：</p><p>/consumers/[group_id]/owners/[topic]/[broker_id-partition_id]</p><p>其中，[broker_id-partition_id]就是一个 消息分区 的标识，节点内容就是该 消息分区 上 消费者的Consumer ID。</p><h3 id="6、消息-消费进度Offset-记录"><a href="#6、消息-消费进度Offset-记录" class="headerlink" title="6、消息 消费进度Offset 记录"></a>6、消息 消费进度Offset 记录</h3><p>在消费者对指定消息分区进行消息消费的过程中，<strong>需要定时地将分区消息的消费进度Offset记录到Zookeeper上</strong>，以便在该消费者进行重启或者其他消费者重新接管该消息分区的消息消费后，能够从之前的进度开始继续进行消息消费。Offset在Zookeeper中由一个专门节点进行记录，其节点路径为:</p><p>/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]</p><p>节点内容就是Offset的值。</p><h3 id="7、消费者注册"><a href="#7、消费者注册" class="headerlink" title="7、消费者注册"></a>7、消费者注册</h3><p>消费者服务器在初始化启动时加入消费者分组的步骤如下</p><p>注册到消费者分组。每个消费者服务器启动时，都会到Zookeeper的指定节点下创建一个属于自己的消费者节点，例如/consumers/[group_id]/ids/[consumer_id]，完成节点创建后，消费者就会将自己订阅的Topic信息写入该临时节点。</p><p><strong>对 消费者分组 中的 消费者 的变化注册监听</strong>。每个 消费者 都需要关注所属 消费者分组 中其他消费者服务器的变化情况，即对/consumers/[group_id]/ids节点注册子节点变化的Watcher监听，一旦发现消费者新增或减少，就触发消费者的负载均衡。</p><p><strong>对Broker服务器变化注册监听</strong>。消费者需要对/broker/ids/[0-N]中的节点进行监听，如果发现Broker服务器列表发生变化，那么就根据具体情况来决定是否需要进行消费者负载均衡。</p><p><strong>进行消费者负载均衡</strong>。为了让同一个Topic下不同分区的消息尽量均衡地被多个 消费者 消费而进行 消费者 与 消息 分区分配的过程，通常，对于一个消费者分组，如果组内的消费者服务器发生变更或Broker服务器发生变更，会发出消费者负载均衡。</p><p>以下是kafka在zookeep中的详细存储结构图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/3149801-0d2ed2bd8b7bec25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka如何保证不丢失消息</title>
      <link href="/2020/11/04/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF/"/>
      <url>/2020/11/04/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="生产者丢失消息的情况"><a href="#生产者丢失消息的情况" class="headerlink" title="生产者丢失消息的情况"></a>生产者丢失消息的情况</h3><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p><p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是  Kafka 生产者(Producer) 使用  <code>send</code> 方法发送消息实际上是异步的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p><blockquote><p><strong>详细代码见我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486269&idx=2&sn=ec00417ad641dd8c3d145d74cafa09ce&chksm=cea244f6f9d5cde0c8eb233fcc4cf82e11acd06446719a7af55230649863a3ddd95f78d111de&token=1633957262&lang=zh_CN#rd" target="_blank" rel="noopener">Kafka系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列?</a></strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SendResult&lt;String, Object&gt; sendResult &#x3D; kafkaTemplate.send(topic, o).get();</span><br><span class="line">if (sendResult.getRecordMetadata() !&#x3D; null) &#123;</span><br><span class="line">  logger.info(&quot;生产者成功发送消息到&quot; + sendResult.getProducerRecord().topic() + &quot;-&gt; &quot; + sendRe</span><br><span class="line">              sult.getProducerRecord().value().toString());</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future &#x3D; kafkaTemplate.send(topic, o);</span><br><span class="line">        future.addCallback(result -&gt; logger.info(&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">                ex -&gt; logger.error(&quot;生产者发送消失败，原因：&#123;&#125;&quot;, ex.getMessage()));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p><p><strong>另外这里推荐为 Producer 的<code>retries</code>（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你3次一下子就重试完了</strong></p><h3 id="消费者丢失消息的情况"><a href="#消费者丢失消息的情况" class="headerlink" title="消费者丢失消息的情况"></a>消费者丢失消息的情况</h3><p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170e29d648e63e5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="kafka offset"></p><p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p><p><strong>解决办法也比较粗暴，我们手动关闭闭自动提交 offset，每次在真正消费完消息之后之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p><h3 id="Kafka-弄丢了消息"><a href="#Kafka-弄丢了消息" class="headerlink" title="Kafka 弄丢了消息"></a>Kafka 弄丢了消息</h3><p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p><p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p><h4 id="设置-acks-all"><a href="#设置-acks-all" class="headerlink" title="设置 acks = all"></a>设置 acks = all</h4><p>解决办法就是我们设置  <strong>acks = all</strong>。acks 是 Kafka 生产者(Producer)  很重要的一个参数。</p><p>acks 的默认值即为1，代表我们的消息被leader副本接收之后就算被成功发送。当我们配置 <strong>acks = all</strong> 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。</p><h4 id="设置-replication-factor-gt-3"><a href="#设置-replication-factor-gt-3" class="headerlink" title="设置 replication.factor &gt;= 3"></a>设置 replication.factor &gt;= 3</h4><p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;= 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p><h4 id="设置-min-insync-replicas-gt-1"><a href="#设置-min-insync-replicas-gt-1" class="headerlink" title="设置 min.insync.replicas &gt; 1"></a>设置 min.insync.replicas &gt; 1</h4><p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p><p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下加入两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor = min.insync.replicas + 1</strong>。</p><h4 id="设置-unclean-leader-election-enable-false"><a href="#设置-unclean-leader-election-enable-false" class="headerlink" title="设置 unclean.leader.election.enable = false"></a>设置 unclean.leader.election.enable = false</h4><blockquote><p><strong>Kafka 0.11.0.0版本开始 unclean.leader.election.enable 参数的默认值由原来的true 改为false</strong></p></blockquote><p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable = false</strong>  的话，当 leader 副本发生故障时就不会从  follower 副本中和 leader 同步程度达不到要求的副本中选择出  leader ，这样降低了消息丢失的可能性。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="Ack-有哪几种-生产中怎样选择"><a href="#Ack-有哪几种-生产中怎样选择" class="headerlink" title="Ack 有哪几种, 生产中怎样选择?"></a>Ack 有哪几种, 生产中怎样选择?</h4><p>ack=0/1/-1的不同情况：</p><ul><li><p>Ack = 0</p><p>producer不等待broker的ack，broker一接收到还没有写入磁盘就已经返回，当broker故障时有可能丢失数据；</p></li><li><p>Ack = 1</p><p>producer等待broker的ack，partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将会丢失数据；</p></li><li><p>Ack = -1</p><p>producer等待broker的ack，partition的leader和follower全部落盘成功后才返回ack，数据一般不会丢失，延迟时间长但是可靠性高。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka剖析</title>
      <link href="/2020/11/04/kafka%E5%89%96%E6%9E%90/"/>
      <url>/2020/11/04/kafka%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="kafka的架构"><a href="#kafka的架构" class="headerlink" title="kafka的架构"></a>kafka的架构</h3><p><img src="https://user-gold-cdn.xitu.io/2020/1/17/16fb2cd4f1223ab9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>Producer：</strong> 消息生产者，向 Kafka Broker 发消息的客户端。</p><p><strong>Consumer：</strong> 消息消费者，从 Kafka Broker 取消息的客户端。</p><p><strong>Consumer Group：</strong> 消费者组（CG），消费者组内每个消费者负责消费不同分区的数据，提高消费能力。一个分区只能由组内一个消费者消费，消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</p><p><strong>Broker：</strong> 一台 Kafka 机器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。</p><p><strong>Topic：</strong> 可以理解为一个队列，topic 将消息分类，生产者和消费者面向的是同一个 topic。</p><p><strong>Partition：</strong> 为了实现扩展性，提高并发能力，一个非常大的 topic 可以分布到多个 broker （即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个 有序的队列。</p><p><strong>Replica：</strong> 副本，为实现备份的功能，保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 Kafka 仍然能够继续工作，Kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。</p><p><strong>Leader：</strong> 每个分区多个副本的“主”副本，生产者发送数据的对象，以及消费者消费数据的对象，都是 leader。</p><p><strong>Follower：</strong> 每个分区多个副本的“从”副本，实时从 leader 中同步数据，保持和 leader 数据的同步。leader 发生故障时，某个 follower 还会成为新的 leader。</p><p><strong>offset：</strong> 消费者消费的位置信息，监控数据消费到什么位置，当消费者挂掉再重新恢复的时候，可以从消费位置继续消费。</p><p><strong>Zookeeper：</strong> Kafka 集群能够正常工作，需要依赖于 zookeeper，zookeeper 帮助 Kafka 存储和管理集群信息。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Kafka集群将 Record 流存储在称为 topic 的类别中，每个记录由一个键、一个值和一个时间戳组成。<strong>Kafka 是一个分布式流平台</strong>，这到底是什么意思？</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/17/16fb2cd4f14b369d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Kafka 工作流程"></p><p>Kafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，面向的都是同一个 topic。<br> topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文件，该 log 文件中存储的就是 Producer 生产的数据。Producer 生产的数据会不断追加到该 log 文件末端，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自己消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。</p><p>作者：臧小晶<br>链接：<a href="https://juejin.im/post/6844904050064883725" target="_blank" rel="noopener">https://juejin.im/post/6844904050064883725</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p><img src="https://user-gold-cdn.xitu.io/2020/1/17/16fb2cd4f11f1b55?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Kafka文件存储机制"></p><p>由于生产者生产的消息会不断追加到 log 文件末尾，为防止 log 文件过大导致数据定位效率低下，Kafka 采取了<strong>分片</strong>和<strong>索引</strong>机制，将每个 partition 分为多个 segment，每个 segment 对应两个文件：“.index” 索引文件和 “.log” 数据文件。</p><h3 id="分区原因"><a href="#分区原因" class="headerlink" title="分区原因"></a>分区原因</h3><p>方便在集群中扩展，每个 partition 可以通过调整以适应它所在的机器，而一个 topic 又可以有多个 partition 组成，因此可以以 partition 为单位读写了。</p><h3 id="数据可靠性保证"><a href="#数据可靠性保证" class="headerlink" title="数据可靠性保证"></a>数据可靠性保证</h3><p>为保证 producer 发送的数据，能可靠地发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack（acknowledge 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/20/16fc0ef625f8c1c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h4 id="副本数据同步策略"><a href="#副本数据同步策略" class="headerlink" title="副本数据同步策略"></a>副本数据同步策略</h4><p><strong>（1）何时发送 ack？</strong><br> 确保有 follower 与 leader 同步完成，leader 再发送 ack，这样才能保证 leader 挂掉之后，能在 follower 中选举出新的 leader 而不丢数据。<br> <strong>（2）多少个 follower 同步完成后发送 ack？</strong><br> 全部 follower 同步完成，再发送 ack。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/20/16fc0ef626139ae5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="同步策略方案比较"></p><h4 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h4><p>采用第二种方案，所有 follower 完成同步，producer 才能继续发送数据，设想有一个 follower 因为某种原因出现故障，那 leader 就要一直等到它完成同步。这个问题怎么解决？<br> leader维护了一个动态的 in-sync replica set（ISR）：和 leader 保持同步的 follower 集合。当 ISR 集合中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower 长时间未向 leader 同步数据，则该 follower 将被踢出 ISR 集合，该时间阈值由 replica.lag.time.max.ms 参数设定。leader 发生故障后，就会从 ISR 中选举出新的 leader。</p><h4 id="ack-应答机制"><a href="#ack-应答机制" class="headerlink" title="ack 应答机制"></a>ack 应答机制</h4><p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等 ISR 中的 follower 全部接受成功。<br> 所以 Kafka 为用户提供了三种可靠性级别，用户根据可靠性和延迟的要求进行权衡，选择以下的配置。<br> <strong>（1）ack 参数配置：</strong></p><ul><li>0：producer 不等待 broker 的 ack，这提供了最低延迟，broker 一收到数据还没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据。</li><li>1：producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据。</li><li>-1（all）：producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才返回 ack。但是在 broker 发送 ack 时，leader 发生故障，则会造成数据重复。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/1/20/16fc0ef62659d31e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="acks=-1 造成数据重复分析"></p><h4 id="故障处理细节"><a href="#故障处理细节" class="headerlink" title="故障处理细节"></a>故障处理细节</h4><p><img src="https://user-gold-cdn.xitu.io/2020/1/20/16fc0ef626ae3ed5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Log 文件中的 HW 和 LEO"></p><p><strong>LEO：每个副本最大的 offset。<br> HW：消费者能见到的最大的 offset，ISR 队列中最小的 LEO。</strong><br><strong>（1）Follower 故障</strong><br> follower 发生故障后会被临时踢出 ISR 集合，待该 follower 恢复后，follower 会 读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步数据操作。等该 follower 的 LEO 大于等于该 partition 的 HW，即 follower 追上 leader 后，就可以重新加入 ISR 了。<br><strong>（2）Leader 故障</strong><br> leader 发生故障后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。<br><strong>注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</strong></p><p>作者：臧小晶<br>链接：<a href="https://juejin.im/post/6844904050064883725" target="_blank" rel="noopener">https://juejin.im/post/6844904050064883725</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="kafka的特点"><a href="#kafka的特点" class="headerlink" title="kafka的特点"></a>kafka的特点</h3><p>　　高吞吐量：Kafka 每秒可以生产约 25 万消息（50 MB），每秒处理 55 万消息（110 MB）<br>　　持久化数据存储：可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如 ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication 防止数据丢失。<br>　　分布式系统易于扩展：所有的 producer、broker 和 consumer 都会有多个，均为分布式的。无需停机即可扩展机器。<br>　　客户端状态维护：消息被处理的状态是在 consumer 端维护，而不是由 server 端维护。当失败时能自动平衡。</p><h3 id="Zookeeper在kafka中的作用"><a href="#Zookeeper在kafka中的作用" class="headerlink" title="Zookeeper在kafka中的作用?"></a>Zookeeper在kafka中的作用?</h3><h3 id="kafka基于硬盘为什么这么快"><a href="#kafka基于硬盘为什么这么快" class="headerlink" title="kafka基于硬盘为什么这么快"></a>kafka基于硬盘为什么这么快</h3><h4 id="顺序读写"><a href="#顺序读写" class="headerlink" title="顺序读写"></a>顺序读写</h4><p>众所周知Kafka是将消息记录持久化到本地磁盘中的，一般人会认为磁盘读写性能差，可能会对Kafka性能如何保证提出质疑。实际上不管是内存还是磁盘，快或慢关键在于寻址的方式，磁盘分为顺序读写与随机读写，内存也一样分为顺序读写与随机读写。基于磁盘的随机读写确实很慢，但磁盘的顺序读写性能却很高，一般而言要高出磁盘随机读写三个数量级，一些情况下磁盘顺序读写性能甚至要高于内存随机读写，这里给出著名学术期刊 ACM Queue 上的一张性能对比图：</p><p><img src="https://img-blog.csdnimg.cn/20190523181118864.png#pic_center" alt="img"><br>磁盘的顺序读写是磁盘使用模式中最有规律的，并且操作系统也对这种模式做了大量优化，Kafka就是使用了磁盘顺序读写来提升的性能。Kafka的message是不断追加到本地磁盘文件末尾的，而不是随机的写入，这使得Kafka写入吞吐量得到了显著提升。</p><h4 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h4><p>为了优化读写性能，Kafka利用了操作系统本身的Page Cache，就是利用操作系统自身的内存而不是JVM空间内存。这样做的好处有：</p><ul><li>避免Object消耗：如果是使用Java堆，Java对象的内存消耗比较大，通常是所存储数据的两倍甚至更多。</li><li>避免GC问题：随着JVM中数据不断增多，垃圾回收将会变得复杂与缓慢，使用系统缓存就不会存在GC问题。</li></ul><p>相比于使用JVM或in-memory cache等数据结构，利用操作系统的Page Cache更加简单可靠。首先，操作系统层面的缓存利用率会更高，因为存储的都是紧凑的字节结构而不是独立的对象。其次，操作系统本身也对于Page Cache做了大量优化，提供了write-behind、read-ahead以及flush等多种机制。再者，即使服务进程重启，系统缓存依然不会消失，避免了in-process cache重建缓存的过程。</p><p>通过操作系统的Page Cache，Kafka的读写操作基本上是基于内存的，读写速度得到了极大的提升。</p><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>这里主要讲的是Kafka利用linux操作系统的 “零拷贝（zero-copy）” 机制在消费端做的优化。首先来了解下数据从文件发送到socket网络连接中的常规传输路径：</p><ul><li>操作系统从磁盘读取数据到内核空间（kernel space）的Page Cache</li><li>应用程序读取Page Cache的数据到用户空间（user space）的缓冲区</li><li>应用程序将用户空间缓冲区的数据写回内核空间到socket缓冲区（socket buffer）</li><li>操作系统将数据从socket缓冲区复制到网络发送的NIC缓冲区</li></ul><p>这个过程包含4次copy操作和2次系统上下文切换，性能其实非常低效。linux操作系统 “零拷贝” 机制使用了sendfile方法，允许操作系统将数据从Page Cache 直接发送到网络，只需要最后一步的copy操作将数据复制到 NIC 缓冲区，这样避免重新复制数据。示意图如下：<br><img src="https://img-blog.csdnimg.cn/20190523181559385.png#pic_center" alt="img"></p><h4 id="分区分段"><a href="#分区分段" class="headerlink" title="分区分段"></a>分区分段</h4><p>Kafka的message是按topic分类存储的，topic中的数据又是按照一个一个的partition即分区存储到不同broker节点。每个partition对应了操作系统上的一个文件夹，partition实际上又是按照segment分段存储的。这也非常符合分布式系统分区分桶的设计思想。</p><p>通过这种分区分段的设计，Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。</p><h4 id="批量发送"><a href="#批量发送" class="headerlink" title="批量发送"></a>批量发送</h4><p>Kafka允许进行批量发送消息，先将消息缓存在内存中，然后一次请求批量发送出去<br>比如可以指定缓存的消息达到某个量的时候就发出去，或者缓存了固定的时间后就发送出去</p><h3 id="和其他消息中间件的对比"><a href="#和其他消息中间件的对比" class="headerlink" title="和其他消息中间件的对比"></a>和其他消息中间件的对比</h3><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis的主从复制</title>
      <link href="/2020/11/03/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2020/11/03/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="同步操作（PSYNC命令）"><a href="#同步操作（PSYNC命令）" class="headerlink" title="同步操作（PSYNC命令）"></a>同步操作（PSYNC命令）</h2><p><strong>PSYNC命令具有完整重同步（full resy nchronization）和部分重同步（partial resynchronization）两种模式：</strong></p><ul><li><strong>完整重同步：</strong>用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步 骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓 冲区里面的写命令来进行同步</li><li><strong>部分重同步：</strong>则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器 时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务 器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li></ul><h2 id="完整重同步"><a href="#完整重同步" class="headerlink" title="完整重同步"></a>完整重同步</h2><ul><li><p><strong>概念：</strong>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，<strong>将从服务器的数据库状态更新至主服务器当前所处的数据库状态</strong></p></li><li><p><strong>SYNC命令：</strong></p><p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：</p><ul><li>①从服务器向主服务器<strong>发送SYNC命令</strong></li><li>②收到SYNC命令的主服务器<strong>执行BGSAVE命令，在后台生成一个RDB文件</strong>，并使用一 个缓冲区记录从现在开始执行的所有写命令</li><li>③当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的<strong>RDB文件发送给从服务器</strong>，从服务器<strong>接收并载入</strong>这个RDB文件，将自己的数据库状态更新至主服务器 执行BGSAVE命令时的数据库状态</li><li>④主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写 命令，将自己的数据库状态更新至主服务器数据库当前所处的状态</li></ul></li><li><p>下图展示了SYNC命令执行期间，主从服务器的通信过程：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20191201105150863.png" alt="img"></p><blockquote><h3 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h3><ul><li>下表展示了一个主从服务器进行同步的例子</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201105237782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><h2 id="部分重同步的实现细节"><a href="#部分重同步的实现细节" class="headerlink" title="部分重同步的实现细节"></a>部分重同步的实现细节</h2><ul><li><strong>同步功能由以下三个部分构成：</strong><ul><li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区（replication backlog）</li><li>服务器的运行ID（run ID）</li></ul></li></ul><blockquote><h3 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h3><ul><li><p>执行复制的双方——主服务器和从服务器会</p><p><strong>分别维护一个复制偏移量：</strong></p><ul><li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li><li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li></ul></li><li><p>通过对比主从服务器的复制偏移量，</p><p><strong>程序可以很容易地知道主从服务器是否处于一致状态：</strong></p><ul><li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li><li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</li></ul></li><li><p>在下图所示的例子中，主从服务器的复制偏移量的值都为10086</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121350757.png" alt="img"></p><ul><li>如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121359413.png" alt="img"></p><h3 id="网络断开重连后的复制偏移量"><a href="#网络断开重连后的复制偏移量" class="headerlink" title="网络断开重连后的复制偏移量"></a>网络断开重连后的复制偏移量</h3><ul><li>考虑以下这个例子：假设如上面的图片所示，主从服务器当前的复制偏移量都为10086，但是就在主服务器要向从服务器传播长度为33字节的数据之前，从<strong>服务器A断线</strong>了，那么主服务 器传播的数据将只有从服务器B和从服务器C能收到，在这之后，主服务器、从服务器B和从 服务器C三个服务器的复制偏移量都将更新为10119，而断线的从服务器A的复制偏移量仍然停留在10086，这说明从服务器A与主服务器并不一致，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121522212.png" alt="img"></p><ul><li>假设从服务器A在断线之后就立即重新连接主服务器，并且成功，那么接下来，从服务器将向主服务器发送PSYNC命令，报告从服务器A当前的复制偏移量为10086，那么这时， <strong>主服务器应该对从服务器执行完整重同步还是部分重同步呢？</strong>如果执行部分重同步的话，主 服务器又如何补偿从服务器A在断线期间丢失的那部分数据呢？<strong>以上问题的答案都和复制积压缓冲区有关</strong></li></ul></blockquote><blockquote><h3 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h3><ul><li>复制积压缓冲区是由主服务器维护的一个<strong>固定长度（fixed-size）先进先出（FIFO）队列</strong>，默认大小为1MB</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121735717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会<strong>将写命令入队到复制积压缓冲区里面</strong>，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121909779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会<strong>为队列中的每个字节记录相应的复制偏移量</strong>，就像下表展示的那样</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121943503.png" alt="img"></p><ul><li><p>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令</p><p><strong>将自己的复制偏移量offset发送给主服务器</strong></p><p>，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操 作：</p><ul><li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）<strong>仍然存在于复制积压缓冲区里面</strong>，那么主服务器将对从服务器执行部分重同步操作</li><li>相反，如果offset偏移量之后的数据<strong>已经不存在于复制积压缓冲区</strong>，那么主服务器将对从服务器执行完整重同步操作</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/2019120112234757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong><em>\</em>演示案例：**</strong></p><ul><li>回到之前上面图片所展示的断线后重连接例子：</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121522212.png" alt="img"></p><ul><li>当从服务器A断线之后，它立即重新连接主服务器，并<strong>向主服务器发送PSYNC命令，报告自己的复制偏移量为10086</strong></li><li>主服务器收到从服务器发来的PSYNC命令以及偏移量10086之后，主服务器将<strong>检查偏移量10086之后的数据是否存在于复制积压缓冲区里面</strong>，结果发现<strong>这些数据仍然存在</strong>，于是主服务器向从服务器发送+CONTINUE回复，表示数据同步将以部分重同步模式来进行</li><li>接着主服务器会将复制积压缓冲区10086偏移量之后的<strong>所有数据（偏移量为10087至 10119）都发送给从服务器</strong></li><li>从服务器只要接收这33字节的缺失数据，就可以回到与主服务器一致的状态，如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201122209306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><blockquote><h3 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h3><ul><li><p>除了复制偏移量和复制积压缓冲区之外，</p><p><strong>实现部分重同步还需要用到服务器运行ID（run ID）：</strong></p><ul><li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID</li><li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3</li></ul></li><li><p>当从服务器对主服务器<strong>进行初次复制时</strong>，主服务器会<strong>将自己的运行ID传送给从服务器</strong>， 而从服务器则会将<strong>这个运行ID保存起来</strong></p></li><li><p>当从服务器断线并重新连上一个主服务器时，</p><p><strong>从服务器将向当前连接的主服务器发送之前保存的运行ID：</strong></p><ul><li>如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID相同</strong>，那么说明从服务器 断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操 作</li><li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID并不相同</strong>，那么 说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服 务器执行完整重同步操作</li></ul></li><li><p>举个例子，假设从服务器原本正在复制一个运行ID为 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3的主服务器，那么在网络断开，从服务器重新连 接上主服务器之后，从服务器将向主服务器发送这个运行ID，主服务器根据自己的运行ID是 否53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3来判断是执行部分重同步还是执行完整重同步</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis集群</title>
      <link href="/2020/11/03/redis%E9%9B%86%E7%BE%A4/"/>
      <url>/2020/11/03/redis%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><h4 id="一、检测主观下线状态"><a href="#一、检测主观下线状态" class="headerlink" title="一、检测主观下线状态"></a>一、检测主观下线状态</h4><ul><li>在默认情况下，Sentinel会<strong>以每秒一次的频率</strong>向所有与它创建了命令连接的实例（<strong>包括主服务器、从服务器、其他Sentinel在内</strong>）发送<strong>PING命令</strong>，并通过实例返回的PING命令回复来判断实例是否在线</li></ul><h4 id="二、检测客观下线状态"><a href="#二、检测客观下线状态" class="headerlink" title="二、检测客观下线状态"></a>二、检测客观下线状态</h4><ul><li>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线 了，它会<strong>向同样监视这一主服务器的其他Sentinel进行询问</strong>，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里<strong>接收到足够数量的已下线判断之后</strong>，Sentinel就会将从服务器判定为客观下线，并对主服务器<strong>执行故障转移操作</strong></li></ul><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的<strong>各个Sentinel会进行协商</strong>，选举出一个领头Sentinel，当某个sentinel被半数以上的sentinel设置成为领头sentinel，那么这个sentinel称为领头sentinel并由领头Sentinel<strong>对下线主服务器执行故障转移操作</strong></p><p>领头的sentinel负责故障转移<br>从从服务器列表中选择一个节点作为新节点<br>1.过滤掉：下线、5s内没有回应ping、与主服务器失联超过down-after-milliseconds的从服务器<br>2.选择从服务器中优先级最高的。若具有多个同样优先级的，则继续<br>3.选择复制偏移量最大的从节点。若具有多个复制偏移量相同的，则继续<br>4.选择runid最小的从服务器<br>sentinel会对1中选出的从服务器发送slaveof no one使其成为主服务器<br>sentinel向其余从服务器发送命令，让他们成为新主服务器的从服务器，并同步数据<br>sentinel会关注刚刚下线的主服务器，并让它成为从服务器，当它恢复的时候就去同步数据</p><h3 id="官方Redis-Cluster-方案-服务端路由查询"><a href="#官方Redis-Cluster-方案-服务端路由查询" class="headerlink" title="官方Redis Cluster 方案(服务端路由查询)"></a>官方Redis Cluster 方案(服务端路由查询)</h3><ul><li><strong>Redis集群采用P2P的Gossip（流言）协议，</strong> Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200806112902246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><strong>通信过程说明：</strong><ul><li>1）集群中的每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口上加10000</li><li>2）每个节点在固定周期内通过特定规则选择几个节点发送ping消息</li><li>3）接收到ping消息的节点用pong消息作为响应</li></ul></li><li>集群中每个节点通过一定规则挑选要通信的节点，每个节点可能知道全部节点，也可能仅知道部分节点，<strong>只要这些节点彼此可以正常通信，最终它们会达到一致的状态</strong>。当节点出故障、新节点加入、主从角色变化、槽信息 变更等事件发生时，通过不断的ping/pong消息通信，经过一段时间后<strong>所有的节点都会知道整个集群全部节点的最新状态，从而达到集群状态同步的目的</strong></li></ul><blockquote><h3 id="Gossip消息"><a href="#Gossip消息" class="headerlink" title="Gossip消息"></a>Gossip消息</h3><ul><li>Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息，了解这些消息<strong>有助于我们理解集群如何完成信息交换</strong></li><li><strong>常用的Gossip消息可分为：</strong><ul><li><strong>meet消息：</strong>用于通知新节点加入。消息发送者通知接收者加入到当前 集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong消息交换</li><li><strong>ping消息：</strong>集群内交换最频繁的消息，集群内每个节点每秒向多个其 他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消 息发送封装了自身节点和部分其他节点的状态数据。</li><li><strong>pong消息：</strong>当接收到ping、meet消息时，作为响应消息回复给发送方确 认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内 广播自身的pong消息来通知整个集群对自身状态进行更新</li><li><strong>fail消息：</strong>当节点判定集群内另一个节点下线时，会向集群内广播一个 fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。具体细节将在后面的“故障转移”文章中说明</li></ul></li><li><strong>它们的通信模式如下图所示：</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20200531152212286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><h4 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h4><ul><li><strong><em>\</em>集群伸缩详情请参阅：**</strong><a href="https://blog.csdn.net/qq_41453285/article/details/106460256" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/106460256</a></li></ul><blockquote><h3 id="伸缩原理"><a href="#伸缩原理" class="headerlink" title="伸缩原理"></a>伸缩原理</h3><ul><li><strong>Redis集群提供了灵活的节点扩容和收缩方案。</strong>在不影响集群对外服务的情况下，可以为集群添加节点进行扩容也可以下线部分节点进行缩容，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200806112949871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><blockquote><h3 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h3><ul><li><strong>扩容是分布式存储最常见的需求，Redis集群扩容操作可分为如下步骤：</strong><ul><li>准备新节点</li><li>加入集群</li><li>迁移槽和数据</li></ul></li></ul></blockquote><blockquote><h3 id="集群收缩"><a href="#集群收缩" class="headerlink" title="集群收缩"></a>集群收缩</h3><ul><li>收缩集群<strong>意味着缩减规模，</strong>需要从现有集群中<strong><em>\</em>安全下线部分节点**</strong>。安全下线节点流程如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/2020053118555180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><strong>流程说明：</strong><ul><li>1）首先需要确定下线节点是否有负责的槽，如果是，需要把槽迁移到 其他节点，保证节点下线后整个集群槽节点映射的完整性</li><li>2）当下线节点不再负责槽或者本身是从节点时，就可以通知集群内其 他节点忘记下线节点，当所有的节点忘记该节点后可以正常关闭</li></ul></li></ul></blockquote><h4 id="请求重定向-MOVED-、ASK重定向"><a href="#请求重定向-MOVED-、ASK重定向" class="headerlink" title="请求重定向(MOVED)、ASK重定向"></a>请求重定向(MOVED)、ASK重定向</h4><ul><li><strong>关于这两个知识点请参阅：</strong><a href="https://blog.csdn.net/qq_41453285/article/details/106463895" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/106463895</a></li></ul><blockquote><h3 id="请求重定向-MOVED"><a href="#请求重定向-MOVED" class="headerlink" title="请求重定向(MOVED)"></a>请求重定向(MOVED)</h3><ul><li>在集群模式下，Redis接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；否则<strong><em>\</em>回复MOVED重定向错误，通知客户端请求正确的节点**</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20200531231926655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><strong>演示案例如下：</strong><ul><li>client在127.0.0.1:6379节点上调用set命令创建”key:test:2”键，发现该键位于9252槽上，于是给client回送一个moved错误，告诉client端9252槽归属于127.0.0.1:6380管理</li><li>于是client重新连接127.0.0.1:6380节点，然后再次调用命令</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200531232320823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><blockquote><h3 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h3><ul><li>Redis集群支持<strong>在线迁移槽（slot）和数据来完成水平伸缩</strong>，当slot对应的数据从源节点到目标节点迁移过程中，客户端需要做到智能识别，保证键命令可正常执行。例如当一个slot数据从源节点迁移到目标节点时，期间可能出现一部分数据在源节点，而另一部分在目标节点，如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/20200806113128921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><strong>当出现上述情况时，客户端键命令执行流程将发生变化，如下所示：</strong><ul><li>1）客户端根据本地slots缓存发送命令到源节点，如果存在键对象则直接执行并返回结果给客户端</li><li>2）如果键对象不存在，则可能存在于目标节点，这时源节点会回复ASK重定向异常。格式如下：(error) ASK {slot} {targetIP}:{targetPort}</li><li>3）客户端从ASK重定向异常提取出目标节点信息，发送asking命令到目标节点打开客户端连接标识，再执行键命令。如果存在则执行，不存在则返回不存在信息</li></ul></li><li><strong>ASK重定向整体流程如下图所示：</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20200806113146529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><ul><li><strong>ASK与MOVED虽然都是对客户端的重定向控制，但是有着本质区别：</strong><ul><li>ASK重定向说明集群正在进行slot数据迁移，<strong>客户端无法知道什么时候迁移完成，因此只能是临时性的重定向</strong>，客户端不会更新slots缓存</li><li>但是MOVED重定向说明键<strong>对应的槽已经明确指定到新的节点</strong>，因此需要更新slots缓存</li></ul></li></ul><h3 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h3><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑<strong>读高并发</strong>的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的<strong>读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20200115180329317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="redis-master-slave"></p><p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p><p><strong>redis replication 的核心机制</strong></p><ul><li>redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会 block master node 的正常工作；</li><li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li></ul><p>注意，如果采用了主从架构，那么建议必须<strong>开启</strong> master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p><p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong>，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p><p><strong>redis 主从复制的核心原理</strong></p><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，</p><p>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，</p><p>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p><p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><p><img src="https://img-blog.csdnimg.cn/20200115180337645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="redis-master-slave-replication"></p><p><strong>过程原理</strong></p><ol><li>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</li><li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来</li><li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis</li><li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</li><li>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li></ol><p><strong>缺点</strong></p><p>所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决</p><h3 id="基于客户端分配"><a href="#基于客户端分配" class="headerlink" title="基于客户端分配"></a>基于客户端分配</h3><p><img src="https://img-blog.csdnimg.cn/20200115173640248.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>简介</strong></p><p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool</p><p><strong>优点</strong></p><p>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</p><p><strong>缺点</strong></p><ul><li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li><li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</li></ul><h3 id="基于代理服务器分片"><a href="#基于代理服务器分片" class="headerlink" title="基于代理服务器分片"></a>基于代理服务器分片</h3><p><img src="https://img-blog.csdnimg.cn/20200115173630730.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>简介</strong></p><p>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端</p><p><strong>特征</strong></p><ul><li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li><li>Proxy 的逻辑和存储的逻辑是隔离的</li><li>代理层多了一次转发，性能有所损耗</li></ul><p><strong>业界开源方案</strong></p><ul><li>Twtter开源的Twemproxy</li><li>豌豆荚开源的Codis</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双写问题和延时双删</title>
      <link href="/2020/11/02/%E5%8F%8C%E5%86%99%E9%97%AE%E9%A2%98%E5%92%8C%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0/"/>
      <url>/2020/11/02/%E5%8F%8C%E5%86%99%E9%97%AE%E9%A2%98%E5%92%8C%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>我们讨论<strong>两种</strong>更新策略：</p><ul><li>1.先删除缓存，再更新数据库</li><li>2.先更新数据库，再删除缓存</li></ul><h2 id="先删缓存，再更新数据库"><a href="#先删缓存，再更新数据库" class="headerlink" title="先删缓存，再更新数据库"></a>先删缓存，再更新数据库</h2><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p><ul><li><p>（1）请求A进行写操作，删除缓存</p></li><li><p>（2）请求B查询发现缓存不存在</p></li><li><p>（3）请求B去数据库查询得到旧值</p></li><li><p>（4）请求B将旧值写入缓存</p></li><li><p>（5）请求A将新值写入数据库 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p><p>那么，如何解决呢？采用延时双删策略 伪代码如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">        redis.delKey(key);</span><br><span class="line">        db.updateData(data);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        redis.delKey(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>转化为中文描述就是</p><p>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存 这么做，可以将1秒内所造成的缓存脏数据，再次删除。</p><p><strong>第二次删除,如果删除失败怎么办？</strong></p><p>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：</p><ul><li>（1）请求A进行写操作，删除缓存</li><li>（2）请求B查询发现缓存不存在</li><li>（3）请求B去数据库查询得到旧值</li><li>（4）请求B将旧值写入缓存</li><li>（5）请求A将新值写入数据库</li><li>（6）请求A试图去删除请求B写入对缓存值，结果失败了。 ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。 <strong>如何解决呢？</strong> 具体解决方案，且看博主对第(3)种更新策略的解析。</li></ul><h3 id="先更新DB再删除缓存"><a href="#先更新DB再删除缓存" class="headerlink" title="先更新DB再删除缓存"></a>先更新DB再删除缓存</h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href="https://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">《Cache-Aside pattern》</a>。其中就指出</p><ol><li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li><li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li></ol><p><strong>这种情况不存在并发问题么？</strong></p><p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p><p>（1）缓存刚好失效</p><p>（2）请求A查询数据库，得一个旧值</p><p>（3）请求B将新值写入数据库</p><p>（4）请求B删除缓存</p><p>（5）请求A将查到的旧值写入缓存 ok，如果发生上述情况，确实是会发生脏数据。</p><p><strong>然而，发生这种情况的概率又有多少呢？</strong></p><p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。</p><p>可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。 假设，有人非要抬杠，有强迫症，一定要解决怎么办？</p><ol><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事务的实现原理</title>
      <link href="/2020/11/02/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2020/11/02/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>相信大家都用过事务以及了解他的特点，如原子性(Atomicity),一致性(Consistency),隔离型(Isolation)以及持久性(Durability)等。今天想跟大家一起研究下事务内部到底是怎么实现的，在讲解前我想先抛出个问题：<br><strong>事务想要做到什么效果？</strong></p><p>按我理解，无非是要做到<strong>可靠性</strong>以及<strong>并发处理</strong></p><p>可靠性：数据库要保证当insert或update操作时抛异常或者数据库crash的时候需要保障数据的操作前后的一致，想要做到这个，我需要知道我修改之前和修改之后的状态，所以就有了undo log和redo log。</p><p>并发处理：也就是说当多个并发请求过来，并且其中有一个请求是对数据修改操作的时候会有影响，为了避免读到脏数据，所以需要对事务之间的读写进行隔离，至于隔离到啥程度得看业务系统的场景了，实现这个就得用MySQL 的隔离级别。</p><p>下面我首先讲实现事务功能的三个技术，分别是日志文件(redo log 和 undo log)，锁技术以及MVCC，然后再讲事务的实现原理，包括原子性是怎么实现的，隔离型是怎么实现的等等。最后在做一个总结，希望大家能够耐心看完</p><ul><li>redo log与undo log介绍</li><li>mysql锁技术以及MVCC基础</li><li>事务的实现原理</li><li>总结</li></ul><hr><h3 id="二、-redo-log-与-undo-log介绍"><a href="#二、-redo-log-与-undo-log介绍" class="headerlink" title="二、 redo log 与 undo log介绍"></a>二、 redo log 与 undo log介绍</h3><h4 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1. redo log"></a>1. redo log</h4><p><strong>什么是redo log ?</strong></p><p>redo log叫做<strong>重做</strong>日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当<strong>事务提交之后</strong>会把所有修改信息都会存到该日志中。假设有个表叫做tb1(id,username) 现在要插入数据（3，ceshi）</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2ff3e4c3b8b46?w=2368&h=788&f=png&s=226339" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select balance from bank where name&#x3D;&quot;zhangsan&quot;;</span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 balance&#x3D;600</span><br><span class="line">update bank set balance &#x3D; balance - 400; </span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 amount&#x3D;400</span><br><span class="line">update finance set amount &#x3D; amount + 400;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><hr><p>为了提高性能，和数据页类似，redo log 也包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。redo log是物理日志，记录的是数据库中物理页的情况 。</p><p>当数据发生修改时，InnoDB不仅会修改Buffer Pool中的数据，也会在redo log buffer记录这次操作；当事务提交时，会对redo log buffer进行刷盘，记录到redo log file中。如果MySQL宕机，重启时可以读取redo log file中的数据，对数据库进行恢复。这样就不需要每次提交事务都实时进行刷脏了</p><h3 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h3><p><img src="https://img-blog.csdnimg.cn/20201030172624806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTQ2Nzk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>注意点：</p><ul><li>先修改Buffer Pool，后写 redo log buffer。</li><li>redo日志比数据页先写回磁盘：事务提交的时候，会把redo log buffer写入redo log file，写入成功才算提交成功（也有其他场景触发写入，这里就不展开了），而Buffer Pool的数据由后台线程在后续某个时刻写入磁盘。</li><li>刷脏的时候一定会保证对应的redo log已经落盘了，也即是所谓的WAL（预写式日志），否则会有数据丢失的可能性。</li></ul><h4 id="2-undo-log"><a href="#2-undo-log" class="headerlink" title="2.undo log"></a>2.undo log</h4><p><strong>什么是 undo log ？</strong></p><p>undo log 叫做回滚日志，用于记录数据<strong>被修改前</strong>的信息。他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p><p>还用上面那两张表</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe552145e2c1?w=4652&h=1848&f=png&s=867671" alt="img"></p><p>每次写入数据或者修改数据之前都会把修改前的信息记录到 undo log。</p><p><strong>undo log 有什么作用？</strong></p><p>undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。</p><p>总结：<br>undo log是用来回滚数据的用于保障 未提交事务的原子性</p><hr><h3 id="三、mysql锁技术以及MVCC基础"><a href="#三、mysql锁技术以及MVCC基础" class="headerlink" title="三、mysql锁技术以及MVCC基础"></a>三、mysql锁技术以及MVCC基础</h3><h4 id="1-mysql锁技术"><a href="#1-mysql锁技术" class="headerlink" title="1. mysql锁技术"></a>1. mysql锁技术</h4><p>当有多个请求来读取表中的数据时可以不采取任何操作，但是多个请求里有读请求，又有修改请求时必须有一种措施来进行并发控制。不然很有可能会造成不一致。<br><strong>读写锁</strong><br>解决上述问题很简单，只需用两种锁的组合来对读写请求进行控制即可，这两种锁被称为：</p><p>共享锁(shared lock),又叫做”读锁”<br>读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。</p><p>排他锁(exclusive lock),又叫做”写锁”<br>写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a27696def80b5f?w=416&h=183&f=png&s=16219" alt="img"></p><p>总结：<br>通过读写锁，可以做到读读可以并行，但是不能做到写读，写写并行<br>事务的隔离性就是根据读写锁来实现的！！！这个后面再说。</p><h4 id="2-MVCC基础"><a href="#2-MVCC基础" class="headerlink" title="2. MVCC基础"></a>2. MVCC基础</h4><p>MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。</p><blockquote><p>InnoDB的 MVCC ，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，<br>一个保存了行的创建时间，一个保存了行的过期时间，<br>当然存储的并不是实际的时间值，而是系统版本号。</p></blockquote><p>以上片段摘自《高性能Mysql》这本书对MVCC的定义。他的主要实现思想是通过<strong>数据多版本</strong>来做到<strong>读写分离</strong>。从而实现不加锁读进而做到读写并行。</p><p><strong>MVCC在mysql中的实现依赖的是undo log与read view</strong></p><ul><li>undo log :undo log 中记录某行数据的多个版本的数据。</li><li>read view :用来判断当前版本数据的可见性</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f5e3c3950ca1?w=3612&h=1512&f=png&s=816439" alt="img"></p><hr><h3 id="四、事务的实现"><a href="#四、事务的实现" class="headerlink" title="四、事务的实现"></a>四、事务的实现</h3><p>前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。</p><ul><li>事务的原子性是通过 undo log 来实现的</li><li>事务的持久性性是通过 redo log 来实现的</li><li>事务的隔离性是通过 (读写锁+MVCC)来实现的</li><li>而事务的终极大 boss <strong>一致性</strong>是通过原子性，持久性，隔离性来实现的！！！</li></ul><p><strong>原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！</strong></p><p>总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。</p><h4 id="1-原子性的实现"><a href="#1-原子性的实现" class="headerlink" title="1.原子性的实现"></a>1.原子性的实现</h4><p>什么是原子性：</p><p>一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。</p><p>上面这段话取自《高性能MySQL》这本书对原子性的定义，原子性可以概括为就是要实现要么全部失败，要么全部成功。</p><p>以上概念相信大家伙儿都了解，那么数据库是怎么实现的呢？ 就是通过<strong>回滚</strong>操作。<br>所谓回滚操作就是当发生错误异常或者显式的执行rollback语句时需要把数据还原到原先的模样，所以这时候就需要用到undo log来进行回滚，接下来看一下undo log在实现事务原子性时怎么发挥作用的</p><h5 id="1-1-undo-log-的生成"><a href="#1-1-undo-log-的生成" class="headerlink" title="1.1 undo log 的生成"></a>1.1 undo log 的生成</h5><p>假设有两个表 bank和finance，表中原始数据如图所示，当进行插入，删除以及更新操作时生成的undo log如下面图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe331bab111c?w=4652&h=1848&f=png&s=867671" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe2457ff3820?w=1904&h=744&f=png&s=319469" alt="img"></p><p>从上图可以了解到数据的变更都伴随着回滚日志的产生：<br>(1) 产生了被修改前数据(zhangsan,1000) 的回滚日志</p><p>(2) 产生了被修改前数据(zhangsan,0) 的回滚日志</p><p>根据上面流程可以得出如下结论：<br><strong>1.每条数据变更(insert/update/delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上</strong><br><strong>2.所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</strong></p><p>思考：为什么先写日志后写数据库？ —稍后做解释</p><h5 id="1-2-根据undo-log-进行回滚"><a href="#1-2-根据undo-log-进行回滚" class="headerlink" title="1.2 根据undo log 进行回滚"></a>1.2 根据undo log 进行回滚</h5><p>为了做到同时成功或者失败，当系统发生错误或者执行rollback操作时需要根据undo log 进行回滚</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fece4894a8a8?w=3748&h=1100&f=png&s=475112" alt="img"></p><p>回滚操作就是要还原到原来的状态，undo log记录了数据被修改前的信息以及新增和被删除的数据信息，根据undo log生成回滚语句，比如：</p><p>(1) 如果在回滚日志里有新增数据记录，则生成删除该条的语句</p><p>(2) 如果在回滚日志里有删除数据记录，则生成生成该条的语句</p><p>(3) 如果在回滚日志里有修改数据记录，则生成修改到原先数据的语句</p><h4 id="2-持久性的实现"><a href="#2-持久性的实现" class="headerlink" title="2.持久性的实现"></a>2.持久性的实现</h4><p>事务一旦提交，其所作做的修改会永久保存到数据库中，此时即使系统崩溃修改的数据也不会丢失。</p><p>先了解一下MySQL的数据存储机制，MySQL的表数据是存放在磁盘上的，因此想要存取的时候都要经历磁盘IO,然而即使是使用SSD磁盘IO也是非常消耗性能的。<br>为此，为了提升性能InnoDB提供了缓冲池(Buffer Pool)，Buffer Pool中包含了磁盘数据页的映射，可以当做缓存来使用：<br><strong>读数据</strong>：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取在放入缓冲池；<br><strong>写数据</strong>：会首先写入缓冲池，缓冲池中的数据会定期同步到磁盘中；</p><p>上面这种缓冲池的措施虽然在性能方面带来了质的飞跃，但是它也带来了新的问题，当MySQL系统宕机，断电的时候可能会丢数据！！！</p><p>因为我们的数据已经提交了，但此时是在缓冲池里头，还没来得及在磁盘持久化，所以我们急需一种机制需要存一下已提交事务的数据，为恢复数据使用。</p><p>于是 redo log就派上用场了。下面看下redo log是什么时候产生的</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a26f9acf011739?w=994&h=373&f=png&s=120202" alt="img"></p><p>既然redo log也需要存储，也涉及磁盘IO为啥还用它？</p><p>（1）redo log 的存储是顺序存储，而缓存同步是随机操作。</p><p>（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。</p><hr><h4 id="3-隔离性实现"><a href="#3-隔离性实现" class="headerlink" title="3.隔离性实现"></a>3.隔离性实现</h4><p>隔离性是事务ACID特性里最复杂的一个。在SQL标准里定义了四种隔离级别，每一种级别都规定一个事务中的修改，哪些是事务之间可见的，哪些是不可见的。</p><p>级别越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。</p><p>Mysql 隔离级别有以下四种（级别由低到高）：</p><ul><li><strong>READ UNCOMMITED</strong> (未提交读)</li><li><strong>READ COMMITED</strong> (提交读)</li><li><strong>REPEATABLE READ</strong> (可重复读)</li><li><strong>SERIALIZABLE</strong> (可重复读)</li></ul><p>只要彻底理解了隔离级别以及他的实现原理就相当于理解了ACID里的隔离型。前面说过原子性，隔离性，持久性的目的都是为了要做到一致性，但隔离型跟其他两个有所区别，原子性和持久性是为了要实现数据的可性保障靠，比如要做到宕机后的恢复，以及错误后的回滚。</p><p>那么隔离性是要做到什么呢？ <strong>隔离性是要管理多个并发读写请求的访问顺序。</strong> 这种顺序包括<strong>串行</strong>或者是<strong>并行</strong><br>说明一点，写请求不仅仅是指insert操作，又包括update操作。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2c1c8b5285ee3?w=688&h=233&f=png&s=40492" alt="img"></p><p>总之，从隔离性的实现可以看出这是一场数据的可靠性与性能之间的权衡。</p><ul><li>可靠性性高的，并发性能低(比如 Serializable)</li><li>可靠性低的，并发性能高(比如 Read Uncommited)</li></ul><p><strong>READ UNCOMMITTED</strong></p><p>在READ UNCOMMITTED隔离级别下，事务中的修改即使还没提交，对其他事务是可见的。事务可以读取未提交的数据，造成脏读。</p><p>因为读不会加任何锁，所以写操作在读的过程中修改数据，所以会造成脏读。好处是可以提升并发处理性能，能做到<strong>读写并行</strong>。</p><p>换句话说，读的操作不能排斥写请求。<br><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2ed4dbd348a68?w=4284&h=1288&f=png&s=731191" alt="img"></p><p>优点：读写并行，性能高<br>缺点：造成脏读</p><p><strong>READ COMMITTED</strong></p><p>一个事务的修改在他提交之前的所有修改，对其他事务都是不可见的。其他事务能读到已提交的修改变化。在很多场景下这种逻辑是可以接受的。</p><p>InnoDB在 READ COMMITTED，使用排它锁,读取数据不加锁而是使用了MVCC机制。或者换句话说他采用了<strong>读写分离机制</strong>。<br>但是该级别会产生<strong>不可重读</strong>以及<strong>幻读</strong>问题。</p><blockquote><p>什么是不可重读？</p></blockquote><p>在一个事务内多次读取的结果不一样。</p><blockquote><p>为什么会产生不可重复读？</p></blockquote><p>这跟 READ COMMITTED 级别下的MVCC机制有关系，在该隔离级别下每次 select的时候新<strong>生成一个版本号</strong>，所以每次select的时候读的不是一个副本而是不同的副本。</p><p>在每次select之间有其他事务<strong>更新</strong>了我们读取的数据并提交了，那就出现了不可重复读<br><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f05d63f388d0?w=3612&h=1512&f=png&s=816439" alt="img"></p><p><strong>REPEATABLE READ</strong>(Mysql默认隔离级别)</p><p>在一个事务内的多次读取的结果是一样的。这种级别下可以避免，脏读，不可重复读等查询问题。mysql 有两种机制可以达到这种隔离级别的效果，分别是采用读写锁以及MVCC。</p><p><strong>采用读写锁实现</strong>：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2c351eb03fc24?w=1082&h=290&f=png&s=120400" alt="img"><br>为什么能可重复度？只要没释放读锁，在次读的时候还是可以读到第一次读的数据。</p><p>优点：实现起来简单</p><p>缺点：无法做到读写并行</p><p><strong>采用MVCC实现</strong>：<br><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f054474b394b?w=3584&h=1512&f=png&s=756027" alt="img"></p><p>为什么能可重复度？因为多次读取只生成一个版本，读到的自然是相同数据。</p><p>优点：读写并行</p><p>缺点：实现的复杂度高</p><p>但是在该隔离级别下仍会存在幻读的问题，关于幻读的解决我打算另开一篇来介绍。</p><p><strong>SERIALIZABLE</strong></p><p>该隔离级别理解起来最简单，实现也最单。在隔离级别下除了不会造成数据不一致问题，没其他优点。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f56d34ff739e?w=3528&h=1060&f=png&s=414467" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f69776d551b3?w=2608&h=776&f=png&s=445068" alt="img"></p><p>–摘自《高性能Mysql》</p><h4 id="4-一致性的实现"><a href="#4-一致性的实现" class="headerlink" title="4.一致性的实现"></a>4.一致性的实现</h4><blockquote><p>数据库总是从一个一致性的状态转移到另一个一致性的状态.</p></blockquote><p>下面举个例子:zhangsan 从银行卡转400到理财账户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select balance from bank where name&#x3D;&quot;zhangsan&quot;;</span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 balance&#x3D;600</span><br><span class="line">update bank set balance &#x3D; balance - 400; </span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 amount&#x3D;400</span><br><span class="line">update finance set amount &#x3D; amount + 400;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>1.假如执行完 <code>update bank set balance = balance - 400;</code>之发生异常了，银行卡的钱也不能平白无辜的减少，而是回滚到最初状态。</p><p>2.又或者事务提交之后，缓冲池还没同步到磁盘的时候宕机了，这也是不能接受的，应该在重启的时候恢复并持久化。</p><p>3.假如有并发事务请求的时候也应该做好事务之间的可见性问题，避免造成脏读，不可重复读，幻读等。在涉及并发的情况下往往在性能和一致性之间做平衡，做一定的取舍，所以隔离性也是对一致性的一种破坏。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文出发点是想讲一下Mysql的事务的实现原理。</p><p>实现事务采取了哪些技术以及思想？</p><ul><li>原子性：使用 undo log ，从而达到回滚</li><li>持久性：使用 redo log，从而达到故障后恢复</li><li>隔离性：使用锁以及MVCC,运用的优化思想有读写分离，读读并行，读写并行</li><li>一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>论坛项目过程</title>
      <link href="/2020/11/01/%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/11/01/%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><h4 id="用户表-user"><a href="#用户表-user" class="headerlink" title="用户表 user"></a>用户表 user</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>username</td><td>varchar</td><td>用户名，创建索引</td></tr><tr><td>password</td><td>varchar</td><td>用户密码</td></tr><tr><td>salt</td><td>varchar</td><td>加密盐值</td></tr><tr><td>email</td><td>varchar</td><td>用户邮箱，创建索引</td></tr><tr><td>type</td><td>int</td><td>用户类型：0 普通、1 管理员、2 版主</td></tr><tr><td>status</td><td>int</td><td>用户状态：0 未激活、1 已激活</td></tr><tr><td>activation_code</td><td>varchar</td><td>激活码</td></tr><tr><td>header_url</td><td>varchar</td><td>用户头像地址</td></tr><tr><td>create_time</td><td>timestamp</td><td>注册时间</td></tr></tbody></table><h4 id="评论表-comment"><a href="#评论表-comment" class="headerlink" title="评论表 comment"></a>评论表 comment</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>user_id</td><td>int</td><td>评论的用户 id，创建索引</td></tr><tr><td>entity_id</td><td>int</td><td>评论实体 id，创建索引</td></tr><tr><td>entity_type</td><td>int</td><td>评论实体类型：1 帖子评论、2 评论回复</td></tr><tr><td>target_id</td><td>int</td><td>评论目标 id</td></tr><tr><td>content</td><td>text</td><td>评论内容</td></tr><tr><td>status</td><td>int</td><td>评论状态：0 有效、1 无效</td></tr><tr><td>create_time</td><td>timestamp</td><td>评论发表时间</td></tr></tbody></table><h4 id="帖子表-discuss-post"><a href="#帖子表-discuss-post" class="headerlink" title="帖子表 discuss_post"></a>帖子表 discuss_post</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>user_id</td><td>int</td><td>发帖的用户 id，创建索引</td></tr><tr><td>title</td><td>varchar</td><td>帖子表标题</td></tr><tr><td>content</td><td>text</td><td>帖子内容</td></tr><tr><td>type</td><td>int</td><td>帖子类型：0 普通、1 置顶</td></tr><tr><td>comment_count</td><td>int</td><td>评论数量</td></tr><tr><td>status</td><td>int</td><td>帖子状态：0 普通、1 精华、2 拉黑</td></tr><tr><td>create_time</td><td>timestamp</td><td>评论发表时间</td></tr></tbody></table><h4 id="用户登录凭证表-login-ticket"><a href="#用户登录凭证表-login-ticket" class="headerlink" title="用户登录凭证表 login_ticket"></a>用户登录凭证表 login_ticket</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>user_id</td><td>int</td><td>登录用户 id</td></tr><tr><td>ticket</td><td>varchar</td><td>登录凭证，随机字符串</td></tr><tr><td>status</td><td>int</td><td>登录状态：0 有效、1 无效</td></tr><tr><td>expired</td><td>timestamp</td><td>过期时间</td></tr></tbody></table><h4 id="消息表-message"><a href="#消息表-message" class="headerlink" title="消息表 message"></a>消息表 message</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>from_id</td><td>int</td><td>发消息的 id，创建索引</td></tr><tr><td>to_id</td><td>int</td><td>收消息的 id，创建索引</td></tr><tr><td>conversation_id</td><td>varchar</td><td>会话 id，由通信双方 id 拼接，创建索引</td></tr><tr><td>content</td><td>text</td><td>消息内容</td></tr><tr><td>status</td><td>int</td><td>消息状态：0 未读、1 已读、2 删除</td></tr><tr><td>create_time</td><td>timestamp</td><td>消息发送时间</td></tr></tbody></table><hr><h2 id="开发社区首页"><a href="#开发社区首页" class="headerlink" title="开发社区首页"></a>开发社区首页</h2><h3 id="搭建基本环境"><a href="#搭建基本环境" class="headerlink" title="搭建基本环境"></a>搭建基本环境</h3><p>构建 SpringBoot 的 maven 项目，引入 mysql 和 mybatis 依赖。</p><hr><p>在 <code>application.properties</code> 配置文件中：</p><ul><li>关闭 thymeleaf 缓存</li><li>配置数据库，设置基本连接信息、最大线程数，最小空闲线程数，最大空闲时间等</li><li>mybatis，设置 mapper 文件的位置、实体类包名、使用主键等</li></ul><hr><p>创建 community 数据库和数据库表。</p><hr><p>用户相关操作：</p><ul><li>创建对应 user 表的 User 实体类</li><li>创建 UserMapper 接口，使用 <code>@Mapper</code> 注解</li><li>创建 user-mapper.xml，重复 sql 语句可以写在 <code>&lt;sql id = &quot;xxx&quot;&gt;</code> 标签，通过 <code>&lt;include refid=&quot;xxx&quot;/&gt;</code> 引用。</li></ul><hr><h3 id="开发社区首页（discuss-post-表）"><a href="#开发社区首页（discuss-post-表）" class="headerlink" title="开发社区首页（discuss_post 表）"></a>开发社区首页（discuss_post 表）</h3><p>功能拆分：开发社区首页，显示前 10 个帖子。开发分页组件，分页显示所有帖子。</p><p>用到的表是 discuss_post 数据库表，包括帖子 id、发帖人 id、标题、内容、类型、状态、发帖时间、评论数量（为了提高效率，避免关联查询，因此冗余存储）、分数（用于进行热度排名）。</p><h4 id="开发数据层"><a href="#开发数据层" class="headerlink" title="开发数据层"></a>开发数据层</h4><p>帖子相关操作：</p><ul><li><p>创建对应 discuss_post 表的 DisscussPost 实体类。</p></li><li><p>创建 DisscussPostMapper 接口，使用 <code>@Mapper</code> 注解。</p><ul><li>分页查询中用户 id 是可选参数，通过动态 SQL 选择，如果为 0 就不使用，在开发用户个人主页查询用户发帖记录时需要使用。</li><li>如果只有一个参数，并且在动态 SQL 的 <code>&lt;if&gt;</code> 里使用，必须使用 <code>@Param</code> 加别名。</li></ul></li><li><p>创建 <code>disscusspost-mapper.xml</code>。</p><ul><li><p><code>where status != 2</code> 拉黑的帖子不展现。</p></li><li><p><code>&lt;if test=&quot;userId!=0&quot;&gt;</code>  userID 为 0 时不使用，按照类型，发帖时间排序。</p></li></ul></li></ul><hr><h4 id="开发业务层"><a href="#开发业务层" class="headerlink" title="开发业务层"></a>开发业务层</h4><p>创建 DiscussPostService 类，可以分页查询帖子和帖子数量。</p><p>创建 UserService 类，实现根据 id 查询用户功能，因为显示帖子时不显示用户 id，而是显示用户名。</p><hr><h4 id="开发视图层"><a href="#开发视图层" class="headerlink" title="开发视图层"></a>开发视图层</h4><p>把静态资源 css、html、img、js 放到 static 目录下。</p><p>把模板 mail、site、index.html 放到 template 目录下。</p><p>创建 HomeController，<code>getIndexPage</code> 方法，用 map 集合把帖子和用户封装到一起。</p><p>修改 <code>index.html</code>，使用 <code>&lt;th:text=&quot;${map.xxx.xxx}&quot;</code> 动态替换。</p><p>【问题】使用帖子关联查询用户时，给查询用户的 <code>findUserById</code> 方法传入了帖子的 <code>getId</code> 方法，应该是 <code>getUserId</code> 方法。</p><hr><h4 id="开发分页组件"><a href="#开发分页组件" class="headerlink" title="开发分页组件"></a>开发分页组件</h4><p>创建 Page 实体类，封装分页信息，包括当前页码、显示限制、帖子总数、查询路径等。显示的起始页不能小于 1，最大页不能超过 total。</p><p>在 <code>index.html</code> 中，当 <code>page.rows &gt; 0</code> 时显示分页信息。</p><p>如果 <code>page.current</code>  等于 1 或 <code>page.total</code>，代表是首页或末页，此时不能点击上一页和下一页，用 <code>disabled</code> 属性实现。</p><hr><h2 id="开发注册登录模块"><a href="#开发注册登录模块" class="headerlink" title="开发注册登录模块"></a>开发注册登录模块</h2><hr><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>在新浪邮箱打开 SMTP 服务。</p><p>引入 <code>spring-boot-starter-mail</code> 依赖。</p><p>在配置文件配置主机、端口、发送邮箱、授权码等。</p><p>创建 MailClient 类，调用 JavaMailSender 发送邮件。</p><p>使用 thymeleaf 发送 HTML 邮件，调用 TemplateEngine 把信息封装到 HTML 模板。</p><p>【问题】发送邮件成功但没接收到，在垃圾箱中可找到。</p><hr><h3 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h3><p>把 register.html 地址关联到首页的注册 href 属性。</p><p>设置域名、创建 CommunityUtil 工具类，在工具类创建生产随机字符串和 MD5 加密方法。</p><p>创建 LoginController，创建 <code>getRegisterPage</code> 方法，跳转注册页面。</p><p>在 UserService 中创建 <code>register</code> 方法，判断注册信息合规后插入数据库，发送激活邮件。</p><p>在 LoginController 创建 <code>register</code> 方法，调用 UserService 的 <code>register</code> 方法。</p><p>创建接口 CommunityConstant，定义激活码的三种状态，成功、重复、失败，让 UserService 和 LoginController 实现该接口。</p><p>点击激活邮件的 url 【本地服务器的url】后，服务器通过 LoginController 的 <code>activation</code> 方法查询数据库用户，如果 url 中的激活码和设置的一样，就把用户 status 改为 1。</p><hr><h3 id="生成验证码"><a href="#生成验证码" class="headerlink" title="生成验证码"></a>生成验证码</h3><p>在 <code>pom.xml</code> 导入 kaptcha 的 jar 包。</p><p>创建配置类 KaptchaConfig，设置验证码的大小、范围、长度等。</p><p>在 LoginController 类新增 <code>getKaptcha</code> 方法生成验证码图片。</p><p>在 <code>login.html</code> 中，将刷新验证码的链接绑定 <code>refresh_kaptcha</code> 方法，通过 id 选择器获取 img 组件，重新访问  <code>getKaptcha</code> 方法生成验证码图片。</p><p>【问题】由于访问同一个生成验证码路径，需要在 url 参数加上一个随机数字，保证会重新请求获取新图片。</p><hr><h3 id="登录退出功能（login-ticket-表）"><a href="#登录退出功能（login-ticket-表）" class="headerlink" title="登录退出功能（login_ticket 表）"></a>登录退出功能（login_ticket 表）</h3><p>登录成功时，需要生成一个登录凭证发送给客户端。凭证可以在多个业务中连续地验证用户的登陆状态，凭证信息存储在 login_ticket 数据库表中，status 的 0 和 1 表示有效和无序，expire 表示过期时间。</p><p>创建对应 login_ticket 表的 LoginTicket 实体类，对应 login_ticket 数据库表。</p><p>创建 LoginTicketMapper 接口，通过 <code>@Insert</code>、<code>@Select</code>、<code>@Update</code> 注解来插入、查询、更新凭证。</p><p>在 UserServce </p><ul><li><p>创建 <code>login</code> 方法，验证账户合规后将凭证信息插入数据库，添加登录凭证到 map 中。</p></li><li><p>创建 <code>logout</code> 方法，将对应凭证设为无效。</p></li></ul><p>在 LoginController </p><ul><li><p>创建 <code>login</code> 方法，判断验证码正确后调用  UserServce 的 <code>login</code> 方法，如果 map 包含 ticket 代表登录成功，重定向跳转首页，否则添加错误信息并跳回登录页。</p></li><li><p>创建 <code>logout</code> 方法，判断验证码正确后调用  UserServce 的<code>logout</code> 方法，跳转至登录页。</p></li></ul><p>在 <code>login.html</code> 绑定登录链接，<code>index.html</code> 绑定退出登录链接。</p><p>【问题】登录成功后，创建了凭证，但忘记将凭证信息插入数据库。</p><hr><h3 id="显示登录信息"><a href="#显示登录信息" class="headerlink" title="显示登录信息"></a>显示登录信息</h3><p>创建 CookieUtil 工具类，通过 name 查询对应 cookie 的 value。</p><p>在 UserService 中新增 <code>findLoginTicket</code> 方法，根据 ticket 查询 LoginTicket。</p><p>创建 HostHolder 类用来模拟 session 的功能，利用 ThreadLocal 实现，存储用户信息。</p><p>创建 LoginTicketInterceptor 拦截器，实现 HandlerInterceptor 接口。</p><ul><li>在 <code>preHandle</code> 方法中通过 CookieUtil 的 <code>getValue</code> 方法查询是否有凭证 cookie，如果有则通过 UserService 的  <code>findloginTicket</code> 方法查询用户 ID，再通过用户 ID 查询用户。最后将用户放入 hostHolder 中。</li><li>在 <code>postHandle</code> 方法中通过 hostHolder 的 <code>get</code> 方法获取用户，并将其存入视图中。</li><li>在 <code>afterCompletion</code> 方法中清除 hostHolder 中存放的用户信息。</li></ul><p>创建 WebMvcConfig 配置类，实现 WebMvcConfigurer接口，配置 LoginTicketInterceptor，拦截除了静态资源之外的所有路径。</p><hr><h3 id="上传头像"><a href="#上传头像" class="headerlink" title="上传头像"></a>上传头像</h3><p>在 UserService 新增 <code>updateHeader</code> 方法，更改指定用户的头像。</p><p>创建 UserController</p><ul><li><p>新增 <code>getSettingPage</code> 方法访问账户设置 <code>setting.html</code> ，并在 <code>index.html</code> 的账号设置按钮关联该链接。</p></li><li><p>新增 <code>uploadHeader</code> 方法更新用户头像，如果上传出现错误将错误信息存在 Model 对象中。</p><p>如果没有错误，生成一个文件对象 dest，利用 MultipartFile 接口的 <code>transferTo</code> 方法将用户上传文件导入 dest，并从 hostHolder 中取出用户，更新用户的头像路径。</p></li><li><p>新增 <code>getHeader</code> 方法获取用户头像，利用文件输入流读取图片数据，利用 HttpServletResponse 的字节输出流再进行输出。</p></li></ul><p>调整 <code>setting.html</code> 的 form 表单， method=”post”，enctype=”multipart/form-data”，并设置提交路径。</p><hr><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>在 UserService 中新增 <code>changePassword</code> 方法，判断原密码是否正确，正确则修改密码并返回 1，否则返回 0。</p><p>在 UserController 中新增 <code>changePassword</code> 方法，根据 UserService 的  <code>changePassword</code> 方法的返回值判断原密码是否成功修改，封装为 JSON 数据并返回。</p><p>在 <code>setting.html</code> 中</p><ul><li>首先在前端判断两次输入的新密码是否一致，如果不一致不允许点击提交并显示错误信息。</li><li>利用 ajax 向 UserController 的  <code>changePassword</code> 方法发送 POST 请求，得到 JSON 数据并解析，如果状态码为 0 提示错误，如果状态码为 1 弹出修改成功提示。</li></ul><p>【问题】js 的虚拟路径问题，需要加上 <code>../</code>。</p><p>【问题】使用 ajax 请求时，表单按钮类型必须是 button，不能是 submit，否则 405 报错。</p><p>【问题】使用 ajax 请求时，Controller 中方法的返回值必须是 JSON 数据，并且需要加上 <code>@ResponseBody</code>。</p><p>【问题】使用 ajax 请求时，回调函数需要先对返回的 JSON 数据进行解析再使用。</p><hr><h3 id="检查登录状态"><a href="#检查登录状态" class="headerlink" title="检查登录状态"></a>检查登录状态</h3><p>利用拦截器，实现只处理带有自定义注解的方法，防止用户在未登录情况下通过 url 访问没有权限的页面。</p><p>创建 <code>@LoginRequired</code> 自定义注解，作用范围在方法上，有效期为运行时。</p><p>在 UserController 中需要在登录状态下调用的方法，访问设置页面、修改密码、上传头像等加上自定义注解。</p><p>创建 LoginRequiredInterceptor 拦截器，在 <code>preHandle</code> 方法中判断方法是否加了 <code>@LoginRequired</code> 注解，如果加了注解并且此时从 hostHolder 中获取不到用户则拒绝访问。</p><p>在 WebMvcConfig 配置类配置 LoginRequiredInterceptor，拦截除了静态资源之外的所有路径。</p><hr><h2 id="开发核心功能"><a href="#开发核心功能" class="headerlink" title="开发核心功能"></a>开发核心功能</h2><h3 id="敏感词过滤"><a href="#敏感词过滤" class="headerlink" title="敏感词过滤"></a>敏感词过滤</h3><p>利用字典树数据结构解决。</p><p>创建 SensitiveFilter 类</p><ul><li>创建静态内部类 TrieNode ，通过 boolean 类型的结束符判断是否匹配到关键字尾部。</li><li>利用 <code>@PostConstruct</code> 注解，在构造方法执行后初始化字典树。</li><li>添加 <code>filter</code> 方法，利用双指针进行匹配，过滤敏感词。</li></ul><p>【问题】判断子节点空时，直接添加了一个 new 的子节点，没有将对象赋值给子节点变量。</p><hr><h3 id="发布帖子"><a href="#发布帖子" class="headerlink" title="发布帖子"></a>发布帖子</h3><p>引入 fastjson 依赖，在 CommunityUtil 中新增 <code>getJSONString</code> 方法封装 JSON 信息。</p><p>在 DisscussPostMapper 接口新增 <code>insertDiscussPost</code> 方法，并在 <code>disscusspost-mapper.xml</code> 配置 insert 语句。</p><p>在 DiscussPostService 新增 <code>addDiscussPost</code> 方法调用 DisscussPostMapper 的 <code>insertDiscussPost</code> 方法，其中需要进行对标题内容和发帖内容进行 HTML 转义以及过滤敏感词。</p><p>创建 DiscussPostController 类，新增 <code>addDiscussPost</code> 方法，调用 DiscussPostService 的 <code>addDiscussPost</code> 方法发帖。</p><p>在 <code>index.html</code> 中为发帖按钮绑定函数，利用 Ajax 向 DiscussPostController 的 <code>addDiscussPost</code> 方法发送 POST 请求。</p><hr><h3 id="显示帖子内容"><a href="#显示帖子内容" class="headerlink" title="显示帖子内容"></a>显示帖子内容</h3><p>在 DisscussPostMapper 接口新增 <code>selectDiscussPostById</code> 方法，在 <code>disscusspost-mapper.xml</code> 配置 select 语句。</p><p>在 DiscussPostService 新增 <code>findDiscussPostById</code> 方法调用 DisscussPostMapper 的 <code>selectDiscussPostById</code> 方法。</p><p>在 DiscussPostController 新增 <code>getDiscussPost</code> 方法，调用 DiscussPostService 的 <code>findDiscussPostById</code> 方法查询帖子内容，将 DiscussPost 对象和 User 对象（通过 userId 查询，不在 DAO 层关联查询）数据存放到 Model 对象，返回模板 <code>discuss-detail</code>。</p><p>在 <code>discuss-detail.html</code> 取出 Model 对象存放的数据绑定到对应组件显示。</p><hr><h3 id="显示评论（comment-表）"><a href="#显示评论（comment-表）" class="headerlink" title="显示评论（comment 表）"></a>显示评论（comment 表）</h3><p>创建 comment 表对应的实体类 Comment。</p><p>创建 CommentMapper 接口</p><ul><li>新增 <code>selectCommentsByEntity</code> 方法，根据实体查询一页的评论数据。</li><li>新增 <code>selectCountByEntity</code> 方法，根据实体查询评论的数量。</li><li>在 <code>comment-mapper.xml</code> 配置 select 语句。</li></ul><p>创建 CommentService 类</p><ul><li>新增 <code>findCommentByEntity</code> 方法，调用 CommentMapper 的 <code>selectCommentByEntity</code> 方法。</li><li>新增 <code>findCommentCount</code> 方法，调用 CommentMapper 的 <code>selectCountByEntity</code> 方法。</li></ul><p>在 DiscussPostController 的 <code>getDiscussPost</code> 方法中增加查询帖子评论和回复的逻辑，将结果存储在 Model 对象。</p><p>【问题】sql 的 xml 文件中绑定参数时，应传入实体类属性名，拼错成数据库字段名（entityId 写成 entity_id）。</p><hr><h3 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h3><p>在 CommentMapper 接口新增 <code>insertComment</code> 方法，添加评论数据，在 <code>comment-mapper</code> 配置对应 sql。</p><p>在 DiscussPostMapper 接口新增 <code>updateCommentCount</code> 方法，增加评论数量，在 <code>discusspost-mapper</code> 配置对应 sql。</p><p>在 DiscussPostService 类新增 <code>updateCommentCount</code> 方法，调用 DiscussPostMapper 的 <code>updateCommentCount</code> 方法。</p><p>在 CommentService 类新增 <code>addComment</code> 方法，调用 CommentMapper 的 <code>insertComment</code> 新增评论，并调用 DiscussPostService 的 <code>updateCommentCount</code> 更新评论数量，使用 <code>@Transactional</code> 注解保证事务。</p><p>创建 CommentController 类，新增 <code>addComment</code> 方法，从 hostHolder 获取用户信息，然后调用 CommentService 的 <code>addComment</code> 方法添加评论。</p><p>【问题】sql 的 xml 文件中绑定参数时，应传入实体类属性名，拼错成数据库字段名（entityId 写成 entity_id）。</p><hr><h3 id="显示私信列表-（message-表）"><a href="#显示私信列表-（message-表）" class="headerlink" title="显示私信列表 （message 表）"></a>显示私信列表 （message 表）</h3><p>创建对应 message 表的实体类 Message。</p><p>创建 MessageMapper 接口，增加查询会话列表、会话数量、私信列表、私信数量、未读私信数量等方法，在 <code>message-mapper.xml</code> 中配置对应的 sql。</p><p>创建 MessageService，调用 MessageMapper 中的方法。</p><p>创建 MessgaeController</p><ul><li>新增 <code>getLetterList</code> 方法，将会话列表信息存储到 Model 对象，返回 <code>letter</code> 视图。</li><li>新增 <code>getLetterDetail</code> 方法，将每个会话具体的私信信息存储到 Model 对象，返回 <code>letter-datail</code> 视图。</li></ul><hr><h3 id="发送私信"><a href="#发送私信" class="headerlink" title="发送私信"></a>发送私信</h3><p>在 MessageMapper </p><ul><li>新增 <code>insertMessage</code> 方法插入私信记录，在 <code>message-mapper.xml</code>  配置 insert 语句。</li><li>新增 <code>updateMessgae</code> 方法修改私信状态，在 <code>message-mapper.xml</code>  配置 update 语句，利用 foreach 动态 sql。</li></ul><p>在 MessageService</p><ul><li><p>新增 <code>addMessage</code> 发送私信方法，过滤敏感词后，调用 MessageMapper 的 <code>insertMessage</code> 。</p></li><li><p>新增 <code>readMessage</code> 方法读取信息，调用MessageMapper 的 <code>updateMessgae</code> 更新私信的状态为 1。</p></li></ul><p>在 MessageController </p><ul><li><p>新增 <code>getLetterIds</code> 方法，将私信集合中未读私信的 id 添加到 List 集合并返回，在 <code>getLetterDetail</code> 方法调用该方法设置已读。</p></li><li><p>新增 <code>sendLetter</code> 发送私信方法，设置私信信息后调用 MessageService 的 <code>addMessage</code> 发送。</p></li></ul><hr><h3 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h3><p>在 HomeController 中增加 <code>getErrorPage</code> 方法，返回错误页面。</p><p>创建 ExceptionAdvice 类</p><ul><li>加上 <code>@ControllerAdvice</code> 注解，表示该类是 Controller 的全局配置类。</li><li>创建 <code>handleException</code> 方法，加上 <code>@ExceptionHandler</code> 注解，该方法在 Controller 出现异常后调用，处理捕获异常。如果是异步请求返回一个 JSON 数据，否则重定向至 HomeController 的 <code>getErrorPage</code> 方法。</li></ul><hr><h3 id="统一日志处理"><a href="#统一日志处理" class="headerlink" title="统一日志处理"></a>统一日志处理</h3><p>在 <code>pom.xml</code> 引入 aspectj 的依赖。</p><p>创建 ServiceLogAspect 类，添加 <code>@Aspect</code> 切面注解，配置切入点表达式，拦截所有 service 包下的方法，利用 <code>@Before</code> 记录日志。</p><hr><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>创建 RedisKeyUtil 工具类</p><ul><li>定义分隔符 <code>:</code> 以及实体获得赞的 key 前缀常量 <code>like:entity</code>。</li><li>新增 <code>getEntityLikeKey(int entityType,int entityId)</code> 方法，通过实体类型和实体 id 生成对应实体获得赞的 key。</li></ul><p>创建业务层的 LikeService 类</p><ul><li><p>注入 RedisTemplate 实例。</p></li><li><p>新增 <code>like</code> 点赞方法，首先通过 RedisKeyUtil 工具类的  <code>getEntityLikeKey</code> 方法获得实体点赞的 key，然后通过 RedisTemplate 对象对 set 集合的 <code>isMember</code> 方法查询 userId 是否存在于对应 key 的 set 集合中，如果存在则移除出点赞的用户集合，如果不存在则添加到点赞的用户集合。</p></li><li><p>新增 <code>findEntityLikeCount</code> 方法查询实体的点赞数量，通过调用 set 集合的 <code>size</code> 方法查询元素个数。</p></li><li><p>新增 <code>findEntityLikeStatus</code> 方法查询某用户对某实体的点赞状态，逻辑如 <code>like</code> 方法，通过 set 集合的 <code>isMember</code> 方法实现。</p></li></ul><p>创建表现层的 LikeController 类</p><ul><li>注入 LikeService 和 HostHolder 实例。</li><li>新增 <code>like</code> 点赞方法，调用业务层的 <code>like</code> 方法进行点赞、调用  <code>findEntityLikeCount</code> 和 <code>findEntityLikeStatus</code>  查询点赞数量和点赞状态，封装到 map 集合，然后通过工具类封装成 JSON 数据返回。</li></ul><p>（更新首页帖子点赞数量）在表现层的 HomeController 类</p><ul><li>注入 LikeService 实例。</li><li>在 <code>getIndexPage</code> 方法在通过 LikeService 类的方法获得点赞数量，存储到 map 集合。</li></ul><hr><h3 id="收到的赞"><a href="#收到的赞" class="headerlink" title="收到的赞"></a>收到的赞</h3><p>对点赞功能进行重构</p><p>在 RedisUnitl 工具类</p><ul><li><p>新增用户获得赞 key 的前缀常量 <code>like:user</code></p></li><li><p>新增 <code>getUserLikeKey(int userId)</code> 方法，通过用户 id 生成对应用户获得赞的 key。</p></li></ul><p>在 LikeService 中</p><ul><li><p>重构 <code>like</code> 方法，在参数列表中加入 entityUserId 表示被点赞用户的 id，用来更新用户的被点赞数量。</p><ul><li><p>通过 RedisTemplate 对象的 <code>execute</code> 方法实现事务，保证被点赞用户点和点赞用户的数据更新一致。通过 <code>isMember</code> 方法查询用户的点赞状态，之后通过 <code>mutli</code> 方法开启事务。</p></li><li><p>当用户已点赞时，调用 <code>remove</code> 方法将当前用户从点赞用户的集合中移除，调用 <code>decrement</code> 方法将被点赞用户的被点赞数减 1；当用户未点赞时，调用 <code>add</code> 方法将当前用户添加到点赞用户的集合，调用 <code>increment</code> 方法将被点赞用户的被点赞数加 1。</p></li></ul></li><li><p>增加 <code>findUserLikeCount</code> 方法，以用户 id 作为 key，调用 <code>get</code> 方法查询用户所获得的点赞数。</p></li></ul><p>在 LikeController 中给 <code>like</code> 方法增加 entityUserId 参数即可。</p><hr><h3 id="关注"><a href="#关注" class="headerlink" title="关注"></a>关注</h3><p>在 RedisUnitl 工具类</p><ul><li><p>新增用户关注实体（帖子、评论、用户等）和粉丝（用户）的前缀常量 <code>followee</code> 和 <code>follower</code></p></li><li><p>新增 <code>getFolloweeKey(int userId, int entityType)</code> 方法，通过用户 id 和实体类型生成用户关注实体的 key。</p></li><li><p>新增 <code>getFollowerKey(int entityType, int entityId)</code> 方法，通过实体类型和实体 id 生成实体用户粉丝的 key。</p></li></ul><p>创建业务层的 FollowService 类</p><ul><li>新增 <code>follow</code> 方法，当用户关注某实体时，<ul><li>调用 <code>add</code> 方法将当前实体 id  和时间作为 value 和 score加入用户的关注集合。</li><li>调用 <code>add</code> 方法将当前用户 id 和时间作为 value 和 score 加入实体的粉丝集合。</li></ul></li><li>新增 <code>unfollow</code> 方法，当用户取消关注某实体时，<ul><li>调用 <code>remove</code> 方法将当前实体从用户的关注集合移除。</li><li>调用 <code>remove</code> 方法将用户从实体的粉丝集合移除。</li></ul></li></ul><hr><h3 id="个人主页"><a href="#个人主页" class="headerlink" title="个人主页"></a>个人主页</h3><p>在业务层的 FollowService 类</p><ul><li>新增 <code>findFolloweeCount</code> 方法，调用 zset 的 <code>zcard</code>  方法查询某用户关注的实体数量。</li><li>新增 <code>findFollowerCount</code> 方法，调用 zset 的 <code>zcard</code>  方法查询某实体的粉丝数量。</li><li>新增 <code>hasFollowed</code> 方法，根据 zset 的 <code>zscore</code>  方法返回值查询当前用户是否关注某实体。</li></ul><p>在 UserController 中新增 <code>getProfilePage</code> 方法获取个人主页。</p><ul><li>调用 LikeService 的  <code>findUserLikeCount</code> 查询用户获赞数，并添加到 Model 中。</li><li>调用 FollowService 的<code>findFolloweeCount</code>、<code>findFollowerCount</code> 、<code>hasFollowed</code> 方法分别查询关注数量、粉丝数量、用户是否关注三项信息并添加到 Model 对象中存储。</li></ul><hr><h3 id="关注列表和粉丝列表"><a href="#关注列表和粉丝列表" class="headerlink" title="关注列表和粉丝列表"></a>关注列表和粉丝列表</h3><p>在业务层的 FollowService 类</p><ul><li>新增 <code>findFollowees</code> 方法，查询用户关注列表，主要通过 zset 的  <code>reverseRange</code> 获取 value 即关注用户的 userId，再查询出其 user，之后通过 <code>score</code> 获取关注时间，存入 map 集合，将 map 添加到 list 列表返回。</li><li>新增 <code>findFollowers</code> 方法，查询用户粉丝列表，主要通过 zset 的  <code>reverseRange</code> 获取 value 即粉丝的 userId，再查询出其 user，之后通过 <code>score</code> 获取关注时间，存入 map 集合，将 map 添加到 list 列表返回。</li></ul><p>在表现层的 FollowController 类</p><ul><li>新增 <code>getFollowees</code> 方法，获取关注列表，存入 Model 对象。</li><li>新增 <code>getFollowers</code> 方法，获取粉丝列表，存入 Model 对象。</li></ul><hr><h3 id="优化登录模块"><a href="#优化登录模块" class="headerlink" title="优化登录模块"></a>优化登录模块</h3><p><strong>存储验证码</strong></p><p>在 RedisUntil 工具类</p><ul><li>新增验证码前缀常量 <code>kaptcha</code></li><li>新增 <code>getKaptchaKey</code> 方法，通过一个用户凭证（由于未登录，利用 cookie 实现）获得对应验证码的 key 值（利用 string 存储验证码）。</li></ul><p>在表现层的 LoginController 类</p><ul><li>重构 <code>getKaptcha</code> 方法，将验证码存入 redis，key 值是当前随机生成的一个字符串，同时将该字符串存入 cookie。</li><li>重构 <code>login</code> 方法，从 cookie 中获得随机字符串，生成验证码的 key 值，然后获取对应的 value 值即验证码。</li></ul><hr><p><strong>存储登录凭证</strong></p><p>在 RedisUntil 工具类</p><ul><li>新增登录凭证前缀常量 <code>ticket</code></li><li>新增 <code>getTicketKey</code> 方法，通过字符串获得登录凭证的对应 key 值（利用 string 存储）。</li></ul><p>在业务层的 UserService 类</p><ul><li>重构 <code>login</code> 方法，将登录凭证存入 redis 中。</li><li>重构 <code>logout</code> 方法，先从 redis 中获取登录凭证对象，将状态设为无效再重新存储进 redis。</li><li>重构 <code>findLoginTicket</code> 方法，根据 ticket 字符串获得对应登录凭证的 key，然后从 redis 查询登录凭证。</li></ul><hr><p><strong>缓存用户信息</strong></p><p>在 RedisUntil 工具类</p><ul><li>新增用户前缀常量 <code>user</code></li><li>新增 <code>getUserKey</code> 方法，通过用户 id 获得用户的对应 key 值（利用 string 存储）。</li></ul><p>在业务层的 UserService 类</p><ul><li><p>新增 <code>getCache</code>，从缓存获取用户信息。</p></li><li><p>新增 <code>initCache</code>，从 MySQL 查询用户信息并存入 redis。</p></li><li><p>新增 <code>clearCache</code>，用户信息变更（更新头像，激活）时清除缓存。</p></li><li><p>重构 <code>findUserById</code> 方法，首先调用 <code>getCache</code>从缓存获取用户信息，如果获取为 null 则调用 <code>initCache</code>。</p></li></ul><hr><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="发送系统通知"><a href="#发送系统通知" class="headerlink" title="发送系统通知"></a>发送系统通知</h3><p>在 CommunityConstant 接口中新增三个常量，代表三个主题：评论、点赞、关注。</p><p>创建 Event 类，封装事件对象，包括主题、用户 id、实体类型、实体 id、实体用户 id 以及一个 map 集合存放其它信息。</p><h4 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h4><p>创建 EventProducer 事件生产者，新增 <code>fireEvent(Event event)</code> 方法，通过 Event 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 KafkaTemplate 实例的 send 方法发送。</p><p>在 CommentController、LikeControler、FollowController 中注入 EventProducer 实例，分别重构 <code>addComment</code> 方法、<code>like</code> 方法、<code>follow</code> 方法，封装 Event 对象，然后调用 EventProducer 的<code>fireEvent</code> 方法发布通知。</p><h4 id="消费事件"><a href="#消费事件" class="headerlink" title="消费事件"></a>消费事件</h4><p>创建 EventConsumer 事件消费者，消费者是被动触发的。</p><ul><li>注入 MessageService 实例。</li><li>增加 <code>handleCommentMessage(ConsumerRecord record)</code> 方法，通过 <code>@KafkaListener</code> 注解，topic 包括了评论、点赞和关注。从 recored 中获取信息，封装成 Message 对象然后调用 <code>addMessage</code> 方法插入数据库。</li></ul><p>【问题】没有向数据库插入系统通知记录，原因是 ServiceLogAspect 类进行日志处理时要获取 ServletRequestAttributes 请求对象，Kafka 的消费事件是自动触发的，没有进行新的请求，产生了请求对象的空指针异常。</p><hr><h3 id="显示系统通知"><a href="#显示系统通知" class="headerlink" title="显示系统通知"></a>显示系统通知</h3><h4 id="通知列表"><a href="#通知列表" class="headerlink" title="通知列表"></a>通知列表</h4><p>在 MessageMapper 接口中</p><ul><li><p>新增 <code>selectLatestNotice(int userId, String topic)</code> 方法，查询某主题最新的通知。</p></li><li><p>新增 <code>selectNoticeCount(int userId, String topic)</code> 方法，查询某主题通知的数量。</p></li><li><p>新增 <code>selectNoticeUnreadCount(int userId, String topic)</code> 方法，查询未读通知的数量。</p></li><li><p>在 <code>message-mapper.xml</code> 配置三个方法的 sql 语句，其中查询未读通知时使用 if 动态语句，如果没有传入 topic 就查询未读总量。</p></li></ul><p>在业务层的 MessageService 中</p><ul><li>新增 <code>findLatestNotice</code> 方法，调用 <code>selectLatestNotice</code> 方法查询最新通知。</li><li>新增 <code>findNoticeCount</code> 方法，调用 <code>selectNoticeCount</code> 方法查询某主题通知的数量。</li><li>新增 <code>findNoticeUnreadCount</code> 方法，调用 <code>selectNoticeUnreadCount</code> 方法查询未读通知的数量。</li></ul><p>在表现层的 MessageController 中新增 <code>getNoticeList</code> 方法，获取通知列表</p><ul><li>调用业务层 MessageService 的方法查询评论、点赞、关注的通知，将其封装在一个 HashMap 集合中然后添加到 Model 对象里。</li><li>调用业务层 MessageService 的方法查询私信和通知的总未读数量，添加到 Model 对象里。</li><li>返回 <code>notice.html</code> 页面。</li></ul><hr><h4 id="显示通知详情"><a href="#显示通知详情" class="headerlink" title="显示通知详情"></a>显示通知详情</h4><p>在 MessageMapper 接口新增 <code>selectNotices</code> 方法，查询某个主题的通知列表，在 <code>message-mapper.xml</code> 配置 SQL。</p><p>在业务层的 MessageService 中新增 <code>findNotices</code> 方法，调用 <code>selectNotices</code> 方法。</p><p>在表现层的 MessageController 中新增 <code>getNoticeDetail</code> 方法</p><ul><li>调用 <code>findNotices</code> 方法获取通知列表详情，封装到 List 集合并存入 Model 对象。</li><li>从通知集合中获取 id 集合，调用 <code>readMessage</code> 方法将消息设为已读。</li><li>返回 <code>notice-detail.html</code> 页面。</li></ul><hr><h4 id="显示未读通知总数"><a href="#显示未读通知总数" class="headerlink" title="显示未读通知总数"></a>显示未读通知总数</h4><p>创建 MessageInterceptor 拦截器</p><ul><li>注入 MessageService 实例和 HostHolder 实例。</li><li>重写 <code>postHandle</code> 方法，查询私信和通知的未读数量和，然后添加到 ModelAndView 对象。</li></ul><p>在 WebConfig 中注入 MessageInterceptor 实例，并在 <code>addInterceptors</code> 方法中添加该拦截器。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>论坛的总结和改进</title>
      <link href="/2020/11/01/%E8%AE%BA%E5%9D%9B%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%94%B9%E8%BF%9B/"/>
      <url>/2020/11/01/%E8%AE%BA%E5%9D%9B%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%94%B9%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><strong>用户表</strong>，包括 id、用户名、密码、盐值、邮箱、类型（普通/管理员/版主）、状态（激活/未激活）、激活码（随机字符串）、头像 url、注册时间。</p><p><strong>登录凭证表</strong>，包括 id、用户 id、登陆凭证（随机字符串）、登录状态（有效/无效）、过期时间。</p><p><strong>评论表</strong>，包括 id、评论用户 id（索引）、评论实体 id（索引）、评论类型（帖子/回复）、被评论目标 id、评论内容、评论状态（有效/无效）、评论时间。</p><p><strong>帖子表</strong>，包括 id、发帖用户 id（索引）、标题、帖子内容、类型（普通/置顶）、评论数量、状态（普通/精华/拉黑）、发帖时间。</p><p><strong>消息表</strong>，包括 id、发消息 id（索引）、收消息 id（索引）、会话 id（由发消息双方 id 拼接，索引）、内容、状态（未读/已读/删除）、发消息时间。</p><hr><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p><strong>判断注册合法性</strong></p><ul><li>利用 StringUtils 判断用户名、密码、邮箱是否非空。</li><li>分别通过用户名和邮箱查询是否已经注册（为数据库的用户名和邮箱字段添加索引）。</li></ul><p><strong>通过 <code>set</code> 方法为用户设置各项信息</strong>，包括 MD5 加密后的密码、激活码等，然后插入数据库。</p><p><strong>给用户发送激活邮件</strong></p><ul><li><p>在新浪邮箱打开 SMTP 服务，引入 <code>spring-boot-starter-mail</code> 依赖。</p></li><li><p>在配置文件配置主机（smtp.sina.com）、端口（465）、邮箱、授权码、协议（smtps），设置 smtp.ssl.enable = true。</p></li><li><p>调用 JavaMailSender 的 API 发送邮件，激活 url 由用户 id 和用户的激活码拼接而成。点击激活 url 后由 controller 中的方法进行处理（成功/重复/失败），调用 Model 对象的 <code>addAttribute</code> 方法将结果返回前端。</p></li></ul><hr><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p><strong>生成验证码</strong></p><ul><li><p>引入 kaptcha 依赖，将验证码的大小、范围、长度等属性封装到 Properties 对象，作为参数构造 Config 对象，再用 Config 对象作为 DeafultKaptcha 对象  <code>setConfig</code> 方法的参数为验证码设置属性。</p></li><li><p>在登录的 controller 处理验证码，设置页面的响应类型为 png，通过 ImageIO 的 <code>write</code> 方法将图片输出到浏览器。</p></li></ul><p><strong>判断验证码正确后，调用业务层处理</strong></p><ul><li>利用 StringUtils 判断用户名、密码是否非空，之后判断用户是否存在、用户是否激活、密码是否正确，将错误信息存到 map 集合。</li><li>如果全部合法，为用户生成一个包含过期时间的登录凭证，将凭证存入 redis 和 map 集合。</li></ul><p><strong>根据返回的 map 是否包含登陆凭证判断登陆状态</strong></p><ul><li>如果登录成功，将凭证存入 cookie 并重定向至首页。</li><li>如果登陆失败，将 map 中的错误信息添加到 Model 对象，返回登录页。</li></ul><hr><h3 id="检查登录状态"><a href="#检查登录状态" class="headerlink" title="检查登录状态"></a>检查登录状态</h3><p>只处理带有自定义注解的方法，防止用户在未登录情况下通过 url 访问没有权限的页面。</p><p>利用 ThreadLocal 创建 HostHolder 类，包括 <code>set</code>、<code>get</code>、<code>remove</code> 方法，模拟 session 存储用户信息。</p><p>通过实现 HandlerInterceptor 接口创建一个拦截器，在 <code>preHandle</code> 方法中通过查询是否有登录凭证的 cookie，如果有则通过登录凭证查询用户 ID，再通过用户 ID 查询用户。最后将用户放入 hostHolder 中，在本次请求中持有用户信息。</p><p>创建 <code>@LoginRequired</code> 自定义注解，作用范围在方法上，有效期为运行时。为需要在登录状态下调用的方法，例如修改密码、上传头像等方法上等加上自定义注解。</p><p>创建拦截器，在 <code>preHandle</code> 中判断方法是否添加了 <code>@LoginRequired</code> 注解，如果加了并且从 hostHolder 获取不到用户则拒绝访问。</p><hr><h3 id="发帖、评论、私信"><a href="#发帖、评论、私信" class="headerlink" title="发帖、评论、私信"></a>发帖、评论、私信</h3><p><strong>敏感词过滤</strong></p><ul><li>创建静态内部类 TrieNode ，通过 boolean 结束符判断是否匹配到关键字尾部。</li><li>利用 <code>@PostConstruct</code> 注解，在构造方法执行后初始化字典树。</li><li>添加 <code>filter</code> 方法，利用双指针进行匹配，过滤敏感词。</li></ul><p><strong>发帖、评论、私信</strong></p><ul><li><p>对内容进行 HTML 转义以及过滤敏感词。</p></li><li><p>将信息插入数据库的帖子/评论/消息表。</p></li></ul><hr><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>创建 RedisKeyUtil 工具类，通过实体类型和实体 id 生成对应实体获得赞的 key。</p><p>点赞/取消点赞：</p><ul><li><p>通过 RedisKeyUtil 获得实体点赞的 key，然后通过 RedisTemplate 的 API 操作，调用集合的 <code>isMember</code> 方法查询 userId 是否存在于对应集合中，如果存在则移除出点赞的用户集合，如果不存在则添加到点赞的用户集合。</p></li><li><p>通过 RedisTemplate 的 <code>execute</code> 方法实现事务，保证被点赞用户点和点赞用户的数据更新一致。通过 <code>isMember</code> 方法查询用户的点赞状态，之后通过 <code>mutli</code> 方法开启事务。</p></li></ul><p>点赞数量：通过调用 set 集合的 <code>size</code> 方法查询元素个数。</p><p>点赞状态：通过 set 集合的 <code>isMember</code> 方法实现。</p><hr><h3 id="关注和粉丝"><a href="#关注和粉丝" class="headerlink" title="关注和粉丝"></a>关注和粉丝</h3><p>在 RedisUnitl 工具类增加两个方法</p><ul><li><p>通过用户 id 和实体类型获得用户关注的实体集合的 key。</p></li><li><p>通过实体类型和实体 id 获得实体拥有的粉丝集合的 key。</p></li></ul><p>当用户关注某实体时，</p><ul><li>将实体 id 和时间作为 value 和 score 加入用户的关注集合。</li><li>将用户 id 和时间作为 value 和 score 加入实体的粉丝集合。</li></ul><p>当用户取消关注某实体时，将实体从用户的关注集合移除，用户从实体的粉丝集合移除。</p><p><strong>关注列表和粉丝列表</strong></p><ul><li>用户的关注列表，通过 zset 的  <code>reverseRange</code> 获取 value 即关注用户的 userId，再查询出 user，通过 <code>score</code> 获取关注时间。</li><li>用户的粉丝列表，通过 zset 的  <code>reverseRange</code> 获取 value 即粉丝的 userId，再查询出 user，通过 <code>score</code> 获取关注时间。</li><li>列表信息封装在 list 集合中，再将 list 添加到 Model 对象里。</li></ul><hr><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p><strong>发送系统通知</strong></p><p>创建 Event 类，封装事件对象，包括主题（评论、点赞、关注）、用户 id、实体类型、实体 id，以及一个 map 集合存放其它信息。</p><p><strong>触发事件</strong></p><p>通过 Event 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 KafkaTemplate 实例的 send 方法发送。</p><p><strong>消费事件</strong></p><p>通过 <code>@KafkaListener</code> 注解，topic 包括了评论、点赞和关注。从 recored 中获取信息，封装成 Message 对象然后调用 <code>addMessage</code> 方法插入数据库。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拆分为dubbo</title>
      <link href="/2020/10/30/%E6%8B%86%E5%88%86%E4%B8%BAdubbo/"/>
      <url>/2020/10/30/%E6%8B%86%E5%88%86%E4%B8%BAdubbo/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="gateway"><a href="#gateway" class="headerlink" title="gateway"></a>gateway</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Reference(interfaceClass &#x3D; RedisServiceApi.class)</span><br></pre></td></tr></table></figure><h4 id="总的pom"><a href="#总的pom" class="headerlink" title="总的pom"></a>总的pom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"> </span><br><span class="line">&lt;groupId&gt;com.example&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dubbodemo&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"> </span><br><span class="line">&lt;name&gt;dubbodemo&lt;&#x2F;name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"> </span><br><span class="line">&lt;modules&gt;</span><br><span class="line">&lt;module&gt;provider&lt;&#x2F;module&gt;</span><br><span class="line">&lt;module&gt;consumer&lt;&#x2F;module&gt;</span><br><span class="line">&lt;module&gt;api&lt;&#x2F;module&gt;</span><br><span class="line">&lt;&#x2F;modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><h4 id="common模块（api模块"><a href="#common模块（api模块" class="headerlink" title="common模块（api模块)"></a>common模块（api模块)</h4><p>User.java，实体类根据需要自己编写，但要注意的是需要实现Serializable这个接口</p><p>api中存放entity实体类和service接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line"> </span><br><span class="line">    private static final long serialVersionUID &#x3D; 7739394865008699599L;</span><br><span class="line"> </span><br><span class="line">    private Long id;</span><br><span class="line"> </span><br><span class="line">    private String username;</span><br><span class="line"> </span><br><span class="line">    private String password;</span><br><span class="line"> </span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, password&#x3D;&#39;&quot; + password + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通用模块的pom"><a href="#通用模块的pom" class="headerlink" title="通用模块的pom"></a>通用模块的pom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;name&gt;dis-seckill-common&lt;&#x2F;name&gt;</span><br><span class="line">&lt;description&gt;通用模块&lt;&#x2F;description&gt;</span><br></pre></td></tr></table></figure><h4 id="消费者的配置文件"><a href="#消费者的配置文件" class="headerlink" title="消费者的配置文件"></a>消费者的配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 避免和provider工程端口冲突</span><br><span class="line">server.port&#x3D;7001</span><br><span class="line">## Dubbo 服务消费者配置</span><br><span class="line">spring.dubbo.application.name&#x3D;consumer &#x2F;&#x2F;模块名字</span><br><span class="line">## Dubbo 服务对象的注册中心zookeeper的地址和端口</span><br><span class="line">spring.dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;localhost:2181</span><br><span class="line">##  服务对象的被注入的包扫描范围</span><br><span class="line">spring.dubbo.scan&#x3D;com.example.consumer.controller &#x2F;&#x2F;相应的service包的位置</span><br></pre></td></tr></table></figure><p><img src="/2020/10/30/%E6%8B%86%E5%88%86%E4%B8%BAdubbo/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201030093252682.png" alt="image-20201030093252682"></p><h4 id="消费者的pom"><a href="#消费者的pom" class="headerlink" title="消费者的pom"></a>消费者的pom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    &lt;name&gt;dis-seckill-goods&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;商品模块&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 添加对api模块的依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.example&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- Spring Boot Dubbo 依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.dubbo.springboot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-dubbo&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;dubbo-spring-boot&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;&#x2F;exclusion&gt;</span><br><span class="line">&lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="服务提供者的配置"><a href="#服务提供者的配置" class="headerlink" title="服务提供者的配置"></a>服务提供者的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;8001</span><br><span class="line">## Dubbo 服务提供者配置</span><br><span class="line">spring.dubbo.application.name&#x3D;provider</span><br><span class="line">## Dubbo 服务对象的注册中心zookeeper的地址和端口</span><br><span class="line">spring.dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;localhost:2181</span><br><span class="line">## 用Dubbo协议在20880端口暴露服务</span><br><span class="line">spring.dubbo.protocol.name&#x3D;dubbo</span><br><span class="line">spring.dubbo.protocol.port&#x3D;20880</span><br><span class="line">## 包扫描范围</span><br><span class="line">spring.dubbo.scan&#x3D;com.example.provider.serviceimpl</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机常见的监控工具</title>
      <link href="/2020/10/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/10/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JDK-监控和故障处理工具总结"><a href="#JDK-监控和故障处理工具总结" class="headerlink" title="JDK 监控和故障处理工具总结"></a>JDK 监控和故障处理工具总结</h1><h2 id="JDK-命令行工具"><a href="#JDK-命令行工具" class="headerlink" title="JDK 命令行工具"></a>JDK 命令行工具</h2><p>这些命令在 JDK 安装目录下的 bin 目录下：</p><ul><li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li><li><strong><code>jstat</code></strong>（ JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li><li><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;</li><li><strong><code>jmap</code></strong> (Memory Map for Java) :生成堆转储快照;</li><li><strong><code>jhat</code></strong> (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</li><li><strong><code>jstack</code></strong> (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li></ul><h3 id="jps-查看所有-Java-进程"><a href="#jps-查看所有-Java-进程" class="headerlink" title="jps:查看所有 Java 进程"></a>jps:查看所有 Java 进程</h3><p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code> 命令。</p><p><code>jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。<code>jps -q</code> ：只输出进程的本地虚拟机唯一 ID。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">16504</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServerCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps <span class="literal">-l</span></span><br><span class="line"><span class="number">7360</span> firstNettyDemo.NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">16492</span> sun.tools.jps.Jps</span><br><span class="line"><span class="number">17340</span> firstNettyDemo.NettyServerCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p><p><code>jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p><h3 id="jstat-监视虚拟机各种运行状态信息"><a href="#jstat-监视虚拟机各种运行状态信息" class="headerlink" title="jstat: 监视虚拟机各种运行状态信息"></a>jstat: 监视虚拟机各种运行状态信息</h3><p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p><p><strong>jstat 命令使用格式：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-<span class="type">t</span>] [-<span class="type">h</span>&lt;<span class="type">lines</span>&gt;] &lt;vmid&gt; [&lt;<span class="built_in">int</span><span class="type">erval</span>&gt; [&lt;<span class="type">count</span>&gt;]]Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>比如 <code>jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p><p><strong>常见的 option 如下：</strong></p><ul><li><code>jstat -class vmid</code> ：显示 ClassLoader 的相关信息；</li><li><code>jstat -compiler vmid</code> ：显示 JIT 编译的相关信息；</li><li><code>jstat -gc vmid</code> ：显示与 GC 相关的堆信息；</li><li><code>jstat -gccapacity vmid</code> ：显示各个代的容量及使用情况；</li><li><code>jstat -gcnew vmid</code> ：显示新生代信息；</li><li><code>jstat -gcnewcapcacity vmid</code> ：显示新生代大小与使用情况；</li><li><code>jstat -gcold vmid</code> ：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了；</li><li><code>jstat -gcoldcapacity vmid</code> ：显示老年代的大小；</li><li><code>jstat -gcpermcapacity vmid</code> ：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了；</li><li><code>jstat -gcutil vmid</code> ：显示垃圾收集信息；</li></ul><p>另外，加上 <code>-t</code>参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。</p><h3 id="jinfo-实时地查看和调整虚拟机各项参数"><a href="#jinfo-实时地查看和调整虚拟机各项参数" class="headerlink" title="jinfo: 实时地查看和调整虚拟机各项参数"></a>jinfo: 实时地查看和调整虚拟机各项参数</h3><p><code>jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p><p><code>jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code>-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span> MaxHeapSize <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:MaxHeapSize=<span class="number">2124414976</span></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span> PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:<span class="literal">-PrintGCCopy</span> to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p><p><code>jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:<span class="literal">-PrintGC</span></span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  +PrintGC <span class="number">17340</span></span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:+PrintGCCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="jmap-生成堆转储快照"><a href="#jmap-生成堆转储快照" class="headerlink" title="jmap:生成堆转储快照"></a>jmap:生成堆转储快照</h3><p><code>jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code>jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code>“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 <code>kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p><p><code>jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在 Windows 平台下也是受限制的。</p><p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jmap <span class="literal">-dump</span>:format=b,file=C:\Users\SnailClimb\Desktop\heap.hprof <span class="number">17340</span></span><br><span class="line">Dumping heap to C:\Users\SnailClimb\Desktop\heap.hprof ...</span><br><span class="line">Heap dump file createdCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="jhat-分析-heapdump-文件"><a href="#jhat-分析-heapdump-文件" class="headerlink" title="jhat: 分析 heapdump 文件"></a>jhat: 分析 heapdump 文件</h3><p><strong><code>jhat</code></strong> 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jhat C:\Users\SnailClimb\Desktop\heap.hprof</span><br><span class="line">Reading from C:\Users\SnailClimb\Desktop\heap.hprof...</span><br><span class="line">Dump file created Sat May <span class="number">04</span> <span class="number">12</span>:<span class="number">30</span>:<span class="number">31</span> CST <span class="number">2019</span></span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving <span class="number">131419</span> objects...</span><br><span class="line">Chasing references, expect <span class="number">26</span> dots..........................</span><br><span class="line">Eliminating duplicate references..........................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port <span class="number">7000</span></span><br><span class="line">Server is ready.Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:7000/" target="_blank" rel="noopener">http://localhost:7000/</a></p><h3 id="jstack-生成虚拟机当前时刻的线程快照"><a href="#jstack-生成虚拟机当前时刻的线程快照" class="headerlink" title="jstack :生成虚拟机当前时刻的线程快照"></a>jstack :生成虚拟机当前时刻的线程快照</h3><p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p><p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p><p><strong>下面是一个线程死锁的代码。我们下面会通过 <code>jstack</code> 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><p><strong>通过 <code>jstack</code> 命令分析：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">13792</span> KotlinCompileDaemon</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">8932</span> Launcher</span><br><span class="line"><span class="number">9256</span> DeadLockDemo</span><br><span class="line"><span class="number">10764</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServer</span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jstack <span class="number">9256</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>输出的部分内容如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Found one Java<span class="literal">-level</span> deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"线程 2"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000333e668 (object <span class="number">0</span>x00000000d5efe1c0, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"线程 1"</span></span><br><span class="line"><span class="string">"线程 1"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000333be88 (object <span class="number">0</span>x00000000d5efe1d0, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"线程 2"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"线程 2"</span>:</span><br><span class="line">        at DeadLockDemo.lambda<span class="variable">$main</span><span class="variable">$1</span>(DeadLockDemo.java:<span class="number">31</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo<span class="variable">$</span><span class="variable">$Lambda</span><span class="variable">$2</span>/<span class="number">1078694789</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">"线程 1"</span>:</span><br><span class="line">        at DeadLockDemo.lambda<span class="variable">$main</span><span class="variable">$0</span>(DeadLockDemo.java:<span class="number">16</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo<span class="variable">$</span><span class="variable">$Lambda</span><span class="variable">$1</span>/<span class="number">1324119927</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>可以看到 <code>jstack</code> 命令已经帮我们找到发生死锁的线程的具体信息。</p><h2 id="JDK-可视化分析工具"><a href="#JDK-可视化分析工具" class="headerlink" title="JDK 可视化分析工具"></a>JDK 可视化分析工具</h2><h3 id="JConsole-Java-监视与管理控制台"><a href="#JConsole-Java-监视与管理控制台" class="headerlink" title="JConsole:Java 监视与管理控制台"></a>JConsole:Java 监视与管理控制台</h3><p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出<code>console</code>命令启动或者在 JDK 目录下的 bin 目录找到<code>jconsole.exe</code>然后双击启动。</p><h4 id="连接-Jconsole"><a href="#连接-Jconsole" class="headerlink" title="连接 Jconsole"></a>连接 Jconsole</h4><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/1JConsole%E8%BF%9E%E6%8E%A5.png" alt="连接 Jconsole"></p><p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Djava.rmi.server.hostname</span>=<span class="string">外网访问 ip 地址 </span></span><br><span class="line"><span class="meta">-Dcom.sun.management.jmxremote.port</span>=<span class="string">60001   //监控的端口号</span></span><br><span class="line"><span class="meta">-Dcom.sun.management.jmxremote.authenticate</span>=<span class="string">false   //关闭认证</span></span><br><span class="line"><span class="meta">-Dcom.sun.management.jmxremote.ssl</span>=<span class="string">falseCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>在使用 JConsole 连接时，远程进程地址如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外网访问 ip 地址:60001 Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="查看-Java-程序概况"><a href="#查看-Java-程序概况" class="headerlink" title="查看 Java 程序概况"></a>查看 Java 程序概况</h4><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/2%E6%9F%A5%E7%9C%8BJava%E7%A8%8B%E5%BA%8F%E6%A6%82%E5%86%B5.png" alt="查看 Java 程序概况 "></p><h4 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h4><p>JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。</p><p>点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。</p><blockquote><ul><li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li></ul></blockquote><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/3%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7.png" alt="内存监控 "></p><h4 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h4><p>类似我们前面讲的 <code>jstack</code> 命令，不过这个是可视化的。</p><p>最下面有一个”检测死锁 (D)”按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/4%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7.png" alt="线程监控 "></p><h3 id="Visual-VM-多合一故障处理工具"><a href="#Visual-VM-多合一故障处理工具" class="headerlink" title="Visual VM:多合一故障处理工具"></a>Visual VM:多合一故障处理工具</h3><p>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<a href="https://visualvm.github.io/" target="_blank" rel="noopener">https://visualvm.github.io/</a> 。Visual VM 中文文档:<a href="https://visualvm.github.io/documentation.html。" target="_blank" rel="noopener">https://visualvm.github.io/documentation.html。</a></p><p>下面这段话摘自《深入理解 Java 虚拟机》。</p><blockquote><p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p></blockquote><p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p><ul><li><strong>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</strong></li><li><strong>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</strong></li><li><strong>dump 以及分析堆转储快照（jmap、jhat）。</strong></li><li><strong>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</strong></li><li><strong>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</strong></li><li><strong>其他 plugins 的无限的可能性……</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计一个高可用系统</title>
      <link href="/2020/10/28/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/10/28/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="什么是高可用？可用性的判断标准是啥？"><a href="#什么是高可用？可用性的判断标准是啥？" class="headerlink" title="什么是高可用？可用性的判断标准是啥？"></a>什么是高可用？可用性的判断标准是啥？</h2><p><strong>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</strong></p><p><strong>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。</strong></p><p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</p><h2 id="哪些情况会导致系统不可用？"><a href="#哪些情况会导致系统不可用？" class="headerlink" title="哪些情况会导致系统不可用？"></a>哪些情况会导致系统不可用？</h2><ol><li>黑客攻击；</li><li>硬件故障，比如服务器坏掉。</li><li>并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。</li><li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。</li><li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。</li><li>自然灾害或者人为破坏。</li><li>……</li></ol><h2 id="有哪些提高系统可用性的方法？"><a href="#有哪些提高系统可用性的方法？" class="headerlink" title="有哪些提高系统可用性的方法？"></a>有哪些提高系统可用性的方法？</h2><h3 id="1-注重代码质量，测试严格把关"><a href="#1-注重代码质量，测试严格把关" class="headerlink" title="1. 注重代码质量，测试严格把关"></a>1. 注重代码质量，测试严格把关</h3><p>我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！</p><p>另外，安利这个对提高代码质量有实际效果的宝贝：</p><ol><li>sonarqube ：保证你写出更安全更干净的代码！（ps: 目前所在的项目基本都会用到这个插件）。</li><li>Alibaba 开源的 Java 诊断工具 Arthas 也是很不错的选择。</li><li>IDEA 自带的代码分析等工具进行代码扫描也是非常非常棒的。</li></ol><h3 id="2-使用集群，减少单点故障"><a href="#2-使用集群，减少单点故障" class="headerlink" title="2.使用集群，减少单点故障"></a>2.使用集群，减少单点故障</h3><p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例，不到一秒就会有另外一台 Redis 实例顶上。</p><h3 id="3-限流"><a href="#3-限流" class="headerlink" title="3.限流"></a>3.限流</h3><p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。——来自 alibaba-<a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel</a> 的 wiki。</p><h3 id="4-超时和重试机制设置"><a href="#4-超时和重试机制设置" class="headerlink" title="4.超时和重试机制设置"></a>4.超时和重试机制设置</h3><p>一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p><h3 id="5-熔断机制"><a href="#5-熔断机制" class="headerlink" title="5.熔断机制"></a>5.熔断机制</h3><p>超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的是流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。</p><h3 id="6-异步调用"><a href="#6-异步调用" class="headerlink" title="6.异步调用"></a>6.异步调用</h3><p>异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 <strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。</p><h3 id="7-使用缓存"><a href="#7-使用缓存" class="headerlink" title="7.使用缓存"></a>7.使用缓存</h3><p>如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！</p><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h3><ol><li><strong>核心应用和服务优先使用更好的硬件</strong></li><li><strong>监控系统资源使用情况增加报警设置。</strong></li><li><strong>注意备份，必要时候回滚。</strong></li><li><strong>灰度发布：</strong> 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可</li><li><strong>定期检查/更换硬件：</strong> 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。</li><li>…..(想起来再补充！也欢迎各位欢迎补充！)</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/high-availability/如何设计一个高可用系统要考虑哪些地方?id=总结" target="_blank" rel="noopener">总结</a></h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%EF%BC%9F.png" alt="如何设计高可用系统？"></p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式ID生成方案</title>
      <link href="/2020/10/28/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"/>
      <url>/2020/10/28/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做<strong>分布式ID</strong>，或<strong>全局ID</strong>。下面来分析各个生成分布式ID的机制。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%88%86%E5%B8%83%E5%BC%8Fid%E6%96%B9%E6%A1%88.jpeg" alt="常用分布式id方案"></p><p>这篇文章并不会分析的特别详细，主要是做一些总结，以后再出一些详细某个方案的文章。</p><h2 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h2><p>第一种方案仍然还是基于数据库的自增ID，需要单独使用一个数据库实例，在这个实例中新建一个单独的表：</p><p>表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`SEQID`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SEQID.SEQUENCE_ID (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment, </span><br><span class="line">    stub <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> stub (stub)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>可以使用下面的语句生成并获取到一个自增ID</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">replace</span> <span class="keyword">into</span> SEQUENCE_ID (stub) <span class="keyword">VALUES</span> (<span class="string">'anyword'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">last_insert_id</span>();</span><br><span class="line"><span class="keyword">commit</span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>stub字段在这里并没有什么特殊的意义，只是为了方便的去插入数据，只有能插入数据才能产生自增id。而对于插入我们用的是replace，replace会先看是否存在stub指定值一样的数据，如果存在则先delete再insert，如果不存在则直接insert。</p><p>这种生成分布式ID的机制，需要一个单独的Mysql实例，虽然可行，但是基于性能与可靠性来考虑的话都不够，<strong>业务系统每次需要一个ID时，都需要请求数据库获取，性能低，并且如果此数据库实例下线了，那么将影响所有的业务系统。</strong></p><p>为了解决数据库可靠性问题，我们可以使用第二种分布式ID生成方案。</p><h2 id="数据库多主模式"><a href="#数据库多主模式" class="headerlink" title="数据库多主模式"></a>数据库多主模式</h2><p>如果我们两个数据库组成一个<strong>主从模式</strong>集群，正常情况下可以解决数据库可靠性问题，但是如果主库挂掉后，数据没有及时同步到从库，这个时候会出现ID重复的现象。我们可以使用<strong>双主模式</strong>集群，也就是两个Mysql实例都能单独的生产自增ID，这样能够提高效率，但是如果不经过其他改造的话，这两个Mysql实例很可能会生成同样的ID。需要单独给每个Mysql实例配置不同的起始值和自增步长。</p><p>第一台Mysql实例配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">1</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>第二台Mysql实例配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">2</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>经过上面的配置后，这两个Mysql实例生成的id序列如下： mysql1,起始值为1,步长为2,ID生成的序列为：1,3,5,7,9,… mysql2,起始值为2,步长为2,ID生成的序列为：2,4,6,8,10,…</p><p>对于这种生成分布式ID的方案，需要单独新增一个生成分布式ID应用，比如DistributIdService，该应用提供一个接口供业务应用获取ID，业务应用需要一个ID时，通过rpc的方式请求DistributIdService，DistributIdService随机去上面的两个Mysql实例中去获取ID。</p><p>实行这种方案后，就算其中某一台Mysql实例下线了，也不会影响DistributIdService，DistributIdService仍然可以利用另外一台Mysql来生成ID。</p><p>但是这种方案的扩展性不太好，如果两台Mysql实例不够用，需要新增Mysql实例来提高性能时，这时就会比较麻烦。</p><p>现在如果要新增一个实例mysql3，要怎么操作呢？ 第一，mysql1、mysql2的步长肯定都要修改为3，而且只能是人工去修改，这是需要时间的。 第二，因为mysql1和mysql2是不停在自增的，对于mysql3的起始值我们可能要定得大一点，以给充分的时间去修改mysql1，mysql2的步长。 第三，在修改步长的时候很可能会出现重复ID，要解决这个问题，可能需要停机才行。</p><p>为了解决上面的问题，以及能够进一步提高DistributIdService的性能，如果使用第三种生成分布式ID机制。</p><h2 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h2><p>我们可以使用号段的方式来获取自增ID，号段可以理解成批量获取，比如DistributIdService从数据库获取ID时，如果能批量获取多个ID并缓存在本地的话，那样将大大提供业务应用获取ID的效率。</p><p>比如DistributIdService每次从数据库获取ID时，就获取一个号段，比如(1,1000]，这个范围表示了1000个ID，业务应用在请求DistributIdService提供ID时，DistributIdService只需要在本地从1开始自增并返回即可，而不需要每次都请求数据库，一直到本地自增到1000时，也就是当前号段已经被用完时，才去数据库重新获取下一号段。</p><p>所以，我们需要对数据库表进行改动，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> id_generator (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  current_max_id <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'当前最大id'</span>,</span><br><span class="line">  increment_step <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'号段的长度'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这个数据库表用来记录自增步长以及当前自增ID的最大值（也就是当前已经被申请的号段的最后一个值），因为自增逻辑被移到DistributIdService中去了，所以数据库不需要这部分逻辑了。</p><p>这种方案不再强依赖数据库，就算数据库不可用，那么DistributIdService也能继续支撑一段时间。但是如果DistributIdService重启，会丢失一段ID，导致ID空洞。</p><p>为了提高DistributIdService的高可用，需要做一个集群，业务在请求DistributIdService集群获取ID时，会随机的选择某一个DistributIdService节点进行获取，对每一个DistributIdService节点来说，数据库连接的是同一个数据库，那么可能会产生多个DistributIdService节点同时请求数据库获取号段，那么这个时候需要利用乐观锁来进行控制，比如在数据库表中增加一个version字段，在获取号段时使用如下SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> id_generator <span class="keyword">set</span> current_max_id=<span class="comment">#&#123;newMaxId&#125;, version=version+1 where version = #&#123;version&#125;Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>因为newMaxId是DistributIdService中根据oldMaxId+步长算出来的，只要上面的update更新成功了就表示号段获取成功了。</p><p>为了提供数据库层的高可用，需要对数据库使用多主模式进行部署，对于每个数据库来说要保证生成的号段不重复，这就需要利用最开始的思路，再在刚刚的数据库表中增加起始值和步长，比如如果现在是两台Mysql，那么 mysql1将生成号段（1,1001]，自增的时候序列为1，3，4，5，7…. mysql1将生成号段（2,1002]，自增的时候序列为2，4，6，8，10…</p><p>更详细的可以参考滴滴开源的TinyId：<a href="https://github.com/didi/tinyid/wiki/tinyid原理介绍" target="_blank" rel="noopener">github.com/didi/tinyid…</a></p><p>在TinyId中还增加了一步来提高效率，在上面的实现中，ID自增的逻辑是在DistributIdService中实现的，而实际上可以把自增的逻辑转移到业务应用本地，这样对于业务应用来说只需要获取号段，每次自增时不再需要请求调用DistributIdService了。</p><h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>上面的三种方法总的来说是基于自增思想的，而接下来就介绍比较著名的雪花算法-snowflake。</p><p>我们可以换个角度来对分布式ID进行思考，只要能让负责生成分布式ID的每台机器在每毫秒内生成不一样的ID就行了。</p><p>snowflake是twitter开源的分布式ID生成算法，是一种算法，所以它和上面的三种生成分布式ID机制不太一样，它不依赖数据库。</p><p>核心思想是：分布式ID固定是一个long型的数字，一个long型占8个字节，也就是64个bit，原始snowflake算法中对于bit的分配如下图：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.png" alt="雪花算法"></p><ul><li>第一个bit位是标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以固定为0。</li><li>时间戳部分占41bit，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li><li>工作机器id占10bit，这里比较灵活，比如，可以使用前5位作为数据中心机房标识，后5位作为单机房机器标识，可以部署1024个节点。</li><li>序列号部分占12bit，支持同一毫秒内同一个节点可以生成4096个ID</li></ul><p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p><p>snowflake算法实现起来并不难，提供一个github上用java实现的：<a href="https://github.com/beyondfengyu/SnowFlake" target="_blank" rel="noopener">github.com/beyondfengy…</a></p><p>在大厂里，其实并没有直接使用snowflake，而是进行了改造，因为snowflake算法中最难实践的就是工作机器id，原始的snowflake算法需要人工去为每台机器去指定一个机器id，并配置在某个地方从而让snowflake从此处获取机器id。</p><p>但是在大厂里，机器是很多的，人力成本太大且容易出错，所以大厂对snowflake进行了改造。</p><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><p>github地址：<a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener">uid-generator</a></p><p>uid-generator使用的就是snowflake，只是在生产机器id，也叫做workId时有所不同。</p><p>uid-generator中的workId是由uid-generator自动生成的，并且考虑到了应用部署在docker上的情况，在uid-generator中用户可以自己去定义workId的生成策略，默认提供的策略是：应用启动时由数据库分配。说的简单一点就是：应用在启动时会往数据库表(uid-generator需要新增一个WORKER_NODE表)中去插入一条数据，数据插入成功后返回的该数据对应的自增唯一id就是该机器的workId，而数据由host，port组成。</p><p>对于uid-generator中的workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，同一个应用每重启一次就会消费一个workId。</p><p>具体可参考<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">github.com/baidu/uid-g…</a></p><h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><p>github地址：<a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener">Leaf</a></p><p>美团的Leaf也是一个分布式ID生成框架。它非常全面，即支持号段模式，也支持snowflake模式。号段模式这里就不介绍了，和上面的分析类似。</p><p>Leaf中的snowflake模式和原始snowflake算法的不同点，也主要在workId的生成，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，在启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总得来说，上面两种都是自动生成workId，以让系统更加稳定以及减少人工成功。</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>这里额外再介绍一下使用Redis来生成分布式ID，其实和利用Mysql自增ID类似，可以利用Redis中的incr命令来实现原子性的自增与返回，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set seq_id 1     // 初始化自增ID为1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 3Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>使用redis的效率是非常高的，但是要考虑持久化的问题。Redis支持RDB和AOF两种持久化的方式。</p><p>RDB持久化相当于定时打一个快照进行持久化，如果打完快照后，连续自增了几次，还没来得及做下一次快照持久化，这个时候Redis挂掉了，重启Redis后会出现ID重复。</p><p>AOF持久化相当于对每条写命令进行持久化，如果Redis挂掉了，不会出现ID重复的现象，但是会由于incr命令过得，导致重启恢复数据时间过长。</p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单点登录</title>
      <link href="/2020/10/28/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2020/10/28/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/2020/10/28/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2020/10/28/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//集合中是否还有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得集合中的下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>Iterator</code> 对象称为迭代器（设计模式的一种），迭代器可以对集合进行遍历，但每一个集合内部的数据结构可能是不尽相同的，所以每一个集合存和取都很可能是不一样的，虽然我们可以人为地在每一个类中定义 <code>hasNext()</code> 和 <code>next()</code> 方法，但这样做会让整个集合体系过于臃肿。于是就有了迭代器。</p><p>迭代器是将这样的方法抽取出接口，然后在每个类的内部，定义自己迭代方式，这样做就规定了整个集合体系的遍历方式都是 <code>hasNext()</code>和<code>next()</code>方法，使用者不用管怎么实现的，会用即可。迭代器的定义为：提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。</p><h4 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h4><p><code>Iterator</code> 主要是用来遍历集合用的，它的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 <code>ConcurrentModificationException</code> 异常。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>我们通过使用迭代器来遍历 <code>HashMap</code>，演示一下 迭代器 Iterator 的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"Java"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"C++"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"PHP"</span>);</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">  System.out.println(entry.getKey() + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识大杂烩</title>
      <link href="/2020/10/25/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
      <url>/2020/10/25/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<p>作者：0XCAFEBABY<br>链接：<a href="https://www.nowcoder.com/discuss/438311" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/438311</a><br>来源：牛客网</p><p>1.JDK JRE<br>\2. Java异常了解吗？说说平时遇到的异常？说出6种常见的java异常。写程序遇到过哪些异常 运行时异常有哪些<br>\3. 面向对象 面对对象的几大特性 多态怎么理解<br>\4. 修饰符：public；protect；default；private优先级<br>\5. 对string类的理解。stringbuffer 和 stringbuilder<br>\6. 反射机制介绍一下<br>\7. bio，nio，aio分别介绍一下，nio的实现方式<br>\8. 问了public等变量定义修饰词的时间域<br>\9. 问了反射机制，还有问了动态代理的好处和坏处，好处答不上来<br>\10. 接口和抽象类的区别。<br>\11. 有一个public static final的HashMap，里边对象的属性能不能修改？<br>\12. 为什么java 平台无关性 机器码和字节码区别 JVM加载代码的一个流程<br>\13. java数据类型以及自己的应用 自动拆箱和自动装箱以及自己的应用即什么时候用到的，列举几种情况<br>\14. 什么是值传递和引用传递，区别及应用<br>\15. 重载和重写<br>\16. static方法是否能重写，接口和抽象类的区别<br>\17. 你觉得java是一种什么样的语言以及java特性<br>\18. lamda表达式了解吗？1.8新特性有什么？（面试宝典对接口抽象这个问题是错的，过时了）<br>\19. 内存泄露怎么造成的，怎么排查<br>\20. 讲讲final修饰符。<br>\21. 一个对象占多少内存。<br>\22. 最短路径问题<br>\23. java浅拷贝和深拷贝<br>\24. 内存泄露的原因和处理<br>\25. java反射机制，优点缺点<br>\26. 说说静态变量和非静态变量的区别，用类名调用静态变量和用实例对象调用静态变量有区别吗？非静态方法里可以有静态变量吗？<br>\27. static能不能被重写？<br> - 重写方法的目的是为了多态，或者说：重写是实现多态的前提，即重写是发生在继承中且是针对非static方法的。<br>语法上子类允许出现和父类只有方法体不一样其他都一模一样的static方法，但是在父类引用指向子类对象时，通过父类引用调用的依然是父类的static方法，而不是子类的static方法。<br>即：语法上static支持重写，但是运行效果上达不到多态目的<br>\28. 序列化，反序列化，什么时候用？ 如何对一个对象序列化</p><h2 id="Java集合类"><a href="#Java集合类" class="headerlink" title="Java集合类"></a>Java集合类</h2><ol><li>Hashmap底层（数组+<a href>链表</a>+<a href>红黑树</a>）hashmap为什么线程不安全，如何保证线程安全，就扯到concurrenthashmap hashmap底层实现 多线程会出现什么情况 扩容机制是什么为什么会死锁 如何解决碰撞 Jdk 1.8的优化。为什么使用<a href>红黑树</a>，它是如何做到效率优化的？ hashmap了解不，原理是什么，位图了解不，跳跃表了解不，<a href>红黑树</a>了解不，<a href>红黑树</a>插入过程，B+树了解不，B+树特点和插入过程，邻接表和邻接矩阵区别，分别在什么地方用到，<br> 插入和查询的流程。</li><li>concurrenthashmap1.7和1.8的区别；concurrenthashmap说说，它是如何保证线程安全的？jdk1.7的hashentry和segment锁。具体说说segment锁？能讲下ConcurrentHashMap的实现原理么 JDK7或者8都行</li><li>常用集合类 实现类 </li><li>list和set区别（重复/不重复）</li><li>set，list，map（线程安全的map，map怎么实现之类的）</li><li><a href>红黑树</a>介绍一下，跟<a href>平衡二叉树</a>比较一下，<a href>红黑树</a>有哪些应用场景</li><li>你常用的数据结构有哪些？</li><li><a href>红黑树</a>的特点，AVL树</li><li>一致性哈希函数以及hashmap的put方法</li><li>数组、二叉搜索树、B树、B+树</li><li>堆和栈。堆、栈</li><li><a href>二叉树</a>的最大节点个数；2^n-1;</li></ol><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><ol><li>java创建线程的方式，runnable和callable区别（参数不同）1. java线程的状态有哪些；线程的几种状态</li><li>wait和sleep的区别；wait和notify的使用场景；</li><li>介绍一下volatile以及原理；volatile介绍一下Volatile底层是如何实现的？ 说了内存可见性和内存屏障，Volatile是绝对线2程安全的吗？不是，没有保证原子性。volatile关键字在线程通信的问题</li><li>介绍一下synchornized以及原理； lock和synchornized的区别；synchronized锁的升级过程？Synchronized，底层是如何实现的？说了monitor对象头，以及两个monitorenter和monitorexit运用于代码块。<br>对象头是存储了哪些信息？说说synchronized的锁优化过程？说了偏向，自旋，轻量和重量。</li><li>介绍一下AQS;</li><li>说一下公平锁和非公平锁的原理；</li><li>cas操作是什么，以及可能出现的问题；</li><li>线程池，然后你再平时怎么用的，工作原理，有哪些重要参数，饱和策略有哪些；线程池了解吧，说说如何实现线程池？核心参数哪些？有哪些阻塞队列呢？如何优雅的关闭线程池 线程池（线程大小，阻塞队列）线程创建，线程池参数，说说你常用的线程池？说了new ***d 和newFixed。以及介绍各个参数</li><li>说说你理解的悲观锁和乐观锁？乐观锁有哪些？乐观锁有什么缺点？</li><li>阻塞队列 线程间通信方式 创建线程方式 创建线程池方式 线程池常用参数</li><li>锁有哪些</li><li>说说你常用的并发包JUI？</li><li>问了如何保证多线程通信</li><li>你用过Java的J.U.C并发包吧，给我讲一下AQS的原理</li><li>CAS的原理给我讲一下，他是怎么保证内存的可见性的。CAS会产生什么问题</li><li>知道Java中的内存模型吧，它有8个指令你给我说一下</li><li>多线程如何保持同步？</li><li>java可见性的关键字及其原理。</li><li>cpu密集型多线程和io密集型多线程的比较。cpu密集型里如何管理多线程？ 用什么样的线程池和阻塞队列？</li><li>cpu线程特别多会产生什么问题？io密集型里怎么减少需要的线程数？</li><li>io多路复用的原理和实现。怎么减少处理io（和磁盘io交互）所需要的线程？</li><li>线程实现方式。有什么区别。线程之间的通讯，进程之间的通讯。</li></ol><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol><li>JVM运行时内存区域划分？哪些线程私有？运行时数据区，私有共享都是哪些？堆区内存如何分配？</li><li>对象的生命周期？</li><li>JVM垃圾回收器，cms和g1的特点，两者的区别是什么，比g1更加先进的垃圾回收器有了解么，ZGC原理，能够管理多大的内存，CMS能管理多大的内存，G1呢</li><li>JVM内存模型 类的生命周期 类加载过程 双亲委派机制了解吗 进入老年代过程 什么情况下直接进入老年代</li><li>JVM内存分布（堆栈等，程序计数器+jvm栈+本地方法栈线程不共享，堆和方法区线程共享）</li><li>类加载机制，过程，类加载机制？如何自定义实现类加载器？双亲委派模型、类加载器类别，双亲委派模型本质是解决了什么问题？安全性，有哪几种类加载器？类加载的流程。知道哪些类加载器。类加载器之间的关系？双亲委派模型。为什么使用双亲委派模型？</li><li>垃圾回收<a href>算法</a>，常见的垃圾回收器及他们之间区别，垃圾回收发生在哪里，怎么判断对象存活、GC Roots具体有哪些、讲讲对象分配与回收，什么可以作为垃圾回收的对象，垃圾回收<a href>算法</a>和流程。</li><li>栈什么情况下会溢出？</li><li>静态变量存放在内存哪个区域？</li><li>怎么查看java虚拟机内存占用？</li><li>如何减少full gc的次数？方法区是否需要gc</li><li>4个引用类型 </li></ol><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol><li>输入一个url后的过程；浏览器从发送请求的全部过程</li><li>OSI七层和TCP四层协议，OSI七层模型/五层模型，每一层有哪些协议，http，tcp，ip位于哪一层</li><li>TCP三次握手四次分手，tcp四次挥手为什么要四次，为什么TCP是安全的，TCP，UDP的区别</li><li>TCP报文结构，HTTP结构， TCP，UDP，HTTP的报文格式（我懵了）</li><li>设计一个应用层协议（没有答出来</li><li>HTTP协议连接过程，HTTPS连接过程，HTTP的长连接是怎么做的HTTP2和HTTP1区别，HTTP请求过程<br>http的几种方法，HTTP跟HTTPS的区别，https加密过程</li></ol><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol><li>程序，进程和线程的区别</li><li>什么时候情况下要用多线程？</li><li>进程之间怎么通信的？</li><li>一个手机应用程序里面的进程和线程分别是怎么进行的？</li><li>死锁，怎么解死锁，死锁条件，怎么预防</li><li>进程的状态：阻塞+就绪+执行</li><li>手机内存8g，是32位的，一个进程能申请多少内存？</li><li>线程的应用，举例，线程的阻塞</li><li>主线程和子线程的区别</li></ol><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux :"></a>Linux :</h2><ol><li>linux中如何查看CPU负载 top</li><li>linux用过嘛（扯到了我训练过深度模型，小哥哥直接来了个场景题）<br>场景题：推荐<a href>算法</a>中如何控制广告推送频率（结合强化学习说了一些</li><li>Linux了解不，df dh区别，如何格式化磁盘，磁盘挂载过程，tcp丢包如何排查，docker是用什么实现的</li><li>怎么查找特定后缀名或前缀名的文件</li></ol><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ol><li>数据库引擎事务隔离级别，串行化如何实现，数据库的隔离级别？四个。你平常使用的是哪个隔离级别。数据库隔离级别以及分别解决了什么问题</li><li>MySQL的存储引擎有哪些？它们之间的区别？你用的mysql存储引擎？为什么选择它？实现原理？</li><li>怎么判断一个SQL语句有没有走索引？紧接着问explain知道哪些字段吗</li><li>mysql存储模型 区别 怎么看用没用索引 怎么判断sql语句好坏</li><li>数据库中索引B+树</li><li>一个手机应用要更改数据库，它的底层是怎么实现的？</li><li>sql查询过程</li><li>MySQL InnoDB存储引擎中的MVCC解决了什么问题，能说下MVCC的实现原理么</li><li>SQL语句经常写吧，那我给你出一道SQL题（分组求和<a href>排序</a>）</li><li>你认为什么情况下不应该建立索引</li><li>mysql有几种锁？怎么实现？</li><li>innodb事物的级别</li><li>b 树的结构？与<a href>二叉树</a>的区别？与b树的区别？</li><li>写过最复杂的sql， 手写代码： 统计各个科目考试最高分:最复杂的包括了sum、case、left join、group by，追问左连接和内联区别，没答上来</li><li>聚簇索引跟<a href>红黑树</a></li><li>sql :给一个日期范围，统计每天入库的数据总量</li><li>sql语句里like和in关键字</li><li>sql语句，求平均分超过60分的学生学号</li><li>数据库sql怎么优化 </li><li>什么情况不能用索引？</li><li>SELECT column_name(s)<br>FROM table_name<br>WHERE column_name<br>BETWEEN value1 AND value2 什么时候会发生死锁；怎么解决死锁；N个资源怎么办？</li></ol><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a><a href>redis</a></h2><ol><li>你知道<a href>redis</a>的什么东西</li><li><a href>redis</a>中zset，说了一下跳跃表的插入，删除过程；</li><li>位图知道原理嘛（操作系统中的位示图还是bitmap?不太了解）</li><li><a href>redis</a>数据类型，<a href>redis</a>的应用场景，为什么<a href>redis</a>快</li><li>Redis的key的写入和删除的原理</li><li>怎么保证Redis的高可用</li><li><a href>redis</a>数据结构？单线程还是多线程？</li><li>用什么样的队列？你是怎么实现？我回答的<a href>redis</a>的list实现的）这种队列有什么缺点？</li><li>分布式锁；</li></ol><h2 id="mq"><a href="#mq" class="headerlink" title="mq"></a>mq</h2><ol><li>你还用过rabbitMQ呀，它能够做什么？</li><li>rabbitMQ是怎么保证消息不丢的，从<a href>客户端</a>—消息队列， 消息队列—服务器端的角度考虑</li></ol><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><ol><li>开源框架有哪些了解的 为什么用spring 为什么不用new就可以自动生产 能不能自己实现一个</li><li>spring security是干嘛的，原理是啥，jwt干啥的</li><li>后台用什么框架？ioc，aop,其他还有什么框架也可以做到ioc,aop（2333～不就spring?）</li><li>Spring IOC,AOP,注解</li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol><li>双重检索单例</li><li>设计模式分为哪三类，各有什么？设计模式，用过哪些设计模式，讲几个，设计模式和原则</li><li>代理模式属于哪一类</li><li>生产者消费者模式,生产消费者的，以及多生产者同步</li><li>描述适配器，写单例</li><li>单例模式，装饰模式，</li></ol><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ol><li>负载均衡的<a href>算法</a>有哪些；</li><li>rpc dubbo的组件有哪些</li><li>分布式事务，CAP定理，有没有使用过相关的产品</li><li>zoo<a href>keep</a>er了解吗</li><li>hbase索引的结构，kafka存储的结构，二进制文件的组织方式，kafka如何避免消息丢失，zoo<a href>keep</a>er在kafka中是干啥的，kafka在zoo<a href>keep</a>er中存储的数据，zoo<a href>keep</a>er了解不，zoo<a href>keep</a>er的共识<a href>算法</a>，分区后如何解决。</li><li>protobuf了解不，grpc了解不，用的什么协议，HTTP2和HTTP1区别，websocket建立连接过程</li><li>RPC你了解过吗？</li><li>如何分布式存储？</li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><a href>算法</a></h2><ol><li><a href>排序</a><a href>算法</a>有哪些，简述冒泡和归并<a href>排序</a>，冒泡<a href>算法</a>的优化,讲讲归并<a href>排序</a>,冒泡的优化知道吗；回答相等不交换，还有flag做已<a href>排序</a>标志的优化；直接插入<a href>排序</a>，写一下伪代码或者说一下思路,插入<a href>排序</a>，时间复杂度</li><li>堆<a href>排序</a>原理</li><li>快排,快排是什么思想，快排的优化是啥，为啥这么做；</li><li>字母<a href>排序</a></li><li>100个数中找出想要的数</li><li>一个数组分成2个相等或接近的子数组</li><li>派单的最短路径问题</li><li>很大的数据，内存放不下，如何快速找到中间值</li><li>手撕栈</li><li><a href>链表</a>找环 <a href>链表</a>找环入口，不用双指针怎么做</li><li>双向<a href>链表</a>实现 ，写了个add()和add(index)的</li><li>求数组的全排列</li><li>中序遍历，递归非递归</li><li>求四个数绝对值的最小值</li><li>黑猫白猫，混在一起，如何把他们区分开？ 黑白灰三种猫混在一起，如何按照黑白灰排好序？ 还有两个小问题忘记了。</li><li>如何用一个int值，表示三种状态？</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>给你10个tomcat你如何判断自己用哪个（容器？emmmm，求指点）<br>位图知道原理嘛（操作系统中的位示图还是bitmap?不太了解）<br>所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此可以大大节省存储空间。<br>其实就是位示图为原型，01存储的，建议面试的时候知道多少说多少，知道什么说什么~</li><li>序列化相关</li><li>最后还是问<a href>项目</a>，<a href>项目</a>中的难点，是如何解决的？</li><li>c++编程搞过没，GPU编程了解不，用的什么GPU，GPU运算性能是什么决定的</li><li>如果某个用户同时请求创建活动接口100次，如果防止它被重复创建？创建前查看该记录是否存在、使用锁、如果是分布式的使用分布式锁—这样解决了99.99%的问题。除了使用这些方案，还能使用什么方法解决吗？</li><li>讲讲分布式锁的实现</li><li>io量很大，队列很长怎么办？</li><li>Q:觉得用过的模板解析引擎有什么不同的特征。<br>A:用过JSP和Thymeleaf，JSP我就说适合Java程序员做<a href>前端</a>，本质还是Servlet，生产环境下调试方便；Thymeleaf是SpringBoot<a href>项目</a>碰到的，本质是EL，语法特殊，但是前后端传值、传对象方便。</li><li>讲一下对jQUERY的使用感受<br>A：研一的<a href>项目</a>做过iOS开发，用OC做的webview APP，用到了jQuery Mobile做界面和事件控制，感觉很方便。 后面的Web<a href>项目</a>主要用来进行Ajax操作，选择器很方便。</li><li>硕士一个<a href>项目</a>涉及到跨系统集成，要我在纸上画出集成逻辑架构，介绍一下开发用到的技术和业务环境。<br> 集成用的WebService，引入Apache旗下的Axis， 涉及到文件传输和多数据源配置。。。。</li><li>用过eclipse、IDEA、Myeclipse，评价一下区别 代码提示、插件库、收费与免费、代码模板、资源消耗</li><li>用过EJB和SSH，评价一下区别</li><li>问了实习经历 了解分布式吗？</li><li>你怎么用的websocket?</li><li>想做安卓还是java后台？手机端安卓怎么开发的？</li><li>activity四大组件</li><li>介绍一下service</li><li>APP的启动流程</li><li>Android事件分发机制</li><li>view的测量方法；</li><li>Android之间线程通信</li><li>介绍一个你用心做的模块，<a href>项目</a>流程，怎么理解异步同步，什么场景用；<br>static能不能被重写？</li><li>MD5为啥要加盐(彩虹表·)；UUID有多少位(32位)</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis源码剖析</title>
      <link href="/2020/10/24/redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/10/24/redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><a href="https://juejin.im/post/6855129008091332615" target="_blank" rel="noopener">https://juejin.im/post/6855129008091332615</a></p><p>本文知识脑图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758550e143b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h2 id="一、Redis的数据模型"><a href="#一、Redis的数据模型" class="headerlink" title="一、Redis的数据模型"></a>一、Redis的数据模型</h2><p>用 键值对 <code>name：&quot;小明&quot;</code>来展示Redis的数据模型如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758534a337a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><ul><li><strong>dictEntry:</strong>   在一些编程语言中，键值对的数据结构被称为字典，而在Redis中，会给每一个key-value键值对分配一个字典实体，就是“dicEntry”。dicEntry包含三部分： <strong>key的指针、val的指针、next指针</strong>，next指针指向下一个dicteEntry形成链表，这个next指针可以将多个哈希值相同的键值对链接在一起，<strong>通过链地址法来解决哈希冲突的问题</strong></li><li><strong>sds</strong> ：<strong>Simple Dynamic String</strong>，简单动态字符串，存储字符串数据。</li><li><strong>redisObject</strong>：Redis的5种常用类型都是以RedisObject来存储的，redisObject中的<strong>type</strong>字段指明了值的数据类型（也就是5种基本类型)。<strong>ptr</strong>字段指向对象所在的地址。</li></ul><p>RedisObject对象很重要，Redis<strong>对象的类型</strong>、<strong>内部编码</strong>、<strong>内存回收</strong>、<strong>共享对象</strong>等功能，都是基于RedisObject对象来实现的。</p><p><strong>这样设计的好处是：可以针对不同的使用场景，对5种常用类型设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</strong></p><p>Redis将jemalloc作为默认内存分配器，减小内存碎片。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Redis 对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 类型</span><br><span class="line">    unsigned type:4;        </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 不使用(对齐位)</span><br><span class="line">    unsigned notused:2;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 编码方式</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; LRU 时间（相对于 server.lruclock）</span><br><span class="line">    unsigned lru:22;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 引用计数</span><br><span class="line">    int refcount;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 指向对象的值</span><br><span class="line">    void *ptr;</span><br><span class="line"> </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h2 id="二、Redis支持的数据结构"><a href="#二、Redis支持的数据结构" class="headerlink" title="二、Redis支持的数据结构"></a>二、Redis支持的数据结构</h2><p>Redis支持的数据结构有哪些？</p><p>如果回答是String、List、Hash、Set、Zset就不对了，这5种是redis的常用基本数据类型，每一种数据类型内部还包含着多种数据结构。</p><p>用encoding指令来看一个值的数据结构。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name tom</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此处设置了name值是tom，它的数据结构是embstr，下文介绍字符串时会详解说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding age</span><br><span class="line">&quot;int&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如下表格总结Redis中所有的数据结构类型：</p><table><thead><tr><th>底层数据结构</th><th>编码常量</th><th>object encoding指令输出</th></tr></thead><tbody><tr><td>整数类型</td><td>REDIS_ENCODING_INT</td><td>“int”</td></tr><tr><td>embstr字符串类型</td><td>REDIS_ENCODING_EMBSTR</td><td>“embstr”</td></tr><tr><td>简单动态字符串</td><td>REDIS_ENCODING_RAW</td><td>“raw”</td></tr><tr><td>字典类型</td><td>REDIS_ENCODING_HT</td><td>“hashtable”</td></tr><tr><td>双端链表</td><td>REDIS_ENCODING_LINKEDLIST</td><td>“linkedlist”</td></tr><tr><td>压缩列表</td><td>REDIS_ENCODING_ZIPLIST</td><td>“ziplist”</td></tr><tr><td>整数集合</td><td>REDIS_ENCODING_INTSET</td><td>“intset”</td></tr><tr><td>跳表和字典</td><td>REDIS_ENCODING_SKIPLIST</td><td>“skiplist”</td></tr></tbody></table><p><strong>补充说明</strong></p><blockquote><p>假如面试官问：redis的数据类型有哪些？</p><p>回答：String、list、hash、set、zet</p></blockquote><p>一般情况下这样回答是正确的，前文也提到redis的数据类型确实是包含这5种，但细心的同学肯定发现了之前说的是<strong>“常用”</strong>的5种数据类型。其实，随着Redis的不断更新和完善，Redis的数据类型早已不止5种了。</p><p>登录redis的官方网站打开官方的数据类型介绍：</p><p><a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">redis.io/topics/data…</a></p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b4475857ff2a94?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>发现Redis支持的数据结构不止5种，而是8种，后三种类型分别是：</p><ul><li>位数组（或简称位图）：使用特殊命令可以处理字符串值，如位数组：您可以设置和清除各个位，将所有位设置为1，查找第一个位或未设置位，等等。</li><li>HyperLogLogs：这是一个概率数据结构，用于估计集合的基数。不要害怕，它比看起来更简单。</li><li>Streams：仅附加的类似于地图的条目集合，提供抽象日志数据类型。</li></ul><p>本文主要介绍5种常用的数据类型，上述三种以后再共同探索。</p><h3 id="2-1-string字符串"><a href="#2-1-string字符串" class="headerlink" title="2.1 string字符串"></a>2.1 string字符串</h3><p>字符串类型是redis最常用的数据类型，在Redis中，字符串是可以修改的，在底层它是以字节数组的形式存在的。</p><p>Redis中的字符串被称为简单动态字符串「SDS」，这种结构很像Java中的ArrayList，其长度是动态可变的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SDS&lt;T&gt; &#123;</span><br><span class="line">  T capacity; &#x2F;&#x2F; 数组容量</span><br><span class="line">  T len; &#x2F;&#x2F; 数组长度</span><br><span class="line">  byte[] content; &#x2F;&#x2F; 数组内容</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b447584f4b52d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p><strong>content[]</strong> 存储的是字符串的内容，<strong>capacity</strong>表示数组分配的长度，<strong>len</strong>表示字符串的实际长度。</p><p>字符串的编码类型有int、embstr和raw三种，如上表所示，那么这三种编码类型有什么不同呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;    &#x2F;&#x2F;简单动态字符串(simple dynamic string, SDS)的抽象类型</span><br><span class="line">  &#x2F;&#x2F; 用于记录buf数组中使用的字节的数目</span><br><span class="line">  &#x2F;&#x2F; 和SDS存储的字符串的长度相等  </span><br><span class="line">int len;    </span><br><span class="line">  &#x2F;&#x2F; 用于记录buf数组中没有使用的字节的数目   </span><br><span class="line">int free;    </span><br><span class="line">  &#x2F;&#x2F; 字节数组，用于储存字符串</span><br><span class="line">char buf[];   &#x2F;&#x2F;buf的大小等于len+free+1，其中多余的1个字节是用来存储’\0’的。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>int 编码</strong>：保存的是可以用 long 类型表示的整数值。</li><li><strong>raw 编码</strong>：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li><li><strong>embstr 编码</strong>：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li></ul><p><img src="https://img2018.cnblogs.com/blog/1432634/201907/1432634-20190724185636136-1199490260.png" alt="img"></p><p>设置一个值测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set num 300</span><br><span class="line">127.0.0.1:6379&gt; object encoding num</span><br><span class="line">&quot;int&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key1 wealwaysbyhappyhahaha</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key2 hahahahahahahaahahahahahahahahahahahaha</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; strlen key2</span><br><span class="line">(integer) 39</span><br><span class="line">127.0.0.1:6379&gt; object encoding key2</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key2 hahahahahahahaahahahahahahahahahahahahahahaha</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key2</span><br><span class="line">&quot;raw&quot;</span><br><span class="line">127.0.0.1:6379&gt; strlen key2</span><br><span class="line">(integer) 45</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="raw类型和embstr类型对比"><a href="#raw类型和embstr类型对比" class="headerlink" title="raw类型和embstr类型对比"></a>raw类型和embstr类型对比</h4><p>embstr编码的结构:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b447584f3e35a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>raw编码的结构：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758547bc9c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="raw编码"></p><blockquote><p>embstr和raw都是由redisObject和sds组成的。不同的是：embstr的redisObject和sds是连续的，只需要使用<strong>malloc</strong>分配一次内存；而raw需要为redisObject和sds分别分配内存，即需要分配两次内存。</p><p>所有相比较而言，embstr少分配一次内存，更方便。但embstr也有明显的缺点：如要增加长度，redisObject和sds都需要重新分配内存。</p></blockquote><p>上文介绍了embstr和raw结构上的不同。重点来了~ <strong>为什么会选择44作为两种编码的分界点？在3.2版本之前为什么是39？这两个值是怎么得出来的呢？</strong></p><p><strong>1） 计算RedisObject占用的字节大小</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct RedisObject &#123;</span><br><span class="line">    int4 type; &#x2F;&#x2F; 4bits</span><br><span class="line">    int4 encoding; &#x2F;&#x2F; 4bits</span><br><span class="line">    int24 lru; &#x2F;&#x2F; 24bits</span><br><span class="line">    int32 refcount; &#x2F;&#x2F; 4bytes &#x3D; 32bits</span><br><span class="line">    void *ptr; &#x2F;&#x2F; 8bytes，64-bit system</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>type: 不同的redis对象会有不同的数据类型(string、list、hash等)，type记录类型，会用到<strong>4bits</strong>。</li><li>encoding：存储编码形式，用<strong>4bits</strong>。</li><li>lru：用<strong>24bits</strong>记录对象的LRU信息。</li><li>refcount：引用计数器，用到<strong>32bits</strong>。</li><li><em>ptr：指针指向对象的具体内容，需要*</em>64bits**。</li></ul><p>计算： 4 + 4 + 24 + 32 + 64 = 128bits = <strong>16bytes</strong></p><p>第一步就完成了，RedisObject对象头信息会占用<strong>16字节</strong>的大小，这个大小通常是固定不变的.</p><p><strong>2) sds占用字节大小计算</strong></p><p><strong>旧版本：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SDS &#123;</span><br><span class="line">    unsigned int capacity; &#x2F;&#x2F; 4byte</span><br><span class="line">    unsigned int len; &#x2F;&#x2F; 4byte</span><br><span class="line">    byte[] content; &#x2F;&#x2F; 内联数组，长度为 capacity</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里的<strong>unsigned int</strong> 一个4字节，加起来是8字节.</p><p>内存分配器jemalloc分配的内存如果超出了64个字节就认为是一个大字符串，就会用到raw编码。</p><p>前面提到 SDS 结构体中的 content 的字符串是以字节\0结尾的字符串，之所以多出这样一个字节，是为了便于直接使用 glibc 的字符串处理函数，以及为了便于字符串的调试打印输出。所以我们还要减去1字节 <strong>64byte  -  16byte   -  8byte  -  1byte  =  39byte</strong></p><p><strong>新版本：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct SDS &#123;</span><br><span class="line">    int8 capacity; &#x2F;&#x2F; 1byte</span><br><span class="line">    int8 len; &#x2F;&#x2F; 1byte</span><br><span class="line">    int8 flags; &#x2F;&#x2F; 1byte</span><br><span class="line">    byte[] content; &#x2F;&#x2F; 内联数组，长度为 capacity</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里unsigned int 变成了uint8_t、uint16_t.的形式，还加了一个char flags标识，总共只用了3个字节的大小。相当于优化了sds的内存使用，相应的用于存储字符串的内存就会变大。</p><p>然后进行计算：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b447586c898442?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p><strong>64byte - 16byte -3byte -1byte = 44byte</strong>。</p><p><strong>总结：</strong></p><p>所以，redis 3.2版本之后embstr最大能容纳的字符串长度是44，之前是39。长度变化的原因是SDS中内存的优化。</p><h3 id="2-2-List"><a href="#2-2-List" class="headerlink" title="2.2 List"></a>2.2 List</h3><p>Redis中List对象的底层是由quicklist(快速列表)实现的，快速列表支持从链表头和尾添加元素，并且可以获取指定位置的元素内容。</p><p>那么，快速列表的底层是如何实现的呢？为什么能够达到如此快的性能？</p><p>罗马不是一日建成的，quicklist也不是一日实现的，起初redis的list的底层是ziplist（压缩列表）或者是  linkedlist（双端列表）。先分别介绍这两种数据结构。</p><h4 id="ziplist-压缩列表"><a href="#ziplist-压缩列表" class="headerlink" title="ziplist 压缩列表"></a>ziplist 压缩列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个列表中只包含少量列表项，且是小整数值或长度比较短的字符串时，redis就使用ziplist（压缩列表）来做列表键的底层实现。压缩列表顾名思义是进行了压缩，每一个节点之间没有指针的指向，而是多个元素相邻，没有缝隙。</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush dotahero sf qop doom</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; object encoding dotahero</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此处使用老版本redis进行测试，向dota英雄列表中加入了qop痛苦女王、sf影魔、doom末日使者三个英雄，数据结构编码使用的是ziplist。</p><p><strong>所以 ziplist是Redis为了节约内存而开发的</strong>，是由一系列特殊编码的连续内存块组成的顺序型数据结构。具体结构相对比较复杂，大家有兴趣地话可以深入了解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct ziplist&lt;T&gt; &#123;</span><br><span class="line">    int32 zlbytes; &#x2F;&#x2F; 整个压缩列表占用字节数</span><br><span class="line">    int32 zltail_offset; &#x2F;&#x2F; 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点</span><br><span class="line">    int16 zllength; &#x2F;&#x2F; 元素个数</span><br><span class="line">    T[] entries; &#x2F;&#x2F; 元素内容列表，挨个挨个紧凑存储</span><br><span class="line">    int8 zlend; &#x2F;&#x2F; 标志压缩列表的结束，值恒为 0xFF</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b447587271beeb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h4 id="双端列表（linkedlist）"><a href="#双端列表（linkedlist）" class="headerlink" title="双端列表（linkedlist）"></a>双端列表（linkedlist）</h4><p>双端列表大家都很熟悉，这里的双端列表和java中的linkedlist很类似。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b4475875e8182a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>从图中可以看出Redis的linkedlist双端链表有以下特性：节点带有prev、next指针、head指针和tail指针，获取前置节点、后置节点、表头节点和表尾节点、获取长度的复杂度都是O(1)。</p><p><strong>压缩列表占用内存少，但是是顺序型的数据结构，插入删除元素的操作比较复杂，所以压缩列表适合数据比较小的情况，当数据比较多的时候，双端列表的高效插入删除还是更好的选择</strong></p><p>在Redis开发者的眼中，数据结构的选择，时间上、空间上都要达到极致，所以，他们将压缩列表和双端列表合二为一，创建了<strong>快速列表（quicklist）</strong>。和java中的hashmap一样，结合了数组和链表的优点。</p><h4 id="快速列表（quicklist）"><a href="#快速列表（quicklist）" class="headerlink" title="快速列表（quicklist）"></a>快速列表（quicklist）</h4><ul><li>rpush: listAddNodeHead —O(1)</li><li>lpush: listAddNodeTail —O(1)</li><li>push:listInsertNode —O(1)</li><li>index : listIndex —O(N)</li><li>pop:ListFirst/listLast —O(1)</li><li>llen:listLength —O(N)</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b4475876af391e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct ziplist &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">struct ziplist_compressed &#123;</span><br><span class="line">    int32 size;</span><br><span class="line">    byte[] compressed_data;</span><br><span class="line">&#125;</span><br><span class="line">struct quicklistNode &#123;</span><br><span class="line">    quicklistNode* prev;</span><br><span class="line">    quicklistNode* next;</span><br><span class="line">    ziplist* zl; &#x2F;&#x2F; 指向压缩列表</span><br><span class="line">    int32 size; &#x2F;&#x2F; ziplist 的字节总数</span><br><span class="line">    int16 count; &#x2F;&#x2F; ziplist 中的元素数量</span><br><span class="line">    int2 encoding; &#x2F;&#x2F; 存储形式 2bit，原生字节数组还是 LZF 压缩存储</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">struct quicklist &#123;</span><br><span class="line">    quicklistNode* head;</span><br><span class="line">    quicklistNode* tail;</span><br><span class="line">    long count; &#x2F;&#x2F; 元素总数</span><br><span class="line">    int nodes; &#x2F;&#x2F; ziplist 节点的个数</span><br><span class="line">    int compressDepth; &#x2F;&#x2F; LZF 算法压缩深度</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数list-compress-depth决定。为了支持快速的 push/pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p><h3 id="2-3-Hash"><a href="#2-3-Hash" class="headerlink" title="2.3 Hash"></a>2.3 Hash</h3><p>Hash数据类型的底层实现是ziplist（压缩列表）或字典（也称为hashtable或散列表）。这里压缩列表或者字典的选择，也是根据元素的数量大小决定的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758773ee9fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>如图hset了三个键值对，每个值的字节数不超过64的时候，默认使用的数据结构是<strong>ziplist</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b4475886a94f94?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>当我们加入了字节数超过64的值的数据时，默认的数据结构已经成为了hashtable。</p><p><strong>Hash对象只有同时满足下面两个条件时，才会使用ziplist（压缩列表）：</strong></p><ul><li>哈希中元素数量小于512个；</li><li>哈希中所有键值对的键和值字符串长度都小于64字节。</li></ul><p>压缩列表刚才已经了解了，hashtables类似于jdk1.7以前的hashmap。hashmap采用了链地址法的方法解决了哈希冲突的问题。想要深入了解的话可以参考之前写的一篇博客： <a href="https://blog.csdn.net/qq_32519415/article/details/87006982" target="_blank" rel="noopener">hashmap你真的了解吗</a></p><h4 id="Redis中的字典"><a href="#Redis中的字典" class="headerlink" title="Redis中的字典"></a>Redis中的字典</h4><p><strong>典</strong>， 又称符号表（symbol table）、关联数组（associative array）或者映射（map）， 是一种用于保存键值对（key-value pair）的抽象数据结构。在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。</p><p>字典中的每个键都是独一无二的， 程序可以在字典中根据键查找与之关联的值， 或者通过键来更新值， 又或者根据键来删除整个键值对， 等等。</p><h4 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h4><blockquote><p>Redis 的字典采用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。所以咱们依次来分析一下哈希表、哈希表节点、以及字典的结构。</p></blockquote><h4 id="1-哈希表结构"><a href="#1-哈希表结构" class="headerlink" title="1.哈希表结构"></a>1.哈希表结构</h4><p><strong>哈希表结构定义</strong> （dict.h/dictht）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表数组</span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表大小</span><br><span class="line">    unsigned long size;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表大小掩码，用于计算索引值</span><br><span class="line">    &#x2F;&#x2F; 总是等于 size - 1</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 该哈希表已有节点的数量</span><br><span class="line">    unsigned long used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>描述</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h&#x2F;dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</span><br><span class="line"></span><br><span class="line">size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</span><br><span class="line"></span><br><span class="line">sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>结构图解：一个空的哈希表</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6adabf00ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><h4 id="2-哈希表节点"><a href="#2-哈希表节点" class="headerlink" title="2.哈希表节点"></a>2.哈希表节点</h4><p>一个哈希表里面可以有多个哈希表节点，那么每个哈希表节点的结构以及多个哈希表节点之间的存储关系是怎么样的呢？</p><p><strong>哈希表节点结构定义</strong> （dictEntry）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 键</span><br><span class="line">    void *key;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 值</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指向下个哈希表节点，形成链表</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>描述</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， </span><br><span class="line">或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</span><br><span class="line"></span><br><span class="line">next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以此来解决键冲突（collision）的问题。</p><p>结构图解：多个哈希值相同的键值对存储结构，解决键冲突</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6adb3ebce3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><h4 id="3-字典结构实现"><a href="#3-字典结构实现" class="headerlink" title="3.字典结构实现"></a>3.字典结构实现</h4><p><strong>字典结构定义</strong> （dict.h/dict）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 类型特定函数</span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; rehash 索引</span><br><span class="line">    &#x2F;&#x2F; 当 rehash 不在进行时，值为 -1</span><br><span class="line">    int rehashidx; &#x2F;* rehashing not in progress if rehashidx &#x3D;&#x3D; -1 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>描述</strong>：type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数，</span><br><span class="line">Redis 会为用途不同的字典设置不同的类型特定函数。</span><br><span class="line"></span><br><span class="line">privdata 属性则保存了需要传给那些类型特定函数的可选参数。</span><br><span class="line">复制代码</span><br><span class="line">typedef struct dictType &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 计算哈希值的函数</span><br><span class="line">    unsigned int (*hashFunction)(const void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 复制键的函数</span><br><span class="line">    void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 复制值的函数</span><br><span class="line">    void *(*valDup)(void *privdata, const void *obj);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对比键的函数</span><br><span class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁键的函数</span><br><span class="line">    void (*keyDestructor)(void *privdata, void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁值的函数</span><br><span class="line">    void (*valDestructor)(void *privdata, void *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p><p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p><p>结构图解：普通状态下（没有进行 rehash）的字典</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6adba856b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><h4 id="哈希表分析"><a href="#哈希表分析" class="headerlink" title="哈希表分析"></a>哈希表分析</h4><h4 id="1-哈希算法"><a href="#1-哈希算法" class="headerlink" title="1.哈希算法"></a>1.哈希算法</h4><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><p>Redis 计算哈希值和索引值的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash &#x3D; dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class="line">index &#x3D; hash &amp; dict-&gt;ht[x].sizemask;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如图 4-4：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6adc63be56?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><p>举个例子， 对于图 4-4 所示的字典来说， 如果我们要将一个键值对 k0 和 v0 添加到字典里面， 那么程序会先使用语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash &#x3D; dict-&gt;type-&gt;hashFunction(k0);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>计算键 k0 的哈希值。</p><p>假设计算得出的哈希值为 8 ， 那么程序会继续使用语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index &#x3D; hash &amp; dict-&gt;ht[0].sizemask &#x3D; 8 &amp; 3 &#x3D; 0;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>计算出键 k0 的索引值 0 ， 这表示包含键值对 k0 和 v0 的节点应该被放置到哈希表数组的索引 0 位置上， 结构图解：图 4-5</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6ae014913d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><h4 id="2-键冲突解决"><a href="#2-键冲突解决" class="headerlink" title="2.键冲突解决"></a>2.键冲突解决</h4><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p><p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p><p>举个例子， 假设程序要将键值对 k2 和 v2 添加到图 4-6 所示的哈希表里面， 并且计算得出 k2 的索引值为 2 ， 那么键 k1 和 k2 将产生冲突， 而解决冲突的办法就是使用 next 指针将键 k2 和 k1 所在的节点连接起来。 结构图解：图 4-7</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6ae08fb489?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6b451b7570?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><p>因为 dictEntry 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面。</p><h4 id="3-rehash"><a href="#3-rehash" class="headerlink" title="3.rehash"></a>3.rehash</h4><p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大<br>的负担。<br>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次<br>rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1]<br>上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。<br>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。<br>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执<br>行。</p><h2 id="四、要点总结"><a href="#四、要点总结" class="headerlink" title="四、要点总结"></a>四、要点总结</h2><blockquote><p>1.字典 ht 属性是包含两个哈希表项的数组，一般情况下， 字典只使用 ht[0]， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash (下节分析) 时使用</p></blockquote><p>作者：程序员油七<br>链接：<a href="https://juejin.im/post/6855129008087793678" target="_blank" rel="noopener">https://juejin.im/post/6855129008087793678</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>redis中的dict 结构内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的。但是在 dict 扩容缩容时，需要分配新的 hashtable，然后进行渐进式搬迁，这时两个 hashtable 存储的分别是旧的 hashtable 和新的 hashtable。待搬迁结束后，旧的 hashtable 被删除，新的 hashtable 取而代之。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758921c661d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h3 id="2-4-Set"><a href="#2-4-Set" class="headerlink" title="2.4 Set"></a>2.4 Set</h3><p>Set数据类型的底层可以是<strong>intset</strong>(整数集)或者是<strong>hashtable</strong>(散列表也叫哈希表)。</p><p>当数据都是整数并且数量不多时，使用intset作为底层数据结构；当有除整数以外的数据或者数据量增多时，使用hashtable作为底层数据结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset 111 222 333</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; object encoding myset</span><br><span class="line">&quot;intset&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd myset hahaha</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding myset</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>inset的数据结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    &#x2F;&#x2F; 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    &#x2F;&#x2F; 集合包含的元素数量</span><br><span class="line">    uint32_t length;</span><br><span class="line">    &#x2F;&#x2F; 保存元素的数组</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>intset底层实现为有序、无重复数的数组。 intset的整数类型可以是16位的、32位的、64位的。如果数组里所有的整数都是16位长度的，新加入一个32位的整数，那么整个16的数组将升级成一个32位的数组。升级可以提升intset的灵活性，又可以节约内存，但不可逆。</p></blockquote><h3 id="2-5-Zset"><a href="#2-5-Zset" class="headerlink" title="2.5 Zset"></a>2.5 Zset</h3><p>Redis中的Zset，也叫做<strong>有序集合</strong>。它的底层是ziplist（压缩列表）或 <strong>skiplist</strong>（跳跃表）。</p><p>压缩列表前文已经介绍过了，同理是在元素数量比较少的时候使用。此处主要介绍跳跃列表。</p><hr><p>  跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>  跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p>  在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p><p>  Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>  和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。</p><hr><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>跳跃表（skiplist）是一种<strong>有序数据链表结构</strong>， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。查询平均性能为O(logN)，最坏的情况会出现O(N)情况，而redis中的zset在数据较多的时候底层就是采用跳跃表去实现的，元素较少的时候会进行小对象压缩采用压缩列表实现。</p><p><img src="https://img-blog.csdnimg.cn/20200413141708514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9mZW5nMTAzMzAxMTE=,size_16,color_FFFFFF,t_70" alt="img"></p><p>从上述图我们可以看出跳跃表有以下几个特点：</p><ul><li><p>跳跃表的每个节点都有多层构成。</p></li><li><p>跳跃表存在一个头结点，该头结点有64层结构，每层都包含指向下个节点的指针，指向本层下个节点中间所跨越的节点个数为跨度（span）。</p></li><li><p>除头结点以外，层高最高的节点为该跳跃表的level，图中的跳跃表level为3。</p></li><li><p>每层都是一个有序链表。</p></li><li><p>最底层的有序链表包含所有的节点数，也即是整个跳跃表的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    robj *obj;  &#x2F;*成员对象*&#x2F;</span><br><span class="line">    double score;   &#x2F;*分值*&#x2F;</span><br><span class="line">    struct zskiplistNode *backward; &#x2F;*后退指针*&#x2F;</span><br><span class="line">    struct zskiplistLevel &#123; &#x2F;*层*&#x2F;</span><br><span class="line">        struct zskiplistNode *forward;  &#x2F;*前进指针*&#x2F;</span><br><span class="line">        unsigned int span;  &#x2F;*跨度*&#x2F;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    struct zskiplistNode *header, *tail;    &#x2F;&#x2F;header指向跳跃表的表头节点，tail指向跳跃表的表尾节点</span><br><span class="line">    unsigned long length;   &#x2F;&#x2F;记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</span><br><span class="line">    int level;  &#x2F;&#x2F;记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>跳跃表<strong><em>\</em>每个节点都维护了多个指向其他节点的指针\</strong>，*<em>所以在进行查询、更新、删除等操作的时候不需要进行整条链表的遍历*</em>，*<em>可以通过维护的指针过滤掉中间的很多节点，从而达到很快速的访问效果***</em>，一般情况来说跳跃表的性能能与平衡树相媲美的，而且跳跃表实现较为简单，所以这也是<strong><em>\</em>redis为什么采用跳跃表来作为zset底层的数据结构实现**</strong>。</p><p><strong>查找过程</strong></p><p>跳跃表的查询，跳跃表有多层的情况下查询复杂度为O(logN)，如果跳跃表就一层那么查询复杂度会上升为O(N)，接下来我们就用图1的实例来模拟下查询score为70的节点的具体查询过程。</p><p><img src="https://img-blog.csdnimg.cn/20200413191759762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9mZW5nMTAzMzAxMTE=,size_16,color_FFFFFF,t_70" alt="img"></p><p>如图所示我们需要找到score为70的节点，查找首先从header开始，因为level为3我们先从L2开始往后开始遍历，查找到第一个节点，发现score比70小，继续往后遍历查找到第五个节点，发现score比70大，于是从当前节点往下一层进行查找，查找到节点3，以此类推，最终查询到score为70的节点。</p><p><strong>插入以及更新过程</strong><br>插入过程：跳跃表插入节点的时候，首先需要通过score找到自己的位置，也就是需要先走一步查找过程，找到新节点所处的位置的时候就创建一个新节点，并对新节点分配一个层数（这里层数的分配redis采用的是random随机机制，分配层数从1开始，每次晋升为上一层的概率为0.25），层数分配完了之后将前后指针进行赋值将新节点与旧节点串起来，<strong><em>\</em>如果层数大于当前的level还需要进行level的更新操作。**</strong></p><p>更新过程：更新过程会稍微复杂一些，更新其实就是插入，只不过插入的时候发现value已经存在了，只是<strong>需要调整一下score值</strong>，如果更新的score值不会带来位置上的改变，那么直接更新score就行不需要进行调整位置，但是如果新score会导致排序改变，那么就需要调整位置了，redis采用的方式比较直接就是先删除这个元素然后再插入这个元素即可，前后需要两次路径搜索</p><p>  Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。</p><p><img src="https://img-blog.csdn.net/20160412161658898" alt="一个跳跃表"></p><p>  上图展示了一个跳跃表示例，位于图片最左边的是zskiplist结构，该结构包含以下属性：</p><ul><li>header：指向跳跃表的表头节点</li><li>tail：指向跳跃表的表尾节点</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li><li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</li></ul><p>  位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：</p><ul><li>层(level)：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，依次类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li><li>后退(backward)指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>分值(score)：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>成员对象(obj)：各个节点中的o1、o2和o3是节点所保存的成员对象。</li></ul><p>  注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#### **跳跃表节点**</span><br><span class="line"></span><br><span class="line">  跳跃表节点的实现由redis.h&#x2F;zskiplistNode结构定义：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;c</span><br><span class="line">&#x2F;* ZSETs use a specialized version of Skiplists *&#x2F;</span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    robj *obj;  &#x2F;*成员对象*&#x2F;</span><br><span class="line">    double score;   &#x2F;*分值*&#x2F;</span><br><span class="line">    struct zskiplistNode *backward; &#x2F;*后退指针*&#x2F;</span><br><span class="line">    struct zskiplistLevel &#123; &#x2F;*层*&#x2F;</span><br><span class="line">        struct zskiplistNode *forward;  &#x2F;*前进指针*&#x2F;</span><br><span class="line">        unsigned int span;  &#x2F;*跨度*&#x2F;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;12345678910</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>  1、分值和成员</p><p>  节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。</p><p>  节点的成员对象(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。</p><p>  在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分至相同的节点将按照成员对象在字典中的大小来进行排序，成员对象较小的节点会排在前面(靠近表头的方向)，而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p><p>  举个例子，在下图中所示的跳跃表中，三个跳跃表节点都保存了相同的分值10086.0，但保存成员对象o1的节点却排在保存成员对象o2和o3的节点的前面，而保存成员对象o2的节点又排在保存成员对象o3的节点之前，由此可见，o1、o2、o3三个成员对象在字典中的排序为o1&lt;=o2&lt;=o3。</p><p><img src="https://img-blog.csdn.net/20160412174412181" alt="三个带有相同分值的跳跃表节点"></p><p>  2、后退指针</p><p>  节点的后退指针(backward属性)用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p><p>  下图用虚线展示了如何从表尾向表头遍历跳跃表中的所有节点：程序首先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点，之后再沿着后退指针访问倒数第三个节点，再之后遇到指向NULL的后退指针，于是访问结束。</p><p><img src="https://img-blog.csdn.net/20160412194049758" alt="从表尾向表头方向遍历跳跃表"></p><p>  3、层</p><p>  跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。</p><p>  每次创建一个新跳跃表节点的时候，程序根据幂次定律(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。</p><p>  下图分别展示了三个高度为1层、3层和5层的节点，因为C语言的数组索引总是从0开始的，所以节点的第一层是level[0]，而第二层是level[1]，依次类推。</p><p><img src="https://img-blog.csdn.net/20160412195202083" alt="带有不同层高的节点"></p><p>  4、前进指针</p><p>  每个层都有一个指向表尾方向的前进指针(level[i].forward属性)，用于从表头向表尾方向访问节点。下图用虚线表示出了程序从表头向表尾方向，遍历跳跃表中所有节点的路径：</p><p><img src="https://img-blog.csdn.net/20160412195458493" alt="遍历整个跳跃表"></p><p>  1) 迭代程序首先访问跳跃表的第一个节点(表头)，然后从第四层的前进指针移动到表中的第二个节点。<br>  2) 在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。<br>  3) 在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。<br>  4) 当程序再次沿着第四个节点的前进指针移动时，它碰到一个NULL，程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历。</p><p>  5、跨度</p><p>  层的跨度(level[i].span属性)用于记录两个节点之间的距离：</p><ul><li>两个节点之间的跨度越大，它们相距得就越远。</li><li>指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。</li></ul><p>  初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样的，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p>  举个例子，下图用虚线标记了在跳跃表中查找分值为3.0、成员对象为o3的节点时，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为3，所以目标节点在跳跃表中的排位为3。</p><p><img src="https://img-blog.csdn.net/20160412201553302" alt="计算节点的排位"></p><p>  再举个例子，下图用虚线标记了在跳跃表中查找分值为2.0、成员对象为o2的节点时，沿途经历的层：在查找节点的过程中，程序经过了两个跨度为1的节点，因此可以计算出，目标节点在跳跃表中的排位为2。</p><p><img src="https://img-blog.csdn.net/20160412201857509" alt="另一个计算节点排位的例子"></p><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a><strong>跳跃表</strong></h4><p>  仅靠多个跳跃表节点就可以组成一个跳跃表，如下图所示：</p><p><img src="https://img-blog.csdn.net/20160412202104618" alt="多个跳跃节点组成的跳跃表"></p><p>  但通过使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量(也即是跳跃表的长度)等信息，如下图所示：</p><p><img src="https://img-blog.csdn.net/20160412202419032" alt="带有zskiplist结构的跳跃表"></p><p>  zskiplist结构的定义如下：</p><p>​<code>ctypedef struct zskiplist {    struct zskiplistNode *header, *tail;    //header指向跳跃表的表头节点，tail指向跳跃表的表尾节点    unsigned long length;   //记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)    int level;  //记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)} zskiplist;12345​</code></p><p>  这样获取表头、表尾节点，表长，以及表中最高层数的复杂度均为O(1)。</p><p>```</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文大概介绍了Redis的5种常用数据类型的底层实现，希望大家结合源码和资料更深入地了解。</p><p>数据结构之美在Redis中体现得淋漓尽致，从String到压缩列表、快速列表、散列表、跳表，这些数据结构都适用在了不同的地方，各司其职。</p><p>不仅如此，Redis将这些数据结构加以升级、结合，将内存存储的效率性能达到了极致，正因为如此，Redis才能成为众多互联网公司不可缺少的高性能、秒级的key-value内存数据库。</p><p>作者：宜信技术学院<br>链接：<a href="https://juejin.im/post/6844903863145742350" target="_blank" rel="noopener">https://juejin.im/post/6844903863145742350</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2020/10/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1. 01背包问题"></a>1. 01背包问题</h2><p>有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。</p><p>第 ii 件物品的体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 读入数据的代码</span><br><span class="line">        Scanner reader &#x3D; new Scanner(System.in);</span><br><span class="line">        &#x2F;&#x2F; 物品的数量为N</span><br><span class="line">        int N &#x3D; reader.nextInt();</span><br><span class="line">        &#x2F;&#x2F; 背包的容量为V</span><br><span class="line">        int V &#x3D; reader.nextInt();</span><br><span class="line">        &#x2F;&#x2F; 一个长度为N的数组，第i个元素表示第i个物品的体积；</span><br><span class="line">        int[] v &#x3D; new int[N + 1] ;</span><br><span class="line">        &#x2F;&#x2F; 一个长度为N的数组，第i个元素表示第i个物品的价值；</span><br><span class="line">        int[] w &#x3D; new int[N + 1] ;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;1 ; i &lt;&#x3D; N ; i++)&#123;</span><br><span class="line">            &#x2F;&#x2F; 接下来有 N 行，每行有两个整数:v[i],w[i]，用空格隔开，分别表示第i件物品的体积和价值</span><br><span class="line">            v[i] &#x3D; reader.nextInt();</span><br><span class="line">            w[i] &#x3D; reader.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close() ;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 正式工作的代码</span><br><span class="line">        &#x2F;*</span><br><span class="line">        定义一个二阶矩阵dp[N+1][V+1],</span><br><span class="line">        这里之所以要N+1和V+1，是因为第0行表示只能选择第0个物品的时候，即没有物品的时候</span><br><span class="line">        第0列表示背包的体积为0的时候，即不能装任何东西的时候</span><br><span class="line"></span><br><span class="line">        dp[i][j]表示在 只能选择前i个物品，背包容量为j的情况下，背包中物品的最大价值</span><br><span class="line">        对于dp[i][j]有两种情况：</span><br><span class="line">        1. 不选择当前的第i件物品&#x2F;第i件物品比背包容量要大，则dp[i][j] &#x3D; dp[i-1][j]</span><br><span class="line">        2. 选择当前的第i件物品（潜在要求第i件物品体积小于等于背包总容量），则能装入的物品最大价值为：</span><br><span class="line">            当前物品的价值 加上 背包剩余容量在只能选前i-1件物品的情况下的最大价值</span><br><span class="line">            dp[i][j] &#x3D; dp[i-1][j-v[i]] + w[i]</span><br><span class="line">        dp[i][j]在两种情况中选择比较大的情况作为当前的最优解；</span><br><span class="line">        即：</span><br><span class="line">        if(j &gt;&#x3D; v[i]):</span><br><span class="line">            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])</span><br><span class="line">        else:</span><br><span class="line">            dp[i][j] &#x3D; dp[i-1][j]</span><br><span class="line">        *&#x2F;</span><br><span class="line">        int[][] dp &#x3D; new int[N+1][V+1];</span><br><span class="line">        dp[0][0] &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt;&#x3D; V; j++)&#123;</span><br><span class="line">                if(j &gt;&#x3D; v[i])&#123;</span><br><span class="line">                    dp[i][j] &#x3D; Math.max(dp[i-1][j], dp[i-1][j-v[i]] + w[i]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[N][V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后代码</p><pre><code>import java.util.Scanner;public class Main{    public static void main(String[] args) throws Exception {        // 读入数据的代码        Scanner reader = new Scanner(System.in);        // 物品的数量为N        int N = reader.nextInt();        // 背包的容量为V        int V = reader.nextInt();        // 一个长度为N的数组，第i个元素表示第i个物品的体积；        int[] v = new int[N + 1] ;        // 一个长度为N的数组，第i个元素表示第i个物品的价值；        int[] w = new int[N + 1] ;        for (int i=1 ; i &lt;= N ; i++){            // 接下来有 N 行，每行有两个整数:v[i],w[i]，用空格隔开，分别表示第i件物品的体积和价值            v[i] = reader.nextInt();            w[i] = reader.nextInt();        }    reader.close() ;    // 正式算法的代码    // 将dp优化为一维数组    /*    注意，这里第二层循环的时候，还是小到大循环的话，那么    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])    实际上变成了    dp[i][j] = Math.max(dp[i][j], dp[i][j-v[i]] + w[i]);    因为i-1的值已经在前面被更新过了，覆盖了    为了避免这个问题，所以要逆序更新，即先更新第i个，然后更新第i-1个，从而保证第i-1个不被覆盖    如果不逆序的话，输出结果为10，dp数组实际为：    0 0 0 0 0 0     0 2 4 6 8 10    0 2 4 6 8 10    0 2 4 6 8 10    0 2 4 6 8 10    */    int[] dp = new int[V+1];    dp[0] = 0;    for(int i = 1; i &lt;= N; i++){        for(int j = V; j &gt;= v[i]; j--){            dp[j] = Math.max(dp[j], dp[j-v[i]] + w[i]);        }        // for(int j = 0; j &lt;= V; j++){        //     System.out.print(dp[j]);        //     System.out.print(&quot; &quot;);        // }        // System.out.print(&quot;\n&quot;);    }    System.out.println(dp[V]); }}</code></pre><h2 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2.完全背包问题"></a>2.完全背包问题</h2><p>有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。</p><p>第 ii 种物品的体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 1010;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int dp[N][N], v[N], w[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</span><br><span class="line">        for(int j &#x3D; 0; j &lt;&#x3D; m; j ++ )</span><br><span class="line">            for(int k &#x3D; 0; k * v[i] &lt;&#x3D; j; k ++ )</span><br><span class="line">                dp[i][j] &#x3D; max(dp[i][j], dp[i - 1][j - k * v[i]] + k * w[i]);</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇总版</title>
      <link href="/2020/10/15/%E6%B1%87%E6%80%BB%E7%89%88/"/>
      <url>/2020/10/15/%E6%B1%87%E6%80%BB%E7%89%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>笔试题整理</title>
      <link href="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-王大锤"><a href="#1-王大锤" class="headerlink" title="1.王大锤"></a>1.王大锤</h2><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002172244791.png" alt="image-20201002172244791"></p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002172300325.png" alt="image-20201002172300325"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这题就暴力扫一遍就可以了，碰到3个连续的或者AABB删掉那个字符即可。。。</span><br><span class="line">&#x2F;&#x2F;当时没做出来。。。菜是原罪！</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        while(sc.hasNext())&#123;</span><br><span class="line">            int n &#x3D; Integer.parseInt(sc.nextLine());</span><br><span class="line">            for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">                StringBuilder sb &#x3D; new StringBuilder(sc.nextLine());</span><br><span class="line">                for(int j &#x3D; 2; j &lt; sb.length(); j++)&#123;</span><br><span class="line">                    if(sb.charAt(j) &#x3D;&#x3D; sb.charAt(j - 1) </span><br><span class="line">                       &amp;&amp; sb.charAt(j - 1) &#x3D;&#x3D; sb.charAt(j - 2))&#123;</span><br><span class="line">                        sb.deleteCharAt(j);</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if(isPattern(sb, j - 3, j))&#123;</span><br><span class="line">                        sb.deleteCharAt(j);</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean isPattern(StringBuilder sb, int i, int j)&#123;</span><br><span class="line">        if(i &lt; 0) return false;</span><br><span class="line">        return sb.charAt(i) &#x3D;&#x3D; sb.charAt(i + 1) &amp;&amp;</span><br><span class="line">                sb.charAt(j - 1) &#x3D;&#x3D; sb.charAt(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-雀魂"><a href="#2-雀魂" class="headerlink" title="2.雀魂"></a>2.雀魂<img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002220653472.png" alt="image-20201002220653472"></h2><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002220728137.png" alt="image-20201002220728137"></p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002220743070.png" alt="image-20201002220743070"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 回溯法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static int[] arr &#x3D; new int[13];</span><br><span class="line">    private static int[] count;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        count &#x3D; new int[9];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; scanner.nextInt();</span><br><span class="line">            ++count[arr[i]-1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int winCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 选择1到9中的一个作为第14张牌，然后判断是否胡牌</span><br><span class="line">        for (int i &#x3D; 1 ; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            if(count[i-1]&lt;4)&#123;</span><br><span class="line">                ++count[i-1];</span><br><span class="line">                if(win())&#123;</span><br><span class="line">                    ++winCount;</span><br><span class="line">                    System.out.print(i);</span><br><span class="line">                    System.out.print(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                --count[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(winCount&#x3D;&#x3D;0)&#123;</span><br><span class="line">            System.out.println(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean win()&#123;</span><br><span class="line">        &#x2F;&#x2F; 从1到9 中选择一个作为雀头, 然后判断剩余的牌是否构成4对</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            if(count[i-1]&lt;2)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            count[i-1]-&#x3D;2;</span><br><span class="line">            if(hasTriples(4))&#123;</span><br><span class="line">                count[i-1]+&#x3D;2;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            count[i-1]+&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean hasTriples(int n)&#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 1到9，每一张牌尝试三张或顺子</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            if(count[i-1]&gt;&#x3D;3)&#123;</span><br><span class="line">                count[i-1]-&#x3D;3;</span><br><span class="line">                boolean subHashTriples &#x3D; hasTriples(n-1);</span><br><span class="line">                count[i-1]+&#x3D;3;</span><br><span class="line">                if(subHashTriples)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i&lt;&#x3D;7  &amp;&amp; count[i-1]&gt;0 &amp;&amp; count[i] &gt; 0 &amp;&amp; count[i+1]&gt;0)&#123;</span><br><span class="line">                --count[i-1];</span><br><span class="line">                --count[i];</span><br><span class="line">                --count[i+1];</span><br><span class="line">                boolean subHasTriples &#x3D; hasTriples(n-1);</span><br><span class="line"></span><br><span class="line">                ++count[i-1];</span><br><span class="line">                ++count[i];</span><br><span class="line">                ++count[i+1];</span><br><span class="line">                if(subHasTriples)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.特工</p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002221037230.png" alt="image-20201002221037230"></p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002221054430.png" alt="image-20201002221054430"></p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002221105589.png" alt="image-20201002221105589"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    private int mod &#x3D; 99997867;</span><br><span class="line"></span><br><span class="line">    private void sln() &#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        int N &#x3D; sc.nextInt(), D &#x3D; sc.nextInt();</span><br><span class="line">        long cnt &#x3D; 0;</span><br><span class="line">        if (N &lt;&#x3D; 2) &#123;</span><br><span class="line">            System.out.println(-1);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] locs &#x3D; new int[N];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">            locs[i] &#x3D; sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">        int left &#x3D; 0, right &#x3D; 2;</span><br><span class="line">        while (right &lt; N) &#123;</span><br><span class="line">            if (locs[right] - locs[left] &gt; D) left++;</span><br><span class="line">            else if (right - left &lt; 2) right++;</span><br><span class="line">            else &#123;</span><br><span class="line">                cnt +&#x3D; calC(right - left);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt %&#x3D; mod;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long calC(long num) &#123;</span><br><span class="line">        return num * (num - 1) &#x2F; 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Main().sln();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3。迷宫"><a href="#3。迷宫" class="headerlink" title="3。迷宫"></a>3。迷宫</h2><p>由于新冠肺炎疫情的爆发，小明养在宿舍的小昆虫已经很久很久都没有人管了。小昆虫已经饿的不行了，必须出来找东西吃，可是出来之后需要走出一个迷宫。小昆虫每次可以朝上、下、左、右四个方向之一走一步，且只要走出任意一条边界线即可逃出迷宫。这只小昆虫曾感染过X星的一种奇异病毒，目前还没有发现任何副作用，但是却拥有了一项特异功能——破坏障碍物。<br>假设小昆虫在一个N<em>M的迷宫中，”@”代表小昆虫的初始位置，”.”代表可以通过的空地，”</em>“代表可以破坏的障碍物，”#”代表不可破坏的障碍物。请问小昆虫最少需要使用多少次特异功能才可以逃出迷宫？</p><p>输入描述<br>多组数据，第1行有1个正整数T，表示有T组数据。（T&lt;=100）<br>对于每组数据，第1行有两个整数N和M。(1&lt;=N, M&lt;=1000)<br>接着N行，每行有一个长度为M的字符串，表示N*M的迷宫。<br>输出描述<br>输出一个整数，表示使用特异功能的最少次数。如果小昆虫不能走出迷宫，则输出-1。</p><p>样例输入<br>3<br>3 3<br>###<br>#@*</p><p>3 4<br>####<br>#@.*<br><em>*.</em><br>3 3<br>.#.<br>#@#<br>.#.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.util.PriorityQueue;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class D2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        String st &#x3D; sc.nextLine();</span><br><span class="line">       int t &#x3D; Integer.parseInt(st);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; t; i++) &#123;</span><br><span class="line">            String str &#x3D; sc.nextLine();</span><br><span class="line">            String[] strs &#x3D; str.split(&quot; &quot;);</span><br><span class="line">            int n &#x3D;Integer.parseInt(strs[0]);    &#x2F;&#x2F;行数</span><br><span class="line">            int m &#x3D;Integer.parseInt(strs[1]);    &#x2F;&#x2F;列数</span><br><span class="line"></span><br><span class="line">            char[][] board &#x3D; new char[n][m];</span><br><span class="line">            int x &#x3D; -1;</span><br><span class="line">            int y &#x3D; -1;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                String s &#x3D; sc.nextLine();</span><br><span class="line">                for (int k &#x3D; 0; k &lt; m; k++) &#123;</span><br><span class="line">                    board[j][k]&#x3D;s.charAt(k);</span><br><span class="line">                    if (board[j][k] &#x3D;&#x3D; &#39;@&#39;) &#123;</span><br><span class="line">                        x &#x3D; k;    &#x2F;&#x2F;列号</span><br><span class="line">                        y &#x3D; j;    &#x2F;&#x2F;行号</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            boolean[][] used &#x3D; new boolean[n][m];</span><br><span class="line">            int[][] move &#x3D; new int[4][2];</span><br><span class="line">            move[0][0]&#x3D;0;</span><br><span class="line">            move[0][1]&#x3D;1;</span><br><span class="line">            move[1][0]&#x3D;0;</span><br><span class="line">            move[1][1]&#x3D;-1;</span><br><span class="line">            move[2][0]&#x3D;1;</span><br><span class="line">            move[2][1]&#x3D;0;</span><br><span class="line">            move[3][0]&#x3D;-1;</span><br><span class="line">            move[3][1]&#x3D;0;</span><br><span class="line"></span><br><span class="line">            PriorityQueue&lt;Integer&gt; list &#x3D; new PriorityQueue&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F;System.out.println(t +&quot; &quot;+n+ &quot; &quot;+m+&quot; &quot;+x+&quot; &quot;+y );</span><br><span class="line">            dis(x,y,board,used,list,0,move);</span><br><span class="line">            if(list.size()&gt;0)&#123;</span><br><span class="line">                System.out.println(list.poll());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(&quot;-1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void dis(int x,int y,char[][] board,boolean[][] used, PriorityQueue&lt;Integer&gt; list,int count,int[][] move)&#123;</span><br><span class="line">        if(x&lt;&#x3D;0||x&gt;&#x3D;board[0].length-1||y&lt;&#x3D;0||y&gt;&#x3D;board.length-1)&#123;     &#x2F;&#x2F;第3个或写成了与</span><br><span class="line">            &#x2F;&#x2F;System.out.println(count);</span><br><span class="line">            list.add(count);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">            x&#x3D;x+move[i][0];</span><br><span class="line">            y&#x3D;y+move[i][1];</span><br><span class="line">            if(x&gt;&#x3D;0&amp;&amp;x&lt;board[0].length&amp;&amp;y&gt;&#x3D;0&amp;&amp;y&lt;board.length&amp;&amp;!used[y][x])&#123;</span><br><span class="line">                used[y][x] &#x3D; true;</span><br><span class="line">                if (board[y][x]&#x3D;&#x3D;&#39;*&#39;)&#123;</span><br><span class="line">                    dis(x,y,board,used,list,count+1,move);</span><br><span class="line">                    &#x2F;&#x2F; System.out.println(count);</span><br><span class="line">                &#125;else if (board[y][x]&#x3D;&#x3D;&#39;.&#39;)&#123;</span><br><span class="line">                    dis(x,y,board,used,list,count,move);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                used[y][x] &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            x-&#x3D;move[i][0];</span><br><span class="line">            y-&#x3D;move[i][1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int bfs(vector&lt;string&gt; grid)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; direct&#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">    queue&lt;vector&lt;int&gt;&gt; que_;</span><br><span class="line">    int hei &#x3D; grid.size();</span><br><span class="line">    int wid &#x3D; grid[0].length();</span><br><span class="line">    int result &#x3D; -1;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; visited(hei, vector&lt;int&gt;(wid, -1));</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; hei; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; wid; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (grid[i][j] &#x3D;&#x3D; &#39;@&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                que_.push(&#123;i, j, 0&#125;);</span><br><span class="line">                visited[i][j] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (!que_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        auto cur &#x3D; que_.front();</span><br><span class="line">        que_.pop();</span><br><span class="line">        if (cur[0] &#x3D;&#x3D; 0 || cur[0] &#x3D;&#x3D; hei - 1 || cur[1] &#x3D;&#x3D; 0 || cur[1] &#x3D;&#x3D; wid - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            if (cur[2] &lt; result || result &#x3D;&#x3D; -1)</span><br><span class="line">            &#123;</span><br><span class="line">                result &#x3D; cur[2];</span><br><span class="line">            &#125;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 4; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int next_y &#x3D; cur[0] + direct[i][0];</span><br><span class="line">            int next_x &#x3D; cur[1] + direct[i][1];</span><br><span class="line">            int last_time &#x3D; cur[2];</span><br><span class="line">            if (visited[next_y][next_x] !&#x3D; -1 &amp;&amp; visited[next_y][next_x] &lt;&#x3D; last_time + 1)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[next_y][next_x] &#x3D; last_time + 1;</span><br><span class="line">            if (grid[next_y][next_x] &#x3D;&#x3D; &#39;.&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                que_.push(&#123;next_y, next_x, last_time&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (grid[next_y][next_x] &#x3D;&#x3D; &#39;*&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                que_.push(&#123;next_y, next_x, last_time + 1&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t, n, m;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; grids(t);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        grids[i].resize(n);</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; grids[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (auto grid : grids)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bfs(grid) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">public class hello &#123;&#x2F;&#x2F;100 999</span><br><span class="line">    static int[][] dir&#x3D;&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">    static int startX,startY;</span><br><span class="line">  &#x2F;&#x2F;  static int endX,endY;</span><br><span class="line">    static int min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">    static int[][] vis;</span><br><span class="line">    static Scanner sc&#x3D;new Scanner(System.in);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    int x&#x3D;sc.nextInt();</span><br><span class="line"></span><br><span class="line">    while(x--&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        int n&#x3D;sc.nextInt();</span><br><span class="line">        int m&#x3D;sc.nextInt();</span><br><span class="line">        char[][] matrix&#x3D;new char[n][m];</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[i]&#x3D;sc.next().toCharArray();</span><br><span class="line">          &#x2F;&#x2F;  sc.nextLine();</span><br><span class="line">            for(int j&#x3D;0;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">             if(matrix[i][j]&#x3D;&#x3D;&#39;@&#39;)</span><br><span class="line">             &#123;</span><br><span class="line">                 startX&#x3D;i;</span><br><span class="line">                 startY&#x3D;j;</span><br><span class="line">             &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis&#x3D;new int[n][m];</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i][j]&#x3D;-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        Queue&lt;Node&gt; q&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">        q.add(new Node(startX,startY));</span><br><span class="line">        BFS(matrix,q);</span><br><span class="line">        System.out.println(min);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void BFS(char[][] matrix,Queue&lt;Node&gt; q) &#123;</span><br><span class="line">    while(!q.isEmpty()) &#123;</span><br><span class="line">        int size &#x3D; q.size();</span><br><span class="line">        while (size-- &gt; 0) &#123;</span><br><span class="line">            Node nowNode &#x3D; q.poll();</span><br><span class="line">            int i &#x3D; nowNode.x, j &#x3D; nowNode.y;</span><br><span class="line">            vis[i][j]&#x3D;nowNode.step;</span><br><span class="line">            if (i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; matrix.length - 1</span><br><span class="line">                    || j &#x3D;&#x3D; 0</span><br><span class="line">                    || j &#x3D;&#x3D; matrix[0].length - 1</span><br><span class="line">            ) &#123;</span><br><span class="line">                min&#x3D;Math.min(vis[i][j],min);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int[] d : dir) &#123;</span><br><span class="line">                int newX &#x3D; d[0] + i;</span><br><span class="line">                int newY &#x3D; d[1] + j;</span><br><span class="line">                if (matrix[newX][newY] &#x3D;&#x3D; &#39;#&#39;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(vis[newX][newY]!&#x3D;-1 &amp;&amp; vis[newX][newY]&lt;&#x3D;nowNode.step+1)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                Node newNode &#x3D; new Node(newX, newY);</span><br><span class="line">                if (matrix[newX][newY] &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line"></span><br><span class="line">                    newNode.step &#x3D;nowNode.step+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(matrix[newX][newY] &#x3D;&#x3D; &#39;.&#39;)</span><br><span class="line">                &#123;</span><br><span class="line">                    newNode.step &#x3D;nowNode.step;</span><br><span class="line">                &#125;</span><br><span class="line">                q.add(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;  ####</span><br><span class="line">        &#x2F;&#x2F; ####</span><br><span class="line">        &#x2F;&#x2F; #@.*</span><br><span class="line">        &#x2F;&#x2F; **.*</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static class Node</span><br><span class="line">    &#123;</span><br><span class="line">        int x;</span><br><span class="line">        int y;</span><br><span class="line">        int step;</span><br><span class="line">        Node(int a,int b)</span><br><span class="line">        &#123;</span><br><span class="line">            x&#x3D;a;</span><br><span class="line">            y&#x3D;b;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据</title>
      <link href="/2020/09/30/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
      <url>/2020/09/30/%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>1MB=2^20B</p><p>1KB=2^10B=10^3B</p><h2 id="1-共同URL"><a href="#1-共同URL" class="headerlink" title="1.共同URL"></a>1.共同URL</h2><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。</p><blockquote><p>5,000,000,000 * 64B ≈ 5GB * 64 = 320GB</p></blockquote><p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p><strong>思路如下</strong>：</p><p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code>，根据计算结果把遍历到的  URL 存储到文件  a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p><p>接着遍历 ai( <code>i∈[0,999]</code>)，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p><h3 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h3><p>1.分而治之，进行哈希取余；2.对每个子文件进行 HashSet 统计。</p><h2 id="2-频率Top100"><a href="#2-频率Top100" class="headerlink" title="2.频率Top100"></a>2.频率Top100</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p><h3 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h3><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p><p><strong>思路如下</strong>：</p><p>首先遍历大文件，对遍历到的每个词x，执行 <code>hash(x) % 5000</code>，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p><p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 <code>map.put(x, 1)</code>；若存在，则执行 <code>map.put(x, map.get(x)+1)</code>，将该词频数加 1。</p><p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p><h3 id="方法总结-1"><a href="#方法总结-1" class="headerlink" title="方法总结"></a>方法总结</h3><p>1.分而治之，进行哈希取余；2.使用 HashMap 统计频数；3.求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</p><h2 id="3-找不重复"><a href="#3-找不重复" class="headerlink" title="3.找不重复"></a>3.找不重复</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p><h3 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h3><h4 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p><h4 id="方法二：位图法"><a href="#方法二：位图法" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h4><p><strong>位图</strong>，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p><p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p><p>假设我们要对 <code>[0,7]</code> 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000</span><br></pre></td></tr></table></figure><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00001010</span><br></pre></td></tr></table></figure><p>依次遍历，结束后，位数组是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01101110</span><br></pre></td></tr></table></figure><p>每个为 1 的位，它的下标都表示了一个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in range(8):if bits[i] &#x3D;&#x3D; 1:print(i)</span><br></pre></td></tr></table></figure><p>这样我们其实就已经实现了排序。</p><p>对于整数相关的算法的求解，<strong>位图法</strong>是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 2^32。</p><p><strong>那么对于这道题</strong>，我们用 2 个 bit 来表示各个数字的状态：</p><p>•00 表示这个数字没出现过；•01 表示这个数字出现过一次（即为题目所找的不重复整数）；•10 表示这个数字出现了多次。</p><p>那么这 232 个整数，总共所需内存为 2^32*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p><p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p><h3 id="方法总结-2"><a href="#方法总结-2" class="headerlink" title="方法总结"></a>方法总结</h3><p><strong>判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p><h2 id="4-1亿个正整数-范围是0-42亿。求出现次数是2的数字，空间复杂度"><a href="#4-1亿个正整数-范围是0-42亿。求出现次数是2的数字，空间复杂度" class="headerlink" title="4.1亿个正整数,范围是0-42亿。求出现次数是2的数字，空间复杂度"></a>4.1亿个正整数,范围是0-42亿。求出现次数是2的数字，空间复杂度</h2><p>使用位图bitMap     。位图是以 bit     位为单位进行数据存储，这样每个字节8个位就可以存储8个数字，普通的一个int占4个字节，32位，用了位图之后可以将空间节省32倍。     </p><p>​      开一个42亿大小的位图，将这一亿个数字存进数字大小对应的位置，一个bit每存进去一个数字，就将value+1,比如第一次存8，就将索引为8的位置的value置为1，第二次就置为2，存完之后搜索value为2的key是多少。     </p><p>​      32位机器最大能表示的数字是42亿9千多万。     </p><p>​      42亿bit /(8 * 1024 * 1024) = 500MB</p><h2 id="5-有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？"><a href="#5-有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？" class="headerlink" title="5.有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？"></a>5.有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？</h2><p>思路一：分治法，将ip地址根据前三位分成256份，然后看这个ip地址对应的网段，只比对这个网段里面是否有这个ip，当然还可以继续分下去，根据数据量来决定分成多少份。     </p><p>​      思路二：位图，将每一条ip对应位图中的一个位，2^32次方(42亿多)个数据只需要512M空间。可以实现O(1)的时间搜索，O(n)的时间存储。     </p><h2 id="6-2g内存，要求一个10g文件的中位数"><a href="#6-2g内存，要求一个10g文件的中位数" class="headerlink" title="6. 2g内存，要求一个10g文件的中位数**"></a>6. 2g内存，要求一个10g文件的中位数**</h2><p>如题 “在一个文件中有 10G 个整数,乱序排列,要求找出中位数(内存限制为 2G)”</p><p>原创，网上这个题目有好多答案，但是有好多都不准确。</p><p> 假设整数用32bit来表示。</p><p>第一步：要表示10G个整数，最少需要一个64位的数据空间。（10G = 5 * 2^31 &gt; 2^32 )</p><p>第二步：分区间</p><p>2G的内存，能够表示多少个64bit，就能分多少个区间。（一个区间 就表示 一个64bit的数据空间）</p><p>区间数位：2G / 64bit = 256M 个区间。</p><p>第三步：求区间表示范围</p><p>32bit的整数最大值为2^32-1,所以区间的范围是2^32 / 256M = 16.</p><p>即0 ~ 15 ，16 ~ 31，32 ~ 47，……（总共256M个)</p><p>此时我们有 256M个区间，大小总共为256M * 64bit = 2G内存。</p><p>第四步：遍历10G个整数。每读取一个整数就将此整数对应的区间+1。</p><p>第五步：找出中位数所在的区间</p><p>统计每个区间中整数的值。然后从第一个区间的整数值开始累加。当累加到5G时，停止。此时的区间便包含中位数。记下此区间所表示的范围，设为[a,a+15].并且记下此区间之前所有区间的累加和，设为m。释放掉除包含中位数区间的其他所有区间的内存。</p><p>第六步：再次遍历10G个整数，统计出现在区间[a,a+15]中每个值的计数，有16个数值，按照a到a+15排序。设为n0,n1,n2,…n15</p><p>第七步：当m+n0+n1+…+nx首次大于5G时，此时的 a+x 就是所求的中位数。</p><p>7.</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智力题</title>
      <link href="/2020/09/30/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
      <url>/2020/09/30/%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-三门问题（Monty-Hall-problem）"><a href="#1-三门问题（Monty-Hall-problem）" class="headerlink" title="1.三门问题（Monty Hall problem）"></a>1.三门问题（Monty Hall problem）</h2><p>亦称为蒙提霍尔问题或蒙提霍尔悖论，大致出自美国的电视游戏节目Let’s Make a Deal。问题名字来自该节目的主持人蒙提·霍尔（Monty Hall）。参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机率？</p><p>作为工科生，还是拿贝叶斯公式来分析一波：</p><p>首先看贝叶斯公式： </p><p><img src="https://img-blog.csdnimg.cn/20190707193021763.png" alt="img"></p><p>p(A|B)的意思是在B事件发生的情况下，A事件发生的概率。p(A,B)是两个事件同时发生的概率。</p><p>那么上面的公式可以延伸出下面的公式：</p><p><img src="https://img-blog.csdnimg.cn/20190707193821826.png" alt="img"></p><p>好，然后我们针对这个题目，我们假设有A、B、C三个门，参赛者选择了A门，主持人打开了B门，然后要参赛者在A门和C门之间抉择换还是不换。那么如果汽车在B门后面，换与不换得到汽车的概率均为0，如果换了能赢，那么汽车必须在C门后面， 现在我们求以下概率：</p><p><img src="https://img-blog.csdnimg.cn/20190707200643101.png" alt="img"></p><p>我们先看分母，我们三种可能情况列一下：</p><p><img src="https://img-blog.csdnimg.cn/20190707201600435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3Vuc2hp,size_16,color_FFFFFF,t_70" alt="img"></p><p>所以分母为：</p><p><img src="https://img-blog.csdnimg.cn/20190707201824129.png" alt="img"></p><p>再看分子，当车在C后面时，参赛者选择了A门，支持人只有B门可以打开，所以：</p><p><img src="https://img-blog.csdnimg.cn/20190707202332301.png" alt="img"></p><p>而车在C门后的概率显而易见：</p><p><img src="https://img-blog.csdnimg.cn/20190707202715221.png" alt="img"></p><p>然后我们就求得了换门获胜的概率：</p><p><img src="https://img-blog.csdnimg.cn/20190707203200890.png" alt="img"></p><p>-———————————————————————————————————————— </p><p>这个问题就结束了。然而对于贝叶斯公式还没有结束。</p><p>贝叶斯公式还会有如下写法：</p><p><img src="https://img-blog.csdnimg.cn/20190707211603830.png" alt="img"></p><p>这个公式可以用在分类上，具体的可以去翻看我的另一篇博客</p><h2 id="2-桶装水"><a href="#2-桶装水" class="headerlink" title="2.桶装水"></a>2.桶装水</h2><p>有无限的水，5L和6L 的桶精确装4L 水</p><blockquote><p>通用解法： 用小的桶不断往大桶填水</p><p>这里： 5L桶 6L桶</p><p>0 0</p><p>5 0</p><p>0 5</p><p>5 5</p><p>4 6</p></blockquote><p><strong>一个装了10L水的桶，一个7L的空桶，一个3L的空桶，怎样变成2个5L</strong></p><p>初始时为10，0，0。<br>第二步7，0，3。<br>然后7，3，0。<br>然后4，3，3。<br>然后4，6，0。<br>然后1，6，3。<br>然后1，7，2。<br>然后8，0，2。<br>然后8，2，0。<br>然后5，2，3。<br>然后5，5，0。</p><p><strong>如果你有无穷多的水，一个3夸脱的和一个5夸脱的提桶，你如何准确称出 4夸脱的水？</strong></p><p>初始时0，5<br>然后3，2<br>然后0，2<br>然后2，0<br>然后2，5<br>然后1，4</p><p>两个舀酒的勺子，分别能舀7两和11两酒，二两酒？</p><p>初始0，11<br>然后7，4<br>然后0，4<br>然后4，0<br>然后4，11<br>然后7，8<br>然后0，8<br>然后7，1<br>然后0，1<br>-—–<br>然后1，11<br>然后7，5<br>然后0，5<br>然后5，0<br>然后5，11，<br>然后7，9<br>然后0，9<br>然后7，2</p><h2 id="3-瞎子分牌"><a href="#3-瞎子分牌" class="headerlink" title="3.瞎子分牌"></a>3.瞎子分牌</h2><p>一副牌52张,告诉瞎子里面有10张牌是正面朝上的, 要求瞎子把这52张牌分成两堆, 并且每堆牌正面朝上的张数相同，可任意翻动牌，但是一直不可以看。</p><blockquote><p>分成10和42， 10 中的所有牌。</p><p>proof： 第一堆（10张牌里有x张向上），全翻 = 10-x 张向上，等于第二堆向上的牌数</p></blockquote><h2 id="4-赛马问题"><a href="#4-赛马问题" class="headerlink" title="4.赛马问题"></a>4.赛马问题</h2><p>64匹马，8个跑道，选跑最快的4匹马需要比赛多少次。</p><p>(     锦标赛<a href>排序</a><a href>算法</a>     )      sum = 11     </p><p>​      第一步：首先每8匹马跑一次，总共需要8次，假设结果中A1&gt;A2&gt;A3&gt;……,B1&gt;B2&gt;B3&gt;….等。 sum=8；     </p><p>​      第二步：这8组中的第一名拉出来跑一次，那么这次最快的是总的第一名，假设是A1，同时假设B1&gt;C1&gt;D1。这时还要角逐2,3,4名，     那这一轮中的第五到第八组都可以直接舍弃     ，因为他们所有的马一定进不了前4名。sum=9。     </p><p>​      第三步：从A组中选A2，A3，A4，B组中B1，B2，B3，C组中C1，C2，D组中D1，这些才有资格角逐2,3,4名。这时需要再比赛两次。 sum=11。（但是如果第10轮选择A4不上场，如果A3获得了第4名，那么A4就不需要比赛了，这样     sum=10     ）。</p><p>25匹马，5个跑道，每个跑道最多能有1匹马进行比赛，最少比多少次能比出前3名？前5名？</p><h2 id="5-老鼠死亡问题"><a href="#5-老鼠死亡问题" class="headerlink" title="5.老鼠死亡问题"></a>5.老鼠死亡问题</h2><p>1000瓶药，有一些可能有毒，用老鼠来喝药，喝到有毒的一周就死。一周内至少需要多少只老鼠才能检测到哪些有毒</p><p>同时给老鼠编号，从1,2,…10，从低位开始，让第n个编号老鼠喝下第n个bit位为1的瓶子中的药水。<br>一周后，若所有的老鼠都没有发病，那么是第0个瓶子有毒，<br>如果有一些编号的老鼠发病，死亡的老鼠记为1，正常老鼠记为0，那么按照老鼠编号1-10对应bit位从低到高，对应的10进制即为有毒药水的编号。</p><p><strong>附上百度解释</strong><br>给1000个瓶分别标上如下标签（10位长度）：<br>0000000001 （第1瓶）<br>0000000010 （第2瓶）<br>0000000011 （第3瓶）<br>……<br>1111101000 （第1000瓶）<br>从编号最后1位是1的所有的瓶子里面取出1滴混在一起（比如从第一瓶，第三瓶，。。。里分别取出一滴混在一起）并标上记号为1。以此类推，从编号第一位是1的所有的瓶子里面取出1滴混在一起并标上记号为10。现在得到有10个编号的混合液，小白鼠排排站，分别标上10，9，。。。1号，并分别给它们灌上对应号码的混合液。24小时过去了，过来验尸吧：<br><strong>从左到右，死了的小白鼠贴上标签1，没死的贴上0，最后得到一个序号，把这个序号换成10进制的数字，就是有毒的那瓶水的编号。</strong><br>检验一下：假如第一瓶有毒，按照0000000001 （第1瓶），说明第1号混合液有毒，因此小白鼠的生死符为0000000001（编号为1的小白鼠挂了），0000000001二进制标签转换成十进制=1号瓶有毒；假如第三瓶有毒，0000000011 （第3瓶），第1号和第2号混合液有毒，因此小白鼠的生死符为00000011（编号为1，2的鼠兄弟挂了），0000000011二进制标签转换成十进制=3号瓶有毒。</p><p>————————————————————————————————————————————<br><strong>举例，10瓶药水，4个bit表示，对应药水编号0-9，又4个bit对应4个老鼠，则老鼠编号1-4，</strong><br>0000， 0<br>0001， 1<br>0010， 2<br>0011， 3<br>0100， 4<br>0101，5<br>0110，6<br>0111，7<br>1000，8<br>1001，9</p><p>老鼠编号 对应药水瓶子编号<br>1， ，，， 1，3，5，7，9<br>2， ，，， 2，3，6，7<br>3， ，，，4，5，6，7<br>4， ，，，8，9</p><p>如果一周之后，全都安然无恙，则0号药水瓶子有毒，<br>如果1，2，3编号老鼠死亡，则很容易看出7号有毒，<br>或者1，2，3编号老鼠置为1，4号置为0，从低到高即为0111=7</p><h2 id="6-石头称重"><a href="#6-石头称重" class="headerlink" title="6.石头称重"></a>6.石头称重</h2><p>13个石头，有一个比较重其他都一样，用天平测量最多需要几次才能测出重的那个</p><p>4 4 5</p><p> 1) 如果 4 == 4 在 5 里面 分为 2 2 1<br> 1.1) 如果 2 == 2 在 1 那 ok <strong>两次</strong><br> 1.2) 如果 2 != 2 称 1 1 ，那个沉就是答案，<strong>三次</strong><br> 2) 4 != 4 在 沉的那堆里面<br> 2.1) 称2 2 排除 2个 再称1 1 ，那个沉就是答案，<strong>三次</strong></p><h2 id="7-抛硬币"><a href="#7-抛硬币" class="headerlink" title="7.抛硬币"></a>7.抛硬币</h2><p>一硬币，一面向上概率0.7，一面0.3，如何公平？</p><p>两个人轮流抛硬币，先抛到正面的赢，问先抛的人赢的概率？</p><p>每一轮 抛硬币，A先抛赢得概率是1/2，B后抛赢得概率是（1/2）*（1/2）= 1/4。那么 每一轮A赢得概率都是B赢得概率的2倍 ，总概率为1,所以A赢的概率是2/3。</p><h2 id="8-蚊香"><a href="#8-蚊香" class="headerlink" title="8.蚊香"></a>8.蚊香</h2><p>两根香，一根烧完1小时，如何测量15分钟</p><p>开始时一根香两头点着，一根香只点一头，两头点着的香烧完说明过去了半小时，这时将只点了一头的香另一头也点着，从这时开始到烧完就是15分钟。</p><h2 id="9-海盗分金币"><a href="#9-海盗分金币" class="headerlink" title="9.海盗分金币"></a>9.海盗分金币</h2><p>1.</p><p>在加勒比海上，有五个海盗，共同抢到了100枚金币， 每一个人按顺序依次提出自己的分配方案，如果提出的方案没有获得<strong>半数或半数以上</strong>的人的同意，则这个提出方案的人就被扔到海里喂鲨鱼，那么第一个提出方案的人要怎么做，才能使自己的利益最大化？（前提是海盗都是十分聪明和贪婪的）</p><p>假使前三个人都因为分配金币的方式不合理而被扔下大海，此时还剩下两个人，也就是4号和5号，那么问题就简单了：</p><p><strong>4号和5号</strong>分金币的情况：<br>   4号提出方案，自己一定会同意的，并且只要自己同意，这个方案就已经获得了半数的支持，就可以被实施<br>   因此，无论5号是否同意4号提出的方案，都不会对最终的结果造成影响，因此，<strong>4号一定会要100枚金币</strong>，以使自己的利益最大化，结果就变成了这样：<br>     <strong>4号</strong>     5号<br>     <strong>100</strong>     0</p><p>现在我们多添加一个人，<br><strong>3号，4号和5号</strong>分金币的情况：<br>   3号要使自己的提议获得半数的支持就必须再拉拢一个人，拉拢4号显然是不合适的，4号一定不会同意，4号知道，只要搞死了3号，剩下的100枚金币都是自己的。（就像上面4号和5号分金币的情况）拉拢5号是合适的，因为5号之前得不到金币，现在只要3号给5号一个金币就能够获得5号的支持，因为5号也知道，如果3号死亡，自己一定一枚金币都得不到。</p><p>情况就变成了这样：</p><p>​    <strong>3号</strong>     4号    <strong>5号</strong><br>​     <strong>99</strong>      0      <strong>1</strong></p><p>现在我们再多添加一个人：<br><strong>2号，3号，4号和5号</strong>分金币的情况：<br>   2号要使自己的提议获得半数的支持也必须再拉拢一个人，拉拢3号显示是不合适的，3号一定不会同意，3号知道，只要搞死了2号，有99枚金币都是自己的（就像上面3号，4号和5号分金币的情况）， 拉拢5号貌似是可以的，他已经有一个金币了，要让他支持自己只要再多给他一个金币就可以了，拉拢4号也是可以的，4号现在没有金币，只要给他一个就可以让他自持自己的提案，综上所述，要让自己利益最大化，就需要拉拢4号，因为只要给4号一个金币即可：<br>   情况就变成了这样：<br>     <strong>2号</strong>     3号     <strong>4号</strong>     5号<br>     <strong>99</strong>      0       <strong>1</strong>     0</p><p>最后我们再多添加一个人这道题目的答案就出来了：<br>1号，2号，3号，4号和5号分金币的情况：</p><p>1号要使自己的提议获得半数的支持必须拉拢两个人，拉拢2号显示是不合适的，2号一定不会同意，2号知道，只要搞死了1号，有99枚金币都是自己的，（就像上面2号，3号，4号和5号分金币的情况）， 拉拢4号貌似是可以的，他已经有一个金币了，要让他支持自己需要再给他一个金币才可以，这样做并不能让自己的利益最大化， 拉拢3号是可以的，3号现在没有金币，只要给他一个就可以让他自持自己的提案， 5号跟3号情况一至，同样没有金币，只要给他一个就可以了，综上所述，要让自己利益最大化，就需要拉拢3号跟5号，因为拉拢他们两个只需要各自给一个金币即可：<br>情况就变成了这样：<br>     <strong>1号</strong>     2号     <strong>3号</strong>     4号     <strong>5号</strong><br>     <strong>98</strong>      0       <strong>1</strong>       0      <strong>1</strong></p><ol start="2"><li><p>或必须半数以上的人同意呢？</p><p>这道题是典型的逆向思维的问题，用回推法可以得到答案。过程如下：从后往前推，人数依次增加如果1-3号强盗都喂了鲨鱼，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。3号知道这一点，就会提（100,0,0）的分配方案，对4号、5号一毛不拔而将全部金币归为已有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票，他的方案即可通过。2号推到3号的方案，就会提出（98，0，1，1）的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。2号的方案会被1号所洞悉，1号并将提出（97，0，1，2，0）或（97，0，1，0，2）的方案，即放弃2号，而给3号一枚金币，同时给4号（或5号）2枚金币。由于1号的这一方案对于3号和4号（或5号）来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。这无疑是1号能够获取最大收益的方案了！</p></li></ol><h2 id="10-54张扑克牌，平均分成3份，大小王在一份的概率"><a href="#10-54张扑克牌，平均分成3份，大小王在一份的概率" class="headerlink" title="10. 54张扑克牌，平均分成3份，大小王在一份的概率"></a>10. 54张扑克牌，平均分成3份，大小王在一份的概率</h2><p>首先大王一定会在某一份中，然后要计算这一份中还要包含小王的概率。去掉大王还剩53张牌，这一份还可以分17张牌，那么每次分到小王的概率是1/53,所以总概率是17/53。</p><p><img src="https://uploadfiles.nowcoder.com/images/20200518/66153173_1589803055420_16F6C01C102793BA75D2E74EDCF64397" alt="img"></p><h2 id="11-让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。"><a href="#11-让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。" class="headerlink" title="11.让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。"></a>11.让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。</h2><p>传入参数有总钱数，分的份数，随机分还是等分。先判断钱数能不能分那么多份，这个直接用总钱数&gt;=0.01<em>份数判断就可以了。然后根据分发策略，选择随机还是等分，随机的话就给 1到总钱数-（总份数-1）</em>0.01 的随机数（总钱数以分为单位），等分的话直接除判断能不能除开，有余数就将余数加到最后一份里面。</p><h2 id="12-分布式多个机器生成id，如何保证不重复"><a href="#12-分布式多个机器生成id，如何保证不重复" class="headerlink" title="12.分布式多个机器生成id，如何保证不重复?"></a>12.分布式多个机器生成id，如何保证不重复?</h2><p>\1.     <strong>snowflake方案</strong>     ：     </p><p>​      snowflake是Twitter开源的分布式ID生成<a href>算法</a>，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着     每个节点在每毫秒可以产生 4096 个 ID     ），最后还有一个符号位，永远是0。     </p><p>​      优点     ：     </p><p>​      1.毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。     </p><p>​      2.不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。     </p><p>​      3.可以根据自身业务特性分配bit位，非常灵活。     </p><p>​      缺点     ：     </p><p>​      强依赖机器时钟，如果     机器上时钟回拨     ，会导致发号重复或者服务会处于不可用状态。     </p><p>​      \2.     <strong>用Redis生成ID：</strong>     </p><p>​      因为Redis是单线程的，也可以用来生成全局唯一ID。可以用Redis的原子操作INCR和INCRBY来实现。     </p><p>​      此外，可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis，可以初始化每台Redis的值分别是1,2,3,4,5，步长都是5，各Redis生成的ID如下：     </p><p>​      A：1,6,11,16     </p><p>​      B：2,7,12,17     </p><p>​      C：3,8,13,18     </p><p>​      D：4,9,14,19     </p><p>​      E：5,10,15,20     </p><p>​      这种方式是负载到哪台机器提前定好，未来很难做修改。3~5台服务器基本能够满足需求，都可以获得不同的ID，但步长和初始值一定需要事先确定，使用Redis集群也可以解决单点故障问题。     </p><p>​      另外，比较适合使用Redis来生成每天从0开始的流水号，如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。     </p><p>​      <strong>优点：</strong>     </p><p>​      1）不依赖于数据库，灵活方便，且性能优于数据库。     </p><p>​      2）数字ID天然<a href>排序</a>，对分页或需要<a href>排序</a>的结果很有帮助。     </p><p>​      <strong>缺点：</strong>     </p><p>​      1）如果系统中没有Redis，需要引入新的组件，增加系统复杂度。     </p><p>​      2）需要编码和配置的工作量较大。</p><h2 id="13-数据库连接池怎么设计"><a href="#13-数据库连接池怎么设计" class="headerlink" title="13.数据库连接池怎么设计?"></a>13.数据库连接池怎么设计?</h2><p>需要考虑的问题：     </p><ol><li>限制连接池中最多、可以容纳的连接数目，避免过度消耗系统资源。 </li><li>当客户请求连接，而连接池中所有连接都已被占用时，该如何处理呢？一种方式是让客户一直等待，直到有空闲连接，另一种方式是为客户分配一个新的临时连接。 </li><li>当客户不再使用连接，需要把连接重新放回连接池。 </li><li>连接池中允许处于空闲状态的连接的最大<a href>项目</a>。假定允许的最长空闲时间为十分钟，并且允许空闲状态的连接最大数目为5， </li></ol><p>​      那么当连接池中有n个(n&gt;5)连接处于空闲状态的时间超过十分钟时，     <strong>就应该把n-5个连接关闭，并且从连接池中删除，</strong>     这样才能更有效的利用系统资源。</p><h2 id="14-扫码登录"><a href="#14-扫码登录" class="headerlink" title="14.扫码登录"></a>14.扫码登录</h2><h2 id="15-砝码秤盐"><a href="#15-砝码秤盐" class="headerlink" title="15.砝码秤盐"></a>15.砝码秤盐</h2><p>140g盐,一天平,7g 、2g砝码各一个,如何只利用这些东西3次把盐分成50g和90g?</p><ul><li><p>第一次： 7g、2g砝码称出9g盐，结果盐分成9g与131g</p></li><li><p>第二次：将9g盐与7g、2g都作为砝码，结果将盐分为18g与113g （注意：这时盐已经分为三份：9g、18g、113g，还有两个砝码）</p></li><li><p>第三次：将18g盐与7g砝码发在左托盘，将2g砝码放在右托盘，然后在113g盐中取盐添置右托盘中，可获取23g盐。</p></li></ul><p>  这时盐分为9g，18g，23g与90g。  </p><p>  即三次，可以得到90g与（9+18+23）50g。</p><h2 id="16-九球称重"><a href="#16-九球称重" class="headerlink" title="16.九球称重"></a>16.九球称重</h2><blockquote><h3 id="有-9-个球，其中-8-个球质量相同，有-1-个球比较重。要求用-2-次天平，找出比较重的那个球。"><a href="#有-9-个球，其中-8-个球质量相同，有-1-个球比较重。要求用-2-次天平，找出比较重的那个球。" class="headerlink" title="有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。"></a>有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。</h3></blockquote><p> 将这些球均分成 3 个一组共 3 组，选出 2 组称重，如果 1 组比较重，那么重球在比较重的那 1 组；如果 1 组重量相等，那么重球在另外 1 组。 </p><p> 对比较重的那 1 组的 3 个球再分成 3 组，重复上面的步骤。 </p><h2 id="17-药丸称重"><a href="#17-药丸称重" class="headerlink" title="17.药丸称重"></a>17.药丸称重</h2><blockquote><h3 id="有-20-瓶药丸，其中-19-瓶药丸质量相同为-1-克，剩下一瓶药丸质量为-1-1-克。瓶子中有无数个药丸。要求用一次天平找出药丸质量-1-1-克的药瓶。"><a href="#有-20-瓶药丸，其中-19-瓶药丸质量相同为-1-克，剩下一瓶药丸质量为-1-1-克。瓶子中有无数个药丸。要求用一次天平找出药丸质量-1-1-克的药瓶。" class="headerlink" title="有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。"></a>有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。</h3></blockquote><p> 可以从药丸的数量上来制造差异：从第 i 瓶药丸中取出 i 个药丸，然后一起称重。可以知道，如果第 i 瓶药丸重 1.1 克/粒，那么称重结果就会比正常情况下重 0.1 * i 克。 </p><h2 id="18-得到-4-升的水"><a href="#18-得到-4-升的水" class="headerlink" title="18.得到 4 升的水"></a>18.得到 4 升的水</h2><blockquote><h3 id="有两个杯子，容量分别为-5-升和-3-升，水的供应不断。问怎么用这两个杯子得到-4-升的水。"><a href="#有两个杯子，容量分别为-5-升和-3-升，水的供应不断。问怎么用这两个杯子得到-4-升的水。" class="headerlink" title="有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。"></a>有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。</h3></blockquote><ul><li>1、将3升的装满倒入5升的；<br>2、再一次将3升的转满，倒入5升的，把5升装满；<br>3、3升杯里剩下的就是1升水；<br>4、倒掉5升的，把1升水倒入5升杯；<br>5、第三次加满3升杯，倒入5升杯，得到4升水。 </li></ul><h2 id="19-扔鸡蛋"><a href="#19-扔鸡蛋" class="headerlink" title="19.扔鸡蛋"></a>19.扔鸡蛋</h2><blockquote><h3 id="一栋楼有-100-层，在第-N-层或者更高扔鸡蛋会破，而第-N-层往下则不会。给-2-个鸡蛋，求-N，要求最差的情况下扔鸡蛋的次数最少"><a href="#一栋楼有-100-层，在第-N-层或者更高扔鸡蛋会破，而第-N-层往下则不会。给-2-个鸡蛋，求-N，要求最差的情况下扔鸡蛋的次数最少" class="headerlink" title="一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少"></a>一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少</h3></blockquote><p>最优解法是反向思考的经典：如果最优解法在最坏情况下需要扔X次，那第一次在第几层扔最好呢？ </p><p> 答案是：从X层扔 </p><p> 假设最优的尝试次数的x次，为什么第一次扔就要选择第x层呢？ </p><p> 这里的解释会有些烧脑，请小伙伴们坐稳扶好： </p><p> <strong>假设第一次扔在第x+1层：</strong> </p><p> 如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x层。 </p><p> 这样一来，我们总共尝试了x+1次，和假设尝试x次相悖。由此可见，第一次扔的楼层必须小于x+1层。 </p><p> <strong>假设第一次扔在第x-1层：</strong> </p><p> 如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-2层。 </p><p> 这样一来，我们总共尝试了x-2+1 = x-1次，虽然没有超出假设次数，但似乎有些过于保守。 </p><p> <strong>假设第一次扔在第x层：</strong> </p><p> 如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-1层。 </p><p> 这样一来，我们总共尝试了x-1+1 = x次，刚刚好没有超出假设次数。 </p><p> 因此，要想尽量楼层跨度大一些，又要保证不超过假设的尝试次数x，那么第一次扔鸡蛋的最优选择就是第x层。 </p><p> 那么算最坏情况，第二次你只剩下x-1次机会，从100-x层 扔</p><p>按照上面的说法，你第二次尝试的位置必然是X+（X-1）； </p><p> 以此类推我们可得： </p><p> x + (x-1) + (x-2) + … + 1 = 100 </p><p> 这个方程式不难理解： </p><p> 左边的多项式是各次扔鸡蛋的楼层跨度之和。由于假设尝试x次，所以这个多项式共有x项。 </p><p> 右边是总的楼层数100。 </p><p> 下面我们来解这个方程： </p><p> x + (x-1) + (x-2) + … + 1 = 100 转化为 </p><p> (x+1)*x/2 = 100 </p><p> 最终x向上取整，得到 x = 14 </p><p> 因此，最优解在最坏情况的尝试次数是14次，第一次扔鸡蛋的楼层也是14层。 </p><p> 最后，让我们把第一个鸡蛋没碎的情况下，所尝试的楼层数完整列举出来： </p><p> 14，27， 39， 50， 60， 69， 77， 84， 90， 95， 99， 100 </p><p> 举个栗子验证下： </p><p> 假如鸡蛋不会碎的临界点是65层，那么第一个鸡蛋扔出的楼层是14，27，50，60，69。这时候啪的一声碎了。 </p><p> 第二个鸡蛋继续，从61层开始，61，62，63，64，65，66，啪的一声碎了。 </p><p> 因此得到不会碎的临界点65层，总尝试次数是 6 + 6 = 12 &lt; 14 。 </p><p> 下面是我个人的理解：这个更像是优化版的均匀法，均匀法让你第二次尝试不超过10，但是第一次的位置无法保证（最多要9次，最好一次），这个由于每多一次尝试，楼层间隔就-1，最终使得第一次与第二次的和完全均匀（最差情况）。 </p><p> 但是核心思路是逆向思考，因为即使理解了需要两次的和均匀也很难得到第一次要在哪层楼扔。 </p><p> 一旦理解了这种方法，多少层楼你都不会怕啦~</p><p>来源：<a href="https://blog.csdn.net/qq_38316721/article/details/81351297" target="_blank" rel="noopener">https://blog.csdn.net/qq_38316721/article/details/81351297</a></p><h2 id="20-一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样"><a href="#20-一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样" class="headerlink" title="20.一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样"></a>20.一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样</h2><p>1/3<br>样本空间为（男男）（女女）（男女）（女男）<br>A＝（已知其中一个是女孩）＝）（女女）（男女）（女男）<br>B＝（另一个也是女孩）＝（女女）<br>于是P（B／A）＝P（AB）／P（A）＝（1／4）／（3／4）＝1／3</p><h2 id="21-分金条"><a href="#21-分金条" class="headerlink" title="21.分金条"></a>21.分金条</h2><p>有个商人雇用了一位手艺高超的工匠了为他做一个精致产品，工作一星期七天的代价是一条金条。商人手头上有一条金条，刚好有可以付工匠一星期的工钱。但工匠要求工钱要按每天来付。虽然他并不急着用钱，每天有钱进账，老人心里总是踏实一些。但商人家中有个规矩，金条每星期只能切二刀。后来商人想出以了个切割金条的办法，满足了工匠的要求。你知道商人是怎么切割金条才能满足工匠的吗？</p><p>切成1、2、4。这三个二进制数的组合能表示0-7中的任何一个。</p><h2 id="22-假钱问题"><a href="#22-假钱问题" class="headerlink" title="22.假钱问题"></a>22.假钱问题</h2><p><strong>老王30买了双鞋，35卖，客人花100买，老王没零钱于是向老李换了100.补给客人后，客人走远后老李突然说是假钱，于是老王补偿给了老李，问老王一共亏了多少？</strong></p><p>卖鞋赚了35-30=5<br>假钱赔了100<br>一共亏95</p><h2 id="23-取硬币问题"><a href="#23-取硬币问题" class="headerlink" title="23.取硬币问题"></a>23.取硬币问题</h2><p><strong>30枚面值不全相同的硬币摆成一排，甲、乙两个人轮流选择这排硬币的其中一端，并取走最外边的那枚硬币。如果你先取硬币，能保证得到的钱不会比对手少吗？</strong></p><p>先取者可以让自己总是取奇数位置上的硬币或者总是取偶数位置上的硬币。数一数是奇数位置上的面值总和多还是偶数位置上的面值总和多，然后总是取这些位置上的硬币就可以了。</p><h2 id="24-旅馆问题"><a href="#24-旅馆问题" class="headerlink" title="24.旅馆问题"></a>24.旅馆问题</h2><p>有三个人去住旅馆，住三间房，每一间房10元，于是他们一共付给老板30，第二天，老板觉得三间房只需要25元就够了  叫小弟退回5给三位客人，谁知小弟贪心,只退回每人1，自己偷偷拿了2，这样一来便等于那三位客人每人各花了九元，于是三个人一共花了27，再加上小弟独吞了2，总共是29。可是当初他们三个人一共付出30，那么还有剩下的1呢？</p><p>他们所消费的27元里已经包括小弟贪污的2元了，再加退还的3元=30元。：这30元现在的分布是：老板拿25元，伙计拿2元，三人各拿1元，正好！</p><h2 id="25-蓝眼睛问题"><a href="#25-蓝眼睛问题" class="headerlink" title="25.蓝眼睛问题"></a>25.蓝眼睛问题</h2><p>有个岛上住着一群人，有一天来了个游客，定了一条奇怪的规矩：所有蓝眼睛的人都必须尽快离开这个岛。每晚8点会有一个航班离岛。每个人都看得见别人眼睛的颜色，但不知道自己的（别人也不可以告知）。此外，他们不知道岛上到底有多少人是蓝眼睛的，只知道至少有一个人的眼睛是蓝色的。所有蓝眼睛的人要花几天才能离开这个岛？</p><p>c=1<br>假设岛上所有人都是聪明的，蓝眼睛的人四处观察之后，发现没有人是蓝眼睛的。但他知道至少有一人是蓝眼睛的，于是就能推导出自己一定是蓝眼睛的。因此，他会搭乘当晚的飞机离开。 </p><p>c=2<br>两个蓝眼睛的人看到对方，并不确定c是1还是2，但是由上一种情况，他们知道，如果c = 1，那个蓝眼睛的人第一晚就会离岛。因此，发现另一个蓝眼睛的人仍在岛上，他一定能推断出c = 2，也就意味着他自己也是蓝眼睛的。于是，两个蓝眼睛的人都会在第二晚离岛。</p><p>c&gt;2<br>逐步提高c时，我们可以看出上述逻辑仍旧适用。如果c = 3，那么，这三个人会立即意识到有2到3人是蓝眼睛的。如果有两人是蓝眼睛的，那么这两人会在第二晚离岛。因此，如果过了第二晚另外两人还在岛上，每个蓝眼睛的人都能推断出c = 3，因此这三人都有蓝眼睛。他们会在第三晚离岛。 </p><p>不论c为什么值，都可以套用这个模式。所以，如果有c人是蓝眼睛的，则所有蓝眼睛的人要用c晚才能离岛，且都在同一晚离开。</p><h2 id="26-疯狗问题"><a href="#26-疯狗问题" class="headerlink" title="26.疯狗问题"></a>26.疯狗问题</h2><p>有50家人家，每家一条狗。有一天警察通知，50条狗当中有病狗，行为和正常狗不一样。每人只能通过观察别人家的狗来判断自己家的狗是否生病，而不能看自己家的狗，如果判断出自己家的狗病了，就必须当天一枪打死自己家的狗。结果，第一天没有，第二天没有，第三天开始一阵枪响，问：一共死了几条狗？</p><p>死了3条（第几天枪响就有几条）。<br>从有一条不正常的狗开始，显然第一天将会听到一声枪响。这里的要点是你只需站在那条不正常狗的主人的角度考虑。<br>有两条的话思路继续，只考虑有两条不正常狗的人，其余人无需考虑。通过第一天他们了解了对方的信息。第二天杀死自己的狗。换句话说每个人需要一天的时间证明自己的狗是正常的。有三条的话，同样只考虑那三个人，其中每一个人需要两天的时间证明自己的狗是正常的狗。</p><h2 id="27-耳光问题（跟蓝眼睛一样）"><a href="#27-耳光问题（跟蓝眼睛一样）" class="headerlink" title="27.耳光问题（跟蓝眼睛一样）"></a>27.耳光问题（跟蓝眼睛一样）</h2><p>一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其他人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？</p><p>答案：有三个人戴黑帽。假设有N个人戴黑帽，当N＝1时，戴黑帽的人看见别人都为白则能肯定自己为黑。于是第一次关灯就应该有声。可以断定N＞1。对于每个戴黑帽的人来说，他能看见N-1顶黑帽，并由此假定自己为白。但等待N-1次还没有人打自己以后，每个戴黑人都能知道自己也是黑的了。所以第N次关灯就有N个人打自己。</p><h2 id="28-红球篮球"><a href="#28-红球篮球" class="headerlink" title="28.红球篮球"></a>28.红球篮球</h2><p><strong>你有两个罐子，每个罐子各有若干红色弹球和蓝色弹球，两个罐子共有50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机从中选取出一个弹球，要使取出的是红球的概率最大，一开始两个罐子应放几个红球，几个蓝球？在你的计划中，得到红球的准确几率是多少？</strong></p><p>一个罐子放1红，一个罐子放49红和50蓝，这样得到红球的概率接近3/4。</p><h2 id="29-猜数字"><a href="#29-猜数字" class="headerlink" title="29.猜数字"></a>29.猜数字</h2><p>教授选出两个从2到9的数，把它们的和告诉学生甲，把它们的积告诉学生乙，让他们轮流猜这两个数， 甲说：“我猜不出”， 乙说：“我猜不出”， 甲说：“我猜到了”， 乙说：“我也猜到了”， 问这两个数是多少？</p><p>3和4。设两个数为n1，n2，n1&gt; =n2，甲听到的数为n=n1 n2，乙听到的数为m=n1*n2，证明n1=3，n2=4是唯一解。</p><p>证明：要证以上命题为真，不妨先证n=7</p><p>1)必要性：<br> 　　i) n&gt; 5 是显然的，因为n &lt;4不可能，n=4或者n=5甲都不可能回答不知道<br> 　　ii) n&gt; 6 因为如果n=6的话，那么甲虽然不知道(不确定2 4还是3 3)但是无论是2，4还是3，3乙都不可能说不知道(m=8或者m=9的话乙说不知道是没有道理的)<br> 　　iii) n &lt;8 因为如果n&gt; =8的话，就可以将n分解成 n=4 x 和 n=6 (x-2)，那么m可以是4x也可以是6(x-2)而4x=6(x-2)的必要条件是x=6即n=10，那样n又可以分解成8 2，所以总之当n&gt; =8时，n至少可以分解成两种不同的合数之和，这样乙说不知道的时候，甲就没有理由马上说知道。以上证明了必要性。<br>2)充分性<br>当n=7时，n可以分解成2 5或3 4<br>显然2 5不符合题意，舍去，容易判断出3 4符合题意，m=12，证毕<br>于是得到n=7 m=12 n1=3 n2=4是唯一解。</p><h2 id="30-水果标签问题"><a href="#30-水果标签问题" class="headerlink" title="30.水果标签问题"></a>30.水果标签问题</h2><p><strong>3个箱子里面放了 苹果，梨子，苹果加梨子，标签全错误，只能选择查看一箱的水果来改正所有标签</strong></p><p>查看贴苹果和梨标签那一个，如果拿出来的是苹果，代表这一箱只有苹果，因为如果是苹果和梨就代表标签没错了。<br>那么剩下的两箱就是梨，苹果和梨，剩下的标签是梨，苹果，由于标签全错，所以贴着苹果的是梨，贴着梨的是苹果和梨。<br>如果拿出来的是梨，同理代表这一箱只有梨。那么剩下的两箱就是苹果，苹果和梨，剩下的标签就是苹果，梨。由于标签全错，贴着苹果的就是苹果和梨，贴着梨的就是苹果。</p><h2 id="31-便士标签问题（和水果标签一样）"><a href="#31-便士标签问题（和水果标签一样）" class="headerlink" title="31.便士标签问题（和水果标签一样）"></a>31.便士标签问题（和水果标签一样）</h2><p>假设在桌上有三个密封的盒，一个盒中有2枚银币(1银币=10便士)，一个盒中有2枚镍币(1镍币=5便士)，还有一个盒中有1枚银币和1枚镍币。这些盒子被标上10便士、 15便士和20便士，但每个标签都是错误的。允许你从一个盒中拿出1枚硬币放在盒前，看到这枚硬币，你能否说出每个盒内装的东西呢？</p><h2 id="32-吃药问题"><a href="#32-吃药问题" class="headerlink" title="32.吃药问题"></a>32.吃药问题</h2><p>某种药方要求非常严格，你每天需要同时服用A、B两种药片各一颗，不能多也不能少。这种药非常贵，你不希望有任何一点的浪费。一天，你打开装药片A的药瓶，倒出一粒药片放在手心；然后打开另一个药瓶，但不小心倒出了两粒药片。现在，你手心上有一颗药片A，两颗药片B，并且你无法区别哪个是A，哪个是B。你如何才能严格遵循药方服用药片，并且不能有任何的浪费？</p><p>把手上的三片药各自切成两半，分成两堆摆放。再取出一粒药片A，也把它切成两半，然后在每一堆里加上半片的A。现在，每一堆药片恰好包含两个半片的A和两个半片的B。一天服用其中一堆即可。</p><h2 id="33-硬币问题"><a href="#33-硬币问题" class="headerlink" title="33.硬币问题"></a>33.硬币问题</h2><p>如何用一枚硬币等概率生成一个1到3之间的随机整数？如果这枚硬币是不公正的呢？</p><p>答案：如果是公正的硬币，则投掷两次，“正反”为1，“反正”为2，“正正”为3，“反反”重来。</p><p>如果是不公正的硬币，注意到出现“正反”和“反正”的概率一样，因此令“正反反正”、“反正正反”、“正反正反”分别为1、2、3，其余情况重来。另一种更妙的办法是，投掷三次硬币，“正反反”为1，“反正反”为2，“反反正”为3，其余情况重来。</p><h2 id="34-灯管问题"><a href="#34-灯管问题" class="headerlink" title="34.灯管问题"></a>34.灯管问题</h2><p><strong>在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？</strong></p><p>打开一个开关。过10分钟后关掉开关，并打开另一个开关。进屋确认可知：<br>亮的灯是由第二次打开的开关控制；<br>摸上去发热的不发亮的灯是由第一次打开的开关控制<br>剩下的第三盏灯是由未操作过的开关控制。</p><h2 id="35-盲人问题"><a href="#35-盲人问题" class="headerlink" title="35.盲人问题"></a>35.盲人问题</h2><p>他们都各自买了两对黑袜和两对白袜，八对袜了的布质、大小完全相同，而每对袜了都有一张商标纸连着。两位盲人不小心将八对袜了混在一起。 他们每人怎样才能取回黑袜和白袜各两对呢？</p><p>每一对分开，一人拿一只，因为袜子不分左右脚</p><h2 id="36-最大钻石问题"><a href="#36-最大钻石问题" class="headerlink" title="36.最大钻石问题"></a>36.最大钻石问题</h2><p><strong>一楼到十楼的每层电梯门口都放着一颗钻石，钻石大小不一。你乘坐电梯从一楼到十楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到最大的一颗？</strong></p><p>选择前五层楼都不拿，观察各层钻石的大小，做到心中有数。后面五个楼层再选择，选择大小接近前五层楼出现过最大钻石大小的钻石。</p><h2 id="37-飞机飞行的问题"><a href="#37-飞机飞行的问题" class="headerlink" title="37.飞机飞行的问题"></a>37.飞机飞行的问题</h2><p>有N架一样的飞机停靠在同一个机场，每架飞机都只有一个油箱，每箱油可使飞机绕地球飞半圈。注意：天空没有加油站，飞机之间只是可以相互 加油。 如果使某一架飞机平安地绕地球飞一圈，并安全地回到起飞时的机场，问：至少需要出动几架飞机？ 注：路途中间没有飞机场，每架飞机都必须安全返回起飞时的机场，不许中途降落。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一共需要6架飞机。假设绕地球一圈为1，3 架飞机同时顺时针飞，在1&#x2F;8 处 油量为 3&#x2F;4 3&#x2F;4 3&#x2F;4 其中一辆給另外两加满往回飞，此时油量为1，1，到1&#x2F;4 处 油量为3&#x2F;4，3&#x2F;4， 加满一辆，另一辆往回 2&#x2F;4 ，1，可以飞到3&#x2F;4 的位置 此时油量为0</span><br><span class="line"></span><br><span class="line">3架飞机往逆时针方向飞，在7&#x2F;8 位置3&#x2F;4， 3&#x2F;4， 3&#x2F;4 ，一架给另两加满然后往回飞 1，1，0，继续飞，在3&#x2F;4 位置 油量为 3&#x2F;4， 3&#x2F;4， 0 ， 平衡一下 2&#x2F;4 ，2&#x2F;4 ，2&#x2F;4 可以把之前的飞机接回去</span><br></pre></td></tr></table></figure><h2 id="38-犯人猜颜色"><a href="#38-犯人猜颜色" class="headerlink" title="38.犯人猜颜色"></a>38.犯人猜颜色</h2><p>一百个犯人站成一纵列，每人头上随机带上黑色或白色的帽子，各人不知道自己帽子的颜色，但是能看见自己前面所有人帽子的颜色．<br> 然后从最后一个犯人开始，每人只能用同一种声调和音量说一个字：”黑”或”白”，<br> 如果说中了自己帽子的颜色，就存活，说错了就拉出去斩了，<br> 说的答案所有犯人都能听见，<br> 是否说对，其他犯人不知道，<br> 在这之前，所有犯人可以聚在一起商量策略，<br> 问如果犯人都足够聪明而且反应足够快，100个人最大存活率是多少？ </p><p> 答案：这是一道经典推理题 </p><p> 1、最后一个人如果看到奇数顶黑帽子报“黑”否则报“白”，他可能死 </p><p> 2、其他人记住这个值（实际是黑帽奇偶数），在此之后当再听到黑时，黑帽数量减一 </p><p> 3、从倒数第二人开始，就有两个信息：记住的值与看到的值，相同报“白”，不同报“黑” </p><p> 99人能100%存活，1人50%能活 </p><p> 除此以外，此题还有变种：每个犯人只能看见前面一个人帽子颜色又能最多存活多少人？ </p><p> 答案：在上题基础上，限制了条件，这时上次的方法就不管用了，此时只能约定偶数位犯人说他前一个人的帽子颜色，奇数犯人获取信息100%存活，偶数犯人50几率存活。</p><h2 id="39-猴子搬香蕉"><a href="#39-猴子搬香蕉" class="headerlink" title="39.猴子搬香蕉"></a>39.猴子搬香蕉</h2><p>一个小猴子边上有100根香蕉，它要走过50米才能到家，每次它最多搬50根香蕉，（多了就被压死了），它每走 </p><p> 1米就要吃掉一根，请问它最多能把多少根香蕉搬到家里。（提示：他可以把香蕉放下往返的走，但是必须保证它每走一米都能有香蕉吃。也可以走到n米时，放下一些香蕉，拿着n根香蕉走回去重新搬50根。） </p><p> 答案：这种试题通常有一个迷惑点，让人看不懂题目的意图。此题迷惑点在于：走一米吃一根香蕉，一共走50米，那不是把50根香蕉吃完了吗？如果要回去搬另外50根香蕉，则往回走的时候也要吃香蕉，这样每走一米需要吃掉三根香蕉，走50米岂不是需要150根香蕉？ </p><p> 其实不然，本题关键点在于：猴子搬箱子的过程其实分为两个阶段，第一阶段：来回搬，当香蕉数目大于50根时，猴子每搬一米需要吃掉三根香蕉。第二阶段：香蕉数《=50，直接搬回去。每走一米吃掉1根。 </p><p> 我们分析第一阶段：假如把100根香蕉分为两箱。一箱50根。 </p><p> 第一步，把A箱搬一米，吃一根。 </p><p> 第二步，往回走一米，吃一根。 </p><p> 第三步，把B箱搬一米，吃一根。 </p><p> 这样，把所有香蕉搬走一米需要吃掉三根香蕉。 </p><p> 这样走到第几米的时候，香蕉数刚好小于50呢？ </p><p> 100-(n<em>3)&lt;50 &amp;&amp; 100-(n-1</em>3)&gt;50 </p><p> 走到16米的时候，吃掉48根香蕉，剩52根香蕉。这步很有意思，它可以直接搬50往前走，也可以再来回搬一次，但结果都是一样的。到17米的时候，猴子还有49根香蕉。这时猴子就轻松啦。直接背着走就行。 </p><p> 第二阶段： </p><p> 走一米吃一根。 </p><p> 把剩下的50-17=33米走完。还剩49-33=16根香蕉。</p><h2 id="40-轮流拿石头"><a href="#40-轮流拿石头" class="headerlink" title="40.轮流拿石头"></a>40.轮流拿石头</h2><p>问题：一共有N颗石子（或者其他乱七八糟的东西），每次最多取M颗最少取1颗，A，B轮流取，谁最后会获胜？（假设他们每次都取最优解）。</p><p>例子：有10个石头，每人每次可以拿1-2个，轮流拿，最后一个拿的人算输，有什么必赢的方案。</p><p>先说结论：</p><p>假如A先取，N&lt;M，A获胜；</p><p>　　　　　  N&gt;M，若N能被（M + 1）整除时，A失败；</p><p>　　　　　　　　  若N不能被（M + 1）整除时，A获胜；</p><p>假如B先取，（同上）；</p><p>N&gt;M时，A要想赢，必须要在自己倒数第二次取完的时候还剩下（M + 1）颗石子（此时A和B还可以再取一次就可以分出胜负游戏就结束了），这样不论B取几颗，A都获胜！但是要怎样才能控制最后一轮的石子数量？</p><p>分两种情况分析，</p><ol><li>N不能被（M + 1）整除，A先拿走n颗石子（使得剩下的石子数量是（M + 1）的整数倍），那么下一次B拿走k颗石子时，A就拿走（M + 1）- k颗石子。这样不论B怎么拿A总能控制剩下的石子数量是（M + 1）的整数倍，那么最后一轮一定剩下（M + 1）颗石子；</li><li>N能被（M + 1）整除，A就认输吧。。。（B除非傻才会让A赢）无论A怎么拿，B可以控制石子数量（即当B拿完后总能使剩下的石子数量是（M + 1）的整数倍)，在最后一轮之前B拿完后还剩（M + 1）颗，A拿多少颗都是输。</li></ol><p><a href="https://www.cnblogs.com/StrayWolf/p/5396427.html" target="_blank" rel="noopener">https://www.cnblogs.com/StrayWolf/p/5396427.html</a></p><p> 答案：较复杂的尼姆博弈：<a href="https://blog.csdn.net/BBHHTT/article/details/80199541" target="_blank" rel="noopener">https://blog.csdn.net/BBHHTT/article/details/80199541</a></p><p>母题：有若干堆石子，每堆石子的数量是有限的，二个人依次从这些石子堆中拿取任意的石子，至少一个（不能不取），最后一个拿光石子的人胜利。</p><p>1、我们首先以一堆为例： 假设现在只有一堆石子，你的最佳选择是将所有石子全部拿走，那么你就赢了。</p><p>2、如果是两堆：假设现在有两堆石子且数量不相同，那么你的最佳选择是取走多的那堆石子中多出来的那几个，使得两堆石子数量相同，这样，不管另一个怎么取，你都可以在另一堆中和他取相同的个数，这样的局面你就是必胜。比如有两堆石子，第一堆有3个，第二堆有5个，这时候你要拿走第二堆的三个，然后两堆就都变成了3个，这时你的对手无论怎么操作，你都可以“学”他，比如他在第一堆拿走两个，你就在第二堆拿走两个，这样你就是稳赢的</p><h2 id="41-蚂蚁走树枝"><a href="#41-蚂蚁走树枝" class="headerlink" title="41. 蚂蚁走树枝"></a>41. 蚂蚁走树枝</h2><p> 问题：放N只蚂蚁在一条长度为M树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。 </p><p> 答案：这个其实就一个诀窍：蚂蚁相碰就往反方向走，可以直接看做没有发生任何事：大家都相当于独立的 </p><p>  A蚂蚁与B蚂蚁相碰后你可以看做没有发生这次碰撞，这样无论是求时间还是距离都很简单了。</p><h2 id="42-三个火枪手"><a href="#42-三个火枪手" class="headerlink" title="42.三个火枪手"></a>42.三个火枪手</h2><p>问题：彼此痛恨的甲、乙、丙三个枪手准备决斗。甲枪法最好，十发八中；乙枪法次之，十发六中；丙枪法最差，十发四中。如果三人同时***，并且每人每轮只发一枪；那么枪战后，谁活下来的机会大一些？ </p><p> 答案： </p><p> 一般人认为甲的枪法好，活下来的可能性大一些。但合乎推理的结论是，枪法最糟糕的丙活下来的几率最大。 </p><p> 那么我们先来分析一下各个枪手的策略。 </p><p> 如同田忌赛马一般，枪手甲一定要对枪手乙先***。因为乙对甲的威胁要比丙对甲的威胁更大，甲应该首先干掉乙，这是甲的最佳策略。 </p><p> 同样的道理，枪手乙的最佳策略是第一枪瞄准甲。乙一旦将甲干掉，乙和丙进行对决，乙胜算的概率自然大很多。 </p><p> 枪手丙的最佳策略也是先对甲***。乙的枪法毕竟比甲差一些，丙先把甲干掉再与乙进行对决，丙的存活概率还是要高一些。 </p><p> 我们根据分析来计算一下三个枪手在上述情况下的存活几率：<br> 第一轮：甲射乙，乙射甲，丙射甲。<br> 甲的活率为24%（40% X 60%） </p><p> 乙的活率为20%(100% - 80%) </p><p> 丙的活率为100%（无人射丙）。 </p><p> 由于丙100％存活率，因此根据上轮甲乙存活的情况来计算三人第二轮的存活几率： </p><p> 情况1：甲活乙死（24% X 80% = 19.2%）<br> 甲射丙，丙射甲：甲的活率为60%，丙的活率为20%。<br> 情况2：乙活甲死（20% X 76% = 15.2%）<br> 乙射丙，丙射乙：乙的活率为60%，丙的活率为40%。<br> 情况3：甲乙同活（24% X 20% = 4.8%）<br> 重复第一轮。<br> 情况4：甲乙同死（76% X 80% = 60.8%）<br> 枪战结束。 </p><p> 据此来计算三人活率：<br> 甲的活率为(19.2% X 60%) + (4.8% X 24%) = 12.672%<br> 乙的活率为(15.2% X 60%) + (4.8% X 20%) = 10.08%<br> 丙的活率为(19.2% X 20%) + (15.2% X 40%) + (4.8% X 100%) + (60.8% X 100%) = 75.52% </p><p> 通过对两轮枪战的详细概率计算，我们发现枪法最差的丙存活的几率最大，枪法较好的甲和乙的存活几率却远低于丙的存活几率。</p><h2 id="43-囚犯拿豆子"><a href="#43-囚犯拿豆子" class="headerlink" title="43.囚犯拿豆子"></a>43.囚犯拿豆子</h2><p>问题：有5个囚犯被判了死刑，他们请求上诉，于是法官愿意给他们一个机会。 </p><p> 犯人抽签分好顺序，按序每人从100粒豆子中随意抓取，最多可以全抓，最少可以不抓，可以和别人抓的一样多。 </p><p> 最终，抓的最多的和最少的要被处死。 </p><p> 1、他们都是非常聪明且自私的人。 </p><p> 2、他们的原则是先求保命。如果不能保命，就拉人陪葬。 </p><p> 3、100颗不必都分完。 </p><p> 4、若有重复的情况，则也算最大或最小，一并处死（中间重复不算）。 </p><p> 假设每个犯人都足够聪明，但每个犯人并不知道其他犯人足够聪明。那么，谁活下来的可能性最大？</p><p>根据题意，一号知道有五个人抓豆子，为保性命，他只要让豆子在20颗以内就可以了。但是他足够聪明的话他一定拿20颗，因为无论多拿一颗：2,3,4号的人一定会拿20颗最后死的人就会是最多的1号和最少的5号  还是少拿一颗：2,3,4号拿20个后，5号选择也拿20个拉上1234号垫背。（下面会说为什么多拿少拿也只会相差一颗） </p><p> 2号是知道1号抓了几颗豆子(20)的。那么，对于2号来说，只有2种选择：与1号一样多，或者不一样多。我们就从这里入手。 </p><p> 情况一，假如2号选择与1号的豆子数不一样多，也就是说2号选择比1号多或者比1号少。 </p><p> 我们先要证明，如果2号选择比1号多或者比1号少，那么他一定会选择比1号只多1颗或者只少1颗。 </p><p> 要证明这个并不算太难。因为每个囚犯的第一选择是先求保命，要保命就要尽量使自己的豆子数既不是最多也不是最少。当2号决定选择比1号多的时候，他已经可以保证自己不是最少，为了尽量使自己不是最多，当然比1号多出来的数量越小越好。因为这个数量如果与一号相差大于1的话，那么3号就有机会抓到的居中数，相差越大，二号成为最多的可能性也就越大。反之，当2号决定选择比1号少的时候，也是同样的道理，他会选择只比1号少1颗。既然2号只会会选择比1号多1颗或者比1号少1颗，那么1、2号的豆子数一定是2个连续的自然数，和一定是2n+1（其中1个人是n,另1人是n+1）。 </p><p> 轮到3号的时候，他可以从剩下的豆子数知道1、2号的数量和，也就不难计算出n的值。而3号也只有2个选择：n颗或者n+1颗。为什么呢？这与上面的证明是一样的道理，保命原则，取最接近的数量，这里不再赘述。 </p><p> 不过，3号选择的时候会有一个特殊情况，在这一情况下，他一定会选择较小的n，而不是较大的n+1。这一特殊情况就是，当3号知道自己选择了n后(已保证自己不是最多)，剩下的豆子数由于数量有限，4、5号中一定有人比n要少，这样自己一定可以活下来。计算的话就是 [100-(3n+1)]/2&lt;=n ，不难算出，在这个特殊情况下，n&gt;=20。也就是说，当1、2号选择了20或21颗的时候，3号只要选择20颗，就可以保证自己活下来。 </p><p> 这样一来剩下的豆子只剩39颗，4、5号至少有一人少于20颗的（这个人当然是后选的5号），这样死的将是5号和1、2号中选21颗的那个人。当然，1号、2号肯定不会有人选择21这一“倒霉”的数字（因为他们都是聪明人），这样的话，上述“特殊情况（即3号选择n）”就不会发生了。 </p><p> 综上所述，2345这四个人不难从剩下的豆子数知道前面几个人的数量总和，也就不难进而计算出n的值，而这样一来他们也只有n或者n+1这两种选择。最后的5号也是不难算出n的。在前4个人只选择了2个数字(n和n+1)的情况下，5号已是必死无疑，这时,根据“死也要拉几个垫背”的条件，5号会选择n或n+1，选择5个人一起完蛋。 </p><p> 情况二，如果2号选择了与1号不一样多的话，最终结果是5个人一起死，那么2号只有选择与1号一样多了。 </p><p> 那么1、2号的和就是2n，而3号如果选择n+1或者n -1的话，就又回到第一点的情况去了(前3个人的和是3m+1或3m+2)，于是3号也只能选择n ，当然，4号还是只能选n，最后的结果仍旧是5个人一起完蛋。 </p><p> “最后处死抓的最多和最少的囚犯”严格执行这句话的话，除非有人舍己为人，死二留三。但这是足够聪明且自私的囚犯，所以这五个聪明人的下场是全死，这道题只不过是找了一个处死所有人的借口罢了. . . . . . </p><p> 变种问题：如果每个囚犯都知道其他囚犯足够聪明，事情会怎么发展？ </p><p> 答案： </p><p> 这样的情况下囚犯一也会像我们一样推导出前面的结论，那么根据自私的规定，他会直接拿完100个，大家一起完蛋(反正结局已定) </p><h2 id="44-学生猜生日-lt-笔试高频-gt"><a href="#44-学生猜生日-lt-笔试高频-gt" class="headerlink" title="44.学生猜生日&lt;笔试高频&gt;"></a>44.学生猜生日&lt;笔试高频&gt;</h2><p>这种题目笔试中出现的次数比较多，用排除法比较好解决</p><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p> 小明和小强都是张老师的学生，张老师的生日是M月N日, </p><p> 2人都知道张老师的生日是下列10组中的一天，张老师把M值告诉了小明, </p><p> 把N值告诉了小强，张老师问他们知道他的生日是那一天吗? </p><p> 3月4日 3月5日 3月8日 </p><p> 6月4日 6月7日 </p><p> 9月1日 9月5日 </p><p> 12月1日 12月2日 12月8日 </p><p> 小明说:如果我不知道的话，小强肯定也不知道. </p><p> 小强说:本来我也不知道，但是现在我知道了. </p><p> 小明说:哦，那我也知道了. </p><p> 请根据以上对话推断出张老师的生日是哪一天? </p><p> 答案：9月1日 </p><p> 排除法： </p><p> 1.小明肯定小强不知道是哪天，排除所有月份里有单独日的月份：6月和12月&lt;因为如果小强的M是2或者7的话，小强就知道了，所以把6月7日与12月2日排除&gt;，所以小明拿到的是3或者9 </p><p> 2.小强本来不知道，所以小强拿到的不是2或者7，但是小强现在知道了，说明把6月与12月排除后，小强拿到的是1,4,8中的一个&lt;这里小强肯定没拿到5，否则他不会知道是哪天的&gt; </p><p> 3.小明现在也知道了，说明小明拿到的不是3，否则他不会知道是3月4日还是3月8日的，所以小明拿到的是9才能唯一确定生日 </p><p> 综上，答案是9月1日 </p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p> 小明和小强是赵老师的学生，张老师的生日是M月N日，张老师 </p><p> 把M值告诉小明，N值告诉小强 </p><p> 给他们六个选项 </p><p> 3月1日 3月3日 7月3日 7月5日  </p><p> 9月1日 11月7日 </p><p> 小明说:我猜不出来 </p><p> 小强说:本来我也猜不出来，但是现在我知道了 </p><p> 问:张老师生日多少 </p><p> 答案：3月1日 </p><p> 排除法： </p><p> 1.小明说猜不出来，说明小明拿到的不是单独出现的9或者11，说明老师生日只能是3月或者7月 </p><p> 2.小强原本不知道，说明小强拿到的不是单独出现的5或者7，说明老是生日是1日或3日 </p><p> 3.小强现在知道了，说明小强拿到的是1，因为如果拿到的是3，那么小强就不知道是3月3日还是7月3日了 </p><p>   综上，老师生日是3月1日  </p><h2 id="45-火车开车问题"><a href="#45-火车开车问题" class="headerlink" title="45.火车开车问题"></a>45.火车开车问题</h2><p>有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以每小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和两辆火车现时启动，从洛杉矶出发，碰到另一辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，假设洛杉矶到纽约的距离为s, 请问，这只小鸟飞行了多长距离？</p><p>那小鸟飞行的距离就是(s/(15+20))*30。 时间 * 速度</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="网络协议分层"><a href="#网络协议分层" class="headerlink" title="网络协议分层"></a>网络协议分层</h2><p>国际标准化组织 ISO 提出了 OSI 开放互连的七层计算机网络模型，从上到下分别是应用层、表示层、会话层、运输层、网络层、链路层和物理层。OSI 模型的概念清楚，理论也比较完善，但是既复杂又不实用。还有一种是 TCP/IP 体系结构，它分为四层，从上到下分别是应用层、运输层、网际层和网络接口层，不过从实质上将只有三层，因为最下面的网络接口层并没有什么具体内容。因特网的协议栈使用一种五层的模型结构，从上到下依次是<strong>应用层、运输层、网络层、链路层和物理层</strong>，其中下层是为上层提供服务的，每层执行某些动作或使用下层的服务来提高服务。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层是网络体系结构中的最高层，应用层的任务就是<strong>通过应用进程之间的交互来完成特定网络应用</strong>，这一层的数据单元叫做<strong>报文</strong>。</p><p>应用层的协议定义了<strong>应用进程之间通信和交互的规则</strong>，主要包括了域名系统 DNS、支持万维网的 HTTP 协议、支持电子邮件的 SMTP 协议、文件传输协议 FTP 等。</p><p><strong>域名解析系统 DNS</strong></p><p>DNS 被设计为一个联机分布式数据库系统，并采用客户服务器方式。DNS 使大多数名字都在本地进行解析，仅少量解析需要在互联网上通信，因此 DNS 的效率很高。由于 DNS 是分布式系统，即使单个计算机出现了故障也不会妨碍到整个 DNS 系统的正常运行。</p><p><strong>主机向本地域名服务器的查询一般都采用递归查询</strong>，递归查询指如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份向其他根域名服务器继续发出查询请求报文。递归查询的结果是要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</p><p><strong>本地域名服务器向根域名服务器查询通常采用迭代查询</strong>，迭代查询指当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉它该向哪一个域名服务器进行查询。本地域名服务器也可以采用递归查询，这取决于最初的查询请求报文设置的查询方式。</p><p><strong>文件传送协议 FTP</strong></p><p>FTP 使用 TCP 可靠的运输服务，FTP 使用客户服务器方式，一个 FTP 服务器进程可以同时为多个客户进程提供服务，在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：控制连接和数据连接，实际用于传输文件的是数据连接。</p><p><strong>电子邮件系统协议 SMTP/POP3/IMAP</strong></p><p>一个电子邮件系统有三个主要组成构件，即用户代理、邮件服务器、以及邮件协议。</p><p>从用户代理把邮件传送到邮件服务器，以及在邮件服务器之间的传送都要使用 SMTP，但用户代理从邮件服务器读取邮件时则要使用 POP3 或 IMAP 协议。</p><p>基于万维网的电子邮件使用户可以利用浏览器收发电子邮件，用户浏览器和邮件服务器之间使用 HTTP 协议，而邮件服务器之间的传送仍然使用 SMTP 协议。</p><p><strong>DHCP (Dynamic Host Configuration Protocol) 动态主机配置协议</strong></p><p>提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><ol><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li></ol><p><strong>子网掩码的作用</strong></p><p>子网掩码的作用: </p><p>1、用于将一个大的IP网络划分为若干小的子网络：</p><p>因为随着互联网的发展，越来越多的网络产生，有的网络多则几百台，有的只有区区几台，这样就浪费了很多IP地址，所以要划分子网。使用子网可以提高网络应用的效率。</p><p>2、用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上：</p><hr><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>运输层的任务就是<strong>负责向两台主机中进程之间的通信提供通用的数据传输服务</strong>，应用进程利用该服务来传送应用层报文。由于一台主机同时可以运行多个进程，因此运输层具有复用和分用的功能，复用就是多个应用层进程可以同时使用下面运输层的服务，分用就是把运输层收到的信息分别交付给上面应用层中的对应进程。</p><p>运输层主要使用两种协议：① 用户数据报协议 UDP，这是一种提供无连接的、尽最大努力交付的数据传输服务，不保证数据传输的可靠性，数据传输单位是用户数据报。② 传输控制协议 TCP，这是一种面向连接的、可靠的数据传输服务，数据传输单元是报文。</p><hr><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层负责<strong>为分组交换网上的不同主机提供通信服务</strong>，在发生数据时，网络层把数据层产生的报文或用户数据报封装成<strong>分组</strong>进行传送，由于网络层使用 IP 协议，因此分组也叫 <strong>IP 数据报</strong>。网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。</p><p>网络层的协议包括了网际协议 IP、地址解析协议 ARP、网际控制报文协议 ICMP 以及路由选择协议 RIP/OSPF/BGP-4 等。</p><p><strong>网际协议 IP</strong></p><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，一般指的是 IPv4。与 IP 协议配套使用的协议还有 ARP、ICMP 和 IGMP，IP 使用 ARP，ICMP 和 IGMP 要使用 IP。由于网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP/IP 体系中的网络层也称网际层或 IP 层。要解决 IP 地址耗尽的问题，根本方法是采用具有更大地址空间的新版本 IP 协议即 IPv6，向 IPv6 过渡可以使用双协议栈或使用隧道技术。</p><p><strong>地址解析协议 ARP</strong></p><p>由于 IP 协议使用了 ARP 协议，因此把 ARP 协议归到网络层，但 ARP 的作用是通过一个 ARP 高速缓存存储本地局域网的各主机和路由器的 IP 地址到硬件地址的映射表，以从网络层的 IP 地址解析出在数据链路层使用的硬件地址，因此也可以把 ARP 划归在数据链路层。与 ARP 对应的协议是 RARP，逆地址解析协议，作用是使只知道自己硬件地址的主机能够找出 IP 地址，但被 DHCP 协议取代。</p><p><strong>路由选择协议 RIP/OSPF/BGP-4</strong></p><p>路由选择协议有两大类：内部网关协议，如 RIP 和 OSPF；外部网关协议，如 BGP-4。</p><p>RIP 是分布式的基于距离向量的路由选择协议，只适用于小型互联网。RIP 按照固定的时间间隔与相邻路由器交换信息，交换的信息是当前路由表。OSPF 是分布式的链路状态协议，适用于大型互联网，只在链路状态发生变化时才向本自治系统中的所有路由器用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。</p><p>BGP-4 是不同自治系统的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。其目标是寻找一条能够到达目的网络且比较好的路由而不是最佳路由。</p><p><strong>网际控制报文协议 ICMP</strong></p><p>ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去，<strong>使用 ICMP 并非为了实现可靠传输</strong>，ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p><p>ICMP 的一个重要应用就是分组间探测 PING，用来测试两台主机之间的连通性，PING 使用了 ICMP 回送请求与回送回答报文。</p><p><strong>Ping</strong></p><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。应答数据包的类型字段为 0，构建新的ICMP数据包，发回给主机A，此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p><strong>Traceroute</strong><br>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文</p><ul><li><p>Traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。将TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了。如果中间的路由器不止一个，当然碰到第一个就“牺牲”。于是，返回一个 ICMP 包，也就是网络差错包，类型是时间超时。接下来，将 TTL 设置为2.。。这样，Traceroute 就拿到了所有的路由器 IP。怎么知道 UDP 有没有到达目的主机呢？Traceroute 程序会发送一份 UDP 数据报给目的主机，但它会选择一个不可能的值作为 UDP 端口号（大于 30000）。当该数据报到达时，将使目的主机的 UDP 模块产生一份“端口不可达”错误 ICMP 报文。如果数据报没有到达，则可能是超时</p></li><li><p>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。要做的工作首先是发送分组，并设置“不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包.</p></li></ul><p><strong>网际组管理协议 IGMP</strong></p><p>IP 多播使用 IGMP 协议，IGMP 并非在互联网范围内对所有多播组成员进行管理，它不知道 IP 多播组包含的成员个数也不知道这些成员都分布在哪些网络上。</p><p>IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机上的某个进程参加或推出了某个多播组。</p><hr><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>数据链路层的任务是<strong>将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻结点之间的链路上传输帧，每一帧包括数据和必要的控制信息（同步信息、地址信息、差错控制等）。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始到哪个比特结束，这样链路层就可以从帧中提取出数据部分上交给网络层。控制信息还使接收端能够检测到所收到的帧有无差错，如果有差错就简单地丢弃这个帧以免继续传送而浪费网络资源。</p><p>数据链路层的协议包括了点对点协议 PPP 和 CSMA/CD 协议等。</p><p><strong>点对点协议 PPP</strong></p><p>在通信线路质量较差的年代，使用高级数据链路控制 HDLC 作为实现可靠传输的数据链路层协议，但现在 HDLC 已经很少使用了，对于点对点的链路，简单得多的点对点协议 PPP 是目前使用得最广泛的数据链路层协议。PPP 协议的特点是简单、只检测差错而不纠正差错、不使用序号也不进行流量控制、可同时支持多种网络层协议。</p><p><strong>CSMA/CD 协议</strong></p><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><p>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</p></li><li><p>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</p></li><li><p>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</p></li></ul><p>记端到端的传播时延为 t，最先发送的站点最多经过 2t就可以知道是否发生了碰撞，称 2t 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2^k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><hr><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层的任务是尽可能地<strong>屏蔽掉传输媒体和通信手段的差异</strong>，使物理层上面的数据链路层感觉不到这些差异，使其只需考虑本层的协议和服务。</p><p>物理层所传输的数据单位是比特，发送方发送 1 或 0，接收方也接收 1 或 0，因此物理层需要考虑用多大的电压代表 1 或 0，以及接收方如何识别出发送方所发送的比特。除此之外，物理层还要确定连接电缆的插头应当有多少根引以及各引脚如何连接等问题。</p><hr><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题</p><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>建立及管理会话。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP-特点"><a href="#TCP-特点" class="headerlink" title="TCP 特点"></a>TCP 特点</h3><p><strong>TCP 是面向连接的运输层协议</strong>，一个应用进程在向另一个进程发送数据之前，两个进程必须先建立 TCP 连接，发送某些预备报文段，建立确保数据传输的参数。作为 TCP 连接建立的一部分，连接双方都将初始化与 TCP 连接相关的许多状态变量。这种连接不是电路交换网络中的端到端电路这种物理连接，而是一种逻辑连接，TCP 报文要先传送到 IP 层加上 IP 首部后，再传到数据链路层，加上链路层的首部和尾部后才离开主机发送到物理层。</p><p><strong>TCP 连接提供全双工服务</strong>，允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都有各自的发送缓存和接收缓存，用来临时存放通信数据。在发送时，应用程序把数据传送给 TCP 缓存后就可以做自己的事，而 TCP 在合适的时候会把数据发送出去。在接收时，TCP 把收到的数据放入缓存，上层应用程序会在合适的时候读取缓存数据。</p><p><strong>TCP 连接是点对点的</strong>，每一条 TCP 连接只能有两个端点，即只能是单个发送方和单个接收方之间的连接。</p><p><strong>TCP 提供可靠的交付服务</strong>，通过 TCP 连接传送的数据无差错、不丢失、不重复，按序到达。</p><p><strong>TCP 是面向字节流的</strong>，流是指流入到进程或从进程中流出的字节序列。面向字节流的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但是 TCP 把应用程序交下来的数据仅仅看成一连串无结构的字节流。TCP 不保证接收方应用程序收到的数据块和发送方应用程序发出的数据块具有对应大小的关系，但是接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。接收方应用程序必须有能力识别收到的字节流，并把它还原成有意义的应用层数据。</p><hr><h3 id="TCP-报文结构"><a href="#TCP-报文结构" class="headerlink" title="TCP 报文结构"></a>TCP 报文结构</h3><p><img src="https://uploadfiles.nowcoder.com/files/20200810/176673786_1597021487780_27194088468_4cb0141fc8_b.jpg" alt="img"></p><p>TCP 传送的数据单元是报文段，一个 TCP 报文段分为首部和数据两部分。首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项，因此 TCP 首部的最小长度是 20 字节.TCP 首部的重要字段如下：</p><p><strong>源端口和目的端口：</strong>各占 2 字节，分别写入源端口号和目的端口号，TCP 的分用功能是通过端口实现的，分用就是指运输层从 IP 层收到发送给各应用进程的数据后，把数据交付给正确的套接字的工作。</p><p><strong>序号：</strong>占 4 字节。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号，首部中的序号字段值指的是本报文段所发送的数据的第一个字节的序号。序号使用 mod2^32^ 计算，每增加到 2^31^-1 后下一个序号就又回到 0。</p><p><strong>确认号：</strong>占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，代表到序号 N-1 为止的所有数据已经正确收到。序号有 32 位长，一般情况下可以保证当序号重复使用时，旧序号的数据早已通过网络到达终点了。</p><p><strong>数据偏移：</strong>占 4 字节，实际是TCP 报文段的首部长度，指出了 TCP 报文段的数据起始处到 TCP 报文段的起始处的距离。由于首部中有长度不确定的选项字段，因此数据偏移字段是必要的。</p><p><strong>标志字段：</strong>占 6 位。URG 是紧急标志，URG=1 时告诉系统此报文段中有紧急数据，应尽快传送，而不按照原来的排队顺序传送，和紧急指针配合使用，紧急指针指出了本报文段中紧急数据的字节数和位置。ACK 是确认标志，ACK=1 时表示成功接收了报文段。SYN 是同步标志，在建立连接时用来同步序号，当 SYN=1 而 ACK=0 时，表示一个连接请求报文段，响应时 SYN 和 ACK 都为 1，因此 SYN=1 表示一个连接请求或连接响应报文。FIN 是终止标志，用来释放一个连接，当 FIN=1 时表示报文段发送方的数据已发送完毕，并要求释放连接。PSH 是推送标志，PSH=1 时接收方就不等待整个缓存填满了再向上交付而是尽快交付数据。RST 是复位标志，当 RST=1 时表示 TCP 连接出现了严重错误，必须释放连接再重新建立连接。</p><p><strong>接收窗口：</strong>占 2 字节，指的是发送本报文段一方的接收窗口，告诉对方从本报文首部的确认号算起允许对方发送的数据量。窗口值是用来限制发送方的发送窗口的，因为接收方的数据缓存空间是有限的。</p><p><strong>检验和：</strong>占 2 字节，检验范围包括首部和数据两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p><hr><h3 id="可靠传输协议-ARQ"><a href="#可靠传输协议-ARQ" class="headerlink" title="可靠传输协议 ARQ"></a>可靠传输协议 ARQ</h3><p>自动重传请求 ARQ 包括了停止等待协议、回退 N 步协议和选择重传协议，后两种结合了窗口机制，属于连续 ARQ 协议。</p><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>停止等待就是每发送完一个分组就停止发送，等待对方的确认，在收到确认之后再发送下一个分组。停止等待协议包括了三种情况：</p><p><strong>1. 无差错情况</strong></p><p>A 发送分组 M<del>1</del>，发送完后就暂停并等待 B 的确认。B 收到了 M<del>1</del> 之后就向 A 发送确认，当 A 收到确认之后就再发送下一个分组 M<del>2</del>。</p><p><strong>2. 出现差错的情况</strong></p><p>当 B 收到 M<del>1</del> 时检测出了差错就丢弃了 M<del>1</del>，其他什么也不做，也可能是 M<del>1</del> 在传输过程中丢失了，B 什么都不知道。在这两种情况下 B 都不会发送任何确认信息，解决方法是：A 只要超过一段时间没有收到确认就认为刚才发送的分组丢失了，因而重传前面发过的分组，这就叫<strong>超时重传</strong>。要实现超时重传，就要在每发送完一个分组时设置一个<strong>超时计时器</strong>，如果在超时计时器到期之间收到了对方的确认就进行撤销。</p><p>有三点需要注意：① A 在发送完一个分组后必须暂时保留已发送分组的副本在超时重传时使用，只有在收到确认后才清除副本。② 分组和确认分组都必须进行编号，这样才能明确是哪一个发送出去的分组进行了确认。③ 超时计时器设置的时间应当比数据在分组传输的平均往返时间稍长一些，如果设置过短会产生不必要的重传，如果设置过长会降低通信效率。</p><p><strong>3. 确认丢失和确认迟到</strong></p><p>B 发送的对 M<del>1</del> 的确认丢失了，A 在设定的超时重传时间内没有收到确认，并不知道是自己发送的问题还是 B 的问题，因此 A 就会超时重传。假设 B 又收到了重传分组 M<del>1</del>，此时 B 会采取两个行动：① 丢弃这个分组，不向上层交付。② 重新向 A 发送确认。</p><p>还有另一种情况就是 B 发送的确认并没有丢失但是迟到了，A 会受到重复的确认，此时 A 会收下并丢弃。通常 A 最终总是可以收到对所有发出的分组的确认，如果 A 不断重传分组但总是收不到确认，就说明通信线路质量太差，不能进行通信。</p><p>停止等待协议的优点是简单，但缺点是信道利用率太低。为了提高传输效率，发送方可以不使用停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发送完一个分组就停下来等待对方的确认。这样可以使信道上一直有数据不间断地传送，流水线传输中可能会遇到差错，解决差错的两种基本方法是回退 N 步和选择重传。</p><hr><h4 id="回退-N-步协议"><a href="#回退-N-步协议" class="headerlink" title="回退 N 步协议"></a>回退 N 步协议</h4><p>在回退 N 步即 GBN 协议中，允许发送方发送多个分组而不需要等待确认。在 GBN 中发送方看到的序号可以分为四个范围，已经发送且被确认的的序号、已经发送还未确认的序号、允许发送但还未发送的序号和不允许发送的序号。其中已经发送但还未确认的序号和允许发送但还未发送的序号可以被看作一个长度为 N 的窗口，随着协议的运行该窗口在序号空间向前滑动，因此 GBN 协议也被称为滑动窗口协议。</p><p>GBN 发送方必须响应三种类型的事件：</p><ul><li><p><strong>上层的调用</strong></p><p>当上层调用发送方法时，发送方首先检查发送窗口是否已满，即是否有 N 个已发送但未确认的分组。如果窗口未满，则产生一个分组并将其发送并更新相应变量，如果窗口已满，发送方指需将数据返回给上层，隐式说明该窗口已满。实际实现中，发送方更可能缓存而不是立即发送这些数据，或者使用同步机制允许上层在仅当窗口不满时才调用发送方法。</p></li><li><p><strong>收到一个 ACK</strong></p><p>在 GBN 协议中，对序号为 n 的分组确认采用累积确认的方式，对按序到达的最后一个分组发送确认，表明接收方已经正确接收到序号为 n 的以前且包括 n 在内的所有分组。例如发送了序号为 1~5 的五个分组，除了第三个全部收到了，那么确认序号就是 2。</p></li><li><p><strong>超时事件</strong></p><p>回退 N 步的名字来源于出现丢失和时延过长时发送方的行为，就像在停止等待协议中那样，如果超时，发送方会重传所有已经发送但还未确认过的分组。如果收到一个 ACK，但仍有已发送但未确认的分组，则计时器也会重新启动。</p></li></ul><p>在 GBN 协议中，接收方丢弃所有失序分组，即使是正确接收的也要丢弃，这样做的理由是接收方必须按序将数据交付给上层。这种做法的优点是接收缓存简单，即接收方不需要缓存任何失序分组。不过丢弃一个正确失序分组的缺点是随后对该分组的重传也许也会错误，而导致更多的重传。</p><hr><h4 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h4><p>GBN 协议潜在地允许用多个分组填充流水线，因此避免了停止等待协议中的信道利用问题，但是 GBN 本身也存在性能问题，单个分组的差错就能引起 GBN 重传大量分组，许多分组根本没有重传必要。随着信道差错率的增加，流水线会被不必要重传的分组所充斥。</p><p>选择重传即 SR 协议，通过让发送方仅重传那些它怀疑在接收方出错的分组而避免不必要的重传。这种个别的、按需重传，要求接收方逐个确认正确接收的分组，再次用窗口长度 N 来限制流水线中未完成和未被确认的分组数。与 GBN 不同的是，发送方已经收到了窗口中对某些分组的 ACK。</p><p>接收方将确认一个正确接收的分组，不管是否按序。失序分组将被缓存直到所有丢失分组都收到，这时才可以将一批分组按序交付上层。</p><hr><h3 id="TCP-可靠原理"><a href="#TCP-可靠原理" class="headerlink" title="TCP 可靠原理"></a>TCP 可靠原理</h3><p>TCP 的可靠传输包含很多机制，例如使用<strong>检验和</strong>来检测一个传输分组中的比特错误、使用<strong>定时器</strong>来用于超时重传一个分组、使用<strong>序号</strong>来检测丢失的分组和冗余副本、使用<strong>确认</strong>来告诉发送方确认的分组信息、使用<strong>否定确认</strong>来告诉发送方某个分组未被正确接收。</p><p>TCP 的发送方仅需维持已发送过但未被确认的字节的最小序号和下一个要发送的字节的序号，从这种角度看 TCP 更像一个 GBN 协议。但是 TCP 和 GBN 有一些显著的区别，许多 TCP 实现会将正确接收但失序的报文段缓存起来。当分组 n 丢失时，GBN 会重传 n 之后的所有分组，但是 TCP 至多只会重传分组 n。对 TCP 提出的一种修改意见是选择确认，它允许 TCP 接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段，从这个角度看 TCP 又像 SR 协议。<strong>因此 TCP 的差错恢复机制是一种 GBN 和 SR  的结合体</strong>。</p><p>除此之外，TCP 还使用<strong>流量控制</strong>和<strong>拥塞控制</strong>来保证可靠性。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>滑动窗口以字节为单位。发送端有一个发送窗口，窗口中的序号是允许发送的序号，窗口的后沿是已经发送并且确认的序号，窗口的前沿是不允许发送的序号。窗口的后沿可能不动（代表没有收到新的确认），也有可能前移（代表收到了新的确认），但是不会后移（不可能撤销已经确认的数据）。窗口的前沿一般是向前的，也有可能不动（表示没有收到新的请求或对方的接收窗口变小），也有可能收缩，但 TCP 强烈不建议这么做，因为发送端在收到通知前可能已经发送了很多数据，此时如果收缩窗口可能会产生错误。</p><p>滑动窗口的状态需要3个指针p1，p2 和 p3。p1 之前的序号表示已经发送并且确认的序号，p1<del>p2 的序号表示已经发送但还没有确认的序号，p2</del>p3 表示允许发送的序号，也叫可用窗口，p1~p3 表示发送窗口，p3 之后的序号表示不可发送的序号。</p><p>发送缓存用来暂时存放发送应用程序传给发送方 TCP 准备发送的数据和已经发送但还没确认的数据。接收缓存用来暂时存放按序到达的但尚未被应用程序读取的数据以及未按序到达的数据。</p><p>注意三点：① 发送窗口根据接收窗口设置，但并不总是一样大，还要根据网络的拥塞情况调整。② 对于不按序到达的数据，TCP 通常存放在接收窗口，等到字节流缺少的字节收到后再按序交付上层应用程序。③ 接收方必须有累积确认功能，可以减小传输开销，可以在合适的时候发送确认，也可以在自己有数据需要发送时捎带确认。但是接收方不能过分推迟发送确认，不能超过0.5秒。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>如果某个应用程序读取数据的速度较慢，而发送方发送得太多、太快，发送的数据就会很容易使连接的接收缓存溢出，TCP 为它的应用程序提供了流量控制以消除发送方使接收方缓存溢出的可能性。流量控制是一个速度匹配服务，即发送方的发送速率与接收方的应用程序读取速率相匹配。</p><p>TCP 通过让<strong>发送方维护一个接收窗口的变量</strong>来提供流量控制。通俗地说，接收窗口用于给发送方一个指示，该接收方还有多少可用的缓存空间，因此方法方的发送窗口不能超过接收方给出的接收窗口的数值。因为 TCP 是全双工通信，在连接两端的发送方都各自维护一个接收窗口。</p><p>当接收窗口 rwnd 减小到 0 时，就不再允许发送方发送数据了。但是可能存在一种情况，当发生了零窗口报文段不久后，发送方的接收缓存又有了一些存储空间，因此又发生了新的报文说明自己的接收窗口大小，但是这个报文可能会在传输过程中丢失。接收方就会一直等待发送方的非零窗口通知，而发送方也一直在等待接收方发送数组，形成一种死锁的状态。为了解决这个问题，TCP 为每一个连接设有一个持续计时器，只要 TCP 连接的一方收到对方的零窗口通知就启动该计时器，到期后发送一个零窗口探测报文，如果仍为 0 就重新设置计时器的时间，如果对方给出了新的窗口值就可以解决可能出现的死锁问题。</p><p>还有一种问题叫做<strong>糊涂窗口综合症</strong>，当接收方处理接收缓冲区数据很慢时，就会使应用进程间传送的有效数据很小， 极端情况下有效数据可能只有 1 字节但传输开销却有 40 字节（20字节的 IP 头以及 20 字节的 TCP 头) ，导致网络效率极低。为了解决这个问题，可以让接收方等待一段时间，使得接收缓存有足够的空间容纳一个最长报文段或者等到接收缓存已有一半的空闲空间。发送方也不要发送太小的报文，而是把数据积累成足够大的报文或达到接收方缓存空间的一半时才发送。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>网络中对资源需求超过了资源可用量的情况就叫做拥塞。当吞吐量明显小于理想的吞吐量时就出现了轻度拥塞，当吞吐量随着负载的增加反而下降时，网络就进入了拥塞状态。当吞吐量降为 0 时，网络已无法正常工作并陷入死锁状态。拥塞控制就是尽量减少注入网络的数据，减轻网络中的路由器和链路的负担。<strong>拥塞控制是一个全局性的问题，它涉及网络中的所有路由器和主机，而流量控制只是一个端到端的问题，是两个端点之间通信量的控制。</strong></p><p>根据网络层是否为运输层拥塞控制提供显式帮助可以将拥塞控制的方法区分为两种：端到端拥塞控制和网络辅助的拥塞控制。TCP 使用端到端的拥塞控制，因为 IP 层不会向端系统提供显式的网络拥塞反馈。TCP 所采取的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其向连接发送数据的速率。如果一个 TCP 发送方感知到它到目的地之间的路径上没什么拥塞则会增加发送速率，如果发送方感知到拥塞就会降低其发送速率。限制发送速率是通过拥塞窗口来实现的，它对发送方能向网络中发送流量的速率进行了限制。判断拥塞是通过超时或者连续接收到 3 个冗余 ACK 实现的。</p><p>TCP 的拥塞控制算法主要包括了慢启动、拥塞避免和快恢复。慢启动和拥塞避免是 TCP 的强制部分，差异在于对收到的 ACK 做出反应时 cwnd 增加的方式，慢启动比拥塞避免要更快地增加 cwnd 的长度。快恢复是推荐部分，对 TCP 发送方不是必需的。</p><p><strong>1. 慢启动</strong></p><p>在慢启动状态，拥塞窗口 cwnd 的值以一个 MSS 最大报文段开始并且每当传输的报文段首次被确认就增加一个 MSS。因此每经过一个 RTT 往返时间，拥塞窗口就会翻倍，发送速率也会翻倍。因此 TCP 的发送速率起始很慢，但是在慢启动阶段以指数增长。</p><p>结束慢启动有三种情况：① 如果存在一个超时指示的丢包事件，即发生了拥塞，TCP 发送方就会将 cwnd 设置为 1 并重新开始慢启动过程。它还将慢启动阈值设置为 cwnd/2，即检测到拥塞时将慢启动阈值设置为拥塞窗口的一半。② 当拥塞窗口达到慢启动阈值时就会结束慢启动而进入拥塞避免模式。③ 最后一种结束慢启动的方式是，如果检测到三个冗余的 ACK，TCP 就会执行快重传并进入快恢复状态。</p><p><strong>2. 拥塞避免</strong></p><p>一旦进入拥塞避免状态，cwnd 的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远。因此 TCP 无法再每经过一个 RTT 就将 cwnd 的值翻倍，而是采用一种较为保守的方法，每个 RTT 后只将 cwnd 的值增加一个 MSS。这能够以几种方式完成，一种通用的方法是发送方无论何时收到一个新的确认，都将 cwnd 增加一个 MSS。</p><p>当出现超时时，TCP 的拥塞避免和慢启动一样，cwnd 的值将被设置为 1，并且将慢启动阈值设置为 cwnd 的一半。</p><p><strong>3. 快恢复</strong></p><p>有时候个报文段丢失，而网络中并没有出现拥塞，如果使用慢启动算法就会降低传输效率。这时应该使用快重传来让发送方尽早知道出现了个别分组的丢失，快重传要求接收端不要等待自己发送数据时再捎带确认，而是要立即发送确认。即使收到了乱序的报文段后也要立即发出对已收到报文段的重复确认。当发送方连续收到三个冗余 ACK 后就知道出现了报文段丢失的情况，会立即重传并进入快恢复状态。</p><p>在快恢复中，会调整慢启动阈值为 cwnd 的一半，并进入拥塞避免状态。</p><hr><h3 id="TCP-连接和释放机制"><a href="#TCP-连接和释放机制" class="headerlink" title="TCP 连接和释放机制"></a>TCP 连接和释放机制</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>TCP 是全双工通信，任何一方都可以发起建立连接的请求，假设 A 是客户端，B 是服务器。</p><p>初始 A 和 B 均处于 CLOSED 状态，B 会创建传输进程控制块 TCB 并进入 LISTEND 状态，监听端口是否收到了 TCP 请求以便及时响应。</p><p>当 A 要发生数据时就向 B 发送一个连接请求报文，TCP 规定连接请求报文的 SYN=1，ACK=0，SYN 不可以携带数据，但要消耗一个序号，假设此时 A 发送的序号 seq 为 x。发送完之后 A 就进入了 SYN-SENT 同步已发送状态。</p><p>当 B 收到 A 的连接请求报文后，如果同意建立连接就会发送给 A 一个确认连接请求报文，其中 SYN=1，ACK=1，ack=x+1，seq=y，ack 的值为 A 发送的序号加 1，ACK 可以携带数据，如果不携带的话则不消耗序号。发送完之后，B进入 SYN-RCVD 同步已接收状态。</p><p>当 A 收到 B 的确认连接请求报文后，还要对该确认再进行一次确认，报文的 ACK=1，ack=y+1，seq=x+1，发送后 A 进入 ESTABLISHED 状态，当 B 接收到该报文后也进入 ESTABLISHED 状态，客户端会稍早于服务器端建立连接。</p><p><strong>三次握手的原因主要有两个目的，信息对等和防止超时。</strong></p><p>从信息对等的角度看，双方只有确定 4 类信息才能建立连接，即 A 和 B 分别确认自己和对方的发送和接收能力正常。在第二次握手后，从 B 的角度看还不能确定自己的发送能力和对方的接收能力，只有在第三次握手后才能确认。</p><p>三次握手也是防止失效连接突然到达导致脏连接，网络报文的生存时间往往会超过 TCP 请求超时时间，A 的某个超时连接请求可能会在双方释放连接之后到达 B，B 会误以为是 A 创建了新的连接请求，然后发送确认报文创建连接。因为 A 机器的状态不是 SYN_SENT，所以直接丢弃了 B 的确认数据。如果是两次握手，连接已经建立了，服务器资源被白白浪费。如果是三次握手，B 由于长时间没有收到确认信息，最终超时导致创建连接失败，因此不会出现脏连接。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当 A 已经没有要发送的数据时就会释放连接，会向 B 发送一个终止连接报文，其中 FIN=1，seq=u，u 的值为之前 A 发送的最后一个序号+1。发送完之后进入 FIN-WAIT-1 状态。</p><p>B 收到该报文后，发送给 A 一个确认报文，ACK=1，ack=u+1，seq=v，v 的值为 B 之前发送的最后一个序号+1。此时 A 进入了FIN-WAIT-2 状态，B 进入了 CLOSE-WAIT 状态，但连接并未完全释放，B 会通知高层的应用层结束 A 到 B 方向的连接，此时 TCP 处于半关闭状态。</p><p>当 B 发送完数据后准备释放连接时，就向 A 发送连接终止报文，FIN=1，同时还要重发ACK=1，ack=u+1，seq=w，seq 不是 v 的原因是在半关闭状态 B 可能又发送了一些数据，之后 B 进入 LAST-ACK 状态。</p><p>A 收到连接终止报文后还要再进行一次确认，确认报文中 ACK=1，ack=w+1，seq=u+1。发送完之后进入 TIME-WAIT 状态，等待 2MSL之后进入 CLOSED 状态，B 收到该确认后进入 CLOSED 状态，服务器端会稍早于客户端释放连接。</p><p><strong>四次挥手的原因</strong></p><p>tcp是全双工通信，服务端和客服端都能发送和接收数据。</p><p>tcp在断开连接时，需要服务端和客服端都确定对方将不再发送数据。</p><p><strong>第1次挥手</strong></p><p>由客户端向服务端发起，服务端收到信息后就能确定客户端已经停止发送数据。</p><p><strong>第2次挥手</strong></p><p>由服务端向客户端发起，客户端收到消息后就能确定服务端已经知道客户端不会再发送数据。</p><p><strong>第3次握手</strong></p><p>由服务端向客户端发起，客户端收到消息后就能确定服务端已经停止发送数据。</p><p><strong>第4次挥手</strong></p><p>由客户端向服务端发起，服务端收到信息后就能确定客户端已经知道服务端不会再发送数据。</p><p><strong>为什么不是3次挥手</strong></p><p>在客服端第1次挥手时，服务端可能还在发送数据。</p><p>所以第2次挥手和第3次挥手不能合并。</p><p><strong>大量 TIME-WAIT 的原因、导致的问题、处理</strong></p><p>在高并发短连接的 TCP 服务器上，服务器处理完请求后立刻主动正常关闭连接，这个场景下会出现大量 socket 处于 TIME-WAIT 状态。</p><p>TIME-WAIT 状态无法真正释放句柄资源，socket 使用的本地端口在默认情况下不能再被使用，会限制有效连接数量，成为性能瓶颈。</p><p>可以调小 tcp_fin_timeout 的值，将 tcp_tw_reuse 设为 1 开启重用，将 tcp_tw_recycle 设为 1 表示开启快速回收。</p><hr><h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><p>TCP 是面向连接的，而 UDP 是无连接的，发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。</p><p>TCP 保证数据的可靠传输，UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态。</p><p>TCP 是面向字节流的，UDP 是面向报文的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文既不拆分也不合并，而是保留这些报文的边界。如果报文太长，IP 层在传送时可能需要分片，如果报文太短，会使 IP 数据报首部的相对长度太大，都会降低 IP 层的效率。</p><p>TCP 有拥塞控制，UDP 没有拥塞控制，因此网络中出现的拥塞不会降低源主机的发送速率。这对某些实时应用很重要，很多实时应用如 IP 电话、实时视频会议等要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许网络有太大的时延，UDP 正好适合这种要求。</p><p>TCP 是点到点之间的一对一通信，UDP 支持一对一、一对多和多对多的交互通信。</p><p>UDP 的首部开销很小，只有 8 字节，相比 TCP 的 20 字节要短。</p><h3 id="TCP和UDP的传送信息单位的区别？"><a href="#TCP和UDP的传送信息单位的区别？" class="headerlink" title="TCP和UDP的传送信息单位的区别？"></a>TCP和UDP的传送信息单位的区别？</h3><p>16位源端口号+16位目的端口号+32位序号+32位确认号+4位头部长度（单位4字节）+6位保留+6个关键字（SYN,ACK，FIN）+16位窗口大小（指接收窗口）+16位校验和+16位紧急指针+最多40字节的选项；</p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。</p><h3 id="Close-wait作用"><a href="#Close-wait作用" class="headerlink" title="Close wait作用"></a>Close wait作用</h3><h3 id="TCP粘包？"><a href="#TCP粘包？" class="headerlink" title="TCP粘包？"></a>TCP粘包？</h3><p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>原因可能是发送方也可能是接收方造成的。</p><p>发送方原因：TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</p><p>接收方原因：TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。</p><h4 id="处理方法："><a href="#处理方法：" class="headerlink" title="处理方法："></a>处理方法：</h4><p> 最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：</p><ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。 </li><li>包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。 </li><li>包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。</li></ul><hr><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p><img src="https://uploadfiles.nowcoder.com/files/20200810/176673786_1597021488550_u16143127921954581760fm26gp0.jpg" alt="img"></p><p><strong>4位版本</strong>：</p><p> 目前协议版本号是4，因此IP有时也称作IPV4.</p><p> <strong>4位首部长度</strong>：</p><p> 首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。</p><p> <strong>服务类型（TOS）</strong>：</p><p> 服务类型字段包括一个3bit的优先权字段（现在已经被忽略），4bit的TOS子字段和1bit未用位必须置0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。</p><p> <strong>总长度</strong>：</p><p> 总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16bit，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。</p><p> <strong>标识字段</strong>：</p><p> 标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</p><p> <strong>生存时间</strong>：</p><p> TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为 3 2或6 4），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0时，数据报就被丢弃，并发送 ICMP 报文通知源主机。</p><p> <strong>首部检验和</strong>：</p><p> 首部检验和字段是根据 I P首部计算的检验和码。它不对首部后面的数据进行计算。 ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP-概况"><a href="#HTTP-概况" class="headerlink" title="HTTP 概况"></a>HTTP 概况</h3><p>HTTP 即超文本传输协议，是 Web 的应用层协议。HTTP 由两个程序实现，一个客户程序和一个服务器程序，客户程序和服务器程序运行在不同的端系统中，通过交换 HTTP 报文进行会话。HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式，当用户请求一个 Web 页面时，浏览器向服务器发出对该页面中所包含对象的 HTTP 请求报文，服务器接收到请求并用包含这些对象的 HTTP 响应报文进行响应。</p><p><strong>HTTP 使用 TCP 作为它的支撑运输协议</strong>，HTTP 客户首先发起一个与服务器的 TCP 连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字访问 TCP。客户端的套接字接口是客户进程与 TCP 连接之间的门，服务器端的套接字接口则是服务器进程与 TCP 连接之间的门。客户向它的套接字接口发送 HTTP 请求报文并从它的套接字接口接收 HTTP 响应报文，类似的，服务器从它的套接字接口接收 HTTP 请求报文并向它的套接字接口发送 HTTP 响应报文。一旦客户向它的套接字接口发送一个 HTTP 请求报文，该报文就脱离了客户控制并进入 TCP 的控制，TCP 为 HTTP 提供可靠的数据传输服务，因此一个客户进程发出的每个 HTTP 请求报文最终都能完整地到达服务器，服务器进程发出地每个 HTTP 响应报文最终也可以完整地到达客户。这里体现了分层体系结构的优点，HTTP 协议不需要担心数据丢失，也不需要关注 TCP 从网络的数据丢失和乱序中如何恢复。</p><p><strong>HTTP 是一种无状态的协议</strong>，服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。假如某个客户在短时间内连续两次请求同一个对象，服务器并不会因为刚刚为该客户做出了响应就不再响应，而是重新进行响应。</p><hr><h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><p>依据每个请求/响应对经过一个单独的 TCP 连接还是相同的 TCP 连接发送，可以将连接划分为非持续连接和持续连接。HTTP 默认使用持续连接，但是也可以配置成使用非持续连接。</p><p><strong>非持续连接</strong></p><p>使用非持续连接时，从服务器向客户传送一个包含了一个 HTML 文件和 10  个 JPG 对象的 Web 页面步骤：</p><p>① HTTP 客户进程在端口号 80 发起一个到服务器的 TCP 连接，并经它的套接字向服务器发送一个 HTTP 请求报文。② HTTP 服务器进程经它的套接字接收请求报文，从其存储器中检索出请求对象，在一个 HTTP 响应报文中封装对象，并通过套接字向客户发送响应报文。③ HTTP 服务器进程通知 TCP 断开该 TCP 连接，直到 TCP 确认客户已经完整接收到响应报文才会实际断开连接。④ HTTP 客户接收到响应报文，客户从报文中提取出 HTML 文件，得到多个 JPG 图像的引用，并对每个引用的 JPG 图像对象重复前三个步骤。</p><p>每个 TCP 连接会在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。每个 TCP 连接只传输一个请求报文和一个响应报文，假如请求一个 HTML 文件和其中包括的 10 个 JPG 图像就要产生 11 个 TCP 连接。</p><p>在非持续连接中，每次请求文件到接收响应大约需要花费两个 RTT 加上服务器传输文件的时间，RTT 就是往返时间，指一个短分组从客户到服务器然后再返回客户所发送的时间。其中三次握手的前两个部分占用一个 RTT，三次握手的第三个确认部分向服务器发送了请求报文，服务器接收到之后做出响应，这用去了另一个 RTT。</p><p><strong>持续连接</strong></p><p>非持续连接有很多缺点。第一，必须为每个请求的对象建立和维护一个新的连接，对于每个连接，在客户和服务器中都要分配 TCP 的缓冲区和保持 TCP 变量，这给 Web 服务器带来了很大负担。第二，每一个对象需要消耗两倍的 RTT，一个用于创建 TCP，一个用于请求和接收对象。</p><p>在 HTTP1.1 中使用了持续连接，服务器在发送响应后保持该 TCP 连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。在使用持续连接的情况下，请求一个完整的 Web 页面可以使用单个持续的 TCP 连接，例如之前所说的包含一个 HTML 文件和 10  个 JPG 对象的 Web 页面就只需要一个 TCP 连接而不是 11 个。</p><hr><h3 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h3><p>HTTP 报文有两种，分为请求报文和响应报文。</p><p><strong>请求报文</strong></p><p>HTTP 请求报文的第一行叫做请求行，其后继的行叫做首部行。请求行有三个字段，包括方法、URL 和 HTTP 版本。方法包括了 GET、POST、HEAD、PUT 和 DELETE 等。绝大部分的 HTTP 请求报文使用 GET 方法，当使用 GET 方法时，在 URL 字段中会带有请求对象的标识。</p><p>首部行指明了对象所在的主机，其实已经存在 TCP 连接了，但是还需要首部行提供主机信息，这时 Web 代理高速缓存所要求的。通过包含 <code>Connection:close</code> 的首部行，可以告诉服务器不要麻烦地使用持续连接，它要求在发送完响应后就关闭连接。<code>User-agent</code> 可以用来指明用户代理，即向服务器发送请求的浏览器类型，服务器可以有效地为不同类型的用户代理发送实际相同对象的不同版本。</p><p>在首部行之后有一个空行，后面跟着的是实体。使用 GET 方法时实体为空，而使用 POST 方法时才会使用实体。当用户提交表单时，HTTP 客户通常使用 POST 方法，使用 POST 方法时用户仍可以向服务器请求一个 Web 页面，但 Web 页面的特定内容依赖于用户在表单字段中输入的内容。如果使用 POST 方法，则实体中包含的就是用户在表单字段的输入值。表单不是必须使用 POST 方法，也可以使用 GET。</p><p>HEAD 方法类似于 GET，当服务器收到一个使用 HEAD 方法的请求时，将会用一个 HTTP 报文进行响应，但是并不返回请求对象。通常开发者使用 HEAD 方法进行调试跟踪。PUT 方法常用于上传对象到指定的 Web 服务器上指定的目录，DELETE 方法允许用户或应用程序删除 Web 服务器上的对象。</p><p><strong>响应报文</strong></p><p>响应报文包括状态行、首部行和实体。状态行有三个字段，协议版本、状态码和对应的状态信息。实体是报文的主要部分，即所请求的对象本身。</p><p>服务器通过首部行来告诉浏览器一些信息。 <code>Connection:close</code> 可以告诉客户发送完报文后将关闭该 TCP 连接。<code>Date</code> 是首部行指示服务器发送响应报文的日期和时间，这个时间不是对象创建或修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文并发送的时间。<code>Server</code> 指明了服务器的类型，类似于请求报文中的 <code>User-agent</code> 。</p><p>状态码及其相应的短语指示了请求的结果，一些常见的状态码和相关短语如下：</p><table><thead><tr><th>状态码</th><th>短语</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>成功响应</td></tr><tr><td>301</td><td>Moved Permanently</td><td>请求的对象已经被永久转移了，新的 URL 定义在响应报文的 Location 首部行，客户将自动获取新的 URL。</td></tr><tr><td>302</td><td>Found</td><td>与301类似，但资源只是临时被移动，客户端应继续使用原有 URL。</td></tr><tr><td>400</td><td>Bad Request</td><td>一个通用的差错代码，标识该请求不能被服务器理解。</td></tr><tr><td>401</td><td>Unauthorized</td><td>未认证，缺乏相关权限。</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解客户端的请求，但是拒绝执行。</td></tr><tr><td>404</td><td>Not Found</td><td>被请求的文档不在服务器上，有可能因为请求 URL 出错。</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端中请求的方法被禁止，例如限制 POST 方式但使用了 GET 访问。</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求。</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求。</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求。</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>服务器不支持请求报文使用的 HTTP 协议版本。</td></tr></tbody></table><hr><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>HTTP 的无状态性简化了服务器的设计，并且提高了 Web 服务器的性能，使其可以同时处理大量的 TCP 连接。但是一个 Web 站点通常希望能够识别用户，可能是为了限制用户的访问，也可能为了把内容与用户身份关联起来，为此 HTTP 使用了 cookie，cookie 是一种客户端的会话技术，允许站点对用户进行追踪。</p><p><strong>cookie 技术有四个组件</strong></p><p>① 在 HTTP 响应报文中的一个 cookie 首部行。② 在 HTTP 请求报文中的一个 cookie 首部行。③ 在用户端系统中保留有一个 cookie 文件，并由用户的浏览器关联。④ 位于 Web 站点的一个后端数据库。cookie 的工作流程：当客户通过浏览器第一次访问某个站点时，该 Web 站点将产生一个唯一识别码，并以此作为索引在它的后端数据库中产生的一个表项。接下来服务器会用一个包含 <code>Set-cookie</code> 首部的 HTTP 响应报文对浏览器进行相应，当浏览器收到后将其添加到自己管理的 cookie 文件中，在下次访问该站点时，请求报文的首部行中就会包括这个识别码，尽管浏览器不知道客户是谁，但是可以确定是同一个客户进行了访问。</p><p><strong>cookie 和 session 的区别</strong></p><p>① cookie 只能存储 ASCII 码字符串，而 session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选session。② session 存储在服务器，而 cookie 存储在客户浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 cookie 中，可以将 cookie 值进行加密，然后在服务器进行解密。</p><p><strong>Cookie和Session的选择？</strong></p><ol><li><p>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session；</p></li><li><p>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</p></li><li><p>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</p></li></ol><hr><h3 id="Web-缓存"><a href="#Web-缓存" class="headerlink" title="Web 缓存"></a>Web 缓存</h3><p>Web 缓存器也叫代理服务器，它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体。Web 缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象副本。可以配置用户的浏览器，使得用户所有的 HTTP 请求首先指向 Web 缓存器。客户通过 Web 缓存器请求对象的步骤如下：</p><p>① 浏览器创建一个到 Web 缓存器的 TCP 连接，并向 Web 缓存器中的对象发送一个 HTTP 请求。② Web 缓存器进行检查，查看本地是否存储了该对象副本。如果有，Web 缓存器就向客户浏览器用 HTTP 响应报文返回该对象。③ 如果 Web 缓存器中没有该对象，它就打开一个与该对象的初始服务器的 TCP 连接，Web 缓存器在这个连接上发送一个请求并接受响应。④ Web 缓存器接收到响应后，在本地存储空间存储一份副本，并向客户的浏览器用 HTTP 响应报文发送该副本。</p><p>Web 缓存器既是服务器又是客户，当它接受浏览器的请求并响应时，它是一个服务器，当他向初始服务器发出请求并接收响应时，它是一个客户。在因特网上部署 Web 缓存器有两个原因，首先，Web 缓存器可以大大减少对客户请求的响应时间，特别是客户与初始服务器之间的带宽远低于客户与 Web 缓存器之间的带宽时更是如此。其次，Web 缓存器可以大大减少一个机构的接入链路到因特网的通信量，通过减少通信量，机构就不必基于增加带宽，可以降低费用。</p><hr><h3 id="输入一个-url-发生的事"><a href="#输入一个-url-发生的事" class="headerlink" title="输入一个 url 发生的事"></a>输入一个 url 发生的事</h3><p><strong>① 分析 url</strong></p><p>判断输入的 url 是否合法，如果不合法浏览器会使用默认的搜索引擎进行搜索。如果输入的是一个域名，默认会加上一个 http 前缀。</p><p><strong>② DNS 查询</strong></p><p>检查浏览器的 DNS 缓存，检查本地 hosts 文件的缓存，如果没有会向本地 DNS 服务器发送请求。</p><p>主机向本地 DNS 服务器发起请求是递归查询，如果找到则返回，否则会向根 DNS 查询。</p><p>根 DNS 查询是迭代查询，没有域名和 ip 的对应关系，而是告知可以查询的域名服务器地址。</p><p>本地 DNS 向得到的域名服务器发出请求，收到一个域名和 ip 关系，把结果返回给用户，并把结果保存到缓存中。</p><p><strong>③ TCP 建立连接</strong></p><p>拿到 ip 地址后，通过 TCP 的三次握手建立连接，按照协议规定的格式发送 HTTP 请求报文。</p><p><strong>④ 处理请求</strong></p><p>服务器收到 HTTP 请求报文后进行响应，主进程进行监听，创建子进程处理，先判断是否是重定向，如果是重定向则返回重定向地址。如果是静态资源则直接返回，否则通过 REST URL 在代码层面处理返回结果，最后返回 HTTP 响应报文。</p><p><strong>⑤ 接收响应</strong></p><p>浏览器收到 HTTP 响应报文后进行解析，首先查看响应报文在状态行的状态码，根据不同的状态码做不同的事，解析 HTML、CSS、JS 等文件。构建 DOM 树，渲染树，重绘，将像素发送 GPU 进行渲染，最后将渲染结果返回给用户并进行缓存。</p><p><strong>⑥ TCP 断开连接</strong></p><p>通过 TCP 的四次挥手断开连接，如果是 HTTP1.1 则会将连接保持一小段时间。</p><hr><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><strong>HTTP 存在的问题</strong></p><p>HTTP 没有密码加密，无法保证通信内容不被窃听，攻击者可以截取客户发送的数据并得到他的信息。</p><p>HTTP 没有报文完整性验证，无法确保通信内容在传输过程中不被改变，攻击者可以篡改客户通信内容。</p><p>HTTP 没有身份鉴别，无法让通信双方确认对方的身份，攻击者可以伪装成客户或者服务器。</p><p><strong>加密原理</strong></p><p>HTTPS 即 HTTP over SSL，在 HTTP 传输上增加了 SSL 安全性服务。SSL 是安全套接字层，通过采用机密性、数据完整性、服务器鉴别以及客户鉴别来强化 TCP，主要用于为发生在 HTTP 之上的事务提供安全性。SSL 会对数据进行加密并把加密数据送往 TCP 套接字，在接收方，SSL 读取 TCP 套接字中的数据并解密，然后把数据交给应用层。HTTPS 采用混合加密机制，使用非对称加密传输对称密钥来保证传输过程的安全性，之后使用对称加密进行通信来保证通信过程的效率。</p><p>HTTPS 的传输过程主要分为两部分：通过 SSL 握手建立安全的 HTTPS 通道和在安全的通道上进行数据传输，SSL 握手的步骤如下：</p><p>① 客户发送它支持的密码算法列表，以及一个客户的不重数，不重数就是在一个协议的生存期只使用一次的数。</p><p>② 服务器从该列表中选择一种对称加密算法（例如 AES），一种公钥加密算法（例如 RSA）和一种报文鉴别码算法。服务器把它的选择以及证书和一个服务器不重数返回给客户。</p><p>③ 客户通过 CA 提供的公钥验证该证书，验证成功后提取服务器的公钥，生产一个前主密钥 PMS，用服务器的公钥加密该 PMS，并将加密的 PMS 发送给服务器。</p><p>④ 客户和服务器独立地从 PMS 和不重数中计算出仅用于当前 SSL 会话的主密钥 MS，然后该 MS 被切片以生成两个密码和两个报文鉴别码密钥。自从以后，客户和服务器之间发送的所有报文均被加密和鉴别（使用报文鉴别码）。</p><p>⑤ 客户和服务器分别发送所有握手报文的一个报文鉴别码。这一步是为了使握手免受篡改危害，在第一步中客户提供的算法列表是以明文形式发送的，因此可能被攻击者截获并删除较强的算法。当客户发送一个级联它以及发送和接收的所有握手报文的报文鉴别码，服务器能够比较这个报文鉴别码和它已经接受和发送的握手报文的报文鉴别码，如果不一致就终止连接。类似的，客户也可以通过服务器发送的报文鉴别码来检查一致性。</p><p>第一步和第二步中的不重复数用于防止重放攻击，每个 TCP 会话使用不同的不重复数就可以使加密密钥不同，当收到重放的 SSL 记录时，该记录无法通过完整性检查，假冒的电子事务不会成功。</p><p>当结束 SSL 会话时，需要在类型字段中指出该记录是否是用于终止 SSL 会话的。通过包含这样一个字段，如果客户或服务器在收到一个关闭 SSL 记录之前突然收到了一个 TCP FIN，就知道遭受了截断攻击。</p><hr><p>作者：Sun浅雨<br>链接：<a href="https://www.nowcoder.com/discuss/472041?type=all&amp;order=time&amp;pos=&amp;page=3&amp;channel=1009&amp;source_id=search_all" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/472041?type=all&amp;order=time&amp;pos=&amp;page=3&amp;channel=1009&amp;source_id=search_all</a><br>来源：牛客网</p><h3 id="HTTP1-0、1-1、2-0之间的区别"><a href="#HTTP1-0、1-1、2-0之间的区别" class="headerlink" title="HTTP1.0、1.1、2.0之间的区别"></a><strong>HTTP1.0、1.1、2.0之间的区别</strong></h3><p> <strong>HTTP1.0：</strong>默认使用Connection:cloose，浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个<a href>客户端</a>也不记录过去的请求（无状态）。</p><p> <strong>HTTP1.1：</strong>默认使用Connection:<a href>keep</a>-alive（长连接），避免了连接建立和释放的开销；通过Content-Length字段来判断当前请求的数据是否已经全部接受。不允许同时存在两个并行的响应。</p><p> <strong>HTTP2.0：</strong>引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以并行的传输数据。</p><h3 id="http1-0和http1-1的主要区别如下："><a href="#http1-0和http1-1的主要区别如下：" class="headerlink" title="http1.0和http1.1的主要区别如下："></a><strong>http1.0和http1.1的主要区别如下：</strong></h3><p> 1、缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match）<br>​ 2、网络连接的优化：1.1支持断点续传<br>​ 3、错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态<br>​ 4、Host头处理：支持Host头域，不在以IP为请求方标志<br>​ 5、长连接：减少了建立和关闭连接的消耗和延迟。</p><h3 id="http1-1和http2-0的主要区别："><a href="#http1-1和http2-0的主要区别：" class="headerlink" title="http1.1和http2.0的主要区别："></a><strong>http1.1和http2.0的主要区别：</strong></h3><p> 1、新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式<br>​ 2、多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成 正常的请求）<br>​ 3、header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的 hearder大小<br>​ 4、服务端推送：同<a href>google</a>的SPDUY（1.0的一种升级）一样</p><h3 id="HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？"><a href="#HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？" class="headerlink" title="HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？"></a><strong>HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密<a href>算法</a>和非对称加密<a href>算法</a>不？</strong></h3><p> <strong>HTTP与HTTPS之间的区别：</strong></p><table><thead><tr><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>默认端口80</td><td>HTTPS默认使用端口443</td></tr><tr><td>明文传输、数据未加密、安全性差</td><td>传输过程ssl加密、安全性较好</td></tr><tr><td>响应速度快、消耗资源少</td><td>响应速度较慢、消耗资源多、需要用到CA证书</td></tr></tbody></table><h3 id="HTTPS链接建立的过程："><a href="#HTTPS链接建立的过程：" class="headerlink" title="HTTPS链接建立的过程："></a><strong>HTTPS链接建立的过程：</strong></h3><p> 1.首先<a href>客户端</a>先给服务器发送一个请求</p><p> 2.服务器发送一个SSL证书给<a href>客户端</a>，内容包括：证书的发布机构、有效期、所有者、签名以及公钥</p><p> 3.<a href>客户端</a>对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密<a href>算法</a>以及对称密钥进行加密</p><p> 4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给<a href>客户端</a></p><p> 5.随后<a href>客户端</a>和服务端就使用对称密钥进行信息传输</p><p><a href="https://blog.csdn.net/qq_1290259791/article/details/85939246?ops_request_misc=%7B%22request%5Fid%22%3A%22160430345319725225016168%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=160430345319725225016168&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-85939246.pc_first_rank_v2_rank_v28&utm_term=https加密&spm=1018.2118.3001.4449" target="_blank" rel="noopener">https://blog.csdn.net/qq_1290259791/article/details/85939246?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160430345319725225016168%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160430345319725225016168&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>first_rank_v2~rank_v28-1-85939246.pc_first_rank_v2_rank_v28&amp;utm_term=https%E5%8A%A0%E5%AF%86&amp;spm=1018.2118.3001.4449</a></p><h3 id="对称加密算法："><a href="#对称加密算法：" class="headerlink" title="对称加密算法："></a><strong>对称加密<a href>算法</a>：</strong></h3><p> 双方持有相同的密钥，且加密速度快，典型对称加密<a href>算法</a>：DES、AES</p><h3 id="非对称加密算法："><a href="#非对称加密算法：" class="headerlink" title="非对称加密算法："></a><strong>非对称加密<a href>算法</a>：</strong></h3><p> 密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密<a href>算法</a>有：RSA、DSA</p><h3 id="HTTP请求有哪些。get和Post区别。"><a href="#HTTP请求有哪些。get和Post区别。" class="headerlink" title="HTTP请求有哪些。get和Post区别。"></a><strong>HTTP请求有哪些。get和Post区别。</strong></h3><p><strong>HTTP请求：</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>向特定资源发送请求，查询数据，并返回实体</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改</td></tr><tr><td>PUT</td><td>向服务器上传新的内容</td></tr><tr><td>HEAD</td><td>类似GET请求，返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>DELETE</td><td>请求服务器删除指定标识的资源</td></tr><tr><td>OPTIONS</td><td>可以用来向服务器发送请求来测试服务器的功能性</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，用于测试或诊断</td></tr><tr><td>CONNECT</td><td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table><p><strong>get和Post区别：</strong></p><table><thead><tr><th>GET</th><th>POST</th><th></th></tr></thead><tbody><tr><td>可见性</td><td>数据在URL中对所有人可见</td><td>数据不会显示在URL中</td></tr><tr><td>安全性</td><td>与post相比，get的安全性较差，因为所 发送的数据是URL的一部分</td><td>安全，因为参数不会被保存在浏览器 历史或web服务器日志中</td></tr><tr><td>数据长度</td><td>受限制，最长2kb</td><td>无限制</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>multipart/form-data</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能被缓存</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="HTTP常见响应状态码，从1xx到5xx"><a href="#HTTP常见响应状态码，从1xx到5xx" class="headerlink" title="HTTP常见响应状态码，从1xx到5xx"></a><strong>HTTP常见响应状态码，从1xx到5xx</strong></h3><p> 100：Continue — 继续。<a href>客户端</a>应继续其请求。</p><p> 200：OK — 请求成功。一般用于GET与POST请求。</p><p> 301：Moved Permanently — 永久重定向。</p><p> 302：Found — 暂时重定向。</p><p> 400：Bad Request — <a href>客户端</a>请求的语法错误，服务器无法理解。</p><p> 403：Forbideen — 服务器理解请求<a href>客户端</a>的请求，但是拒绝执行此请求。</p><p> 404：Not Found — 服务器无法根据<a href>客户端</a>的请求找到资源（网页）。</p><p> 500：Internal Server Error — 服务器内部错误，无法完成请求。</p><p> 502：Bad Gateway — 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。</p><h3 id="重定向和转发区别"><a href="#重定向和转发区别" class="headerlink" title="重定向和转发区别"></a><strong>重定向和转发区别</strong></h3><p> <strong>重定向：redirect：</strong></p><p> 地址栏发生变化 </p><p> 重定向可以访问其他站点（服务器）的资源</p><p> 重定向是两次请求。不能使用request对象来共享数据</p><p> <strong>转发：forward：</strong></p><p> 转发地址栏路径不变</p><p> 转发只能访问当前服务器下的资源</p><p> 转发是一次请求，可以使用request对象共享数据</p><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p>网络安全主要探讨的问题是攻击者如何攻击计算机网络，以及如何防御这些攻击，或者如何事先预防这样的攻击。</p><h3 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h3><p>计算机网络面临的威胁主要有被动攻击和主动攻击。</p><p><strong>被动攻击</strong>指攻击者从网络上窃听他人的通信内容，也叫截获。在被动攻击中，攻击者只是观察和分析某一协议数据单元 PDU 而不干扰信息流。攻击者可以通过观察 PDU 的协议控制信息部分，了解正在通信的协议的地址和身份，通过研究 PDU 的长度和发送频度，了解所交换的数据的某种性质。这种攻击又叫做流量分析。</p><p><strong>主动攻击</strong>包括：</p><ul><li><p><strong>篡改</strong></p><p>攻击者篡改网络上传输的报文，包括彻底中断传送的报文，甚至把完全伪造的报文发给接收端，这种攻击方式也叫做更改报文流。</p></li><li><p><strong>恶意程序</strong></p><p>① 计算机病毒，能够传染其他程序的程序，主要通过修改其他程序来把自身或自身的变种复制进去完成。② 计算机蠕虫，通过网络通信能把自己从一个结点发往另一个节点并且自动启动运行的程序。③ 特洛伊木马，它执行的功能并非声称的功能而是恶意程序，例如一个编译程序除了完成编译任务外还偷偷地复制源程序。④ 逻辑炸弹，当运行环境满足某种特殊条件时就会执行特殊功能的程序，例如当日期为 22 号且为周三的时候就会删除所有文件。⑤ 后门入侵，指利用系统实现中的漏洞通过网络入侵系统。⑥ 流氓软件，一种未经用户同意就在用户计算机上安装并损害用户利益的软件。</p></li><li><p><strong>拒绝服务DoS</strong></p><p>DoS 攻击使得网络、主机或其他基础设施部分不能由合法用户使用。Web 服务器、电子邮件服务器、DNS 服务器和机构网络都能够成为 DoS 攻击的目标。大多数 DoS 攻击属于以下三种情况：① 弱点攻击，指向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文，如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能会停止运行甚至崩溃。② 带宽洪泛，指攻击者向目标主机发送大量的分组，分组数量之多使得目标的接入链路变得阻塞，使合法的分组无法到达服务器。③ 连接洪泛，指攻击者在目标主机中创建大量的半开或全开 TCP 连接，主机因这些伪造的连接而陷入困境，并停止接受合法的连接。</p></li><li><p><strong>ARP欺骗</strong></p><p>在使用以太网交换机的网络中，攻击者向某个以太网交换机发送大量的伪造源 MAC 地址，以太网交换机收到这样的帧就把虚假的 MAC 源地址填入到交换表中，由于伪造的数量很大很快就填满了表，导致以太网交换机无法正常工作。</p></li></ul><p>对于被动攻击可以采用各种数据加密技术，对付主动攻击则需要将加密技术与适当的鉴别技术相结合。</p><p>安全的计算机网络具有以下特性：</p><ul><li><p><strong>机密性</strong></p><p>仅有发送方和希望的接收方能够理解报文传输的内容，因为窃听者可以截获报文，这要求报文必须进行加密，使截取而都报文无法被截获者理解。为了使网络具有保密性，需要使用各种密码技术。</p></li><li><p><strong>报文完整性</strong></p><p>通信内容在传输过程中需要被确保未被恶意篡改或意外改动。</p></li><li><p><strong>端点鉴别</strong></p><p>发送方和接收方都应该能证实通信过程中的另一方，以确信通信的另一方确实具有其声称的身份。在实际应用中，报文完整性和端点鉴别往往是不可分割的，因为假设通过了端点鉴别保证了通信双方的身份却没有通过报文鉴别保证报文的完整性是没有意义的。</p></li><li><p><strong>运行安全性</strong></p><p>几乎所有机构都有与互联网相连的网络，这些网络都因此具有潜在的安全问题。需要通过访问控制来确保网络的安全性，防火墙位于机构和公共网络之间，控制接入和来自网络的分组；入侵检测系统指需深度分组检查任务，向网络管理员发出有关可疑活动的警告。</p></li></ul><hr><h3 id="密码技术"><a href="#密码技术" class="headerlink" title="密码技术"></a>密码技术</h3><p>密码技术使发送方可以伪装数据，接收方需要从伪装的数据中恢复出初始数据，而入侵者不能从截获到的数据中获得任何信息。报文的最初形式被称为明文，在使用加密算法加密后得到的加密报文被称为密文。密码体制分为两种，对称密钥密码体制和公开密钥密码体制。</p><p>对称密钥密码体制使用相同的加密密钥和解密密钥，对称加密的运算速度快，但是安全性差，因为在密钥传输的过程中可能会被截获。数据加密标准 DES 属于对称密码密钥，这种密码的保密性仅仅取决于对密钥的保密，而算法是公开的，之后被更加安全的高级加密标准 AES 所取代。</p><p>公开密钥密码体制使用公钥进行加密，私钥进行解密，其中公钥是任何人都可以得知的，而私钥是通信双方所独有的。非对称加密的运算速度慢，但是安全性好。最常见的公钥加密算法是 RSA，它使用两个大素数 p 和 q 来生成密钥，p 和 q 的值越大，破解的难度就越大，但是执行加密和解密的时间也就越长，RSA 实验室推荐 p 和 q 的乘积为 1024 的数量级。</p><p>在使用对称密钥时，由于双方使用同样的密钥，因此在通信信道上可以进行<strong>一对一的双向保密通信</strong>，每一方既可以用该密钥加密明文并发送给对方，也可以接收密文用同一密钥解密。这种保密通信仅限于持有此密钥的双方。但在使用公开密钥时，在通信信道上可以是<strong>多对一的单向保密通信</strong>，可以同时有很多客户利用公钥对自己的报文加密后发送给某个服务器，服务器利用其私钥可以对收到的密文一一解密，但如果是反方向则是行不通的，例如在网购时很多客户都向同一个网站发送各自的信用卡信息。</p><hr><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p><strong>数字签名的作用</strong></p><p>① <strong>报文鉴别：</strong>接收者能够核实发送者对报文的签名，也就是说接收者可以确认报文发送方的身份。</p><p>② <strong>报文完整性：</strong>接收者可以确信收到的数据和发送者发送的完全一样并且没有被篡改过。</p><p>③ <strong>不可否认：</strong>发送者事后不能抵赖对报文的签名。</p><p><strong>实现原理</strong></p><p>有多种实现数字签名的方法，但采用公钥算法要比采用对称密钥算法更容易实现。为了进行签名，会首先用私钥对报文进行 D 运算得到某种不可读的密文，为了核实签名，接收方会利用发送方的公钥进行 E 运算还原出明文。任何人都可以用发送方的公钥还原出明文，因此这种通信方式并不是为了保密，而是为了进行签名和核实签名，即确认发送方的身份。</p><p>数字签名实现报文鉴别：除了发送方之外没有人持有其私钥，因此无法产生发送方才能产生的密文。</p><p>数字签名保证报文完整性：如果其他人篡改过密文，那么解密出的明文就会不可读，就知道收到的报文被篡改过。</p><p>数字签名保证不可否认：如果发送方抵赖发送过报文，接收方可以把初始报文和密文发送给公证的第三者，第三者通过公钥很容易证实发送方确实发送过报文。</p><p><strong>公钥认证</strong></p><p>攻击者可能会发送使用自己私钥加密的密文和自己的公钥来伪造发送方的身份，该问题通过 CA 解决，发送方在发送数据时也会发送 CA 签署的证书，接收方会利用 CA 的公钥来核对发送方证书的合法性并提取发送方的公钥。</p><p>CA 即认证中心，将公钥与特定的实体绑定， 它的职责就是使识别和发行证书合法化。CA 主要有两个作用：① CA 认证一个实体（一个人、一台路由器等）的真实身份。② 一旦 CA 认证了某个实体的身份，CA 会生成一个将其身份和实体的公钥绑定起来的证书，这个证书包含了这个公钥和公钥所有者全局唯一的身份标识信息（例如一个人的名字或一个 IP 地址），由 CA 对这个证书进行数字签名。</p><hr><h3 id="报文鉴别"><a href="#报文鉴别" class="headerlink" title="报文鉴别"></a>报文鉴别</h3><p>报文鉴别就是鉴别收到的报文确实是发送方发送的，而不是别人伪造或篡改的。数字签名就可以实现报文鉴别，但是数字签名有一个很大的缺点，就是对较长的报文进行数字签名时会使计算机增加非常大的负担，因为需要较长时间的运算。有一种相对简单的报文鉴别方式，就是密码散列函数。在密码学中的散列函数称为密码散列函数，最重要的特点就是：要找到两个不同的报文，它们具有相同的密码散列函数输出，在计算上是不可行的，也就是说密码散列函数实际上是一种单向函数。</p><p><strong>使用散列函数进行报文鉴别的原理</strong></p><p>通信双方需要共享一个密钥 k ，发送方生成报文 m，用 k 级联 m 生成 m+k，并使用 SHA-1 或 MD5 这样的散列函数计算 m+k 的散列值 h，这个散列值就被称为报文鉴别码 MAC。发送方会将 MAC 附加到报文 m 上，生成一个扩展报文，并将该扩展报文发送给接收方。接收方接到扩展报文后，由于知道共享密钥 k，因此可以计算出报文鉴别码，如果计算出的报文鉴别码和 h 相等就可以得出一切正常的结论。</p><p>除了共享密钥，还可以使用公钥加密。发送方可以利用自己的私钥进行散列运算，接收方利用发送方的公钥进行还原。这种方法得到的扩展报文是不为伪造且不可否认的，因为攻击者没有发送方的私钥，无法伪造出发送方发出的报文。</p><hr><h3 id="端点鉴别"><a href="#端点鉴别" class="headerlink" title="端点鉴别"></a>端点鉴别</h3><p>端点鉴别就是一个实体经过计算机网络向另一个实体证明其身份的过程，实体可以是一个人也可以是一个进程。端点鉴别主要通过鉴别协议 ap 来实现，鉴别协议通常在两个通信实体运行其他协议之前运行。鉴别协议首先建立相互满意的各方标识，仅当鉴别完成之后各方才继续下面的工作。</p><p><strong>鉴别协议 ap1.0</strong></p><p>发送方直接发送一个报文说明自己的身份，缺陷很大，攻击者可以任意伪造。</p><p><strong>鉴别协议 ap2.0</strong></p><p>发送方有一个总是用于通信的 IP 地址，接收方可以验证携带鉴别报文的 IP 数据报的源地址和发送方经常使用的 IP 地址是否匹配来进行鉴别。但存在 IP 欺骗的可能性，攻击者也可以伪造源 IP 地址。</p><p><strong>鉴别协议 ap3.0</strong></p><p>进行鉴别的经典方法是使用秘密口令，口令是鉴别者和被鉴别者之间的一个共享秘密。接收方会要求发送方提供口令来进行验证，但这种方式依旧不是安全的，因为攻击者可能会通过嗅探获得发送方的口令。一种改进想法是对口令进行加密，防止攻击者获得口令，但是这不能解决重放攻击，攻击者可以获取加密口令并不断重放。</p><p><strong>鉴别协议 ap4.0</strong></p><p>重放攻击主要是由于接收方并不知道此时发送方是否还是活跃的，ap 4.0 主要通过一个<strong>不重数</strong>来防止重放攻击。不重数就是在一个协议的生存期中只会使用一次的数，是一个不重复使用的大随机数，一旦某协议使用了一个不重数，就永远不会再使用那个数了。接收方会向发送方发送一个不重数，发送方将其加密后发回给接收方，接收方通过验证这个数字来判断发送方是否是活跃的。</p><hr><h3 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h3><p><strong>网络层</strong></p><p>网络层的安全协议是 IPsec，它并不是一个单一的协议，而是能够为两个网络实体之间的 IP 数据报提供通信安全的协议族。IPsec 并没有限定用户必须使用的加密和鉴定算法，允许通信双方选择合适的算法和参数，为保证互操作性而包含了一套加密算法，要求所有 IPsec 的实现都必须使用。许多机构都使用 IPsec 来保证虚拟专用网 VPN 的安全性。</p><p>IPsec 协议族中有两个主要协议：<strong>鉴别首部 AH 协议</strong>和<strong>封装安全有效载荷 ESP 协议</strong>。当某源 IPsec 实体向一个目的实体发发送安全数据报时，它可以使用 AH 或 ESP 协议来实现。AH 提供源鉴别和数据完整性服务，而 ESP 除了这两种服务外还可以提供机密性服务，因此使用要比 AH 广泛许多。使用 AH 或 ESP 的 IP 数据报称为 IP 安全数据报，它可以在两台主机、两台路由器或一台主机和一个路由器之间发送。IP 安全数据报有两种工作方式：① 运输方式，在整个运输层报文段的前后分别加上控制信息再加上 IP 首部，构成 IP 安全数据报。② 隧道方式，在原始的 IP 数据报的前后分别加上控制信息，构成 IP 安全数据报，这种方式使用较多。</p><p><strong>运输层</strong></p><p>运输层的安全协议主要是 SSL 安全套节字层和 TLS 运输层安全，TLS 是 SSL3.0 的修改版本。SSL 主要作用在端系统的 HTTP 和运输层之间，在 TCP 上建立起一个安全通道，为 TCP 传输的应用层数据提供安全保障。应用层使用 SSL 最多的就是 HTTP，但 SSL 并不是只用于 HTTP，而是可以用于任何应用层的协议，例如 SSL 也可以用于邮件存取的鉴别和数据加密。</p><p>SSL 提供的安全性服务包括三种：① <strong>服务器鉴别</strong>，允许用户证实服务器的身份，支持 SSL 的客户端通过验证来自服务器的证书来鉴别服务器的身份并取得服务器的公钥。② <strong>客户鉴别</strong>，SSL 可选的安全服务，允许服务器验证用户的身份。③ <strong>加密的 SSL 会话</strong>，对客户和服务器发送的所有报文进行加密，并检测报文是否被篡改。</p><hr><h3 id="防火墙和入侵检测"><a href="#防火墙和入侵检测" class="headerlink" title="防火墙和入侵检测"></a>防火墙和入侵检测</h3><p>在计算机网络中，当通信流量进入/离开网络时要执行安全检查、做记录、丢弃或转发，这些工作都有防火墙和入侵检测系统来完成。</p><p><strong>防火墙</strong></p><p>防火墙是一个硬件和软件的结合体，它将一个机构的内部网络与整个因特网隔离开，内部的属于可信网络，外部的属于不可信网络，允许一些数据分组通过而阻止另一些。它属于一种访问控制技术，通过严格控制进出网络的分组来禁止任何不必要的通信，从而减少潜在侵入的发送，从外部到内部和从内部到外部的所有流量都必须经过防火墙，只有被授权的流量才允许通过，授权与否由本地的安全策略定义，防火墙可以限制对授权流量的访问。 </p><p>防火墙分为三种：① 基于<strong>分组过滤</strong>，分组过滤器独立地检查每个数据报，然后基于管理员特定的规则决定该数据报应当允许通过还是丢弃，过滤因素通常包括 IP 源或目的地址、TCP 或 UDP 地源和目的端口、IP 数据报中的协议字段类型等。②  基于<strong>状态过滤</strong>，利用一张连接表来实际地跟踪 TCP 连接，并使用跟踪信息做出过滤决定。③ <strong>应用程序网关</strong>，这是一个应用程序特定的服务器，所有应用程序数据都必须通过它，每种程序都需要一个不同的应用网关。</p><p><strong>入侵检测系统 IDS</strong></p><p>防火墙不可能阻止所有入侵行为，入侵检测系统作为第二道防线，通过对进入网络的分组进行深度分析与检测发现异常网络行为，并进行报警以便进一步处理。IDS 可以用于检测多种攻击，包括网络映射、端口扫描、DoS 带宽洪泛攻击、病毒和蠕虫等。一个机构可以在它的机构网络中部署一个或多个 IDS 传感器，由于 IDS 不仅需要做深度分组检查，还必须要把每个过往的分组与数以万计的特征进行比较，因此会导致很大的处理量，所以一般都需要多个 IDS 传感器。IDS 系统可以大致分为基于特征的系统和基于异常的系统。</p><p><strong>基于特征的 IDS</strong> 维护了一个范围广泛的攻击特征数据库，每个特征是一个与入侵活动相关联的规则集，基于特征的 IDS 嗅探通过它的每个分组，将分组中的数据与数据库中的特征进行比较，如果匹配将产生一个警告，该警告能够发送一个电子邮件报文给网络管理员或者网络管理系统。但是基于特征的 IDS 无法应对新型攻击，并且即使与特征匹配时也可能不是一个攻击而因此产生了一个虚假警告。</p><p><strong>基于异常的 IDS</strong> 会观察正常运行的流量，并生成一个流量概况文件。它会寻找统计上不寻常的分组流，例如 ICMP 分组不寻常的百分比或端口扫描指数性突然增长。基于异常的 IDS 最大的特点就是不依赖现有攻击的以前只是，另一方面区分正常流量和统计异常流量也是一个挑战。至今大多数部署的 IDS 主要是基于特征的。</p><hr><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>多道程序环境下允许多个程序并发执行，进程就是为了更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p><p>进程就是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。系统资源指的是处理机、存储器和其他设备服务于某个进程的时间，例如把处理机资源理解为处理机的时间片才是准确的。因为进程是这些资源分配和调度的独立单位，这就决定了进程一定是一个动态的、过程性的概念。</p><p><strong>结构</strong></p><p>①进程控制块PCB：进程实体的一部分，进程存在的唯一标识，包括进程描述信息、控制和管理信息、资源分配清单和处理机相关信息。</p><p>②程序段：就被进程调度程序调度到CPU执行的程序代码段。</p><p>③数据段：进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p><p><strong>特征</strong></p><p>①动态性 进程是一次程序的执行，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。</p><p>②并发性 指多个进程同时存在于内存中，能在一段时间内同时运行。并发性是进程的重要特征，也是操作系统的重要特征。进入进程的目的就是为了使程序能与其他进程的程序并发执行，提高资源利用率。</p><p>③独立性 指进程实体是一个能独立运行、独立获得自由和独立接受调度的基本单位。</p><p>④异步性 由于进程的相互制约，会使进程具有执行的间断性，即进程按各自独立的，不可预知的速度向前推进。</p><p>⑤结构性 每个进程都配置有一个进程控制块PCB对其进行描述，从结构上看进程实体是由程序段、数据段和PCB组成的。</p><p><strong>进程的状态和转换</strong></p><p>①运行态 进程正在处理机上运行</p><p>②就绪态 进程已处于准备运行的状态，获得了除处理机外的一切资源</p><p>③阻塞态 进程正在等待某一事件而暂停运行，如等待某资源可用或等待输入/输出流</p><p>④创建态 进程正在被创建，尚未转到就绪态</p><p>⑤结束态 进程正从系统中消失，可能是正常结束或其他原因中断退出</p><p>就绪-&gt;运行：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片）</p><p>运行-&gt;就绪：处于运行态的进程在时间片用完后，不得不让出处理机。在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转为就绪态，让更高优先级的进程执行。</p><p>运行-&gt;阻塞：进程请求某一资源的使用和分配或等待某事件的发生（如IO完成），进程以系统调用的形式请求操作系统提供服务。</p><p>阻塞-&gt;就绪：进程等待的事件到来时，如IO结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞转为就绪态。</p><p><strong>进程控制</strong></p><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p><strong>进程创建</strong></p><p>允许一个进程创建另一个进程，创建者为父进程，被创建者为子进程。子进程可以继承父进程所拥有的资源，当子进程被撤销时，应将父进程的资源归还。撤销父进程时，必须同时撤销所有子进程。</p><p>①为新进程分配一个唯一的进程标识号，并申请一个空白PCB。②为进程分配资源，为新进程的程序和数据分配必要内存空间。若资源不足不会创建失败而是进入阻塞态。③初始化PCB，包括标志信息，处理机状态信息，进程优先级等。④若进程就绪队列未满，就将新进程插入就绪队列等待被调度。</p><p><strong>进程终止</strong></p><p>正常结束，表示进程任务已经完成并准备退出运行。异常结束，表示进程在运行时发生了某种异常，使程序无法继续运行，例如非法指令，IO故障等。外界干预，指进程因为外界请求而终止，例如操作系统干预或父进程请求终止等。</p><p>①根据被终止进程的标识符，检索PCB，读出该进程的状态。②若处于执行状态，终止执行，将处理机资源分配给其他进程。③若进程还有子进程，应将所有子进程终止。④将该进程的全部资源归还给父进程或操作系统。⑤将PCB从所在队列删除。</p><p><strong>进程阻塞</strong></p><p>①找到将要被阻塞进程的PCB。②如果为运行态，保护现场转为阻塞态，停止运行。③把PCB插入相应事件的等待队列。</p><p><strong>进程唤醒</strong></p><p>①在该事件的等待队列中找到进程对应的PCB。②将其从等待队列中移除，设置状态为就绪态。③将PCB插入就绪队列，等待调度程序调度。</p><p><strong>进程切换</strong></p><p>①保存处理机上下文，包括程序计数器和其他寄存器。②更新PCB信息。③把进程的PCB移入相应的队列。④选择另一个进程执行并更新其PCB。⑤更新内存管理的数据结构。⑥恢复处理机上下文。</p><p><strong>进程通信</strong></p><p>①共享存储：在通信的进程之间存在一块可以直接访问的共享空间，共享存储分为两种：低级的共享基于数据结构，高级的共享基于存储区。操作系统只负责为通信进程提供可共享的存储空间和同步互斥工具，数据交换由用户自己安排读写指令完成。</p><p>②消息传递：进程间的数据交换以格式化的消息为单位，进程提供系统提供的发送消息和接收消息两个原语进行数据交换。消息传递分为：直接通信方式，把消息挂在接收进程的消息缓存队列上。间接通信方式，发送进程把消息发送到某个中间实体，中间实体一般称作信箱，相应的通信系统为电子邮件系统。</p><p>③管道通信：消息传递的一种特殊方式，管道就是连接一个读进程和一个写进程来实现它们通信的一个共享文件。管道可以理解为共享存储的优化和发展，管道通信中存储空间优化为缓冲区，缓冲区只允许一边写入另一边读出，只要缓冲区有数据进程就能从缓冲区读出，只要有数据写进程就不会往缓冲区写数据，因此管道通信是半双工通信。</p><hr><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>引入进程的目的是为了多道程序更好的并发执行，提高资源利用率和吞吐量；引入线程的目的是为了减少程序在并发执行时的时空开销，提高操作系统的并发性能。</p><p>线程就是一种轻量级的进程，是一个基本的CPU执行单位，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是操作系统独立调度和分配的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它与同一进程下的其他线程共享进程的全部资源。</p><p><strong>线程和进程的区别</strong></p><p>①调度：进程是拥有资源的基本单位，而线程是独立调度的基本单位。在同一进程中，线程的切换不会引起进程的切换。在不同进程中线程的切换会引起进程切换。</p><p>②拥有资源：不管是传统操作系统还是有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源，只有一点运行中必不可少的资源。如果线程也是拥有资源的单位，那么切换线程就需要较大的时空开销，它的引入就没有意义。</p><p>③系统开销：创建和撤销进程涉及资源的分配和回收，操作系统的开销远大于创建或撤销线程的开销。进程切换也需要涉及CPU环境的保存和新调度到进程CPU环境的设置，但线程切换只需要保存和设置少量的寄存器容量，开销很小。</p><p>④地址空间：进程的地址空间之间互相独立，同一进程的各个线程共享进程的资源，进程内的线程对其他进程不可见。</p><p>⑤通信：进程间通信需要同步和互斥手段的辅助，保证数据一致性。线程可以直接读写进程数据段（全局变量）来进行通信。</p><p><strong>线程的实现方式</strong></p><p>①用户级线程：有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。</p><p>②内核级线程：线程管理的所有工作都由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。</p><hr><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁就是指多个进程因为互相竞争资源而陷入的一种僵局，如果没有外力的作用，这些进程都无法继续向前推进。</p><p>死锁的原因包含了：</p><p>①不可剥夺资源数量的不足，如果是可剥夺资源是不会造成死锁的。</p><p>②进程的推进顺序非法，进程请求和释放资源的顺序不当，例如进程P1和P2分别占用资源R1和R2，而此时P1和P2又分别申请资源R2和R1。</p><p>③信号量的使用不当，彼此等待对方的消息。</p><p>死锁有四个必要条件：</p><p>①互斥条件，进程对资源的占用具有排他性控制，如果进程请求的资源已被占用，请求就会被阻塞。</p><p>②不可剥夺条件，当一个资源没有被使用完成前是不能被其他进程强行获取的，只有占用它的进程主动释放才可以。</p><p>③请求和保持条件，一个进程已经占有了某个资源，又要请求其他资源，而该资源被其他进程占用，请求被阻塞，但进程也不会释放自己已经占有的资源。</p><p>④循环等待条件，存在一个进程资源的循环等待链，链中每个进程已经占有的资源同时是其他进程请求的资源。</p><p><strong>预防</strong></p><p>事先预防，实现起来比较简单，但是条件严格，效率很低。</p><p>①破坏互斥条件，系统中的所有资源都允许共享，但是有的资源不能同时访问，不太现实。</p><p>②破坏不可剥夺条件，允许剥夺其他进程已经占有的资源，可能会造成前段工作的失效，如果频繁发送就会增加系统开销，严重降低系统的吞吐量。</p><p>③破坏请求和保持条件，采用预先资源分配法，一次性分配进程需要的所有资源，缺点是会严重浪费系统资源。</p><p>④破坏循环等待条件，采用顺序资源分配法， 缺点是会造成编程不便。</p><p><strong>避免</strong></p><p>同样也是事先预防，不同的是动态地根据情况来避免死锁，性能比较好。</p><p>①系统安全状态，不安全的系统可能会导致死锁，安全的系统状态不会导致死锁，如果资源分配不会进入不安全的系统状态就给进程分配资源。</p><p>②银行家算法，把操作系统视为银行家，操作系统管理的资源视为资金，进程向操作系统申请资源相当于贷款。采用预先资源分配策略，主要的数据结构是可利用的资源向量，分配矩阵，需求矩阵，最大需求矩阵。</p><p><strong>检测</strong></p><p>画出资源分配图，圆圈表示进程，框表示一类资源。进程到资源是请求边，资源到进程是分配边。然后利用死锁定理来简化资源分配图，如果S不可被完全简化那么代表是一个死锁。</p><p><strong>解除</strong></p><p>如果没有采取死锁的预防和避免，就要采用死锁的检测和解除。</p><p>①资源剥夺法：挂起某些死锁进程并剥夺其资源。</p><p>②撤销进程法：撤销一个甚至全部死锁进程并剥夺其资源。</p><p>③进程回退法：让一个或多个进程回到不至于造成死锁的状态。</p><h2 id="分页分段"><a href="#分页分段" class="headerlink" title="分页分段"></a>分页分段</h2><p>传统存储管理方式：操作系统引入了虚拟内存的概念，利用计算机的空间局部性和时间局部性原理，将程序分的一部分装入内存运行，其余部分留在外存，等需要的时候再讲外存的程序装入内存继续运行。</p><h3 id="虚拟内存实现方式："><a href="#虚拟内存实现方式：" class="headerlink" title="虚拟内存实现方式："></a>虚拟内存实现方式：</h3><p>请求分页，请求分段，请求段页式存储管理。请求分页存储管理中，将虚拟地址内存空间划分为大小相等的页块，同时内存地址空间，也划分为等大小的页块。系统维持一个页表，存储这虚拟页号到物理快块号的映射。程序中的逻辑地址由两部分组成：页号P和页内位移量W。块号*块大小加上页内偏移得到物理地址。</p><p>如果程序执行时，调用到不再内存中的虚拟页面时，发生缺页中断，将页由外存调入内存。如果内存已满，采用页面置换算法将老的淘汰，载入新的。页面置换算法常见的有FIFO,LRU。</p><p><img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201024091740786.png" alt="image-20201024091740786"></p><p>优点：没有外碎片，每个内碎片不超过页的大小。</p><p>缺点：程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。</p><h3 id="请求分段存储管理："><a href="#请求分段存储管理：" class="headerlink" title="请求分段存储管理："></a>请求分段存储管理：</h3><p>将用户程序地址空间分成若干个大小不等的段，每段能够定义一组相对完整的逻辑信息。存储分配时，以段为单位，段内地址连续，段间不连续。虚拟地址由段号和段内地址组成，虚拟地址到实存地址的变换通过段表来实现。 分页对程序猿而言是不可见的。而分段通常对程序猿而言是可见的，因而分段为组织程序和数据提供了方便。段页式存储组织是分段式和分页式结合的存储组织方法。这样可充分利用分段管理和分页管理的长处。</p><p><img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201024091751743.png" alt="image-20201024091751743"></p><p>优点：可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。</p><p>缺点：会产生碎片。</p><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统</p><p>的共享和保护，又拥有分页系统的虚拟内存功能。</p><p><img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201024091706330.png" alt="image-20201024091706330"></p><h3 id="大内核和微内核有什么区别？"><a href="#大内核和微内核有什么区别？" class="headerlink" title="大内核和微内核有什么区别？"></a>大内核和微内核有什么区别？</h3><ul><li>大内核，就是将操作系统的全部功能都放进内核里面，组成一个紧密连接整体。大内核的优点就是效率高，但是很难定位<code>bug</code>，拓展性比较差，每次需要增加新的功能，都要将新的代码和原来的内核代码重新编译。 </li><li>微内核与单体内核不同，微内核只是将操作中最核心的功能加入内核，包括<code>IPC</code>、地址空间分配和基本的调度，这些东西都在内核态运行，其他功能作为模块被内核调用，并且是在用户空间运行。微内核比较好维护和拓展，但是效率可能不高，因为需要频繁地在内核态和用户态之间切换。</li></ul><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>作者：风雨下钟山<br>链接：<a href="https://www.nowcoder.com/discuss/468422" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/468422</a><br>来源：牛客网</p><h4 id="Socket通信流程是怎样的？"><a href="#Socket通信流程是怎样的？" class="headerlink" title="Socket通信流程是怎样的？"></a>Socket通信流程是怎样的？</h4><p><img src="https://uploadfiles.nowcoder.com/images/20200806/6638786_1596672311055_5EE57B5D9BB579AAED205B35F053429B" alt="图片说明"> </p><ul><li>概括地说，就是通信的两端都建立了一个 <code>Socket</code> ，然后通过 <code>Socket</code> 对数据进行传输。通常服务器处于一个无限循环，等待<a href>客户端</a>的连接。 </li><li>对于<a href>客户端</a>，它的的过程比较简单，首先创建 <code>Socket</code>，通过<code>TCP</code>连接服务器，将 <code>Socket</code> 与远程主机的某个进程连接，然后就发送数据，或者读取响应数据，直到数据交换完毕，关闭连接，结束 <code>TCP</code> 对话。 </li><li>对于服务端，先初始化 <code>Socket</code>，建立流式套接字，与本机地址及端口进行绑定，然后通知 <code>TCP</code>，准备好接收连接，调用 <code>accept()</code> 阻塞，等待来自<a href>客户端</a>的连接。如果这时<a href>客户端</a>与服务器建立了连接，<a href>客户端</a>发送数据请求，服务器接收请求并处理请求，然后把响应数据发送给<a href>客户端</a>，<a href>客户端</a>读取数据，直到数据交换完毕。最后关闭连接，交互结束。 </li></ul><h4 id="延伸问题：从TCP连接的角度说说Socket通信流程。"><a href="#延伸问题：从TCP连接的角度说说Socket通信流程。" class="headerlink" title="延伸问题：从TCP连接的角度说说Socket通信流程。"></a>延伸问题：从<code>TCP</code>连接的角度说说Socket通信流程。</h4><p><img src="https://uploadfiles.nowcoder.com/images/20200806/6638786_1596672375547_34FD922BEF6AB289D1B71C7D84037E42" alt="图片说明"> </p><p>首先是三次握手的<code>Socket</code>交互流程。</p><ol><li>服务器调用 <code>socket()</code>、<code>bind()</code>、<code>listen()</code> 完成初始化后，调用 <code>accept()</code> 阻塞等待； </li><li><a href>客户端</a> <code>Socket</code> 对象调用 <code>connect()</code> 向服务器发送了一个 <code>SYN</code> 并阻塞； </li><li>服务器完成了第一次握手，即发送 <code>SYN</code> 和 <code>ACK</code> 应答； </li><li><a href>客户端</a>收到服务端发送的应答之后，从 <code>connect()</code> 返回，再发送一个 <code>ACK</code> 给服务器； </li><li>服务器 <code>Socket</code> 对象接收<a href>客户端</a>第三次握手 <code>ACK</code> 确认，此时服务端从 <code>accept()</code> 返回，建立连接。 </li></ol><p>接下来就是两个端的连接对象互相收发数据。</p><p><img src="https://uploadfiles.nowcoder.com/images/20200806/6638786_1596672413212_A3DEEBF7F3F9D50D1D3613B9F2A48D7B" alt="图片说明"> </p><p>然后是四次挥手的<code>Socket</code>交互流程。</p><ol><li>某个应用进程调用 <code>close()</code> 主动关闭，发送一个 <code>FIN</code>； </li><li>另一端接收到 <code>FIN</code> 后被动执行关闭，并发送 <code>ACK</code> 确认； </li><li>之后被动执行关闭的应用进程调用 <code>close()</code> 关闭 <code>Socket</code>，并也发送一个 <code>FIN</code>； </li><li>接收到这个 <code>FIN</code> 的一端向另一端 <code>ACK</code> 确认。</li></ol><h3 id="close-wait产生原因"><a href="#close-wait产生原因" class="headerlink" title="close_wait产生原因"></a>close_wait产生原因</h3><p>通常，CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的 CLOSE_WAIT 状态，那么就意味着被动关闭的一方没有及时发出 FIN 包，一般有如下几种可能：</p><ul><li>程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。</li><li>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。</li><li>BACKLOG 太大：此处的 backlog 不是 syn backlog，而是 accept 的 backlog，如果 backlog 太大的话，设想突然遭遇大访问量的话，即便响应速度不慢，也可能出现来不及消费的情况，导致多余的请求还在<a href="http://jaseywang.me/2014/07/20/tcp-queue-的一些问题/" target="_blank" rel="noopener">队列</a>里就被对方关闭了。</li></ul><p>如果你通过「netstat -ant」或者「ss -ant」命令发现了很多 CLOSE_WAIT 连接，请注意结果中的「Recv-Q」和「Local Address」字段，通常「Recv-Q」会不为空，它表示应用还没来得及接收数据，而「Local Address」表示哪个地址和端口有问题，我们可以通过「lsof -i:<PORT>」来确认端口对应运行的是什么程序以及它的进程号是多少。</PORT></p><p>如果是我们自己写的一些程序，比如用 HttpClient 自定义的蜘蛛，那么八九不离十是程序问题，如果是一些使用广泛的程序，比如 Tomcat 之类的，那么更可能是响应速度太慢或者 timeout 设置太小或者 BACKLOG 设置过大导致的故障。</p><h3 id="第二次挥手和第三次挥手能不能合并"><a href="#第二次挥手和第三次挥手能不能合并" class="headerlink" title="第二次挥手和第三次挥手能不能合并"></a>第二次挥手和第三次挥手能不能合并</h3><p>第二次挥手的目的是确认你刚才给我发的包已经收到了，第三次挥手的目标是一个新的请求，因为第一次挥手数据包过来时服务器要有两件事要做，diyijianercihuishoudehuifu第一件二次挥手的回复，第二件通过应用程序解阻塞之后才能调用close，这个应用程序有可能调用了close，也有可能没调用，只要不调用close，就没有第三次挥手，如果第一次挥手发了数据包之后，服务器是要尽快去认，应用程序里面迟迟不调用close，所以第三次挥手迟迟发不了，如果把二和三合并一起，第三次迟迟发不了，两次挥手都发不了，客户端还等着呢，所以不能合并，拆开发。</p><h3 id="那为什么会有close-wait状态呢"><a href="#那为什么会有close-wait状态呢" class="headerlink" title="那为什么会有close_wait状态呢"></a>那为什么会有close_wait状态呢</h3><p>·在服务器与客户端通信的过程中，因为服务器未关闭socket导致closed_wait的发生，当客户端不断地发送连接请求的时候，这样打开的文件描述符就会不断增加。在linux系统中，一个进程可以最大同时打开的文件描述符是有限的。通过ulimit可以查看。</p><h3 id="IO复用？"><a href="#IO复用？" class="headerlink" title="IO复用？"></a>IO复用？</h3><p>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p>1、select、poll和epoll<br>·select、poll、epoll都可以监听多个文件描述符，等待指定的超时时间，直到一个或者多个文件描述符上有事件发生时返回。返回的值就是文件描述符的数量。返回0表示没有事件发生。</p><p>·差别：<br> (1)事件集<br>  ·select有三种类型的描述符类型：readfds、writefds、exceptfds，分别对应读、写、异常条件的描述符集合。因此，select不能处理这三种事件以外的事件类型。并且，每一次select会使得内核直接对fd_set进行修改，再下一次使用select的时候需要重置fd_set。每次select返回的都是注册了的事件集合，包括了就绪和没有就绪的，程序检索就绪事件的时间复杂度为O(n)</p><p>  ·poll对select进行了改进，poll的参数是一个结构体pollfd。poll不会修改描述符，因此每次使用不需要重置pollfd。但是，poll仍然是返回注册了的事件集合，包括了就绪和没有就绪的，程序检索就绪事件的时间复杂度为O(n)。</p><p>  ·epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<br>红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事<br>件完成的描述符。使得检索的时间复杂度达到O(1)</p><p> (2)支持最大的文件描述符<br>  ·select：受到系统的限制，由&lt;sys/select.h&gt;头文件中的FD_SETSIZE宏决定，通常是1024<br>  ·poll和epoll一般为65535</p><p> (3)工作模式<br>  ·select和poll只能工作在相对来说低效的水平触发模式(LT)<br>  ·epoll可以工作在高效的边缘触发模式(ET),也可以工作在水平触发模式</p><p> (4)实现原理<br>  ·select和poll都是基于轮询的方式，每一次的调用都要扫描整个注册的文件描述符集合，并将其中就绪的文件描述符返回给用户，因此检测就绪事件的时间复杂度是O(n)<br>  ·epoll_wait是采用回调的方式，内核检测到了就绪文件描述符，就会触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪队列中，内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此epoll_wait无需轮询检测哪些事件已经就绪，其时间复杂度是O(1)<br>  ·epoll需要触发回调函数，因此更适用于连接数目多，但活动连接较少的情况。</p><h3 id="同步与异步，阻塞和非阻塞"><a href="#同步与异步，阻塞和非阻塞" class="headerlink" title="同步与异步，阻塞和非阻塞"></a>同步与异步，阻塞和非阻塞</h3><p>同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p><p>而异步则是相反，<strong><em>调用\</em>在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p><p>·阻塞是指结果返回前，当前进程直接被挂起，一直等待结果的到来； 非阻塞则立刻返回，执行后续操作</p><p>·同步阻塞：当前进程在等待时，没有执行其他操作而是被挂起<br>·同步非阻塞：线程等待的时候，执行其它操作(效率低，很有可能设计线程切换的操作)</p><p>·异步阻塞：线程在等待消息通知时被挂起<br>·异步非阻塞：线程不等待，可以去做其他事情</p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p><ol><li>LT 模式<br>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait()<br>会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</li><li>ET 模式<br>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。<br>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个<br>文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</li></ol><h3 id="工作场景"><a href="#工作场景" class="headerlink" title="工作场景"></a>工作场景</h3><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><ol><li>select 应用场景<br>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比<br>如核反应堆的控制。<br>select 可移植性更好，几乎被所有主流平台所支持。</li><li>poll 应用场景<br>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</li><li>epoll 应用场景<br>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。<br>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。<br>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在<br>内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且<br>epoll 的描述符存储在内核，不容易调试。</li></ol><h3 id="arp欺骗"><a href="#arp欺骗" class="headerlink" title="arp欺骗"></a>arp欺骗</h3><p>在使用以太网交换机的网络中，攻击者向某个以太网交换机发送大量的伪造源 MAC 地址，以太网交换机收到这样的帧就把虚假的 MAC 源地址填入到交换表中，由于伪造的数量很大很快就填满了表，导致以太网交换机无法正常工作。</p><p> 1.解决方法：利用交换机防止ARP攻击</p><p>在交换机上绑定MAC地址与IP地址，为每台主机添加一条IP地址和MAC地址对应的关系静态地址表。用户发送数据包时，若交换机获得的IP和MAC地址与之前建立的映射表匹配，则发送的包能通过，否则将丢弃该数据包，从而有效地防止ARP欺骗。</p><p>2.[DHCP snooping](<a href="https://baike.baidu.com/item/DHCP" target="_blank" rel="noopener">https://baike.baidu.com/item/DHCP</a> snooping)，网上设备可借由<a href="https://baike.baidu.com/item/DHCP" target="_blank" rel="noopener">DHCP</a>保留网络上各计算机的MAC地址，在伪造的ARP数据包发出时即可侦测到。此方式已在一些厂牌的网上设备产品所支持。</p><p>3.每台计算机的ARP一律改用静态的方式，不过这在大型的网上是不可行的，因为需要经常更新每台计算机的ARP表。</p><h3 id="SYN-flood"><a href="#SYN-flood" class="headerlink" title="SYN flood"></a>SYN flood</h3><p>Syn-Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问。</p><p>解决方法</p><p>1.无效连接监视释放</p><p>这种方法不停监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。</p><p>2.延缓TCB分配方法</p><p>从前面SYN Flood原理可以看到，消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用SYN Cache和SYN Cookie技术。</p><p>SYN Cache技术：</p><p>这种技术是在收到SYN数据报文时不急于去分配TCB，而是先回应一个SYN ACK报文，并在一个专用HASH表（Cache）中保存这种半开连接信息，直到收到正确的回应ACK报文再分配TCB。</p><p>SYN Cookie技术：</p><p>对于SYN攻击，SYN Cache虽然不分配TCB，但是为了判断后续对方发来的ACK报文中的Sequence Number的正确性，还是需要使用一些空间去保存己方生成的Sequence Number等信息，也造成了一些资源的浪费。Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（SequenceNumber-1）相同，从而决定是否分配TCB资源。</p><p>3．使用SYN Proxy防火墙</p><p>SYN Cache技术和SYN Cookie技术总的来说是一种主机保护技术，需要系统的TCP/IP协议栈的支持，而目前并非所有的操作系统支持这些技术。因此很多防火墙中都提供一种 SYN代理的功能，其主要原理是对试图穿越的SYN请求进行验证后才放行，下图描述了这种过程：</p><h3 id="DNS欺骗？"><a href="#DNS欺骗？" class="headerlink" title="DNS欺骗？"></a>DNS欺骗？</h3><p> DNS欺骗就是攻击者冒充<a href="https://baike.baidu.com/item/域名服务器/9705133" target="_blank" rel="noopener">域名服务器</a>的一种欺骗行为。 原理：如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。</p><ol><li><p>进行IP地址和MAC地址的绑定</p><p>(1)预防ARP欺骗攻击。因为DNS攻击的欺骗行为要以ARP欺骗作为开端，所以如果能有效防范或避免ARP欺骗，也就使得DNS ID欺骗攻击无从下手。例如可以通过将Gateway Router 的Ip Address和MAC Address静态绑定在一起，就可以防范ARP攻击欺骗。</p></li></ol><p>2.直接使用IP地址访问</p><p>   对个别信息安全等级要求十分严格的WEB站点尽量不要使用DNS进行解析。由于DNS欺骗攻击中不少是针对窃取客户的私密数据而来的，而多数用户访问的站点并不涉及这些隐私信息，因此当访问具有严格保密信息的站点时，可以直接使用IP地址而无需通过DNS解析，这样所有的DNS欺骗攻击可能造成的危害就可以避免了。除此，应该做好DNS Server的安全配置项目和升级DNS软件，合理限定DNS Server进行响应的IP地址区间，关闭DNS Server的递归查询项目等。</p><p>3.对DNS数据包进行监测</p><p>   在DNS欺骗攻击中，Client会接收到至少两个DNS的数据响应包，一个是真实的数据包，另一个是攻击数据包。欺骗攻击数据包为了抢在真实应答包之前回复给Client，它的信息数据结构与真实的数据包相比十分简单，只有应答域，而不包括授权域和附加域。因此，可以通过监测DNS响应包，遵循相应的原则和模型算法对这两种响应包进行分辨，从而避免虚假数据包的攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字节算法题汇总</title>
      <link href="/2020/09/28/%E5%AD%97%E8%8A%82%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2020/09/28/%E5%AD%97%E8%8A%82%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>作者：星__尘<br>链接：<a href="https://www.nowcoder.com/discuss/428158?page=2" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/428158?page=2</a><br>来源：牛客网</p><h2 id="动态规划和贪心"><a href="#动态规划和贪心" class="headerlink" title="动态规划和贪心"></a><strong><a href>动态规划</a>和贪心</strong></h2><ul><li><p><a href>算法题</a>：买卖股票的最佳时机（只能有一次买卖，可以最多两次买卖，不限次数） </p><p>股票问题通用解法详解参考： <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/</a> </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缓存优化</title>
      <link href="/2020/09/09/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"/>
      <url>/2020/09/09/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2020/09/09/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200909163600765.png" alt="image-20200909163600765"></p><p>caffeine</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 帖子列表缓存</span><br><span class="line">private LoadingCache&lt;String, List&lt;DiscussPost&gt;&gt; postListCache;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 帖子总数缓存</span><br><span class="line">private LoadingCache&lt;Integer, Integer&gt; postRowsCache;</span><br><span class="line"></span><br><span class="line">@PostConstruct</span><br><span class="line">public void init() &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化帖子列表缓存</span><br><span class="line">    postListCache &#x3D; Caffeine.newBuilder()</span><br><span class="line">            .maximumSize(maxSize)</span><br><span class="line">            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)</span><br><span class="line">            .build(new CacheLoader&lt;String, List&lt;DiscussPost&gt;&gt;() &#123;</span><br><span class="line">                @Nullable</span><br><span class="line">                @Override</span><br><span class="line">                public List&lt;DiscussPost&gt; load(@NonNull String key) throws Exception &#123;</span><br><span class="line">                    if (key &#x3D;&#x3D; null || key.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        throw new IllegalArgumentException(&quot;参数错误!&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String[] params &#x3D; key.split(&quot;:&quot;);</span><br><span class="line">                    if (params &#x3D;&#x3D; null || params.length !&#x3D; 2) &#123;</span><br><span class="line">                        throw new IllegalArgumentException(&quot;参数错误!&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    int offset &#x3D; Integer.valueOf(params[0]);</span><br><span class="line">                    int limit &#x3D; Integer.valueOf(params[1]);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 二级缓存: Redis -&gt; mysql</span><br><span class="line"></span><br><span class="line">                    logger.debug(&quot;load post list from DB.&quot;);</span><br><span class="line">                    return discussPostMapper.selectDiscussPosts(0, offset, limit, 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#x2F;&#x2F; 初始化帖子总数缓存</span><br><span class="line">    postRowsCache &#x3D; Caffeine.newBuilder()</span><br><span class="line">            .maximumSize(maxSize)</span><br><span class="line">            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)</span><br><span class="line">            .build(new CacheLoader&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                @Nullable</span><br><span class="line">                @Override</span><br><span class="line">                public Integer load(@NonNull Integer key) throws Exception &#123;</span><br><span class="line">                    logger.debug(&quot;load post rows from DB.&quot;);</span><br><span class="line">                    return discussPostMapper.selectDiscussPostRows(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>热帖排行</title>
      <link href="/2020/09/09/%E7%83%AD%E5%B8%96%E6%8E%92%E8%A1%8C/"/>
      <url>/2020/09/09/%E7%83%AD%E5%B8%96%E6%8E%92%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>Quartz</p><p>配置-&gt;数据库-&gt;调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 刷新帖子分数任务</span><br><span class="line">@Bean</span><br><span class="line">public JobDetailFactoryBean postScoreRefreshJobDetail() &#123;</span><br><span class="line">    JobDetailFactoryBean factoryBean &#x3D; new JobDetailFactoryBean();</span><br><span class="line">    factoryBean.setJobClass(PostScoreRefreshJob.class);</span><br><span class="line">    factoryBean.setName(&quot;postScoreRefreshJob&quot;);</span><br><span class="line">    factoryBean.setGroup(&quot;communityJobGroup&quot;);</span><br><span class="line">    factoryBean.setDurability(true);</span><br><span class="line">    factoryBean.setRequestsRecovery(true);</span><br><span class="line">    return factoryBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SimpleTriggerFactoryBean postScoreRefreshTrigger(JobDetail postScoreRefreshJobDetail) &#123;</span><br><span class="line">    SimpleTriggerFactoryBean factoryBean &#x3D; new SimpleTriggerFactoryBean();</span><br><span class="line">    factoryBean.setJobDetail(postScoreRefreshJobDetail);</span><br><span class="line">    factoryBean.setName(&quot;postScoreRefreshTrigger&quot;);</span><br><span class="line">    factoryBean.setGroup(&quot;communityTriggerGroup&quot;);</span><br><span class="line">    factoryBean.setRepeatInterval(1000 * 60 * 5);</span><br><span class="line">    factoryBean.setJobDataMap(new JobDataMap());</span><br><span class="line">    return factoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>帖子分数刷新的任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class PostScoreRefreshJob implements Job, CommunityConstant &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(PostScoreRefreshJob.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private LikeService likeService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ElasticsearchService elasticsearchService;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 牛客纪元</span><br><span class="line">    private static final Date epoch;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            epoch &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).parse(&quot;2014-08-01 00:00:00&quot;);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;初始化牛客纪元失败!&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        String redisKey &#x3D; RedisKeyUtil.getPostScoreKey();</span><br><span class="line">        BoundSetOperations operations &#x3D; redisTemplate.boundSetOps(redisKey);</span><br><span class="line"></span><br><span class="line">        if (operations.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            logger.info(&quot;[任务取消] 没有需要刷新的帖子!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;[任务开始] 正在刷新帖子分数: &quot; + operations.size());</span><br><span class="line">        while (operations.size() &gt; 0) &#123;</span><br><span class="line">            this.refresh((Integer) operations.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(&quot;[任务结束] 帖子分数刷新完毕!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void refresh(int postId) &#123;</span><br><span class="line">        DiscussPost post &#x3D; discussPostService.findDiscussPostById(postId);</span><br><span class="line"></span><br><span class="line">        if (post &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;该帖子不存在: id &#x3D; &quot; + postId);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 是否精华</span><br><span class="line">        boolean wonderful &#x3D; post.getStatus() &#x3D;&#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; 评论数量</span><br><span class="line">        int commentCount &#x3D; post.getCommentCount();</span><br><span class="line">        &#x2F;&#x2F; 点赞数量</span><br><span class="line">        long likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_POST, postId);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 计算权重</span><br><span class="line">        double w &#x3D; (wonderful ? 75 : 0) + commentCount * 10 + likeCount * 2;</span><br><span class="line">        &#x2F;&#x2F; 分数 &#x3D; 帖子权重 + 距离天数</span><br><span class="line">        double score &#x3D; Math.log10(Math.max(w, 1))</span><br><span class="line">                + (post.getCreateTime().getTime() - epoch.getTime()) &#x2F; (1000 * 3600 * 24);</span><br><span class="line">        &#x2F;&#x2F; 更新帖子分数</span><br><span class="line">        discussPostService.updateScore(postId, score);</span><br><span class="line">        &#x2F;&#x2F; 同步搜索数据</span><br><span class="line">        post.setScore(score);</span><br><span class="line">        elasticsearchService.saveDiscussPost(post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算帖子分数</p><p>log(评论数<em>10+点赞数</em>2)+现在时间-牛客纪元</p><p>点赞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    public String like(int entityType, int entityId, int entityUserId, int postId) &#123;</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if(entityType &#x3D;&#x3D; ENTITY_TYPE_POST) &#123;</span><br><span class="line">    &#x2F;&#x2F; 计算帖子分数</span><br><span class="line">    String redisKey &#x3D; RedisKeyUtil.getPostScoreKey();</span><br><span class="line">    redisTemplate.opsForSet().add(redisKey, postId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>评论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算帖子分数</span><br><span class="line">String redisKey &#x3D; RedisKeyUtil.getPostScoreKey();</span><br><span class="line">redisTemplate.opsForSet().add(redisKey, discussPostId);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kafka系统通知</title>
      <link href="/2020/09/08/Kafka%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/"/>
      <url>/2020/09/08/Kafka%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2020/09/08/Kafka%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908222307315.png" alt="image-20200908222307315"></p><p>Event</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Event &#123;</span><br><span class="line"></span><br><span class="line">    private String topic;</span><br><span class="line">    private int userId;</span><br><span class="line">    private int entityType;</span><br><span class="line">    private int entityId;</span><br><span class="line">    private int entityUserId;</span><br><span class="line">    private Map&lt;String, Object&gt; data &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EventProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理事件</span><br><span class="line">    public void fireEvent(Event event) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将事件发布到指定的主题</span><br><span class="line">        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public class EventConsumer implements CommunityConstant &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(EventConsumer.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MessageService messageService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ElasticsearchService elasticsearchService;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;wk.image.command&#125;&quot;)</span><br><span class="line">    private String wkImageCommand;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;wk.image.storage&#125;&quot;)</span><br><span class="line">    private String wkImageStorage;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;qiniu.key.access&#125;&quot;)</span><br><span class="line">    private String accessKey;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;qiniu.key.secret&#125;&quot;)</span><br><span class="line">    private String secretKey;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;qiniu.bucket.share.name&#125;&quot;)</span><br><span class="line">    private String shareBucketName;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ThreadPoolTaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    @KafkaListener(topics &#x3D; &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;)</span><br><span class="line">    public void handleCommentMessage(ConsumerRecord record) &#123;</span><br><span class="line">        if (record &#x3D;&#x3D; null || record.value() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息的内容为空!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Event event &#x3D; JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">        if (event &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息格式错误!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 发送站内通知</span><br><span class="line">        Message message &#x3D; new Message();</span><br><span class="line">        message.setFromId(SYSTEM_USER_ID);</span><br><span class="line">        message.setToId(event.getEntityUserId());</span><br><span class="line">        message.setConversationId(event.getTopic());</span><br><span class="line">        message.setCreateTime(new Date());</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; content &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        content.put(&quot;userId&quot;, event.getUserId());</span><br><span class="line">        content.put(&quot;entityType&quot;, event.getEntityType());</span><br><span class="line">        content.put(&quot;entityId&quot;, event.getEntityId());</span><br><span class="line"></span><br><span class="line">        if (!event.getData().isEmpty()) &#123;</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; entry : event.getData().entrySet()) &#123;</span><br><span class="line">                content.put(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        message.setContent(JSONObject.toJSONString(content));</span><br><span class="line">        messageService.addMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 消费发帖事件</span><br><span class="line">    @KafkaListener(topics &#x3D; &#123;TOPIC_PUBLISH&#125;)</span><br><span class="line">    public void handlePublishMessage(ConsumerRecord record) &#123;</span><br><span class="line">        if (record &#x3D;&#x3D; null || record.value() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息的内容为空!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Event event &#x3D; JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">        if (event &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息格式错误!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DiscussPost post &#x3D; discussPostService.findDiscussPostById(event.getEntityId());</span><br><span class="line">        elasticsearchService.saveDiscussPost(post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 消费删帖事件</span><br><span class="line">    @KafkaListener(topics &#x3D; &#123;TOPIC_DELETE&#125;)</span><br><span class="line">    public void handleDeleteMessage(ConsumerRecord record) &#123;</span><br><span class="line">        if (record &#x3D;&#x3D; null || record.value() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息的内容为空!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Event event &#x3D; JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">        if (event &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息格式错误!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elasticsearchService.deleteDiscussPost(event.getEntityId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 触发评论事件</span><br><span class="line">Event event &#x3D; new Event()</span><br><span class="line">        .setTopic(TOPIC_COMMENT)</span><br><span class="line">        .setUserId(hostHolder.getUser().getId())</span><br><span class="line">        .setEntityType(comment.getEntityType())</span><br><span class="line">        .setEntityId(comment.getEntityId())</span><br><span class="line">        .setData(&quot;postId&quot;, discussPostId);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 触发点赞事件</span><br><span class="line">if (likeStatus &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    Event event &#x3D; new Event()</span><br><span class="line">            .setTopic(TOPIC_LIKE)</span><br><span class="line">            .setUserId(hostHolder.getUser().getId())</span><br><span class="line">            .setEntityType(entityType)</span><br><span class="line">            .setEntityId(entityId)</span><br><span class="line">            .setEntityUserId(entityUserId)</span><br><span class="line">            .setData(&quot;postId&quot;, postId);</span><br><span class="line">    eventProducer.fireEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 触发关注事件</span><br><span class="line">Event event &#x3D; new Event()</span><br><span class="line">        .setTopic(TOPIC_FOLLOW)</span><br><span class="line">        .setUserId(hostHolder.getUser().getId())</span><br><span class="line">        .setEntityType(entityType)</span><br><span class="line">        .setEntityId(entityId)</span><br><span class="line">        .setEntityUserId(entityId);</span><br><span class="line">eventProducer.fireEvent(event);</span><br></pre></td></tr></table></figure><p>显示系统通知（我们只要评论，赞和关注)</p><p><img src="/2020/09/08/Kafka%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200909105702853.png" alt="image-20200909105702853"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;notice&#x2F;list&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">public String getNoticeList(Model model) &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询评论类通知</span><br><span class="line">    Message message &#x3D; messageService.findLatestNotice(user.getId(), TOPIC_COMMENT);</span><br><span class="line">    if (message !&#x3D; null) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; messageVO &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        messageVO.put(&quot;message&quot;, message);</span><br><span class="line"></span><br><span class="line">        String content &#x3D; HtmlUtils.htmlUnescape(message.getContent());</span><br><span class="line">        Map&lt;String, Object&gt; data &#x3D; JSONObject.parseObject(content, HashMap.class);</span><br><span class="line"></span><br><span class="line">        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));</span><br><span class="line">        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));</span><br><span class="line">        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));</span><br><span class="line">        messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));</span><br><span class="line"></span><br><span class="line">        int count &#x3D; messageService.findNoticeCount(user.getId(), TOPIC_COMMENT);</span><br><span class="line">        messageVO.put(&quot;count&quot;, count);</span><br><span class="line"></span><br><span class="line">        int unread &#x3D; messageService.findNoticeUnreadCount(user.getId(), TOPIC_COMMENT);</span><br><span class="line">        messageVO.put(&quot;unread&quot;, unread);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;commentNotice&quot;, messageVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询点赞类通知</span><br><span class="line">    message &#x3D; messageService.findLatestNotice(user.getId(), TOPIC_LIKE);</span><br><span class="line">    if (message !&#x3D; null) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; messageVO &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        messageVO.put(&quot;message&quot;, message);</span><br><span class="line"></span><br><span class="line">        String content &#x3D; HtmlUtils.htmlUnescape(message.getContent());</span><br><span class="line">        Map&lt;String, Object&gt; data &#x3D; JSONObject.parseObject(content, HashMap.class);</span><br><span class="line"></span><br><span class="line">        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));</span><br><span class="line">        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));</span><br><span class="line">        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));</span><br><span class="line">        messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));</span><br><span class="line"></span><br><span class="line">        int count &#x3D; messageService.findNoticeCount(user.getId(), TOPIC_LIKE);</span><br><span class="line">        messageVO.put(&quot;count&quot;, count);</span><br><span class="line"></span><br><span class="line">        int unread &#x3D; messageService.findNoticeUnreadCount(user.getId(), TOPIC_LIKE);</span><br><span class="line">        messageVO.put(&quot;unread&quot;, unread);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;likeNotice&quot;, messageVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询关注类通知</span><br><span class="line">    message &#x3D; messageService.findLatestNotice(user.getId(), TOPIC_FOLLOW);</span><br><span class="line">    if (message !&#x3D; null) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; messageVO &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        messageVO.put(&quot;message&quot;, message);</span><br><span class="line"></span><br><span class="line">        String content &#x3D; HtmlUtils.htmlUnescape(message.getContent());</span><br><span class="line">        Map&lt;String, Object&gt; data &#x3D; JSONObject.parseObject(content, HashMap.class);</span><br><span class="line"></span><br><span class="line">        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));</span><br><span class="line">        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));</span><br><span class="line">        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));</span><br><span class="line"></span><br><span class="line">        int count &#x3D; messageService.findNoticeCount(user.getId(), TOPIC_FOLLOW);</span><br><span class="line">        messageVO.put(&quot;count&quot;, count);</span><br><span class="line"></span><br><span class="line">        int unread &#x3D; messageService.findNoticeUnreadCount(user.getId(), TOPIC_FOLLOW);</span><br><span class="line">        messageVO.put(&quot;unread&quot;, unread);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;followNotice&quot;, messageVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询未读消息数量</span><br><span class="line">    int letterUnreadCount &#x3D; messageService.findLetterUnreadCount(user.getId(), null);</span><br><span class="line">    model.addAttribute(&quot;letterUnreadCount&quot;, letterUnreadCount);</span><br><span class="line">    int noticeUnreadCount &#x3D; messageService.findNoticeUnreadCount(user.getId(), null);</span><br><span class="line">    model.addAttribute(&quot;noticeUnreadCount&quot;, noticeUnreadCount);</span><br><span class="line"></span><br><span class="line">    return &quot;&#x2F;site&#x2F;notice&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>点赞关注</title>
      <link href="/2020/09/07/%E7%82%B9%E8%B5%9E%E5%85%B3%E6%B3%A8/"/>
      <url>/2020/09/07/%E7%82%B9%E8%B5%9E%E5%85%B3%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>点赞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public String like(int entityType, int entityId, int entityUserId, int postId) &#123;</span><br><span class="line">       User user &#x3D; hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 点赞</span><br><span class="line">       likeService.like(user.getId(), entityType, entityId, entityUserId);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 数量</span><br><span class="line">       long likeCount &#x3D; likeService.findEntityLikeCount(entityType, entityId);</span><br><span class="line">       &#x2F;&#x2F; 状态</span><br><span class="line">       int likeStatus &#x3D; likeService.findEntityLikeStatus(user.getId(), entityType, entityId);</span><br><span class="line">       &#x2F;&#x2F; 返回的结果</span><br><span class="line">       ....</span><br><span class="line">       ....</span><br></pre></td></tr></table></figure><p>关注</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;follow&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String follow(int entityType, int entityId) &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">    followService.follow(user.getId(), entityType, entityId);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;unfollow&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String unfollow(int entityType, int entityId) &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">    followService.unfollow(user.getId(), entityType, entityId);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;followees&#x2F;&#123;userId&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">public String getFollowees(@PathVariable(&quot;userId&quot;) int userId, Page page, Model model) &#123;</span><br><span class="line">    User user &#x3D; userService.findUserById(userId);</span><br><span class="line">    if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;该用户不存在!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(&quot;user&quot;, user);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;followers&#x2F;&#123;userId&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">public String getFollowers(@PathVariable(&quot;userId&quot;) int userId, Page page, Model model) &#123;</span><br><span class="line">    User user &#x3D; userService.findUserById(userId);</span><br></pre></td></tr></table></figure><p>关注列表</p><p>粉丝列表</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>点赞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void like(int userId, int entityType, int entityId, int entityUserId) &#123;</span><br><span class="line">    redisTemplate.execute(new SessionCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            String entityLikeKey &#x3D; RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">            String userLikeKey &#x3D; RedisKeyUtil.getUserLikeKey(entityUserId);</span><br><span class="line"></span><br><span class="line">            boolean isMember &#x3D; operations.opsForSet().isMember(entityLikeKey, userId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            if (isMember) &#123;</span><br><span class="line">                operations.opsForSet().remove(entityLikeKey, userId);</span><br><span class="line">                operations.opsForValue().decrement(userLikeKey);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                operations.opsForSet().add(entityLikeKey, userId);</span><br><span class="line">                operations.opsForValue().increment(userLikeKey);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询某实体点赞的数量</span><br><span class="line">public long findEntityLikeCount(int entityType, int entityId) &#123;</span><br><span class="line">    String entityLikeKey &#x3D; RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">    return redisTemplate.opsForSet().size(entityLikeKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询某人对某实体的点赞状态</span><br><span class="line">public int findEntityLikeStatus(int userId, int entityType, int entityId) &#123;</span><br><span class="line">    String entityLikeKey &#x3D; RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">    return redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? 1 : 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关注</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void follow(int userId, int entityType, int entityId) &#123;</span><br><span class="line">    redisTemplate.execute(new SessionCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            String followeeKey &#x3D; RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">            String followerKey &#x3D; RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());</span><br><span class="line">            operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">            return operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void unfollow(int userId, int entityType, int entityId) &#123;</span><br><span class="line">    redisTemplate.execute(new SessionCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            String followeeKey &#x3D; RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">            String followerKey &#x3D; RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            operations.opsForZSet().remove(followeeKey, entityId);</span><br><span class="line">            operations.opsForZSet().remove(followerKey, userId);</span><br><span class="line"></span><br><span class="line">            return operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>发布帖子</title>
      <link href="/2020/09/07/%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90/"/>
      <url>/2020/09/07/%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><p><img src="/2020/09/07/%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200907224007422.png" alt="image-20200907224007422"></p><p><img src="/2020/09/07/%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200907225126398.png" alt="image-20200907225126398"></p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>发布帖子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String addDiscussPost(String title, String content) &#123;</span><br><span class="line">        User user &#x3D; hostHolder.getUser();</span><br><span class="line">        if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return CommunityUtil.getJSONString(403, &quot;你还没有登录哦!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DiscussPost post &#x3D; new DiscussPost();</span><br><span class="line">        post.setUserId(user.getId());</span><br><span class="line">        post.setTitle(title);</span><br><span class="line">        post.setContent(content);</span><br><span class="line">        post.setCreateTime(new Date());</span><br><span class="line">        discussPostService.addDiscussPost(post);</span><br></pre></td></tr></table></figure><p>帖子详情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;detail&#x2F;&#123;discussPostId&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">public String getDiscussPost(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Model model, Page page) &#123;</span><br><span class="line">    &#x2F;&#x2F; 帖子</span><br><span class="line">    DiscussPost post &#x3D; discussPostService.findDiscussPostById(discussPostId);</span><br><span class="line">    model.addAttribute(&quot;post&quot;, post);</span><br><span class="line">    &#x2F;&#x2F; 作者</span><br><span class="line">    User user &#x3D; userService.findUserById(post.getUserId());</span><br><span class="line">    model.addAttribute(&quot;user&quot;, user);</span><br><span class="line">    &#x2F;&#x2F; 点赞数量</span><br><span class="line">    long likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);</span><br><span class="line">    model.addAttribute(&quot;likeCount&quot;, likeCount);</span><br><span class="line">    &#x2F;&#x2F; 点赞状态</span><br><span class="line">    int likeStatus &#x3D; hostHolder.getUser() &#x3D;&#x3D; null ? 0 :</span><br><span class="line">            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);</span><br><span class="line">    model.addAttribute(&quot;likeStatus&quot;, likeStatus);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 评论分页信息</span><br><span class="line">    page.setLimit(5);</span><br><span class="line">    page.setPath(&quot;&#x2F;discuss&#x2F;detail&#x2F;&quot; + discussPostId);</span><br><span class="line">    page.setRows(post.getCommentCount());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 评论: 给帖子的评论</span><br><span class="line">    &#x2F;&#x2F; 回复: 给评论的评论</span><br><span class="line">    &#x2F;&#x2F; 评论列表</span><br><span class="line">    List&lt;Comment&gt; commentList &#x3D; commentService.findCommentsByEntity(</span><br><span class="line">            ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());</span><br><span class="line">    &#x2F;&#x2F; 评论VO列表</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; commentVoList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (commentList !&#x3D; null) &#123;</span><br><span class="line">        for (Comment comment : commentList) &#123;</span><br><span class="line">            &#x2F;&#x2F; 评论VO</span><br><span class="line">            Map&lt;String, Object&gt; commentVo &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F; 评论</span><br><span class="line">            commentVo.put(&quot;comment&quot;, comment);</span><br><span class="line">            &#x2F;&#x2F; 作者</span><br><span class="line">            commentVo.put(&quot;user&quot;, userService.findUserById(comment.getUserId()));</span><br><span class="line">            &#x2F;&#x2F; 点赞数量</span><br><span class="line">            likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">            commentVo.put(&quot;likeCount&quot;, likeCount);</span><br><span class="line">            &#x2F;&#x2F; 点赞状态</span><br><span class="line">            likeStatus &#x3D; hostHolder.getUser() &#x3D;&#x3D; null ? 0 :</span><br><span class="line">                    likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">            commentVo.put(&quot;likeStatus&quot;, likeStatus);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 回复列表</span><br><span class="line">            List&lt;Comment&gt; replyList &#x3D; commentService.findCommentsByEntity(</span><br><span class="line">                    ENTITY_TYPE_COMMENT, comment.getId(), 0, Integer.MAX_VALUE);</span><br><span class="line">            &#x2F;&#x2F; 回复VO列表</span><br><span class="line">            List&lt;Map&lt;String, Object&gt;&gt; replyVoList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            if (replyList !&#x3D; null) &#123;</span><br><span class="line">                for (Comment reply : replyList) &#123;</span><br><span class="line">                    Map&lt;String, Object&gt; replyVo &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">                    &#x2F;&#x2F; 回复</span><br><span class="line">                    replyVo.put(&quot;reply&quot;, reply);</span><br><span class="line">                    &#x2F;&#x2F; 作者</span><br><span class="line">                    replyVo.put(&quot;user&quot;, userService.findUserById(reply.getUserId()));</span><br><span class="line">                    &#x2F;&#x2F; 回复目标</span><br><span class="line">                    User target &#x3D; reply.getTargetId() &#x3D;&#x3D; 0 ? null : userService.findUserById(reply.getTargetId());</span><br><span class="line">                    replyVo.put(&quot;target&quot;, target);</span><br><span class="line">                    &#x2F;&#x2F; 点赞数量</span><br><span class="line">                    likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, reply.getId());</span><br><span class="line">                    replyVo.put(&quot;likeCount&quot;, likeCount);</span><br><span class="line">                    &#x2F;&#x2F; 点赞状态</span><br><span class="line">                    likeStatus &#x3D; hostHolder.getUser() &#x3D;&#x3D; null ? 0 :</span><br><span class="line">                            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, reply.getId());</span><br><span class="line">                    replyVo.put(&quot;likeStatus&quot;, likeStatus);</span><br><span class="line"></span><br><span class="line">                    replyVoList.add(replyVo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            commentVo.put(&quot;replys&quot;, replyVoList);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 回复数量</span><br><span class="line">            int replyCount &#x3D; commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">            commentVo.put(&quot;replyCount&quot;, replyCount);</span><br><span class="line"></span><br><span class="line">            commentVoList.add(commentVo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(&quot;comments&quot;, commentVoList);</span><br><span class="line"></span><br><span class="line">    return &quot;&#x2F;site&#x2F;discuss-detail&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加评论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">comment.setUserId(hostHolder.getUser().getId());</span><br><span class="line">comment.setStatus(0);</span><br><span class="line">comment.setCreateTime(new Date());</span><br><span class="line">commentService.addComment(comment);</span><br></pre></td></tr></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过滤敏感词</title>
      <link href="/2020/09/07/%E8%BF%87%E6%BB%A4%E6%95%8F%E6%84%9F%E8%AF%8D/"/>
      <url>/2020/09/07/%E8%BF%87%E6%BB%A4%E6%95%8F%E6%84%9F%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>树结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private class TrieNode &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 关键词结束标识</span><br><span class="line">    private boolean isKeywordEnd &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 子节点(key是下级字符,value是下级节点)</span><br><span class="line">    private Map&lt;Character, TrieNode&gt; subNodes &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public boolean isKeywordEnd() &#123;</span><br><span class="line">        return isKeywordEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKeywordEnd(boolean keywordEnd) &#123;</span><br><span class="line">        isKeywordEnd &#x3D; keywordEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 添加子节点</span><br><span class="line">    public void addSubNode(Character c, TrieNode node) &#123;</span><br><span class="line">        subNodes.put(c, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取子节点</span><br><span class="line">    public TrieNode getSubNode(Character c) &#123;</span><br><span class="line">        return subNodes.get(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个敏感词添加到前缀树中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将一个敏感词添加到前缀树中</span><br><span class="line">private void addKeyword(String keyword) &#123;</span><br><span class="line">    TrieNode tempNode &#x3D; rootNode;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; keyword.length(); i++) &#123;</span><br><span class="line">        char c &#x3D; keyword.charAt(i);</span><br><span class="line">        TrieNode subNode &#x3D; tempNode.getSubNode(c);</span><br><span class="line"></span><br><span class="line">        if (subNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 初始化子节点</span><br><span class="line">            subNode &#x3D; new TrieNode();</span><br><span class="line">            tempNode.addSubNode(c, subNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 指向子节点,进入下一轮循环</span><br><span class="line">        tempNode &#x3D; subNode;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置结束标识</span><br><span class="line">        if (i &#x3D;&#x3D; keyword.length() - 1) &#123;</span><br><span class="line">            tempNode.setKeywordEnd(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public String filter(String text) &#123;</span><br><span class="line">    if (StringUtils.isBlank(text)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指针1</span><br><span class="line">    TrieNode tempNode &#x3D; rootNode;</span><br><span class="line">    &#x2F;&#x2F; 指针2</span><br><span class="line">    int begin &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 指针3</span><br><span class="line">    int position &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 结果</span><br><span class="line">    StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    while (position &lt; text.length()) &#123;</span><br><span class="line">        char c &#x3D; text.charAt(position);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 跳过符号</span><br><span class="line">        if (isSymbol(c)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 若指针1处于根节点,将此符号计入结果,让指针2向下走一步</span><br><span class="line">            if (tempNode &#x3D;&#x3D; rootNode) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 无论符号在开头或中间,指针3都向下走一步</span><br><span class="line">            position++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 检查下级节点</span><br><span class="line">        tempNode &#x3D; tempNode.getSubNode(c);</span><br><span class="line">        if (tempNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 以begin开头的字符串不是敏感词</span><br><span class="line">            sb.append(text.charAt(begin));</span><br><span class="line">            &#x2F;&#x2F; 进入下一个位置</span><br><span class="line">            position &#x3D; ++begin;</span><br><span class="line">            &#x2F;&#x2F; 重新指向根节点</span><br><span class="line">            tempNode &#x3D; rootNode;</span><br><span class="line">        &#125; else if (tempNode.isKeywordEnd()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 发现敏感词,将begin~position字符串替换掉</span><br><span class="line">            sb.append(REPLACEMENT);</span><br><span class="line">            &#x2F;&#x2F; 进入下一个位置</span><br><span class="line">            begin &#x3D; ++position;</span><br><span class="line">            &#x2F;&#x2F; 重新指向根节点</span><br><span class="line">            tempNode &#x3D; rootNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 检查下一个字符</span><br><span class="line">            position++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将最后一批字符计入结果</span><br><span class="line">    sb.append(text.substring(begin));</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>登录注册</title>
      <link href="/2020/09/06/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/"/>
      <url>/2020/09/06/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="涉及数据库"><a href="#涉及数据库" class="headerlink" title="涉及数据库"></a>涉及数据库</h2><p>user</p><p><img src="/2020/09/06/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200906203352925.png" alt="image-20200906203352925"></p><p>LoginTicket</p><p><img src="/2020/09/06/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200906215039799.png" alt="image-20200906215039799"></p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map &#x3D; userService.register(user);</span><br></pre></td></tr></table></figure><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String login(String username, String password, String code, boolean rememberme,</span><br><span class="line">                       Model model, HttpServletResponse response,</span><br><span class="line">                       @CookieValue(&quot;kaptchaOwner&quot;) String kaptchaOwner)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map &#x3D; userService.login(username, password, expiredSeconds);</span><br></pre></td></tr></table></figure><h3 id="kaptcha"><a href="#kaptcha" class="headerlink" title="kaptcha"></a>kaptcha</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void getKaptcha(HttpServletResponse response&#x2F;*, HttpSession session*&#x2F;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 生成验证码</span><br><span class="line">        String text &#x3D; kaptchaProducer.createText();</span><br><span class="line">        BufferedImage image &#x3D; kaptchaProducer.createImage(text);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将验证码存入session</span><br><span class="line">        &#x2F;&#x2F; session.setAttribute(&quot;kaptcha&quot;, text);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 验证码的归属</span><br><span class="line">        String kaptchaOwner &#x3D; CommunityUtil.generateUUID();</span><br><span class="line">        Cookie cookie &#x3D; new Cookie(&quot;kaptchaOwner&quot;, kaptchaOwner);</span><br><span class="line">        cookie.setMaxAge(60);</span><br><span class="line">        cookie.setPath(contextPath);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        &#x2F;&#x2F; 将验证码存入Redis</span><br><span class="line">        String redisKey &#x3D; RedisKeyUtil.getKaptchaKey(kaptchaOwner);</span><br><span class="line">        redisTemplate.opsForValue().set(redisKey, text, 60, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将突图片输出给浏览器</span><br><span class="line">        response.setContentType(&quot;image&#x2F;png&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            OutputStream os &#x3D; response.getOutputStream();</span><br><span class="line">            ImageIO.write(image, &quot;png&quot;, os);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            logger.error(&quot;响应验证码失败:&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>验证码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (StringUtils.isNotBlank(kaptchaOwner)) &#123;</span><br><span class="line">    String redisKey &#x3D; RedisKeyUtil.getKaptchaKey(kaptchaOwner);</span><br><span class="line">    kaptcha &#x3D; (String) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) &#123;</span><br><span class="line">    model.addAttribute(&quot;codeMsg&quot;, &quot;验证码不正确!&quot;);</span><br><span class="line">    return &quot;&#x2F;site&#x2F;login&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="UserService"><a href="#UserService" class="headerlink" title="UserService"></a>UserService</h3><p>注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; register(User user)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User u &#x3D; userMapper.selectByName(user.getUsername());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册用户</span><br><span class="line">user.setSalt(CommunityUtil.generateUUID().substring(0, 5));</span><br><span class="line">user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt()));</span><br><span class="line">user.setType(0);</span><br><span class="line">user.setCreateTime(new Date());</span><br><span class="line">userMapper.insertUser(user);</span><br></pre></td></tr></table></figure><p>登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; login(String username, String password, long expiredSeconds)</span><br><span class="line">&#123;</span><br><span class="line">        ....</span><br><span class="line">        Cookie cookie &#x3D; new Cookie(&quot;ticket&quot;, map.get(&quot;ticket&quot;).toString());</span><br><span class="line">        cookie.setPath(contextPath);</span><br><span class="line">        cookie.setMaxAge(expiredSeconds);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        return &quot;redirect:&#x2F;index&quot;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 验证账号</span><br><span class="line">&#x2F;&#x2F; 验证密码</span><br><span class="line">&#x2F;&#x2F; 生成登录凭证</span><br><span class="line">&#x2F;&#x2F; 生成登录凭证</span><br><span class="line">LoginTicket loginTicket &#x3D; new LoginTicket();</span><br><span class="line">loginTicket.setUserId(user.getId());</span><br><span class="line">loginTicket.setTicket(CommunityUtil.generateUUID());</span><br><span class="line">loginTicket.setStatus(0);</span><br><span class="line">loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));</span><br><span class="line">String redisKey &#x3D; RedisKeyUtil.getTicketKey(loginTicket.getTicket());</span><br><span class="line">redisTemplate.opsForValue().set(redisKey, loginTicket);</span><br><span class="line"></span><br><span class="line">map.put(&quot;ticket&quot;, loginTicket.getTicket());</span><br><span class="line">return map;</span><br></pre></td></tr></table></figure><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AlphaInterceptor implements HandlerInterceptor</span><br><span class="line">WebMvcConfig implements WebMvcConfigurer</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 从cookie中获取凭证</span><br><span class="line">    String ticket &#x3D; CookieUtil.getValue(request, &quot;ticket&quot;);</span><br><span class="line"></span><br><span class="line">    if (ticket !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 查询凭证</span><br><span class="line">        LoginTicket loginTicket &#x3D; userService.findLoginTicket(ticket);</span><br><span class="line">        &#x2F;&#x2F; 检查凭证是否有效</span><br><span class="line">        if (loginTicket !&#x3D; null &amp;&amp; loginTicket.getStatus() &#x3D;&#x3D; 0 &amp;&amp; loginTicket.getExpired().after(new Date())) &#123;</span><br><span class="line">            &#x2F;&#x2F; 根据凭证查询用户</span><br><span class="line">            User user &#x3D; userService.findUserById(loginTicket.getUserId());</span><br><span class="line">            &#x2F;&#x2F; 在本次请求中持有用户</span><br><span class="line">            hostHolder.setUser(user);</span><br><span class="line">            &#x2F;&#x2F; 构建用户认证的结果,并存入SecurityContext,以便于Security进行授权.</span><br><span class="line">            Authentication authentication &#x3D; new UsernamePasswordAuthenticationToken(</span><br><span class="line">                    user, user.getPassword(), userService.getAuthorities(user.getId()));</span><br><span class="line">            SecurityContextHolder.setContext(new SecurityContextImpl(authentication));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line">    if (user !&#x3D; null &amp;&amp; modelAndView !&#x3D; null) &#123;</span><br><span class="line">        modelAndView.addObject(&quot;loginUser&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry.addInterceptor(loginTicketInterceptor)</span><br><span class="line">        .excludePathPatterns(&quot;&#x2F;**&#x2F;*.css&quot;, &quot;&#x2F;**&#x2F;*.js&quot;, &quot;&#x2F;**&#x2F;*.png&quot;, &quot;&#x2F;**&#x2F;*.jpg&quot;, &quot;&#x2F;**&#x2F;*.jpeg&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些不常见的面试算法题</title>
      <link href="/2020/08/06/%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2020/08/06/%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li><p>平衡二叉搜索树插入算法</p></li><li><p>对于给定的数据，找出比这个数大的最小回文数（正反读都一样的数），如 12310 -&gt; 12321</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">leetcode 564</span><br><span class="line">public class hello &#123;&#x2F;&#x2F;100 999</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str&#x3D;&quot;271&quot;;</span><br><span class="line"></span><br><span class="line">        int len&#x3D;str.length();</span><br><span class="line">        char[] s&#x3D;str.toCharArray();</span><br><span class="line">        int flag&#x3D;0,i;</span><br><span class="line">        for(i&#x3D;len&#x2F;2-1;i&gt;&#x3D;0;--i)&#123;</span><br><span class="line">            if(s[i]&gt;s[len-1-i])&#123;flag&#x3D;1;break;&#125;</span><br><span class="line">            else if(s[i]&lt;s[len-1-i])&#123; flag&#x3D;-1;break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag!&#x3D;1)&#123;&#x2F;&#x2F;前半串要加1</span><br><span class="line">            &#x2F;&#x2F;s[(len-1)&#x2F;2]++;</span><br><span class="line">            for(i&#x3D;(len-1)&#x2F;2;i&gt;&#x3D;0;--i)&#123;&#x2F;&#x2F;199 191 999</span><br><span class="line">                s[i]++;</span><br><span class="line">                if(s[i]&gt;&#39;9&#39;)&#123;</span><br><span class="line">                    s[i]&#x3D;&#39;0&#39;;</span><br><span class="line">                &#125;else break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(s[0]&#x3D;&#x3D;&#39;0&#39;)&#123;&#x2F;&#x2F;999 9999</span><br><span class="line">                s[0]&#x3D;&#39;1&#39;;</span><br><span class="line">                len++;</span><br><span class="line">                s[len&#x2F;2]&#x3D;&#39;0&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i&#x3D;0;i&lt;len&#x2F;2;++i)</span><br><span class="line">            System.out.print((s[i])+&quot; &quot;);</span><br><span class="line">        for(i&#x3D;(len+1)&#x2F;2-1;i&gt;&#x3D;0;--i)</span><br><span class="line">            System.out.println(s[i]+&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对一个奇数位升序，偶数位降序的链表，进行排序，例如 1-&gt;100-&gt;20-&gt;80-&gt;40-&gt;30</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇偶拆分 反转 合并链表</span><br></pre></td></tr></table></figure></li><li><p>从一个数 l 一直 与 操作到 r ，怎么做最快，复杂度最小</p></li><li><p>输出交错后的链表(比如链表a-b-c-d-e,交错后输出为a-e-b-d-c)</p></li><li><p>请对3个有序数组进行归并排序</p></li></ol><ol start="7"><li><p>掷骰子走路，1～6，给定的输入n，走到第n个格子有多少种走法</p></li><li><p>青蛙跳格子，数组里元素表示该位置石头个数，每次跳3-5格，问跳出数组最少踩多少石头</p></li><li><p>.给一个正整数，表示成一个或多个不同的正整数的和，输出所有的解决方案</p></li><li><p>找出数组里出现次数大于n/k的数</p></li><li><p>给一个矩阵，从右上角往左下角一层一层斜着遍历</p></li><li><p>一个int数组，找出两个异或最大的数字，时间要求O(n)</p></li><li><p>四个int数组，从每个数组里边挑一个数，加起来等于指定数，要求打印出所有非重复的组合，要求最大n2</p></li><li><p>查找有序数组中一个目标值出现的第一次位置，没有找到返回 -1</p></li><li><p>二分查找在升序数组中找出绝对值最小的那个数</p></li><li><p>给定一个包含大写英文字母和数字的句子，找出这个句子所包含的最大的十六进制整数，返回这个整数的值。数据保证该整数在int表示范围内</p></li><li><p>字符串数组两个字符串的最小距离</p></li><li><p>实现洗牌算法</p></li><li><p>单链表高位在前、低位在后，大数计算</p></li><li><p>阶乘</p></li><li><p>合并数组</p></li><li><p>一道矩阵相乘</p></li><li><p>求连续子序列乘积为完全平方数的最大长度</p></li><li><p>定一个升序数组，可能会有重复的数字，将数组里的数平方后，有多少不同的数</p></li><li><p>:两个大数字符串求和输出字符串</p></li><li><p>任意数组中的第一个缺失的正整数</p></li><li><p>字符串反转</p></li><li><p>.给你一个数组和一个target，找出和是target整数倍的连续子串</p></li><li><p>I am student 返回 student am I 不用split</p></li><li><p>给一个分数n/m，如果这个分数是无线循环小数，找出循环位。</p></li><li><p>排序数组，平方后，数组当中有多少不同的数字（相同算一个）</p></li><li><p>一个数据先递增再递减，找出数组不重复的个数，比如 [1, 3, 9, 1]，结果为3，不能使用额外空间，复杂度o(n)</p></li><li><p>某一个大文件被拆成了N个小文件，每个小文件编号从0至N-1，相应大小分别记为S(i)。给定磁盘空间为C，试实现一个函数从N个文件中连续选出若干个文件拷贝到磁盘中，使得磁盘剩余空间最小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ol><ol start="34"><li><p>给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3</p></li><li><p>算法题，一个有序数组，从随机一位截断，把前段放在后边，如 4 5 6 7 1 2 3求中位数</p></li><li><p>链表实现一个栈</p></li><li><p>求完全二叉树的节点个数，小于O(n)，并分析复杂度</p></li><li><p>写一个函数，求平方根，函数参数为目标数字和精度，测试案例 fn(4.1,0.001) fn(501.1,0.001) fn(0.045,0.001)</p></li><li><p>给定一个 0-4随机数生成器 如何生成0-6随机数</p></li><li><p>中文数字转阿拉伯数字，字符串处理问题</p><p>中文数字格式：一万三千五百四十一      </p><p>阿拉伯数字格式：13541      </p><p>中文数字中要分单位和数字分别处理，可以用两个数组分别保存中文数字和中文单位，每次循环扫描给的中文数字，去匹配对应的数字。中文数字数字可以用数组下标对应数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">   static char[] cnArr &#x3D; &#123;&#39;零&#39;,&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;&#125;;</span><br><span class="line">   static char[] chArr &#x3D; &#123;&#39;十&#39;, &#39;百&#39;, &#39;千&#39;, &#39;万&#39;, &#39;亿&#39;&#125;;</span><br><span class="line">public static int chineseNumToArabicNum(String chineseNum) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    int temp &#x3D; 1;&#x2F;&#x2F;存放一个单位的数字如：十万</span><br><span class="line">    int count &#x3D; 0;&#x2F;&#x2F;判断是否有表示单位的文字</span><br><span class="line">    for (int i &#x3D; 0; i &lt; chineseNum.length(); i++) &#123;</span><br><span class="line">        boolean b &#x3D; true;&#x2F;&#x2F;判断是否是单位</span><br><span class="line">        char c &#x3D; chineseNum.charAt(i);</span><br><span class="line">        for (int j &#x3D; 0; j &lt; cnArr.length; j++) &#123;&#x2F;&#x2F;非单位，即数字</span><br><span class="line">            if (c &#x3D;&#x3D; cnArr[j]) &#123;</span><br><span class="line">                if (count !&#x3D; 0) &#123;&#x2F;&#x2F;添加下一个单位之前，先把上一个单位值添加到结果中</span><br><span class="line">                    result +&#x3D; temp;</span><br><span class="line">                    temp &#x3D; 1;</span><br><span class="line">                    count &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 下标+1，就是对应的值</span><br><span class="line">                temp &#x3D; j;</span><br><span class="line">                b &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (b) &#123;&#x2F;&#x2F;单位&#123;&#39;十&#39;,&#39;百&#39;,&#39;千&#39;,&#39;万&#39;,&#39;亿&#39;&#125;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; chArr.length; j++) &#123;</span><br><span class="line">                if (c &#x3D;&#x3D; chArr[j]) &#123;</span><br><span class="line">                    switch (j) &#123;</span><br><span class="line">                        case 0:</span><br><span class="line">                            temp *&#x3D; 10;</span><br><span class="line">                            break;</span><br><span class="line">                        case 1:</span><br><span class="line">                            temp *&#x3D; 100;</span><br><span class="line">                            break;</span><br><span class="line">                        case 2:</span><br><span class="line">                            temp *&#x3D; 1000;</span><br><span class="line">                            break;</span><br><span class="line">                        case 3:</span><br><span class="line">                            temp *&#x3D; 10000;</span><br><span class="line">                            break;</span><br><span class="line">                        case 4:</span><br><span class="line">                            temp *&#x3D; 100000000;</span><br><span class="line">                            break;</span><br><span class="line">                        default:</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &#x3D;&#x3D; chineseNum.length() - 1) &#123;&#x2F;&#x2F;遍历到最后一个字符</span><br><span class="line">            result +&#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三个线程循环打印ABC**</p></li><li><pre><code>public class hello {    //1-&gt;100-&gt;20-&gt;80-&gt;40-&gt;30    1-&gt;20-30-&gt;40-&gt;80-&gt;100    static class ListNode    {        int val;        ListNode(int x)        {            val=x;        }        ListNode next;    }    public static void main(String[] args) {        ListNode l1=new ListNode(1);        ListNode l2=new ListNode(100);        ListNode l3=new ListNode(20);        ListNode l4=new ListNode(80);        l1.next=l2;        l2.next=l3;        l3.next=l4;        l4.next=null;//        while(l1!=null)//        {//            System.out.println(l1.val);//            l1=l1.next;//        }        help(l1);        while(l1!=null)        {            System.out.println(l1.val);            l1=l1.next;        }    }    public static ListNode help(ListNode head)    {        if(head==null || head.next==null)        {            return head;        }        ListNode h1=head,t1=head;        ListNode h2=head.next,t2=h2;        while(t1.next!=null &amp;&amp; t2.next!=null)        {            t1.next=t2.next;            t1=t1.next;            t2.next=t1.next;            t2=t2.next;        }        t1.next=null;        ListNode temp=reverse(h2);        ListNode res=mergeTwoLists(temp,h1);        return res;    }    public static ListNode reverse(ListNode head)    {       if(head==null || head.next==null) return head;       ListNode temp=reverse(head.next);       head.next.next=head;       head.next=null;       return temp;    }    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {        if(l1==null) return l2;        if(l2==null) return l1;        ListNode dummy=new ListNode(0);        ListNode curr=dummy;        ListNode p=l1,q=l2;        while(p!=null&amp;&amp;q!=null)        {            int x=p.val;            int y=q.val;            if(x&lt;y)            {                curr.next=p;                p=p.next;            }            else            {                curr.next=q;                q=q.next;            }            curr=curr.next;        }        if(p!=null) curr.next=p;        if(q!=null) curr.next=q;        return dummy.next;    }}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">43. **平方后，数组当中有多少不同的数字**</span><br></pre></td></tr></table></figure>public class Solution {public int diffSquareNum(int nums[]) {    int n = nums.length;    if(n == 0 || nums == null){        return 0;    }    int sum = 0;    int left = 0;    int right = n - 1;    while(left &lt;= right){        if(nums[left] + nums[right] == 0){            sum++;            int temp = nums[left];            //这里开始去掉后面重复的数字            while(left &lt;= right &amp;&amp; nums[left] == temp)                left++;            while(left &lt;= right &amp;&amp; nums[right] == -temp)                right--;        }        else if(nums[left] + nums[right] &lt; 0){            sum++;            int temp = nums[left];            while(left &lt;= right &amp;&amp; nums[left] == temp)                left++;        }        else {            sum++;            int temp = nums[right];            while(left &lt;= right &amp;&amp; nums[right] == temp)                right--;        }    }    return sum;}}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">43</span><br><span class="line"></span><br><span class="line">给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，</span><br></pre></td></tr></table></figure>public class hello {public static void main(String[] args) {char[] c={&apos;a&apos;,&apos;c&apos;,&apos;b&apos;,&apos;d&apos;};String s=&quot;tbcacbdata&quot;;int res=help(c,s);System.out.println(res);}public static int help(char[] ch,String s){    if(ch.length &gt; s.length()){        return -1;    }    for(int i = 0; i &lt;= s.length() - ch.length+1; i++){        //每次匹配长度为m的子串        if(matchs(ch,s.substring(i,i+ch.length)))            return i;    }    return -1;}private static boolean matchs(char[] ch,String s){    for(int i = 0; i &lt; s.length();i++){        //返回-1说明字符串中不包含这个字符        if(s.indexOf(ch[i]) == -1)            return false;    }    return true;}</code></pre></li></ol><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">44.一个有序数组，从随机一位截断，把前段放在后边，如 4 5 6 7 1 2 3求中位数</span><br></pre></td></tr></table></figure><p>public class findNumInRotateArr {</p><pre><code>public static double minNumberInRotateArray(int[] nums) {    if (nums == null || nums.length == 0) {        return 0;    }    int left = 0;    int right = nums.length - 1;    while (left &lt; right) {        int mid = left + ((right - left) &gt;&gt; 1);        if (nums[mid] &lt; nums[right]) {            right = mid;        } else if (nums[mid] &gt; nums[right]) {            left = mid + 1;        } else {            right--;        }    }    int size = nums.length;    if (size % 2 == 1) {        return nums[(left + size / 2) % size];    } else {        return (double) (nums[(left + size / 2) % size] + nums[(left + (size - 1) / 2) % size]) / 2;    }}public static void main(String[] args) {    int[] arr = {6, 7, 8, 1, 2, 3, 4, 5};    System.out.println(minNumberInRotateArray(arr));}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">45.给定一个未排序的整数数组，找出最长连续序列的长度。</span><br><span class="line"></span><br><span class="line">要求算法的时间复杂度为 *O(n)*。</span><br></pre></td></tr></table></figure><p>输入: [100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">46.高考成绩2000万数据，分数0-750，如何快速知道你的排名，如何知道任一分数排名 ---&gt;桶排序</span><br><span class="line"></span><br><span class="line">桶[排序]()    (Bucket sort)的工作的原理：假设输入数据   服从均匀分布   ，将数据分到有限数量的桶里，每个桶再分别[排序]()（有可能再使用别的[排序]()[算法]()或是以递归方式继续使用桶[排序]()进行排）。   </span><br><span class="line"></span><br><span class="line">​    [算法]()描述：   </span><br><span class="line"></span><br><span class="line">​    设置一个定量的数组当作空桶；   </span><br><span class="line"></span><br><span class="line">​    遍历输入数据，并且把数据一个一个放到对应的桶里去；   </span><br><span class="line"></span><br><span class="line">​    对每个不是空的桶进行[排序]()；   </span><br><span class="line"></span><br><span class="line">​    从不是空的桶里把排好序的数据拼接起来。</span><br></pre></td></tr></table></figure><p>public class Solution {<br>    public ArrayList<Integer> bucketSort(int[] scores){<br>      //先确定最大最小值，来确定范围<br>      int max = Integer.MIN_VALUE;<br>      int min = Integer.MAX_VALUE;<br>      for(int i = 0; i &lt; scores.length;i++){<br>          max = Math.max(max,scores[i]);<br>          min = Math.min(min,scores[i]);<br>      }<br>      //计算出桶数<br>      //int bucketNum = (max - min)/scores.length + 1;<br>      //这里直接给出751个桶<br>      int bucketNum = 751;<br>      ArrayList&lt;ArrayList<Integer>&gt; list = new ArrayList&lt;&gt;(bucketNum);<br>      for(int i = 0; i &lt; bucketNum; i++){<br>          list.add(new ArrayList<Integer>());<br>      }</Integer></Integer></Integer></p><pre><code>  //将每个元素放入桶  for(int i = 0; i &lt; scores.length;i++){      //本题中这里放元素也可以简化      //list.get((scores[i] - min)/bucketNum).add(scores[i]);      list.get(scores[i]).add(scores[i]);  }  //桶内排序,本题中可以省略这一步  for(int i = 0; i&lt; list.size();i++){      Collections.sort(list.get(i));  }   return list;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">47.</span><br><span class="line"></span><br><span class="line">**最大栈（最小栈）**</span><br></pre></td></tr></table></figure><p>使用辅助栈：<br>public class MaxStack{<br>    private Stack<Integer> stack;<br>    private Stack<Integer> helper;<br>    public MaxStack(){<br>        stack = new Stack&lt;&gt;();<br>        helper = new Stack&lt;&gt;();<br>    }<br>    public void push(int x) {<br>        if(helper.isEmpty() || helper.peek() &lt;= x){<br>            helper.push(x);<br>        }<br>        stack.push(x);<br>    }<br>    public void pop(){<br>        if(stack.peek() == helper.peek()){<br>            helper.pop();<br>        }<br>        stack.pop();<br>    }<br>    public int peek(){<br>        if(!helper.isEmpty()){<br>            return stack.peek();<br>        }<br>        throw new RuntimeException(“栈中元素为空”);</Integer></Integer></p><pre><code>}public int getMax(){    if(!helper.isEmpty()){        return helper.peek();    }    throw new RuntimeException(&quot;最大值栈中元素为空&quot;);}</code></pre><p>}<br>用最大值标记，存入数据栈中，空间复杂度降到O(1)<br>public class MaxStack {<br>    private Stack<Integer> stack;<br>    public MaxStack(){<br>        stack = new Stack&lt;&gt;();<br>    }<br>    int max = Integer.MIN_VALUE;<br>    public void push(int x){<br>        if(max &lt;= x){<br>            if(!stack.isEmpty()){<br>                stack.push(max);<br>            }<br>            max = x;<br>        }<br>        stack.push(x);<br>    }<br>    public void pop(){<br>        if(stack.peek() == max){<br>            stack.pop();<br>            max = stack.pop();<br>        }else{<br>            stack.pop();<br>        }<br>    }<br>    public int getMax(){<br>        return max;<br>    }<br>}</Integer></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">48. 链表实现一个栈</span><br></pre></td></tr></table></figure><p>public class ListNode{<br>    int val;<br>    ListNode next;<br>    ListNode(int val){<br>        this.val =val;<br>    }<br>}<br>public class ListToStack{<br>    public ListToStack(){<br>        ListNode head;<br>    }<br>    public void push(int x){<br>        ListNode node = new ListNode(x);<br>        node.next = head.next;<br>        head.next = node;<br>    }<br>    public int pop(){<br>        ListNode node = head.next;<br>        head.next = node.next;<br>        node.next = null;<br>        return node.val;<br>    }<br>    public int peek(){<br>        return head.next.val;<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 48.一个形如 123456789101112……的字符串，输入一个n（很大很大），输出字符串第n个字符</span><br><span class="line"></span><br><span class="line">## 49.版本数字比较，比如&quot;1.10.0&quot;版本比&quot;1.8.1&quot;版本新，不允许使用split等函数</span><br><span class="line"></span><br><span class="line">## 50.中缀表达式转后缀</span><br><span class="line"></span><br><span class="line">1、任何中缀表达式都由运算数，运算符，括号（大，中，小），这三部分组成。</span><br><span class="line"></span><br><span class="line">2、从中缀表达式的左边开始扫描（脑中自己想像的），若遇到运算数时，则直接将其输出（不压入堆栈）。</span><br><span class="line"></span><br><span class="line">3、若遇到左括号，则将其压栈。</span><br><span class="line"></span><br><span class="line">4、若遇到右括号，表达括号内的中缀表达式已经扫描完毕。这时需将栈顶的运算符依次弹出并输出，直至遇到左括号[左括号弹出但不输出]。</span><br><span class="line"></span><br><span class="line">5、若遇到的是运算符：a、如果该运算符的优先级大于栈顶运算符的优先级时，将其压栈</span><br><span class="line"></span><br><span class="line">​                  b、如果该运算符的优先级小于栈顶运算符的优先级时，将栈顶运算符弹出并输出，接着和新的栈顶运算 符比较，若大于，则将其压栈，若小于，继续将栈顶运算符弹出并输出......(一直递归下去，直至运算符大于栈顶云算符为止)。</span><br><span class="line"></span><br><span class="line">6、最后一步，若扫描到中缀表达式的末尾[即扫描结束]，若堆栈中还有存留的运算符依次弹出并输出即可。</span><br></pre></td></tr></table></figure><p>public class hello {//100 999</p><pre><code>public static void calculate(String string) {    Stack&lt;String&gt; operator = new Stack&lt;&gt;();//操作符栈    List&lt;String&gt; list = new ArrayList&lt;&gt;();//结果集    char[] s = string.toCharArray();    //遍历表达式    // 1+(2-4*3)    // 1 2 4 3 * - +    // 1+(2-4*3)*5    // 1 2 4 3 * - +5-    for (int i = 0; i &lt; s.length; i++) {        if (s[i] == &apos; &apos;)            continue;        if (s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;){            StringBuilder stringBuilder = new StringBuilder();            while (i &lt; s.length &amp;&amp; s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;){                stringBuilder.append(s[i]);                i++;            }            i--;            list.add(stringBuilder.toString());        }//正则表达式匹配数字，对应思路1        else if (s[i] == &apos;(&apos;){//对应思路2            operator.push(String.valueOf(s[i]));        }else if (s[i] == &apos;)&apos;){//对应思路3            while (!operator.peek().equals(&quot;(&quot;)){                list.add(operator.pop());            }            operator.pop();        }else{//对应思路4            while (!operator.isEmpty() &amp;&amp; priority(operator.peek()) &gt;= priority(String.valueOf(s[i]))){                list.add(operator.pop());            }            operator.push(String.valueOf(s[i]));        }    }    // 1+(2-4*3)  1 2 4 3 * - +    // 1+(2*4-3)  1 2 4 * 3 - +    while (!operator.isEmpty())        list.add(operator.pop());    System.out.println(list.size());</code></pre><p>//        Stack<Integer> nums = new Stack&lt;&gt;();<br>//        for (int i = 0; i &lt; list.size(); i++) {<br>//            if (list.get(i).equals(“+”)){<br>//                nums.push(nums.pop() + nums.pop());<br>//            }else if (list.get(i).equals(“-“)){<br>//                nums.push(-(nums.pop() - nums.pop()));<br>//            }else if (list.get(i).equals(“*”)){<br>//                nums.push(nums.pop() * nums.pop());<br>//            }else if (list.get(i).equals(“/“)){<br>//                int num1 = nums.pop();<br>//                int num2 = nums.pop();<br>//                nums.push(num2 / num1);<br>//            } else<br>//                nums.push(Integer.parseInt(list.get(i)));<br>//        }<br>//<br>//        return nums.pop();//弹出栈中元素返回结果<br>    }<br>    //计算符优先级<br>    private static int priority(String oper){<br>        if (oper.equals(“+”) || oper.equals(“-“))<br>            return 0;<br>        else if (oper.equals(“*”) || oper.equals(“/“))<br>            return 1;<br>        else return -1;<br>    }<br>    public static void main(String[] args) {<br>    String s=”1+(2*4-3)”;<br>    calculate(s);<br>    }<br>}</Integer></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 51.滑动窗口</span><br><span class="line"></span><br><span class="line">某一个大文件被拆成了N个小文件，每个小文件编号从0至N-1，相应大小分别记为S(i)。给定磁盘空间为C，试实现一个函数从N个文件中连续选出若干个文件拷贝到磁盘中，使得磁盘剩余空间最小。 </span><br><span class="line"></span><br><span class="line">滑动窗口   ：每次记录窗口内的总和，和小于C，记录剩余空间，再窗口右端右移，和大于C，就窗口左端右移，小于C情况下比较剩余空间取最小值。</span><br></pre></td></tr></table></figure><p>public class Solution {<br>    public int[] findMin(int[] s,int c){<br>        int i = 0;<br>        int j = 0;<br>        int minValue = Integer.MAX_VALUE;<br>        int sum = 0;<br>        int left = 0;<br>        int right = 0;<br>        while(j &lt;= s.length){<br>            if(sum &lt;= c){<br>               j++;<br>               sum += s[j];<br>               minValue = Math.min(minValue,c - sum);<br>               if(minValue == c - sum){<br>                   left = i;<br>                   right = j;<br>               }<br>            }else{<br>                i++;<br>                sum -= s[i];<br>            }<br>        }<br>        int nums = new int[right - left];<br>        for(int k = left;k &lt; right;k++){<br>            nums[k - left] = s[k];<br>        }<br>        return nums;<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">52.求有序链表的中位数</span><br></pre></td></tr></table></figure><p>public class Test {<br>    //【快慢指针————求一个有序链表的中位数】<br>    public static double sortedListMedian(ListNode head) {<br>        if(head == null)<br>            System.out.println(“链表不能为空！”);<br>        ListNode slow = head, fast = head;<br>        while(fast.next != null &amp;&amp; fast.next.next != null) {<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        }<br>        if(fast.next == null)       //说明链表有奇数个节点，此时slow正好是中位数<br>            return slow.val * 1.0;<br>        else                        //说明链表有偶数个节点，此时(slow+slow.next)/2是中位数<br>            return (slow.val + slow.next.val) / 2.0;<br>    }</p><pre><code>//返回由一个数组生成的链表的头结点private static ListNode makeListByArray(int[] array) {    ListNode dummyHead = new ListNode(-1);    ListNode cur = dummyHead;    for (int i = 0; i &lt; array.length; i++) {        cur.next = new ListNode(array[i]);        cur = cur.next;    }    return dummyHead.next;}//主函数public static void main(String[] args) {    int[] array = {0,1,2,3,4,5};    ListNode head = makeListByArray(array);    double ans = sortedListMedian(head);    System.out.println(ans);}</code></pre><p>}</p><p>// 链表节点定义<br>class ListNode {<br>    int val;<br>    ListNode next;</p><pre><code>public ListNode(int val, ListNode next) {    this.val = val;    this.next = next;}public ListNode(int val) {    this(val,null);}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">53.**题目：合并K个有序数组</span><br></pre></td></tr></table></figure><p>输入: [[1,2,3], [1,2]]<br>输出: [1,1,2,2,3]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 O(N log k) 的时间复杂度内完成：*N* 是所有数组包含的整数总数量。***k\* 是数组的个数**。</span><br><span class="line"></span><br><span class="line">解法：N个数组进行两两合并，合并后的数组再继续执行合并过程，最后合成N*M的有序数组。可以认为合并这个递归过程发生了logN次，每一次合并的过程都是N*M个数合并，所以每一次合并的时间复杂度为N*M,总的时间复杂度就是N*M*logN</span><br></pre></td></tr></table></figure><p>public class hello {//100 999</p><pre><code>public static void main(String[] args) {    int[][] arr={{1,2,3},{5,6},{3,4},{1,3}};    int[] res=mergekSortedArrays(arr);    System.out.println(res);}public static int[] mergekSortedArrays(int[][] arrays) {    // write your code here    if(arrays == null || arrays.length == 0)        return null;    return helper(arrays, 0, arrays.length-1);}private static int[] helper(int[][] arrays, int l, int r){    int mid = l + (r-l)/2;    if(l&lt;r)    {        int[] left = helper(arrays, l, mid);        int[] right = helper(arrays, mid+1, r);        return merge2Arrays(left, right);    }    return arrays[l];}private static int[] merge2Arrays(int[] a, int[] b){    int[] res = new int[a.length + b.length];    int i=0, j=0;    for(int k=0; k&lt;res.length; k++){        if(i &gt;= a.length)            res[k] = b[j++];        else if(j &gt;= b.length)            res[k] = a[i++];        else if(a[i] &lt; b[j])            res[k] = a[i++];        else            res[k] = b[j++];    }    return res;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class Solution {<br>    /**<br>     * @param arrays: k sorted integer arrays<br>     * @return: a sorted array<br>     */<br>    public int[] mergekSortedArrays(int[][] arrays) {<br>        // write your code here<br>            if(arrays == null || arrays.length == 0)<br>                return null;</p><pre><code>        return helper(arrays, 0, arrays.length-1);}private int[] helper(int[][] arrays, int l, int r){    if(l == r)        return arrays[l];    if(l + 1 == r)        return merge2Arrays(arrays[l], arrays[r]);    int mid = l + (r-l)/2;    int[] left = helper(arrays, l, mid);    int[] right = helper(arrays, mid+1, r);    return merge2Arrays(left, right);}private int[] merge2Arrays(int[] a, int[] b){    int[] res = new int[a.length + b.length];    int i=0, j=0;    for(int k=0; k&lt;res.length; k++){        if(i &gt;= a.length)            res[k] = b[j++];        else if(j &gt;= b.length)            res[k] = a[i++];        else if(a[i] &lt; b[j])            res[k] = a[i++];        else            res[k] = b[j++];    }    return res;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">54.无序数组有多少个和为K的子数组</span><br></pre></td></tr></table></figure><p>双指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">55.因子分解</span><br><span class="line"></span><br><span class="line">给一个正数N，求这个N的所有的因子分解；</span><br><span class="line"></span><br><span class="line">N &#x3D; 12；</span><br><span class="line"></span><br><span class="line">Ans &#x3D; &#123;12&#125;,&#123;6,2&#125;,&#123;3,4&#125;,&#123;3,2,2&#125;</span><br><span class="line"></span><br><span class="line">解法：递归</span><br></pre></td></tr></table></figure><p>package backtracking;</p><p>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.List;</p><p>// <a href="https://leetcode.com/problems/factor-combinations/" target="_blank" rel="noopener">https://leetcode.com/problems/factor-combinations/</a><br>public class FactorCombinations {</p><p>  public static void main(String[] args) {<br>    FactorCombinations obj = new FactorCombinations();<br>    int n = 12;<br>    List&lt;List<Integer>&gt; resultList = obj.getFactors(12);<br>    System.out.println(Arrays.toString(resultList.toArray()));<br>  }</Integer></p><p>  public List&lt;List<Integer>&gt; getFactors(int n) {<br>    List&lt;List<Integer>&gt; resultList = new ArrayList&lt;List<Integer>&gt;();<br>    // DFS<br>    dfs(resultList, new ArrayList<Integer>(), n, 2);<br>    //dfs1(resultList, new ArrayList<Integer>(), n, 2);</Integer></Integer></Integer></Integer></Integer></p><pre><code>return resultList;</code></pre><p>  }</p><p>  private void dfs(List&lt;List<Integer>&gt; resultList, List<Integer> list, int n, int start) {<br>    // exit<br>    if (n == 1) {<br>      if (list.size() &gt; 1) {<br>        resultList.add(new ArrayList<Integer>(list));<br>      }</Integer></Integer></Integer></p><pre><code>  return;}for (int i = start; i &lt;= n; i++) {  if (n % i == 0) {    list.add(i);    dfs(resultList, list, n / i, i);    list.remove(list.size() - 1);  }}</code></pre><p>  }</p><p>}</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>投票法</title>
      <link href="/2020/08/05/%E6%8A%95%E7%A5%A8%E6%B3%95/"/>
      <url>/2020/08/05/%E6%8A%95%E7%A5%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一半"><a href="#一半" class="headerlink" title="一半"></a>一半</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int majorityElement(int[] nums) &#123;</span><br><span class="line">    int major&#x3D;nums[0];</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line">    for(int num:nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if(major&#x3D;&#x3D;num)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(count&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            major&#x3D;num;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return major;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3"><a href="#1-3" class="headerlink" title="1/3"></a>1/3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; majorityElement(int[] nums) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">        首先可以明确的一点是，这样的元素可能有0个、1个、或者2个，再没有别的情况了. </span><br><span class="line">        然后，求众数I 里的 Boyer-Moore 算法思路在这里依然可用，但需要些改动：</span><br><span class="line">        1) 满足条件的元素最多有两个，那么需要两组变量. count, major变成了</span><br><span class="line">           count1, major1; count2, major2;</span><br><span class="line">        2) 选出的两个元素，需要验证它们的出现次数是否真的满足条件.</span><br><span class="line">        **&#x2F;</span><br><span class="line">        List&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if(nums.length &lt; 1) return ret;</span><br><span class="line">        int count1 &#x3D; 0, count2 &#x3D; 0;</span><br><span class="line">        int major1 &#x3D; nums[0], major2 &#x3D; nums[0];</span><br><span class="line">        for(int num : nums) &#123;</span><br><span class="line">            if(num &#x3D;&#x3D; major1)</span><br><span class="line">                count1++;</span><br><span class="line">            else if(num &#x3D;&#x3D; major2)</span><br><span class="line">                count2++;</span><br><span class="line">            else if(count1 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                count1 &#x3D; 1;</span><br><span class="line">                major1 &#x3D; num;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(count2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                count2 &#x3D; 1;</span><br><span class="line">                major2 &#x3D; num;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count1 &#x3D; 0;</span><br><span class="line">        count2 &#x3D; 0;</span><br><span class="line">        for(int num : nums) &#123;</span><br><span class="line">            if(num &#x3D;&#x3D; major1)</span><br><span class="line">                count1++;</span><br><span class="line">            else if(num &#x3D;&#x3D; major2)</span><br><span class="line">                count2++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count1 &gt; nums.length&#x2F;3)</span><br><span class="line">            ret.add(major1);</span><br><span class="line">        if(major1 !&#x3D; major2 &amp;&amp; count2 &gt; nums.length&#x2F;3)</span><br><span class="line">            ret.add(major2);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="n-k"><a href="#n-k" class="headerlink" title="n/k"></a>n/k</h2><p>左神的代码写的很好，时间复杂度是O(N*K)，额外空间复杂度O(K)，用map集合保存K个不同的值。一、如果map的大小不超过K，遍历到相同的，value加1，不同的，添加进去。用map.containskey判断是否在容器中，比用数组方便。<br>二、如果map大小达到K，遍历到相同的，所有键的值减1，如果值变成0，要删除。这时候引出一全体键值都减1的函数，左神用了遍历map，如果要删除的键放进一个链表里。<br>三、判断map中剩下的值出现次数是否大于N/K</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class hello &#123;&#x2F;&#x2F;100 999</span><br><span class="line">    public static void printKMajor(int[] arr, int K) &#123;</span><br><span class="line">        if (K &lt; 2) &#123;</span><br><span class="line">            System.out.println(&quot;the value of K is invalid.&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; cands &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i !&#x3D; arr.length; i++) &#123;</span><br><span class="line">            if (cands.containsKey(arr[i])) &#123;</span><br><span class="line">                cands.put(arr[i], cands.get(arr[i]) + 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (cands.size() &#x3D;&#x3D; K - 1) &#123;</span><br><span class="line">                    allCandsMinusOne(cands);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cands.put(arr[i], 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; reals &#x3D; getReals(arr, cands);</span><br><span class="line">        boolean hasPrint &#x3D; false;</span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; set : cands.entrySet()) &#123;</span><br><span class="line">            Integer key &#x3D; set.getKey();</span><br><span class="line">            if (reals.get(key) &gt; arr.length &#x2F; K) &#123;</span><br><span class="line">                hasPrint &#x3D; true;</span><br><span class="line">                System.out.print(key + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(hasPrint ? &quot;&quot; : &quot;no such number.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void allCandsMinusOne(HashMap&lt;Integer, Integer&gt; map) &#123;</span><br><span class="line">        List&lt;Integer&gt; removeList &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; set : map.entrySet()) &#123;</span><br><span class="line">            Integer key &#x3D; set.getKey();</span><br><span class="line">            Integer value &#x3D; set.getValue();</span><br><span class="line">            if (value &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                removeList.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (Integer removeKey : removeList) &#123;</span><br><span class="line">            map.remove(removeKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HashMap&lt;Integer, Integer&gt; getReals(int[] arr,</span><br><span class="line">                                                     HashMap&lt;Integer, Integer&gt; cands) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; reals &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i !&#x3D; arr.length; i++) &#123;</span><br><span class="line">            int curNum &#x3D; arr[i];</span><br><span class="line">            if (cands.containsKey(curNum)) &#123;</span><br><span class="line">                reals.put(curNum,reals.getOrDefault(curNum,0)+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return reals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123; 1, 2, 3, 1, 1, 2, 1 &#125;;</span><br><span class="line">        int K &#x3D; 4;</span><br><span class="line">        printKMajor(arr, K);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树相关操作</title>
      <link href="/2020/07/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/07/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static TreeNode stringToTreeNode(String input) &#123;</span><br><span class="line">    input &#x3D; input.trim();</span><br><span class="line">    if (input.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] parts &#x3D; input.split(&quot;,&quot;);</span><br><span class="line">    String item &#x3D; parts[0];</span><br><span class="line">    TreeNode root &#x3D; new TreeNode(Integer.parseInt(item));</span><br><span class="line">    Queue&lt;TreeNode&gt; nodeQueue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    nodeQueue.add(root);</span><br><span class="line">    int index &#x3D; 1;</span><br><span class="line">    while(!nodeQueue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node &#x3D; nodeQueue.remove();</span><br><span class="line"></span><br><span class="line">        if (index &#x3D;&#x3D; parts.length) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        item &#x3D; parts[index++];</span><br><span class="line">        item &#x3D; item.trim();</span><br><span class="line">        if (!item.equals(&quot;null&quot;)) &#123;</span><br><span class="line">            int leftNumber &#x3D; Integer.parseInt(item);</span><br><span class="line">            node.left &#x3D; new TreeNode(leftNumber);</span><br><span class="line">            nodeQueue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (index &#x3D;&#x3D; parts.length) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        item &#x3D; parts[index++];</span><br><span class="line">        item &#x3D; item.trim();</span><br><span class="line">        if (!item.equals(&quot;null&quot;)) &#123;</span><br><span class="line">            int rightNumber &#x3D; Integer.parseInt(item);</span><br><span class="line">            node.right &#x3D; new TreeNode(rightNumber);</span><br><span class="line">            nodeQueue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内部类</title>
      <link href="/2020/07/24/Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2020/07/24/Java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>内部类可对同一包中其他类隐藏，内部类方法可以访问定义这个内部类的作用域中的数据，包括 private 数据。</p><p>内部类是一个编译器现象，与虚拟机无关。编译器会把内部类转换成常规的类文件，用 $ 分隔外部类名与内部类名，其中匿名内部类使用数字编号，虚拟机对此一无所知。</p><p><strong>静态内部类：</strong> 属于外部类，只加载一次。作用域仅在包内，可通过 <code>外部类名.内部类名</code> 直接访问，类内只能访问外部类所有静态属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">     static class Inner</span><br><span class="line">    &#123;</span><br><span class="line">        static int id&#x3D;1;</span><br><span class="line">        public void run()</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;hello&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">         new test.Inner().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员内部类：</strong> 属于外部类的每个对象，随对象一起加载。不可以定义静态成员和方法，可访问外部类的所有内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    private double radius &#x3D; 0;</span><br><span class="line">    public static int count &#x3D;1;</span><br><span class="line">    public Circle(double radius) &#123;</span><br><span class="line">        this.radius &#x3D; radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    class Draw &#123;     &#x2F;&#x2F;内部类</span><br><span class="line">        public void drawSahpe() &#123;</span><br><span class="line">            System.out.println(radius);  &#x2F;&#x2F;外部类的private成员</span><br><span class="line">            System.out.println(count);   &#x2F;&#x2F;外部类的静态成员</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>局部内部类：</strong> 定义在方法内，不能声明访问修饰符，只能定义实例成员变量和实例方法，作用范围仅在声明类的代码块中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        class Inner&#123;</span><br><span class="line">            public void fun()&#123;</span><br><span class="line">                System.out.println(&quot;HelloWorld&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        new Inner().fun();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        new test().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名内部类：</strong> 只用一次的没有名字的类，可以简化代码，创建的对象类型相当于 new 的类的子类类型。用于实现事件监听和其他回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public interface Product &#123;</span><br><span class="line">    public double getPrice();</span><br><span class="line">    public String  getName();</span><br><span class="line">&#125;</span><br><span class="line">public class test1 &#123;</span><br><span class="line">    public void test (Product p)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(p.getName()+&quot;--------&quot;+p.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String [ ] args )</span><br><span class="line">    &#123;</span><br><span class="line">        test1 as&#x3D; new test1 ();</span><br><span class="line">        as.test(new Product( )&#x2F;&#x2F;此处实现接口并实现抽象方法</span><br><span class="line">        &#123;</span><br><span class="line">            public double getPrice( )&#x2F;&#x2F;实现方法</span><br><span class="line">            &#123;</span><br><span class="line">                return 8888;</span><br><span class="line">            &#125;</span><br><span class="line">            public String getName( )&#x2F;&#x2F;实现方法</span><br><span class="line">            &#123;</span><br><span class="line">                return &quot;I can do it &quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MVCC剖析</title>
      <link href="/2020/07/22/MVCC%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/22/MVCC%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（<code>row_id</code>并不是必要的，我们创建的表中有主键或者非NULL唯一键时都不会包含<code>row_id</code>列）：</p><ul><li><code>trx_id</code>：每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值给<code>trx_id</code>隐藏列。</li><li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><p>可以将这些<code>undo日志</code>都连起来，串成一个链表</p><p>为了判断一下版本链中的哪个版本是当前事务可见的，还有一个<code>ReadView</code>的概念，这个<code>ReadView</code>中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，我们把这个列表命名为为<code>m_ids</code>。这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见:</p><ul><li>如果被访问版本的<code>trx_id</code>属性值小于<code>m_ids</code>列表中最小的事务id，表明生成该版本的事务在生成<code>ReadView</code>前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值大于<code>m_ids</code>列表中最大的事务id，表明生成该版本的事务在生成<code>ReadView</code>后才生成，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值在<code>m_ids</code>列表中最大的事务id和最小事务id之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p><code>READ COMMITTED</code> — 每次读取数据前都生成一个ReadView</p><p><code>REPEATABLE READ</code> —在第一次读取数据时生成一个ReadView</p><p>比方说我们的表<code>t</code>现在只包含一条记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | c      |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 刘备   |</span><br><span class="line">+----+--------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>假设插入该记录的事务id为<code>80</code>，那么此刻该条记录的示意图如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf19851d3dce6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vemvvn1db6h431ekvsp158m19.png-15kB"></p><p>假设之后两个<code>id</code>分别为<code>100</code>、<code>200</code>的事务对这条记录进行<code>UPDATE</code>操作，操作流程如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198519aee7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vfo4g814h019mj1jqb1ggu72o3j.png-106.5kB"></p><blockquote><p>小贴士： 能不能在两个事务中交叉更新同一条记录呢？哈哈，这是不可以滴，第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。本篇文章不是讨论锁的，有关锁的更多细节我们之后再说。</p></blockquote><p>每次对记录进行改动，都会记录一条<code>undo日志</code>，每条<code>undo日志</code>也都有一个<code>roll_pointer</code>属性（<code>INSERT</code>操作对应的<code>undo日志</code>没有该属性，因为该记录并没有更早的版本），可以将这些<code>undo日志</code>都连起来，串成一个链表，所以现在的情况就像下图一样：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198524e1b34?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vfrv111j4guetptcts1qgp40.png-57.1kB"></p><p>对该记录每次更新后，都会将旧值放到一条<code>undo日志</code>中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被<code>roll_pointer</code>属性连接成一个链表，我们把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id，这个信息很重要，我们稍后就会用到。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>对于使用<code>READ UNCOMMITTED</code>隔离级别的事务来说，直接读取记录的最新版本就好了，对于使用<code>SERIALIZABLE</code>隔离级别的事务来说，使用加锁的方式来访问记录。对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，就需要用到我们上边所说的<code>版本链</code>了，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。所以设计<code>InnoDB</code>的大叔提出了一个<code>ReadView</code>的概念，这个<code>ReadView</code>中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，我们把这个列表命名为为<code>m_ids</code>。这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>如果被访问版本的<code>trx_id</code>属性值小于<code>m_ids</code>列表中最小的事务id，表明生成该版本的事务在生成<code>ReadView</code>前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值大于<code>m_ids</code>列表中最大的事务id，表明生成该版本的事务在生成<code>ReadView</code>后才生成，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值在<code>m_ids</code>列表中最大的事务id和最小事务id之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本，如果最后一个版本也不可见的话，那么就意味着该条记录对该事务不可见，查询结果就不包含该记录。</p><p>在<code>MySQL</code>中，<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的的一个非常大的区别就是它们生成<code>ReadView</code>的时机不同，我们来看一下。</p><p>READ COMMITTED — 每次读取数据前都生成一个ReadView</p><p><code>REPEATABLE READ</code> —在第一次读取数据时生成一个ReadView</p><h4 id="READ-COMMITTED-—-每次读取数据前都生成一个ReadView"><a href="#READ-COMMITTED-—-每次读取数据前都生成一个ReadView" class="headerlink" title="READ COMMITTED — 每次读取数据前都生成一个ReadView"></a>READ COMMITTED — 每次读取数据前都生成一个ReadView</h4><p>比方说现在系统里有两个<code>id</code>分别为<code>100</code>、<code>200</code>的事务在执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;关羽&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;张飞&#39; WHERE id &#x3D; 1;</span><br><span class="line">复制代码</span><br><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>小贴士： 事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。</p></blockquote><p>此刻，表<code>t</code>中<code>id</code>为<code>1</code>的记录得到的版本链表如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf19852d16845?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vgdl0j1c9d16rbelo1deh17324d.png-42.2kB"></p><p>假设现在有一个使用<code>READ COMMITTED</code>隔离级别的事务开始执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;刘备&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个<code>SELECT1</code>的执行过程如下：</p><ul><li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[100, 200]</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>c</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;关羽&#39;</code>，该版本的<code>trx_id</code>值也为<code>100</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>m_ids</code>列表中最小的事务id<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;刘备&#39;</code>的记录。</li></ul><p>之后，我们把事务id为<code>100</code>的事务提交一下，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;关羽&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;张飞&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后再到事务id为<code>200</code>的事务中更新一下表<code>t</code>中<code>id</code>为1的记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;赵云&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;诸葛亮&#39; WHERE id &#x3D; 1;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此刻，表<code>t</code>中<code>id</code>为<code>1</code>的记录的版本链就长这样：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198532476f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vgrt5jeh2itl5e41ocl944q.png-57.6kB"></p><p>然后再到刚才使用<code>READ COMMITTED</code>隔离级别的事务中继续查找这个id为<code>1</code>的记录，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200均未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;刘备&#39;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 100提交，Transaction 200未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;张飞&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个<code>SELECT2</code>的执行过程如下：</p><ul><li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[200]</code>（事务id为<code>100</code>的那个事务已经提交了，所以生成快照时就没有它了）。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>c</code>的内容是<code>&#39;诸葛亮&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;赵云&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，比<code>m_ids</code>列表中最小的事务id<code>200</code>还要小，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;张飞&#39;</code>的记录。</li></ul><p>以此类推，如果之后事务id为<code>200</code>的记录也提交了，再此在使用<code>READ COMMITTED</code>隔离级别的事务中查询表<code>t</code>中<code>id</code>值为<code>1</code>的记录时，得到的结果就是<code>&#39;诸葛亮&#39;</code>了，具体流程我们就不分析了。总结一下就是：使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p><h4 id="REPEATABLE-READ-—在第一次读取数据时生成一个ReadView"><a href="#REPEATABLE-READ-—在第一次读取数据时生成一个ReadView" class="headerlink" title="REPEATABLE READ —在第一次读取数据时生成一个ReadView"></a>REPEATABLE READ —在第一次读取数据时生成一个ReadView</h4><p>对于使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个<code>ReadView</code>，之后的查询就不会重复生成了。我们还是用例子看一下是什么效果。</p><p>比方说现在系统里有两个<code>id</code>分别为<code>100</code>、<code>200</code>的事务在执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;关羽&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;张飞&#39; WHERE id &#x3D; 1;</span><br><span class="line">复制代码</span><br><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此刻，表<code>t</code>中<code>id</code>为<code>1</code>的记录得到的版本链表如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf19852d16845?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vgdl0j1c9d16rbelo1deh17324d.png-42.2kB"></p><p>假设现在有一个使用<code>REPEATABLE READ</code>隔离级别的事务开始执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;刘备&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个<code>SELECT1</code>的执行过程如下：</p><ul><li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[100, 200]</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>c</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;关羽&#39;</code>，该版本的<code>trx_id</code>值也为<code>100</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>m_ids</code>列表中最小的事务id<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;刘备&#39;</code>的记录。</li></ul><p>之后，我们把事务id为<code>100</code>的事务提交一下，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;关羽&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;张飞&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后再到事务id为<code>200</code>的事务中更新一下表<code>t</code>中<code>id</code>为1的记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;赵云&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;诸葛亮&#39; WHERE id &#x3D; 1;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此刻，表<code>t</code>中<code>id</code>为<code>1</code>的记录的版本链就长这样：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198532476f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vgrt5jeh2itl5e41ocl944q.png-57.6kB"></p><p>然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个id为<code>1</code>的记录，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200均未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;刘备&#39;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 100提交，Transaction 200未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值仍为&#39;刘备&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个<code>SELECT2</code>的执行过程如下：</p><ul><li>因为之前已经生成过<code>ReadView</code>了，所以此时直接复用之前的<code>ReadView</code>，之前的<code>ReadView</code>中的<code>m_ids</code>列表就是<code>[100, 200]</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>c</code>的内容是<code>&#39;诸葛亮&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;赵云&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，而<code>m_ids</code>列表中是包含值为<code>100</code>的事务id的，所以该版本也不符合要求，同理下一个列<code>c</code>的内容是<code>&#39;关羽&#39;</code>的版本也不符合要求。继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，<code>80</code>小于<code>m_ids</code>列表中最小的事务id<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;刘备&#39;</code>的记录。</li></ul><p>也就是说两次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是<code>&#39;刘备&#39;</code>，这就是<code>可重复读</code>的含义。如果我们之后再把事务id为<code>200</code>的记录提交了，之后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个id为<code>1</code>的记录，得到的结果还是<code>&#39;刘备&#39;</code>，具体执行过程大家可以自己分析一下。</p><h3 id="MVCC总结"><a href="#MVCC总结" class="headerlink" title="MVCC总结"></a>MVCC总结</h3><p>从上边的描述中我们可以看出来，所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行普通的<code>SEELCT</code>操作时访问记录的版本链的过程，这样子可以使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是生成<code>ReadView</code>的时机不同，<code>READ COMMITTD</code>在每一次进行普通<code>SELECT</code>操作前都会生成一个<code>ReadView</code>，而<code>REPEATABLE READ</code>只在第一次进行普通<code>SELECT</code>操作前生成一个<code>ReadView</code>，之后的查询操作都重复这个<code>ReadView</code>就好了</p><p>作者：小孩子4919<br>链接：<a href="https://juejin.im/post/5c9b1b7df265da60e21c0b57" target="_blank" rel="noopener">https://juejin.im/post/5c9b1b7df265da60e21c0b57</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="为什么MVCC不能解决幻读？"><a href="#为什么MVCC不能解决幻读？" class="headerlink" title="为什么MVCC不能解决幻读？"></a>为什么MVCC不能解决幻读？</h3><p><a href="https://blog.csdn.net/weixin_42907817/article/details/107121470" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42907817/article/details/107121470</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Semaphore剖析</title>
      <link href="/2020/07/18/Semaphore%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/18/Semaphore%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>可以看到公平共享锁和非公平共享锁的区别就在是否需要判断队列中是否有已经等待的线程。公平共享锁需要先判断，非公平共享锁直接插队，尽管前面已经有线程在等待。</p><p>非公平锁acquire，内部重写，如果state&lt;0 会被阻塞，如果成功，会扣取state值</p><p>acquire state减一 release加一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化10个信号量在信号包中，让ABCD4个线程分别去获取</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Semaphore semaphore &#x3D; new Semaphore(10,false);</span><br><span class="line">        SemaphoreTest(semaphore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void SemaphoreTest(final Semaphore semaphore) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;线程A初始获取了4个信号量，然后分3次释放了这4个信号量</span><br><span class="line">        Thread threadA &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire(8);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get 1 semaphore&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; release 1 semaphore&quot;);</span><br><span class="line">                    semaphore.release(3);</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; release 1 semaphore&quot;);</span><br><span class="line">                    semaphore.release(5);</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.setName(&quot;threadA&quot;);</span><br><span class="line">        &#x2F;&#x2F;线程B初始获取了5个信号量，然后分2次释放了这5个信号量</span><br><span class="line">        Thread threadB &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;B start&quot;);</span><br><span class="line">                    semaphore.acquire(6);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get 6 semaphore&quot;);</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; release 6 semaphore&quot;);</span><br><span class="line">                    semaphore.release(6);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadB.setName(&quot;threadB&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;线程C初始获取了4个信号量，然后分1次释放了这4个信号量</span><br><span class="line">        Thread threadC &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;C start&quot;);</span><br><span class="line">                    semaphore.acquire(2);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get 2 semaphore&quot;);</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; release 2 semaphore&quot;);</span><br><span class="line">                    semaphore.release(2);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        threadC.setName(&quot;threadC&quot;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        Thread.sleep(1);</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        threadC.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring相关问题</title>
      <link href="/2020/07/17/Spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/17/Spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h3><h4 id="Q1：IoC-是什么？"><a href="#Q1：IoC-是什么？" class="headerlink" title="Q1：IoC 是什么？"></a>Q1：IoC 是什么？</h4><p>IoC 即控制反转，简单来说就是把原来代码里需要实现的对象创建、依赖反转给容器来帮忙实现，需要创建一个容器并且需要一种描述让容器知道要创建的对象间的关系，在 Spring 中管理对象及其依赖关系是通过 Spring 的 IoC 容器实现的。</p><p>IoC 的实现方式有依赖注入和依赖查找，由于依赖查找使用的很少，因此 IoC 也叫做依赖注入。依赖注入指对象被动地接受依赖类而不用自己主动去找，对象不是从容器中查找它依赖的类，而是在容器实例化对象时主动将它依赖的类注入给它。假设一个 Car 类需要一个 Engine 的对象，那么一般需要需要手动 new 一个 Engine，利用 IoC 就只需要定义一个私有的 Engine 类型的成员变量，容器会在运行时自动创建一个 Engine 的实例对象并将引用自动注入给成员变量。</p><hr><h4 id="Q2：IoC-容器初始化过程？"><a href="#Q2：IoC-容器初始化过程？" class="headerlink" title="Q2：IoC 容器初始化过程？"></a>Q2：IoC 容器初始化过程？</h4><p><strong>基于 XML 的容器初始化</strong></p><p>当创建一个 ClassPathXmlApplicationContext 时，构造方法做了两件事：① 调用父容器的构造方法为容器设置好 Bean 资源加载器。② 调用父类的 <code>setConfigLocations</code> 方法设置 Bean 配置信息的定位路径。</p><p>ClassPathXmlApplicationContext 通过调用父类 AbstractApplicationContext 的 <code>refresh</code> 方法启动整个 IoC 容器对 Bean 定义的载入过程，<code>refresh</code> 是一个模板方法，规定了 IoC 容器的启动流程。在创建 IoC 容器前如果已有容器存在，需要把已有的容器销毁，保证在 <code>refresh</code> 方法后使用的是新创建的 IoC 容器。</p><p>容器创建后通过 <code>loadBeanDefinitions</code> 方法加载 Bean 配置资源，该方法做两件事：① 调用资源加载器的方法获取要加载的资源。② 真正执行加载功能，由子类 XmlBeanDefinitionReader 实现。加载资源时首先解析配置文件路径，读取配置文件的内容，然后通过 XML 解析器将 Bean 配置信息转换成文档对象，之后按照 Spring Bean 的定义规则对文档对象进行解析。</p><p>Spring IoC 容器中注册解析的 Bean 信息存放在一个 HashMap 集合中，key 是字符串，值是 BeanDefinition，注册过程中需要使用 synchronized 保证线程安全。当配置信息中配置的 Bean 被解析且被注册到 IoC 容器中后，初始化就算真正完成了，Bean 定义信息已经可以使用且可被检索。Spring IoC 容器的作用就是对这些注册的 Bean 定义信息进行处理和维护，注册的 Bean 定义信息是控制反转和依赖注入的基础。</p><p><strong>基于注解的容器初始化</strong></p><p>分为两种：① 直接将注解 Bean 注册到容器中，可以在初始化容器时注册，也可以在容器创建之后手动注册，然后刷新容器使其对注册的注解 Bean 进行处理。② 通过扫描指定的包及其子包的所有类处理，在初始化注解容器时指定要自动扫描的路径。</p><hr><h4 id="Q3：依赖注入的实现方法有哪些？"><a href="#Q3：依赖注入的实现方法有哪些？" class="headerlink" title="Q3：依赖注入的实现方法有哪些？"></a>Q3：依赖注入的实现方法有哪些？</h4><p><strong>构造方法注入：</strong> IoC Service Provider 会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。这种方法的优点是在对象构造完成后就处于就绪状态，可以马上使用。缺点是当依赖对象较多时，构造方法的参数列表会比较长，构造方法无法被继承，无法设置默认值。对于非必需的依赖处理可能需要引入多个构造方法，参数数量的变动可能会造成维护的困难。</p><p><strong>setter 方法注入：</strong> 当前对象只需要为其依赖对象对应的属性添加 setter 方法，就可以通过 setter 方法将依赖对象注入到被依赖对象中。setter 方法注入在描述性上要比构造方法注入强，并且可以被继承，允许设置默认值。缺点是无法在对象构造完成后马上进入就绪状态。</p><p><strong>接口注入：</strong> 必须实现某个接口，接口提供方法来为其注入依赖对象。使用少，因为它强制要求被注入对象实现不必要接口，侵入性强。</p><hr><h4 id="Q4：依赖注入的相关注解？"><a href="#Q4：依赖注入的相关注解？" class="headerlink" title="Q4：依赖注入的相关注解？"></a>Q4：依赖注入的相关注解？</h4><p><code>@Autowired</code>：自动按类型注入，如果有多个匹配则按照指定 Bean 的 id 查找，查找不到会报错。</p><p><code>@Qualifier</code>：在自动按照类型注入的基础上再按照 Bean 的 id 注入，给变量注入时必须搭配 <code>@Autowired</code>，给方法注入时可单独使用。</p><p><code>@Resource</code> ：直接按照 Bean 的 id 注入，只能注入 Bean 类型。</p><p><code>@Value</code> ：用于注入基本数据类型和 String 类型。</p><hr><h4 id="Q5：依赖注入的过程？"><a href="#Q5：依赖注入的过程？" class="headerlink" title="Q5：依赖注入的过程？"></a>Q5：依赖注入的过程？</h4><p><code>getBean</code> 方法获取 Bean 实例，该方***调用 <code>doGetBean</code> ，<code>doGetBean</code> 真正实现从 IoC 容器获取 Bean 的功能，也是触发依赖注入的地方。</p><p>具体创建 Bean 对象的过程由 ObjectFactory 的 <code>createBean</code> 完成，该方法主要通过 <code>createBeanInstance</code> 方法生成 Bean 包含的 Java 对象实例和 <code>populateBean</code> 方法对 Bean 属性的依赖注入进行处理。</p><p>在 <code>populateBean</code>方法中，注入过程主要分为两种情况：① 属性值类型不需要强制转换时，不需要解析属性值，直接进行依赖注入。② 属性值类型需要强制转换时，首先解析属性值，然后对解析后的属性值进行依赖注入。依赖注入的过程就是将 Bean 对象实例设置到它所依赖的 Bean 对象属性上，真正的依赖注入是通过 <code>setPropertyValues</code> 方法实现的，该方法使用了委派模式。</p><p>BeanWrapperImpl 类负责对完成初始化的 Bean 对象进行依赖注入，对于非集合类型属性，使用 JDK 反射，通过属性的 setter 方法为属性设置注入后的值。对于集合类型的属性，将属性值解析为目标类型的集合后直接赋值给属性。</p><p>当容器对 Bean 的定位、载入、解析和依赖注入全部完成后就不再需要手动创建对象，IoC 容器会自动为我们创建对象并且注入依赖。</p><hr><h4 id="Q6：Bean-的生命周期？"><a href="#Q6：Bean-的生命周期？" class="headerlink" title="Q6：Bean 的生命周期？"></a>Q6：Bean 的生命周期？</h4><p>在 IoC 容器的初始化过程中会对 Bean 定义完成资源定位，加载读取配置并解析，最后将解析的 Bean 信息放在一个 HashMap 集合中。当 IoC 容器初始化完成后，会进行对 Bean 实例的创建和依赖注入过程，注入对象依赖的各种属性值，在初始化时可以指定自定义的初始化方法。经过这一系列初始化操作后 Bean 达到可用状态，接下来就可以使用 Bean 了，当使用完成后会调用 destroy 方法进行销毁，此时也可以指定自定义的销毁方法，最终 Bean 被销毁且从容器中移除。</p><p>XML 方式通过配置 bean 标签中的 init-Method 和 destory-Method 指定自定义初始化和销毁方法。 </p><p>注解方式通过 <code>@PreConstruct</code> 和 <code>@PostConstruct</code> 注解指定自定义初始化和销毁方法。</p><hr><h4 id="Q7：Bean-的作用范围？"><a href="#Q7：Bean-的作用范围？" class="headerlink" title="Q7：Bean 的作用范围？"></a>Q7：Bean 的作用范围？</h4><p>通过 scope 属性指定 bean 的作用范围，包括：</p><p>① singleton：单例模式，是默认作用域，不管收到多少 Bean 请求每个容器中只有一个唯一的 Bean 实例。</p><p>② prototype：原型模式，和 singleton 相反，每次 Bean 请求都会创建一个新的实例。</p><p>③ request：每次 HTTP 请求都会创建一个新的 Bean 并把它放到 request 域中，在请求完成后 Bean 会失效并被垃圾收集器回收。</p><p>④ session：和 request 类似，确保每个 session 中有一个 Bean 实例，session 过期后 bean 会随之失效。</p><p>⑤ global session：当应用部署在 Portlet 容器时，如果想让所有 Portlet 共用全局存储变量，那么该变量需要存储在 global session 中。</p><hr><h4 id="Q8：如何通过-XML-方式创建-Bean？"><a href="#Q8：如何通过-XML-方式创建-Bean？" class="headerlink" title="Q8：如何通过 XML 方式创建 Bean？"></a>Q8：如何通过 XML 方式创建 Bean？</h4><p>默认无参构造方法，只需要指明 bean 标签中的 id 和 class 属性，如果没有无参构造方***报错。</p><p>静态工厂方法，通过 bean 标签中的 class 属性指明静态工厂，factory-method 属性指明静态工厂方法。</p><p>实例工厂方法，通过 bean 标签中的 factory-bean 属性指明实例工厂，factory-method 属性指明实例工厂方法。</p><hr><h4 id="Q9：如何通过注解创建-Bean？"><a href="#Q9：如何通过注解创建-Bean？" class="headerlink" title="Q9：如何通过注解创建 Bean？"></a>Q9：如何通过注解创建 Bean？</h4><p><code>@Component</code> 把当前类对象存入 Spring 容器中，相当于在 xml 中配置一个 bean 标签。value 属性指定 bean 的 id，默认使用当前类的首字母小写的类名。</p><p><code>@Controller</code>，<code>@Service</code>，<code>@Repository</code> 三个注解都是 <code>@Component</code>  的衍生注解，作用及属性都是一模一样的。只是提供了更加明确语义，<code>@Controller</code> 用于表现层，<code>@Service</code>用于业务层，<code>@Repository</code>用于持久层。如果注解中有且只有一个 value 属性要赋值时可以省略 value。</p><p>如果想将第三方的类变成组件又没有源代码，也就没办法使用 <code>@Component</code> 进行自动配置，这种时候就要使用 <code>@Bean</code> 注解。被 <code>@Bean</code> 注解的方法返回值是一个对象，将会实例化，配置和初始化一个新对象并返回，这个对象由 Spring 的 IoC 容器管理。name 属性用于给当前 <code>@Bean</code>  注解方法创建的对象指定一个名称，即 bean 的 id。当使用注解配置方法时，如果方法有参数，Spring 会去容器查找是否有可用 bean对象，查找方式和 <code>@Autowired</code> 一样。</p><hr><h4 id="Q10：如何通过注解配置文件？"><a href="#Q10：如何通过注解配置文件？" class="headerlink" title="Q10：如何通过注解配置文件？"></a>Q10：如何通过注解配置文件？</h4><p><code>@Configuration</code> 用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解，value 属性用于指定配置类的字节码。</p><p><code>@ComponentScan</code> 用于指定 Spring 在初始化容器时要扫描的包。basePackages 属性用于指定要扫描的包。</p><p><code>@PropertySource</code> 用于加载 <code>.properties</code> 文件中的配置。value 属性用于指定文件位置，如果是在类路径下需要加上 classpath。</p><p><code>@Import</code> 用于导入其他配置类，在引入其他配置类时可以不用再写 <code>@Configuration</code> 注解。有 <code>@Import</code> 的是父配置类，引入的是子配置类。value 属性用于指定其他配置类的字节码。</p><hr><h4 id="Q11：BeanFactory、FactoryBean-和-ApplicationContext-的区别？"><a href="#Q11：BeanFactory、FactoryBean-和-ApplicationContext-的区别？" class="headerlink" title="Q11：BeanFactory、FactoryBean 和 ApplicationContext 的区别？"></a>Q11：BeanFactory、FactoryBean 和 ApplicationContext 的区别？</h4><p>BeanFactory 是一个 Bean 工厂，使用简单工厂模式，是 Spring IoC 容器顶级接口，可以理解为含有 Bean 集合的工厂类，作用是管理 Bean，包括实例化、定位、配置对象及建立这些对象间的依赖。BeanFactory 实例化后并不会自动实例化 Bean，只有当 Bean 被使用时才实例化与装配依赖关系，属于延迟加载，适合多例模式。</p><p>FactoryBean 是一个工厂 Bean，使用了工厂方法模式，作用是生产其他 Bean 实例，可以通过实现该接口，提供一个工厂方法来自定义实例化 Bean 的逻辑。FactoryBean 接口由 BeanFactory 中配置的对象实现，这些对象本身就是用于创建对象的工厂，如果一个 Bean 实现了这个接口，那么它就是创建对象的工厂 Bean，而不是 Bean 实例本身。</p><p>ApplicationConext 是 BeanFactory 的子接口，扩展了 BeanFactory 的功能，提供了支持国际化的文本消息，统一的资源文件读取方式，事件传播以及应用层的特别配置等。容器会在初始化时对配置的 Bean 进行预实例化，Bean 的依赖注入在容器初始化时就已经完成，属于立即加载，适合单例模式，一般推荐使用。</p><hr><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h4 id="Q1：AOP-是什么？"><a href="#Q1：AOP-是什么？" class="headerlink" title="Q1：AOP 是什么？"></a>Q1：AOP 是什么？</h4><p>AOP 即面向切面编程，简单地说就是将代码中重复的部分抽取出来，在需要执行的时候使用动态代理技术，在不修改源码的基础上对方法进行增强。</p><p>Spring 根据类是否实现接口来判断动态代理方式，如果实现接口会使用 JDK 的动态代理，核心是 InvocationHandler 接口和 Proxy 类，如果没有实现接口会使用 CGLib 动态代理，CGLib 是在运行时动态生成某个类的子类，如果某个类被标记为 final，不能使用 CGLib 。</p><p>JDK 动态代理主要通过重组字节码实现，首先获得被代理对象的引用和所有接口，生成新的类必须实现被代理类的所有接口，动态生成Java 代码后编译新生成的 <code>.class</code> 文件并重新加载到 JVM 运行。JDK 代理直接写 Class 字节码，CGLib 是采用 ASM 框架写字节码，生成代理类的效率低。但是 CGLib 调用方法的效率高，因为 JDK 使用反射调用方法，CGLib 使用 FastClass 机制为代理类和被代理类各生成一个类，这个类会为代理类或被代理类的方法生成一个 index，这个 index 可以作为参数直接定位要调用的方法。</p><p>常用场景包括权限认证、自动缓存、错误处理、日志、调试和事务等。</p><hr><h4 id="Q2：AOP-的相关注解有哪些？"><a href="#Q2：AOP-的相关注解有哪些？" class="headerlink" title="Q2：AOP 的相关注解有哪些？"></a>Q2：AOP 的相关注解有哪些？</h4><p><code>@Aspect</code>：声明被注解的类是一个切面 Bean。</p><p><code>@Before</code>：前置通知，指在某个连接点之前执行的通知。</p><p><code>@After</code>：后置通知，指某个连接点退出时执行的通知（不论正常返回还是异常退出）。</p><p><code>@AfterReturning</code>：返回后通知，指某连接点正常完成之后执行的通知，返回值使用returning属性接收。</p><p><code>@AfterThrowing</code>：异常通知，指方法抛出异常导致退出时执行的通知，和<code>@AfterReturning</code>只会有一个执行，异常使用throwing属性接收。</p><hr><h4 id="Q3：AOP-的相关术语有什么？"><a href="#Q3：AOP-的相关术语有什么？" class="headerlink" title="Q3：AOP 的相关术语有什么？"></a>Q3：AOP 的相关术语有什么？</h4><p><code>Aspect</code>：切面，一个关注点的模块化，这个关注点可能会横切多个对象。</p><p><code>Joinpoint</code>：连接点，程序执行过程中的某一行为，即业务层中的所有方法。。</p><p><code>Advice</code>：通知，指切面对于某个连接点所产生的动作，包括前置通知、后置通知、返回后通知、异常通知和环绕通知。</p><p><code>Pointcut</code>：切入点，指被拦截的连接点，切入点一定是连接点，但连接点不一定是切入点。</p><p><code>Proxy</code>：代理，Spring AOP 中有 JDK 动态代理和 CGLib 代理，目标对象实现了接口时采用 JDK 动态代理，反之采用 CGLib 代理。</p><p><code>Target</code>：代理的目标对象，指一个或多个切面所通知的对象。</p><p><code>Weaving</code> ：织入，指把增强应用到目标对象来创建代理对象的过程。</p><hr><h4 id="Q4：AOP-的过程？"><a href="#Q4：AOP-的过程？" class="headerlink" title="Q4：AOP 的过程？"></a>Q4：AOP 的过程？</h4><p>Spring AOP 由 BeanPostProcessor 后置处理器开始，这个后置处理器是一个***，可以监听容器触发的 Bean 生命周期事件，向容器注册后置处理器以后，容器中管理的 Bean 就具备了接收 IoC 容器回调事件的能力。BeanPostProcessor 的调用发生在 Spring IoC 容器完成 Bean 实例对象的创建和属性的依赖注入后，为 Bean 对象添加后置处理器的入口是 <code>initializeBean</code> 方法。</p><p>Spring 中 JDK 动态代理通过 JdkDynamicAopProxy 调用 Proxy 的 <code>newInstance</code> 方法来生成代理类，JdkDynamicAopProxy 也实现了 InvocationHandler 接口，<code>invoke</code> 方法的具体逻辑是先获取应用到此方法上的拦截器链，如果有拦截器则创建 MethodInvocation 并调用其 <code>proceed</code> 方法，否则直接反射调用目标方法。因此 Spring AOP 对目标对象的增强是通过拦截器实现的。</p><hr><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h4 id="Q1：Spring-MVC-的处理流程？"><a href="#Q1：Spring-MVC-的处理流程？" class="headerlink" title="Q1：Spring MVC 的处理流程？"></a>Q1：Spring MVC 的处理流程？</h4><p>Web 容器启动时会通知 Spring 初始化容器，加载 Bean 的定义信息并初始化所有单例 Bean，然后遍历容器中的 Bean，获取每一个 Controller 中的所有方法访问的 URL，将 URL 和对应的 Controller 保存到一个 Map 集合中。</p><p>所有的请求会转发给 DispatcherServlet 前端处理器处理，DispatcherServlet 会请求 HandlerMapping 找出容器中被 <code>@Controler</code> 注解修饰的 Bean 以及被 <code>@RequestMapping</code> 修饰的方法和类，生成 Handler 和 HandlerInterceptor 并以一个 HandlerExcutionChain 处理器执行链的形式返回。</p><p>之后 DispatcherServlet 使用 Handler 找到对应的 HandlerApapter，通过 HandlerApapter 调用 Handler 的方法，将请求参数绑定到方法的形参上，执行方法处理请求并得到 ModelAndView。</p><p>最后 DispatcherServlet 根据使用 ViewResolver 试图解析器对得到的 ModelAndView 逻辑视图进行解析得到 View 物理视图，然后对视图渲染，将数据填充到视图中并返回给客户端。</p><hr><h4 id="Q2：Spring-MVC-有哪些组件？"><a href="#Q2：Spring-MVC-有哪些组件？" class="headerlink" title="Q2：Spring MVC 有哪些组件？"></a>Q2：Spring MVC 有哪些组件？</h4><p><code>DispatcherServlet</code>：SpringMVC 中的前端控制器，是整个流程控制的核心，负责接收请求并转发给对应的处理组件。</p><p><code>Handler</code>：处理器，完成具体业务逻辑，相当于 Servlet 或 Action。</p><p><code>HandlerMapping</code>：完成 URL 到 Controller 映射，DispatcherServlet 通过 HandlerMapping 将不同请求映射到不同 Handler。</p><p><code>HandlerInterceptor</code>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</p><p><code>HandlerExecutionChain</code>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor。</p><p><code>HandlerAdapter</code>：处理器适配器，Handler执行业务方法前需要进行一系列操作，包括表单数据验证、数据类型转换、将表单数据封装到JavaBean等，这些操作都由 HandlerAdapter 完成。DispatcherServlet 通过 HandlerAdapter 来执行不同的 Handler。</p><p><code>ModelAndView</code>：装载模型数据和视图信息，作为 Handler 处理结果返回给 DispatcherServlet。</p><p><code>ViewResolver</code>：视图解析器，DispatcherServlet 通过它将逻辑视图解析为物理视图，最终将渲染的结果响应给客户端。</p><hr><h4 id="Q3：Spring-MVC-的相关注解？"><a href="#Q3：Spring-MVC-的相关注解？" class="headerlink" title="Q3：Spring MVC 的相关注解？"></a>Q3：Spring MVC 的相关注解？</h4><p><code>@Controller</code>：在类定义处添加，将类交给IoC容器管理。</p><p><code>@RequtestMapping</code>：将URL请求和业务方法映射起来，在类和方法定义上都可以添加该注解。<code>value</code> 属性指定URL请求的实际地址，是默认值。<code>method</code> 属性限制请求的方法类型，包括GET、POST、PUT、DELETE等。如果没有使用指定的请求方法请求URL，会报405 Method Not Allowed 错误。<code>params</code> 属性限制必须提供的参数，如果没有会报错。</p><p><code>@RequestParam</code>：如果 Controller 方法的形参和 URL 参数名一致可以不添加注解，如果不一致可以使用该注解绑定。<code>value</code> 属性表示HTTP请求中的参数名。<code>required</code> 属性设置参数是否必要，默认false。<code>defaultValue</code> 属性指定没有给参数赋值时的默认值。</p><p><code>@PathVariable</code>：Spring MVC 支持 RESTful 风格 URL，通过 <code>@PathVariable</code> 完成请求参数与形参的绑定。</p><hr><h3 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h3><h4 id="Q1：ORM-是什么？"><a href="#Q1：ORM-是什么？" class="headerlink" title="Q1：ORM 是什么？"></a>Q1：ORM 是什么？</h4><p>ORM 即 Object-Relational Mapping ，表示对象关系映射，映射的不只是对象的值还有对象之间的关系，通过 ORM 就可以把对象映射到关系型数据库中。操作实体类就相当于操作数据库表，可以不再重点关注 SQL 语句。</p><hr><h4 id="Q2：JPA-如何使用？"><a href="#Q2：JPA-如何使用？" class="headerlink" title="Q2：JPA 如何使用？"></a>Q2：JPA 如何使用？</h4><p>只需要持久层接口继承 JpaRepository 即可，泛型参数列表中第一个参数是实体类类型，第二个参数是主键类型。</p><p>运行时通过 <code>JdkDynamicAopProxy</code> 的 <code>invoke</code> 方法创建了一个动态代理对象 <code>SimpleJpaRepository</code>，<code>SimpleJpaRepository</code> 中封装了 JPA 的操作，通过 <code>hibernate</code>（封装了JDBC）完成数据库操作。</p><hr><h4 id="Q3：JPA-实体类相关注解有哪些？"><a href="#Q3：JPA-实体类相关注解有哪些？" class="headerlink" title="Q3：JPA 实体类相关注解有哪些？"></a>Q3：JPA 实体类相关注解有哪些？</h4><p><code>@Entity</code>：表明当前类是一个实体类。</p><p><code>@Table</code> ：关联实体类和数据库表。</p><p><code>@Column</code> ：关联实体类属性和数据库表中字段。</p><p><code>@Id</code> ：声明当前属性为数据库表主键对应的属性。</p><p><code>@GeneratedValue</code>： 配置主键生成策略。</p><p><code>@OneToMany</code> ：配置一对多关系，mappedBy 属性值为主表实体类在从表实体类中对应的属性名。</p><p><code>@ManyToOne</code> ：配置多对一关系，targetEntity 属性值为主表对应实体类的字节码。</p><p><code>@JoinColumn</code>：配置外键关系，name 属性值为外键名称，referencedColumnName 属性值为主表主键名称。</p><hr><h4 id="Q4：对象导航查询是什么？"><a href="#Q4：对象导航查询是什么？" class="headerlink" title="Q4：对象导航查询是什么？"></a>Q4：对象导航查询是什么？</h4><p>通过 get 方法查询一个对象的同时，通过此对象可以查询它的关联对象。</p><p>对象导航查询一到多默认使用延迟加载的形式， 关联对象是集合，因此使用立即加载可能浪费资源。</p><p>对象导航查询多到一默认使用立即加载的形式， 关联对象是一个对象，因此使用立即加载。</p><p>如果要改变加载方式，在实体类注解配置加上 fetch 属性即可，LAZY 表示延迟加载，EAGER 表示立即加载。</p><hr><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h4 id="Q1：Mybatis-的优缺点？"><a href="#Q1：Mybatis-的优缺点？" class="headerlink" title="Q1：Mybatis 的优缺点？"></a>Q1：Mybatis 的优缺点？</h4><p><strong>优点</strong></p><p>相比 JDBC 减少了大量代码量，减少冗余代码。</p><p>使用灵活，SQL 语句写在 XML 里，从程序代码中彻底分离，降低了耦合度，便于管理。</p><p>提供 XML 标签，支持编写动态 SQL 语句。</p><p>提供映射标签，支持对象与数据库的 ORM 字段映射关系。</p><p><strong>缺点</strong></p><p>SQL 语句编写工作量较大，尤其是字段和关联表多时。</p><p>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><hr><h4 id="Q2：Mybatis-的-XML-文件有哪些标签属性？"><a href="#Q2：Mybatis-的-XML-文件有哪些标签属性？" class="headerlink" title="Q2：Mybatis 的 XML 文件有哪些标签属性？"></a>Q2：Mybatis 的 XML 文件有哪些标签属性？</h4><p><code>select</code>、<code>insert</code>、<code>update</code>、<code>delete</code> 标签分别对应查询、添加、更新、删除操作。</p><p><code>parameterType</code>  属性表示参数的数据类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型，当有多个参数时可以使用 <code>#{argn}</code> 的形式表示第 n 个参数。除了基本数据类型都要以全限定类名的形式指定参数类型。</p><p><code>resultType</code>  表示返回的结果类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型。还可以使用把返回结果封装为复杂类型的 <code>resultMap</code> 。</p><hr><h4 id="Q3：Mybatis-的一级缓存是什么？"><a href="#Q3：Mybatis-的一级缓存是什么？" class="headerlink" title="Q3：Mybatis 的一级缓存是什么？"></a>Q3：Mybatis 的一级缓存是什么？</h4><p>一级缓存是 SqlSession 级别，默认开启且不能关闭。</p><p>操作数据库时需要创建 SqlSession 对象，对象中有一个 HashMap 存储缓存数据，不同 SqlSession 之间缓存数据区域互不影响。</p><p>一级缓存的作用域是 SqlSession 范围的，在同一个 SqlSession 中执行两次相同的 SQL 语句时，第一次执行完毕会将结果保存在缓存中，第二次查询直接从缓存中获取。</p><p>如果 SqlSession 执行了 DML 操作（insert、update、delete），Mybatis 必须将缓存清空保证数据有效性。 </p><hr><h4 id="Q4：Mybatis-的二级缓存是什么？"><a href="#Q4：Mybatis-的二级缓存是什么？" class="headerlink" title="Q4：Mybatis 的二级缓存是什么？"></a>Q4：Mybatis 的二级缓存是什么？</h4><p>二级缓存是Mapper 级别，默认关闭。</p><p>使用二级缓存时多个 SqlSession 使用同一个 Mapper 的 SQL 语句操作数据库，得到的数据会存在二级缓存区，同样使用 HashMap 进行数据存储，相比于一级缓存，二级缓存范围更大，多个 SqlSession 可以共用二级缓存，作用域是 Mapper 的同一个 namespace，不同 SqlSession 两次执行相同的 namespace 下的 SQL 语句，参数也相等，则第一次执行成功后会将数据保存在二级缓存中，第二次可直接从二级缓存中取出数据。</p><p>要使用二级缓存，需要在全局配置文件中配置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code> ，再在对应的映射文件中配置一个 <code>&lt;cache/&gt;</code> 标签。</p><hr><h4 id="Q5：Mybatis-和-的区别？"><a href="#Q5：Mybatis-和-的区别？" class="headerlink" title="Q5：Mybatis  #{} 和 ${} 的区别？"></a>Q5：Mybatis  <code>#{}</code> 和 <code>${}</code> 的区别？</h4><p>使用 <code>${}</code>  相当于使用字符串拼接，存在 SQL 注入的风险。</p><p>使用 <code>#{}</code> 相当于使用占位符，可以防止 SQL 注入，不支持使用占位符的地方就只能使用 <code>${}</code> ，典型情况就是动态参数。</p><p>作者：冠状病毒biss<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=3&amp;channel=666&amp;source_id=search_post" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=3&amp;channel=666&amp;source_id=search_post</a><br>来源：牛客网</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何在主线程捕获子线程的异常</title>
      <link href="/2020/07/17/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%8D%95%E8%8E%B7%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/07/17/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%8D%95%E8%8E%B7%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>  通过对线程调用setUncaughtExceptionHandler，对处理器实现Thread.UncaughtExceptionHandler的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class test extends Thread&#123;</span><br><span class="line">    public static class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">        public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;MyUncaughtExceptionHandler do something...&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;errorMsg:&quot; + e.getMessage());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static class ChildTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;  Thread.currentThread().setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;do something&quot;);</span><br><span class="line"></span><br><span class="line">            throw new RuntimeException(&quot;ChildTask异常&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Thread t&#x3D; new Thread(new ChildTask());</span><br><span class="line">            t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</span><br><span class="line">            t.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>守护线程与非守护线程</title>
      <link href="/2020/07/17/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/07/17/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程中会同时存在二种线程：也就是守护线程和非守护线程，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。</p><p>将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。但是必须在thread.start()之前设置</p><h2 id="Main线程结束，其他线程一样可以正常运行。"><a href="#Main线程结束，其他线程一样可以正常运行。" class="headerlink" title="Main线程结束，其他线程一样可以正常运行。"></a>Main线程结束，其他线程一样可以正常运行。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class ParentTest</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;parent thread begin &quot;);</span><br><span class="line">        </span><br><span class="line">        ChildThread t1 &#x3D; new ChildThread(&quot;thread1&quot;);</span><br><span class="line">        ChildThread t2 &#x3D; new ChildThread(&quot;thread2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;parent thread over &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class ChildThread extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    private String name &#x3D; null;</span><br><span class="line"> </span><br><span class="line">    public ChildThread(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(this.name + &quot;--child thead begin&quot;);</span><br><span class="line"> </span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(this.name + &quot;--child thead over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">--程序运行结果如下:</span><br><span class="line">parent thread begin </span><br><span class="line">parent thread over </span><br><span class="line">thread2--child thead begin</span><br><span class="line">thread1--child thead begin</span><br><span class="line">thread2--child thead over</span><br><span class="line">thread1--child thead over</span><br></pre></td></tr></table></figure><h2 id="Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程"><a href="#Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程" class="headerlink" title="Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程"></a>Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class ParentTest</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;parent thread begin &quot;);</span><br><span class="line">        </span><br><span class="line">        ChildThread t1 &#x3D; new ChildThread(&quot;thread1&quot;);</span><br><span class="line">        ChildThread t2 &#x3D; new ChildThread(&quot;thread2&quot;);</span><br><span class="line">        t1.setDaemon(true);</span><br><span class="line">        t2.setDaemon(true);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;parent thread over &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ChildThread extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    private String name &#x3D; null;</span><br><span class="line">    public ChildThread(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(this.name + &quot;--child thead begin&quot;);</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this.name + &quot;--child thead over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> 执行结果如下：</span><br><span class="line">parent thread begin</span><br><span class="line">parent thread over</span><br><span class="line">thread1--child thead begin</span><br><span class="line">thread2--child thead begin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java中如何正常终止线程</title>
      <link href="/2020/07/17/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E6%AD%A3%E5%B8%B8%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/07/17/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E6%AD%A3%E5%B8%B8%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="使用退出标志"><a href="#使用退出标志" class="headerlink" title="使用退出标志"></a>使用退出标志</h2><p>使线程正常退出，也就是当 run() 方法完成后线程中止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class test extends Thread&#123;</span><br><span class="line">    public volatile boolean state &#x3D; false;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(!state)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;state的值：&quot;+state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test t&#x3D;new test();</span><br><span class="line">        t.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.state&#x3D;true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;state的值：false</span><br><span class="line">&#x2F;&#x2F;state的值：true</span><br></pre></td></tr></table></figure><h2 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt()"></a>Interrupt()</h2><p>interrupt() 方法并不像在 for 循环语句中使用 break 语句那样干脆，马上就停止循环。调用 interrupt() 方法仅仅是在当前线程中打一个停止的标记，并不是真的停止线程。</p><p>也就是说，线程中断并不会立即终止线程，而是通知目标线程，有人希望你终止。至于目标线程收到通知后会如何处理，则完全由目标线程自行决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class test extends Thread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            test t &#x3D; new test();</span><br><span class="line">            t.start();</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;super.run();</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; 2000; i++) &#123;</span><br><span class="line">            System.out.println(&quot;i&#x3D;&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确使用</p><p>Thread.currentThread().isInterrupted()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class test extends Thread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            test t &#x3D; new test();</span><br><span class="line">            t.start();</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;super.run();</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; 2000; i++) &#123;</span><br><span class="line">            if(Thread.currentThread().isInterrupted())</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;i&#x3D;&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-stop-终止线程"><a href="#使用-stop-终止线程" class="headerlink" title="使用 stop() 终止线程"></a>使用 stop() 终止线程</h2><p>为什么弃用stop：</p><ol><li>调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。</li><li>调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序列化和反序列化</title>
      <link href="/2020/07/16/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/07/16/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>[TOC]<br>当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。</p><p>好处:</p><p>一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SerialDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        &#x2F;&#x2F;序列化</span><br><span class="line">        FileOutputStream fos &#x3D; new FileOutputStream(&quot;object.out&quot;);</span><br><span class="line">        ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);</span><br><span class="line">        User user1 &#x3D; new User(&quot;xuliugen&quot;, &quot;123456&quot;, &quot;male&quot;);</span><br><span class="line">        oos.writeObject(user1);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">        &#x2F;&#x2F;反序列化</span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(&quot;object.out&quot;);</span><br><span class="line">        ObjectInputStream ois &#x3D; new ObjectInputStream(fis);</span><br><span class="line">        User user2 &#x3D; (User) ois.readObject();</span><br><span class="line">        System.out.println(user2.getUserName()+ &quot; &quot; + </span><br><span class="line">            user2.getPassword() + &quot; &quot; + user2.getSex());</span><br><span class="line">        &#x2F;&#x2F;反序列化的输出结果为：xuliugen 123456 male</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private String userName;</span><br><span class="line">    private String password;</span><br><span class="line">    private String sex;</span><br><span class="line">    &#x2F;&#x2F;全参构造方法、get和set方法省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/5/4/16a82df8ad1e3584?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/5/4/16a82df8ad0910e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CyclicBarrier剖析</title>
      <link href="/2020/07/16/CyclicBarrier%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/16/CyclicBarrier%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。<br>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，<br>直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierExample &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">        final int totalThread &#x3D; 10;</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; totalThread; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">        System.out.print(&quot;before..&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;after..&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before..before..before..before..before..before..before..before..before..before..after..after</span><br><span class="line">..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>JDK 的思路就是：首先，每个 CyclicBarrier 都有一个 Lock，想执行 await 方法，就必须获得这把锁.设置一个计数器，线程每调用一次计数器，就减一，并使用  Condition 阻塞线程。当计数器是0的时候，就唤醒所有线程，并尝试执行构造函数中的任务。由于 CyclicBarrier 是可重复执行的，所以，就需要重置计数器。</p><p>CyclicBarrier 还有一个重要的点，就是 generation 的概念，由于每一个线程可以使用多个 CyclicBarrier，每个 CyclicBarrier 又都可以唤醒线程，那么就需要用代来控制，如果代不匹配，就需要重新休眠。有一个 “代” 的概念，因为 CyclicBarrier 是可以复用的，那么每次所有的线程通过了栅栏，就表示一代过去了.</p><p>而他和 CountDownLatch 的区别在于，CountDownLatch 只能使用一次就 over 了，CyclicBarrier 能使用多次，可以说功能类似，CyclicBarrier 更强大一点。并且 CyclicBarrier 携带了一个在栅栏处可以执行的任务。更加灵活。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch剖析</title>
      <link href="/2020/07/16/CountDownLatch%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/16/CountDownLatch%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>用来控制一个线程等待多个线程。<br>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方<br>法而在等待的线程就会被唤醒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">       final int totalThread &#x3D; 10;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(&quot;run..&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看看这个类的结构：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/16317a37eda063fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p><p>该类是一个独立的类，没有继承别的类，有一个内部类 Sync，这个类继承了 AQS 抽象类，其实，在之前的文章中，我们说过，AQS 是 JUC 所有锁的实现，定义了锁的基本操作。这个内部类重写了 tryAcquireShared 方法和 tryReleaseShared 方法。</p><p>然后呢？我们看看构造方法。</p><h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;</span><br><span class="line">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">    this.sync &#x3D; new Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部实现还是继承了 AQS 的 Sync 类。</p><p>Sync 构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sync(int count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br><span class="line">protected final void setState(int newState) &#123;</span><br><span class="line">    state &#x3D; newState;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * The synchronization state.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><p>设置了这个 State 变量，我们之前分析过 AQS 的源码，这个变量可以说是 AQS 实现的核心，通过控制这个变量，能够实现共享共享锁或者独占锁。</p><p>那么，如果让我们来设计这个CountDownLatch ，我们该如何设计呢？</p><p>事实上，很简单，我们只需要对 state 变量进行减 1 操作，直到这个变量变成 0，我们就唤醒主线程。</p><p>不知道 Doug Lea 是不是这么设计的？我们去看看。</p><h3 id="await-方法"><a href="#await-方法" class="headerlink" title="await 方法"></a>await 方法</h3><p>主线程会调用这个方法，让自己阻塞，直到被唤醒。</p><p>看看这个方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">       sync.acquireSharedInterruptibly(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">           throws InterruptedException &#123;</span><br><span class="line">       if (Thread.interrupted())</span><br><span class="line">           throw new InterruptedException();</span><br><span class="line">       if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">           doAcquireSharedInterruptibly(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>await 方法调用的是 Syn的  acquireSharedInterruptibly 方法，如果返回值不是大于等于 0 ，说明当前线程不能获取锁，那么就调用 doAcquireSharedInterruptibly 方法。这个方法内部会将当前线程挂起，直到 state 变成 0，才会被唤醒。</p><p>而 <strong>tryAcquireShared</strong> 方法是需要子类自己实现的。我们看看 CountDown 是如何实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return (getState() &#x3D;&#x3D; 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>很简单，就是获取 state 变量，也就是构造方法中设置的参数。</p><p> doAcquireSharedInterruptibly方法的是如何将当前线程挂起的呢？</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个 node 对象，对象中有个属性就是当前线程对象。并将这个 node 添加进队列尾部。</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    &#x2F;&#x2F; 中断失败标记</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到这个 node 的上一个节点</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F; 如果上一个节点是 head，说明他前面已经没有线程阻挡他获取锁了。</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                &#x2F;&#x2F; 获取锁的状态</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                &#x2F;&#x2F; 如果大于等于0，说明可以获取锁</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 将包装当前线程的 node 设置为 head.</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    &#x2F;&#x2F; 设置他的 next 是 null，让 GC 回收</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    &#x2F;&#x2F; 没有发生错误，不必执行下面的取消操作</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果他的前面的节点的状态时 -1，那么当前线程就需要等待。</span><br><span class="line">            &#x2F;&#x2F; 调用 parkAndCheckInterrupt 等待，如果等待过程中被中断了，抛出异常</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)  </span><br><span class="line">            &#x2F;&#x2F; 如果发生了中断异常，则取消获取锁。</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的代码写了很多注释，总的来说，逻辑如下：</p><ol><li>将当前线程包装成一个 Node 对象，加入到 AQS 的队列尾部。</li><li>如果他前面的 node 是 head ，便可以尝试获取锁了。</li><li>如果不是，则阻塞等待，调用的是 LockSupport.park(this);</li></ol><p><strong>CountDown 的 await 方法就是通过 AQS 的锁机制让主线程阻塞等待。而锁的实现就是通过构造器中设置的 state 变量来控制的。当 state 是 0 的时候，就可以获取锁。然后执行后面的逻辑。</strong></p><p>知道了 await 方法，CountDown 方法应该能猜个大概了。</p><h3 id="countDown-方法"><a href="#countDown-方法" class="headerlink" title="countDown 方法"></a>countDown 方法</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>调用了  AQS 需要子类实现 tryReleaseShared 方法。看看 CountDownLatch 是怎么实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F; Decrement count; signal when transition to zero</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line">        if (c &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc &#x3D; c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>该方法很简单，就是将 state 变量减 1，只要减过之后， state 不是 0，就返回 fasle。</strong></p><p>回到 releaseShared 方法中，当 tryReleaseShared 返回值是 true 时，也就是 state 是 0，就需要执行 doReleaseShared 方法 ，唤醒阻塞在 CountDown 上的线程了。</p><p>唤醒代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">            int ws &#x3D; h.waitStatus;</span><br><span class="line">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>只要队列中 head 节点不是 null，且和 tail 不相等，并且状态是 -1，使用 CAS 将状态修改成 0，如果成功，唤醒当前线程。当前线程就会在 doAcquireSharedInterruptibly 方法中苏醒，再次尝试获取锁，只要他的上一个节点是 head，也就是没有人和他争抢锁，并且 state 是 0，就能够成功获取到锁，继续执行下面的逻辑，不再继续阻塞。</p><p>而我们 CountDownLatch 的主线程也就可以被唤醒从而继续执行了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，CountDownLatch 还是比较简单的。说白了就是通过共享锁实现的。在我们的代码中，只有一个线程会阻塞，那就是我们的主线程， 其余的线程就是在不停的释放 state 变量，直到为 0。从 AQS 的角度来讲，整个工作流程如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/16317a37edbaecf8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p><p>简单的一个流程图，CountDownLatch 就是通过使用 AQS 的机制来实现<code>倒计时门栓</code>的。</p><p>作者：莫那·鲁道<br>链接：<a href="https://juejin.im/post/5ae754dd6fb9a07abc29b2ce" target="_blank" rel="noopener">https://juejin.im/post/5ae754dd6fb9a07abc29b2ce</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>String、StringBuffer、StringBuilder</title>
      <link href="/2020/07/14/String%E3%80%81StringBuffer%E3%80%81StringBuilder/"/>
      <url>/2020/07/14/String%E3%80%81StringBuffer%E3%80%81StringBuilder/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>String 被声明为 final，因此它不可被继承。<br>在 Java 8 中，String 内部使用 char 数组存储数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">&#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">private final char value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">&#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">private final byte[] value;</span><br><span class="line">&#x2F;** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. *&#x2F;</span><br><span class="line">private final byte coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value<br>数组的方法，因此可以保证 String 不可变。</p><h2 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h2><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法<br>进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回<br>这个新字符串的引用。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PriorityQueue源码剖析</title>
      <link href="/2020/07/13/PriorityQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/PriorityQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>Java的集合框架，PriorityQueue源码解析等…</strong></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面以Java <em>ArrayDeque</em>为例讲解了<em>Stack</em>和<em>Queue</em>，其实还有一种特殊的队列叫做<em>PriorityQueue</em>，即优先队列。<strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（*natural ordering*），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于C++的仿函数）。</p><p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p><a href="https://camo.githubusercontent.com/ac0678ef35b8a6cbfca531e2ca645ff2a50e9baf/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f626173652e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ac0678ef35b8a6cbfca531e2ca645ff2a50e9baf/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f626173652e706e67" alt="PriorityQueue"></a></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leftNo &#x3D; parentNo*2+1</span><br><span class="line">rightNo &#x3D; parentNo*2+2</span><br><span class="line">parentNo &#x3D; (nodeNo-1)&#x2F;2</span><br></pre></td></tr></table></figure><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em>。</p><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h3><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><p><a href="https://camo.githubusercontent.com/e7333c5724af6ee4e4fdff70862f9a31a906e361/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f6f666665722e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/e7333c5724af6ee4e4fdff70862f9a31a906e361/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f6f666665722e706e67" alt="add"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;offer(E e)</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e &#x3D;&#x3D; null)&#x2F;&#x2F;不允许放入null元素</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    int i &#x3D; size;</span><br><span class="line">    if (i &gt;&#x3D; queue.length)</span><br><span class="line">        grow(i + 1);&#x2F;&#x2F;自动扩容</span><br><span class="line">    size &#x3D; i + 1;</span><br><span class="line">    if (i &#x3D;&#x3D; 0)&#x2F;&#x2F;队列原来为空，这是插入的第一个元素</span><br><span class="line">        queue[0] &#x3D; e;</span><br><span class="line">    else</span><br><span class="line">        siftUp(i, e);&#x2F;&#x2F;调整</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;siftUp()</span><br><span class="line">private void siftUp(int k, E x) &#123;</span><br><span class="line">    while (k &gt; 0) &#123;</span><br><span class="line">        int parent &#x3D; (k - 1) &gt;&gt;&gt; 1;&#x2F;&#x2F;parentNo &#x3D; (nodeNo-1)&#x2F;2</span><br><span class="line">        Object e &#x3D; queue[parent];</span><br><span class="line">        if (comparator.compare(x, (E) e) &gt;&#x3D; 0)&#x2F;&#x2F;调用比较器的比较方法</span><br><span class="line">            break;</span><br><span class="line">        queue[k] &#x3D; e;</span><br><span class="line">        k &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] &#x3D; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h3 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h3><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong>。</p><p><a href="https://camo.githubusercontent.com/bd7715e17d75c967a49a0df6cc399e544a8cc80c/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f7065656b2e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/bd7715e17d75c967a49a0df6cc399e544a8cc80c/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f7065656b2e706e67" alt="peek"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;peek()</span><br><span class="line">public E peek() &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0)</span><br><span class="line">        return null;</span><br><span class="line">    return (E) queue[0];&#x2F;&#x2F;0下标处的那个元素就是最小的那个</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h3><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><a href="https://camo.githubusercontent.com/dbe221333180c2a9693d46afd4b79cc485569f30/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f706f6c6c2e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/dbe221333180c2a9693d46afd4b79cc485569f30/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f706f6c6c2e706e67" alt="poll"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0)</span><br><span class="line">        return null;</span><br><span class="line">    int s &#x3D; --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result &#x3D; (E) queue[0];&#x2F;&#x2F;0下标处的那个元素就是最小的那个</span><br><span class="line">    E x &#x3D; (E) queue[s];</span><br><span class="line">    queue[s] &#x3D; null;</span><br><span class="line">    if (s !&#x3D; 0)</span><br><span class="line">        siftDown(0, x);&#x2F;&#x2F;调整</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素（也就是最小的那个元素）。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;siftDown()</span><br><span class="line">private void siftDown(int k, E x) &#123;</span><br><span class="line">    int half &#x3D; size &gt;&gt;&gt; 1;</span><br><span class="line">    while (k &lt; half) &#123;</span><br><span class="line">    &#x2F;&#x2F;首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span><br><span class="line">        int child &#x3D; (k &lt;&lt; 1) + 1;&#x2F;&#x2F;leftNo &#x3D; parentNo*2+1</span><br><span class="line">        Object c &#x3D; queue[child];</span><br><span class="line">        int right &#x3D; child + 1;</span><br><span class="line">        if (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">            c &#x3D; queue[child &#x3D; right];</span><br><span class="line">        if (comparator.compare(x, (E) c) &lt;&#x3D; 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] &#x3D; c;&#x2F;&#x2F;然后用c取代原来的值</span><br><span class="line">        k &#x3D; child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] &#x3D; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</p><p><a href="https://camo.githubusercontent.com/6511a83152577db51c77d1448facc75da6fd2a17/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f72656d6f7665322e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6511a83152577db51c77d1448facc75da6fd2a17/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f72656d6f7665322e706e67" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;remove(Object o)</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">&#x2F;&#x2F;通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span><br><span class="line">    int i &#x3D; indexOf(o);</span><br><span class="line">    if (i &#x3D;&#x3D; -1)</span><br><span class="line">        return false;</span><br><span class="line">    int s &#x3D; --size;</span><br><span class="line">    if (s &#x3D;&#x3D; i) &#x2F;&#x2F;情况1</span><br><span class="line">        queue[i] &#x3D; null;</span><br><span class="line">    else &#123;</span><br><span class="line">        E moved &#x3D; (E) queue[s];</span><br><span class="line">        queue[s] &#x3D; null;</span><br><span class="line">        siftDown(i, moved);&#x2F;&#x2F;情况2</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stack&amp;Queue源码剖析</title>
      <link href="/2020/07/13/Stack-Queue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/Stack-Queue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Stack-amp-Queue概述"><a href="#Stack-amp-Queue概述" class="headerlink" title="Stack &amp; Queue概述"></a>Stack &amp; Queue概述</h2><p>Java里有一个叫做<em>Stack</em>的类，却没有叫做<em>Queue</em>的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>；既然<em>Queue</em>只是一个接口，当需要使用队列时也就首选<em>ArrayDeque</em>了（次选是<em>LinkedList</em>）。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><em>Queue<em>接口继承自Collection接口，除了最基本的Collection的方法之外，它还支持额外的</em>insertion</em>, <em>extraction</em>和<em>inspection</em>操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现（没有则返回null）。</p><table><thead><tr><th></th><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td><td>offer(e)</td></tr><tr><td>Remove</td><td>remove()</td><td>poll()</td></tr><tr><td>Examine</td><td>element()</td><td>peek()</td></tr></tbody></table><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><code>Deque</code>是”double ended queue”, 表示双向的队列，英文读作”deck”. Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现（没有则返回null）。</p><p><em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<em>Deque</em>与<em>Queue</em>相对应的接口：</p><p>当把<code>Deque</code>当做FIFO的<code>queue</code>来使用时，元素是从<code>deque</code>的尾部添加，从头部进行删除的； 所以<code>deque</code>的部分方法是和<code>queue</code>是等同的。具体如下：</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>add(e)</code></td><td><code>addLast(e)</code></td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td><code>offer(e)</code></td><td><code>offerLast(e)</code></td><td>向队尾插入元素，失败则返回<code>false</code></td></tr><tr><td><code>remove()</code></td><td><code>removeFirst()</code></td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td><code>poll()</code></td><td><code>pollFirst()</code></td><td>获取并删除队首元素，失败则返回<code>null</code></td></tr><tr><td><code>element()</code></td><td><code>getFirst()</code></td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除队首元素，失败则返回<code>null</code></td></tr></tbody></table><p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>push(e)</code></td><td><code>addFirst(e)</code></td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>offerFirst(e)</code></td><td>向栈顶插入元素，失败则返回<code>false</code></td></tr><tr><td><code>pop()</code></td><td><code>removeFirst()</code></td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>pollFirst()</code></td><td>获取并删除栈顶元素，失败则返回<code>null</code></td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则返回<code>null</code></td></tr></tbody></table><p><em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现。</p><p>由于官方更推荐使用<em>AarryDeque</em>用作栈和队列。从名字可以看出<em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p><p><a href="https://camo.githubusercontent.com/fd346bba6c6485031d222ba6c3b16c592846e0c4/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f626173652e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/fd346bba6c6485031d222ba6c3b16c592846e0c4/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f626173652e706e67" alt="ArrayDeque"></a></p><p>上图中我们看到，<strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以<code>head</code>不一定总等于0，<code>tail</code>也不一定总是比<code>head</code>大。</p><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h3><p><code>addFirst(E e)</code>的作用是在<em>Deque</em>的首端插入元素，也就是在<code>head</code>的前面插入元素，在空间足够且下标没有越界的情况下，只需要将<code>elements[--head] = e</code>即可。</p><p><a href="https://camo.githubusercontent.com/04f331e67b3d429fe7d1570885e6ac32b8a0ba70/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f61646446697273742e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/04f331e67b3d429fe7d1570885e6ac32b8a0ba70/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f61646446697273742e706e67" alt="addFirst"></a></p><p>实际需要考虑：1.空间是否够用，以及2.下标是否越界的问题。上图中，如果<code>head</code>为<code>0</code>之后接着调用<code>addFirst()</code>，虽然空余空间还够用，但<code>head</code>为<code>-1</code>，下标越界了。下列代码很好的解决了这两个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;addFirst(E e)</span><br><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    if (e &#x3D;&#x3D; null)&#x2F;&#x2F;不允许放入null</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[head &#x3D; (head - 1) &amp; (elements.length - 1)] &#x3D; e;&#x2F;&#x2F;2.下标是否越界</span><br><span class="line">    if (head &#x3D;&#x3D; tail)&#x2F;&#x2F;1.空间是否够用</span><br><span class="line">        doubleCapacity();&#x2F;&#x2F;扩容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，<code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。因为<code>elements.length</code>必需是<code>2</code>的指数倍，<code>elements - 1</code>就是二进制低位全<code>1</code>，跟<code>head - 1</code>相与之后就起到了取模的作用，如果<code>head - 1</code>为负数（其实只可能是-1），则相当于对其取相对于<code>elements.length</code>的补码。</p><p>下面再说说扩容函数<code>doubleCapacity()</code>，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：</p><p><a href="https://camo.githubusercontent.com/1d720a181a6ca38a00d311025d96a3daf776b176/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f646f75626c6543617061636974792e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1d720a181a6ca38a00d311025d96a3daf776b176/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f646f75626c6543617061636974792e706e67" alt="doubleCapacity"></a></p><p>图中我们看到，复制分两次进行，第一次复制<code>head</code>右边的元素，第二次复制<code>head</code>左边的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;doubleCapacity()</span><br><span class="line">private void doubleCapacity() &#123;</span><br><span class="line">    assert head &#x3D;&#x3D; tail;</span><br><span class="line">    int p &#x3D; head;</span><br><span class="line">    int n &#x3D; elements.length;</span><br><span class="line">    int r &#x3D; n - p; &#x2F;&#x2F; head右边元素的个数</span><br><span class="line">    int newCapacity &#x3D; n &lt;&lt; 1;&#x2F;&#x2F;原空间的2倍</span><br><span class="line">    if (newCapacity &lt; 0)</span><br><span class="line">        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span><br><span class="line">    Object[] a &#x3D; new Object[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, 0, r);&#x2F;&#x2F;复制右半部分，对应上图中绿色部分</span><br><span class="line">    System.arraycopy(elements, 0, a, r, p);&#x2F;&#x2F;复制左半部分，对应上图中灰色部分</span><br><span class="line">    elements &#x3D; (E[])a;</span><br><span class="line">    head &#x3D; 0;</span><br><span class="line">    tail &#x3D; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h3><p><code>addLast(E e)</code>的作用是在<em>Deque</em>的尾端插入元素，也就是在<code>tail</code>的位置插入元素，由于<code>tail</code>总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用<code>doubleCapacity()</code>进行扩容。</p><p><a href="https://camo.githubusercontent.com/d70399fc026fabaebd445cf59a6e4d5bd1024e76/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f6164644c6173742e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d70399fc026fabaebd445cf59a6e4d5bd1024e76/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f6164644c6173742e706e67" alt="addLast"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    if (e &#x3D;&#x3D; null)&#x2F;&#x2F;不允许放入null</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[tail] &#x3D; e;&#x2F;&#x2F;赋值</span><br><span class="line">    if ( (tail &#x3D; (tail + 1) &amp; (elements.length - 1)) &#x3D;&#x3D; head)&#x2F;&#x2F;下标越界处理</span><br><span class="line">        doubleCapacity();&#x2F;&#x2F;扩容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a>pollFirst()</h3><p><code>pollFirst()</code>的作用是删除并返回<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于<code>ArrayDeque</code>中不允许放入<code>null</code>，当<code>elements[head] == null</code>时，意味着容器为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public E pollFirst() &#123;</span><br><span class="line">    E result &#x3D; elements[head];</span><br><span class="line">    if (result &#x3D;&#x3D; null)&#x2F;&#x2F;null值意味着deque为空</span><br><span class="line">        return null;</span><br><span class="line">    elements[h] &#x3D; null;&#x2F;&#x2F;let GC work</span><br><span class="line">    head &#x3D; (head + 1) &amp; (elements.length - 1);&#x2F;&#x2F;下标越界处理</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast()"></a>pollLast()</h3><p><code>pollLast()</code>的作用是删除并返回<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public E pollLast() &#123;</span><br><span class="line">    int t &#x3D; (tail - 1) &amp; (elements.length - 1);&#x2F;&#x2F;tail的上一个位置是最后一个元素</span><br><span class="line">    E result &#x3D; elements[t];</span><br><span class="line">    if (result &#x3D;&#x3D; null)&#x2F;&#x2F;null值意味着deque为空</span><br><span class="line">        return null;</span><br><span class="line">    elements[t] &#x3D; null;&#x2F;&#x2F;let GC work</span><br><span class="line">    tail &#x3D; t;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="peekFirst"><a href="#peekFirst" class="headerlink" title="peekFirst()"></a>peekFirst()</h3><p><code>peekFirst()</code>的作用是返回但不删除<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素，直接返回<code>elements[head]</code>即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E peekFirst() &#123;</span><br><span class="line">    return elements[head]; &#x2F;&#x2F; elements[head] is null if deque empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="peekLast"><a href="#peekLast" class="headerlink" title="peekLast()"></a>peekLast()</h3><p><code>peekLast()</code>的作用是返回但不删除<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E peekLast() &#123;</span><br><span class="line">    return elements[(tail - 1) &amp; (elements.length - 1)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap-ConcurrentHashMap面试必问</title>
      <link href="/2020/07/13/HashMap-ConcurrentHashMap%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE/"/>
      <url>/2020/07/13/HashMap-ConcurrentHashMap%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>众所周知，HashMap的底层结构是<strong>数组和链表</strong>组成的，不过在jdk1.7和jdk1.8中具体实现略有不同。</p><h3 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><p>先看图<a href="https://camo.githubusercontent.com/51e51a0e34f51ceda409cac151e34156169e3d53/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432626537373935382e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/51e51a0e34f51ceda409cac151e34156169e3d53/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432626537373935382e6a7067" alt="img"></a></p><p>再看看1.7的实现<a href="https://camo.githubusercontent.com/d113e661f95ade8a9c24b0f347c8cb4fdc2417f6/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432626664366162612e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d113e661f95ade8a9c24b0f347c8cb4fdc2417f6/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432626664366162612e6a7067" alt="img"></a></p><p>介绍成员变量：</p><ul><li>初始化桶大小，因为底层是数组，所以这是数组默认的大小。</li><li>桶最大值。</li><li>默认的负载因子（0.75）</li><li>table真正存放数据的数组。</li><li>map存放数量的大小</li><li>桶大小，可在构造函数时显式指定。</li><li>负载因子，可在构造函数时显式指定。</li></ul><h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public HashMap() &#123;</span><br><span class="line">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); &#x2F;&#x2F; 桶和负载因子</span><br><span class="line">&#125;</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    threshold &#x3D; initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给定的默认容量为16，负载因子为0.75.</li><li>Map在使用过程中不断的往里面存放数据，当数量达到了<code>16 * 0.75 = 12</code>就需要将当前16的容量进行扩容，而扩容这个过程涉及到rehash（重新哈希）、复制数据等操作，所有非常消耗性能。</li><li>因此通常建议能提前预估HashMap的大小最好，尽量的减少扩容带来的额外性能损耗。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Ideally, under random hashCodes, the frequency of</span><br><span class="line"></span><br><span class="line">nodes in bins follows a Poisson distribution</span><br><span class="line">(http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Poisson_distribution) with a</span><br><span class="line">parameter of about 0.5 on average for the default resizing</span><br><span class="line">threshold of 0.75, although with a large variance because of</span><br><span class="line">resizing granularity. Ignoring variance, the expected</span><br><span class="line">occurrences of list size k are (exp(-0.5) * pow(0.5, k) &#x2F;</span><br><span class="line">factorial(k)). The first values are:</span><br><span class="line">0: 0.60653066</span><br><span class="line">1: 0.30326533</span><br><span class="line">2: 0.07581633</span><br><span class="line">3: 0.01263606</span><br><span class="line">4: 0.00157952</span><br><span class="line">5: 0.00015795</span><br><span class="line">6: 0.00001316</span><br><span class="line">7: 0.00000094</span><br><span class="line">8: 0.00000006</span><br><span class="line">more: less than 1 in ten million</span><br><span class="line">注意wiki链接中的关键字：Poisson_distribution</span><br><span class="line">泊淞分布啊</span><br></pre></td></tr></table></figure><p>简单翻译一下就是在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布，同时给出了桶中元素个数和概率的对照表。</p><p>从上面的表中可以看到当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</p><p>好了，再深挖就要挖到统计学那边去了，就此打住，重申一下使用hash容器请尽量指定初始容量，且是2的幂次方。</p><p>关于泊淞分布的知识请看</p><p><a href="http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html#comment-356111" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html#comment-356111</a></p><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Entry&lt;K,V&gt;[] table &#x3D; (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p>如何定义呢？<a href="https://camo.githubusercontent.com/d4896d60a3183274a1e559b0a66a29ffedfb7a44/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633038653639332e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d4896d60a3183274a1e559b0a66a29ffedfb7a44/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633038653639332e6a7067" alt="img"></a></p><p>Entry是Hashmap中的一个内部类，从他的成员变量很容易看出：</p><ul><li>key就是写入时的键</li><li>value自然就是值</li><li>开始的时候就提到HashMap是由数组和链表组成，所以这个next就是用于实现链表结构</li><li>hash存放的是当前key的hashcode</li></ul><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold); &#x2F;&#x2F; 判断数组是否需要初始化</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return putForNullKey(value); &#x2F;&#x2F; 判断key是否为空</span><br><span class="line">    int hash &#x3D; hash(key); &#x2F;&#x2F; 计算hashcode</span><br><span class="line">    int i &#x3D; indexFor(hash, table.length); &#x2F;&#x2F; 计算桶</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123; &#x2F;&#x2F; 遍历判断链表中的key和hashcode是否相等，等就替换</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i); &#x2F;&#x2F; 没有就添加新的呗</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前数组是否需要初始化</li><li>如果key为空，则put一个空值进去</li><li>根据key计算hashcode</li><li>根据计算的hashcode定位index的桶</li><li>如果桶是一个链表，则需要遍历判断里面的hashcode、key是否和传入的key相等，如果相等则进行覆盖，并返回原来的值</li><li>如果桶是空的，说明当前位置没有数据存入，此时新增一个Entry对象写入当前位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;&#x2F;&#x2F; 是否扩容</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;</span><br><span class="line">        bucketIndex &#x3D; indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];</span><br><span class="line">    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当调用addEntry写入Entry时需要判断是否需要扩容</li><li>如果需要就进行两倍扩充，并将当前的key重新hash并定位。</li><li>而在createEntry中会将当前位置的桶传入到新建的桶中，如果当前桶油值就会在位置形成链表。</li></ul><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null) &#x2F;&#x2F; 判断key是否为空</span><br><span class="line">        return getForNullKey(); &#x2F;&#x2F; 为空，就返回空值</span><br><span class="line">    Entry&lt;K,V&gt; entry &#x3D; getEntry(key); &#x2F;&#x2F; get entry</span><br><span class="line">    return null &#x3D;&#x3D; entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key); &#x2F;&#x2F;根据key和hashcode</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];</span><br><span class="line">         e !&#x3D; null;</span><br><span class="line">         e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先根据key计算hashcode，然后定位具体的桶</li><li>判断该位置是否为链表</li><li>不是链接就根据key和hashcode是否相等来返回值</li><li>为链表则需要遍历直到key和hashcode相等就返回值</li><li>啥都没得，就返回null</li></ul><h3 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p>不知道 1.7 的实现大家看出需要优化的点没有？</p><p>其实一个很明显的地方就是链表</p><p><strong>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。</strong></p><p><a href="https://camo.githubusercontent.com/1bd19ba02d0aa93cf7d6c947c0672cafe7e478fd/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633163316364372e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1bd19ba02d0aa93cf7d6c947c0672cafe7e478fd/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633163316364372e6a7067" alt="img"></a></p><p>看看成员变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line">&#x2F;**</span><br><span class="line"> * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line"> * by either of the constructors with arguments.</span><br><span class="line"> * MUST be a power of two &lt;&#x3D; 1&lt;&lt;30.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * The load factor used when none specified in constructor.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Holds cached entrySet(). Note that AbstractMap fields are used</span><br><span class="line"> * for keySet() and values().</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * The number of key-value mappings contained in this map.</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient int size;</span><br></pre></td></tr></table></figure><ul><li><code>TREEIFY_THRESHOLD</code> 用于判断是否需要将链表转换为红黑树的阈值。</li><li>HashEntry 修改为 Node。</li><li>Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 <code>key value hashcode next</code> 等数据。</li></ul><h4 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h4><p><a href="https://camo.githubusercontent.com/068bac3f602c768691b1def1d91a114c457dac95/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633337383039302e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/068bac3f602c768691b1def1d91a114c457dac95/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633337383039302e6a7067" alt="img"></a></p><ul><li>判断当前桶是否为空，空的就需要初始化（resize中会判断是否进行初始化）</li><li>根据当前key的hashcode定位到具体的桶中并判断是否为空，为空则表明没有Hash冲突，就直接在当前位置创建一个新桶</li><li>如果当前桶油值（Hash冲突），那么就要比较当前桶中的key、key的hashcode与写入的key是否相等，相等就赋值给e，在第8步的时候会统一进行赋值及返回</li><li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据</li><li>如果是个链表，就需要将当前的key、value封装称一个新节点写入到当前桶的后面形成链表。</li><li>接着判断当前链表的大小是否大于预设的阈值，大于就要转换成为红黑树</li><li>如果在遍历过程中找到key相同时直接退出遍历。</li><li>如果<code>e != null</code>就相当于存在相同的key，那就需要将值覆盖。</li><li>最后判断是否需要进行扩容。</li></ul><h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先将key hash之后取得所定位的桶</li><li>如果桶为空，则直接返回null</li><li>否则判断桶的第一个位置（有可能是链表、红黑树）的key是否为查询的key，是就直接返回value</li><li>如果第一个不匹配，则判断它的下一个是红黑树还是链表</li><li>红黑树就按照树的查找方式返回值</li><li>不然就按照链表的方式遍历匹配返回值</li></ul><p><strong>从这两个核心方法（get/put）可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 <code>O(logn)</code>。</strong></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            map.put(UUID.randomUUID().toString(), &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>HashMap扩容的时候会调用resize()方法，就是这里的并发操作容易在一个桶上形成环形链表</li><li>这样当获取一个不存在的key时，计算出的index正好是环形链表的下标就会出现死循环。</li><li>但是1.7的头插法造成的问题，1.8改变了插入顺序，就解决了这个问题，但是为了内存可见性等安全性，还是需要ConCurrentHashMap</li></ul><p><a href="https://camo.githubusercontent.com/b7a084415c8a08d4fa15227227a863eb649f994e/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633465646535342e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/b7a084415c8a08d4fa15227227a863eb649f994e/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633465646535342e6a7067" alt="img"></a></p><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><p>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator &#x3D; map.entrySet().iterator();</span><br><span class="line">        while (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next &#x3D; entryIterator.next();</span><br><span class="line">            System.out.println(&quot;key&#x3D;&quot; + next.getKey() + &quot; value&#x3D;&quot; + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator &#x3D; map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String key &#x3D; iterator.next();</span><br><span class="line">            System.out.println(&quot;key&#x3D;&quot; + key + &quot; value&#x3D;&quot; + map.get(key));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>建议使用第一种，同时可以把key value取出。</li><li>第二种还需要通过key取一次key，效率较低。</li></ul><h2 id="ConCurrentHashMap"><a href="#ConCurrentHashMap" class="headerlink" title="ConCurrentHashMap"></a>ConCurrentHashMap</h2><h3 id="jdk1-7-1"><a href="#jdk1-7-1" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><p><a href="https://camo.githubusercontent.com/ecc8e454cddfede7ac97cfd212b0a13682f1b53a/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633563653935632e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ecc8e454cddfede7ac97cfd212b0a13682f1b53a/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633563653935632e6a7067" alt="img"></a></p><ul><li>Segment数组</li><li>HashEntry组成</li><li>和HashMap一样，仍然是数组加链表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span><br><span class="line"> *&#x2F;</span><br><span class="line">final Segment&lt;K,V&gt;[] segments;</span><br><span class="line">transient Set&lt;K&gt; keySet;</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line">       private static final long serialVersionUID &#x3D; 2249069246763182397L;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span><br><span class="line">       transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">       transient int count;</span><br><span class="line">       transient int modCount;</span><br><span class="line">       transient int threshold;</span><br><span class="line">       final float loadFactor;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/a55002a94ff6ed86b32ed1475168147d72e3aacc/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633633356336392e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/a55002a94ff6ed86b32ed1475168147d72e3aacc/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633633356336392e6a7067" alt="img"></a></p><ul><li>唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</li><li>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。</li><li>不会像HashTable那样不管是put还是get操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。</li><li>每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</li></ul><h4 id="put-2"><a href="#put-2" class="headerlink" title="put"></a>put</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    if (value &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck</span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment</span><br><span class="line">        s &#x3D; ensureSegment(j);</span><br><span class="line">    return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过key定位到Segment，之后在对应的Segment中进行具体的put</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">        int index &#x3D; (tab.length - 1) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class="line">            if (e !&#x3D; null) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue &#x3D; e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value &#x3D; value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                e &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (node !&#x3D; null)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                int c &#x3D; count + 1;</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                else</span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count &#x3D; c;</span><br><span class="line">                oldValue &#x3D; null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虽然HashEntry中的value是用volatile关键字修饰的，但是并不能保证并发的原子性，所以put操作仍然需要加锁处理。</li><li>首先第一步的时候会尝试获取锁，如果获取失败肯定就是其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</li></ul><p><a href="https://camo.githubusercontent.com/71f965d21a47f284830a21fac13f956ca08fe757/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636333633938322e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/71f965d21a47f284830a21fac13f956ca08fe757/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636333633938322e6a7067" alt="img"></a></p><ul><li>尝试获取自旋锁</li><li>如果重试的次数达到了<code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li></ul><p><a href="https://camo.githubusercontent.com/95b3b80b9d412127883290166fcd4b612d4b36f1/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636432356333372e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/95b3b80b9d412127883290166fcd4b612d4b36f1/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636432356333372e6a7067" alt="img"></a></p><ul><li>将当前的Segment中的table通过key的hashcode定位到HashEntry</li><li>遍历该HashEntry，如果不为空则判断传入的key和当前遍历的key是否相等，相等则覆盖旧的value</li><li>不为空则需要新建一个HashEntry并加入到Segment中，同时会先判断是否需要扩容</li><li>最后会解除在1中所获取当前Segment的所。</li></ul><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; &#x2F;&#x2F; manually integrate access methods to reduce overhead</span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    int h &#x3D; hash(key);</span><br><span class="line">    long u &#x3D; (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) !&#x3D; null &amp;&amp;</span><br><span class="line">        (tab &#x3D; s.table) !&#x3D; null) &#123;</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; h &amp;&amp; key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</li><li>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</li><li>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</li></ul><h3 id="jdk1-8-1"><a href="#jdk1-8-1" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p><strong>那就是查询遍历链表效率太低。</strong></p><p><a href="https://camo.githubusercontent.com/28bb34f51a46357d1636147c6290b5098592250b/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636533333739352e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/28bb34f51a46357d1636147c6290b5098592250b/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636533333739352e6a7067" alt="img"></a></p><p><strong>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性</strong></p><p><a href="https://camo.githubusercontent.com/683f45273cb02892783747659b250bc58ba66a8d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636565626530322e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/683f45273cb02892783747659b250bc58ba66a8d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636565626530322e6a7067" alt="img"></a></p><ul><li>也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。</li><li>其中的 <code>val next</code> 都用了 volatile 修饰，保证了可见性。</li></ul><h4 id="put-3"><a href="#put-3" class="headerlink" title="put"></a>put</h4><p><a href="https://camo.githubusercontent.com/865ef617cb35cbbb2da99fc73313df2c909b498d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636663333239332e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/865ef617cb35cbbb2da99fc73313df2c909b498d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636663333239332e6a7067" alt="img"></a></p><ul><li>根据key计算出hashcode</li><li>判断是否需要进行初始化</li><li>f即为当前key定位出的Node，如果为空表示当前位置可以写入数据，利用CAS尝试写入，失败则自旋保证成功。</li><li>如果当前位置的<code>hashcode == MOVED == -1</code>，则需要进行扩容</li><li>如果都不满足，则利用synchronized锁写入数据</li><li>如果数量大于<code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ul><h4 id="get-2"><a href="#get-2" class="headerlink" title="get"></a>get</h4><p><a href="https://camo.githubusercontent.com/c7a73630d6aa169d98cae7209f604c12414c9541/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432643232633663622e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/c7a73630d6aa169d98cae7209f604c12414c9541/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432643232633663622e6a7067" alt="img"></a></p><ul><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值。</li></ul><p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code>），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>套路：</p><ul><li>谈谈你理解的 HashMap，讲讲其中的 get put 过程。</li><li>1.8 做了什么优化？</li><li>是线程安全的嘛？</li><li>不安全会导致哪些问题？</li><li>如何解决？有没有线程安全的并发容器？</li><li>ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？<h2 id="源码图"><a href="#源码图" class="headerlink" title="源码图"></a>源码图</h2><img src="https://img-blog.csdnimg.cn/20200713192652430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="img"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TreeMap(Set)源码剖析</title>
      <link href="/2020/07/13/TreeMap-Set-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/TreeMap-Set-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>基于红黑树实现的 TreeMap 提供了平均和最差时间复杂度均为 O(log<del>n</del>) 的增删改查操作，该集合最大的特点就是 Key 的有序性。TreeMap 继承了 SortedMap 和 NavigableMap，SortedMap 表示 Key 是有序不可重复的，支持获取头尾 Key-Value 元素，或者根据 Key 指定范围获取子集合等。插入的 Key 必须实现 Comparable 接口或提供额外的 Comparator 比较器，所以 Key 不允许为 null。NavigableMap 继承了 SortedMap，根据指定的搜索条件返回最匹配的 Key-Value 元素。</p><p>不同于 HashMap 的是 TreeMap 并非一定要重写 hashCode 和 equals 方法来达到 Key 去重的目的。HashMap 是依靠 hashCode 和 equals 来去重的，而 TreeMap 依靠 Comparable 或 Comparator 来实现去重。 TreeMap 对 Key 进行排序时，如果比较器不为空就会优先使用比较器的 compare 方法，如果比较器为空就会使用 Key 实现的自然排序 Comparable 接口的 compareTo 方法，如果两者都不满足就会抛出异常。</p><p>TreeMap 通过 put 和 deleteEntry 实现红黑树增加和删除节点的操作。插入新节点的规则有三个：① 需要调整的新节点总是红色的。② 如果插入新节点的父节点是黑色的，不需要调整。③ 如果插入新节点的父节点是红色的，由于红黑树中不能出现相邻的红色，则进入循环判断，通过重新着色或左右旋转来调整。TreeMap 的插入操作就是按照 Key 的对比往下遍历，大于比较节点值的向右查找，小于的向左查找，先按照二叉查找树的特性操作，无需关心节点颜色与树的平衡，后续会重新着色和旋转，保持红黑树的特性。</p><p>TreeMap 是线程不安全的集合，在多线程操作时需要添加互斥机制，或者把对象放在 Collections.synchronizedMap() 中实现同步。在 JDK 7 之后的 HashMap、TreeSet、ConcurrentHashMap 也都是使用红黑树的方式管理节点。如果只是对单个元素进行排序，使用 TreeSet 即可。TreeSet 的底层就是 TreeMap，Value 共享一个静态的 Object 对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LinkedHashMap(Set)源码剖析</title>
      <link href="/2020/07/13/LinkedHashMap-Set-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/LinkedHashMap-Set-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>Java的集合框架，TreeSet &amp; TreeMap源码解析等…</strong></p><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>概括的说，<code>LinkedHashMap</code> 继承自<code>HashMap</code>，实现了<code>Map&lt;K,V&gt;</code>接口。其内部还维护了一个<strong>双向链表</strong>，在每次<strong>插入数据，或者访问、修改数据</strong>时，<strong>会增加节点、或调整链表的节点顺序</strong>。以决定迭代时输出的顺序。</p><p>默认情况，遍历时的顺序是<strong>按照插入节点的顺序</strong>。这也是其与<code>HashMap</code>最大的区别。<br>也可以在构造时传入<code>accessOrder</code>参数，使得其遍历顺序<strong>按照访问的顺序</strong>输出。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><code>LinkedHashMap</code>的节点<code>Entry&lt;K,V&gt;</code>继承自<code>HashMap.Node&lt;K,V&gt;</code>，在其基础上扩展了一下。改成了一个<strong>双向链表</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时类里有两个成员变量<code>head tail</code>,分别指向内部双向链表的表头、表尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;双向链表的头结点</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;双向链表的尾节点</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h3><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在<br>每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未<br>使用的节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">       LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">       if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">           LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">               (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">           p.after &#x3D; null;</span><br><span class="line">           if (b &#x3D;&#x3D; null)</span><br><span class="line">               head &#x3D; a;</span><br><span class="line">           else</span><br><span class="line">               b.after &#x3D; a;</span><br><span class="line">           if (a !&#x3D; null)</span><br><span class="line">               a.before &#x3D; b;</span><br><span class="line">           else</span><br><span class="line">               last &#x3D; b;</span><br><span class="line">           if (last &#x3D;&#x3D; null)</span><br><span class="line">               head &#x3D; p;</span><br><span class="line">           else &#123;</span><br><span class="line">               p.before &#x3D; last;</span><br><span class="line">               last.after &#x3D; p;</span><br><span class="line">           &#125;</span><br><span class="line">           tail &#x3D; p;</span><br><span class="line">           ++modCount;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h3><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。<br>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    static class LRUCache&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt;</span><br><span class="line">    &#123;</span><br><span class="line">     private static final int MAX_ENTRIES&#x3D;3;</span><br><span class="line">     protected  boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</span><br><span class="line">     &#123;</span><br><span class="line">         return size()&gt;MAX_ENTRIES;</span><br><span class="line">     &#125;</span><br><span class="line">     LRUCache()</span><br><span class="line">     &#123;</span><br><span class="line">         super(MAX_ENTRIES,0.75f,true);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LRUCache&lt;Integer, String&gt; cache &#x3D; new LRUCache&lt;&gt;();</span><br><span class="line">        cache.put(1, &quot;a&quot;);</span><br><span class="line">        cache.put(2, &quot;b&quot;);</span><br><span class="line">        cache.put(3, &quot;c&quot;);</span><br><span class="line">        cache.get(1);</span><br><span class="line">        cache.put(4, &quot;d&quot;);</span><br><span class="line">        System.out.println(cache.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>前面已经说过<em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashSet&lt;E&gt;</span><br><span class="line">    extends HashSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#x2F;&#x2F; LinkedHashSet里面有一个LinkedHashMap</span><br><span class="line">    public LinkedHashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        map &#x3D; new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    public boolean add(E e) &#123;&#x2F;&#x2F;简单的方法转换</span><br><span class="line">        return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashSet源码剖析</title>
      <link href="/2020/07/13/HashSet%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/HashSet%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>HashSet 的是通过 HashMap 实现的，HashMap 的 Key 值即 HashSet 存储的元素，所有 Key 都使用相同的 Value ，一个 static final 修饰的变量名为 PRESENT 的 Object 类型的对象。使用 Key 保证集合元素的唯一性，但它不保证集合元素的有序性。由于 HashSet 的底层是 HashMap 实现的，HashMap 是线程不安全的，因此 HashSet 也是线程不安全的。</p><p>HashSet 判断元素是否相同时，对于基本类型的包装类，直接按值进行比较。对于引用数据类型，会先比较 hashCode 返回值是否相同，如果不同则代表不是同一个对象，如果相同则继续比较 equals 方法返回值是否相同，都相同说明是同一个对象。</p><p>TreeSet 的是使用 TreeMap 实现的，底层为树结构，在添加新元素到集合中时，按照某种比较规则将其插入合适的位置，保证插入后的集合仍然是有序的。LinkedHashSet 继承自 HashSet，内部使用链表维护了元素插入的顺序。</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList源码剖析</title>
      <link href="/2020/07/13/LinkedList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/LinkedList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（<em>Queue</em>），同时又可以看作一个栈（<em>Stack</em>）。这样看来，<em>LinkedList</em>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，一方面是因为Java官方已经声明不建议使用<em>Stack</em>类，更遗憾的是，Java里根本没有一个叫做<em>Queue</em>的类（它是个接口名字）。关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>（当作栈或队列使用时）有着更好的性能。</p><p><a href="https://camo.githubusercontent.com/af8b89b4d140940680305ab75b62b457c384fee3/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f626173652e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/af8b89b4d140940680305ab75b62b457c384fee3/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f626173652e706e67" alt="LinkedList"></a></p><p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p><h2 id="LinkedLists实现"><a href="#LinkedLists实现" class="headerlink" title="LinkedLists实现"></a>LinkedLists实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟<em>List</em>接口相关的函数，而将<em>Queue</em>和<em>Stack</em>以及<em>Deque</em>相关的知识放在下一节讲。双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候<code>first</code>和<code>last</code>都指向<code>null</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  transient int size &#x3D; 0;</span><br><span class="line">  transient Node&lt;E&gt; first;</span><br><span class="line">  transient Node&lt;E&gt; last;</span><br><span class="line">&#x2F;&#x2F; Node是私有的内部类</span><br><span class="line">  private static class Node&lt;E&gt; &#123;</span><br><span class="line">      E item;</span><br><span class="line">      Node&lt;E&gt; next;</span><br><span class="line">      Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">          this.item &#x3D; element;</span><br><span class="line">          this.next &#x3D; next;</span><br><span class="line">          this.prev &#x3D; prev;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getFirst-，getLast"><a href="#getFirst-，getLast" class="headerlink" title="getFirst()，getLast()"></a>getFirst()，getLast()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public E getFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E getLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeFirst-，removeLast-，remove-e-，remove-index"><a href="#removeFirst-，removeLast-，remove-e-，remove-index" class="headerlink" title="removeFirst()，removeLast()，remove(e)，remove(index)"></a>removeFirst()，removeLast()，remove(e)，remove(index)</h3><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p><p><a href="https://camo.githubusercontent.com/20a94f0e8e77cbbf0c70264439b940cf1e64ff23/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f72656d6f76652e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/20a94f0e8e77cbbf0c70264439b940cf1e64ff23/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f72656d6f76652e706e67" alt="remove"></a></p><p>删除元素 - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判读的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">    E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line"></span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 第一个元素</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next &#x3D; next;</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 最后一个元素</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev &#x3D; prev;</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item &#x3D; null; &#x2F;&#x2F; GC</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remove(int index)</code>使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除head元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    first &#x3D; next;</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除last元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public E removeLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;</span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    last &#x3D; prev;</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p><em>add()\</em>方法有两个版本，一个是<code>add(E e)</code>，该方法在*LinkedList*的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last &#x3D; newNode;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/4831538ace9fd84081b890f29bd06e0500fa9703/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f6164642e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/4831538ace9fd84081b890f29bd06e0500fa9703/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f6164642e706e67" alt="img"></a></p><p><code>add(int index, E element)</code>, 当index==size时，等同于add(E e); 如果不是，则分两步：1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    if (index &#x3D;&#x3D; size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    else</span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>node(int index)</code>函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3><p>addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a &#x3D; c.toArray();</span><br><span class="line">    int numNew &#x3D; a.length;</span><br><span class="line">    if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    if (index &#x3D;&#x3D; size) &#123;</span><br><span class="line">        succ &#x3D; null;</span><br><span class="line">        pred &#x3D; last;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        succ &#x3D; node(index);</span><br><span class="line">        pred &#x3D; succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Object o : a) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">        if (pred &#x3D;&#x3D; null)</span><br><span class="line">            first &#x3D; newNode;</span><br><span class="line">        else</span><br><span class="line">            pred.next &#x3D; newNode;</span><br><span class="line">        pred &#x3D; newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (succ &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; pred;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pred.next &#x3D; succ;</span><br><span class="line">        succ.prev &#x3D; pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size +&#x3D; numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2020/07/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class bubbleSort &#123;</span><br><span class="line">    public static int[] BubbleSort(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    swap(arr, j, j + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;21, 34, 56, 11, 2&#125;;</span><br><span class="line">        BubbleSort(arr);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void quickSort(int arr[], int left, int right) &#123;</span><br><span class="line">        if (left &gt;&#x3D; right) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int index &#x3D; partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, index - 1);</span><br><span class="line">        quickSort(arr, index + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int partition(int[] arr, int left, int right) &#123;</span><br><span class="line">        int key &#x3D; arr[left];</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            while (right &gt; left &amp;&amp; arr[right] &gt;&#x3D; key) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[left] &#x3D; arr[right];</span><br><span class="line">            while (right &gt; left &amp;&amp; arr[left] &lt; key) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[right] &#x3D; arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] &#x3D; key;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 测试案例</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;49, 38, 65, 97, 76, 13, 27, 49&#125;;</span><br><span class="line"></span><br><span class="line">        quickSort(arr, 0, arr.length - 1);</span><br><span class="line"></span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            System.out.print(i + &quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class InsertSort &#123;</span><br><span class="line">    public static int[] insertSort(int[] arr) &#123;</span><br><span class="line">        int temp, j;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            temp &#x3D; arr[i];</span><br><span class="line">            for (j &#x3D; i - 1; j &gt;&#x3D; 0 &amp;&amp; temp &lt; arr[j]; j--) &#123;</span><br><span class="line">                arr[j + 1] &#x3D; arr[j];</span><br><span class="line">            &#125;&#x2F;&#x2F; 1 2 2 5 2</span><br><span class="line">            arr[j + 1] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F;  Set&lt;Integer&gt; set&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">        int[] arr &#x3D; &#123;3, 1, 2, 5&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static int[] sort(int[] a,int low,int high)&#123;</span><br><span class="line">        int mid &#x3D; (low+high)&#x2F;2;</span><br><span class="line">        if(low&lt;high)&#123;</span><br><span class="line">            sort(a,low,mid);</span><br><span class="line">            sort(a,mid+1,high);</span><br><span class="line">            &#x2F;&#x2F;左右归并</span><br><span class="line">            merge(a,low,mid,high);</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void merge(int[] a, int low, int mid, int high) &#123;</span><br><span class="line">        int[] temp &#x3D; new int[high-low+1];</span><br><span class="line">        int i&#x3D; low;</span><br><span class="line">        int j &#x3D; mid+1;</span><br><span class="line">        int k&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F; 把较小的数先移到新数组中</span><br><span class="line">        while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;high)&#123;</span><br><span class="line">            if(a[i]&lt;a[j])&#123;</span><br><span class="line">                temp[k++] &#x3D; a[i++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp[k++] &#x3D; a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把左边剩余的数移入数组</span><br><span class="line">        while(i&lt;&#x3D;mid)&#123;</span><br><span class="line">            temp[k++] &#x3D; a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把右边边剩余的数移入数组</span><br><span class="line">        while(j&lt;&#x3D;high)&#123;</span><br><span class="line">            temp[k++] &#x3D; a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把新数组中的数覆盖nums数组</span><br><span class="line">        for(int x&#x3D;0;x&lt;temp.length;x++)&#123;</span><br><span class="line">            a[x+low] &#x3D; temp[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr&#x3D;&#123;2,1,5,4&#125;;</span><br><span class="line">        sort(arr,0,arr.length-1);</span><br><span class="line">        for(int a:arr)</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line">    public static void heapSort(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; arr.length &#x2F; 2 - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">            downjust(arr, i, arr.length);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; :&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; arr.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            swap(arr, i, 0);</span><br><span class="line">            downjust(arr, 0, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void downjust(int[] arr, int low, int high) &#123;</span><br><span class="line">        int i &#x3D; low, j &#x3D; i * 2 + 1, temp &#x3D; arr[i];</span><br><span class="line">        while (j &lt; high) &#123;</span><br><span class="line">            if (j + 1 &lt; high &amp;&amp; arr[j] &lt; arr[j + 1])</span><br><span class="line">                j++;</span><br><span class="line">            if (arr[j] &gt; temp) &#123;</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">                i &#x3D; j;</span><br><span class="line">                j &#x3D; i * 2 + 1;</span><br><span class="line">            &#125; else break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums &#x3D; &#123;110, 16, 7, 3, 20, 17, 8&#125;;</span><br><span class="line">        heapSort(nums);</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            System.out.print(num + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class SelectSort &#123;</span><br><span class="line">    &#x2F;&#x2F;选择排序：每次从待排序的元素中选出最小值</span><br><span class="line">    &#x2F;&#x2F;选择排序：每次从待排序的元素中选出最小值  </span><br><span class="line">    public static void selectionSort(int[] arr)&#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; arr.length - 1; i++)&#123;</span><br><span class="line">            int min &#x3D; i;</span><br><span class="line">            for(int j &#x3D; i + 1; j &lt; arr.length; j++)&#123;</span><br><span class="line">                &#x2F;&#x2F;将a[i]和a[i+1...N-1]中的最小元素交换</span><br><span class="line">                if(arr[j] &lt; arr[min])&#123;&#x2F;&#x2F;升序排列</span><br><span class="line">                    min &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(min !&#x3D; i)&#123;</span><br><span class="line">                int temp &#x3D; arr[i];</span><br><span class="line">                arr[i] &#x3D; arr[min];</span><br><span class="line">                arr[min] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array &#x3D; &#123;3,2,4,1,5,0&#125;;</span><br><span class="line">        selectionSort(array);</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class shellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;1,8,3,4,2,0,5,6,3,2,8,9&#125;;</span><br><span class="line">        shell(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 希尔排序</span><br><span class="line">     * @param arr 要排序的数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void shell(int[] arr)&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;希尔排序实际上是直接插入排序的升级版本，在直接插入排序的算法中，如果越到后面突然出现某个比较小的值</span><br><span class="line">        &#x2F;&#x2F;这个时候排序的步骤就越长，希尔排序就是为了解决这个问题，先大致的排一下，然后拍的过程中用的是直接插入排序算法</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;首先计算步长</span><br><span class="line">        for(int d &#x3D; arr.length&#x2F;2;d&gt;0;d &#x3D; d&#x2F;2)&#123;</span><br><span class="line">            &#x2F;&#x2F;开始直接排序算法</span><br><span class="line">            &#x2F;&#x2F;先来一轮直接排序</span><br><span class="line">            for(int i &#x3D; d;i &lt; arr.length;i++)&#123;</span><br><span class="line">                &#x2F;&#x2F;然后开始交换</span><br><span class="line">                for(int j &#x3D; i - d;j &gt;&#x3D;0; j &#x3D; j-d)&#123;</span><br><span class="line">                    if(arr[j] &gt; arr[j+d])&#123;</span><br><span class="line">                        int temp &#x3D; arr[j];</span><br><span class="line">                        arr[j] &#x3D; arr[j+d];</span><br><span class="line">                        arr[j+d] &#x3D; temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images2018.cnblogs.com/blog/1032108/201807/1032108-20180724193606939-1891336874.jpg" alt></p><h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h2><p> 笔试时，遇到一个算法题：差不多是 在n个不同的数中随机取出不重复的m个数。洗牌算法是将原来的数组进行打散，使原数组的某个数在打散后的数组中的每个位置上等概率的出现，刚好可以解决该问题。</p><p>该算法是经典洗牌算法。它的proof如下：</p><p>对于arr[i],洗牌后在第n-1个位置的概率是1/n（第一次交换的随机数为i）<br>在n-2个位置概率是[(n-1)/n] * [1/(n-1)] = 1/n，（第一次交换的随机数不为i，第二次为arr[i]所在的位置（注意，若i=n-1，第一交换arr[n-1]会被换到一个随机的位置））<br>在第n-k个位置的概率是[(n-1)/n] * [(n-2)/(n-1)] <em>…</em> [(n-k+1)/(n-k+2)] *[1/(n-k+1)] = 1/n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">该算法的基本思想和 Fisher 类似，每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。</span><br><span class="line">算法步骤为：</span><br><span class="line">    1. 建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；</span><br><span class="line">    2. 生成一个从 0 到 n - 1 的随机数 x；</span><br><span class="line">    3. 输出 arr 下标为 x 的数值，即为第一个随机数；</span><br><span class="line">    4. 将 arr 的尾元素和下标为 x 的元素互换；</span><br><span class="line">    5. 同2，生成一个从 0 到 n - 2 的随机数 x；</span><br><span class="line">    6. 输出 arr 下标为 x 的数值，为第二个随机数；</span><br><span class="line">    7. 将 arr 的倒数第二个元素和下标为 x 的元素互换；</span><br><span class="line">……</span><br><span class="line">如上，直到输出 m 个数为止</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class hello &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] arr &#x3D; &#123;5,1,2,6,7,8,93,67,8,3,86,4,6,8,45,86&#125;;</span><br><span class="line">        flushArr(arr);</span><br><span class="line">        for(int num : arr)&#123;</span><br><span class="line">            System.out.print(num + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void flushArr(int[] arr)&#123;</span><br><span class="line">        for (i &#x3D; arr.length - 1; i &gt; 0; i--)</span><br><span class="line">        &#123;  </span><br><span class="line">            &#x2F;&#x2F;随机数生成器，范围[0, i]  </span><br><span class="line">            int rand &#x3D; (new Random()).nextInt(i+1);  </span><br><span class="line"></span><br><span class="line">            int temp &#x3D; arr[i];  </span><br><span class="line">            arr[i] &#x3D; arr[rand];  </span><br><span class="line">            arr[rand] &#x3D; temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int createRandom(int end)&#123;</span><br><span class="line">        return (new Random().nextInt(end));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最短路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[1,1,0,1],</span><br><span class="line"> [1,0,1,0],</span><br><span class="line"> [1,1,1,1],</span><br><span class="line"> [1,0,1,1]]</span><br><span class="line"> 1 表示可以经过某个位置，求解从 (0, 0) 位置到 (tr, tc) 位置的最短路径长度。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">static int min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">   static class Pair&#123;</span><br><span class="line">       int key;</span><br><span class="line">       int value;</span><br><span class="line">       public Pair(int key,int value) &#123;</span><br><span class="line">           this.key&#x3D;key;</span><br><span class="line">           this.value&#x3D;value;</span><br><span class="line">       &#125;</span><br><span class="line">       public int getKey() &#123;</span><br><span class="line">           return (int) this.key;</span><br><span class="line">       &#125;</span><br><span class="line">       public int getValue() &#123;</span><br><span class="line">           return (int) this.value;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       int [][]grids&#x3D; &#123;&#123;1,2&#125;,</span><br><span class="line">                       &#123;1,1&#125;&#125;;</span><br><span class="line">       minPathLength(grids, 1, 1);</span><br><span class="line">       System.out.println(min);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   public static void minPathLength(int[][] grids, int tr, int tc) &#123;</span><br><span class="line">       final int[][] direction &#x3D; &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">       int[][] s&#x3D;new int[2][2];</span><br><span class="line">       for(int i&#x3D;0;i&lt;2;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           for(int j&#x3D;0;j&lt;2;j++)</span><br><span class="line">           &#123;</span><br><span class="line">               s[i][j]&#x3D;300;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       s[0][0]&#x3D;1;</span><br><span class="line"></span><br><span class="line">       final int m &#x3D; grids.length, n &#x3D; grids[0].length;</span><br><span class="line">       Queue&lt;Pair&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">       queue.add(new Pair(0, 0));</span><br><span class="line">       int pathLength &#x3D; 0;</span><br><span class="line">       while (!queue.isEmpty()) &#123;</span><br><span class="line">           int size &#x3D; queue.size();</span><br><span class="line">           while (size-- &gt; 0) &#123;</span><br><span class="line">               Pair cur &#x3D; queue.poll();</span><br><span class="line">               int cr &#x3D; cur.getKey(), cc &#x3D; cur.getValue();</span><br><span class="line">               grids[cr][cc] &#x3D; 0; &#x2F;&#x2F; 标记</span><br><span class="line">               for (int[] d : direction) &#123;</span><br><span class="line">                   int nr &#x3D; cr + d[0], nc &#x3D; cc + d[1];</span><br><span class="line">                   if (nr &lt; 0 || nr &gt;&#x3D; m || nc &lt; 0 || nc &gt;&#x3D; n || s[nr][nc]&lt;&#x3D;s[cr][cc]+grids[nr][nc]) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   s[nr][nc]&#x3D;s[cr][cc]+grids[nr][nc];</span><br><span class="line">                   queue.add(new Pair(nr, nc));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       min&#x3D;Math.min(min,s[1][1]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="不同的数字"><a href="#不同的数字" class="headerlink" title="不同的数字"></a>不同的数字</h2><p>一个有序数组，有重复的数，平方后，数组当中有多少不同的数字,例子，[-1，3，3]，返回结果 2.</p><p>例子，[-1，-1，1，1]，返回结果 1. nums = {-2,-1,0,1,2,3} 返回4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int findDiff(int[] nums) &#123;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    int left &#x3D; 0;</span><br><span class="line">    int right &#x3D; nums.length - 1;</span><br><span class="line">    int pre &#x3D; - 1;</span><br><span class="line">   </span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        if (Math.abs(nums[left]) &gt; Math.abs(nums[right])) &#123;</span><br><span class="line">            if (pre !&#x3D; Math.abs(nums[left]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                pre &#x3D; Math.abs(nums[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (pre !&#x3D; abs(nums[right]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                pre &#x3D; abs(nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-hard"><a href="#leetcode-hard" class="headerlink" title="leetcode hard"></a>leetcode hard</h2><p>股票问题</p><p>4 中位数</p><p>10 正则匹配</p><p>23 合并K个</p><p>41 缺失第一个正数</p><p>44 通配符匹配</p><p>124 二叉树最大路径和</p><p>146 LRU</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>敲击url后发生了什么</title>
      <link href="/2020/07/10/%E6%95%B2%E5%87%BBurl%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/10/%E6%95%B2%E5%87%BBurl%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>第一步：浏览器输入域名</p><p>例如输入：</p><p><img src="https://img-blog.csdn.net/20180907093605464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW9fMDUwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>第二步：浏览器查找域名的IP地址</p><p>浏览器会把输入的域名解析成对应的IP，其过程如下：</p><p>1.查找浏览器缓存：因为浏览器一般会缓存DNS记录一段时间，不同浏览器的时间可能不一样，一般2-30分钟不等，浏览器去查找这些缓存，如果有缓存，直接返回IP，否则下一步。</p><p>2.查找系统缓存：浏览器缓存中找不到IP之后，浏览器会进行系统调用（windows中是gethostbyname），查找本机的hosts文件，如果找到，直接返回IP，否则下一步。</p><p>3.查找路由器缓存：如果1,2步都查询无果，则需要借助网络，路由器一般都有自己的DNS缓存，将前面的请求发给路由器，查找ISP 服务商缓存 DNS的服务器，如果查找到IP则直接返回，没有的话继续查找。</p><p>4.递归查询：如果以上步骤还找不到，则ISP的DNS服务器就会进行递归查询，所谓递归查询就是如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步查询。（本地域名服务器地址是通过DHPC协议获取地址，DHPC是负责分配IP地址的）</p><p>5.迭代查询：本地域名服务器采用迭代查询，它先向一个根域名服务器查询。本地域名服务器向根域名服务器的查询一般都是采用迭代查询。所谓迭代查询就是当根域名服务器收到本地域名服务器发出的查询请求报文后，要么告诉本地域名服务器下一步应该查询哪一个域名服务器，然后本地域名服务器自己进行后续的查询。（而不是替代本地域名服务器进行后续查询）。</p><p>本例子中：根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.net的IP地址。本地域名服务器向顶级域名服务器dns.net进行查询。顶级域名服务器dns.net告诉本地域名服务器，下一次应查询的权限域名服务器dns.csdn.net的IP地址。本地域名服务器向权限域名服务器dns.csdn.net进行查询。权限域名服务器dns.csdn.net告诉本地域名服务器，所查询的主机<a href="http://www.csdn.net的IP地址。本地域名服务器最后把结果告诉主机。" target="_blank" rel="noopener">www.csdn.net的IP地址。本地域名服务器最后把结果告诉主机。</a></p><p>第三步 ：浏览器与目标服务器建立TCP连接</p><ol><li><p>主机浏览器通过DNS解析得到了目标服务器的IP地址后，与服务器建立TCP连接。</p></li><li><p>TCP3次握手连接：浏览器所在的客户机向服务器发出连接请求报文（SYN标志为1）；服务器接收报文后，同意建立连接，向客户机发出确认报文（SYN，ACK标志位均为1）；客户机接收到确认报文后，再次向服务器发出报文，确认已接收到确认报文；此处客户机与服务器之间的TCP连接建立完成，开始通信。</p></li></ol><p>第四步：浏览器通过http协议发送请求</p><p>浏览器向主机发起一个HTTP-GET方法报文请求。请求中包含访问的URL，也就是<a href="http://www.csdn.com/" target="_blank" rel="noopener">http://www.csdn.com/</a> ，KeepAlive，长连接，还有User-Agent用户浏览器操作系统信息，编码等。值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件。Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。</p><p>第五步：某些服务会做永久重定向响应</p><p>对于大型网站存在多个主机站点，了负载均衡或者导入流量，提高SEO排名，往往不会直接返回请求页面，而是重定向。返回的状态码就不是200OK，而是301,302以3开头的重定向码，浏览器在获取了重定向响应后，在响应报文中Location项找到重定向地址，浏览器重新第一步访问即可。</p><p>重定向的作用：重定向是为了负载均衡或者导入流量，提高SEO排名。利用一个前端服务器接受请求，然后负载到不同的主机上，可以大大提高站点的业务并发处理能力；重定向也可将多个域名的访问，集中到一个站点；由于baidu.com，<a href="http://www.baidu.com会被搜索引擎认为是两个网站，照成每个的链接数都会减少从而降低排名，永久重定向会将两个地址关联起来，搜索引擎会认为是同一个网站，从而提高排名。" target="_blank" rel="noopener">www.baidu.com会被搜索引擎认为是两个网站，照成每个的链接数都会减少从而降低排名，永久重定向会将两个地址关联起来，搜索引擎会认为是同一个网站，从而提高排名。</a></p><p>第六步：浏览器跟踪重定向地址</p><p>当浏览器知道了重定向后最终的访问地址之后，重新发送一个http请求，发送内容同上。</p><p>第七步：服务器处理请求</p><p>服务器接收到获取请求，然后处理并返回一个响应。Web 页面内容放入报文主体中，发回给主机。浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP和UDP相关问题</title>
      <link href="/2020/07/10/TCP%E5%92%8CUDP%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/10/TCP%E5%92%8CUDP%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>TCP提供可靠的、面向连接的运输服务。在传输数据之前必须三次握手建立连接，数据传输结束之后，4次挥手释放连接，而且在数据传递时，又有确认应答、超时重传、流量控制、拥塞控制等机制保证传送数据的可靠性。TCP经常用于对网络通信质量有很高要求的地方，如文件传输，邮件发送，远程登录等场景。SMTP、TELNET、HTTP、FTP</p><p>   UDP在传送数据之前不需要建立连接，目的主机收到UDP报文后，不需要给出确认。UDP不提供可靠交付，一般用于即时通信，如语音、视频、直播等。RIP(路由选择协议)，DNS</p><h2 id="什么是TCP的三次握手？"><a href="#什么是TCP的三次握手？" class="headerlink" title="什么是TCP的三次握手？"></a>什么是TCP的三次握手？</h2><p><img src="https://img-blog.csdnimg.cn/20200710095751436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="img"></p><p>假设 A 为客户端，B 为服务器端。</p><p>最初客户端和服务端都处于 CLOSED(关闭) 状态。ACK为确认值，ack为确认编号</p><p>一开始，服务器首先创建传输控制块TCB，然后处于 LISTEN(监听) 状态，等待客户端的连接请求。</p><p>· 第一次握手：A 的 TCP 客户端进程创建传输控制块 TCB、向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。</p><p>· 第二次握手：B 收到连接请求报文后，向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，己选择一个初始序号 seq = y，确认号 ack = x + 1。（请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。）这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。</p><p>· 第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。(这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。)这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</p><h2 id="为什么是三次握手？"><a href="#为什么是三次握手？" class="headerlink" title="为什么是三次握手？"></a>为什么是三次握手？</h2><p><strong>三次握手的原因主要有两个目的，信息对等和防止超时。</strong></p><p>从信息对等的角度看，双方只有确定 4 类信息才能建立连接，即 A 和 B 分别确认自己和对方的发送和接收能力正常。在第二次握手后，从 B 的角度看还不能确定自己的发送能力和对方的接收能力，只有在第三次握手后才能确认。</p><p>防止超时。三次握手也是防止失效连接突然到达导致脏连接，网络报文的生存时间往往会超过 TCP 请求超时时间，A 的某个超时连接请求可能会在双方释放连接之后到达 B，B 会误以为是 A 创建了新的连接请求，然后发送确认报文创建连接。如果是两次握手，连接已经建立了，服务器资源被白白浪费。如果是三次握手，B 由于长时间没有收到确认信息，最终超时导致创建连接失败，因此不会出现脏连接。</p><h2 id="四次挥手？"><a href="#四次挥手？" class="headerlink" title="四次挥手？"></a>四次挥手？</h2><p><img src="https://img-blog.csdnimg.cn/20200710100009759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="img"></p><p>由于TCP连接是全双工的，因此每个方向都必须单独关闭。当一方数据发送任务完成之后，可以发送FIN来终止这个方向的连接。而另一方可以继续发送数据。</p><p>· 客户端发送请求释放连接报文，FIN=1,seq=u;客户端进入FIN-WAIT-1状态；</p><p>· 服务器收到请求，发送确认报文。ACK=1,seq=v,ack=u+1;服务器进入CLOSE-WAIT状态。客户端收到后进入终止等待2FIN-WAIT-2;</p><p>· 服务器发送完数据之后，向客户端发送请求释放连接报文，FIN=1,ACK=1,seq=w,ack=u+1;进入LAST-ACK状态</p><p>·客户端收到请求后，发送确认报文，ACK=1,seq=u+1,ack=w+1。客户端进入TIME-WAIT状态，等待2MSL后进如CLOSED状态，服务器收到确认后进如CLOSED状态。</p><h2 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h2><p>第一点原因是为了保证被动关闭方可以进入 CLOSED 状态。MSL 是最大报文段寿命，等待 2MSL 可以保证 A 发送的最后一个确认报文能被 B 接收，如果该报文丢失，B 没有收到就会超时重传之前的 FIN+ACK 报文，而如果 A 在发送确认报文后就立即释放连接就无法收到 B 超时重传的报文，因而也不会再一次发送确认报文段，B 就无法正常进入 CLOSED 状态。</p><p>第二点原因是 2MSL 时间之后，本连接中的所有报文就都会从网络中消失，可以防止已失效连接的请求数据包与正常连接的请求数据包混淆而发生异常。</p><p>除此之外，TCP 还设有一个保活计时器，用于解决客户端主机故障的问题，服务器每收到一次客户的数据就重新设置保活计时器，时间为 2 小时。如果 2 小时内没有收到就间隔 75 秒发送一次探测报文，连续 10 次都没有响应后就关闭连接。</p><h2 id="TCP是怎么保证可靠的？"><a href="#TCP是怎么保证可靠的？" class="headerlink" title="TCP是怎么保证可靠的？"></a>TCP是怎么保证可靠的？</h2><p>TCP 的可靠传输包含很多机制，例如使用<strong>检验和</strong>来检测一个传输分组中的比特错误、使用<strong>定时器</strong>来用于超时重传一个分组、使用<strong>序号</strong>来检测丢失的分组和冗余副本、使用<strong>确认</strong>来告诉发送方确认的分组信息、使用<strong>否定确认</strong>来告诉发送方某个分组未被正确接收。除此之外，TCP 还使用<strong>流量控制</strong>和<strong>拥塞控制</strong>来保证可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ICMP及其应用</title>
      <link href="/2020/07/09/ICMP%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2020/07/09/ICMP%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ICMP 报文是封装在 IP 包里面的。ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><h2 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h2><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。<br>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时<br>间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p>ping 命令执行的时候，源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。最重要的是两个，第一个是类型字段，对于请求数据包而言该字段为 8；另外一个是顺序号，主要用于区分连续 ping 的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加 1。</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。应答数据包的类型字段为 0，构建新的ICMP数据包，发回给主机A，此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><h2 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h2><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。<br>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文</p><ul><li><p>Traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。将TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了。如果中间的路由器不止一个，当然碰到第一个就“牺牲”。于是，返回一个 ICMP 包，也就是网络差错包，类型是时间超时。接下来，将 TTL 设置为2.。。这样，Traceroute 就拿到了所有的路由器 IP。怎么知道 UDP 有没有到达目的主机呢？Traceroute 程序会发送一份 UDP 数据报给目的主机，但它会选择一个不可能的值作为 UDP 端口号（大于 30000）。当该数据报到达时，将使目的主机的 UDP 模块产生一份“端口不可达”错误 ICMP 报文。如果数据报没有到达，则可能是超时</p></li><li><p>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。要做的工作首先是发送分组，并设置“不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果</p></li></ul><p>中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包，</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis高可用</title>
      <link href="/2020/07/05/redis%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>/2020/07/05/redis%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>Redis多副本（主从）</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6EJvicazJ6KzImNoKH1nofWM9rqIR6VUWeDxJHhJHIQgDFF9Hb5kRnGkNicM7KGfpad5VnUo0pOQjm2Fw7TGUs0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>Redis 多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。</p><p>优点：</p><p>1、高可靠性，一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行。另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题。</p><p>2、读写分离策略，从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</p><p>缺点：</p><p>1、故障恢复复杂，如果没有RedisHA系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其他从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐。</p><p>2、主库的写能力受到单机的限制，可以考虑分片</p><p>3、主库的存储能力受到单机的限制，可以考虑Pika</p><p>4、原生复制的弊端在早期的版本也会比较突出，如：Redis复制中断后，Slave会发起psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于COW机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘IO和CPU（压缩）资源消耗；发送数GB大小的备份文件导致服务器出口带宽暴增，阻塞请求。建议升级到最新版本。</p><p><strong>Redis Sentinel（哨兵）</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6EJvicazJ6KzImNoKH1nofWM9rqIR6VUW1ibIW7Go066hNFQF5jUpkv5NN8RIA4McUSyRPVb82OTnpnWnmKyrDbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>Redis Sentinel是社区版本推出的原生高可用解决方案，Redis Sentinel部署架构主要包括两部分：Redis Sentinel集群和Redis数据集群，其中Redis Sentinel集群是由若干Sentinel节点组成的分布式集群。可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel的节点数量要满足2n+1（n&gt;=1）的奇数个。</p><p>优点：</p><p>1、Redis Sentinel集群部署简单</p><p>2、能够解决Redis主从模式下的高可用切换问题</p><p>3、很方便实现Redis数据节点的线形扩展，轻松突破Redis自身单线程瓶颈，可极大满足对Redis大容量或高性能的业务需求。</p><p>4、可以实现一套Sentinel监控一组Redis数据节点或多组数据节点</p><p>缺点：</p><p>1、部署相对Redis 主从模式要复杂一些，原理理解更繁琐</p><p>2、资源浪费，Redis数据节点中slave节点作为备份节点不提供服务</p><p>3、Redis Sentinel主要是针对Redis数据节点中的主节点的高可用切换，对Redis的数据节点做失败判定分为主观下线和客观下线两种，对于Redis的从节点有对节点做主观下线操作，并不执行故障转移。</p><p>4、不能解决读写分离问题，实现起来相对复杂</p><p>建议：</p><p>1、如果监控同一业务，可以选择一套Sentinel集群监控多组Redis数据节点的方案，反之选择一套Sentinel监控一组Redis数据节点的方案</p><p>2、sentinel monitor <master-name> <ip> <port> <quorum> 配置中的<quorum>建议设置成Sentinel节点的一半加1，当Sentinel部署在多个IDC的时候，单个IDC部署的Sentinel数量不建议超过（Sentinel数量 – quorum）。</quorum></quorum></port></ip></master-name></p><p>3、合理设置参数，防止误切，控制切换灵敏度控制</p><ol><li>quorum</li><li>down-after-milliseconds 30000</li><li>failover-timeout 180000</li><li>maxclient</li><li>timeout</li></ol><p>4、部署的各个节点服务器时间尽量要同步，否则日志的时序性会混乱</p><p>5、Redis建议使用pipeline和multi-keys操作，减少RTT次数，提高请求效率</p><p>6、自行搞定配置中心（zookeeper），方便客户端对实例的链接访问</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6EJvicazJ6KzImNoKH1nofWM9rqIR6VUWNSEC8dvIoHtWlm4OyK3KxaXc4sSzibK0nFC4hNKhhsPXibrQibFwLOglA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>Redis Cluster是社区版推出的Redis分布式集群解决方案，主要解决Redis分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster能起到很好的负载均衡的目的。Redis Cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p><p>优点：</p><p>1、无中心架构</p><p>2、数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p><p>3、可扩展性，可线性扩展到1000多个节点，节点可动态添加或删除。</p><p>4、高可用性，部分节点不可用时，集群仍可用。通过增加Slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升。</p><p>5、降低运维成本，提高系统的扩展性和可用性。</p><p>缺点：</p><p>1、Client实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅JedisCluster相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</p><p>2、节点会因为某些原因发生阻塞（阻塞时间大于clutser-node-timeout），被判断下线，这种failover是没有必要的。</p><p>3、数据通过异步复制,不保证数据的强一致性。</p><p>4、多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</p><p>5、Slave在集群中充当“冷备”，不能缓解读压力，当然可以通过SDK的合理设计来提高Slave资源的利用率。</p><p>6、key批量操作限制，如使用mset、mget目前只支持具有相同slot值的key执行批量操作。对于映射为不同slot值的key由于keys 不支持跨slot查询，所以执行mset、mget、sunion等操作支持不友好。</p><p>7、key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个key分布于不同的节点上时无法使用事务功能。</p><p>8、key作为数据分区的最小粒度，因此不能将一个很大的键值对象如hash、list等映射到不同的节点。</p><p>9、不支持多数据库空间，单机下的redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0。</p><p>10、复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p><p>11、避免产生hot-key，导致主库节点成为系统的短板。</p><p>12、避免产生big-key，导致网卡撑爆、慢查询等。</p><p>13、重试时间应该大于cluster-node-time时间</p><p>14、Redis Cluster不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis写入和删除的原理</title>
      <link href="/2020/07/05/redis%E5%86%99%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2020/07/05/redis%E5%86%99%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/ea15a1e0d43d" target="_blank" rel="noopener">https://www.jianshu.com/p/ea15a1e0d43d</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis相关问题剖析</title>
      <link href="/2020/07/05/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/05/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Redis-学习笔记"><a href="#Redis-学习笔记" class="headerlink" title="Redis 学习笔记"></a>Redis 学习笔记</h1><h2 id="初识-Redis"><a href="#初识-Redis" class="headerlink" title="初识 Redis"></a>初识 Redis</h2><p>Redis 是一种基于键值对的 NoSQL 数据库，Redis 中的值可以是由 string、hash、list、set、zset 等多种数据结构和算法组成，因此 Redis 可以满足很多应用场景。Redis 将所有数据都存放在内存中，所以它的读写能力也非常高。Redis 还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会丢失。除了这些功能，Redis 还提供了键过期、发布订阅、事务、流水线、Lua 等附加功能。</p><h3 id="Redis-的特性"><a href="#Redis-的特性" class="headerlink" title="Redis 的特性"></a>Redis 的特性</h3><p><strong>速度快</strong></p><p>正常情况下，Redis 执行命令的速度非常快，官方给出的数字是读写性能可以达到 10 万/秒。Redis 速度快的原因主要归纳为几点：① Redis 的所有数据都放在内存中。② Redis 是使用 C 语言实现的，一般来说 C 语言实现的程序距离底层操作系统更近，因此速度相对会更快。③ Redis 使用了单线程架构，预防了多线程的竞争问题。 </p><p><strong>基于键值对的数据结构服务器</strong></p><p>与很多键值对数据库不同的是，Redis 中的值不仅可以是字符串，还可以是具体的数据结构，这样不仅能应用于多种场景开发，也可以提高开发效率。Redis 的全称是 REmote Dictionary Server，它主要提供五种数据结构：字符串、哈希、列表、集合、有序集合，同时在字符串的基础上演变出了位图和 HyperLogLog 两种数据结构，随着 LBS 基于位置服务的发展，Redis 3.2 加入了有关 GEO 地理信息定位的功能。</p><p><strong>丰富的功能</strong></p><p>① 提供了键过期功能，可以实现缓存。② 提供了发布订阅功能，可以实现消息系统。③ 支持 Lua 脚本，可以创造新的 Redis 命令。④ 提供了简单的事务功能，能在一定程度商保证事务特性。⑤ 提供了流水线功能，这样客户端能将一批命令一次性传到 Redis，减少了网络开销。⑤IO多路复用</p><p><strong>持久化</strong></p><p>通常来说数据放在内存中是不安全的，一旦发生断电或故障数据就可能丢失，因此 Redis 提供了两种持久化方式 RDB 和 AOF 将内存的数据保存到硬盘中。</p><p><strong>高可用和分布式</strong></p><p>Redis 从 2.8 版本正式提供了高可用实现 Redis Sentinel，能够保证 Redis 节点的故障发现和故障自动转移。Redis 从 3.0 版本正式提供了分布式实现 Redis Cluster，提供了高可用、读写和容量的扩展性。</p><hr><h3 id="Redis-的使用场景"><a href="#Redis-的使用场景" class="headerlink" title="Redis 的使用场景"></a>Redis 的使用场景</h3><p><strong>缓存</strong></p><p>缓存机制几乎在所有大型网站都有使用，合理使用缓存不仅可以加快数据的访问速度，而且能够有效降低后端数据源的压力。Redis 提供了键值过期时间设置，并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。</p><p><strong>排行榜系统</strong></p><p>排行榜系统几乎存在于所有网站，Redis 提供了列表和有序集合数据结构，合理使用这些数据结构可以方便构建各各种排行榜系统。</p><p><strong>计数器应用</strong></p><p>计数器在网站中的作用很重要，例如视频网站有播放数、电商网站有浏览数，为了保证数据实时性，每一次播放和浏览都要做加 1 的操作，如果并发量很大对于传统关系型数据库的性能是很大的挑战。Redis 天然支持计数功能而且性能也非常好。</p><p><strong>社交网络</strong></p><p>粉丝、共同好友/喜好、推送、下拉刷新等是社交网络的必备功能，由于社交网站的访问量通常很大，而且关系型数据不太适合保存这种类型的数据，Redis 提供的数据结构可以相对容易地实现这些功能。</p><p><strong>消息队列系统</strong></p><p>消息队列系统是一个大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis 提供了发布订阅和阻塞队列的功能，对于一般的消息队列功能基本可以满足。</p><p><strong>Redis 不适合非常大的数据量，成本非常高，也不适合冷数据，会浪费内存。</strong></p><hr><h2 id="API-的理解和使用"><a href="#API-的理解和使用" class="headerlink" title="API 的理解和使用"></a>API 的理解和使用</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串类型是 Redis 最基础的数据结构，键都是字符串类型，而且其他几种数据结构都是在字符串类型的基础上构建的。字符串类型的值可以实际可以是字符串（简单的字符串、复杂的字符串如 JSON、XML）、数字（整形、浮点数）、甚至二进制（图片、音频、视频），但是值最大不能超过 512 MB。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><strong>设置值</strong></p><p><code>set key value [ex seconds] [px millseconds] [nx|xx]</code></p><ul><li>ex seconds：为键设置秒级过期时间，跟 setex 效果一样</li><li>px millseconds：为键设置毫秒级过期时间</li><li>nx：键必须不存在才可以设置成功，用于添加，跟 setnx 效果一样。由于 Redis 的单线程命令处理机制，如果多个客户端同时执行，则只有一个客户端能设置成功，可以用作分布式锁的一种实现。</li><li>xx：键必须存在才可以设置成功，用于更新</li></ul><p><strong>获取值</strong></p><p><code>get key</code>，如果不存在返回 nil</p><p><strong>批量设置值</strong></p><p><code>mset key value [key value...]</code></p><p><strong>批量获取值</strong></p><p><code>mget key [key...]</code></p><p>批量操作命令可以有效提高开发效率，假如没有 mget，执行 n 次 get 命令需要 n 次网络时间 + n 次命令时间，使用 mget 只需要 1 次网络时间 + n 次命令时间。</p><p>Redis 可以支持每秒数万的读写操作，但这指的是 Redis 服务端的处理能力，对于客户端来说一次命令处理命令时间还有网络时间。因为 Redis 的处理能力已足够高，对于开发者来说，网络可能会成为性能瓶颈。</p><p><strong>计数</strong></p><p><code>incr key</code></p><p>incr 命令用于对值做自增操作，返回结果分为三种：① 值不是整数返回错误。② 值是整数，返回自增后的结果。③ 值不存在，按照值为 0 自增，返回结果 1。除了 incr 命令，还有自减 decr、自增指定数字 incrby、自减指定数组 decrby、自增浮点数 incrbyfloat。</p><hr><h4 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h4><p><strong>追加值</strong></p><p>append key  value，可以向字符串尾部追加值</p><p><strong>字符串长度</strong></p><p><code>strlen key</code></p><p><strong>设置并返回原值</strong></p><p><code>getset key value</code></p><p><strong>设置指定位置的字符</strong></p><p><code>setrange key offset value</code></p><p><strong>获取部分字符串</strong></p><p><code>getrange key start end</code>，start 和 end分别是开始和结束的偏移量，偏移量从 0 开始计算。</p><hr><h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><p>字符串类型的内部编码有三种:</p><ul><li>int：8 个字节的长整形</li><li>embstr：小于等于 39 个字节的字符串</li><li>raw：大于 39 个字节的字符串</li></ul><hr><h4 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h4><p><strong>缓存功能</strong></p><p>Redis 作为缓存层，MySQL 作为存储层，首先从 Redis 获取数据，如果没有获取到就从 MySQL 获取，并将结果写回到 Redis，添加过期时间。</p><p><strong>计数</strong></p><p>Redis 可以实现快速计数功能，例如视频每播放一次就用 incy 把播放数加 1。</p><p><strong>共享 Session</strong></p><p>一个分布式 Web 服务将用户的 Session 信息保存在各自服务器，但会造成一个问题，出于负载均衡的考虑，分布式服务会将用户的访问负载到不同服务器上，用户刷新一次可能会发现需要重新登陆。为解决该问题，可以使用 Redis 将用户的 Session 进行集中管理，在这种模式下只要保证 Redis 是高可用和扩展性的，每次用户更新或查询登录信息都直接从 Redis 集中获取。</p><p><strong>限速</strong></p><p>例如为了短信接口不被频繁访问会限制用户每分钟获取验证码的次数或者网站限制一个 IP 地址不能在一秒内访问超过 n 次。可以使用键过期策略和自增计数实现。</p><hr><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>哈希类型是指键值本身又是一个键值对结构，哈希类型中的映射关系叫做 field-value，这里的 value 是指 field 对于的值而不是键对于的值。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><strong>设置值</strong></p><p><code>hset key field value</code>，如果设置成功会返回 1，反之会返回 0，此外还提供了 hsetnx 命令，作用和 setnx 类似，只是作用于由键变为 field。</p><p><strong>获取值</strong></p><p><code>hget key field</code>，如果不存在会返回 nil。</p><p><strong>删除 field</strong></p><p><code>hdel key field [field...]</code>，会删除一个或多个 field，返回结果为删除成功 field 的个数。</p><p><strong>计算 field 个数</strong></p><p><code>hlen key</code></p><p><strong>批量设置或获取 field-value</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field...]</span><br><span class="line">hmset key field value [field value...]</span><br></pre></td></tr></table></figure><p>hmset 需要的参数是 key 和多对 field-value，hmget 需要的参数是 key 和多个 field。</p><p><strong>判断 field 是否存在</strong></p><p><code>hexists key field</code>，存在返回 1，否则返回  0。</p><p><strong>获取所有的 field</strong></p><p><code>hkeys key</code>，返回指定哈希键的所有 field。</p><p><strong>获取所有 value</strong></p><p><code>hvals key</code>，获取指定键的所有 value。</p><p><strong>获取所有的 field-value</strong></p><p><code>hgetall key</code>，获取指定键的所有 field-value。</p><p><strong>计数</strong></p><p><code>hincrby key field</code> 和 <code>hincrbyfloat key field</code>，作用和 incrby 和 incrbyfloat 一样，作用域是 field。</p><p><strong>计算 value 的字符串长度</strong></p><p>hstrlen key field</p><hr><h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><p>哈希类型的内部编码有两种：</p><ul><li>ziplist 压缩列表：当哈希类型元素个数和值小于配置值（默认 512 个和 64 字节）时会使用 ziplist 作为内部实现，使用更紧凑的结构实现多个元素的连续存储，在节省内存方面比 hashtable 更优秀。</li><li>hashtable 哈希表：当哈希类型无法满足 ziplist 的条件时会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度都为 O(1)。</li></ul><hr><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>缓存用户信息，有三种实现：</p><ul><li><p>原生字符串类型：每个属性一个键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set user:1:name tom</span><br><span class="line">set user:1:age 23</span><br><span class="line">set user:1:city xi&#39;an</span><br></pre></td></tr></table></figure><p>优点：简单直观，每个属性都支持更新操作。</p><p>缺点：占用过多的键，内存占用量较大，用户信息内聚性差，一般不会在生产环境使用。</p></li><li><p>序列化字符串类型：将用户信息序列化后用一个键保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set user:1 serialize(userInfo)</span><br></pre></td></tr></table></figure><p>优点：编程简单，如果合理使用序列化可以提高内存使用率。</p><p>缺点：序列化和反序列化有一定开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到 Redis。</p></li><li><p>哈希类型：每个用户属性使用一对 field-value，但只用一个键保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset user:1 name tom age 23 city xi&#39;an</span><br></pre></td></tr></table></figure><p>优点：简单直观，如果合理使用可以减少内存空间使用。</p><p>缺点：要控制哈希在 ziplist 和 hashtable 两种内部编码的转换，hashtable 会消耗更多内存。</p></li></ul><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表类型是用来存储多个有序的字符串，列表中的每个字符串称为元素，一个列表最多可以存储 2^32^-1 个元素。可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发中有很多应用场景。</p><p>列表类型有两个特点：① 列表中的元素是有序的，可以通过索引下标获取某个元素或者某个范围内的元素列表。② 列表中的元素可以重复。</p><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><p><strong>添加操作</strong></p><p>从右边插入元素：<code>rpush key value [value...]</code></p><p>从左到右获取列表的所有元素：<code>lrange 0 -1</code></p><p>从左边插入元素：<code>lpush key value [value...]</code></p><p>向某个元素前或者后插入元素：<code>linsert key before|after pivot value</code>，会在列表中找到等于 pivot 的元素，在其前或后插入一个新的元素 value。</p><p><strong>查找</strong></p><p>获取指定范围内的元素列表：<code>lrange key start end</code>，索引从左到右的范围是 0<del>N-1，从右到左是 -1</del>-N，lrange 中的 end 包含了自身。</p><p>获取列表指定索引下标的元素：<code>lindex key index</code>，获取最后一个元素可以使用 <code>lindex key -1</code>。</p><p>获取列表长度：<code>llen key</code></p><p><strong>删除</strong></p><p>从列表左侧弹出元素：<code>lpop key</code></p><p>从列表右侧弹出元素：<code>rpop key</code></p><p>删除指定元素：<code>lrem key count value</code>，如果 count 大于 0，从左到右删除最多 count 个元素，如果 count 小于 0，从右到左删除最多个 count 绝对值个元素，如果 count 等于 0，删除所有。</p><p>按照索引范围修剪列表：<code>ltrim key start end</code>，只会保留 start ~ end 范围的元素。</p><p><strong>修改</strong></p><p>修改指定索引下标的元素：<code>lset key index newValue</code>。</p><p><strong>阻塞操作</strong></p><p>阻塞式弹出：<code>blpop/brpop key [key...] timeout</code>，timeout 表示阻塞时间。</p><p>当列表为空时，如果 timeout = 0，客户端会一直阻塞，如果在此期间添加了元素，客户端会立即返回。</p><p>如果是多个键，那么brpop会从左至右遍历键，一旦有一个键能弹出元素，客户端立即返回。</p><p>如果多个客户端对同一个键执行 brpop，那么最先执行该命令的客户端可以获取弹出的值。</p><hr><h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><p>列表的内部编码有两种：</p><ul><li>ziplist 压缩列表：跟哈希的 zipilist 相同，元素个数和大小小于配置值（默认 512 个和 64 字节）时使用。</li><li>linkedlist 链表：当列表类型无法满足 ziplist 的条件时会使用linkedlist。</li></ul><p>Redis 3.2 提供了 quicklist 内部编码，它是以一个 ziplist 为节点的 linkedlist，它结合了两者的优势，为列表类提供了一种更为优秀的内部编码实现。</p><hr><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p><strong>消息队列</strong></p><p>Redis 的 lpush + brpop 即可实现阻塞队列，生产者客户端使用 lpush 从列表左侧插入元素，多个消费者客户端使用 brpop 命令阻塞式地抢列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</p><p><strong>文章列表</strong></p><p>每个用户有属于自己的文章列表，现在需要分页展示文章列表，就可以考虑使用列表。因为列表不但有序，同时支持按照索引范围获取元素。每篇文章使用哈希结构存储，例如每篇文章有三个属性，title、timestamp 和 content：</p><p><code>hmset article:k title t timestamp 147651524 content c</code>。</p><p>向用户文章列表添加文章，<code>user:{id}:articles</code> 作为用户文章列表的键：</p><p><code>lpush user:k:articles article:k</code>。</p><p>分页获取用户文章列表，例如以下伪代码获取用户 id = 1 的前 10 篇文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">articles &#x3D; lrange user:1:articles 0 9</span><br><span class="line">for article in &#123;articles&#125;</span><br><span class="line">hgetall &#123;article&#125;</span><br></pre></td></tr></table></figure><p>使用列表类型保存和获取文章列表存在两个问题：① 如果每次分页获取的文章个数较多，需要执行多次 hgetall 操作，此时可以考虑使用 Pipeline 批量获取，或者考虑将文章数据序列化为字符串类型，使用 mget 批量获取。② 分页获取文章列表时，lrange 命令在列表两端性能较好，但如果列表大，获取中间范围的元素性能会变差，可以考虑将列表做二级拆分，或使用 Redis3.2 的 quicklist。</p><hr><p><strong>lpush + lpop = 栈</strong></p><p><strong>lpush + rpop  = 队列</strong></p><p><strong>lpush + ltrim = 优先集合</strong></p><p><strong>lpush + brpop = 消息队列</strong></p><hr><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合类型也是用来保存多个字符串元素，和列表不同的是集合不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。一个集合最多可以存储 2^32^-1 个元素。Redis 除了支持集合内的增删改查，还支持多个集合取交集、并集、差集。</p><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><p><strong>集合内操作</strong></p><p><strong>添加元素</strong></p><p><code>sadd key element [element...]</code>，返回结果为添加成功的元素个数。</p><p><strong>删除元素</strong></p><p><code>srem key element [element...]</code>，返回结果为成功删除的元素个数。</p><p><strong>计算元素个数</strong></p><p><code>scard key</code>，时间复杂度为 O(1)，会直接使用 Redis 内部的遍历。</p><p><strong>判断元素是否在集合中</strong></p><p><code>sismember key element</code>，如果存在返回 1，否则返回 0。</p><p><strong>随机从集合返回指定个数个元素</strong></p><p><code>srandmember key [count]</code>，如果不指定 count 默认为 1。</p><p><strong>从集合随机弹出元素</strong></p><p><code>spop key</code>，可以从集合中随机弹出一个元素。</p><p><strong>获取所有元素</strong></p><p><code>smembers key</code></p><hr><p><strong>集合间操作</strong></p><p><strong>求多个集合的交集</strong></p><p><code>sinter key [key...]</code></p><p><strong>求多个集合的并集</strong></p><p><code>sunion key [key...]</code></p><p><strong>求多个集合的差集</strong></p><p><code>sdiff key [key...]</code></p><p><strong>保存交集、并集、差集的结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key [key...]</span><br><span class="line">sunionstore destination destination key [key...]</span><br><span class="line">sdiffstore destination key [key...]</span><br></pre></td></tr></table></figure><p>集合间的运算在元素较多的情况下会比较耗时，所以 Redis 提供了这三个指令将集合间交集、并集、差集的结果保存在 destination key 中。</p><hr><h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><p>集合类型的内部编码有两种：</p><ul><li>intset 整数集合：当集合中的元素个数小于配置值（默认 512 个时），,且都是整数时，使用 intset。</li><li>hashtable 哈希表：当集合类型无法满足 intset 条件时使用 hashtable。当某个元素不为整数时，也会使用 hashtable。</li></ul><hr><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>集合类型比较典型的使用场景是标签，例如一个用户可能与娱乐、体育比较感兴趣，另一个用户可能对例时、新闻比较感兴趣，这些兴趣点就是标签。这些数据对于用户体验以及增强用户黏度比较重要。</p><p><strong>给用户添加标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2 tag5</span><br><span class="line">sadd user:2:tags tag3 tag4 tag5</span><br><span class="line">...</span><br><span class="line">sadd user:k:tags tagx tagy tagz</span><br></pre></td></tr></table></figure><p><strong>给标签添加用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd tag:1:users user:1 user:3</span><br><span class="line">sadd tag:2:users user:1 user:4 user:5</span><br><span class="line">...</span><br><span class="line">sadd tag:k:users user:x user:y ...</span><br></pre></td></tr></table></figure><p>用户和标签的关系维护应该在一个事务内执行，防止部分命令失败造成的数据不一致。</p><p><strong>删除用户标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem user:1:tags tag1 tag5</span><br></pre></td></tr></table></figure><p><strong>删除标签下的用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem tag:1:users user:1</span><br></pre></td></tr></table></figure><p>删除也同样应该放在一个事务中。</p><p><strong>求两个用户共同感兴趣的标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinter user:1:tags user:2:tags</span><br></pre></td></tr></table></figure><p><strong>sadd = 标签</strong></p><p><strong>spop/srandmember = 生成随机数，比如抽奖</strong></p><p><strong>sadd + sinter = 社交需求</strong></p><hr><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>有序集合保留了集合不能有重复成员的特性，不同的是可以排序。但是它和列表使用索引下标作为排序依据不同的是，他给每个元素设置一个分数（score）作为排序的依据。有序集合提供了获取指定分数和元素查询范围、计算成员排名等功能。</p><table><thead><tr><th>数据结构</th><th>是否允许元素重复</th><th>是否有序</th><th>有序实现方式</th><th>应用场景</th></tr></thead><tbody><tr><td>列表</td><td>是</td><td>是</td><td>下标</td><td>时间轴，消息队列</td></tr><tr><td>集合</td><td>否</td><td>否</td><td>/</td><td>标签，社交</td></tr><tr><td>有序集合</td><td>否</td><td>是</td><td>分值</td><td>排行榜，社交</td></tr></tbody></table><h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><p><strong>集合内</strong></p><p><strong>添加成员</strong></p><p><code>zadd key score member [score member...]</code>，返回结果是成功添加成员的个数</p><p>Redis 3.2 为 zadd 命令添加了 nx、xx、ch、incr 四个选项：</p><ul><li>nx：member 必须不存在才可以设置成功，用于添加</li><li>xx：member 必须存在才能设置成功，用于更新</li><li>ch：返回此次操作后，有序集合元素和分数变化的个数</li><li>incr：对 score 做增加，相当于 zincrby</li></ul><p>zadd 的时间复杂度为 O(log<del>n</del>)，sadd 的时间复杂度为 O(1)。</p><p><strong>计算成员个数</strong></p><p><code>zcard key</code>，时间复杂度为 O(1)。</p><p><strong>计算某个成员的分数</strong></p><p><code>zscore key member</code> ，如果不存在则返回 nil。</p><p><strong>计算成员排名</strong></p><p><code>zrank key member</code>，从低到高返回排名</p><p><code>zrevrank key member</code>，从高到低返回排名</p><p><strong>删除成员</strong></p><p><code>zrem key member [member...]</code>，返回结果是成功删除的个数。</p><p><strong>增加成员的分数</strong></p><p><code>zincrby key increment member</code></p><p><strong>返回指定排名范围的成员</strong></p><p><code>zrange key start end [withscores]</code></p><p><code>zrevrange key start end [withscores]</code></p><p>zrange 从低到高返回，zrevrange 从高到底返回，如果加上 withscores 选项同时会返回成员的分数。</p><p><strong>返回指定分数范围的成员</strong></p><p><code>zrangebyscore key min max [withscores] [limit offset count]</code></p><p><code>zrevrangebyscore key min max [withscores] [limit offset count]</code></p><p>zrangebyscore 从低到高返回，zrevrangebyscore 从高到底返回，如果加上 withscores 选项同时会返回成员的分数。[limit offset count] 可以限制输出的起始位置和个数。</p><p><strong>返回指定分数范围成员个数</strong></p><p><code>zcount key min max</code></p><p><strong>删除指定排名内的升序元素</strong></p><p><code>zremrangebyrank key start end</code></p><p><strong>删除指定分数范围内的成员</strong></p><p><code>zremrangebyscore key min max</code></p><hr><p><strong>集合间的操作</strong></p><p><strong>交集</strong></p><p><code>zinterstore destination numkeys key [key...] [weights weight [weight...]] [aggregate sum|min|max]</code></p><ul><li><p>destination：交集结果保存到这个键</p></li><li><p>numkeys：要做交集计算键的个数</p></li><li><p>key [key…]：需要做交集计算的键</p></li><li><p>weights weight [weight…]：每个键的权重，默认 1</p></li><li><p>aggregate sum|min|max：计算交集后，分值可以按和、最小值、最大值汇总，默认 sum</p></li></ul><p><strong>并集</strong></p><p><code>zunionstore destination numkeys key [key...] [weights weight [weight...]] [aggregate sum|min|max]</code></p><hr><h4 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h4><p>有序集合的内部编码有两种：</p><ul><li>ziplist 压缩列表：当有序集合元素个数和值小于配置值（默认128 个和 64 字节）时会使用 ziplist 作为内部实现。</li><li>skiplist 跳跃表：当 ziplist 不满足条件时使用，因为此时 ziplist 的读写效率会下降。</li></ul><hr><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>有序集合的典型使用场景就是排行榜系统。</p><p>例如用户 mike 上传了一个视频并添加了 3 个赞，可以使用有序集合的 zadd 和 zincrby：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd user:ranking:2020_06_19 3 mike</span><br></pre></td></tr></table></figure><p>如果之后再获得一个赞，可以使用 zincrby：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zincrby user:ranking:2020_06_19 1 mike</span><br></pre></td></tr></table></figure><p>例如需要将用户 tom 从榜单删除，可以使用 zrem：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem user:ranking:2020_06_19 tom</span><br></pre></td></tr></table></figure><p>展示获取赞数最多的十个用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrange user:ranking:2020_06_19 0 9</span><br></pre></td></tr></table></figure><p>展示用户信息及用户分数，将用户名作为键后缀，将用户信息保存在哈希类型中，至于用户分数和排名可以使用 zscore 和 zrank：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hgetall user:info:tom</span><br><span class="line">zscore user:ranking:2020_06_19 tom</span><br><span class="line">zrank user:ranking:2020_06_19 tom</span><br></pre></td></tr></table></figure><hr><h3 id="键管理"><a href="#键管理" class="headerlink" title="键管理"></a>键管理</h3><h4 id="单个键管理"><a href="#单个键管理" class="headerlink" title="单个键管理"></a>单个键管理</h4><p><strong>键重命名</strong></p><p><code>rename key newkey</code></p><p>如果 rename 前键已经存在，那么它的值也会被覆盖。</p><p>为了防止强行覆盖，Redis 提供了 renamenx 命令，确保只有 newkey 不存在时才被覆盖。由于重命名键期间会执行 del 命令删除旧的键，如果键对应值比较大会存在阻塞的可能。</p><p><strong>随机返回一个键</strong></p><p><code>random key</code></p><p><strong>键过期</strong></p><p><code>expire key seconds</code>：键在 seconds 秒后过期</p><p><code>expireat key timestamp</code>：键在秒级时间戳 timestamp 后过期</p><p>如果过期时间为负值，键会被立即删除，和 del 命令一样。</p><p>persist 命令可以将键的过期时间清除。</p><p>对于字符串类型键，执行 set 命令会去掉过期时间，set 命令对应的函数 setKey 最后执行了 removeExpire 函数去掉了过期时间。</p><p>Redis 不支持二级数据结构（例如哈希、列表）内部元素的过期功能，例如不能对列表类型的一个元素设置过期时间。</p><p>setex 命令作为 set + expire 的组合，不单是原子执行并且减少了一次网络通信的时间。</p><p><strong>键迁移</strong></p><ul><li><p>move</p><p><code>move key db</code></p><p>move 命令用于在 Redis 内部进行数据迁移，<code>move key db</code> 就是把指定的键从源数据库移动到目标数据库中。</p></li><li><p>dump + restore</p><p><code>dump key</code></p><p><code>restore key ttl value</code></p><p>可以实现在不同的 Redis 势力之间进行数据迁移，分为两步：</p><p>① 在源 Redis 上，dump 命令会将键值序列化，格式采用 RDB 格式。</p><p>② 在目标 Redis 上，restore 命令将上面序列化的值进行复原，ttl 参数代表过期时间， ttl = 0 则没有过期时间。</p><p>整个迁移并非原子性的，而是通过客户端分步完成，并且需要两个客户端。</p></li><li><p>migrate</p><p>实际上 migrate 命令就是将 dump、restore、del 三个命令进行组合，从而简化了操作流程。migrate 具有原子性，且支持多个键的迁移，有效提高了迁移效率。实现过程和 dump + restore 类似，有三点不同：</p><p>① 整个过程是原子执行，不需要在多个 Redis 实例开启客户端。</p><p>② 数据传输直接在源 Redis 和目标 Redis 完成。</p><p>③ 目标 Redis 完成 restore 后会发送 OK 给源 Redis，源 Redis 接收后会根据 migrate 对应的选项来决定是否在源 Redis 上删除对应的键。</p></li></ul><table><thead><tr><th>命令</th><th>作用域</th><th>原子性</th><th>支持多个键</th></tr></thead><tbody><tr><td>move</td><td>Redis 实例内部</td><td>是</td><td>否</td></tr><tr><td>dump + restore</td><td>Redis 实例之间</td><td>否</td><td>否</td></tr><tr><td>migrate</td><td>Redis 实例之间</td><td>是</td><td>是</td></tr></tbody></table><hr><h4 id="遍历键"><a href="#遍历键" class="headerlink" title="遍历键"></a>遍历键</h4><p><strong>全量遍历键</strong></p><p><code>keys pattern</code></p><p><code>*</code>代表匹配任意字符，<code>?</code> 匹配一个字符，<code>[]</code> 匹配部分字符，例如 <code>[1,3]</code> 匹配 1 和 3， <code>[1-3]</code> 匹配 1 到 3 的任意数字，<code>\</code>用来做转义。</p><p><code>keys *</code> 遍历所有的键，一般不在生产环境使用，在以下情况可以使用：</p><p>① 在一个不对外提供服务的 Redis 从节点上执行，不会阻塞客户端的请求，但会影响主从复制。</p><p>② 如果确定键值总数比较少可以执行。</p><hr><p><strong>渐进式遍历</strong></p><p>Redis 从 2.8 版本后提供了一个新的命令 scan，能有效解决 keys 存在的问题。和 keys 遍历所有键不同，scan 采用渐进式遍历的方式解决阻塞问题，每次 scan 的时间复杂度为 O(1)，但是要真正实现 keys 的功能可能需要执行多次 scan。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan cursor [match pattern] [count number]</span><br></pre></td></tr></table></figure><p>cursor 是必须参数，代表一个游标，第一次遍历从 0 开始，每次 scan 完会返回当前游标的值，直到值为 0 表示遍历结束。</p><p>match pattern 是可选参数，作用是模式匹配。</p><p>count number 是可选参数，作用是表明每次要遍历的键个数，默认值为 10。</p><p>除了 scan 外，Redis 提供了面向哈希、集合、有序集合的扫描遍历命令，解决了 hgetall、smembers、zrange 可能产生的阻塞问题，对应命令分别为 hscan、sscan、zscan。</p><p>渐进式遍历可以有效解决 keys 命令可能产生的阻塞问题，但是如果在 scan 过程中有键的变化，那么遍历效果可能会遇到问题：新增的键没有被遍历到，遍历了重复的键等情况。</p><hr><h4 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h4><p><strong>切换数据库</strong></p><p><code>select dbIndex</code></p><p>Redis 中默认配置有 16 个数据库，例如 select 0 将切换到第一个数据库，数据库之间的数据是隔离的。</p><p><strong>flushdb/flushall</strong></p><p>用于清除数据库，flushdb 只清除当前数据库，flushall 会清除所有数据库。如果当前数据库键值数量比较多，flushdb/flushall 存在阻塞 Redis 的可能性。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redis 提供 5 种数据结构，每种数据结构都有多种内部编码实现。</p><p>纯内存存储、IO 多路复用计数、单线程架构是造就 Redis 高性能的三个因素。</p><p>由于 Redis 的单线程结构，所以需要每个命令能被快速执行完，否则会存在阻塞的可能。</p><p>批量操作（例如 mget、mset、hmset 等）能够有效提高命令执行的效率，但要注意每次批量操作的个数和字节数。</p><p>persist 命令可以删除任意类型键的过期时间，但 set 也会删除字符串类型键的过期时间。</p><p>move、dump + restore、migrate 是 Redis 发展过程中三种迁移键的方式，其中 move 命令基本废弃，migrate 命令用原子性的方式实现了 dump + restore，并且支持批量操作，是 Redis Cluster 实现水平扩容的重要工具。</p><p>scan 命令可以解决 keys 命令可能带来的阻塞问题，同时 Redis 还提供了 hscan、sscan、zscan 渐进式遍历 hash、set、zset。</p><hr><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的<br>Redis会将一个事务中的所有命令序列化，然后按顺序执行。<br>1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。<br>2.如果在一个事务中的<strong>命令</strong>出现错误，那么<strong>所有的命令</strong>都不会执行；<br>3.如果在一个事务中出现<strong>运行错误</strong>，那么<strong>正确的命令</strong>会被执行。<br>注：redis的discard只是结束本次事务,正确命令造成的影响仍然存在.</p><p>1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。<br>2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。<br>3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。<br>4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</p><hr><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>Bitmaps 本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。</p><p>Bitmaps 单独提供了一套命令，所以在 Redis 使用 Bitmaps 和使用字符串的方法不太相同，可以把 Bitmaps 看作一个以位为单位的数组，数组的每个单元只能存储 0 和 1，数组的下标叫做偏移量。</p><h4 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h4><p>例：将每个独立用户是否访问过网站存放在 Bitmaps 中，将访问过的用户记作 1，没有访问过的记作 0，偏移量作为用户的 id。</p><p><strong>设置值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure><p>设置键的第 offset 个位的值，假设有 20 个用户，id 为 0、5、11、15、19 的用户对网站进行了访问，那么初始化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setbit unique:users:2020-06-20 0 1</span><br><span class="line">setbit unique:users:2020-06-20 5 1</span><br><span class="line">setbit unique:users:2020-06-20 11 1</span><br><span class="line">setbit unique:users:2020-06-20 15 1</span><br><span class="line">setbit unique:users:2020-06-20 19 1</span><br></pre></td></tr></table></figure><p>很多应用的用户 id 直接以一个指定数字开头，例如 10000，直接将用户 id 与 Bitmaps 的偏移量对应势必会造成一定浪费，通常做法是每次做 setbit 操作时将用户 id 减去这个指定数字。在第一次初始化 Bitmaps 时，如果偏移量非常大，那么整个初始化过程会执行比较慢，可能造成阻塞。</p><p><strong>获取值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure><p>获取键的第 offset 个位的值，例如获取 id 为 8 的用户是否在 2020-06-20 这天访问过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit unique:users:2020-06-20 8</span><br></pre></td></tr></table></figure><p><strong>获取指定范围值为 1 的个数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure><p>例如获取 2020-06-20 这天访问过的用户数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount unique:users:2020-06-20</span><br></pre></td></tr></table></figure><p>start 和 end 代表起始和结束字节数。</p><p><strong>Bitmaps 间的运算</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop op destkey key [key...]</span><br></pre></td></tr></table></figure><p>bitop 是一个复合操作，它可以做交集、并集、非、异或并将结果保存到 destkey 中。</p><p>例如计算 2020-06-20 和 2020-06-21 都访问过网站的用户数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitop and unique:users:and:2020-06-20_21 unique:users:2020-06-20 unique:users:2020-06-21</span><br><span class="line">bitcount unique:users:and:2020-06-20_21</span><br></pre></td></tr></table></figure><p>例如计算 2020-06-20 和 2020-06-21 任意一天访问过网站的用户数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitop or unique:users:or:2020-06-20_21 unique:users:2020-06-20 unique:users:2020-06-21</span><br><span class="line">bitcount unique:users:or:2020-06-20_21</span><br></pre></td></tr></table></figure><p><strong>计算第一个值为 tartgetBit 的偏移量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitops key targetBit [start] [end]</span><br></pre></td></tr></table></figure><p>例如计算 2020-06-20 当前访问网站的最小用户 id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitops unique:users:2019-06-20 1</span><br></pre></td></tr></table></figure><p>假设网站的活跃用户量很大，使用 Bitmaps 相比 set 可以节省很多内存，但如果活跃用户很少就会浪费内存。</p><hr><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>HyperLogLog 不是一种新的数据结构，实际也是字符串类型，是一种基数算法。提供 HyperLogLog 可以利用极小的内存空间完成独立总数的统计，数据集可以是 IP、Email、ID 等。</p><p><strong>添加</strong></p><p><code>pfadd key element [element...]</code>，如果添加成功会返回 1</p><p><strong>计算独立用户数</strong></p><p><code>pfcount key [key...]</code></p><p><strong>合并</strong></p><p><code>pfmerge destkey sourcekey [sourcekey...]</code></p><p>HyperLogLog 内存占用量非常小，但是存在错误率，开发者在进行数据结构选型时只需要确认如下两条：</p><ul><li>只为了计算独立总数，不需要获取单条数据。</li><li>可以容忍一定误差率，毕竟 HyperLogLog 在内存占用量上有很大优势。</li></ul><hr><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>Redis 提供了基于发布/订阅模式的消息机制，此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel）发送消息，订阅该频道的每个客户端都可以收到该消息。</p><h4 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h4><p><strong>发布消息</strong></p><p><code>publish channel message</code>，返回结果为订阅者的个数。</p><p><strong>订阅消息</strong></p><p><code>subscribe channel [channel..]</code>，订阅者可以订阅一个或多个频道。</p><p>客户端在执行订阅命令后会进入订阅状态，只能接收 subscribe、psubscribe、unsubscribe、punsubscribe 的四个命令。新开启的订阅客户端，无法收到该频道之前的消息，因为 Redis 不会对法捕的消息进行持久化。</p><p>和很多专业的消息队列系统如 Kafka、RocketMQ 相比，Redis 的发布订阅略显粗糙，例如无法实现消息堆积和回溯，但胜在足够简单，如果当前场景可以容忍这些缺点，也是一个不错的选择。</p><p><strong>取消订阅</strong></p><p><code>unsubscribe [channel [channel...]]</code></p><p>客户端可以通过 unsubscribe 命令取消对指定频道的订阅，取消成功后不会再收到该频道的发布消息。</p><p><strong>按照模式订阅和取消订阅</strong></p><p><code>psubscribe pattern [pattern...]</code></p><p><code>punsubscribe pattern [pattern...]</code></p><p>这两种命令支持 glob 风格，例如订阅所有以 it 开头的频道：<code>psubscribe it*</code></p><p><strong>查询订阅</strong></p><p>查看活跃的频道：<code>pubsub channels [pattern]</code>，活跃频道是指当前频道至少有一个订阅者。</p><p>查看频道订阅数：<code>pubsub numsub [channel ...]</code></p><p>查看模式订阅数：<code>pubsub numpat</code></p><hr><h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><p>聊天室、公告牌、服务之间利用消息解耦都可以使用发布订阅模式，以服务器解耦为例：视频管理系统负责管理视频信息，用户通过各种客户端获取视频信息。</p><p>假如视频管理员在视频管理系统中对视频信息进行了更新，希望及时通知给视频服务端，就可以采用发布订阅模式，发布视频信息变化的消息到指定频道，视频服务订阅这个频道及时更新视频信息，通过这种方式实现解耦。</p><p>视频服务订阅 video:changes 频道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe video:changes</span><br></pre></td></tr></table></figure><p>视频管理系统发布消息到 video:changes 频道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish video:changes &quot;video1,video3,video5&quot;</span><br></pre></td></tr></table></figure><p>视频服务收到消息，对视频信息进行更新..</p><hr><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>Redis 3.2 版本提供了 GEO 地理信息定位功能，支持存储地理位置信息用来实现诸如附近位置、摇一摇这一类依赖于地理位置信息的功能。</p><p><strong>增加地理位置信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member...]</span><br></pre></td></tr></table></figure><p>longitude、latitude、member 分别是该地理位置的经度、纬度、成员。</p><p>例如添加北京的地理位置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd cities:locations 116.28 39.55 beijing</span><br></pre></td></tr></table></figure><p>返回结果表示成功添加的个数，如果需要更新地理位置信息仍然可以使用 geoadd 命令，返回结果为 0。</p><p><strong>获取地理位置信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getpos key member [member...]</span><br></pre></td></tr></table></figure><p><strong>获取两个地理位置的距离</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure><p>其中 unit 代表返回结果的单位，包含 m 米、km 公里、mi 英里、ft 英尺。</p><p><strong>删除地理位置信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member</span><br></pre></td></tr></table></figure><p>GEO 没有提供删除成员的命令，但由于它底层是 zset，可以使用 zrem 删除。</p><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>慢查询中有两个重要参数 slowlog-log-slower-than 和 slowlog-max-len。</p><p>慢查询不包括命令网络传输和排队时间。</p><p>有必要将慢查询定期存放。</p><p>Pipeline 可以有效减少 RTT 次数，但每次 Pipeline 的命令数量不能无节制。</p><p>Redis 可以使用 Lua 脚本创造出原子、高效、自定义命令组合。</p><p>Bitmaps 可以用来做独立用户统计，有效节省内存。</p><p>Bitmaps 中 setbit 一个大的偏移量，由于申请大量内存会导致阻塞。</p><p>HyperLogLog 虽然在统计独立总量时存在一定误差，但是节省的内存量十分惊人。</p><p>Redis 的发布订阅相比许多专业消息队列系统功能较弱，不具备息堆积和回溯能力，但胜在足够简单。</p><p>Redis 3.2 提供了 GEO 功能，用来实现基于地理位置信息的应用，底层实现是 zset。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p><p>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p><p><img src="https://img-blog.csdnimg.cn/20191213103148681.png" alt="img"></p><p>使用SETNX完成同步锁的流程及事项如下：</p><p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</p><p>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p><p>释放锁，使用DEL命令将锁数据删除</p><h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>​    <strong>描述：</strong></p><p>​    缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p><p>   <strong>解决方案：</strong></p><ol><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ol><li><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol></li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p><strong>解决方案</strong></p><ol><li>设置热点数据永远不过期。</li><li>加互斥锁，互斥锁</li></ol><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>2）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="image"></p><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p><p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md" target="_blank" rel="noopener">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">**缓存穿透**是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</span><br><span class="line"></span><br><span class="line">**解决方案**</span><br><span class="line"></span><br><span class="line">1. 接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</span><br><span class="line">2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</span><br><span class="line">3. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</span><br><span class="line"></span><br><span class="line">**附加**</span><br><span class="line"></span><br><span class="line">对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</span><br><span class="line">Bitmap： 典型的就是哈希表</span><br><span class="line">缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</span><br><span class="line"></span><br><span class="line">布隆过滤器（推荐）</span><br><span class="line"></span><br><span class="line">就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</span><br><span class="line">它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</span><br><span class="line">Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</span><br><span class="line">Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。</span><br><span class="line">Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</span><br></pre></td></tr></table></figure><p>is 对象的个数，在极端情况下可能会造成连接泄露，而连接池的形式可以有效的保护和控制资源的使用。</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>直连</td><td>简单方便，适用于少量长期连接的场景。</td><td>存在每次连接关闭 TCP 连接的开销，资源无法控制可能出现连接泄露，Jedis 对象线程不安全</td></tr><tr><td>连接池</td><td>无需每次连接都生成 Jedis 对象降低开销，使用连接池的形式保护和控制资源的使用</td><td>相对于直连比较麻烦，尤其在资源的管理上需要很多参数来保证，一旦规划不合理也会出现问题</td></tr></tbody></table><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p><strong>快照（snapshotting）持久化（RDB）</strong></p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。默认的文件名为dump.rdb。</p><p><strong>1、save触发方式</strong></p><p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：</p><p><img src="https://pics1.baidu.com/feed/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg?token=7ed4cf784a82d04e60b8dc72cf7e3c24&s=EDBAA5565D1859C85444707E02005071" alt="img"></p><p>执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p><p><strong>2、bgsave触发方式</strong></p><p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p><p><img src="https://pics5.baidu.com/feed/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg?token=a72f072d65d2de548d71bb459cd0bf4f&s=05AAFE168FF04C8A10FD2DEE0300E032" alt="img"></p><p>具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</p><p><strong>3、自动触发</strong></p><p>自动触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：</p><p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><img src="https://pics5.baidu.com/feed/1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg?token=22f387ba78130c6115420059481b2393&s=EF48A15796784D8816E1D9EB03007024" alt="img"></p><p><strong>AOF（append-only file）持久化</strong></p><p>与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p><strong>RDB 的优势和劣势</strong></p><p>①、优势</p><p>（1）RDB，全量备份，非常适合用于进行备份和灾难恢复。</p><p>（2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p><p>（3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p><p>②、劣势</p><p>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p><p><strong>AOF 的优势和劣势</strong></p><p>(1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。</p><p>（2）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p><p><strong>5、缺点</strong></p><p>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p><p>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p><p><strong>相关 issue</strong> ：<a href="https://github.com/Snailclimb/JavaGuide/issues/783" target="_blank" rel="noopener">783：Redis 的 AOF 方式</a></p><hr><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(transaction)功能。</p><blockquote><p>MULTI<br>OK<br>INCR foo<br>QUEUED<br>INCR bar<br>QUEUED<br>EXEC</p></blockquote><p>1) (integer) 1<br>2) (integer) 1<br>Copy to clipboardErrorCopied<br>使用 MULTI命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了EXEC命令将执行所有命令。</p><p>Redis官网相关介绍 <a href="https://redis.io/topics/transactions" target="_blank" rel="noopener">https://redis.io/topics/transactions</a> 如下：</p><p>redis事务</p><p>但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： 1. 原子性，2. 隔离性，3. 持久性，4. 一致性。</p><p>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；<br>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；<br>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。<br>一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；<br>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</p><p>Redis官网也解释了自己为啥不支持回滚。简单来说就是Redis开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p><p>redis roll back</p><p>你可以将Redis中的事务就理解为 ：Redis事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</p><h3 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h3><p>文件事件处理器包括分别是<strong>套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器</strong>。使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。<br>I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br><strong>工作原理：</strong><br>1)I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br>尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字.<br><img src="https://img-blog.csdnimg.cn/20190429094050254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0J1dHRlcmZseV9yZXN0aW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>redis 提供 6种数据淘汰策略：</p><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从<strong>已设置过期时间</strong>的数据集（server.db[i].expires）中随机移除key</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-eviction：当内存不足以容纳新写入数据时，新写入操作会报错，无法写入新数据，一般不采用</li></ul><h3 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h3><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p><table><thead><tr><th>对比参数</th><th>Redis</th><th align="center">Memcached</th></tr></thead><tbody><tr><td>类型</td><td>1. 支持内存 2. 非关系型数据库</td><td align="center">1. 支持内存 2. 键值对形式 3. 缓存形式</td></tr><tr><td><strong>数据存储类型</strong></td><td>1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】</td><td align="center">只支持简单的key-value</td></tr><tr><td><strong>持久化支持</strong></td><td>1. RDB 2. AOF</td><td align="center">不支持</td></tr><tr><td><strong>集群模式</strong></td><td>原生支持 cluster 模式，可以实现主从复制，读写分离</td><td align="center">没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td></tr><tr><td>内存管理机制</td><td>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td><td align="center">Memcached 的数据则会一直在内存中，Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</td></tr></tbody></table><ul><li>存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。</li><li>数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。</li><li>用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>value的大小：<strong><em>\</em>redis可以达到1GB，而memcache只有1MB**</strong>。</li></ul><h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p><p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p><ol><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li></ol><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。<br>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="高并发情况下，对于Redis的更新操作有哪些注意事项？"><a href="#高并发情况下，对于Redis的更新操作有哪些注意事项？" class="headerlink" title="高并发情况下，对于Redis的更新操作有哪些注意事项？"></a>高并发情况下，对于Redis的更新操作有哪些注意事项？</h3><p>操作：先更新数据库，再删除缓存<br>正常的情况是这样的：  </p><ul><li>1、 先操作数据库，成功</li><li>2、再删除缓存，也成功</li><li>3、 如果原子性被破坏了：第一步成功(操作数据库)，第二步失败(删除缓存)，会导致数据库里是新数据，而缓存里是旧数据。</li></ul><p>如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。<br>如果在高并发的场景下，出现数据库与缓存数据不一致的概率特别低，也不是没有：缓存刚好失效//线程A查询数据库，得一个旧值//线程B将新值写入数据库//线程B删除缓存//线程A将查到的旧值写入缓存<br>要达成上述情况，还是说一句概率特别低,因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。对于这种策略，其实是一种设计模式：Cache Aside Pattern<br><strong>解决删除缓存失败的解决思路</strong>：将需要删除的key发送到消息队列中—自己消费消息，获得需要删除的key—不断重试删除操作，直到成功</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>Redis每次按key获取一个值的时候，都会更新value中的<strong>lru字段</strong>为当前秒级别的时间戳。</p><p>Redis初始的实现算法很简单，随机从dict中取出五个key,淘汰一个lru字段值最小的。</p><p>在3.0的时候，又改进了一版算法：</p><ul><li>首先第一次随机选取的key都会放入一个pool中(pool的大小为16)，pool中的key是按lru大小顺序排列的。</li><li>接下来每次随机选取的key <strong>lru值必须小于pool中最小的lru</strong>才会继续放入，直到将pool放满。</li><li>放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。</li><li><strong><em>\</em>淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰**</strong>。</li></ul><h3 id="Redis的IO复用"><a href="#Redis的IO复用" class="headerlink" title="Redis的IO复用"></a>Redis的IO复用</h3><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p><p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件： 1. 文件事件; 2. 时间事件。</p><p>时间事件不需要多花时间了解，我们接触最多的还是 <strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p><p>《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。</p><blockquote><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。</p><p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote><p>可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p><img src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png" alt="img"></p><h4 id="master结点挂了"><a href="#master结点挂了" class="headerlink" title="master结点挂了"></a>master结点挂了</h4><p>raft选举出新的leader</p><h3 id="节点间通信机制"><a href="#节点间通信机制" class="headerlink" title="节点间通信机制"></a>节点间通信机制</h3><p>支撑N个redis master node，每个master node都可以挂载多个slave node</p><p>读写分离的架构，对于每个master来说，写就写到master，然后读就从mater对应的slave去读</p><p>高可用，因为每个master都有salve节点，那么如果mater挂掉，redis cluster这套机制，就会自动将某个slave切换成master</p><h3 id="hash-slot"><a href="#hash-slot" class="headerlink" title="hash slot"></a>hash slot</h3><p>redis cluster有固定的16384个hash slot，对每个key计算CRC16值，然后对16384取模，可以获取key对应的hash slot</p><p>redis cluster中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot</p><h3 id="gossip？"><a href="#gossip？" class="headerlink" title="gossip？"></a>gossip？</h3><p>gossip协议包含多种消息，包括ping，pong，meet，fail，等等</p><p>Redis 集群是去中心化的，彼此之间状态同步靠 gossip 协议通信，集群的消息有以下几种类型：</p><ul><li><strong>Meet</strong> 通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群。</li><li><strong>Ping</strong> 节点每秒会向集群中其他节点发送 ping 消息，消息中带有自己已知的两个节点的地址、槽、状态信息、最后一次通信时间等。</li><li><strong>Pong</strong> 节点收到 ping 消息后会回复 pong 消息，消息中同样带有自己已知的两个节点信息。</li><li><strong>Fail</strong> 节点 ping 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。</li></ul><p><img src="https://pic3.zhimg.com/80/v2-0e5e3f73c7cc427a688c6d45cf1f445a_hd.jpg" alt="img"></p><h4 id="redis键的删除策略"><a href="#redis键的删除策略" class="headerlink" title="redis键的删除策略"></a>redis键的删除策略</h4><p>问题：如果一个键过期了，那么它什么时候会被删除呢？有三个答案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在过期时间来临时，立即执行对键的删除操作 .。</span><br></pre></td></tr></table></figure><p>这种过期策略对内存友好，但对CPU是非常不友好的。因为还要主动设定定时器并主动删除，即通过CPU换内存（CPU主动删除了内存中的数据嘛，CPU忙，内存空闲）。可以想象一下在大数据大并发的时候，这种机制是多么灾难</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">惰性删除(Lazy Expiration)：redis内部不会监视记录是否过期，但是每次从键空间获取键时，检查记录是否过期。这种技术被称为lazy（惰性）expiration。</span><br></pre></td></tr></table></figure><p>与定时删除相反，此删除机制对内存是不友好的对CPU是友好的，惰性删除不会主动去删除已到期(expire)的键，而是等有需要调用的时候再判断，即内存换CPU（内存中有大量残留数据）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定期删除：每隔一段时间，对redis数据库进行一次检查，删除里面的过期键</span><br></pre></td></tr></table></figure><p>属于前两种方法的折中.但要注意操作检查执行的时间和频率，如果删除操作做的太频繁，或者检查执行的时间太长，定期策略就会退化成定时策略。</p><p>Redis服务器实际使用的是惰性删除和定期删除策略两种策略，配合使用两种策略和在使用CPU和内存找到平衡点。</p><h4 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h4><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p>有几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.先更新redis再更新db</span><br><span class="line">2.先更新db再更新redis</span><br><span class="line">3.先更新DB再删除redis</span><br><span class="line">4.先删除redis再更新DB</span><br><span class="line">5.延迟双删</span><br><span class="line">6.延迟删除等变种</span><br></pre></td></tr></table></figure><h4 id="1-先更新redis再更新db"><a href="#1-先更新redis再更新db" class="headerlink" title="1.先更新redis再更新db"></a>1.先更新redis再更新db</h4><p>按下面步骤会有问题,AB是两个线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A_update_redis</span><br><span class="line">B_update_redis</span><br><span class="line">B_update_db</span><br><span class="line">A_update_db</span><br></pre></td></tr></table></figure><p>最终db是a值但是redis是b值，不一致</p><h4 id="2-先更新db再更新redis"><a href="#2-先更新db再更新redis" class="headerlink" title="2.先更新db再更新redis"></a>2.先更新db再更新redis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A_update_db</span><br><span class="line">B_update_db</span><br><span class="line">B_update_redis</span><br><span class="line">A_update_redis</span><br></pre></td></tr></table></figure><p>最终db是b值但是redis是a值</p><h4 id="3-先更新DB再删除redis"><a href="#3-先更新DB再删除redis" class="headerlink" title="3.先更新DB再删除redis"></a>3.先更新DB再删除redis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A_update_db</span><br><span class="line">B_update_db</span><br><span class="line">B_rm_redis</span><br><span class="line">A_rm_redis</span><br></pre></td></tr></table></figure><p>是不是不明白。想不出来怎么不一致了？<br> 不是这样的，没这么简单，第二次rm_redis就会保证后面的redis和db是一致的<br> 实际是下面这种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A_get_data</span><br><span class="line">redis_cache_miss</span><br><span class="line">A_get_db</span><br><span class="line">B_update_db</span><br><span class="line">B_rm_redis</span><br><span class="line">(此时如果拿db是b值，但是redis没有值)</span><br><span class="line">A_update_redis</span><br></pre></td></tr></table></figure><p>依赖于A_update_redis在B_update_db之后，极端情况<br> 此时redis是old，db是new</p><h4 id="4-先删除redis再更新DB"><a href="#4-先删除redis再更新DB" class="headerlink" title="4.先删除redis再更新DB"></a>4.先删除redis再更新DB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A_rm_redis</span><br><span class="line">B_get_data</span><br><span class="line">B_redis_miss</span><br><span class="line">B_get_db</span><br><span class="line">B_update_redis</span><br><span class="line">A_update_db</span><br></pre></td></tr></table></figure><p>此时redis是old值，db是new值</p><h4 id="5-延迟双删"><a href="#5-延迟双删" class="headerlink" title="5.延迟双删"></a>5.延迟双删</h4><p>即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm_redis</span><br><span class="line">update_db</span><br><span class="line">sleep xxx ms</span><br><span class="line">rm_redis</span><br></pre></td></tr></table></figure><p>这样叫做双删，最后一次sleep一段时间再rm_redis保证再次读请求回溯打到db，用最新值写redis</p><p>作者：赤子心_d709<br>链接：<a href="https://www.jianshu.com/p/125bba448cdd" target="_blank" rel="noopener">https://www.jianshu.com/p/125bba448cdd</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>I/O 多路复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跳跃表</title>
      <link href="/2020/07/05/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
      <url>/2020/07/05/%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>[TOC]</p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。上层结点都有指向下层结点的指针，从上往下每一层链表节点数递减。比如第一层有两个，第二层有四个，以此类推。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/27/16f4745348536f87?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="跳跃表-三级索引-寻找42"></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>看懂了跳跃表的数据结构，那么就很容易理解节点的插入操作了，基本上两步操作就可以实现：在最底层的数据链表中插入数据，然后调整索引；</p><p>其中每一层的索引链表中是否需要增加新增的节点，其实并没有什么标准答案，我们尽量做到索引的平均分布即可，常用的就是【随机判断】决定是否需要新增或调整索引，当有新节点插入的时候，通过概率算法判断这个节点需要插入到几级节点中。</p><p>比如：</p><ul><li>底层数据链表有 N 个元素，随机选择 N/2 个元素作为 1 级索引，随机选择 N/4 个元素作为 2 级索引…一直到顶层索引；</li><li>新插入数据节点，1/2 概率不插入任何一级索引，1/4 概率返回需要插入 1 级索引，1/8 概率返回需要插入到 2 级索引，以此类推；</li><li>这里要注意一点，插入 2 级索引的时候，同时也需要插入 1 级索引；也就是插入 n 级索引的时候，同时也要插入 1~( n-1 ) 级索引。</li></ul><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>通过一个bit数组来存储特定数据的一种数据结构,每一个bit位都能独立包含信息,bit是数据的最小存储单元,因此能大量节省空间</p><p>按下标从数组的高位(左)向低位(右)取值,bit数组起始值全为0,从左到右取下标(下标从0开始),数组的每个元素值就是一个下标值.将元素对应的下标在bit位上的值改为1</p><p>举例:数组[2,5,3,8] 起始000000000 元素2对应下标2,<br>将左到右的下标2的值改为1 –&gt; 001000000————————————————</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql相关</title>
      <link href="/2020/07/05/sql%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/07/05/sql%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="左连接和内联的区别"><a href="#左连接和内联的区别" class="headerlink" title="左连接和内联的区别"></a>左连接和内联的区别</h2><p><strong>左连接：左边有的，右边没有的为null</strong></p><p><strong>右连接：左边没有的，右边有的为null</strong></p><p><strong>内连接：显示左边右边共有的</strong></p><p><img src="https://img-blog.csdnimg.cn/20200705154749515.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200705154850251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>左连接</p><p><img src="https://img-blog.csdnimg.cn/20200705155226877.png" alt="在这里插入图片描述"></p><p>内连接</p><p><img src="https://img-blog.csdnimg.cn/20200705155007995.png" alt="在这里插入图片描述"></p><p>右连接</p><p><img src="https://img-blog.csdnimg.cn/20200705154938172.png" alt="在这里插入图片描述"></p><h2 id="like和in关键字"><a href="#like和in关键字" class="headerlink" title="like和in关键字"></a>like和in关键字</h2><p>LIKE：</p><p>当无法确切知道所要查找的值，而是知道所要查找的数据符合的模式时，可以使用LIKE 子句进行匹配。一般来说，LIKE 子句仅在字符串类型时使用，但对数字类型数据是不能使用 LIKE 子句的。</p><p>不在 LIKE子句中使用时， 就不具有特殊的含义，仅表示其本身的值。</p><p>IN：</p><p>当确切知道所要查找的内容，且为多个值时，可以使用 IN 子句来进行数据比较</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一条SQL查询语句的执行过程</title>
      <link href="/2020/07/05/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/07/05/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>输入下面一条SQL语句，我们来分析下这条语句在MySQL内部的执行过程。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190109110912557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bjd2wxMjA2,size_16,color_FFFFFF,t_70" alt="img"></p><p>体来说，MySQL 可以分为 Server 层和存储引擎两部分。</p><p>Server 层包括：连接器、查询缓存、分析器、优化器、执行器等，涵盖了 MySQL 的大多数核心服务功能，以及所有的内置函数（如：日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如：存储过程、触发器、视图等等。</p><p>存储引擎层负责：数据的存储和提取。其架构是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。从MySQL5.5.5版本开始默认的是InnoDB，但是在建表时可以通过 engine = MyISAM 来指定存储引擎。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p><p>从图中可以看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。</p><h2 id="1、连接器"><a href="#1、连接器" class="headerlink" title="1、连接器"></a>1、连接器</h2><p> 第一步，要首先连接上数据库，这个时候使用的就是连接器。</p><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功创建以后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://img-blog.csdnimg.cn/20190109112901965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bjd2wxMjA2,size_16,color_FFFFFF,t_70" alt="img"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p><p><strong>数据库中的长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接指的是每次执行完很少的几次查询就断开连接，下次查询时再重新建立一个。</strong></p><p>但是如果连接都使用长连接的话，你可能会发现，有时候 MySQL 占用内存涨的特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才会释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象上看就是 MySQL 异常重启了。</p><p>那么怎么解决这个问题呢？下面提供两种解决方案：</p><blockquote><p>1、<strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，释放资源，之后要查询的时候再重连。 </p><p>2、如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过<strong>执行 mysql_reset_connection 来重新初始化连接资源</strong>。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p></blockquote><h2 id="2、查询缓存"><a href="#2、查询缓存" class="headerlink" title="2、查询缓存"></a>2、查询缓存</h2><p>连接建立完成后，就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p><p><strong>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果都会以key-value 对的形式，被直接缓存到内存中。其中，\</strong>key 是查询的语句，value 是查询的结果*<em>。如果你的查询能够直接在缓存中找到 key，那么这个 value 就会直接返回给客户端。*</em></p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><ul><li><p><strong>但是大多数情况下不建议使用查询缓存 —&gt; 因为查询缓存往往弊大于利</strong></p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你刚费劲存的结果还没来得及使用就被一个更新给清空了。</p></li></ul><p>对于更新压力大的数据库而言，查询缓存的命中率就会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>默认的 SQL 语句是不缓存的，可以显示的指定查询缓存：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10;</span><br></pre></td></tr></table></figure><p>需要说明的是：MySQL 8.0版本已经将查询缓存功能删除了。</p><h2 id="3、分析器"><a href="#3、分析器" class="headerlink" title="3、分析器"></a>3、分析器</h2><p>如果没有命中查询缓存，就要开始正真执行语句了。首先，MySQL 需要知道你要做什么，因此要对 SQL 语句做解析。</p><p>分析器先会做“词法分析”。MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>做完了这些识别以后，就要做“语法分析”。语法分析根据语法规则，判断输入的这个 SQL语句是否满足 MySQL 的语法规范。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID=1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; <span class="keyword">check</span> the <span class="keyword">manual</span> that corresponds <span class="keyword">to</span> your MySQL <span class="keyword">server</span> <span class="keyword">version</span> <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> <span class="keyword">use</span> near <span class="string">'elect * from t where ID=1'</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><h2 id="4、优化器"><a href="#4、优化器" class="headerlink" title="4、优化器"></a>4、优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始之前还要经过优化器的处理。</p><p>优化器是在表里有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而<strong>优化器的作用就是决定选择使用哪一个方案</strong>。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h2 id="5、执行器"><a href="#5、执行器" class="headerlink" title="5、执行器"></a>5、执行器</h2><p> MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。</p><p>如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): <span class="keyword">SELECT</span> command denied <span class="keyword">to</span> <span class="keyword">user</span> <span class="string">'b'</span>@<span class="string">'localhost'</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">'T'</span></span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行流程是这样的：</p><p>1、调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</p><p>2、调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行；</p><p>3、执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p><strong>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>隔离级别serilizable</title>
      <link href="/2020/07/05/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABserilizable/"/>
      <url>/2020/07/05/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABserilizable/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="如何实现的"><a href="#如何实现的" class="headerlink" title="如何实现的"></a>如何实现的</h2><p>在SERIALIZABLE级别下，不会使用mysql的mvcc机制，而是在每一个select请求下获得读锁，在每一个update操作下尝试获得写锁。</p><p>对于insert、update、delete，InnoDB会自动给涉及的数据加写锁；对于一般的Select语句，InnoDB不会加任何锁</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2020/07/04/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2020/07/04/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZGC和Shenandoah</title>
      <link href="/2020/07/04/ZGC%E5%92%8CShenandoah/"/>
      <url>/2020/07/04/ZGC%E5%92%8CShenandoah/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h2><p>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际是非常少的。那么其他阶段是怎么做到可以并发执行的呢？</p><p>ZGC主要新增了两项技术，一个是<strong>着色指针Colored Pointer</strong>，另一个是<strong>读屏障Load Barrier</strong>。</p><p><strong>着色指针Colored Pointer</strong><br> ZGC利用指针的64位中的几位表示Finalizable、Remapped、Marked1、Marked0（ZGC仅支持64位平台），以标记该指向内存的存储状态。相当于在对象的指针上标注了对象的信息。注意，这里的指针相当于Java术语当中的引用。</p><p>在这个被指向的内存发生变化的时候（内存在Compact被移动时），颜色就会发生变化。</p><p>在G1的时候就说到过，Compact阶段是需要STW，否则会影响用户线程执行。那么怎么解决这个问题呢？</p><p><strong>读屏障Load Barrier</strong> 由于着色指针的存在，在程序运行时访问对象的时候，可以轻易知道对象在内存的存储状态（通过指针访问对象），若请求读的内存在被着色了。那么则会触发读屏障。读屏障会更新指针再返回结果，此过程有一定的耗费，从而达到与用户线程并发的效果。</p><p>把这两项技术联合下理解，引用R大（RednaxelaFX）的话</p><blockquote><p>与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。</p></blockquote><p>链接：<a href="https://juejin.im/post/5bade237e51d450ea401fd71" target="_blank" rel="noopener">https://juejin.im/post/5bade237e51d450ea401fd71</a></p><h2 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h2><p>相比 G1 内存布局同样基于 Region，默认回收策略也是优先处理回收价值最大的 Region。但在管理堆内存方面，与 G1 有不同：① 支持并发整理，G1 的回收阶段不能与用户线程并发。②默认不使用分代收集，不会有专门的新生代 Region 或老年代 Region。③ 摒弃了在 G1 中耗费大量内存和计算资源去维护的记忆集，改用名为连接矩阵的全局数据结构来记录跨 Region 的引用关系。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/2020/07/04/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2020/07/04/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong><em>对于socket流而言,数据的流向经历两个阶段：\</em></strong></p><ul><li>第一步通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li><li>第二步把数据从内核缓冲区复制到应用进程缓冲区。</li></ul><p>recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中</p><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p><blockquote><p>blocking IO的特点就是在IO执行的两个阶段都被block了。</p></blockquote><h2 id="非阻塞式-I-O"><a href="#非阻塞式-I-O" class="headerlink" title="非阻塞式 I/O"></a>非阻塞式 I/O</h2><p>应用进程可以继续执行，但是需要不断的执行系统调用来获知I/O 是否完成，这种方式称为轮询（polling）。</p><blockquote><p><strong>此时的非阻塞IO只是应用到等待数据上,当真正有数据到达执行recvfrom的时候,还是同步阻塞IO来的</strong></p></blockquote><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>同步异步指的是被调用者结果返回时通知线程的一种机制，阻塞非阻塞指的是调用结果返回前 线程的状态，是挂起还是继续处理其他任务。</p><h2 id="I-O-复用"><a href="#I-O-复用" class="headerlink" title="I/O 复用"></a>I/O 复用</h2><p>主要有 三种机制，分别是select  poll epoll  ，让它们等待数据，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p><p>好处:<br>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，<br>那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开<br>销更小。<br><img src="https://img-blog.csdnimg.cn/20200715094639319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="img"></p><p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval</span><br><span class="line">*timeout);</span><br></pre></td></tr></table></figure><p>有三种类型的描述符类型：readfds、writefds、exceptdfs，分别对应读、写、异常条件的描述符集合。fd_set 使用<br>数组实现，数组大小使用 FD_SETSIZE 定义。</p><p><strong>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</strong></p><p>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fd_set fd_in, fd_out;</span><br><span class="line">struct timeval tv;</span><br><span class="line">&#x2F;&#x2F; Reset the sets</span><br><span class="line">FD_ZERO( &amp;fd_in );</span><br><span class="line">FD_ZERO( &amp;fd_out );</span><br><span class="line">&#x2F;&#x2F; Monitor sock1 for input events</span><br><span class="line">FD_SET( sock1, &amp;fd_in );</span><br><span class="line">&#x2F;&#x2F; Monitor sock2 for output events</span><br><span class="line">FD_SET( sock2, &amp;fd_out );</span><br><span class="line">&#x2F;&#x2F; Find out which socket has the largest numeric value as select requires it</span><br><span class="line">int largest_sock &#x3D; sock1 &gt; sock2 ? sock1 : sock2;</span><br><span class="line">&#x2F;&#x2F; Wait up to 10 seconds</span><br><span class="line">tv.tv_sec &#x3D; 10;</span><br><span class="line">tv.tv_usec &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; Call the select</span><br><span class="line">int ret &#x3D; select( largest_sock + 1, &amp;fd_in, &amp;fd_out, NULL, &amp;tv );</span><br><span class="line">&#x2F;&#x2F; Check if select actually succeed</span><br><span class="line">if ( ret &#x3D;&#x3D; -1 )</span><br><span class="line">&#x2F;&#x2F; report error and abort</span><br><span class="line">else if ( ret &#x3D;&#x3D; 0 )</span><br><span class="line">&#x2F;&#x2F; timeout; no event detected</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if ( FD_ISSET( sock1, &amp;fd_in ) )</span><br><span class="line">&#x2F;&#x2F; input event on sock1</span><br><span class="line">if ( FD_ISSET( sock2, &amp;fd_out ) )</span><br><span class="line">&#x2F;&#x2F; output event on sock2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>int poll(struct pollfd *fds, unsigned int nfds, int timeout);</p><p>poll 的机制与 select 类似，与 select 在本质上没有多大差别，但是 poll 没有最大文件描述符数量的限制。poll改变了fds集合的描述方式，使用了pollfd结构而不是select的fd_set结构 .pollfd 使用链表实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The structure for two events</span><br><span class="line">struct pollfd fds[2];</span><br><span class="line">&#x2F;&#x2F; Monitor sock1 for input</span><br><span class="line">fds[0].fd &#x3D; sock1;</span><br><span class="line">fds[0].events &#x3D; POLLIN;</span><br><span class="line">&#x2F;&#x2F; Monitor sock2 for output</span><br><span class="line">fds[1].fd &#x3D; sock2;</span><br><span class="line">fds[1].events &#x3D; POLLOUT;</span><br><span class="line">&#x2F;&#x2F; Wait 10 seconds</span><br><span class="line">int ret &#x3D; poll( &amp;fds, 2, 10000 );</span><br><span class="line">&#x2F;&#x2F; Check if poll actually succeed</span><br><span class="line">if ( ret &#x3D;&#x3D; -1 )</span><br><span class="line">&#x2F;&#x2F; report error and abort</span><br><span class="line">else if ( ret &#x3D;&#x3D; 0 )</span><br><span class="line">&#x2F;&#x2F; timeout; no event detected</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; If we detect the event, zero it out so we can reuse the structure</span><br><span class="line">if ( fds[0].revents &amp; POLLIN )</span><br><span class="line">fds[0].revents &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; input event on sock1</span><br><span class="line">if ( fds[1].revents &amp; POLLOUT )</span><br><span class="line">fds[1].revents &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; output event on sock2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ol><li><p>功能<br>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p><p>select 会修改描述符，而 poll 不会；<br>select 的描述符类型使用数组实现，大小默认为 1024，因此默认只能监听 1024 个描述符。而 poll 的描述符类型使用链表实现，没有描述符数量的限制；<br>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。<br>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</p></li><li><p>速度<br>select 和 poll 速度都比较慢。<br>select 和 poll 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。<br>select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用<br>轮询的方式来找到 I/O 完成的描述符。</p></li><li><p>可移植性<br>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p></li></ol><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure><p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<br>红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事<br>件完成的描述符。<br>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获<br>得事件完成的描述符。</p><p>epoll 仅适用于 Linux OS。<br>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和<br>poll 的不确定情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Create the epoll descriptor. Only one is needed per app, and is used to monitor all</span><br><span class="line">sockets.</span><br><span class="line">&#x2F;&#x2F; The function argument is ignored (it was not before, but now it is), so put your favorite</span><br><span class="line">number here</span><br><span class="line">int pollingfd &#x3D; epoll_create( 0xCAFE );</span><br><span class="line">if ( pollingfd &lt; 0 )</span><br><span class="line">&#x2F;&#x2F; report error</span><br><span class="line">&#x2F;&#x2F; Initialize the epoll structure in case more members are added in future</span><br><span class="line">struct epoll_event ev &#x3D; &#123; 0 &#125;;</span><br><span class="line">&#x2F;&#x2F; Associate the connection class instance with the event. You can associate anything</span><br><span class="line">&#x2F;&#x2F; you want, epoll does not use this information. We store a connection class pointer,</span><br><span class="line">pConnection1</span><br><span class="line">ev.data.ptr &#x3D; pConnection1;</span><br><span class="line">&#x2F;&#x2F; Monitor for input, and do not automatically rearm the descriptor after the event</span><br><span class="line">ev.events &#x3D; EPOLLIN | EPOLLONESHOT;</span><br><span class="line">&#x2F;&#x2F; Add the descriptor into the monitoring list. We can do it even if another thread is</span><br><span class="line">&#x2F;&#x2F; waiting in epoll_wait - the descriptor will be properly added</span><br><span class="line">if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) !&#x3D; 0 )</span><br><span class="line">&#x2F;&#x2F; report error</span><br><span class="line">&#x2F;&#x2F; Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may</span><br><span class="line">happen)</span><br><span class="line">struct epoll_event pevents[ 20 ];</span><br><span class="line">&#x2F;&#x2F; Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into</span><br><span class="line">epoll_event array</span><br><span class="line">int ready &#x3D; epoll_wait( pollingfd, pevents, 20, 10000 );</span><br><span class="line">&#x2F;&#x2F; Check if epoll actually succeed</span><br><span class="line">if ( ret &#x3D;&#x3D; -1 )</span><br><span class="line">&#x2F;&#x2F; report error and abort</span><br><span class="line">else if ( ret &#x3D;&#x3D; 0 )</span><br><span class="line">&#x2F;&#x2F; timeout; no event detected</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; Check if any events detected</span><br><span class="line">for ( int i &#x3D; 0; i &lt; ret; i++ )</span><br><span class="line">&#123;</span><br><span class="line">if ( pevents[i].events &amp; EPOLLIN )</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; Get back our connection pointer</span><br><span class="line">Connection * c &#x3D; (Connection*) pevents[i].data.ptr;</span><br><span class="line">c-&gt;handleReadEvent();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p><ol><li><p>LT 模式<br>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait()<br>会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p></li><li><p>ET 模式<br>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。<br>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个<br>文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><blockquote><p>triggered代表电路激活，也就是有事件通知给程序，level-triggered表示只要有IO操作可以进行比如某个文件描述符有数据可读，每次调用epoll_wait都会返回以通知程序可以进行IO操作，edge-triggered表示只有在文件描述符状态发生变化时，调用epoll_wait才会返回，如果第一次没有全部读完该文件描述符的数据而且没有新数据写入，再次调用epoll_wait都不会有通知给到程序，因为文件描述符的状态没有变化</p><p>作者：技术成长之道<br>链接：<a href="https://juejin.im/post/5e770c5ee51d4526ef5fb554" target="_blank" rel="noopener">https://juejin.im/post/5e770c5ee51d4526ef5fb554</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote></li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><ol><li>select 应用场景<br>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比<br>如核反应堆的控制。<br>select 可移植性更好，几乎被所有主流平台所支持。</li><li>poll 应用场景<br>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</li><li>epoll 应用场景<br>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。<br>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。<br>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在<br>内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且<br>epoll 的描述符存储在内核，不容易调试。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>公平锁和非公平锁</title>
      <link href="/2020/07/04/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/"/>
      <url>/2020/07/04/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li></ul><p>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><ul><li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点.因为通常情况下挂起的线程重新开始与它真正开始运行，二者之间会产生严重的延时。</li><li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对象头由什么构成</title>
      <link href="/2020/07/04/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%94%B1%E4%BB%80%E4%B9%88%E6%9E%84%E6%88%90/"/>
      <url>/2020/07/04/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%94%B1%E4%BB%80%E4%B9%88%E6%9E%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>对象布局</p><p>在JVM中，对象在内存中的布局分为3块：</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>主要用于储存对象自身的运行时数据，例如对象的hashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程的ID、偏向时间戳</p><h3 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h3><p>而类型指针用于标识JVM通过这个指针来确定这个对象是哪个类的实例。</p><p><img src="https://pic1.zhimg.com/80/v2-e47232518a4e042f31a9e0eb6a48f88c_1440w.jpg" alt="img"></p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>它存储着对象真正的有效信息(程序代码中定义的各种类型的字段内容)，无论是从父类继承来的字段还是子类中定义的</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>它并没有什么特殊的含义，仅仅只是起占位符的作用。原因呢是因为JVM要求对象的起始地址必须是8个字节的整数倍(对象的大小必须是8个字节的整数倍)</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sleep和wait的区别</title>
      <link href="/2020/07/04/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/04/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>1.sleep() 方法正在执行的线程主动让出 cpu（然后 cpu 就可以去执行其他任务），在 sleep 指定时间后 cpu 再回到该线程继续往下执行（注意：sleep 方法只让出了 cpu，而并不会释放同步资源锁）；wait() 是 Object 的方法，调用会放弃对象锁，进入等待队列，待调用 notify()/notifyAll() 唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态。（注意：notify 的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说 notify 只是让之前调用 wait 的线程有权利重新参与线程的调度）；</p><p>2.sleep() 方法可以在任何地方使用，而 wait() 方法则只能在同步方法或同步块中使用；</p><h2 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h2><p><strong>wait、notify原理</strong></p><p>在前面以经说到对象锁的本质，重量级锁模式时对象头是一个指向互斥量的指针，实际上互斥量就是一个监视器锁（ObjectMonitor）的数据结构，此时对象的hashCode、分代年龄等信息都会保存到对应的ObjectMonitor中，ObjectMonitor还有一些属性如recursion记录本锁被重入的次数，EntrySet记录想获取本锁的线程集合，WaitSet记录等待本锁的线程，TheOwner记录拥有本锁的线程对象。如下：</p><p><img src="https://img2018.cnblogs.com/blog/1743446/201907/1743446-20190729174119167-1716466123.png" alt="img"></p><p>（图片来源于网络）</p><p>几个线程一起竞争对象的锁（EntrySet），只有一个能成功（acquire），成功的线程记录在The Owner中。调用wait、notify运行流程如下：</p><p>​    （1） 现有一个对象o，锁正在被线程 t1 持有，调用wait()方法后，线程 t1 将会被”晾到” (实际上仅仅是记录到) Wait Set 结构中。</p><p>​    （2）然后将会有另一个线程 t2 获取到锁，The Owner记录的变成了 t2 线程。</p><p>​    （3）t2 线程不需要 o的锁时，调用o.notify()/o.notifyAll()方法，对象o就会告诉 Wait Set结构中记录的线程们：你们又可以来竞争我啦，我的锁现在没被人持有。</p><p><strong>简单的说就是：wait是对象通知持有自己锁的线程释放我的锁，notify()/notifyAll()就是对象通知刚刚被自己晾在一边的线程又可以来竞争我的锁了。</strong>我想到了一个比较贴切的比喻：</p><p>​    客人（线程）来拜访主人（对象），必须获得主人的时间权（锁），且主人同时只能接待一人（互斥）。</p><p>​    正在客厅接待一名客人时，因为一些原因主人必须先接待另一位客人，这时主人请当前客人去另一间房里等待，让出自己的时间权（wait方法）</p><p>​    主人在客厅接待另一位客人，接待完毕后，让前一位（也可能有几位）在另一间房等待的客人再来到客厅，继续接待（notify/notifyAll方法）</p><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起并释放锁。当其他线程的运行使得这个条件满足时，其它线程<br>会调用 notify() 。<br>它们都属于 Object 的一部分，而不属于 Thread。只能用在同步方法或者同步控制块中使用，</p><p>notify不会释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"T1 start!"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"T1 end!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"T2 start!"</span>);</span><br><span class="line">                    object.notify();</span><br><span class="line">                    System.out.println(<span class="string">"T2 end!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T1 start!</span><br><span class="line">T2 start!</span><br><span class="line">T2 end!</span><br><span class="line">T1 end!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程的区别和相关问题</title>
      <link href="/2020/07/03/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/03/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念。</p><p>· 线程：是进程的一个执行单元，是独立运行的基本单位。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>•开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源。线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>· 调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程</p><p>中的线程时，会引起进程切换。</p><p>· 通信方面</p><p>进程有独立的地址空间，线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p><h2 id="进程的内存空间"><a href="#进程的内存空间" class="headerlink" title="进程的内存空间"></a>进程的内存空间</h2><p>内核态内存空间、用户态的堆栈（一般8M，从高地址向低地址增长）、数据段、进程代码段</p><p>进程间通信方式</p><p>进程间通信方式：管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket等</p><ul><li>管道:无名管道, 半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。只能用于父子进程和兄弟进程。</li><li>FIFO：也称为命名管道，去除了管道只能在父子进程中使用的限制。</li><li>消息队列</li></ul><p>1.消息队列存放于内核中，可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</p><p>2.避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</p><p>3.读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</p><ul><li>信号量是一个计数器，用于实现进程间的互斥与同步。信号量基于操作系统的 PV 操作。每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li><li>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li><li>套接字：与其它通信机制不同的是，它可用于不同机器间的进程通信。</li></ul><h2 id="进程同步方式？"><a href="#进程同步方式？" class="headerlink" title="进程同步方式？"></a>进程同步方式？</h2><p>1.临界区</p><p>对临界资源进行访问的那段代码称为临界区。</p><p>2.同步与互斥</p><p>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</p><p>互斥：多个进程在同一时刻只有一个进程能进入临界区。</p><p>3.信号量：</p><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><p>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</p><p>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</p><h2 id="线程共享和线程私有的"><a href="#线程共享和线程私有的" class="headerlink" title="线程共享和线程私有的"></a>线程共享和线程私有的</h2><p>线程共享的有：进程代码段、进程共有数据等</p><p>线程私有的：线程ID、寄存器的值、线程的栈</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>就绪，运行，阻塞。</p><p>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。运行缺少资源会变为阻塞。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>B树和B+树的区别?</title>
      <link href="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><img src="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" class><p><img src="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201103195345798.png" alt="image-20201103195345798"></p><p>B Tree 指的是 Balance Tree，也就是平衡树，相当于是一棵多叉查找树，对于一棵 m 阶的 B 树具有如下特性：</p><p>1、根节点至少有两个孩子。</p><p>2、每个中间节点都包含 k - 1 个元素和 k 个孩子，其中 ceil(m/2) &lt;= k &lt;= m。</p><p>3、每个节点中的元素从小到大排列，节点当中的 k - 1 个元素正好是 k 个孩子包含的元素的值域划分。</p><p>4、每一个叶子节点都包含 k - 1 个元素，其中 ceil(m/2) &lt;= k &lt;= m。</p><p>5、所有的叶子节点都位于同一侧。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><img src="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" class><p><img src="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201103195404475.png" alt="image-20201103195404475"></p><p>1.有n棵子树的结点中含有n-1 个关键字； </p><p> 2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树剖析</title>
      <link href="/2020/07/03/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/03/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>红黑树是自平衡的二叉查找树</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03bae101f8c99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>性质1：每个节点要么是红色，要么是黑色。</p><p>性质2：根节点永远是黑色的。</p><p>性质3：所有的叶子节点都是空节点（即null），并且是黑色的。</p><p>性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点。）</p><p>性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>红黑树的插入主要分两步：</p><ul><li><p>首先和二叉查找树的插入一样，查找、插入</p></li><li><p>然后调整结构，保证满足红黑树状态</p><ul><li><p>对结点进行重新着色</p></li><li><p>以及对树进行相关的旋转操作</p></li></ul></li></ul><p>一般情况下，红黑树中新插入的节点都是红色的。因为我们从性质5中知道，当前红黑树中从根节点到每个叶子节点的黑色节点数量是一样的，此时假如新的黑色节点的话，必然破坏规则，但加入红色节点却不一定，除非其父节点就是红色节点，因此加入红色节点，破坏规则的可能性小一些。</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>LL</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03baf6b875784?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>LR（插入节点的父节点是左节点，插入节点是右节点）</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03bbc0efb78e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>RR</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03be147552958?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>RL</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03bd41c1d7d63?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>  IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查.<br>  ngnix中,用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器.<br>  java中TreeMap，jdk1.8的hashmap的实现.</p><h2 id="与平衡树的区别"><a href="#与平衡树的区别" class="headerlink" title="与平衡树的区别"></a>与平衡树的区别</h2><p>1.红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。红黑树放弃了追求完全平衡，追求大致平衡</p><p>2.平衡二叉树,每次插入新节点之后需要旋转的次数不能预知。</p><h2 id="平衡树的概念"><a href="#平衡树的概念" class="headerlink" title="平衡树的概念"></a>平衡树的概念</h2><p>平衡二叉树必须是排序二叉树</p><p>左子树和右子树的深度之差的绝对值不超过1。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>平台无关性、机器码、字节码、与C++区别</title>
      <link href="/2020/07/03/%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2020/07/03/%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="无关性"><a href="#无关性" class="headerlink" title="无关性:"></a>无关性:</h2><p><strong>在一个计算机上编译得到的字节码文件（就是.class文件），可以复制到任何一个安装了Java运行环境的计算机上直接运行。然后字节码文件由虚拟机负责解释执行，即Java虚拟机将字节码翻译成本地计算机的机器码，然后将机器码交给本地的操作系统运行。</strong></p><p> C/C++程序是依赖平台的：C/C++源程序所在的特定平台对其源文件进行编译、链接，生成机器指令，即<strong>根据当前平台的机器指令生成可执行文件</strong> 不能保证在所有平台上都能正确的运行，其原因是不同平台可能具有不同的机器指令</p><p>Java在计算机的操作系统上又提供了一个Java运行环境——JRE,只要平台提供了Java运行环境，Java编写的软件就可以在其上运行。</p><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h2><p>机器码是电脑的CPU可直接解读的数据，通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。</p><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>字节码（Bytecode）是一种包含执行程序的<strong>二进制文件</strong>。<strong>字节码是一种中间码</strong>，在运行时通过JVM（JAVA虚拟机）做一次转换生成机器指令，因此能够更好的跨平台运行。</p><h2 id="与C-区别"><a href="#与C-区别" class="headerlink" title="与C++区别"></a>与C++区别</h2><p>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持<br>面向过程。<br>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。<br>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。<br>Java 支持自动垃圾回收，而 C++ 需要手动回收。<br>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编代码通常意味着机器的母语(所谓的机器语言)的人类可读形式</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nio、Bio、Aio</title>
      <link href="/2020/07/03/Nio%E3%80%81Bio%E3%80%81Aio/"/>
      <url>/2020/07/03/Nio%E3%80%81Bio%E3%80%81Aio/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>BIO （Blocking I/O）：同步阻塞I/O模式。</strong></p><p><strong>NIO （New I/O）：同步非阻塞模式。</strong></p><p><strong>AIO （Asynchronous I/O）：异步非阻塞I/O模型。</strong></p><p><strong>同步异步指的是被调用者结果返回时通知线程的一种机制，阻塞非阻塞指的是调用结果返回前 线程的状态，是挂起还是继续处理其他任务。</strong></p><p>同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p><p>而异步则是相反，<strong><em>调用\</em>在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>阻塞和非阻塞关注的是<strong>程序在等待调用结果时的状态.</strong></p><p>同步阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。</p><p>同步非阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是回到客厅看电视，然后每隔几分钟到厨房看一下水有没有烧开。</p><p>异步非阻塞I/O模型：这种模式下，我们的工作模式是先来到厨房，开始烧水，我们不一一直坐在水壶前面等，也不隔一段时间去看一下，而是在客厅看电视，水壶上面有个开关，水烧开之后他会通知我。</p><p>阻塞VS非阻塞：人是否坐在水壶前面一直等。</p><p>同步VS异步：水壶是不是在水烧开之后主动通知人。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Bio</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class test implements Runnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     test t&#x3D;new test();</span><br><span class="line">     Thread t1&#x3D;new Thread(t);</span><br><span class="line">     t1.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Socket client&#x3D;new Socket(InetAddress.getLocalHost(),8888);</span><br><span class="line">            BufferedReader bufferedReader &#x3D; new BufferedReader</span><br><span class="line">                    (new InputStreamReader</span><br><span class="line">                            (client.getInputStream()));</span><br><span class="line">            System.out.println(&quot;值: &quot;+bufferedReader.readLine());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerSocket serverSocket&#x3D;new ServerSocket(8888);</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                Socket socket&#x3D;serverSocket.accept();</span><br><span class="line">                try (PrintWriter out &#x3D; new PrintWriter(socket.getOutputStream());) &#123;</span><br><span class="line">                    out.println(&quot;Hello world!&quot;);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>服务器端启动 ServerSocket，端口 0 表示自动绑定一个空闲端口。</p></li><li><p>调用 accept 方法，阻塞等待客户端连接。</p></li><li><p>利用 Socket 模拟了一个简单的客户端，只进行连接、读取、打印。</p></li><li><p>当连接建立后，启动一个单独线程负责回复客户端请求。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/14/1697c8d55677ce94?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li></ul><p>Nio</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class NioExample extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try (Selector selector &#x3D; Selector.open();</span><br><span class="line">             ServerSocketChannel serverSocket &#x3D; ServerSocketChannel.open();)</span><br><span class="line">        &#123;&#x2F;&#x2F; 创建 Selector 和 Channel</span><br><span class="line">            serverSocket.bind(new InetSocketAddress(InetAddress.getLocalHost(), 8888));</span><br><span class="line">            serverSocket.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F; 注册到 Selector，并说明关注点</span><br><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                selector.select();&#x2F;&#x2F; 阻塞等待就绪的 Channel，这是关键点之一</span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys &#x3D; selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter &#x3D; selectedKeys.iterator();</span><br><span class="line">                while (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key &#x3D; iter.next();</span><br><span class="line">                    &#x2F;&#x2F; 生产系统中一般会额外进行就绪状态检查</span><br><span class="line">                    sayHelloWorld((ServerSocketChannel) key.channel());</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sayHelloWorld(ServerSocketChannel server) throws IOException &#123;</span><br><span class="line">        try (SocketChannel client &#x3D; server.accept();) &#123;</span><br><span class="line">            client.write(Charset.defaultCharset().encode(&quot;Hello world!&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 省略了与前面类似的 main</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        NioExample server &#x3D; new NioExample();</span><br><span class="line">        server.start();</span><br><span class="line">        try (Socket client &#x3D; new Socket(InetAddress.getLocalHost(), 8888)) &#123;</span><br><span class="line">            BufferedReader bufferedReader &#x3D; new BufferedReader(new InputStreamReader(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，通过 Selector.open() 创建一个 Selector，作为类似调度员的角色。</p><p>然后，创建一个 ServerSocketChannel，并且向 Selector 注册，通过指定 SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。注意：为什么我们要明确配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会抛出 IllegalBlockingModeException 异常。</p><p>Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒。</p><p>在 sayHelloWorld 方法中，通过 SocketChannel 和 Buffer 进行数据操作，在本例中是发送了一段字符串。</p><p>可以看到，在前面两个样例中，IO 都是同步阻塞模式，所以需要多线程以实现多任务处理。而 NIO 则是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。下面这张图对这种实现思路进行了形象地说明</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/14/1697c8d556639922?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><a href="https://juejin.im/post/5c8aea1df265da2de33f6a09" target="_blank" rel="noopener">https://juejin.im/post/5c8aea1df265da2de33f6a09</a></p><p><a href="https://juejin.im/post/5d19820c6fb9a07ea42094e2#heading-4" target="_blank" rel="noopener">https://juejin.im/post/5d19820c6fb9a07ea42094e2#heading-4</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>值传递和引用传递</title>
      <link href="/2020/07/03/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
      <url>/2020/07/03/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="值传递："><a href="#值传递：" class="headerlink" title="值传递："></a>值传递：</h2><p><strong>在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容</strong></p><p>来看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">valueCrossTest</span><span class="params">(<span class="keyword">int</span> age,<span class="keyword">float</span> weight)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"传入的age："</span>+age);</span><br><span class="line">     System.out.println(<span class="string">"传入的weight："</span>+weight);</span><br><span class="line">     age=<span class="number">33</span>;</span><br><span class="line">     weight=<span class="number">89.5f</span>;</span><br><span class="line">     System.out.println(<span class="string">"方法内重新赋值后的age："</span>+age);</span><br><span class="line">     System.out.println(<span class="string">"方法内重新赋值后的weight："</span>+weight);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">25</span>;</span><br><span class="line">        <span class="keyword">float</span> w=<span class="number">77.5f</span>;</span><br><span class="line">        valueCrossTest(a,w);</span><br><span class="line">        System.out.println(<span class="string">"方法执行后的age："</span>+a);</span><br><span class="line">        System.out.println(<span class="string">"方法执行后的weight："</span>+w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传入的age：<span class="number">25</span></span><br><span class="line">传入的weight：<span class="number">77.5</span></span><br><span class="line"></span><br><span class="line">方法内重新赋值后的age：<span class="number">33</span></span><br><span class="line">方法内重新赋值后的weight：<span class="number">89.5</span></span><br><span class="line"></span><br><span class="line">方法执行后的age：<span class="number">25</span></span><br><span class="line">方法执行后的weight：<span class="number">77.5</span></span><br></pre></td></tr></table></figure><p>从上面的打印结果可以看到：<br>a和w作为实参传入valueCrossTest之后，无论在方法内做了什么操作，最终a和w都没变化。</p><p>这是什么造型呢？！！</p><p>下面我们根据上面学到的知识点，进行详细的分析：</p><p>首先程序运行时，调用main()方法，此时JVM为main()方法往虚拟机栈中压入一个栈帧，即为当前栈帧，用来存放main()中的局部变量表(包括参数)、操作栈、方法出口等信息，如a和w都是main()方法中的局部变量，因此可以断定，a和w是躺着mian方法所在的栈帧中<br>如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669e46bb87ca5be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>而当执行到valueCrossTest()方法时，JVM也为其往虚拟机栈中压入一个栈，即为当前栈帧，用来存放valueCrossTest()中的局部变量等信息，因此age和weight是躺着valueCrossTest方法所在的栈帧中，而他们的值是从a和w的值copy了一份副本而得，如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669e46bb8aa7c65?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>。<br>因而可以a和age、w和weight对应的内容是不一致的，所以当在方法内重新赋值时，实际流程如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669e46be8b5eaf0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>也就是说，age和weight的改动，只是改变了当前栈帧（valueCrossTest方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，mian方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出a和w时，依然是初始化时的内容。<br>因此：<br><strong>值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。</strong></p><h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p><strong>引用传递指的是在方法调用时，实参的地址通过方法调用被传递给相应的形参，对形参的操作会影响的真实内容。</strong></p><p>先定义一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">         <span class="keyword">private</span> String name;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> name;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们写个函数测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PersonCrossTest</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"传入的person的name："</span>+person.getName());</span><br><span class="line">         person.setName(<span class="string">"我是张小龙"</span>);</span><br><span class="line">         System.out.println(<span class="string">"方法内重新赋值后的name："</span>+person.getName());</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">//测试</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p=<span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">"我是马化腾"</span>);</span><br><span class="line">        p.setAge(<span class="number">45</span>);</span><br><span class="line">        PersonCrossTest(p);</span><br><span class="line">        System.out.println(<span class="string">"方法执行后的name："</span>+p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传入的person的name：我是马化腾</span><br><span class="line">方法内重新赋值后的name：我是张小龙</span><br><span class="line">方法执行后的name：我是张小龙</span><br></pre></td></tr></table></figure><p>可以看出，person经过personCrossTest()方法的执行之后，内容发生了改变，这印证了上面所说的<strong>“引用传递”</strong>，对形参的操作，改变了实际对象的内容。</p><p>那么，到这里就结题了吗？<br>不是的，没那么简单，<br>能看得到想要的效果<br>是因为刚好选对了例子而已！！！</p><p>下面我们对上面的例子稍作修改，加上一行代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PersonCrossTest</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"传入的person的name："</span>+person.getName());</span><br><span class="line">        person=<span class="keyword">new</span> Person();<span class="comment">//加多此行代码</span></span><br><span class="line">        person.setName(<span class="string">"我是张小龙"</span>);</span><br><span class="line">        System.out.println(<span class="string">"方法内重新赋值后的name："</span>+person.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传入的person的name：我是马化腾</span><br><span class="line">方法内重新赋值后的name：我是张小龙</span><br><span class="line">方法执行后的name：我是马化腾</span><br></pre></td></tr></table></figure><p>为什么这次的输出和上次的不一样了呢？<br>看出什么问题了吗？</p><p>按照上面讲到JVM内存模型可以知道，对象和数组是存储在Java堆区的，而且堆区是共享的，因此程序执行到main（）方法中的下列代码时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p=<span class="keyword">new</span> Person();</span><br><span class="line">p.setName(<span class="string">"我是马化腾"</span>);</span><br><span class="line">p.setAge(<span class="number">45</span>);</span><br><span class="line">PersonCrossTest(p);</span><br></pre></td></tr></table></figure><p>JVM会在堆内开辟一块内存，用来存储p对象的所有内容，同时在main（）方法所在线程的栈区中创建一个引用p存储堆区中p对象的真实地址，如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669e46be94a3fd8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>当执行到PersonCrossTest()方法时，因为方法内有这么一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person=<span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>JVM需要在堆内另外开辟一块内存来存储new Person()，假如地址为“xo3333”，那此时形参person指向了这个地址，假如真的是引用传递，那么由上面讲到：<strong>引用传递中形参实参指向同一个对象，形参的操作会改变实参对象的改变</strong>。</p><p>可以推出：实参也应该指向了新创建的person对象的地址，所以在执行PersonCrossTest()结束之后，最终输出的应该是后面创建的对象内容。</p><p>然而实际上，最终的输出结果却跟我们推测的不一样，最终输出的仍然是一开始创建的对象的内容。</p><p>由此可见：<strong>引用传递，在Java中并不存在。</strong></p><p>但是有人会疑问：为什么第一个例子中，在方法内修改了形参的内容，会导致原始对象的内容发生改变呢？</p><p>这是因为：<strong>无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669e46be89ea9fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>有图可以看出，方法内的形参person和实参p并无实质关联，它只是由p处copy了一份指向对象的地址，此时：</p><p><strong>p和person都是指向同一个对象</strong>。</p><p>因此在第一个例子中，对形参p的操作，会影响到实参对应的对象内容。而在第二个例子中，当执行到new Person()之后，JVM在堆内开辟一块空间存储新对象，并且把person改成指向新对象的地址，此时：</p><p><strong>p依旧是指向旧的对象，person指向新对象的地址。</strong></p><p>所以此时<strong>对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系</strong>。</p><p>作者：假不理<br>链接：<a href="https://juejin.im/post/5bce68226fb9a05ce46a0476" target="_blank" rel="noopener">https://juejin.im/post/5bce68226fb9a05ce46a0476</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="/2020/07/03/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2020/07/03/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="cloneable"><a href="#cloneable" class="headerlink" title="cloneable"></a>cloneable</h2><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类<br>实例的 clone() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CloneExample &#123;</span><br><span class="line">  private int a;</span><br><span class="line">  private int b;</span><br><span class="line">&#125;</span><br><span class="line">CloneExample e1 &#x3D; new CloneExample();</span><br><span class="line">&#x2F;&#x2F; CloneExample e2 &#x3D; e1.clone(); &#x2F;&#x2F; &#39;clone()&#39; has protected access in &#39;java.lang.Object&#39;</span><br></pre></td></tr></table></figure><p>正确：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CloneExample implements Cloneable &#123;</span><br><span class="line">  private int a;</span><br><span class="line">  private int b;</span><br><span class="line">  @Override</span><br><span class="line">  public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">  return super.clone();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/14/6610661def48e619bd53667d83d96094?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="/clone-qian.png"></p><p>我们举个clone产生的浅拷贝的例子，我们定义一个对象中的对象，然后尝试拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Address implements Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不是好的方式</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class CustUser implements Cloneable&#123;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line">    private Address address;</span><br><span class="line">    private String[] cars;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException&#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了CustUser和Address。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void testShallowCopy() throws CloneNotSupportedException &#123;</span><br><span class="line">       Address address&#x3D; new Address();</span><br><span class="line">       address.setName(&quot;北京天安门&quot;);</span><br><span class="line">       CustUser custUser &#x3D; new CustUser();</span><br><span class="line">       custUser.setAddress(address);</span><br><span class="line">       custUser.setLastName(&quot;李&quot;);</span><br><span class="line">       custUser.setFirstName(&quot;雷&quot;);</span><br><span class="line">       String[] cars &#x3D; new String[]&#123;&quot;别克&quot;,&quot;路虎&quot;&#125;;</span><br><span class="line">       custUser.setCars(cars);</span><br><span class="line"></span><br><span class="line">       CustUser custUserCopy&#x3D;(CustUser) custUser.clone();</span><br><span class="line">       custUserCopy.setFirstName(&quot;梅梅&quot;);</span><br><span class="line">       custUserCopy.setLastName(&quot;韩&quot;);</span><br><span class="line">       custUserCopy.getAddress().setName(&quot;北京颐和园&quot;);</span><br><span class="line">       custUserCopy.getCars()[0]&#x3D;&quot;奥迪&quot;;</span><br><span class="line"></span><br><span class="line">       log.info(&quot;&#123;&#125;&quot;,custUser);</span><br><span class="line">       log.info(&quot;&#123;&#125;&quot;,custUserCopy);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>浅拷贝我们只调用了CustUser的clone方法。看下输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CustUser(firstName&#x3D;雷, lastName&#x3D;李, address&#x3D;Address(name&#x3D;北京颐和园), cars&#x3D;[奥迪, 路虎])</span><br><span class="line"></span><br><span class="line">CustUser(firstName&#x3D;梅梅, lastName&#x3D;韩, address&#x3D;Address(name&#x3D;北京颐和园), cars&#x3D;[奥迪, 路虎])</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们可以看到拷贝之后的Address变化会影响到被拷贝的对象。</p><p>上面的例子我们还要关注两个点：第一点String是不可变的。不管是拷贝还是赋值，String都是不可变的。</p><p>第二点，上面的例子中我们定义了一个数组，可以看到如果只是调用clone的话，数组也是浅拷贝。</p><p><strong>要使用深拷贝，只需要修改CustUser的构造函数就可以了：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;不是很好的使用方式</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException&#123;</span><br><span class="line">        CustUserDeep custUserDeep&#x3D;(CustUserDeep)super.clone();</span><br><span class="line">        custUserDeep.address&#x3D;(Address)address.clone();</span><br><span class="line">        custUserDeep.cars&#x3D;cars.clone();</span><br><span class="line">            return custUserDeep;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在重写的clone方法中，我们分别调用了CustUser,Address和数组的clone方法来进行拷贝。</p><p>再运行一次上面的测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CustUserDeep(firstName&#x3D;雷, lastName&#x3D;李, address&#x3D;Address(name&#x3D;北京天安门), cars&#x3D;[别克, 路虎])</span><br><span class="line"></span><br><span class="line">CustUserDeep(firstName&#x3D;梅梅, lastName&#x3D;韩, address&#x3D;Address(name&#x3D;北京颐和园), cars&#x3D;[奥迪, 路虎])</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到address和cars是不同的，这表示我们的深拷贝是成功的。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/14/5c30e76c9d63860ac430dfd2ddfbdd4f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="/clone-深.png"></p><p>用序列化进行深拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369285298572941L</span>;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 邮件</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDesc personDesc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 将该对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。所以利用这个特性可以实现对象的深拷贝</span></span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 将流序列化成对象</span></span><br><span class="line">            ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">            person = (Person) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDesc.setDesc(desc);</span><br><span class="line">    &#125;</span><br><span class="line">  ...省略...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDesc</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">872390113109L</span>; </span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化一个对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"平头哥"</span>,<span class="number">20</span>,<span class="string">"123456@qq.com"</span>,<span class="string">"我的公众号是：平头哥的技术博文"</span>);</span><br><span class="line">        <span class="comment">// 复制对象</span></span><br><span class="line">        Person person1 = (Person) person.clone();</span><br><span class="line">        <span class="comment">// 改变 person1 的属性值</span></span><br><span class="line">        person1.setName(<span class="string">"我是平头哥的克隆对象"</span>);</span><br><span class="line">        <span class="comment">// 修改 person age 的值</span></span><br><span class="line">        person1.setAge(<span class="number">22</span>);</span><br><span class="line">        person1.setDesc(<span class="string">"我已经关注了平头哥的技术博文公众号"</span>);</span><br><span class="line">        System.out.println(<span class="string">"person对象："</span>+person);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"person1对象："</span>+person1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个对象多少个字节</title>
      <link href="/2020/07/03/%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82/"/>
      <url>/2020/07/03/%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AAAAA &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BBBBB &#123;</span><br><span class="line">  int a &#x3D; 1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CCCCC &#123;</span><br><span class="line">  long a &#x3D; 1l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DDDDD &#123;</span><br><span class="line">   String s &#x3D; &quot;Hello&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针压缩：</p><ul><li><p>A对象只包含一个对象头，大小占12字节，不是8的倍数，需要4字节进行填充，一共占16字节</p></li><li><p>B对象包含一个对象头和int类型，12+4=16，正好是8的倍数，不需要填充。</p></li><li><p>C对象包含一个对象头和long类型，12+8=20，不是8的倍数，需要4个字节进行填充，占24字节</p></li><li><p>D对象包含一个对象头和引用类型，12+4=16，正好是8的倍数，不需要填充</p><p><a href="https://blog.csdn.net/qlmmys/article/details/53213857" target="_blank" rel="noopener">https://blog.csdn.net/qlmmys/article/details/53213857</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反射机制及其优缺点</title>
      <link href="/2020/07/02/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>/2020/07/02/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个属性和方法，这种功能称为java语言的反射机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内</span><br><span class="line">容保存着 Class 对象。也可以使用Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</span><br></pre></td></tr></table></figure><p>类对象 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：<br><strong>Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</strong><br><strong>Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</strong><br><strong>Constructor ：可以用 Constructor 创建新的对象。</strong></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</p><p>方便性: 可以写在配置文件里，直接修改配置文件就行了</p><p>spring.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class&#x3D;reflection.Service1</span><br><span class="line">method&#x3D;doService1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line"> </span><br><span class="line">    @SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;从spring.txt中获取类名称和方法名称</span><br><span class="line">        File springConfigFile &#x3D; new File(&quot;e:\\project\\j2se\\src\\spring.txt&quot;);</span><br><span class="line">        Properties springConfig&#x3D; new Properties();</span><br><span class="line">        springConfig.load(new FileInputStream(springConfigFile));</span><br><span class="line">        String className &#x3D; (String) springConfig.get(&quot;class&quot;);</span><br><span class="line">        String methodName &#x3D; (String) springConfig.get(&quot;method&quot;);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;根据类名称获取类对象</span><br><span class="line">        Class clazz &#x3D; Class.forName(className);</span><br><span class="line">        &#x2F;&#x2F;根据方法名称，获取方法对象</span><br><span class="line">        Method m &#x3D; clazz.getMethod(methodName);</span><br><span class="line">        &#x2F;&#x2F;获取构造器</span><br><span class="line">        Constructor c &#x3D; clazz.getConstructor();</span><br><span class="line">        &#x2F;&#x2F;根据构造器，实例化出对象</span><br><span class="line">        Object service &#x3D; c.newInstance();</span><br><span class="line">        &#x2F;&#x2F;调用对象的指定方法</span><br><span class="line">        m.invoke(service);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些<br>非反射操作低得多。</p><p>内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使<br>用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。</p><h3 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            String className = <span class="string">"charactor.Hero"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class pClass1=Class.forName(className);</span><br><span class="line">                Class pClass2=Hero<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                Class pClass3=<span class="keyword">new</span> Hero().getClass();</span><br><span class="line">                System.out.println(pClass1==pClass2);</span><br><span class="line">                System.out.println(pClass1==pClass3);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import charactor.Hero;</span><br><span class="line">public class TestReflection &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;传统的使用new的方式创建对象</span><br><span class="line">        Hero h1 &#x3D;new Hero();</span><br><span class="line">        h1.name &#x3D; &quot;teemo&quot;;</span><br><span class="line">        System.out.println(h1);</span><br><span class="line">          </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;使用反射的方式创建对象</span><br><span class="line">            String className &#x3D; &quot;charactor.Hero&quot;;</span><br><span class="line">            &#x2F;&#x2F;类对象</span><br><span class="line">            Class pClass&#x3D;Class.forName(className);</span><br><span class="line">            &#x2F;&#x2F;构造器</span><br><span class="line">            Constructor c&#x3D; pClass.getConstructor();</span><br><span class="line">            &#x2F;&#x2F;通过构造器实例化</span><br><span class="line">            Hero h2&#x3D; (Hero) c.newInstance();</span><br><span class="line">            h2.name&#x3D;&quot;gareen&quot;;</span><br><span class="line">            System.out.println(h2);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>对于private修饰的成员，需要使用setAccessible(true)才能访问和修改。不在此知识点讨论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestReflection &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            Hero h &#x3D;new Hero();</span><br><span class="line">            &#x2F;&#x2F;使用传统方式修改name的值为garen</span><br><span class="line">            h.name &#x3D; &quot;garen&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;获取类Hero的名字叫做name的字段</span><br><span class="line">                Field f1&#x3D; h.getClass().getDeclaredField(&quot;name&quot;);</span><br><span class="line">                &#x2F;&#x2F;修改这个字段的值</span><br><span class="line">                f1.set(h, &quot;teemo&quot;);</span><br><span class="line">                &#x2F;&#x2F;打印被修改后的值</span><br><span class="line">                System.out.println(h.name);</span><br><span class="line">                 </span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getField和getDeclaredField的区别</span><br><span class="line">这两个方法都是用于获取字段</span><br><span class="line">getField 只能获取public的，包括从父类继承来的字段。</span><br><span class="line">getDeclaredField 可以获取本类所有的字段，包括private的，但是不能获取继承来的字段。 (注： 这里只能获取到private的字段，但并不能访问该private字段的值,除非加上setAccessible(true))</span><br></pre></td></tr></table></figure><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">    public int damage;</span><br><span class="line">    public int id;</span><br><span class="line">     </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Hero()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    public Hero(String string) &#123;</span><br><span class="line">        name &#x3D;string;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hero [name&#x3D;&quot; + name + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isDead() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public void attackHero(Hero h2) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestReflection &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h &#x3D; new Hero();</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取这个名字叫做setName，参数类型是String的方法</span><br><span class="line">            Method m &#x3D; h.getClass().getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">            &#x2F;&#x2F; 对h对象，调用这个方法</span><br><span class="line">            m.invoke(h, &quot;盖伦&quot;);</span><br><span class="line">            &#x2F;&#x2F; 使用传统的方式，调用getName方法</span><br><span class="line">            System.out.println(h.getName());</span><br><span class="line"> </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>==、equals、hashcode</title>
      <link href="/2020/07/02/%E3%80%81equals%E3%80%81hashcode/"/>
      <url>/2020/07/02/%E3%80%81equals%E3%80%81hashcode/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。<br>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x &#x3D; new Integer(1);</span><br><span class="line">Integer y &#x3D; new Integer(1);</span><br><span class="line">System.out.println(x.equals(y)); &#x2F;&#x2F; true</span><br><span class="line">System.out.println(x &#x3D;&#x3D; y); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><h2 id="为什么重写equals需要重写hashcode？"><a href="#为什么重写equals需要重写hashcode？" class="headerlink" title="为什么重写equals需要重写hashcode？"></a>为什么重写equals需要重写hashcode？</h2><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，如果不重写hashcode的话，会导致等价的两个对象散列值不相同 (由于默认的hashcode方法是根据对象的内存地址经哈希算法得来的，故两者的hashcode不一定相等) 。因此在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何排查内存泄漏</title>
      <link href="/2020/07/02/%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>/2020/07/02/%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>内存泄漏：你用new申请了一块内存，后来很长时间都不再使用了（按理应该释放），但是因为一直被某个或某些实例所持有导致 GC 不能回收，也就是该被释放的对象没有释放。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>首先通过“虚拟机进程状况工具：jps”找出正在运行的虚拟机进程，最主要是找出这个进程在本地虚拟机的唯一ID（LVMID，Local Virtual Machine Identifier），因为在后面的排查过程中都是需要这个LVMID来确定要监控的是哪一个虚拟机进程。<br>同时，对于本地虚拟机进程来说，LVMID与操作系统的进程ID（PID，Process Identifier）是一致的，使用Windows的任务管理器或Unix的ps命令也可以查询到虚拟机进程的LVMID。<br>jps命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure><p>使用命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用jps：jps -l</span><br><span class="line">使用ps：ps aux | grep tomat</span><br></pre></td></tr></table></figure><p>找到你需要监控的ID（假设为20954），再利用“虚拟机统计信息监视工具：jstat”监视虚拟机各种运行状态信息。<br>jstat命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [ option vmid [interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure><p>使用命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 20954 1000</span><br></pre></td></tr></table></figure><p>意思是每1000毫秒查询一次，一直查。gcutil的意思是已使用空间站总空间的百分比。<br>结果如下图：</p><p>jstat执行结果<br>查询结果表明：这台服务器的新生代Eden区（E，表示Eden）使用了28.30%（最后）的空间，两个Survivor区（S0、S1，表示Survivor0、Survivor1）分别是0和8.93%，老年代（O，表示Old）使用了87.33%。程序运行以来共发生Minor GC（YGC，表示Young GC）101次，总耗时1.961秒，发生Full GC（FGC，表示Full GC）7次，Full GC总耗时3.022秒，总的耗时（GCT，表示GC Time）为4.983秒。</p><p>2.2 找出导致频繁Full GC的原因<br>分析方法通常有两种：<br>1）把堆dump下来再用MAT等工具进行分析，但dump堆要花较长的时间，并且文件巨大，再从服务器上拖回本地导入工具，这个过程有些折腾，不到万不得已最好别这么干。<br>2）更轻量级的在线分析，使用“Java内存影像工具：jmap”生成堆转储快照（一般称为headdump或dump文件）。<br>jmap命令格式：<br>jmap [ option ] vmid<br>使用命令如下：<br>jmap -histo:live 20954<br>查看存活的对象情况，如下图所示：</p><p>存活对象<br>按照一位IT友的说法，数据不正常，十有八九就是泄露的。在我这个图上对象还是挺正常的。</p><p>我在网上找了一位博友的不正常数据，如下：</p><p>image.png<br>可以看出HashTable中的元素有5000多万，占用内存大约1.5G的样子。这肯定不正常。</p><p>2.3 定位到代码<br>定位带代码，有很多种方法，比如前面提到的通过MAT查看Histogram即可找出是哪块代码。——我以前是使用这个方法。 也可以使用BTrace，我没有使用过。</p><p>举例：</p><p>一台生产环境机器每次运行几天之后就会莫名其妙的宕机，分析日志之后发现在tomcat刚启动的时候内存占用比较少，但是运行个几天之后内存占用越来越大，通过jmap命令可以查询到一些大对象引用没有被及时GC，这里就要求解决内存泄露的问题。</p><p>Java的内存泄露多半是因为对象存在无效的引用，对象得不到释放，如果发现Java应用程序占用的内存出现了泄露的迹象，那么我们一般采用下面的步骤分析：</p><ol><li>用工具生成java应用程序的heap dump（如jmap）</li><li>使用Java heap分析工具（如MAT），找出内存占用超出预期的嫌疑对象</li><li>根据情况，分析嫌疑对象和其他对象的引用关系。</li><li>分析程序的源代码，找出嫌疑对象数量过多的原因。</li></ol><p>以下一步步的按照项目实例来操作，去解决内存泄露的问题。</p><p>1.登录linux服务器，获取tomcat的pid，命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160907153739493" alt="img"></p><p>2.利用jmap初步分析内存映射，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live 3514 | head -7</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160907162814112" alt="img"></p><p>第2行是我们业务系统的对象，通过这个对象的引用可以初步分析出到底是哪里出现了引用未被垃圾回收收集，通知开发人员优化相关代码。</p><p>3.如果上面一步还无法定位到关键信息，那么需要拿到heap dump，生成离线文件，做进一步分析，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format&#x3D;b,file&#x3D;heap.hprof 3514</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160907162941232" alt="img"></p><p>4.拿到heap dump文件，利用eclipse插件MAT来分析heap profile。</p><p>a. 安装MAT插件</p><p>b. 在eclipse里切换到Memory Analysis视图</p><p>c. 用MAT打开heap profile文件。</p><p><img src="https://img-blog.csdn.net/20160907163118749" alt="img"></p><p>直接看到下面Action窗口，有4种Action来分析heap profile，介绍其中最常用的2种:</p><p>- <strong>Histogram</strong>：这个使用的最多，跟上面的jmap -histo 命令类似，只是在MAT里面可以用GUI来展示应用系统各个类产生的实例。</p><p><img src="https://img-blog.csdn.net/20160907163309052" alt="img"></p><p>Shllow Heap排序后发现 Cms_Organization 这个类占用的内存比较多（没有得到及时GC），查看引用：</p><p><img src="https://img-blog.csdn.net/20160907163424065" alt="img"></p><p>分析引用栈，找到无效引用，打开源码：</p><p><img src="https://img-blog.csdn.net/20160907163540520" alt="img"></p><p>有问题的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class RefreshCmsOrganizationStruts implements Runnable&#123;</span><br><span class="line"> </span><br><span class="line">private final static Logger logger &#x3D; Logger.getLogger(RefreshCmsOrganizationStruts.class);</span><br><span class="line"></span><br><span class="line">private List&lt;Cms_Organization&gt; organizations;</span><br><span class="line"> </span><br><span class="line">private OrganizationDao organizationDao &#x3D; (OrganizationDao) WebContentBean</span><br><span class="line">.getInstance().getBean(&quot;organizationDao&quot;);</span><br><span class="line">public RefreshCmsOrganizationStruts(List&lt;Cms_Organization&gt; organizations) &#123;</span><br><span class="line">this.organizations &#x3D; organizations;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void run() &#123;</span><br><span class="line">Iterator&lt;Cms_Organization&gt; iter &#x3D; organizations.iterator();</span><br><span class="line">Cms_Organization organization &#x3D; null;</span><br><span class="line">while (iter.hasNext()) &#123;</span><br><span class="line">organization &#x3D; iter.next();</span><br><span class="line">synchronized (organization) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">organizationDao.refreshCmsOrganizationStrutsInfo(organization.getOrgaId());</span><br><span class="line">organizationDao.refreshCmsOrganizationResourceInfo(organization.getOrgaId());</span><br><span class="line">organizationDao.sleep();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">logger.debug(&quot;RefreshCmsOrganizationStruts organization &#x3D; &quot; + organization.getOrgaId(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析源码，定时任务定时调用，每次调用生成10个线程处理，而它又使用了非线程安全的List对象，导致List对象无法被GC收集，所以这里将List替换为CopyOnWriteArrayList 。</p><p><strong>Dominator Tree</strong>：这个使用的也比较多，显示大对象的占用率</p><p><img src="https://img-blog.csdn.net/20160907164212086" alt="img"></p><p>同样的打开源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class CategoryCacheJob extends QuartzJobBean implements StatefulJob &#123;</span><br><span class="line"></span><br><span class="line">private static final Logger LOGGER &#x3D; Logger.getLogger(CategoryCacheJob.class);</span><br><span class="line"></span><br><span class="line">public static Map&lt;String,List&lt;Cms_Category&gt;&gt; cacheMap &#x3D; new java.util.HashMap&lt;String,List&lt;Cms_Category&gt;&gt;();</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 缓存编目树开始 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">MongoBaseDao mongoBaseDao &#x3D; (MongoBaseDao) BeanLocator.getInstance().getBean(&quot;mongoBaseDao&quot;);</span><br><span class="line">MongoOperations mongoOperations &#x3D; mongoBaseDao.getMongoOperations();</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">LOGGER.info(&quot;1.缓存基础教育编目树&quot;);</span><br><span class="line">Query query &#x3D; Query.query(Criteria.where(&quot;isDel&quot;).is(&quot;0&quot;).and(&quot;categoryType&quot;).is(&quot;F&quot;));</span><br><span class="line">query.sort().on(&quot;orderNo&quot;, Order.ASCENDING);</span><br><span class="line">List&lt;Cms_Category&gt; list &#x3D; mongoOperations.find(query, Cms_Category.class);</span><br><span class="line">String key &#x3D; query.toString().replaceAll(&quot;\\&#123;|\\&#125;|\\p&#123;Cntrl&#125;|\\p&#123;Space&#125;&quot;, &quot;&quot;);</span><br><span class="line">key +&#x3D; &quot;_CategoryCacheJob&quot;;</span><br><span class="line">cacheMap.put(key, list);</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;LOGGER.info(&quot;2.缓存职业教育编目树&quot;);</span><br><span class="line">Query query2 &#x3D; Query.query(Criteria.where(&quot;isDel&quot;).is(&quot;0&quot;).and(&quot;categoryType&quot;).in(&quot;JMP&quot;,&quot;JHP&quot;));</span><br><span class="line">query2.sort().on(&quot;orderNo&quot;, Order.ASCENDING);</span><br><span class="line">List&lt;Cms_Category&gt; list2 &#x3D; mongoOperations.find(query2, Cms_Category.class);</span><br><span class="line">String key2 &#x3D; query2.toString().replaceAll(&quot;\\&#123;|\\&#125;|\\p&#123;Cntrl&#125;|\\p&#123;Space&#125;&quot;, &quot;&quot;);</span><br><span class="line">key2 +&#x3D; &quot;_CategoryCacheJob&quot;;</span><br><span class="line">cacheMap.put(key2, list2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;LOGGER.info(&quot;3.缓存专题教育编目树&quot;);</span><br><span class="line">Query query3 &#x3D; Query.query(Criteria.where(&quot;isDel&quot;).is(&quot;0&quot;).and(&quot;categoryType&quot;).is(&quot;JS&quot;));</span><br><span class="line">query3.sort().on(&quot;orderNo&quot;, Order.ASCENDING);</span><br><span class="line">List&lt;Cms_Category&gt; list3 &#x3D; mongoOperations.find(query3, Cms_Category.class);</span><br><span class="line">String key3 &#x3D; query3.toString().replaceAll(&quot;\\&#123;|\\&#125;|\\p&#123;Cntrl&#125;|\\p&#123;Space&#125;&quot;, &quot;&quot;);</span><br><span class="line">key3 +&#x3D; &quot;_CategoryCacheJob&quot;;</span><br><span class="line">cacheMap.put(key3, list3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 缓存编目树结束 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125; catch(Exception ex) &#123;</span><br><span class="line">LOGGER.error(ex.getMessage(), ex);</span><br><span class="line">LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 缓存编目树出错 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存泄漏的原因分析，总结出来只有一条：<strong>存在无效的引用</strong></p><p><a href="https://blog.csdn.net/fishinhouse/article/details/80781673" target="_blank" rel="noopener">https://blog.csdn.net/fishinhouse/article/details/80781673</a></p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.8新特性</title>
      <link href="/2020/07/02/JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/07/02/JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(cpt);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"========================="</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt2 = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line">TreeSet&lt;Integer&gt; set2 = <span class="keyword">new</span> TreeSet&lt;&gt;(cpt2);</span><br></pre></td></tr></table></figure><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>Stream操作的三个步骤</p><ul><li><p>创建stream</p></li><li><p>中间操作（过滤、map）</p></li><li><p>终止操作</p><p>stream的创建：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1，校验通过Collection 系列集合提供的stream()或者paralleStream()</span><br><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">Strean&lt;String&gt; stream1 &#x3D; list.stream();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.通过Arrays的静态方法stream()获取数组流</span><br><span class="line">String[] str &#x3D; new String[10];</span><br><span class="line">Stream&lt;String&gt; stream2 &#x3D; Arrays.stream(str);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.通过Stream类中的静态方法of</span><br><span class="line">Stream&lt;String&gt; stream3 &#x3D; Stream.of(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4.创建无限流</span><br><span class="line">&#x2F;&#x2F; 迭代</span><br><span class="line">Stream&lt;Integer&gt; stream4 &#x3D; Stream.iterate(0,(x) -&gt; x+2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成</span><br><span class="line">Stream.generate(() -&gt;Math.random());</span><br></pre></td></tr></table></figure><p>Stream的中间操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 筛选 过滤  去重</span><br><span class="line">   *&#x2F;</span><br><span class="line">  emps.stream()</span><br><span class="line">          .filter(e -&gt; e.getAge() &gt; 10)</span><br><span class="line">          .limit(4)</span><br><span class="line">          .skip(4)</span><br><span class="line">          &#x2F;&#x2F; 需要流中的元素重写hashCode和equals方法</span><br><span class="line">          .distinct()</span><br><span class="line">          .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   *  生成新的流 通过map映射</span><br><span class="line">   *&#x2F;</span><br><span class="line">  emps.stream()</span><br><span class="line">          .map((e) -&gt; e.getAge())</span><br><span class="line">          .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   *  自然排序  定制排序</span><br><span class="line">   *&#x2F;</span><br><span class="line">  emps.stream()</span><br><span class="line">          .sorted((e1 ,e2) -&gt; &#123;</span><br><span class="line">              if (e1.getAge().equals(e2.getAge()))&#123;</span><br><span class="line">                  return e1.getName().compareTo(e2.getName());</span><br><span class="line">              &#125; else&#123;</span><br><span class="line">                  return e1.getAge().compareTo(e2.getAge());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>Stream的终止操作：</p><p>reduce:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> *  reduce ：规约操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">List&lt;Integer&gt; list &#x3D; Arrays.asList(1,2,3,4,5,6,7,8,9,10);</span><br><span class="line">Integer count2 &#x3D; list.stream()</span><br><span class="line">        .reduce(0, (x, y) -&gt; x + y);</span><br><span class="line">System.out.println(count2);</span><br><span class="line"></span><br><span class="line">Optional&lt;Double&gt; sum &#x3D; emps.stream()</span><br><span class="line">        .map(Employee::getSalary)</span><br><span class="line">        .reduce(Double::sum);</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><p>collect操作：Collect-将流转换为其他形式，接收一个Collection接口的实现，用于给Stream中元素做汇总的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  collect：收集操作</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; ageList &#x3D; emps.stream()</span><br><span class="line">        .map(Employee::getAge)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">ageList.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="接口中可以定义默认实现方法和静态方法"><a href="#接口中可以定义默认实现方法和静态方法" class="headerlink" title="接口中可以定义默认实现方法和静态方法"></a>接口中可以定义默认实现方法和静态方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Interface &#123;</span><br><span class="line">    default  String getName()&#123;</span><br><span class="line">        return &quot;zhangsan&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String getName2()&#123;</span><br><span class="line">        return &quot;zhangsan&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对static的理解</title>
      <link href="/2020/07/02/%E5%AF%B9static%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/07/02/%E5%AF%B9static%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="能否被重写"><a href="#能否被重写" class="headerlink" title="能否被重写"></a>能否被重写</h2><p>语法上子类允许出现和父类只有方法体不一样其他都一模一样的static方法，但是在父类引用指向子类对象时，通过父类引用调用的依然是父类的static方法，而不是子类的static方法。<br>即：语法上static支持重写，但是运行效果上达不到多态目的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;  </span><br><span class="line">        static void a( )&#123;System.out.println(&quot;A&quot;);  &#125;  </span><br><span class="line">                 void b( )&#123;System.out.println(&quot;B&quot;); &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">public class  Inherit extends Base&#123;  </span><br><span class="line">          static void a( )&#123;System.out.println(&quot;C&quot;);  &#125;  </span><br><span class="line">                  void b( )&#123;System.out.println(&quot;D&quot;); &#125;  </span><br><span class="line">           public static void main(String args[])&#123;  </span><br><span class="line">                    Base b&#x3D;new Base();  </span><br><span class="line">                    Base  c&#x3D;new Inherit();  </span><br><span class="line">                    b.a();  </span><br><span class="line">                    b.b();  </span><br><span class="line">                    c.a();  </span><br><span class="line">                    c.b();  </span><br><span class="line">         &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h2><p>​    1.静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来<br> 访问它。静态变量在内存中只存在一份。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">  private int x; &#x2F;&#x2F; 实例变量</span><br><span class="line">  private static int y; &#x2F;&#x2F; 静态变量</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">  &#x2F;&#x2F; int x &#x3D; A.x; &#x2F;&#x2F; Non-static field &#39;x&#39; cannot be referenced from a static context</span><br><span class="line">  A a &#x3D; new A();</span><br><span class="line">  int x &#x3D; a.x;</span><br><span class="line">  int y &#x3D; A.y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>静态方法<br> 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class A &#123;</span><br><span class="line">public static void func1()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; public abstract static void func2(); &#x2F;&#x2F; Illegal combination of modifiers: &#39;abstract&#39;</span><br><span class="line">and &#39;static&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>静态语句块<br> 静态语句块在类初始化时运行一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println(&quot;123&quot;);</span><br><span class="line">&#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">  A a1 &#x3D; new A();</span><br><span class="line">  A a2 &#x3D; new A();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure></li><li><p>静态内部类</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">  class InnerClass &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  static class StaticInnerClass &#123;</span><br><span class="line"> &#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; InnerClass innerClass &#x3D; new InnerClass(); &#x2F;&#x2F; &#39;OuterClass.this&#39; cannot be</span><br><span class="line">   referenced from a static context</span><br><span class="line">  OuterClass outerClass &#x3D; new OuterClass();</span><br><span class="line">  InnerClass innerClass &#x3D; outerClass.new InnerClass();</span><br><span class="line">  StaticInnerClass staticInnerClass &#x3D; new StaticInnerClass();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.初始化顺序</p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺<br>序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static String staticField &#x3D; &quot;静态变量&quot;;</span><br><span class="line">  static &#123;</span><br><span class="line">  System.out.println(&quot;静态语句块&quot;);</span><br><span class="line">&#125;</span><br><span class="line">  public String field &#x3D; &quot;实例变量&quot;;</span><br><span class="line"> &#123;</span><br><span class="line">  System.out.println(&quot;普通语句块&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后才是构造函数的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public InitialOrderTest() &#123;</span><br><span class="line">  System.out.println(&quot;构造函数&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>修饰符(public&amp;protect&amp;default&amp;private)、接口，抽象类</title>
      <link href="/2020/07/02/%E4%BF%AE%E9%A5%B0%E7%AC%A6public-protect-default-private/"/>
      <url>/2020/07/02/%E4%BF%AE%E9%A5%B0%E7%AC%A6public-protect-default-private/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><img src="/2020/07/02/%E4%BF%AE%E9%A5%B0%E7%AC%A6public-protect-default-private/1.png" class title="如图% } Java 中有三个访问权限修饰符：private、protected 以及 public，**如果不加访问修饰符，表示包级可见**。 可以对类或类中的成员（字段以及方法）加上访问修饰符。 **protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。** &lt;figure class&#x3D;highlight plain&gt;&lt;table&gt;&lt;tr&gt;&lt;td class&#x3D;gutter&gt;&lt;pre&gt;&lt;span class&#x3D;line&gt;1&lt;&#x2F;span&gt;&lt;br&gt;&lt;span class&#x3D;line&gt;2&lt;&#x2F;span&gt;&lt;br&gt;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;td class&#x3D;code&gt;&lt;pre&gt;&lt;span class&#x3D;line&gt;类可见表示其它类可以用这个类创建实例对象。&lt;&#x2F;span&gt;&lt;br&gt;&lt;span class&#x3D;line&gt;成员可见表示其它类可以用这个类的实例对象访问到该成员；&lt;&#x2F;span&gt;&lt;br&gt;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&lt;&#x2F;figure&gt; ## 抽象类与接口 ### 抽象类 **抽象类用来描述一种类型应该具备的基本特征与功能。** （犬科均会吼叫，但属于犬科的狼与狗其吼叫内容不同。所以犬科规定了有吼叫功能，但并不明确吼叫的细节。吼叫的细节应该由狼与狗这样的犬科子类重写吼叫的方法具体实现。） **抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。** ### 接口 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了（default）。 **接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。接口的变量默认都是 static 和 final 的。** ### 比较 * 从设计层面上看，**抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所** **有父类对象**。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具 有 IS-A 关系。 * 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 * 接口的变量只能是 static 和 final 类型的，而抽象类的变量没有这种限制。 * 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 {% asset_img 2.png"><img src="/2020/07/02/%E4%BF%AE%E9%A5%B0%E7%AC%A6public-protect-default-private/3.png" class><h3 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h3><p>使用接口：<br>1.需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；<br>2.需要使用多重继承。<br>使用抽象类：<br>1.需要在几个相关的类中共享代码。<br>2.需要能控制继承来的成员的访问权限，而不是都为 public。<br>3.需要继承非静态和非常量字段。<br>在很多情况下，<strong>接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并</strong><br><strong>且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象三大特性的理解?</title>
      <link href="/2020/07/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/07/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>将数据和基于数据的操作封装在一起，数据被保护在抽象数据类型的内部，只保留一些对外的接口使其与外部发生联系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> gender;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> gender == <span class="number">0</span> ? <span class="string">"man"</span> : <span class="string">"woman"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">    System.out.println(name + <span class="string">" is working very hard!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(name + <span class="string">" can't work any more!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非<br>private 的属性和方法。<br>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。<br>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态分为编译时多态和运行时多态：</p><ul><li><p>编译时多态主要指方法的重载</p></li><li><p>运行时多态指的是 <strong>对象引用所指向的具体类型在运行期间才确定</strong></p></li></ul><p>运行时多态有三个条件：<br>  1.继承<br>  2.重写<br>  3.向上转型</p><p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且<br>在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，<br>会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Instument is playing..."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Wind is playing..."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Percussion is playing..."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   List&lt;Instrument&gt; instruments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   instruments.add(<span class="keyword">new</span> Wind());</span><br><span class="line">   instruments.add(<span class="keyword">new</span> Percussion());</span><br><span class="line">   <span class="keyword">for</span>(Instrument instrument : instruments) &#123;</span><br><span class="line">   instrument.play();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wind is playing...</span><br><span class="line">Percussion is playing...</span><br></pre></td></tr></table></figure><h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><p>重写（Override）<br>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。<br>为了满足里式替换原则，重写有以下三个限制：<br><strong>1.子类方法的访问权限必须大于等于父类方法；</strong><br><strong>2.子类方法的返回类型必须是父类方法返回类型或为其子类型。</strong><br><strong>3.子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</strong><br>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有查找到再到父类中查看，看是否有继承来的方<br>法。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p><p>this.func(this)<br>super.func(this)<br>this.func(super)<br>super.func(super)</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Error和Exception</title>
      <link href="/2020/07/02/Error%E5%92%8CException/"/>
      <url>/2020/07/02/Error%E5%92%8CException/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Throwable 用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM<br>无法处理的错误，Exception 分为两种：</p><ul><li><p>非运行时异常 ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复,IOEXception,SQLException,SocketException；</p></li><li><p>运行时异常 ：是程序运行时发错误，例如除 0 会引发 Arithmetic [əˈrɪθmətɪk] Exception，此时程序崩溃并且无法恢复，RuntimeException及其子类。如IndexOutOfBounds ,ArrayIndexOutOfBounds </p></li></ul><img src="/2020/07/02/Error%E5%92%8CException/1.png" class title="如图">]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDK和JRE</title>
      <link href="/2020/07/02/JDK%E5%92%8CJRE/"/>
      <url>/2020/07/02/JDK%E5%92%8CJRE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>JDK（Java Development Kit）：是 Java 开发工具包，，包括了 JRE、Java 工具(比如一些编译调试工具)和 Java 基础类库。</p><p>JRE（ Java Runtime Environment）：是 Java 的运行环境，包含 <strong>JVM 标准实现及 Java 核心类库</strong>。</p><p>(JDK同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。)</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>B树、B+树、红黑树</title>
      <link href="/2020/07/01/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2020/07/01/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="B树与B-树的区别？"><a href="#B树与B-树的区别？" class="headerlink" title="B树与B+树的区别？"></a>B树与B+树的区别？</h2><ol><li><p>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为页的大小是固定的，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。 </p></li><li><p>因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。</p></li></ol><h2 id="B-树与红黑树的区别？"><a href="#B-树与红黑树的区别？" class="headerlink" title="B+树与红黑树的区别？"></a>B+树与红黑树的区别？</h2><p>但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个</p><p>原因</p><p>（一）更少的查找次数</p><p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。</p><p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p><p>（二）利用磁盘预读特性</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h2 id="为什么说红黑树没能充分利用磁盘预读功能"><a href="#为什么说红黑树没能充分利用磁盘预读功能" class="headerlink" title="为什么说红黑树没能充分利用磁盘预读功能?"></a>为什么说红黑树没能充分利用磁盘预读功能?</h2><p>红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。<br>也就是说，使用红黑树（平衡二叉树）结构的话，每次磁盘预读中的很多数据是用不上的数据。因此，它没能利用好磁盘预读的提供的数据。然后又由于深度大（较B树而言），所以进行的磁盘IO操作更多。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现阻塞队列</title>
      <link href="/2020/07/01/%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
      <url>/2020/07/01/%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-什么是阻塞队列？"><a href="#1-什么是阻塞队列？" class="headerlink" title="1. 什么是阻塞队列？"></a>1. 什么是阻塞队列？</h2><p><strong>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</strong>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><h2 id="2-相关方法"><a href="#2-相关方法" class="headerlink" title="2.相关方法"></a>2.相关方法</h2><p>两个锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notFull</span><br><span class="line">notEmpty</span><br></pre></td></tr></table></figure><p>put方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;add方法实现，间接调用了offer(e)</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        if (offer(e))</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;offer方法</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">     checkNotNull(e);&#x2F;&#x2F;检查元素是否为null</span><br><span class="line">     final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">     lock.lock();&#x2F;&#x2F;加锁</span><br><span class="line">     try &#123;</span><br><span class="line">         if (count &#x3D;&#x3D; items.length)&#x2F;&#x2F;判断队列是否满</span><br><span class="line">             return false;</span><br><span class="line">         else &#123;</span><br><span class="line">             enqueue(e);&#x2F;&#x2F;添加元素到队列</span><br><span class="line">             return true;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;入队操作</span><br><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前数组</span><br><span class="line">    final Object[] items &#x3D; this.items;</span><br><span class="line">    &#x2F;&#x2F;通过putIndex索引对数组进行赋值</span><br><span class="line">    items[putIndex] &#x3D; x;</span><br><span class="line">    &#x2F;&#x2F;索引自增，如果已是最后一个位置，重新设置 putIndex &#x3D; 0;</span><br><span class="line">    if (++putIndex &#x3D;&#x3D; items.length)</span><br><span class="line">        putIndex &#x3D; 0;</span><br><span class="line">    count++;&#x2F;&#x2F;队列中元素数量加1</span><br><span class="line">    &#x2F;&#x2F;唤醒调用take()方法的线程，执行元素获取操作。</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的add方法和offer方法实现比较简单，其中需要注意的是enqueue(E x)方法，其方法内部通过putIndex索引直接将元素添加到数组items中，这里可能会疑惑的是当putIndex索引大小等于数组长度时，需要将putIndex重新设置为0，这是因为当前队列执行元素获取时总是从队列头部获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">checkNotNull(e); <span class="comment">// 不允许元素为空</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">lock.lockInterruptibly(); <span class="comment">// 加锁，保证调用put方法的时候只有1个线程</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (count == items.length) <span class="comment">// 如果队列满了，阻塞当前线程，while用来防止假唤醒</span></span><br><span class="line">notFull.await(); <span class="comment">// 线程阻塞并被挂起，同时释放锁</span></span><br><span class="line">insert(e); <span class="comment">// 调用insert方法</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock(); <span class="comment">// 释放锁，让其他线程可以调用put方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法是一个阻塞的方法，如果队列元素已满，那么当前线程将会被notFull条件对象挂起加到等待队列中，直到队列有空档才会唤醒执行添加操作。但如果队列没有满，那么就直接调用enqueue(e)方法将元素加入到数组队列中。到此我们对三个添加方法即put，offer，add都分析完毕，其中offer，add在正常情况下都是无阻塞的添加，而put方法是阻塞添加。<br>————————————————</p><p>删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//判断队列是否为null，不为null执行dequeue()方法，否则返回null</span></span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//删除队列头元素并返回</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//拿到当前数组的数据</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="comment">//获取要删除的对象</span></span><br><span class="line">      E x = (E) items[takeIndex];</span><br><span class="line">      将数组中takeIndex索引位置设置为<span class="keyword">null</span></span><br><span class="line">      items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//takeIndex索引加1并判断是否与数组长度相等，</span></span><br><span class="line">      <span class="comment">//如果相等说明已到尽头，恢复为0</span></span><br><span class="line">      <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">          takeIndex = <span class="number">0</span>;</span><br><span class="line">      count--;<span class="comment">//队列个数减1</span></span><br><span class="line">      <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">          itrs.elementDequeued();<span class="comment">//同时更新迭代器中的元素数据</span></span><br><span class="line">      <span class="comment">//删除了元素说明队列有空位，唤醒notFull条件对象添加线程，执行添加操作</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手撕代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS是什么?</title>
      <link href="/2020/07/01/AQS%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/01/AQS%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>AQS全称是AbstractQueuedSynchronizer，即抽象同步队列。下面看一下AQS的类图结构：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/21/16c151e53fa38334?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>为了方便下面几个关键点的理解，大家先<strong>熟悉一下AQS的类图结构</strong>。</p><p>AQS 队列同步器是<strong>用来构建锁或其他同步组件的基础框架</strong>，它使用一个 volatile int state 变量作为共享资源。如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。</p><p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，对同步状态进行更改需要使用同步器提供的 3个方法 <code>getState</code>、<code>setState</code> 和 <code>compareAndSetState</code> ，它们保证状态改变是安全的。</p><h2 id="state-状态的维护"><a href="#state-状态的维护" class="headerlink" title="state 状态的维护"></a>state 状态的维护</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在AQS中维持了一个单一的共享状态state，来实现同步器同步。看一下state的相关代码如下：</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="state源码"><a href="#state源码" class="headerlink" title="state源码"></a>state源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line">   * The synchronization state.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private volatile int state;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Returns the current value of synchronization state.</span><br><span class="line">   * This operation has memory semantics of a &#123;@code volatile&#125; read.</span><br><span class="line">   * @return current state value</span><br><span class="line">   *&#x2F;</span><br><span class="line">  protected final int getState() &#123;</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Sets the value of synchronization state.</span><br><span class="line">   * This operation has memory semantics of a &#123;@code volatile&#125; write.</span><br><span class="line">   * @param newState the new state value</span><br><span class="line">   *&#x2F;</span><br><span class="line">  protected final void setState(int newState) &#123;</span><br><span class="line">      state &#x3D; newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Atomically sets synchronization state to the given updated</span><br><span class="line">   * value if the current state value equals the expected value.</span><br><span class="line">   * This operation has memory semantics of a &#123;@code volatile&#125; read</span><br><span class="line">   * and write.</span><br><span class="line">   *</span><br><span class="line">   * @param expect the expected value</span><br><span class="line">   * @param update the new value</span><br><span class="line">   * @return &#123;@code true&#125; if successful. False return indicates that the actual</span><br><span class="line">   *         value was not equal to the expected value.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">      &#x2F;&#x2F; See below for intrinsics setup to support this</span><br><span class="line">      return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="state-源码设计几个回答要点："><a href="#state-源码设计几个回答要点：" class="headerlink" title="state 源码设计几个回答要点："></a>state 源码设计几个回答要点：</h3><ul><li>state用volatile修饰，保证多线程中的可见性。</li><li>getState()和setState()方法采用final修饰，限制AQS的子类重写它们两。</li><li>compareAndSetState（）方法采用乐观锁思想的CAS算法，也是采用final修饰的，不允许子类重写。</li></ul><h2 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h2><p>谈到CLH队列，我们结合以上state状态，先来看一下<strong>AQS原理图</strong>：</p><img src="/2020/07/01/AQS%E6%98%AF%E4%BB%80%E4%B9%88/1.jpg" class title="this is AQS"><p>CLH(Craig, Landin, and Hagersten locks) 同步队列 是一个FIFO双向队列，其内部通过节点head和tail记录队首和队尾元素，队列元素的类型为Node。</p><p><strong>AQS依赖它来完成同步状态state的管理，当前线程如果获取同步状态失败时，AQS则会调用addWaiter方法，CAS的方式将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程</strong>，<strong>CAS设置失败会采用死循环的方式</strong>。当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><p>CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），condition队列的后续节点（nextWaiter）如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/31/16c4545ea0b027b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>waitStatus几种状态状态：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/7/31/16c454d3d62d9108?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>我们再看一下CLH队列入列以及出列的代码：</p><h3 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h3><p>CLH队列入列就是<strong>tail指向新节点、新节点的prev指向当前最后的节点，当前最后一个节点的next指向当前节点</strong>。addWaiter方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造Node</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">  Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">        &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure（快速尝试添加尾节点）</span><br><span class="line">        Node pred &#x3D; tail;</span><br><span class="line">        if (pred !&#x3D; null) &#123;</span><br><span class="line">            node.prev &#x3D; pred;</span><br><span class="line">            &#x2F;&#x2F;CAS设置尾节点</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next &#x3D; node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;多次尝试</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>由以上代码可得，addWaiter设置尾节点失败的话，调用enq(Node node)方法设置尾节点，enq方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   private Node enq(final Node node) &#123;</span><br><span class="line">        &#x2F;&#x2F;死循环尝试，知道成功为止</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node t &#x3D; tail;</span><br><span class="line">            &#x2F;&#x2F;tail 不存在，设置为首节点</span><br><span class="line">            if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    tail &#x3D; head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node.prev &#x3D; t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next &#x3D; node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="出列"><a href="#出列" class="headerlink" title="出列"></a>出列</h3><p>首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点。可以看一下以下两段源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  Node h &#x3D; head;</span><br><span class="line">  if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">  unparkSuccessor(h);</span><br><span class="line">复制代码</span><br><span class="line"> private void unparkSuccessor(Node node) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">         * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">         * fails or if status is changed by waiting thread.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int ws &#x3D; node.waitStatus;</span><br><span class="line">        if (ws &lt; 0)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Thread to unpark is held in successor, which is normally</span><br><span class="line">         * just the next node.  But if cancelled or apparently null,</span><br><span class="line">         * traverse backwards from tail to find the actual</span><br><span class="line">         * non-cancelled successor.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Node s &#x3D; node.next;</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">            s &#x3D; null;</span><br><span class="line">            for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">                if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                    s &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s !&#x3D; null)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="CLH核心几个回答要点"><a href="#CLH核心几个回答要点" class="headerlink" title="CLH核心几个回答要点"></a>CLH核心几个回答要点</h3><ul><li>双向链表入列出列</li><li>CAS算法设置尾节点+死循环自旋。</li></ul><p><strong>CAS算法，可以看一下我工作实战中仿造CAS算法解决并发问题的实现</strong> <a href="https://juejin.im/post/5d0616ade51d457756536791" target="_blank" rel="noopener">juejin.im/post/5d0616…</a></p><h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2><h3 id="ConditionObject简介"><a href="#ConditionObject简介" class="headerlink" title="ConditionObject简介"></a>ConditionObject简介</h3><p>我们都知道，synchronized控制同步的时候，可以配合<strong>Object的wait()、notify()，notifyAll()</strong> 系列方法可以实现等待/通知模式。而Lock呢？它提供了条件Condition接口，配合<strong>await(),signal(),signalAll()</strong> 等方法也可以实现等待/通知机制。<strong>ConditionObject实现了Condition接口</strong>，给AQS提供<strong>条件变量的支持</strong> 。</p><h3 id="Condition队列与CLH队列的那些事"><a href="#Condition队列与CLH队列的那些事" class="headerlink" title="Condition队列与CLH队列的那些事"></a>Condition队列与CLH队列的那些事</h3><p>我们先来看一下图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/30/16c4214fad310ccf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>ConditionObject队列与CLH队列的爱恨情仇：</strong></p><ul><li>调用了await()方法的线程，会被加入到conditionObject等待队列中，并且唤醒CLH队列中head节点的下一个节点。</li><li>线程在某个ConditionObject对象上调用了singnal()方法后，等待队列中的firstWaiter会被加入到AQS的CLH队列中，等待被唤醒。</li><li>当线程调用unLock()方法释放锁时，CLH队列中的head节点的下一个节点(在本例中是firtWaiter)，会被唤醒。</li></ul><p><strong>区别：</strong></p><ul><li>ConditionObject对象都维护了一个单独的<strong>等待队列</strong> ，AQS所维护的CLH队列是<strong>同步队列</strong>，它们节点类型相同，都是Node。</li></ul><h2 id="独占与共享模式。"><a href="#独占与共享模式。" class="headerlink" title="独占与共享模式。"></a>独占与共享模式。</h2><p>AQS支持两种同步模式:独占式和共享式。</p><ul><li><p>Exclusive</p><p>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><p><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p></li></ul><p><strong>独占模式</strong>表示锁只会被一个线程占用，其他线程必须等到持有锁的线程释放锁后才能获取锁，同一时间只能有一个线程获取到锁。</p><p><strong>共享模式</strong>表示多个线程获取同一个锁有可能成功</p><p>独占模式通过 acquire 和 release 方法获取和释放锁，共享模式通过 acquireShared 和 releaseShared</p><p><img src="https://img-blog.csdnimg.cn/20200305231339850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxaW50ZXJuZXQ=,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200305231413792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxaW50ZXJuZXQ=,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h3><p>获取同步状态时，调用 <code>acquire</code> 方法，维护一个同步队列，使用 <code>tryAcquire</code> 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 <code>addWaiter</code> 方法加入到同步队列的尾部，在队列中自旋。之后调用 <code>acquireQueued</code> 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞，被阻塞线程的唤醒主要依靠前驱节点的出队或被中断实现，移出队列或停止自旋的条件是前驱节点是头结点且成功获取了同步状态。</p><p>释放同步状态时，同步器调用 <code>tryRelease</code> 方法释放同步状态，然后调用 <code>unparkSuccessor</code> 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。</p><p>同一时刻仅有一个线程持有同步状态，如<strong>ReentrantLock</strong>。又可分为公平锁和非公平锁。</p><p><strong>公平锁：</strong> 按照线程在队列中的排队顺序，有礼貌的，先到者先拿到锁。</p><p><strong>非公平锁：</strong> 当线程要获取锁时，无视队列顺序直接去抢锁，不讲道理的，谁抢到就是谁的。</p><p><strong>acquire(int arg)是独占式获取同步状态的方法</strong>，我们来看一下源码：</p><ul><li><strong>acquire(long arg)方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  public final void acquire(long arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>addWaiter方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造Node</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">  Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">        &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure（快速尝试添加尾节点）</span><br><span class="line">        Node pred &#x3D; tail;</span><br><span class="line">        if (pred !&#x3D; null) &#123;</span><br><span class="line">            node.prev &#x3D; pred;</span><br><span class="line">            &#x2F;&#x2F;CAS设置尾节点</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next &#x3D; node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;多次尝试</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>acquireQueued(final Node node, long arg)方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> final boolean acquireQueued(final Node node, long arg) &#123;</span><br><span class="line">        boolean failed &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted &#x3D; false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p &#x3D; node.predecessor();</span><br><span class="line">                if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>selfInterrupt()方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">     Thread.currentThread().interrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>结合源代码，可得acquire(int arg)方法流程图，如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/30/16c42890d2ec5e01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h3><p>多个线程可同时执行，如Semaphore/CountDownLatch等都是共享式的产物。</p><p>获取同步状态时，调用 <code>acquireShared</code> 方法，该方法调用 <code>tryAcquireShared</code> 方法尝试获取同步状态，返回值为 int 类型，返回值不小于于 0 表示能获取同步状态。因此在共享式获取锁的自旋过程中，成功获取同步状态并退出自旋的条件就是该方法的返回值不小于0。</p><p>释放同步状态时，调用 <code>releaseShared</code> 方法，释放后会唤醒后续处于等待状态的节点。它和独占式的区别在于 <code>tryReleaseShared</code> 方法必须确保同步状态安全释放，通过循环 CAS 保证，因为释放同步状态的操作会同时来自多个线程。</p><p><strong>acquireShared(long arg)是共享式获取同步状态的方法</strong>，可以看一下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  public final void acquireShared(long arg) &#123;</span><br><span class="line">        if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>由上可得，先调用tryAcquireShared(int arg)方法尝试获取同步状态，如果获取失败，调用<strong>doAcquireShared(int arg)自旋方式获取同步状态</strong>，方法源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> private void doAcquireShared(long arg) &#123;</span><br><span class="line">        final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">        boolean failed &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted &#x3D; false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p &#x3D; node.predecessor();</span><br><span class="line">                if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                    long r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                        if (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed &#x3D; false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><a href="https://www.javadoop.com/" target="_blank" rel="noopener">https://www.javadoop.com/</a></p><h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><p>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）<br>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。<br>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p><p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">isHeldExclusively()&#x2F;&#x2F;该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">tryAcquire(int)&#x2F;&#x2F;独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br><span class="line">tryRelease(int)&#x2F;&#x2F;独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br><span class="line">tryAcquireShared(int)&#x2F;&#x2F;共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">tryReleaseShared(int)&#x2F;&#x2F;共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p><p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2 id="自定义同步器。"><a href="#自定义同步器。" class="headerlink" title="自定义同步器。"></a>自定义同步器。</h2><p>基于以上分析，我们都知道<strong>state，CLH队列，ConditionObject队列</strong> 等这些关键点，你要实现自定义锁的话，首先需要确定你要实现的是<strong>独占锁还是共享锁，定义原子变量state的含义，再定义一个内部类去继承AQS，重写对应的模板方法</strong>。</p><p>我们来看一下基于 AQS 实现的不可重入的独占锁的demo，来自《Java并发编程之美》：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class NonReentrantLock implements Lock,Serializable&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;内部类,自定义同步器</span><br><span class="line">    static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        &#x2F;&#x2F;是否锁已经被持有</span><br><span class="line">        public boolean isHeldExclusively() &#123;</span><br><span class="line">            return getState() &#x3D;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果state为0 则尝试获取锁</span><br><span class="line">        public boolean tryAcquire(int arg) &#123;</span><br><span class="line">            assert arg&#x3D;&#x3D; 1 ;</span><br><span class="line">            &#x2F;&#x2F;CAS设置状态,能保证操作的原子性，当前为状态为0,操作成功状态改为1</span><br><span class="line">            if(compareAndSetState(0, 1))&#123;</span><br><span class="line">                &#x2F;&#x2F;设置当前独占的线程</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;尝试释放锁，设置state为0</span><br><span class="line">        public boolean tryRelease(int arg) &#123;</span><br><span class="line">            assert arg &#x3D;&#x3D;1;</span><br><span class="line">            &#x2F;&#x2F;如果同步器同步器状态等于0,则抛出监视器非法状态异常</span><br><span class="line">            if(getState() &#x3D;&#x3D; 0)</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#x2F;&#x2F;设置独占锁的线程为null</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            &#x2F;&#x2F;设置同步状态为0</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回Condition,每个Condition都包含了一个Condition队列</span><br><span class="line">        Condition newCondition()&#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个Sync来做具体的工作</span><br><span class="line">    private final Sync sync&#x3D; new Sync ();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isLocked() &#123;</span><br><span class="line">        return sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">        @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>NonReentrantLockDemoTest:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class NonReentrantLockDemoTest &#123;</span><br><span class="line"></span><br><span class="line">    private static NonReentrantLock nonReentrantLock &#x3D; new NonReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                nonReentrantLock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    nonReentrantLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/31/16c45d2d8320a2c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>作者：Jay_huaxiao<br>链接：<a href="https://juejin.im/post/5d34502cf265da1baf7d27aa" target="_blank" rel="noopener">https://juejin.im/post/5d34502cf265da1baf7d27aa</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Lock lock&#x3D;new ReentrantLock();</span><br><span class="line">        Condition a&#x3D;lock.newCondition();</span><br><span class="line">        Thread t1&#x3D;new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">             lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;wo shi t1 aaa&quot;);</span><br><span class="line"></span><br><span class="line">                    a.signal();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2&#x3D;new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;wo shi t2 &quot;);</span><br><span class="line">                    a.await();</span><br><span class="line">                    System.out.println(&quot;wo shi t2 aaaa&quot;);</span><br><span class="line"></span><br><span class="line">                    a.signal();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t3&#x3D;new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">&#x2F;&#x2F;                    Thread.sleep(2000);</span><br><span class="line">                    System.out.println(&quot;wo shi t3&quot;);</span><br><span class="line">                    a.await();</span><br><span class="line">                    System.out.println(&quot;wo shi t3 aaaa&quot;);</span><br><span class="line">                    a.signal();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class MyLock implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    private Helper helper&#x3D;new Helper();</span><br><span class="line"></span><br><span class="line">    private class Helper extends AbstractQueuedSynchronizer&#123;</span><br><span class="line">        &#x2F;&#x2F;获取锁</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">            int state&#x3D;getState();</span><br><span class="line">            if(state&#x3D;&#x3D;0)&#123;</span><br><span class="line">                &#x2F;&#x2F;利用CAS原理修改state</span><br><span class="line">                if(compareAndSetState(0,arg))&#123;</span><br><span class="line">                    &#x2F;&#x2F;设置当前线程占有资源</span><br><span class="line">                    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(getExclusiveOwnerThread()&#x3D;&#x3D;Thread.currentThread())&#123;</span><br><span class="line">                setState(getState()+arg);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;释放锁</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryRelease(int arg) &#123;</span><br><span class="line">            int state&#x3D;getState()-arg;</span><br><span class="line">            boolean flag&#x3D;false;</span><br><span class="line">            &#x2F;&#x2F;判断释放后是否为0</span><br><span class="line">            if(state&#x3D;&#x3D;0)&#123;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">                setState(state);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            setState(state);&#x2F;&#x2F;存在线程安全吗？重入性的问题，当前已经独占了资源()state</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Condition newConditionObjecct()&#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        helper.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        helper.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return helper.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return helper.tryAcquireNanos(1,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        helper.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return helper.newConditionObjecct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cookie和Session剖析</title>
      <link href="/2020/06/30/Cookie%E5%92%8CSession%E5%89%96%E6%9E%90/"/>
      <url>/2020/06/30/Cookie%E5%92%8CSession%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="为什么要有Cookie？"><a href="#为什么要有Cookie？" class="headerlink" title="为什么要有Cookie？"></a>为什么要有Cookie？</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来</p><p>保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上</p><p>用途：</p><p>· 会话状态管理（如用户登录状态、购物车）</p><p>· 浏览器行为跟踪（如跟踪分析用户行为等）</p><h2 id="Cookie创建过程？"><a href="#Cookie创建过程？" class="headerlink" title="Cookie创建过程？"></a>Cookie创建过程？</h2><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务<br>器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><h2 id="Cookie分类"><a href="#Cookie分类" class="headerlink" title="Cookie分类"></a>Cookie分类</h2><p>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</p><p>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session?"></a>Session?</h2><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p><strong>session 认证流程：</strong></p><ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul><p><strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong></p><p>在对安全性要求极高的场景下，例如转账等操作，除了使用 Session管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h2 id="Session和Cookie区别？"><a href="#Session和Cookie区别？" class="headerlink" title="Session和Cookie区别？"></a>Session和Cookie区别？</h2><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选<br>Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加<br>密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信<br>息都存储到 Session 中。</li></ul><h2 id="Cookie和Session的选择？"><a href="#Cookie和Session的选择？" class="headerlink" title="Cookie和Session的选择？"></a>Cookie和Session的选择？</h2><ol><li><p>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session；</p></li><li><p>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</p></li><li><p>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</p></li></ol><h2 id="Cookie的不可跨域名性？"><a href="#Cookie的不可跨域名性？" class="headerlink" title="Cookie的不可跨域名性？"></a>Cookie的不可跨域名性？</h2><p>一个cookie只能用于一个域名(有效的二级域名，比如 shop.com)，不能够发给其它的域名。Cookie跨域指的是允许不同的二级域名间共享</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token?"></a>Token?</h2><ol><li>把用户的用户名和密码发到后端</li><li>后端进行校验，校验成功会生成token, 把token发送给客户端</li><li>客户端自己保存token, 再次请求就要在Http协议的请求头中带着token去访问服务端，和在服务端保存的token信息进行比对校验。</li></ol><ul><li><strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</strong></li><li><strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</strong></li><li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/29/16f523a04d9c745f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h2><ul><li><p>Session 是一种<strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息</strong>。而 Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></p></li><li><p>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。<strong>如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</strong></p></li><li><p>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。</p></li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><p>JWT 的 Header 通常包含两个字段，分别是：typ(type) 和 alg(algorithm)。</p><ul><li>typ：token的类型，这里固定为 JWT</li><li>alg：使用的 hash 算法，例如：HMAC SHA256 或者 RSA</li></ul><p>一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对他进行编码后是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; base64.b64encode(json.dumps(&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;))</span><br><span class="line">&#39;eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9&#39;</span><br></pre></td></tr></table></figure><h5 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h5><p>JWT 中的 Payload 其实就是真实存储我们需要传递的信息的部分，例如正常我们会存储些用户 ID、用户名之类的。此外，还包含一些例如发布人、过期日期等的元数据。</p><p>但是，这部分和 Header 部分不一样的地方在于这个地方可以加密，而不是简单得直接进行 BASE64 编码。但是这里我为了解释方便就直接使用 BASE64 编码，需要注意的是，这里的 BASE64 编码稍微有点不一样，切确得说应该是 Base64UrlEncoder，和 Base64 编码的区别在于会忽略最后的 padding（=号），然后 ‘-‘ 会被替换成’_’。</p><p>举个例子，例如我们的 Payload 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;user_id&quot;:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure><p>那么直接 Base64 的话应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; base64.urlsafe_b64encode(&#39;&#123;&quot;user_id&quot;:&quot;zhangsan&quot;&#125;&#39;)</span><br><span class="line">&#39;eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ&#x3D;&#x3D;&#39;</span><br></pre></td></tr></table></figure><p>然后去掉 = 号，最后应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ&#39;</span><br></pre></td></tr></table></figure><h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>Signature 部分其实就是对我们前面的 Header 和 Payload 部分进行签名，保证 Token 在传输的过程中没有被篡改或者损坏，签名的算法也很简单，但是，为了加密，所以除了 Header 和 Payload 之外，还多了一个密钥字段，完整算法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    Signature &#x3D; HMACSHA256(</span><br><span class="line">        base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">        base64UrlEncode(payload),</span><br><span class="line">        secret)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>还是以前面的例子为例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    base64UrlEncode(header)  &#x3D;》 eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9</span><br><span class="line">    base64UrlEncode(payload) &#x3D;》 eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>secret 就设为：”secret”, 那最后出来的签名应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    &gt;&gt;&gt; import hmac</span><br><span class="line">    &gt;&gt;&gt; import hashlib</span><br><span class="line">    &gt;&gt;&gt; import base64</span><br><span class="line">    &gt;&gt;&gt; dig &#x3D; hmac.new(&#39;secret&#39;,     &gt;&gt;&gt; msg&#x3D;&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ&quot;, </span><br><span class="line">               digestmod&#x3D;</span><br><span class="line">    &gt;&gt;&gt; base64.b64encode(dig.digest())</span><br><span class="line">    &#39;ec7IVPU-ePtbdkb85IRnK4t4nUVvF2bBf8fGhJmEwSs&#x3D;&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>将上面三个部分组装起来就组成了我们的 JWT token了，所以我们的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#123;&#39;user_id&#39;: &#39;zhangsan&#39;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>的 token 就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ.ec7IVPU-ePtbdkb85IRnK4t4nUVvF2bBf8fGhJmEwSs</span><br></pre></td></tr></table></figure><ol><li><p>在头部信息中声明加密算法和常量， 然后把header使用json转化为字符串</p></li><li><p>在载荷中声明用户信息，同时还有一些其他的内容；再次使用json 把载荷部分进行转化，转化为字符串</p></li><li><p>使用在header中声明的加密算法和每个项目随机生成的secret来进行加密， 把第一步分字符串和第二部分的字符串进行加密， 生成新的字符串。词字符串是独一无二的。</p></li><li><p>解密的时候，只要客户端带着JWT来发起请求，服务端就直接使用secret进行解密。</p></li></ol><h2 id="JWT与token的联系"><a href="#JWT与token的联系" class="headerlink" title="JWT与token的联系"></a>JWT与token的联系</h2><p>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</p><p>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用的状态码</title>
      <link href="/2020/06/30/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2020/06/30/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>{asset_img 1.png 表格}</p><ul><li><p>200：一切正常</p></li><li><p>204 No content：一切正常，但响应头后没有 body 数据</p></li><li><p>206：这种响应是在客户端表明自己只需要目标URL上的部分资源的时候返回的.这种情况经常发生在客户端继续请求一个未完成的下载的时候</p></li></ul><p>​      (状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range:       bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。)</p><ul><li><p>301：永久性重定向</p></li><li><p>302：临时重定向</p><p>301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI</p></li><li><p>303：跟302相似，只是对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI</p></li><li><p>304：“304 Not Modified”，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。</p></li><li><p>307：临时重定向，与302类似，只是强制要求使用POST方法</p></li><li><p>400  Bad Request：请求报文语法有误，服务器无法识别</p></li><li><p>401：请求需要认证</p></li><li><p>403 Forbidden：请求的对应资源禁止被访问</p></li><li><p>404 Not Found：服务器无法找到对应资源</p></li><li><p>500 Internal Server Error：服务器内部错误</p></li><li><p>“502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</p></li><li><p>503 Service Unavailable：服务器正忙</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是DHCP以及DHCP是怎么工作的</title>
      <link href="/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFDHCP%E4%BB%A5%E5%8F%8ADHCP%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
      <url>/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFDHCP%E4%BB%A5%E5%8F%8ADHCP%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p><strong>DHCP (Dynamic Host Configuration Protocol) 动态主机配置协议提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信</strong></p><p><strong>息。</strong></p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><ol><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP</li></ol><p>中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继</p><p>代理。</p><ol start="2"><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客</li></ol><p>户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是TCP粘包</title>
      <link href="/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFTCP%E7%B2%98%E5%8C%85/"/>
      <url>/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFTCP%E7%B2%98%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>原因可能是发送方也可能是接收方造成的。</p><p>发送方原因：TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</p><p>接收方原因：TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。</p><h2 id="处理方法："><a href="#处理方法：" class="headerlink" title="处理方法："></a>处理方法：</h2><p>1.发送方关闭Nagle算法。</p><p>2.接收方：接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层循环读取所有的数据，根据报文的长度判断每个包开始和结束的位置。</p><p>分包机制一般有两个通用的解决方法：</p><ol><li><p>特殊字符控制；</p></li><li><p>在包头首都添加数据包的长度</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP和UDP传输的报文段和用户数据报的差异</title>
      <link href="/2020/06/30/TCP%E5%92%8CUDP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
      <url>/2020/06/30/TCP%E5%92%8CUDP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><img src="/2020/06/30/TCP%E5%92%8CUDP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%AE%E5%BC%82/1.png" class title="TCP"><p>16位源端口号+16位目的端口号+32位序号+32位确认号+4位头部长度（单位4字节）+6位保留+6个关键字（SYN,ACK，FIN）+16位窗口大小（指接收窗口）+16位校验和+16位紧急指针+最多40字节的选项；</p><img src="/2020/06/30/TCP%E5%92%8CUDP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%AE%E5%BC%82/2.png" class title="UDP"><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是CSMA/CD</title>
      <link href="/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFCSMA-CD/"/>
      <url>/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFCSMA-CD/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><p>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</p></li><li><p>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</p></li><li><p>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</p></li></ul><p>记端到端的传播时延为 t，最先发送的站点最多经过 2t就可以知道是否发生了碰撞，称 2t 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2^k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引相关疑问</title>
      <link href="/2020/06/30/%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E7%96%91%E9%97%AE/"/>
      <url>/2020/06/30/%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E7%96%91%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/24/1710a4ae8e0c0464?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="索引有哪几种"><a href="#索引有哪几种" class="headerlink" title="索引有哪几种"></a>索引有哪几种</h2><ol><li><p>B+Tree 索引</p></li><li><p>哈希索引</p></li><li><p>全文索引</p></li><li><p>空间数据索引</p></li></ol><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>联合索引是指对表上的多个列进行索引，联合索引也是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2.</p><p><img src="https://img-blog.csdn.net/20180807153551287?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtMTA2MDg5MTI2NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h2 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h2><p>顾名思义是最左优先，以最左边的为起点任何连续的索引都能匹配上.(A,B,C) 这样3列，mysql会首先匹配A，然后再B，C.</p><p>如果用(B,C)这样的数据来检索的话，就会找不到A使得索引失效。</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引包含所有需要查询的字段的值,不需要回表操作。<br>具有以下优点：<br>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。<br>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以<br>不使用系统调用（通常比较费时）。<br>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</p><h2 id="什么情况下不应该用索引？"><a href="#什么情况下不应该用索引？" class="headerlink" title="什么情况下不应该用索引？"></a>什么情况下不应该用索引？</h2><p>1.表记录少的</p><p>2.经常增删改的表或者字段</p><p>3.where条件里用不到的字段不创建索引</p><p>4.过滤性不好的不适合建索引</p><h2 id="适合创建索引条件"><a href="#适合创建索引条件" class="headerlink" title="适合创建索引条件"></a>适合创建索引条件</h2><p>1.主键自动建立唯一索引</p><p>2.频繁作为查询条件的字段应该建立索引</p><p>3.查询中与其他表关联的字段，外键关系建立索引</p><p>4.单键/组合索引的选择问题，组合索引性价比更高</p><p>5.查询中排序的字段，排序字段若通过索引去访问将大大提高排序效率</p><p>6.查询中统计或者分组字段</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聚簇索引和非聚簇索引</title>
      <link href="/2020/06/30/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
      <url>/2020/06/30/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="聚集索引（聚簇索引）："><a href="#聚集索引（聚簇索引）：" class="headerlink" title="聚集索引（聚簇索引）："></a>聚集索引（聚簇索引）：</h3><p>以innodb作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。这种以主键作为B+树索引的键值而构建的B+树索引，我们称之为聚集索引。 </p><h3 id="非聚集索引（非聚簇索引）："><a href="#非聚集索引（非聚簇索引）：" class="headerlink" title="非聚集索引（非聚簇索引）："></a>非聚集索引（非聚簇索引）：</h3><p>以主键以外的列值作为键值构建的B+树索引，我们称之为非聚集索引。非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。</p><p><img src="/2020/06/30/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630104400532.png" alt="image-20200630104400532"></p><p><img src="file:///C:/Users/77406/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一条SQL语句执行很慢的原因有哪些</title>
      <link href="/2020/06/30/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
      <url>/2020/06/30/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、开始装逼：分类讨论"><a href="#一、开始装逼：分类讨论" class="headerlink" title="一、开始装逼：分类讨论"></a>一、开始装逼：分类讨论</h2><p>一条 SQL 语句执行的很慢，那是每次执行都很慢呢？还是大多数情况下是正常的，偶尔出现很慢呢？所以我觉得，我们还得分以下两种情况来讨论。</p><p>1、大多数情况是正常的，只是偶尔会出现很慢的情况。</p><p>2、在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。</p><p>针对这两种情况，我们来分析下可能是哪些原因导致的。</p><h2 id="二、针对偶尔很慢的情况"><a href="#二、针对偶尔很慢的情况" class="headerlink" title="二、针对偶尔很慢的情况"></a>二、针对偶尔很慢的情况</h2><p>一条 SQL 大多数情况正常，偶尔才能出现很慢的情况，针对这种情况，我觉得这条SQL语句的书写本身是没什么问题的，而是其他原因导致的，那会是什么原因呢？</p><h3 id="1、数据库在刷新脏页我也无奈啊"><a href="#1、数据库在刷新脏页我也无奈啊" class="headerlink" title="1、数据库在刷新脏页我也无奈啊"></a>1、数据库在刷新脏页我也无奈啊</h3><p>当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在<strong>内存</strong>中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到<strong>磁盘</strong>中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到<strong>磁盘</strong>中去。</p><p>不过，redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，<strong>就会导致我们平时正常的SQL语句突然执行的很慢</strong>，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。</p><h3 id="2、拿不到锁我能怎么办"><a href="#2、拿不到锁我能怎么办" class="headerlink" title="2、拿不到锁我能怎么办"></a>2、拿不到锁我能怎么办</h3><p>这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，我也没办法啊。</p><p>如果要判断是否真的在等待锁，我们可以用 <strong>show processlist</strong>这个命令来查看当前的状态哦，这里我要提醒一下，有些命令最好记录一下，反正，我被问了好几个命令，都不知道怎么写，呵呵。</p><p>下来我们来访分析下第二种情况，我觉得第二种情况的分析才是最重要的</p><h2 id="三、针对一直都这么慢的情况"><a href="#三、针对一直都这么慢的情况" class="headerlink" title="三、针对一直都这么慢的情况"></a>三、针对一直都这么慢的情况</h2><p>如果在数据量一样大的情况下，这条 SQL 语句每次都执行的这么慢，那就就要好好考虑下你的 SQL 书写了，下面我们来分析下哪些原因会导致我们的 SQL 语句执行的很不理想。</p><p>我们先来假设我们有一个表，表里有下面两个字段,分别是主键 id，和两个普通字段 c 和 d。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE &#96;t&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;c&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;d&#96; int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><h3 id="1、扎心了，没用到索引"><a href="#1、扎心了，没用到索引" class="headerlink" title="1、扎心了，没用到索引"></a>1、扎心了，没用到索引</h3><p>没有用上索引，我觉得这个原因是很多人都能想到的，例如你要查询这条语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where 100 &lt;c and c &lt; 100000;</span><br></pre></td></tr></table></figure><p><strong>（1）、字段没有索引</strong></p><p>刚好你的 c 字段上没有索引，那么抱歉，只能走全表扫描了，你就体验不会索引带来的乐趣了，所以，这回导致这条查询语句很慢。</p><p><strong>（2）、字段有索引，但却没有用索引</strong></p><p>好吧，这个时候你给 c 这个字段加上了索引，然后又查询了一条语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c - 1 &#x3D; 1000;</span><br></pre></td></tr></table></figure><p>我想问大家一个问题，这样子在查询的时候会用索引查询吗？</p><p>答是不会，如果我们在字段的左边做了运算，那么很抱歉，在查询的时候，就不会用上索引了，所以呢，大家要注意这种<strong>字段上有索引，但由于自己的疏忽，导致系统没有使用索引</strong>的情况了。</p><p>正确的查询应该如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c &#x3D; 1000 + 1;</span><br></pre></td></tr></table></figure><p>有人可能会说，右边有运算就能用上索引？难道数据库就不会自动帮我们优化一下，自动把 c - 1=1000 自动转换为 c = 1000+1。</p><p>不好意思，确实不会帮你，所以，你要注意了。</p><p><strong>（3）、函数操作导致没有用上索引</strong></p><p>如果我们在查询的时候，对字段进行了函数操作，也是会导致没有用上索引的，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) &#x3D; 1000;</span><br></pre></td></tr></table></figure><p>这里我只是做一个例子，假设函数 pow 是求 c 的 n 次方，实际上可能并没有 pow(c,2)这个函数。其实这个和上面在左边做运算也是很类似的。</p><p>所以呢，一条语句执行都很慢的时候，可能是该语句没有用上索引了，不过具体是啥原因导致没有用上索引的呢，你就要会分析了，我上面列举的三个原因，应该是出现的比较多的吧。</p><h3 id="2、呵呵，数据库自己选错索引了"><a href="#2、呵呵，数据库自己选错索引了" class="headerlink" title="2、呵呵，数据库自己选错索引了"></a>2、呵呵，数据库自己选错索引了</h3><p>我们在进行查询操作的时候，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where 100 &lt; c and c &lt; 100000;</span><br></pre></td></tr></table></figure><p>我们知道，主键索引和非主键索引是有区别的，主键索引存放的值是<strong>整行字段的数据</strong>，而非主键索引上存放的值不是整行字段的数据，而且存放<strong>主键字段的值</strong>。不大懂的可以看我这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485127&idx=2&sn=b9bbaa8cd34f3eb71c28169395f5d06a&scene=21#wechat_redirect" target="_blank" rel="noopener">面试小知识：MySQL索引相关</a>   里面有说到主键索引和非主键索引的区别</p><p>也就是说，我们如果走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。</p><p>好吧扯了这么多，其实我就是想告诉你，就算你在 c 字段上有索引，系统也并不一定会走 c 这个字段上的索引，而是有可能会直接扫描扫描全表，找出所有符合 100 &lt; c and c &lt; 100000 的数据。</p><p><strong>为什么会这样呢？</strong></p><p>其实是这样的，系统在执行这条语句的时候，会进行预测：究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？显然，扫描行数越少当然越好了，因为扫描行数越少，意味着I/O操作的次数越少。</p><p>如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走两次索引。而且，我们也不知道符合 100 c &lt; and c &lt; 10000 这个条件的数据有多少行，万一这个表是全部数据都符合呢？这个时候意味着，走 c 索引不仅扫描的行数是 n，同时还得每行数据走两次索引。</p><p><strong>所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？</strong></p><p>判断来源于系统的预测，也就是说，如果要走 c 字段索引的话，系统会预测走 c 字段索引大概需要扫描多少行。如果预测到要扫描的行数很多，它可能就不走索引而直接扫描全表了。</p><p>那么问题来了，<strong>系统是怎么预测判断的呢？</strong>这里我给你讲下系统是怎么判断的吧，虽然这个时候我已经写到脖子有点酸了。</p><p>系统是通过<strong>索引的区分度</strong>来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。我们也把区分度称之为<strong>基数</strong>，即区分度越高，基数越大。所以呢，基数越大，意味着符合 100 &lt; c and c &lt; 10000 这个条件的行数越少。</p><p>所以呢，一个索引的基数越大，意味着走索引查询越有优势。</p><p><strong>那么问题来了，怎么知道这个索引的基数呢？</strong></p><p>系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过<strong>采样</strong>的方式，来预测索引的基数的。</p><p><strong>扯了这么多，重点的来了</strong>，居然是采样，那就有可能出现<strong>失误</strong>的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。<strong>然后就呵呵，系统就不走 c 索引了，直接走全部扫描了</strong>。</p><p>所以呢，说了这么多，得出结论：<strong>由于统计的失误，导致系统没有走索引，而是走了全表扫描</strong>，而这，也是导致我们 SQL 语句执行的很慢的原因。</p><blockquote><p>这里我声明一下，系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用临时表、是否需要排序等也是会影响系统的选择的。</p></blockquote><p>不过呢，我们有时候也可以通过强制走索引的方式来查询，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t force index(a) where c &lt; 100 and c &lt; 100000;</span><br></pre></td></tr></table></figure><p>我们也可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from t;</span><br></pre></td></tr></table></figure><p>来查询索引的基数和实际是否符合，如果和实际很不符合的话，我们可以重新来统计索引的基数，可以用这条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table t;</span><br></pre></td></tr></table></figure><p>来重新统计分析。</p><p><strong>既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引哦</strong>，这也可能是 SQL 执行的很慢的一个原因。</p><p>好吧，就先扯这么多了，你到时候能扯出这么多，我觉得已经很棒了，下面做一个总结。</p><p><strong>四、总结</strong></p><p>以上是我的总结与理解，最后一个部分，我怕很多人不大懂<strong>数据库居然会选错索引</strong>，所以我详细解释了一下，下面我对以上做一个总结。</p><p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p><p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p><p>(2)、执行的时候，遇到锁，如表锁、行锁。</p><p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p><p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p><p>(2)、数据库选错了索引。</p><p>大家如果有补充的，也是可以留言区补充一波哦。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>reentranlock底层原理</title>
      <link href="/2020/06/30/reentranlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2020/06/30/reentranlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><p>首先<code>ReentrantLock</code>继承自父类<code>Lock</code>，然后有<code>3</code>个内部类，其中中有一个抽象内部类Sync继承AQS，两个内部类NonfairSync和FairSync继承了Sync(Sync重写tryRelease），重写了lock()方法和tryAcquire()方法，分别实现了非公平锁和公平锁。<br><img src="https://uploadfiles.nowcoder.com/files/20191214/592649258_1576325730428_2019121410495622.png" alt="在这里插入图片描述"><br>ReentrantLock默认为非公平锁，如果想创建公平锁，可给构造方法传入参数true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code>有两个构造方法，无参构造方法默认是创建<strong>非公平锁</strong>，而传入<code>true</code>为参数的构造方法创建的是<strong>公平锁</strong>。</p><h3 id="非公平锁的实现原理"><a href="#非公平锁的实现原理" class="headerlink" title="非公平锁的实现原理"></a>非公平锁的实现原理</h3><p>当我们使用无参构造方法构造的时候即<code>ReentrantLock lock = new ReentrantLock()</code>，创建的就是非公平锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者传入false参数 创建的也是非公平锁</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="lock方法获取锁"><a href="#lock方法获取锁" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol><li><code>lock</code>方法调用<code>CAS</code>方法设置<code>state</code>的值，如果<code>state</code>等于期望值<code>0</code>(代表锁没有被占用)，那么就将<code>state</code>更新为<code>1</code>(代表该线程获取锁成功)，然后执行<code>setExclusiveOwnerThread</code>方法直接将该线程设置成锁的所有者。如果<code>CAS</code>设置<code>state</code>的值失败，即<code>state</code>不等于<code>0</code>，代表锁正在被占领着，则执行<code>acquire(1)</code>，即下面的步骤。</li><li><code>nonfairTryAcquire</code>方法首先调用<code>getState</code>方法获取<code>state</code>的值，如果<code>state</code>的值为<code>0</code>(之前占领锁的线程刚好释放了锁)，那么用<code>CAS</code>设置<code>state</code>的值，设置成功则将该线程设置成锁的所有者，并且返回<code>true</code>。如果<code>state</code>的值不为<code>0</code>，那就<strong>调用<code>getExclusiveOwnerThread</code>方法查看占用锁的线程是不是自己</strong>，如果是的话那就直接将<code>state + 1</code>，然后返回<code>true</code>。如果<code>state</code>不为<code>0</code>且锁的所有者又不是自己，那就返回<code>false</code>，<strong>然后线程会进入到同步队列中</strong>。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">作者：冠状病毒biss</span><br><span class="line">链接：https:&#x2F;&#x2F;www.nowcoder.com&#x2F;discuss&#x2F;355081?type&#x3D;post&amp;order&#x3D;time&amp;pos&#x3D;&amp;page&#x3D;1&amp;channel&#x3D;0&amp;source_id&#x3D;search_post</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">弊端：可能导致排队的线程一直无法得到CPU资源的饥饿现象</span><br><span class="line">public void lock() &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line">1.调用NofairSync中的lock方法</span><br><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))&#x2F;&#x2F;AQS类的方法 使用CAS算法更新state的值</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());&#x2F;&#x2F;若更新成功设置当前线程为独占线程c</span><br><span class="line">    else</span><br><span class="line">        acquire(1);&#x2F;&#x2F;若CAS更新失败，执行是AQS类的acquire()方法</span><br><span class="line">&#125;</span><br><span class="line">2.AQS中的acquire()方法</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">if (!tryAcquire(arg) &amp;&amp;&#x2F;&#x2F;尝试获取锁 失败则调用addWaiter方法创建结点并追加到队列尾部</span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&#x2F;&#x2F;然后调用acquireQueued阻塞或者自旋尝试获取锁</span><br><span class="line">    selfInterrupt();&#x2F;&#x2F;在 acquireQueued 中，如果线程是因为中断而退出的阻塞状态会返回true</span><br><span class="line">    &#125;</span><br><span class="line">   3.Nofair中的tryAcquire()重写</span><br><span class="line">   protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;如果当前state值为0 并CAS操作成功 独占锁 返回true</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F;否则判断当前线程是否是持有锁的那个独占线程</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;&#x2F;&#x2F;相当于重入锁</span><br><span class="line">        int nextc &#x3D; c + acquires;&#x2F;&#x2F;是将state值更新</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; 假如超过最大可重入次数</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;&#x2F;&#x2F;state不为0，并且不是那个持有锁的线程 返回false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryRelease锁的释放"><a href="#tryRelease锁的释放" class="headerlink" title="tryRelease锁的释放"></a>tryRelease锁的释放</h4><ol><li>判断当前线程是不是锁的所有者，如果是则进行步骤<code>2</code>，如果不是则抛出异常。</li><li>判断此次释放锁后<code>state</code>的值是否为0，如果是则代表<strong>锁没有重入</strong>，然后将锁的所有者设置成<code>null</code>且返回<code>true</code>，然后执行步骤<code>3</code>，如果不是则<strong>代表锁发生了重入</strong>执行步骤<code>4</code>。</li><li>现在锁已经释放完，即<code>state=0</code>，唤醒同步队列中的后继节点进行锁的获取。</li><li>锁还没有释放完，即<code>state!=0</code>，不唤醒同步队列。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169aad4a8e578933?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;子类重写的tryRelease方法，需要等锁的state&#x3D;0，即tryRelease返回true的时候，才会去唤醒其</span><br><span class="line">    &#x2F;&#x2F;它线程进行尝试获取锁。</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F;状态的state减去releases</span><br><span class="line">    int c &#x3D; getState() - releases;</span><br><span class="line">    &#x2F;&#x2F;判断锁的所有者是不是该线程</span><br><span class="line">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">        &#x2F;&#x2F;如果所的所有者不是该线程 则抛出异常 也就是锁释放的前提是线程拥有这个锁，</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;如果该线程释放锁之后 状态state&#x3D;0，即锁没有重入，那么直接将将锁的所有者设置成null</span><br><span class="line">    &#x2F;&#x2F;并且返回true，即代表可以唤醒其他线程去获取锁了。如果该线程释放锁之后state不等于0，</span><br><span class="line">    &#x2F;&#x2F;那么代表锁重入了，返回false，代表锁还未正在释放，不用去唤醒其他线程。</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        free &#x3D; true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="公平锁的实现原理"><a href="#公平锁的实现原理" class="headerlink" title="公平锁的实现原理"></a>公平锁的实现原理</h3><h4 id="lock方法获取锁-1"><a href="#lock方法获取锁-1" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol><li>获取状态的<code>state</code>的值，如果<code>state=0</code>即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，执行步骤<code>2</code>。如果<code>state!=0</code>则代表锁正在被其它线程占用，执行步骤<code>3</code>。</li><li><strong>判断同步队列是否存在线程(节点)，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。</strong></li><li><strong>判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中</strong></li></ol><p>通过步骤<code>2</code><strong>实现了锁获取的公平性，即锁的获取按照先来先得的顺序，后来的不能抢先获取锁，非公平锁和公平锁也正是通过这个区别来实现了锁的公平性。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169aaf5a27ee58d5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;同步队列中有线程 且 锁的所有者不是当前线程那么将线程加入到同步队列的尾部，</span><br><span class="line">    &#x2F;&#x2F;保证了公平性，也就是先来的线程先获得锁，后来的不能抢先获取。</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    &#x2F;&#x2F;判断状态state是否等于0，等于0代表锁没有被占用，不等于0则代表锁被占用着。</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;调用hasQueuedPredecessors方法判断同步队列中是否有线程在等待，如果同步队列中没有</span><br><span class="line">        &#x2F;&#x2F;线程在等待 则当前线程成为锁的所有者，如果同步队列中有线程在等待，则继续往下执行</span><br><span class="line">        &#x2F;&#x2F;这个机制就是公平锁的机制，也就是先让先来的线程获取锁，后来的不能抢先获取。</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断当前线程是否为锁的所有者，如果是，那么直接更新状态state，然后返回true。</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果同步队列中有线程存在 且 锁的所有者不是当前线程，则返回false。</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="tryRelease锁的释放-1"><a href="#tryRelease锁的释放-1" class="headerlink" title="tryRelease锁的释放"></a>tryRelease锁的释放</h4><p>公平锁的释放和非公平锁的释放一样，这里就不重复。<br> 公平锁和非公平锁的公平性是在<strong>获取锁</strong>的时候体现出来的，释放的时候都是一样释放的。</p><h3 id="ReentrantLock的等待-通知机制"><a href="#ReentrantLock的等待-通知机制" class="headerlink" title="ReentrantLock的等待/通知机制"></a>ReentrantLock的等待/通知机制</h3><p>我们知道关键字<code>Synchronized</code> + <code>Object</code>的<code>wait</code>和<code>notify</code>、<code>notifyAll</code>方法能实现<strong>等待/通知</strong>机制，那么<code>ReentrantLock</code>是否也能实现这样的等待/通知机制，答案是：可以。<br> <code>ReentrantLock</code>通过<code>Condition</code>对象，也就是<strong>条件队列</strong>实现了和<code>wait</code>、<code>notify</code>、<code>notifyAll</code>相同的语义。 线程执行<code>condition.await()</code>方法，将节点1从同步队列转移到条件队列中。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b3432b128105d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>线程执行<code>condition.signal()</code>方法，将节点1从条件队列中转移到同步队列。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b3411b74cfff1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>因为只有在同步队列中的线程才能去获取锁，所以通过<code>Condition</code>对象的<code>wait</code>和<code>signal</code>方法能实现等待/通知机制。<br> 代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">Condition condition &#x3D; lock.newCondition();</span><br><span class="line">public void await() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;线程获取锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">        condition.await(); &#x2F;&#x2F;调用await()方法 会释放锁，和Object.wait()效果一样。</span><br><span class="line">        System.out.println(&quot;线程被唤醒----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(&quot;线程释放锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void signal() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(1000);  &#x2F;&#x2F;休眠1秒钟 等等一个线程先执行</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;另外一个线程获取到锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">        condition.signal();</span><br><span class="line">        System.out.println(&quot;唤醒线程----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(&quot;另外一个线程释放锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Test t &#x3D; new Test();</span><br><span class="line">    Thread t1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            t.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            t.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程获取锁----Thread-0</span><br><span class="line">另外一个线程获取到锁----Thread-1</span><br><span class="line">唤醒线程----Thread-1</span><br><span class="line">另外一个线程释放锁----Thread-1</span><br><span class="line">线程被唤醒----Thread-0</span><br><span class="line">线程释放锁----Thread-0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>执行的流程大概是这样，线程<code>t1</code>先获取到锁，输出了”线程获取锁—-Thread-0”，然后线程<code>t1</code>调用<code>await</code>方法，调用这个方法的结果就是<strong>线程<code>t1</code>释放了锁进入等待状态，等待唤醒</strong>，接下来线程<code>t2</code>获取到锁，然输出了”另外一个线程获取到锁—-Thread-1”，同时线程<code>t2</code>调用<code>signal</code>方法，调用这个方法的结果就是<strong>唤醒一个在条件队列(Condition)的线程，然后线程<code>t1</code>被唤醒，而这个时候线程<code>t2</code>并没有释放锁，线程<code>t1</code>也就没法获得锁，等线程<code>t2</code>继续执行输出”唤醒线程—-Thread-1”之后线程<code>t2</code>释放锁且输出”另外一个线程释放锁—-Thread-1”，这时候线程<code>t1</code>获得锁，继续往下执行输出了<code>线程被唤醒----Thread-0</code>，然后释放锁输出”线程释放锁—-Thread-0”</strong>。</p><p>如果想单独唤醒部分线程应该怎么做呢？这时就有必要使用多个<code>Condition</code>对象了，因为<code>ReentrantLock</code>支持创建多个<code>Condition</code>对象，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;为了减少篇幅 仅给出伪代码</span><br><span class="line">ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">Condition condition &#x3D; lock.newCondition();</span><br><span class="line">Condition condition1 &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程1 调用condition.await() 线程进入到条件队列</span><br><span class="line">condition.await();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程2 调用condition1.await() 线程进入到条件队列</span><br><span class="line">condition1.await();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程32 调用condition.signal() 仅唤醒调用condition中的线程，不会影响到调用condition1。</span><br><span class="line">condition1.await();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就实现了部分唤醒的功能。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><h3 id="和synchronized的对比"><a href="#和synchronized的对比" class="headerlink" title="和synchronized的对比"></a>和synchronized的对比</h3><ol><li>锁的实现<br>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li><li>性能<br>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</li><li>等待可中断<br>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<br>ReentrantLock 可中断，而 synchronized 不行。</li><li>公平锁<br>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<br>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</li><li>锁绑定多个条件<br>一个 ReentrantLock 可以同时绑定多个 Condition 对象。<br>使用选择<br>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一<br>种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没<br>有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</li></ol><p>作者：薛8<br>链接：<a href="https://juejin.im/post/5c95df97e51d4551d06d8e8e" target="_blank" rel="noopener">https://juejin.im/post/5c95df97e51d4551d06d8e8e</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">https://www.javadoop.com/post/AbstractQueuedSynchronizer</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用explain关键字</title>
      <link href="/2020/06/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8explain%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/06/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8explain%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析你的查询语句或是表结构的性能瓶颈。</p><h2 id="explain执行计划包含的信息"><a href="#explain执行计划包含的信息" class="headerlink" title="explain执行计划包含的信息"></a>explain执行计划包含的信息</h2><p><img src="https://img-blog.csdn.net/20170509232741017?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>其中最重要的字段为：id、type、key、rows、Extra</strong></p><p>id:select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p><p>type : 访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是<strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p><p>key : 使用的索引</p><p>rows : 扫描的行数</p><p>Extra:不适合在其他字段中显示，但是十分重要的额外信息(例如覆盖索引等等)</p><h2 id="各字段详解"><a href="#各字段详解" class="headerlink" title="各字段详解"></a>各字段详解</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序<br>三种情况：<br>1、id相同：执行顺序由上至下</p><p><img src="https://img-blog.csdn.net/20170509234043416?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>2、id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p><p><img src="https://img-blog.csdn.net/20170510223451835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3、id相同又不同（两种情况同时存在）：id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p><p><img src="https://img-blog.csdn.net/20170510224901726?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>查询的类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询</p><p>1、SIMPLE：简单的select查询，查询中不包含子查询或者union<br>2、PRIMARY：查询中包含任何复杂的子部分，最外层查询则被标记为primary<br>3、SUBQUERY：在select 或 where列表中包含了子查询<br>4、DERIVED：在from列表中包含的子查询被标记为derived（衍生），mysql或递归执行这些子查询，把结果放在零时表里<br>5、UNION：若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived<br>6、UNION RESULT：从union表获取结果的select</p><p><img src="https://img-blog.csdn.net/20170510231953999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>一般来说，好的sql查询至少达到range级别，最好能达到ref</p><p>1、system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计</p><p>2、const：表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const</p><p><img src="https://img-blog.csdn.net/20170511215148532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3、eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描。</p><p>注意：ALL全表扫描的表记录最少的表如t1表</p><p><img src="https://img-blog.csdn.net/20170512143354425?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>4、ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体</p><p><img src="https://img-blog.csdn.net/20170512150131136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>5、range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、&lt;、&gt;、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引</p><p><img src="https://img-blog.csdn.net/20170512151841933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>6、index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常为ALL块，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取）</p><p><img src="https://img-blog.csdn.net/20170512152255874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>7、ALL：Full Table Scan，遍历全表以找到匹配的行</p><p><img src="https://img-blog.csdn.net/20170512152537516?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>查询涉及到的字段上存在索引，则该索引将被列出，但不一定被查询实际使用</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>实际使用的索引，如果为NULL，则没有使用索引。<br>查询中如果使用了覆盖索引，则该索引仅出现在key列表中</p><p><img src="https://img-blog.csdn.net/20170512155222855?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示索引中使用的字节数，查询中使用的索引的长度（最大可能长度），并非实际使用长度，理论上长度越短越好。key_len是根据表定义计算而得的，不是通过表内检索出的</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>显示索引的那一列被使用了，如果可能，是一个常量const。</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>不适合在其他字段中显示，但是十分重要的额外信息</p><p>1、Using filesort ：<br>mysql对数据使用一个外部的索引排序，而不是按照表内的索引进行排序读取。也就是说mysql无法利用索引完成的排序操作成为“文件排序”</p><p><img src="https://img-blog.csdn.net/20170515175218264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>由于索引是先按email排序、再按address排序，所以查询时如果直接按address排序，索引就不能满足要求了，mysql内部必须再实现一次“文件排序”</p><p>2、Using temporary：<br>使用临时表保存中间结果，也就是说mysql在对查询结果排序时使用了临时表，常见于order by 和 group by</p><p><img src="https://img-blog.csdn.net/20170515180947413?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3、Using index：<br>表示相应的select操作中使用了覆盖索引（Covering Index），避免了访问表的数据行，效率高</p><p><img src="https://img-blog.csdn.net/20170515182415063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">如果同时出现Using where，表明索引被用来执行索引键值的查找（参考上图）<br>如果没用同时出现Using where，表明索引用来读取数据而非执行查找动作</p><p>覆盖索引（Covering Index）：也叫索引覆盖。就是select列表中的字段，只用从索引中就能获取，不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。<br>注意：<br>a、如需使用覆盖索引，select列表中的字段只取出需要的列，不要使用select *<br>b、如果将所有字段都建索引会导致索引文件过大，反而降低crud性能</p><p>4、Using where ：<br>使用了where过滤</p><p>5、Using join buffer ：<br>使用了链接缓存</p><p>6、Impossible WHERE：<br>where子句的值总是false，不能用来获取任何元祖</p><p><img src="https://img-blog.csdn.net/20170515183331598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>7、select tables optimized away：<br>在没有group by子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT（*）操作，不必等到执行阶段在进行计算，查询执行计划生成的阶段即可完成优化</p><p>8、distinct：<br>优化distinct操作，在找到第一个匹配的元祖后即停止找同样值得动作</p><h2 id="综合Case"><a href="#综合Case" class="headerlink" title="综合Case"></a>综合Case</h2><p><img src="https://img-blog.csdn.net/20170516093515092?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>执行顺序<br>1（id = 4）、【select id, name from t2】：select_type 为union，说明id=4的select是union里面的第二个select。</p><p>2（id = 3）、【select id, name from t1 where address = ‘11’】：因为是在from语句中包含的子查询所以被标记为DERIVED（衍生），where address = ‘11’ 通过复合索引idx_name_email_address就能检索到，所以type为index。</p><p>3（id = 2）、【select id from t3】：因为是在select中包含的子查询所以被标记为SUBQUERY。</p><p>4（id = 1）、【select d1.name, … d2 from … d1】：select_type为PRIMARY表示该查询为最外层查询，table列被标记为 “derived3”表示查询结果来自于一个衍生表（id = 3 的select结果）。</p><p>5（id = NULL）、【 … union … 】：代表从union的临时表中读取行的阶段，table列的 “union 1, 4”表示用id=1 和 id=4 的select结果进行union操作。<br>————————————————<br>版权声明：本文为CSDN博主「走慢一点点」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wuseyukui/article/details/71512793" target="_blank" rel="noopener">https://blog.csdn.net/wuseyukui/article/details/71512793</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前缀树的场景以及实现</title>
      <link href="/2020/06/29/%E5%89%8D%E7%BC%80%E6%A0%91%E7%9A%84%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/06/29/%E5%89%8D%E7%BC%80%E6%A0%91%E7%9A%84%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>trie 树也称为字典树、单词查找树，最大的特点就是共享<strong>字符串的公共前缀</strong>来达到节省空间的目的了。例如，字符串 “abc”和”abd”构成的 trie 树如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lffcJ72RwSZzf9UxWSPuqWByjiaHHSIQFU2ZNCkAnAKoOib8TSWjW8ZwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><h3 id="trie-树来实现敏感词过滤"><a href="#trie-树来实现敏感词过滤" class="headerlink" title="trie 树来实现敏感词过滤"></a>trie 树来实现敏感词过滤</h3><p>三个敏感词：”de”, “bca”, “bcf” 建立一颗 trie 树</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027l7SvJibyl5wONF8oPM2Ua4xKlgEpPDFYZicicqibOskxvnribWILm3TuFZkA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>接着我们可以采用三个指针来遍历</p><p>1、首先指针 p1 指向 root，指针 p2 和 p3 指向字符串第一个字符</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lDl8BH9p53bggbEDaZmxU5fGjTurE6VamdybAWHMqNqsxnib3ZfRMcZw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>2、然后从字符串的 a 开始，检测有没有以 a 作为前缀的敏感词，直接判断 p1 的孩子节点中是否有 a 这个节点就可以了，显然这里没有。接着把指针 p2 和 p3 向右移动一格。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027l9s7FxaxdiaSreteIAa3ITSqu3691kXWMPC7FKZyWTAI7ibOXyj2WvOicw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>3、然后从字符串 b 开始查找，看看是否有以 b 作为前缀的字符串，p1 的孩子节点中有 b，这时，<strong>我们把 p1 指向节点 b，p2 向右移动一格，不过，p3不动。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lECEqictiaiaEK7g1AyBT44iaP6wTb7JcArqNu8mhOy1U4GqulcUJ8zaMVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>4、判断 p1 的孩子节点中是否存在 p2 指向的字符c，显然有。我们把 p1 指向节点 c，p2 向右移动一格，p3不动。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027liaPbDjQlcyJ3IDs1QMjoRvNBmkxl1BC5traDHIHwsGeBZkeX22KMBwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>5、判断 p1 的孩子节点中是否存在 p2 指向的字符d，这里没有。这意味着，<strong>不存在以字符b作为前缀的敏感词</strong>。这时我们把p2和p3都移向字符c，p1 还是还原到最开始指向 root。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027ldHazFSFXC1h1VGwTjlqkAJb40EL2NVNCDGbko01F3Lv9c5uxkXBXfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>6、和前面的步骤一样，判断有没以 c 作为前缀的字符串，显然这里没有，所以把 p2 和 p3 移到字符 d。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lNfHacf2TMLSg2BmvqYlb9klTg1TOhd2iacOjv9TB7OMm0eRhUFvEt9g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>7、然后从字符串 d 开始查找，看看是否有以 d 作为前缀的字符串，p1 的孩子节点中有 d，这时，<strong>我们把 p1 指向节点 b，p2 向右移动一格，不过，p3和刚才一样不动。</strong>（看到这里，我猜你已经懂了）</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027l2D8TFoo007qFT8ZiagibsLvFcIs8888shb0q4ApuhAibfSSytpQiayrq5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>8、判断 p1 的孩子节点中是否存在 p2 指向的字符e，显然有。我们把 p1 指向节点 e，<strong>并且，这里e是最后一个节点了，查找结束，所以存在敏感词de</strong>，即 p3 和 p2 这个区间指向的就是敏感词了，把 p2 和 p3 指向的区间那些字符替换成 *。并且把 p2 和 p3 移向字符 f。如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lqNuh2DLKx9LecEZaS1aRfYDbIWZficQGpoibrqMbe6br8UohHsoMTCcA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>9、接着还是重复同样的步骤，知道 p3 指向最后一个字符。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>面试官：可以说说时间复杂度吗？</p><p>小秋：如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。</p><p>如果让你来 构建 trie 树，你会用什么数据结构来实现？</p><p>小秋：我一般使用 Java，我会采用 HashMap 来实现，因为一个节点的字节点个数未知，采用 HashMap 可以动态拓展，而且可以在 O(1) 复杂度内判断某个子节点是否存在。</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>77406@LAPTOP-VEMP0J78 MINGW64 ~/Desktop</title>
      <link href="/2020/06/29/77406-LAPTOP-VEMP0J78-MINGW64-Desktop/"/>
      <url>/2020/06/29/77406-LAPTOP-VEMP0J78-MINGW64-Desktop/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ORM是什么</title>
      <link href="/2020/06/29/ORM%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2020/06/29/ORM%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ORM:(Object/Relation Mapping): 对象/关系映射<br>ORM的实现思想：<br>将关系数据库中表中的记录映射成为对象，以对象的形式展现，程序员可以把对数据库的操作转化为对对象的操作。</p><p><img src="https://images2018.cnblogs.com/blog/1351833/201805/1351833-20180501180203283-1149901647.png" alt="img"></p><h2 id="为什么是mybatis是半ORM"><a href="#为什么是mybatis是半ORM" class="headerlink" title="为什么是mybatis是半ORM"></a>为什么是mybatis是半ORM</h2><p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring两种代理</title>
      <link href="/2020/06/28/spring%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86/"/>
      <url>/2020/06/28/spring%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、原理区别："><a href="#一、原理区别：" class="headerlink" title="一、原理区别："></a>一、原理区别：</h2><p>我们了解到，“代理”的目的是构造一个和被代理的对象有同样行为的对象，一个对象的行为是在类中定义的，对象只是类的实例。所以构造代理，不一定非得通过持有、包装对象这一种方式。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>JDK动态代理</p><p>通过 <code>Proxy</code> 类的 <code>newInstance</code> 方法获取一个动态代理对象，需要传入三个参数，被代理对象的类加载器、被代理对象实现的接口，以及一个 <code>InvocationHandler</code> 调用处理器来指明具体的逻辑，相比静态代理的优势是接口中声明的所有方法都被转移到 <code>InvocationHandler</code> 的 <code>invoke</code> 方法集中处理。</p><p>CGLiB动态代理：</p><p>JDK 动态代理要求实现被代理对象的接口，而 CGLib 要求代理类去继承目标类，如果一个类是 final 类则不能使用 CGLib 代理。两种代理都在运行期生成字节码，JDK 动态代理直接写字节码，而 CGLib 动态代理使用 ASM 框架写字节码。 JDK 动态代理调用代理方法通过反射机制实现，而 GCLib 动态代理通过 FastClass 机制直接调用方法，它为代理类和被代理类各生成一个类</p><h2 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h2><p>jdk只能针对接口不能针对类实现代理。</p><p>CGLib通过继承方式实现代理。所以类或方法最好不要声明成final，对于final类或方法，是无法继承的。</p><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><p>用户管理接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.lf.shejimoshi.proxy.entity;</span><br><span class="line">&#x2F;&#x2F;用户管理接口</span><br><span class="line">public interface UserManager &#123;</span><br><span class="line">    &#x2F;&#x2F;新增用户抽象方法</span><br><span class="line">    void addUser(String userName,String password);</span><br><span class="line">    &#x2F;&#x2F;删除用户抽象方法</span><br><span class="line">    void delUser(String userName);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户管理接口实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.lf.shejimoshi.proxy.entity;</span><br><span class="line">&#x2F;&#x2F;用户管理实现类,实现用户管理接口</span><br><span class="line">public class UserManagerImpl implements UserManager&#123;</span><br><span class="line">    &#x2F;&#x2F;重写新增用户方法</span><br><span class="line">    @Override</span><br><span class="line">    public void addUser(String userName, String password) &#123;</span><br><span class="line">        System.out.println(&quot;调用了新增的方法！&quot;);</span><br><span class="line">        System.out.println(&quot;传入参数为 userName: &quot;+userName+&quot; password: &quot;+password);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;重写删除用户方法</span><br><span class="line">    @Override</span><br><span class="line">    public void delUser(String userName) &#123;</span><br><span class="line">        System.out.println(&quot;调用了删除的方法！&quot;);</span><br><span class="line">        System.out.println(&quot;传入参数为 userName: &quot;+userName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK动态代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.lf.shejimoshi.proxy.jdk;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">import com.lf.shejimoshi.proxy.entity.UserManager;</span><br><span class="line">import com.lf.shejimoshi.proxy.entity.UserManagerImpl;</span><br><span class="line">&#x2F;&#x2F;JDK动态代理实现InvocationHandler接口</span><br><span class="line">public class JdkProxy implements InvocationHandler &#123;</span><br><span class="line">    private Object target ;&#x2F;&#x2F;需要代理的目标对象</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;JDK动态代理，监听开始！&quot;);</span><br><span class="line">        Object result &#x3D; method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;JDK动态代理，监听结束！&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;定义获取代理对象方法</span><br><span class="line">    private Object getJDKProxy(Object targetObject)&#123;</span><br><span class="line">        &#x2F;&#x2F;为目标对象target赋值</span><br><span class="line">        this.target &#x3D; targetObject;</span><br><span class="line">        &#x2F;&#x2F;JDK动态代理只能针对实现了接口的类进行代理，newProxyInstance 函数所需参数就可看出</span><br><span class="line">        return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JdkProxy jdkProxy &#x3D; new JdkProxy();&#x2F;&#x2F;实例化JDKProxy对象</span><br><span class="line">        UserManager user &#x3D; (UserManager) jdkProxy.getJDKProxy(new UserManagerImpl());&#x2F;&#x2F;获取代理对象</span><br><span class="line">        user.addUser(&quot;admin&quot;, &quot;123123&quot;);&#x2F;&#x2F;执行新增方法</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK动态代理运行结果</p><p>Cglib动态代理（需要导入两个jar包，asm-5.2.jar,cglib-3.2.5.jar。版本自行选择）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;cglib&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另一个版本的代码 https:&#x2F;&#x2F;www.cnblogs.com&#x2F;wyq1995&#x2F;p&#x2F;10945034.html</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.lf.shejimoshi.proxy.cglib;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">import com.lf.shejimoshi.proxy.entity.UserManager;</span><br><span class="line">import com.lf.shejimoshi.proxy.entity.UserManagerImpl;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Cglib动态代理，实现MethodInterceptor接口</span><br><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    private Object target;&#x2F;&#x2F;需要代理的目标对象</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;重写拦截方法</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] arr, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;Cglib动态代理，监听开始！&quot;);</span><br><span class="line">        Object invoke &#x3D; method.invoke(target, arr);&#x2F;&#x2F;方法执行，参数：target 目标对象 arr参数数组</span><br><span class="line">        System.out.println(&quot;Cglib动态代理，监听结束！&quot;);</span><br><span class="line">        return invoke;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;定义获取代理对象方法</span><br><span class="line">    public Object getCglibProxy(Object objectTarget)&#123;</span><br><span class="line">        &#x2F;&#x2F;为目标对象target赋值</span><br><span class="line">        this.target &#x3D; objectTarget;</span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">        &#x2F;&#x2F;设置父类,因为Cglib是针对指定的类生成一个子类，所以需要指定父类</span><br><span class="line">        enhancer.setSuperclass(objectTarget.getClass());</span><br><span class="line">        enhancer.setCallback(this);&#x2F;&#x2F; 设置回调 </span><br><span class="line">        Object result &#x3D; enhancer.create();&#x2F;&#x2F;创建并返回代理对象</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CglibProxy cglib &#x3D; new CglibProxy();&#x2F;&#x2F;实例化CglibProxy对象</span><br><span class="line">        UserManager user &#x3D;  (UserManager) cglib.getCglibProxy(new UserManagerImpl());&#x2F;&#x2F;获取代理对象</span><br><span class="line">        user.delUser(&quot;admin&quot;);&#x2F;&#x2F;执行删除方法</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cglib动态代理运行结果</p><p><img src="https://images2017.cnblogs.com/blog/985411/201801/985411-20180111010415222-40358282.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mybatis相关疑惑</title>
      <link href="/2020/06/28/mybatis%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91/"/>
      <url>/2020/06/28/mybatis%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="mybatis中-和-的区别"><a href="#mybatis中-和-的区别" class="headerlink" title="mybatis中#和$的区别"></a>mybatis中#和$的区别</h2><p><strong>#{parameterName}</strong></p><p><strong>${parameterName}</strong></p><p>首先，我们说一下这两种引用参数时的区别，<strong>使用#</strong>{parameterName}引用参数的时候，Mybatis会<strong>把这个参数认为是一个字符串，并自动加上’’</strong>，例如传入参数是“Smith”，那么在下面SQL中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from emp where name = #&#123;employeeName&#125;</span><br></pre></td></tr></table></figure><p>使用的时候就会转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * <span class="keyword">from</span> emp where name = <span class="string">'Smith'</span>;</span><br></pre></td></tr></table></figure><p>同时<strong>使用${parameterName}的</strong>时候在下面SQL中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * <span class="keyword">from</span> emp where name = $&#123;employeeName&#125;</span><br></pre></td></tr></table></figure><p>就会直接转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * <span class="keyword">from</span> emp where name = Smith</span><br></pre></td></tr></table></figure><p>简单说<strong>#{}是经过预编译的,是安全的</strong>。</p><p>而<strong>${}</strong>是未经过预编译的,<strong>仅仅是取变量的值,是非安全的,存在SQL注入</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&#123;&#125; 这种取值是编译好SQL语句再取值</span><br><span class="line">$&#123;&#125; 这种是取值以后再去编译SQL语句</span><br></pre></td></tr></table></figure><p>下面我们用一个实际的例子看看分别使用和是否可以防止SQL注入。</p><p><strong>首先是使用#{}：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用#&#123;&#125; --&gt;</span><br><span class="line">  &lt;select id=<span class="string">"selectUser"</span> parameterType=<span class="string">"String"</span> </span><br><span class="line">    resultType=<span class="string">"com.mybatis.po.MyUser"</span>&gt;</span><br><span class="line">    select * from user where account = #&#123;account&#125; and password = #&#123;password&#125;</span><br><span class="line">  &lt;<span class="regexp">/select&gt;</span></span><br></pre></td></tr></table></figure><p>分别测试正常传参和拼接传参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用#&#123;&#125; 正常传参</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; parameter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parameter.put(<span class="string">"account"</span>, );</span><br><span class="line">    parameter.put(<span class="string">"password"</span>, password);</span><br><span class="line">    MyUser mu = ss.selectOne(<span class="string">"com.mybatis.mapper.UserMapper.selectUser"</span>, parameter);</span><br><span class="line">    System.out.println(<span class="string">"返回结果："</span> + mu);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用#&#123;&#125; 拼接传参</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; parameter_1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parameter_1.put(<span class="string">"account"</span>, <span class="string">"201301001"</span>);</span><br><span class="line">    parameter_1.put(<span class="string">"password"</span>, <span class="string">"111111"</span> + <span class="string">"or account = 'admin' "</span>);</span><br><span class="line">    MyUser mu_1 = ss.selectOne(<span class="string">"com.mybatis.mapper.UserMapper.selectUser"</span>, parameter_1);</span><br><span class="line">    System.out.println(<span class="string">"返回结果："</span> + mu_1);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2020/06/28/mybatis%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200628154136546.png" alt="image-20200628154136546"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = ? and password = ? </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt; Parameters: <span class="number">201301001</span>(<span class="built_in">String</span>), <span class="number">111111</span>(<span class="built_in">String</span>)</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - &lt;==      Total: <span class="number">1</span></span><br><span class="line">返回结果：MyUser [id=<span class="number">17</span>, account=<span class="number">201301001</span>, password=<span class="number">111111</span>, name=蒙奇D路飞]</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = ? and password = ? </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt; Parameters: <span class="number">201301001</span>(<span class="built_in">String</span>), <span class="number">111111</span> or account = <span class="string">'admin'</span> (<span class="built_in">String</span>)</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - &lt;==      Total: <span class="number">0</span></span><br><span class="line">返回结果：<span class="literal">null</span></span><br></pre></td></tr></table></figure><p>很明显，使用<strong>#{}</strong>的时候，即使传入了恶意参数，<strong>#{}</strong>只会将其作为一个占位符的参数，如上面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = ? and password = ? </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt; Parameters: <span class="number">201301001</span>(<span class="built_in">String</span>), <span class="number">111111</span> or account = <span class="string">'admin'</span> (<span class="built_in">String</span>)</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - &lt;==      Total: <span class="number">0</span></span><br><span class="line">转换为实际的SQL语句：select * <span class="keyword">from</span> user where account = <span class="string">'201301001'</span> and password = <span class="string">'111111 or account = '</span>admin<span class="string">''</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where account = <span class="string">'201301001'</span> and password = <span class="string">'111111 or account = '</span>admin<span class="string">''</span> </span><br><span class="line">select * from user where account = <span class="number">201301001</span> and password = <span class="number">111111</span> or account = <span class="string">'admin'</span></span><br></pre></td></tr></table></figure><p>现在是使用<strong>${}</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用$&#123;&#125; --&gt;</span><br><span class="line">  &lt;select id=<span class="string">"selectUser2"</span> parameterType=<span class="string">"String"</span> </span><br><span class="line">    resultType=<span class="string">"com.mybatis.po.MyUser"</span>&gt;</span><br><span class="line">    select * <span class="keyword">from</span> user where account = $&#123;account&#125; and password = $&#123;password&#125;</span><br><span class="line">  &lt;<span class="regexp">/select&gt;</span></span><br></pre></td></tr></table></figure><p>分别测试正常传参和拼接传参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用$&#123;&#125; 正常传参</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; parameter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parameter.put(<span class="string">"account"</span>, <span class="string">"201301001"</span>);</span><br><span class="line">    parameter.put(<span class="string">"password"</span>, <span class="string">"111111"</span>);</span><br><span class="line">    MyUser mu = ss.selectOne(<span class="string">"com.mybatis.mapper.UserMapper.selectUser2"</span>,parameter);</span><br><span class="line">    System.out.println(<span class="string">"返回结果："</span> + mu);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用$&#123;&#125; 拼接传参</span></span><br><span class="line">   <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; parameter2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   parameter2.put(<span class="string">"account"</span>, <span class="string">"201301001"</span>);</span><br><span class="line">   parameter2.put(<span class="string">"password"</span>, <span class="string">"111111"</span> + <span class="string">" or account = 'admin' "</span>);</span><br><span class="line">   MyUser mu2 = ss.selectOne(<span class="string">"com.mybatis.mapper.UserMapper.selectUser2"</span>, parameter2);</span><br><span class="line">   System.out.println(<span class="string">"返回结果："</span> + mu2);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2020/06/28/mybatis%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200628154158333.png" alt="image-20200628154158333"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = <span class="number">201301001</span> and password = <span class="number">111111</span> </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - ==&gt; Parameters: </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - &lt;==      Total: <span class="number">1</span></span><br><span class="line">返回结果：MyUser [id=<span class="number">17</span>, account=<span class="number">201301001</span>, password=<span class="number">111111</span>, name=蒙奇D路飞]</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = <span class="number">201301001</span> and password = <span class="number">111111</span> or account = <span class="string">'admin'</span> </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - ==&gt; Parameters: </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - &lt;==      Total: <span class="number">2</span></span><br><span class="line">返回结果：[MyUser [id=<span class="number">1</span>, account=admin, password=<span class="number">111111</span>, name=管理员], MyUser [id=<span class="number">17</span>, account=<span class="number">201301001</span>, password=<span class="number">111111</span>, name=蒙奇D路飞]]</span><br></pre></td></tr></table></figure><p>很明显，使用<strong>${}</strong>将参数拼接后在编译成SQL语句，不能防止SQL注入，查询出了有关account=admin的额外信息，这是很危险的。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>count(*)、count(1)、count(某字段)的区别</title>
      <link href="/2020/06/28/count-%E3%80%81count-1-%E3%80%81count-%E6%9F%90%E5%AD%97%E6%AE%B5-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/06/28/count-%E3%80%81count-1-%E3%80%81count-%E6%9F%90%E5%AD%97%E6%AE%B5-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><strong>count(*)：所有行进行统计，包括NULL行.COUNT(*)不单会进行全表扫描，也会对表的每个字段进行扫描。<br>count(1)：所有行进行统计，包括NULL行.其实就可以想成表中有这么一个字段,这个字段就是固定值1,count(1),就是计算一共有多少个1<br>count(column)：对column中非Null进行统计</strong></p><p>执行效率：<br>列名为主键，count(列名)会比count(1)快  </p><p>列名不为主键，count(1)会比count(列名)快  </p><p>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）  </p><p>如果有主键，则 select count（主键）的执行效率是最优的  </p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池底层&amp;四种类型&amp;参数含义</title>
      <link href="/2020/06/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B-%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/"/>
      <url>/2020/06/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B-%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>线程池底层都是通过 ThreadPoolExecutor 来实现的</p><h2 id="线程池的执行过程"><a href="#线程池的执行过程" class="headerlink" title="线程池的执行过程"></a>线程池的执行过程</h2><p>这里用一个图来说明线程池的执行流程</p><p><img src="https://upload-images.jianshu.io/upload_images/11183270-a01aea078d7f4178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>任务被提交到线程池，会先判断当前线程数量是否小于corePoolSize，如果小于则创建线程来执行提交的任务，否则将任务放入workQueue队列，如果workQueue满了，则判断当前线程数量是否小于maximumPoolSize,如果小于则创建线程执行任务，否则就会调用handler，以表示线程池拒绝接收任务。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>参数介绍</p><table><thead><tr><th align="left">参数</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td align="left">corePoolSize</td><td>int</td><td>核心线程数</td></tr><tr><td align="left">maximumPoolSize</td><td>int</td><td>最大线程数</td></tr><tr><td align="left">keepAliveTime</td><td>long</td><td>存活时间</td></tr><tr><td align="left">unit</td><td>TimeUnit</td><td>时间单位</td></tr><tr><td align="left">workQueue</td><td>BlockingQueue</td><td>存放线程的队列</td></tr><tr><td align="left">threadFactory</td><td>ThreadFactory</td><td>创建线程的工厂</td></tr><tr><td align="left">handler</td><td>RejectedExecutionHandler</td><td>多余的的线程处理器（拒绝策略）</td></tr></tbody></table><h3 id="核心线程数corePoolSize"><a href="#核心线程数corePoolSize" class="headerlink" title="核心线程数corePoolSize"></a>核心线程数corePoolSize</h3><p>这个参数表示线程池中的基本线程数量也就是核心线程数量。</p><h3 id="最大线程数maximumPoolSize-ˈmaeksɪməm"><a href="#最大线程数maximumPoolSize-ˈmaeksɪməm" class="headerlink" title="最大线程数maximumPoolSize[ˈmæksɪməm]"></a>最大线程数maximumPoolSize[ˈmæksɪməm]</h3><p>这个参数是线程池中允许创建的最大线程数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当使用有界队列时，且队列存放的任务满了，那么线程池会创建新的线程（最大不会超过这个参数所设置的值）。需要注意的是，**当使用无界队列时，这个参数是无效的。</span><br></pre></td></tr></table></figure><h3 id="线程存活时间keepAliveTime"><a href="#线程存活时间keepAliveTime" class="headerlink" title="线程存活时间keepAliveTime"></a>线程存活时间keepAliveTime</h3><p>这个就是非核心线程空闲时可以存活的时间，一旦超过这个时间，线程就会被销毁。</p><h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3><p>keepAliveTime的单位。</p><h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><p>当前线程数超过corePoolSize时，新的任务会处在等待状态，并存在workQueue中，BlockingQueue是一个先进先出的阻塞式队列实现，底层实现会涉及Java并发的AQS机制，有关于AQS的相关知识，我会单独写一篇，敬请期待。</p><h3 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h3><p>创建线程的工厂类，通常我们会自顶一个threadFactory设置线程的名称，这样我们就可以知道线程是由哪个工厂类创建的，可以快速定位。</p><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>线程池执行拒绝策略，当线数量达到maximumPoolSize大小，并且workQueue也已经塞满了任务的情况下，线程池会调用handler拒绝策略来处理请求。</p><p>系统默认的拒绝策略有以下几种：</p><ol><li>AbortPolicy：为线程池默认的拒绝策略，该策略直接抛异常处理。</li><li>DiscardPolicy：直接抛弃不处理。</li><li>DiscardOldestPolicy：丢弃队列中最老的任务。</li><li>CallerRunsPolicy：将任务分配给当前执行execute方法线程来处理。</li></ol><p>我们还可以自定义拒绝策略，只需要实现RejectedExecutionHandler接口即可，友好的拒绝策略实现有如下：</p><ol><li>将数据保存到数据，待系统空闲时再进行处理</li><li>将数据用日志进行记录，后由人工处理</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现有一个线程池，参数corePoolSize = 5，maximumPoolSize = 10，BlockingQueue阻塞队列长度为5，此时有4个任务同时进来，问：线程池会创建几条线程？</p><p>如果4个任务还没处理完，这时又同时进来2个任务，问：线程池又会创建几条线程还是不会创建？</p><p>如果前面6个任务还是没有处理完，这时又同时进来5个任务，问：线程池又会创建几条线程还是不会创建？</p><p><strong>线程池corePoolSize=5，线程初始化时不会自动创建线程，所以当有4个任务同时进来时，执行execute方法会新建【4】条线程来执行任务；</strong></p><p><strong>前面的4个任务都没完成，现在又进来2个队列，会新建【1】条线程来执行任务，这时poolSize=corePoolSize，还剩下1个任务，线程池会将剩下这个任务塞进阻塞队列中，等待空闲线程执行；</strong></p><p><strong>如果前面6个任务还是没有处理完，这时又同时进来了5个任务，此时还没有空闲线程来执行新来的任务，所以线程池继续将这5个任务塞进阻塞队列，但发现阻塞队列已经满了，核心线程也用完了，还剩下1个任务不知道如何是好，于是线程池只能创建【1】条“临时”线程来执行这个任务了；</strong></p><p><strong>这里创建的线程用“临时”来描述还是因为它们不会长期存在于线程池，它们的存活时间为keepAliveTime，此后线程池会维持最少corePoolSize数量的线程。</strong></p><h2 id="IO密集型和CPU密集型"><a href="#IO密集型和CPU密集型" class="headerlink" title="IO密集型和CPU密集型"></a>IO密集型和CPU密集型</h2><p>CPU密集型任务应配置尽可能小的线程，如配置CPU数目+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*CPU数目。</p><h3 id="线程池大小的设置"><a href="#线程池大小的设置" class="headerlink" title="线程池大小的设置"></a>线程池大小的设置</h3><h4 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h4><p>一个服务器有八个cpu，处理请求5ms，io操作200ms，理想情况下应该开什么线程？1s会处理多少请求？</p><p>8* U_cpu *(1+200/5)</p><ul><li><p>计算密集型任务：</p><p>N = N_cpu + 1</p><ul><li>加 1 的原因：当有一个线程偶尔故障时，额外的那个线程可以立即补上，保证CPU时钟不会被浪费</li></ul></li><li><p>包含 I/O 或其他阻塞操作：</p><p>N = N_cpu * U_cpu * (1 + W / C)</p><ul><li><p>N_cpu：CPU 的个数</p></li><li><p>U_cpu：目标 CPU 利用率</p></li><li><p>W / C：等待时间 (Wait) / 计算时间 (Compute)</p></li><li><p>获取 CPU 数目的方法：<code>int N_CPUS = Runtime.getRuntime().availableProcessors();</code></p></li></ul></li></ul><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><blockquote><p>假设要求一个系统的 TPS（Transaction Per Second 或者 Task Per Second）至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s</p></blockquote><p>如何设计线程个数，使得可以在1s内处理完20个Transaction？</p><p>20/(1/4)=80</p><h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><blockquote><p>计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？</p></blockquote><p>线程数 = 8 * (1 + 100/5) = 168 (个)</p><blockquote><p> 那如果DB的 QPS（Query Per Second）上限是1000，此时这个线程数又该设置为多大呢？</p></blockquote><p>一个线程每秒处理的任务数 1000/105,168个线程168*（1000/105）=1600QPS </p><p>168*(1000/1600)=105</p><h4 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h4><p>任务处理时间 100ms，服务器 4 核 8G 如何设计线程池达到 1000qps？任务是 90ms 在 IO，10ms 在计算的情况下怎么弄？全在计算呢？</p><p>一个线程一秒处理10个任务 10QPS  1000/10=100个线程   4*(1+90/10)=40个线程 </p><p>8 *(90/10+1）</p><h2 id="四种类型"><a href="#四种类型" class="headerlink" title="四种类型"></a>四种类型</h2><h3 id="1-FixedThreadPool"><a href="#1-FixedThreadPool" class="headerlink" title="1.FixedThreadPool"></a>1.FixedThreadPool</h3><p>所有任务只能使用固定大小的线程，超出的线程会在队列中等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>FixedThreadPool</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>都设置为参数nThreads，<code>keepAliveTime</code>为0L，表示多余的线程立刻终止，因为不会产生多余的线程它的任务队列采用的是LinkedBlockingQueue。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/3/1615a7fcb4af71c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>创建线程池的方法，在我们的程序中只需要，后面其他种类的同理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 参数是要线程池的线程最大值</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-CachedThreadPool"><a href="#2-CachedThreadPool" class="headerlink" title="2.CachedThreadPool"></a>2.CachedThreadPool</h3><p>一个任务创建一个线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code>的<code>corePoolSize</code>是0，<code>maximumPoolSize</code>是Integer.MAX_VALUE，也就是说<code>CachedThreadPool</code>没有核心线程，全部都是非核心线程，并且没有上限。<code>keepAliveTime</code>是60秒，就是说空闲线程等待新任务60秒，超时则销毁。此处用到的队列是阻塞队列<code>SynchronousQueue</code>[ˈsɪŋkrənəs],这个队列没有缓冲区，所以其中最多只能存在一个元素,有新的任务则阻塞等待。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616e2b8b89d971c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="3-SingleThreadExecutor"><a href="#3-SingleThreadExecutor" class="headerlink" title="3.SingleThreadExecutor"></a>3.SingleThreadExecutor</h3><p>相当于大小为 1 的 FixedThreadPool。其创建源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到总线程数和核心线程数都是1，所以就只有一个核心线程。该线程池才用链表阻塞队列<code>LinkedBlockingQueue</code>，先进先出原则，所以保证了任务的按顺序逐一进行。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616e43b53271671?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="4-ScheduledThreadPool"><a href="#4-ScheduledThreadPool" class="headerlink" title="4.ScheduledThreadPool"></a>4.ScheduledThreadPool</h3><p><code>ScheduledThreadPool</code>是一个能实现定时和周期性任务的线程池，它的创建源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里创建了<code>ScheduledThreadPoolExecutor</code>，继承自<code>ThreadPoolExecutor</code>，主要用于定时延时或者定期处理任务。<code>ScheduledThreadPoolExecutor</code>的构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">        super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">              new DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看出<code>corePoolSize</code>是传进来的固定值，<code>maximumPoolSize</code>无限大，因为采用的队列<code>DelayedWorkQueue</code>是无解的，所以<code>maximumPoolSize</code>参数无效。该线程池执行如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616e5ded43058a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>当执行<code>scheduleAtFixedRate</code>或者<code>scheduleWithFixedDelay</code>方法时，会向<code>DelayedWorkQueue</code>添加一个实现<code>RunnableScheduledFuture</code>接口的<code>ScheduledFutureTask</code>(任务的包装类)，并会检查运行的线程是否达到<code>corePoolSize</code>。如果没有则新建线程并启动<code>ScheduledFutureTask</code>，然后去执行任务。如果运行的线程达到了<code>corePoolSize</code>时，则将任务添加到<code>DelayedWorkQueue</code>中。<code>DelayedWorkQueue</code>会将任务进行排序，先要执行的任务会放在队列的前面。在跟此前介绍的线程池不同的是，当执行完任务后，会将<code>ScheduledFutureTask</code>中的<code>time</code>变量改为下次要执行的时间并放回到<code>DelayedWorkQueue</code>中。</p><h3 id="5-代码"><a href="#5-代码" class="headerlink" title="5.代码"></a>5.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化10个信号量在信号包中，让ABCD4个线程分别去获取</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F; ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(5);</span><br><span class="line">       &#x2F;&#x2F; ExecutorService threadPool &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">       &#x2F;&#x2F; ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 6; i++) &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;current thread name: &quot; + Thread.currentThread().getName());</span><br><span class="line">                Object object &#x3D; null;</span><br><span class="line">               &#x2F;&#x2F; System.out.print(&quot;result## &quot;+object.toString());</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化10个信号量在信号包中，让ABCD4个线程分别去获取</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService &#x3D; Executors.newScheduledThreadPool(1);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;current Time&quot; + System.currentTimeMillis());</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);</span><br><span class="line">        &#125;, 1, 3, TimeUnit.SECONDS);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-对比"><a href="#6-对比" class="headerlink" title="6.对比"></a>6.对比</h3><p>FixedThreadPool 适用于处理CPU密集型的任务，尽可能的少的分配线程，即适用执行长期的任务。</p><p>CachedThreadPool用于并发执行大量短期的小任务。</p><p>SingleThreadExecutor适用于串行执行任务的场景，一个任务一个任务地执行。</p><p>newScheduledThreadPool 周期性执行任务的场景，需要限制线程数量的场景</p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><h3 id="Abort-策略"><a href="#Abort-策略" class="headerlink" title="Abort 策略"></a>Abort 策略</h3><p>默认策略，新任务提交时直接抛出异常RejectedExecutionException，该异常可由调用者捕获。</p><h3 id="CallerRuns-策略"><a href="#CallerRuns-策略" class="headerlink" title="CallerRuns 策略:"></a>CallerRuns 策略:</h3><p>不会在线程池的线程中执行新的任务，而是在调用exector的线程中运行新的任务。</p><h3 id="Discard策略"><a href="#Discard策略" class="headerlink" title="Discard策略:"></a>Discard策略:</h3><p>直接丢弃新提交的任务；</p><h3 id="DiscardOlds策略"><a href="#DiscardOlds策略" class="headerlink" title="DiscardOlds策略:"></a>DiscardOlds策略:</h3><p>如果执行器没有关闭，队列头的任务将会被丢弃，然后执行器重新尝试执行任务（如果失败，则重复这一过程）；</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package concurrency.pool;</span><br><span class="line"> </span><br><span class="line">import java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line">import java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by li on 2016&#x2F;7&#x2F;2.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SaturationPolicy &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 线程池工作队列已满时，在不同饱和策略下表现</span><br><span class="line">     * @param handler 线程池工作队列饱和策略</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void policy(RejectedExecutionHandler handler)&#123;</span><br><span class="line">        &#x2F;&#x2F;基本线程2个，最大线程数为3，工作队列容量为5</span><br><span class="line">        ThreadPoolExecutor exec &#x3D; new ThreadPoolExecutor(2,3,0l, TimeUnit.MILLISECONDS,new LinkedBlockingDeque&lt;&gt;(5));</span><br><span class="line">        if (handler !&#x3D; null)&#123;</span><br><span class="line">            exec.setRejectedExecutionHandler(handler);&#x2F;&#x2F;设置饱和策略</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            exec.submit(new Task());&#x2F;&#x2F;提交任务</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        policy(new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">&#x2F;&#x2F;        policy((new ThreadPoolExecutor.CallerRunsPolicy()));</span><br><span class="line">&#x2F;&#x2F;        policy(new ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">&#x2F;&#x2F;        policy(new ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;自定义任务</span><br><span class="line">    static class Task implements Runnable &#123;</span><br><span class="line">        private static int count &#x3D; 0;</span><br><span class="line">        private int id &#x3D; 0;&#x2F;&#x2F;任务标识</span><br><span class="line">        public Task() &#123;</span><br><span class="line">            id &#x3D; ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public  void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);&#x2F;&#x2F;休眠3秒</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(&quot;线程被中断&quot; + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot; 任务：&quot; + id + &quot;\t 工作线程: &quot;+ Thread.currentThread().getName() + &quot; 执行完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有哪些工作队列"><a href="#有哪些工作队列" class="headerlink" title="有哪些工作队列"></a>有哪些工作队列</h2><h3 id="SynchronousQueue："><a href="#SynchronousQueue：" class="headerlink" title="SynchronousQueue："></a>SynchronousQueue：</h3><p>是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;2个核心线程最大线程为3的线程池</span><br><span class="line">        Executor executors &#x3D; new ThreadPoolExecutor(</span><br><span class="line">                2, 3, 30, TimeUnit.SECONDS,</span><br><span class="line">                new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                new RejectHandler());</span><br><span class="line">        execute(executors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void execute(Executor executors) &#123;</span><br><span class="line">        executors.execute(new NameRunnable(1));</span><br><span class="line">        executors.execute(new NameRunnable(2));</span><br><span class="line">        executors.execute(new NameRunnable(3));</span><br><span class="line">        executors.execute(new NameRunnable(4));</span><br><span class="line">        executors.execute(new NameRunnable(5));</span><br><span class="line">        executors.execute(new NameRunnable(6));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class NameRunnable implements Runnable &#123;</span><br><span class="line">        private int name;</span><br><span class="line"></span><br><span class="line">        public NameRunnable(int name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(name + &quot; is running... &quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + &quot; is end !!! &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;***</span><br><span class="line">     * 拒绝的Runnable</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static class RejectHandler implements RejectedExecutionHandler &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;</span><br><span class="line">            NameRunnable name &#x3D; (NameRunnable) r;</span><br><span class="line"></span><br><span class="line">            System.out.print(name.getName() + &quot; is rejected ^^\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200127233842102.png" alt="在这里插入图片描述"></p><h3 id="ArrayBlockingQueue："><a href="#ArrayBlockingQueue：" class="headerlink" title="ArrayBlockingQueue："></a>ArrayBlockingQueue：</h3><p>ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;2个核心线程最大线程为3的线程池,阻塞队列大小为2</span><br><span class="line">Executor executors &#x3D; new ThreadPoolExecutor(</span><br><span class="line">               2, 3, 30, TimeUnit.SECONDS,</span><br><span class="line">               new ArrayBlockingQueue&lt;&gt;(2),</span><br><span class="line">               new RejectHandler());</span><br><span class="line">       execute(executors);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200127234739185.png" alt="在这里插入图片描述"></p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;2个核心线程最大线程为3的线程池,阻塞队列大小为2</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Executor executors &#x3D; new ThreadPoolExecutor(</span><br><span class="line">                2, 6, 30, TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingQueue&lt;&gt;(2),</span><br><span class="line">                new RejectHandler());</span><br><span class="line">        execute(executors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void execute(Executor executors) &#123;</span><br><span class="line">        executors.execute(new NameRunnable(1));</span><br><span class="line">        executors.execute(new NameRunnable(2));</span><br><span class="line">        executors.execute(new NameRunnable(3));</span><br><span class="line">        executors.execute(new NameRunnable(4));</span><br><span class="line">        executors.execute(new NameRunnable(5));</span><br><span class="line">        executors.execute(new NameRunnable(6));</span><br><span class="line">        executors.execute(new NameRunnable(7));</span><br><span class="line">        executors.execute(new NameRunnable(8));</span><br><span class="line">        executors.execute(new NameRunnable(9));</span><br><span class="line">        executors.execute(new NameRunnable(10));</span><br><span class="line">        executors.execute(new NameRunnable(11));</span><br><span class="line">        executors.execute(new NameRunnable(12));</span><br><span class="line">        executors.execute(new NameRunnable(13));</span><br><span class="line">        executors.execute(new NameRunnable(14));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200128001009488.png" alt="在这里插入图片描述"></p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。</p><h2 id="如何优雅关闭线程池"><a href="#如何优雅关闭线程池" class="headerlink" title="如何优雅关闭线程池"></a>如何优雅关闭线程池</h2><h4 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a>Runnable vs Callable</h4><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是<strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 *<em><code>Runnable</code> 接口*</em>，这样代码看起来会更加简洁。</p><p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。（<code>Executors.callable（Runnable task</code>）或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Runnable.java</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 被线程执行，没有返回值也无法抛出异常</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line">Callable.java</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 计算结果，或在无法这样做时抛出异常。</span><br><span class="line">     * @return 计算得出的结果</span><br><span class="line">     * @throws 如果无法计算结果，则抛出异常</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a>execute() vs submit()</h4><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><p>我们以<strong><code>AbstractExecutorService</code></strong>接口中的一个 <code>submit</code> 方法为例子来看看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>我们再来看看<code>execute()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="shutdown-VS-shutdownNow"><a href="#shutdown-VS-shutdownNow" class="headerlink" title="shutdown()VS shutdownNow()"></a>shutdown()VS shutdownNow()</h4><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h4 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a>isTerminated() VS isShutdown()</h4><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap解析</title>
      <link href="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁<br>（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发<br>度更高（并发度就是 Segment 的个数）。Segment 继承自 ReentrantLock。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">   final int hash;</span><br><span class="line">   final K key;</span><br><span class="line">   volatile V value;</span><br><span class="line">   volatile HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁<br>（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发<br>度更高（并发度就是 Segment 的个数）。<br><strong>Segment 继承自 ReentrantLock。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line">   private static final long serialVersionUID &#x3D; 2249069246763182397L;</span><br><span class="line">   static final int MAX_SCAN_RETRIES &#x3D;</span><br><span class="line">   Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;</span><br><span class="line">   transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">   transient int count;</span><br><span class="line">   transient int modCount;</span><br><span class="line">   transient int threshold;</span><br><span class="line">   final float loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br></pre></td></tr></table></figure><img src="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/1.png" class title="如图"><p>HashEntry跟HashMap差不多的，但是不同点是，他使用volatile去修饰了他的数据Value还有下一个节点next。</p><h2 id="并发度高的原因"><a href="#并发度高的原因" class="headerlink" title="并发度高的原因"></a>并发度高的原因</h2><p>原理上来说，ConcurrentHashMap 采用了<strong>分段锁</strong>技术，其中 Segment 继承于 ReentrantLock。</p><p>不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>concurrentHashMap的put 方法首先定位到 某个Segment，调用segment的put方法在对应的segment做插入操作。segment put实现过程：</p><ol><li>获取锁，保证put操作的线程安全；</li><li>定位到HashEntry数组中具体的HashEntry；</li></ol><p>然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，在扩容的时候，首先创建一个容量是原来容量两倍的数组，将原数组的元素再散列后插入到新的数组里。为了高效，ConcurrentHashMap只对某个Segment进行扩容，不会对整个容器扩容。第二步定位添加元素的位置，然后将其放入数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ConcurrentHashMap#put</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">　　Segment&lt;K,V&gt; s;</span><br><span class="line">　　if (value &#x3D;&#x3D; null)</span><br><span class="line">　　　　throw new NullPointerException();</span><br><span class="line">　　int hash &#x3D; hash(key);&#x2F;&#x2F;根据散列函数，计算出key值的散列值</span><br><span class="line">　　int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;&#x2F;&#x2F;这个操作就是定位Segment的数组下标，jdk1.7之前是segmentFor返回Segment，1.7之后直接就取消了这个方法，直接计算数组下标，然后通过偏移量底层操作获取Segment</span><br><span class="line">　　if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck</span><br><span class="line">　　　　　　(segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment</span><br><span class="line">　　　　s &#x3D; ensureSegment(j);&#x2F;&#x2F;通过便宜量定位不到就调用ensureSegment方法定位Segment</span><br><span class="line">　　return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过key定位到Segment，之后在对应的Segment中进行具体的put</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">        int index &#x3D; (tab.length - 1) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class="line">            if (e !&#x3D; null) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue &#x3D; e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value &#x3D; value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                e &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (node !&#x3D; null)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                int c &#x3D; count + 1;</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                else</span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count &#x3D; c;</span><br><span class="line">                oldValue &#x3D; null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get 逻辑比较简单，只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p><p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值,<strong>整个过程都不需要加锁</strong>。。</p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。<br>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>相对于HashMap的resize，ConcurrentHashMap的rehash原理类似，但是Doug Lea为rehash做了一定的优化，避免让所有的节点都进行复制操作：由于扩容是基于2的幂指来操作，假设扩容前某HashEntry对应到Segment中数组的index为i，数组的容量为capacity，那么扩容后该HashEntry对应到新数组中的index只可能为i或者i+capacity，因此大多数HashEntry节点在扩容前后index可以保持不变。基于此，rehash方法中会定位第一个后续所有节点在扩容后index都保持不变的节点，然后将这个节点之前的所有节点重排即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">void rehash() &#123;</span><br><span class="line">HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;</span><br><span class="line">int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">if (oldCapacity &gt;&#x3D; MAXIMUM_CAPACITY)</span><br><span class="line">return;</span><br><span class="line"> </span><br><span class="line">&#x2F;*</span><br><span class="line"> * Reclassify nodes in each list to new Map.  Because we are</span><br><span class="line"> * using power-of-two expansion, the elements from each bin</span><br><span class="line"> * must either stay at same index, or move with a power of two</span><br><span class="line"> * offset. We eliminate unnecessary node creation by catching</span><br><span class="line"> * cases where old nodes can be reused because their next</span><br><span class="line"> * fields won&#39;t change. Statistically, at the default</span><br><span class="line"> * threshold, only about one-sixth of them need cloning when</span><br><span class="line"> * a table doubles. The nodes they replace will be garbage</span><br><span class="line"> * collectable as soon as they are no longer referenced by any</span><br><span class="line"> * reader thread that may be in the midst of traversing table</span><br><span class="line"> * right now.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;*</span><br><span class="line"> * 其实这个注释已经解释的很清楚了，主要就是因为扩展是按照2的幂次方</span><br><span class="line"> * 进行扩展的，所以扩展前在同一个桶中的元素，现在要么还是在原来的</span><br><span class="line"> * 序号的桶里，或者就是原来的序号再加上一个2的幂次方，就这两种选择。</span><br><span class="line"> * 所以原桶里的元素只有一部分需要移动，其余的都不要移动。该函数为了</span><br><span class="line"> * 提高效率，就是找到最后一个不在原桶序号的元素，那么连接到该元素后面</span><br><span class="line"> * 的子链表中的元素的序号都是与找到的这个不在原序号的元素的序号是一样的</span><br><span class="line"> * 那么就只需要把最后一个不在原序号的元素移到新桶里，那么后面跟的一串</span><br><span class="line"> * 子元素自然也就连接上了，而且序号还是相同的。在找到的最后一个不在</span><br><span class="line"> * 原桶序号的元素之前的元素就需要逐个的去遍历，加到和原桶序号相同的新桶上</span><br><span class="line"> * 或者加到偏移2的幂次方的序号的新桶上。这个都是新创建的元素，因为</span><br><span class="line"> * 只能在表头插入元素。这个原因可以参考</span><br><span class="line"> * 《探索 ConcurrentHashMap 高并发性的实现机制》中的讲解</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line">HashEntry&lt;K,V&gt;[] newTable &#x3D; HashEntry.newArray(oldCapacity&lt;&lt;1);</span><br><span class="line">threshold &#x3D; (int)(newTable.length * loadFactor);</span><br><span class="line">int sizeMask &#x3D; newTable.length - 1;</span><br><span class="line">for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">&#x2F;&#x2F; We need to guarantee that any existing reads of old Map can</span><br><span class="line">&#x2F;&#x2F;  proceed. So we cannot yet null out each bin.</span><br><span class="line">HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];</span><br><span class="line"> </span><br><span class="line">if (e !&#x3D; null) &#123;</span><br><span class="line">HashEntry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">int idx &#x3D; e.hash &amp; sizeMask;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;  Single node on list</span><br><span class="line">if (next &#x3D;&#x3D; null)</span><br><span class="line">newTable[idx] &#x3D; e;</span><br><span class="line"> </span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; Reuse trailing consecutive sequence at same slot</span><br><span class="line">HashEntry&lt;K,V&gt; lastRun &#x3D; e;</span><br><span class="line">int lastIdx &#x3D; idx;</span><br><span class="line">for (HashEntry&lt;K,V&gt; last &#x3D; next;</span><br><span class="line"> last !&#x3D; null;</span><br><span class="line"> last &#x3D; last.next) &#123;</span><br><span class="line">int k &#x3D; last.hash &amp; sizeMask;</span><br><span class="line">&#x2F;&#x2F; 这里就是遍历找到最后一个不在原桶序号处的元素</span><br><span class="line">if (k !&#x3D; lastIdx) &#123;</span><br><span class="line">lastIdx &#x3D; k;</span><br><span class="line">lastRun &#x3D; last;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 把最后一个不在原桶序号处的元素赋值到新桶中</span><br><span class="line">&#x2F;&#x2F; 由于链表本身的特性，那么该元素后面的元素也都能连接过来</span><br><span class="line">&#x2F;&#x2F; 并且能保证后面的这些元素在新桶中的序号都是和该元素是相等的</span><br><span class="line">&#x2F;&#x2F; 因为上面的遍历就是确保了该元素后面的元素的序号都是和这个元素</span><br><span class="line">&#x2F;&#x2F; 的序号是相等的。不然遍历中还会重新赋值lastIdx</span><br><span class="line">newTable[lastIdx] &#x3D; lastRun;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Clone all remaining nodes</span><br><span class="line">&#x2F;&#x2F; 这个就是把上面找到的最后一个不在原桶序号处的元素之前的元素赋值到</span><br><span class="line">&#x2F;&#x2F; 新桶上，注意都是把元素添加到新桶的表头处</span><br><span class="line">for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;</span><br><span class="line">int k &#x3D; p.hash &amp; sizeMask;</span><br><span class="line">HashEntry&lt;K,V&gt; n &#x3D; newTable[k];</span><br><span class="line">newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(p.key, p.hash,</span><br><span class="line"> n, p.value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">table &#x3D; newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-8他的数据结构"><a href="#1-8他的数据结构" class="headerlink" title="1.8他的数据结构"></a>1.8他的数据结构</h2><p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p><p>跟HashMap很像，也把之前的HashEntry改成了Node，但是作用不变，把值和next采用了volatile去修饰，保证了可见性，并且也引入了红黑树，在链表大于一定值的时候会转换（默认是8）。</p><p>① 取消分段锁机制，进一步降低冲突概率。② 引入红黑树结构，同一个哈希槽上的元素个数超过一定阈值后，单向链表改为红黑树结构。③ 使用了更加优化的方式统计集合内的元素数量。具体优化表现在：在 put、resize 和 size 方法中设计元素总数的更新和计算都避免了锁，使用 CAS 代替。</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><p>①根据 key 计算出 hashcode，判断是否需要进行初始化。 。</p><p>②<code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p><p>③如果都不满足，则利用 synchronized 锁写入数据。</p><p>④如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        int binCount &#x3D; 0;</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">                tab &#x3D; initTable();</span><br><span class="line">            else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                    break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                synchronized (f) &#123;</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123;</span><br><span class="line">                            binCount &#x3D; 1;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal &#x3D; e.val;</span><br><span class="line">                                    if (!onlyIfAbsent)</span><br><span class="line">                                        e.val &#x3D; value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                    pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount &#x3D; 2;</span><br><span class="line">                            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) !&#x3D; null) &#123;</span><br><span class="line">                                oldVal &#x3D; p.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    p.val &#x3D; value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (binCount !&#x3D; 0) &#123;</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    if (oldVal !&#x3D; null)</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><img src="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/2.png" class title="如图"><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p><code>get</code> 同样不需要同步</p><p>1.根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p><p>2.如果是红黑树那就按照树的方式获取值。</p><p>3.就不满足那就按照链表的方式遍历获取值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">      int h &#x3D; spread(key.hashCode());</span><br><span class="line">      if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">          (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;</span><br><span class="line">          if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;</span><br><span class="line">              if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))</span><br><span class="line">                  return e.val;</span><br><span class="line">          &#125;</span><br><span class="line">          else if (eh &lt; 0)</span><br><span class="line">              return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">          while ((e &#x3D; e.next) !&#x3D; null) &#123;</span><br><span class="line">              if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                  ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                  return e.val;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><img src="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/3.png" class title="如图"><h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><h2 id="扩容时候遇到put操作怎么办"><a href="#扩容时候遇到put操作怎么办" class="headerlink" title="扩容时候遇到put操作怎么办"></a>扩容时候遇到put操作怎么办</h2><p>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索</p><p><strong>ForwardingNode</strong>： 是临时节点，这个节点会出现在扩容的时候，不存储实际的数据数据。</p><p>这是一个真正的辅助类，该类仅仅只存活在ConcurrentHashMap扩容操作时。只是一个标志节点，并且指向nextTable，它提供find方法而已。该类也是集成Node节点，其hash为-1，key、value、next均为null。如下：</p><pre><code>static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; {    final Node&lt;K,V&gt;[] nextTable;    ForwardingNode(Node&lt;K,V&gt;[] tab) {        super(MOVED, null, null, null);        this.nextTable = tab;    }    Node&lt;K,V&gt; find(int h, Object k) {    // loop to avoid arbitrarily deep recursion on forwarding nodes    outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) {        Node&lt;K,V&gt; e; int n;        if (k == null || tab == null || (n = tab.length) == 0 ||                (e = tabAt(tab, (n - 1) &amp; h)) == null)            return null;        for (;;) {            int eh; K ek;            if ((eh = e.hash) == h &amp;&amp;                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))                return e;            if (eh &lt; 0) {                if (e instanceof ForwardingNode) {                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;                    continue outer;                }                else                    return e.find(h, k);            }            if ((e = e.next) == null)                return null;        }    }}}</code></pre><p>如果Hash桶被迁移到新的table中，会在旧的table插入一个ForwardingNode临时节点，内部会指向新的table。</p><p>当读操作碰到ForwardingNode，会通过ForwardingNode内部的nextTable找到新的table，继续读。</p><p>当写操作碰到ForwadingNode，加入帮助扩容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span><br><span class="line">private final void tryPresize(int size) &#123;</span><br><span class="line">    &#x2F;&#x2F; c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span><br><span class="line">    int c &#x3D; (size &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span><br><span class="line">    int sc;</span><br><span class="line">    while ((sc &#x3D; sizeCtl) &gt;&#x3D; 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab &#x3D; table; int n;</span><br><span class="line">        &#x2F;&#x2F; 这个 if 分支和之前说的初始化数组的代码基本上是一样的</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            n &#x3D; (sc &gt; c) ? sc : c;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (table &#x3D;&#x3D; tab) &#123;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        table &#x3D; nt;</span><br><span class="line">                        sc &#x3D; n - (n &gt;&gt;&gt; 2); &#x2F;&#x2F; 0.75 * n</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    sizeCtl &#x3D; sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (c &lt;&#x3D; sc || n &gt;&#x3D; MAXIMUM_CAPACITY)</span><br><span class="line">            break;</span><br><span class="line">        else if (tab &#x3D;&#x3D; table) &#123;</span><br><span class="line">            int rs &#x3D; resizeStamp(n);</span><br><span class="line">            if (sc &lt; 0) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||</span><br><span class="line">                    transferIndex &lt;&#x3D; 0)</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span><br><span class="line">                &#x2F;&#x2F; 此时 nextTab 不为 null</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span><br><span class="line">            &#x2F;&#x2F; 调用 transfer 方法，此时 nextTab 参数为 null</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap解析</title>
      <link href="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>内部包含了一个 Entry 类型的数组 table,1.8之后改成Node。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;transient Entry[] table;</span><br><span class="line">  transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当<br>成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结<br>果相同的 Entry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//key的hash值，put和get的时候都需要用到它来确定元素在数组中的位置</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="comment">//指向单链表的下一个节点</span></span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="keyword">this</span>.hash = hash;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><img src="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/2.png" class title="流程图"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法，会先调用一个hash()方法，得到当前key的一个hash值，</span></span><br><span class="line"><span class="comment">//用于确定当前key应该存放在数组的哪个下标位置</span></span><br><span class="line"><span class="comment">//这里的 hash方法，我们姑且先认为是key.hashCode()，其实不是的，一会儿细讲</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把hash值和当前的key，value传入进来</span></span><br><span class="line"><span class="comment">//这里onlyIfAbsent如果为true，表明不能修改已经存在的值，因此我们传入false</span></span><br><span class="line"><span class="comment">//evict只有在方法 afterNodeInsertion(boolean evict) &#123; &#125;用到，可以看到它是一个空实现，因此不用关注这个参数</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">//判断table是否为空，如果空的话，会先调用resize扩容</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">n = (tab = resize()).length;</span><br><span class="line"><span class="comment">//根据当前key的hash值找到它在数组中的下标，判断当前下标位置是否已经存在元素，</span></span><br><span class="line"><span class="comment">//若没有，则把key、value包装成Node节点，直接添加到此位置。</span></span><br><span class="line"><span class="comment">// i = (n - 1) &amp; hash 是计算下标位置的，为什么这样算，后边讲</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">//如果当前位置已经有元素了，分为三种情况。</span></span><br><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">//1.当前位置元素的hash值等于传过来的hash，并且他们的key值也相等，</span></span><br><span class="line"><span class="comment">//则把p赋值给e，跳转到①处，后续需要做值的覆盖处理</span></span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">e = p;</span><br><span class="line"><span class="comment">//2.如果当前是红黑树结构，则把它加入到红黑树 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//3.说明此位置已存在元素，并且是普通链表结构，则采用尾插法，把新节点加入到链表尾部</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果头结点的下一个节点为空，则插入新节点</span></span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果在插入的过程中，链表长度超过了8，则转化为红黑树</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line"><span class="comment">//插入成功之后，跳出循环，跳转到①处</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若在链表中找到了相同key的话，直接退出循环，跳转到①处</span></span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">p = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//① </span></span><br><span class="line"><span class="comment">//1.说明发生了碰撞，e代表的是旧值，因此节点位置不变，但是需要替换为新值</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">V oldValue = e.value;</span><br><span class="line"><span class="comment">//用新值替换旧值，并返回旧值。</span></span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">e.value = value;</span><br><span class="line"><span class="comment">//看方法名字即可知，这是在node被访问之后需要做的操作。其实此处是一个空实现，</span></span><br><span class="line"><span class="comment">//只有在 LinkedHashMap才会实现，用于实现根据访问先后顺序对元素进行排序，hashmap不提供排序功能</span></span><br><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="comment">//void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span></span><br><span class="line">afterNodeAccess(e);</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fail-fast机制</span></span><br><span class="line">++modCount;</span><br><span class="line"><span class="comment">//如果当前数组中的元素个数超过阈值，则扩容</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">resize();</span><br><span class="line"><span class="comment">//同样的空实现</span></span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hash方法"><a href="#Hash方法" class="headerlink" title="Hash方法"></a>Hash方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">两个值进行与运算，结果会趋向于<span class="number">0</span>；或运算，结果会趋向于<span class="number">1</span>；而只有异或运算，<span class="number">0</span>和<span class="number">1</span>的比例可以达到<span class="number">1</span>:<span class="number">1</span>的平衡状态。（非呢？别扯犊子了，两个值怎么做非运算。。。）</span><br><span class="line">所以，异或运算之后，可以让结果的随机性更大，而随机性大了之后，哈希碰撞的概率当然就更小了</span><br></pre></td></tr></table></figure><p>这里，会先判断key是否为空，若为空则返回0。这也说明了hashMap是支持key传 null 的。若非空，则先计算key的hashCode值，赋值给h，然后把h右移16位，并与原来的h进行异或处理。为什么要这样做，这样做有什么好处呢？</p><p>可以看到，其实相当于，我们把高16位值和当前h的低16位进行了混合，这样可以尽量保留高16位的特征，从而降低哈希碰撞的概率。</p><p>思考一下，为什么这样做，就可以降低哈希碰撞的概率呢？先别着急，我们需要结合 i = (n - 1) &amp; hash 这一段运算来理解。</p><p> <strong>i = (n - 1) &amp; hash</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y :       10110010</span><br><span class="line">x-1 :     00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure><p>这个性质和 y 对 x 取模效果是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y :   10110010</span><br><span class="line">x :   00010000</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><ul><li>首先将key hash之后取得所定位的桶</li><li>如果桶为空，则直接返回null</li><li>否则判断桶的第一个位置（有可能是链表、红黑树）的key是否为查询的key，是就直接返回value</li><li>如果第一个不匹配，则判断它的下一个是红黑树还是链表</li><li>红黑树就按照树的查找方式返回值</li><li>不然就按照链表的方式遍历匹配返回值<img src="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/3.png" class title="流程图"></li></ul><h3 id="为什么HashMap链表会形成死循环"><a href="#为什么HashMap链表会形成死循环" class="headerlink" title="为什么HashMap链表会形成死循环"></a>为什么HashMap链表会形成死循环</h3><p>准确的讲应该是 JDK1.7 的 HashMap 链表会有死循环的可能，因为JDK1.7是采用的头插法，在多线程环境下有可能会使链表形成环状，从而导致死循环。JDK1.8做了改进，用的是尾插法，不会产生死循环。</p><h3 id="JDK7与JDK8中HashMap的不同点"><a href="#JDK7与JDK8中HashMap的不同点" class="headerlink" title="JDK7与JDK8中HashMap的不同点"></a>JDK7与JDK8中HashMap的不同点</h3><ul><li><p>JDK8中使用了红黑树</p></li><li><p>JDK7中链表的插入使用的头插法（扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致CPU飙升），JDK8中链表使用的尾插法（JDK8中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法</p></li><li></li></ul><h2 id="那为啥用16不用别的呢？"><a href="#那为啥用16不用别的呢？" class="headerlink" title="那为啥用16不用别的呢？"></a>那为啥用16不用别的呢？</h2><p>因为在使用是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。</p><p>只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。这是为了<strong>实现均匀分布</strong>。</p><h2 id="什么时候变成红黑树"><a href="#什么时候变成红黑树" class="headerlink" title="什么时候变成红黑树"></a>什么时候变成红黑树</h2><p>一个是链表长度到8,一个是数组长度到64.</p><h2 id="HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？"><a href="#HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？" class="headerlink" title="HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？"></a>HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？</h2><p>1.Hashtable</p><p>2.ConcurrentHashMap</p><p>不过出于线程并发度的原因，我都会舍弃前两者使用最后的ConcurrentHashMap，他的性能和效率明显高于前两者。</p><h2 id="Hashtable效率低"><a href="#Hashtable效率低" class="headerlink" title="Hashtable效率低"></a>Hashtable效率低</h2><p>他在对数据操作的时候都会上锁，所以效率比较低下。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p><strong>resize 方法：扩容数组</strong>,分为两个部分，一个是扩容数组，一个是重新规划长度。</p><p>重新规划长度和阈值，如果长度发生了变化，部分数据节点也要重新排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 HashMap实行了懒加载, 新建HashMap时不会对table进行赋值, 而是到第一次插入时, 进行resize时构建table;</span><br><span class="line">2 当HashMap.size 大于 threshold时, 会进行resize;threshold的值我们在上一次分享中提到过: 当第一次构建时, 如果没有指定HashMap.table的初始长度, 就用默认值16, 否则就是指定的值; 然后不管是第一次构建还是后续扩容, threshold &#x3D; table.length * loadFactor;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr &#x3D; threshold;</span><br><span class="line">        int newCap, newThr &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;如果原table不为空</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果原容量已经达到最大容量了，无法进行扩容，直接返回</span><br><span class="line">            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;设置新容量为旧容量的两倍</span><br><span class="line">            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                &#x2F;&#x2F;阈值也变为原来的两倍</span><br><span class="line">                newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">        * 从构造方法我们可以知道</span><br><span class="line">        * 如果没有指定initialCapacity, 则不会给threshold赋值, 该值被初始化为0</span><br><span class="line">    * 如果指定了initialCapacity, 该值被初始化成大于initialCapacity的最小的2的次幂</span><br><span class="line">* 这里这种情况指的是原table为空，并且在初始化的时候指定了容量，</span><br><span class="line">* 则用threshold作为table的实际大小</span><br><span class="line">*&#x2F;</span><br><span class="line">        else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">            newCap &#x3D; oldThr;</span><br><span class="line">        &#x2F;&#x2F;构造方法中没有指定容量，则使用默认值</span><br><span class="line">        else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 计算指定了initialCapacity情况下的新的 threshold</span><br><span class="line">        if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold &#x3D; newThr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**从以上操作我们知道, 初始化HashMap时, </span><br><span class="line">    *  如果构造函数没有指定initialCapacity, 则table大小为16</span><br><span class="line">    *  如果构造函数指定了initialCapacity, 则table大小为threshold,</span><br><span class="line">    *  即大于指定initialCapacity的最小的2的整数次幂</span><br><span class="line">    </span><br><span class="line">    *  从下面开始, 初始化table或者扩容, 实际上都是通过新建一个table来完成</span><br><span class="line">    *&#x2F; </span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table &#x3D; newTab;</span><br><span class="line">        if (oldTab !&#x3D; null) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                  &#x2F;** 这里注意, table中存放的只是Node的引用,这里将oldTab[j]&#x3D;null只是清除旧表的引用, </span><br><span class="line">                   * 但是真正的node节点还在, 只是现在由e指向它</span><br><span class="line">                   *&#x2F;</span><br><span class="line">                    oldTab[j] &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F;桶中只有一个节点，直接放入新桶中</span><br><span class="line">                    if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                    &#x2F;&#x2F;桶中为红黑树，则对树进行拆分，对树的操作有机会再讲</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    &#x2F;&#x2F;桶中为链表，对链表进行拆分</span><br><span class="line">                    else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    &#x2F;&#x2F;下面为对链表的拆分，我们单独来讲一下。</span><br><span class="line">                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next &#x3D; e.next;</span><br><span class="line">                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                    loHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; e;</span><br><span class="line">                                loTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                    hiHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; e;</span><br><span class="line">                                hiTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                        if (loTail !&#x3D; null) &#123;</span><br><span class="line">                            loTail.next &#x3D; null;</span><br><span class="line">                            newTab[j] &#x3D; loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                            hiTail.next &#x3D; null;</span><br><span class="line">                            newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>重新规划长度</strong></p><p>①  判断原来的table是否为空，是的话判断: 如果原容量大于等于最大容量，那么将阈值设为 Integer 的最大值，并且 return 终止扩容，由于 size 不可能超过该值因此之后不会再发生扩容。如果 size 超出扩容阈值，把 table 容量增加为之前的2倍。否则 把 table 容量增加为之前的2倍。</p><p>② 判断oldThr&gt;0, 如果是hashmap传入指定的initialCapacity，这个初始值会给到oldThr.</p><p>③ 否则的话 传入默认的容量和负载因子</p><p><strong>重新排列数据节点</strong></p><p>① 如果节点为 null 值则不进行处理。② 否则如果节点没有next节点，那么重新计算其散列值然后存入新的 table 数组中。③ 如果节点为 TreeNode 节点，那么调用 split 方法进行处理，该方法用于对红黑树调整，如果太小会退化回链表。④ 如果节点是链表节点，需要将链表拆分为 超出旧容量的链表和未超出容量的链表。对于<code>hash &amp; oldCap == 0</code> 的部分不需要做处理，反之需要放到新的下标位置上，新下标 = 旧下标 + 旧容量。</p><p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capacity : 00010000</span><br><span class="line">new capacity : 00100000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   old:</span><br><span class="line">   10: 0000 1010</span><br><span class="line">   15: 0000 1111</span><br><span class="line">    &amp;: 0000 1010    </span><br><span class="line">    </span><br><span class="line">   new:</span><br><span class="line">   10: 0000 1010</span><br><span class="line">   31: 0001 1111</span><br><span class="line">    &amp;: 0000 1010    </span><br><span class="line"></span><br><span class="line">从上面的示例可以很轻易的看出, 两次indexFor()的差别只是第二次参与位于比第一次左边有一位从0变为1, 而这个变化的1刚好是oldCap, 那么只需要判断原key的hash这个位上是否为1: 若是1, 则需要移动至oldCap + i的槽位, 若为0, 则不需要移动;</span><br></pre></td></tr></table></figure><p>对于一个 Key<br>它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；<br>如果为 1，那么得到的结果为原来的结果 +16。</p><p><strong>线程不安全：</strong>Java 7 扩容时 resize 方法调用的 transfer 方法中使用头插法迁移元素，多线程会导致 Entry 链表形成环形数据结构，Entry 节点的 next 永远不为空，引起死循环。Java 8 在 resize 方法中完成扩容，并且改用了尾插法，不会产生死循环的问题，但是在多线程的情况下还是可能会导致数据覆盖的问题，因此依旧线程不安全。</p><h2 id="为啥Hashtable-是不允许键或值为-null-的，HashMap-的键值则都可以为-null？"><a href="#为啥Hashtable-是不允许键或值为-null-的，HashMap-的键值则都可以为-null？" class="headerlink" title="为啥Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null？"></a>为啥Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null？</h2><p>Hashtable使用的是<strong>安全失败机制（fail-safe）</strong>，这种机制会使你此次读到的数据不一定是最新的数据。</p><p>如果你使用null值，就会使得其无法判断对应的key是不存在还是为空</p><h2 id="和HashTable的对比"><a href="#和HashTable的对比" class="headerlink" title="和HashTable的对比"></a>和HashTable的对比</h2><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p>fail-fast的字面意思是“快速失败”。在迭代器遍历元素的过程中，需要比较操作前后 modCount 是否改变，如果改变了说明集合结构被改变，需要抛出ConcurrentModificationException,防止继续遍历。</p><h2 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h2><p>当我们对集合结构上做出改变的时候，fail-fast机制就会抛出异常。但是，对于采用fail-safe机制来说，就不会抛出异常(大家估计看到safe两个字就知道了)。</p><p>这是因为，当集合的结构被改变的时候，fail-safe机制会在复制原集合的一份数据出来，然后在复制的那份数据遍历。</p><p>因此，虽然fail-safe不会抛出异常，但存在以下缺点：</p><p>1.复制时需要额外的空间和时间上的开销。</p><p>2.不能保证遍历的是最新内容</p><h2 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h2><p>resize方法</p><pre><code>void resize(int newCapacity) {    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    if (oldCapacity == MAXIMUM_CAPACITY) {        threshold = Integer.MAX_VALUE;        return;    }    Entry[] newTable = new Entry[newCapacity];    boolean oldAltHashing = useAltHashing;    useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;            (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);    boolean rehash = oldAltHashing ^ useAltHashing;//判断是否需要对原node重新hash定位table的index    transfer(newTable, rehash); //扩容核心方法    table = newTable;    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);}</code></pre><p>JDK7的transfer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新table的容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//遍历原table</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            <span class="comment">//保存下一次循环的 Entry&lt;K,V&gt;</span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                <span class="comment">//通过e的key值计算e的hash值</span></span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//得到e在新table中的插入位置</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">//采用链头插入法将e插入i位置，最后得到的链表相对于原table正好是头尾相反的</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            <span class="comment">//下一次循环</span></span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容时 <code>resize</code> 调用 <code>transfer</code> 使用头插法迁移元素，每个线程都会生成newTable (newTable 是局部变量)，但原先 table 中的 Entry <a href>链表</a>是共享的.假设两个线程，线程1挂起，线程二执行迁移完成，此时线程1继续执行，本来是用e遍历table，用next保存下一个结点，但这样顺序就颠倒了。</p><p>JDK8 在 <code>resize</code> 方法中完成扩容，并改用尾插法，不会产生死循环，但并发下仍可能丢失数据。可用 ConcurrentHashMap 或 <code>Collections.synchronizedMap</code> 包装同步集合</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>换电脑了迁移hexo博客(Win-&gt;MAC)</title>
      <link href="/2020/06/26/%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E8%BF%81%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/06/26/%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E8%BF%81%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>1.找到自己Windows的hexo根目录</p><p>2.在 Mac安装git和node.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先在自己电脑上装好node和git（首先确保brew安装好了）</span><br><span class="line">brew install git</span><br><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>3.安装hexo</p><p>用node.js来安装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo g</span><br></pre></td></tr></table></figure><p>4.初始化hexo目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">新建一个hexo目录，</span><br><span class="line"></span><br><span class="line">mkdir bolg</span><br><span class="line"></span><br><span class="line">cd blog</span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line">在用hexo s测试是否成功，打开localhost:4000查看本地</span><br></pre></td></tr></table></figure><p>5.生成SSH密钥，关联github</p><p>先查看本地的SSH key: cd ~/.ssh<br>(我是新mac电脑，所以没有的，直接生成密钥）<br>$ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a>“    后面那个是注册邮箱</p><p>进入.ssh文件夹： cd ~/.ssh，然后打开里面的 id_rsa.pub文件，里面的内容就是 SSH key，复制全部内容；</p><p>网页打开 github 的设置：Settings -&gt; SSH and GPG keys，点击绿色的按钮 New SSH key，然后在输入框中输入刚才复制的内容；</p><p>保存后，github 会向你的邮箱发送一个验证链接（记得要去登录邮箱验证，不然之后的 hexo d 部署会一直不成功的！）；</p><p>测试一下是否成功：ssh <a href="mailto:git@github.com">git@github.com</a>，<br>看到以下即成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PTY allocation request failed on channel <span class="number">0</span></span><br><span class="line">Hi gjincai! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">Connection to github.com closed.</span></span><br></pre></td></tr></table></figure><p>6.文件配置转移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windows 下的博客根目录 hexo，复制该目录下的：_config.yml, scaffolds, source, themes,<span class="keyword">package</span>.json；</span><br><span class="line">mac 下的博客根目录 hexo，把刚才复制的内容，直接覆盖替换相同的文件文件夹。</span><br></pre></td></tr></table></figure><p> 7.设置个人信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname”</span><br><span class="line">git config --global user.email youremail@example.com</span><br></pre></td></tr></table></figure><p>到这就好了，和往常一样hexo g        hexo d发布文章吧！</p><p>结果会提示ERROR Deployer not found: git</p><p>安装以下再尝试：npm install hexo-deployer-git –save（若提示有关权限不足的，加sudo，反正我是遇到了）</p><p>之后就能正常发布文章了！nice</p>]]></content>
      
      
      <categories>
          
          <category> hexo相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis缓存穿透、击穿、雪崩等</title>
      <link href="/2020/06/26/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%AD%89/"/>
      <url>/2020/06/26/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h2><p>正常情况下，查询的数据都存在，如果请求一个不存在的数据，也就是缓存和数据库都查不到这个数据，每次都会去数据库查询，这种查询不存在数据的现象我们称为缓存穿透</p><h3 id="穿透带来的问题"><a href="#穿透带来的问题" class="headerlink" title="穿透带来的问题"></a>穿透带来的问题</h3><p>如果每次都拿一个不存在的id去查询数据库，可能会导致你的数据库压力增大</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>缓存空值<br> 之所以发生穿透，是因为缓存中没有存储这些数据的key，从而每次都查询数据库<br>我们可以为这些key在缓存中设置对应的值为null，后面查询这个key的时候就不用查询数据库了<br>当然为了健壮性，我们要对这些key设置过期时间，以防止真的有数据</li><li>BloomFilter<br>BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中<br>我们把有数据的key都放到BloomFilter中，每次查询的时候都先去BloomFilter判断，如果没有就直接返回null<br>注意BloomFilter没有删除操作，对于删除的key，查询就会经过BloomFilter然后查询缓存再查询数据库，所以BloomFilter可以结合缓存空值用，对于删除的key，可以在缓存中缓存null</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>在高并发的情况下，大量的请求同时查询同一个key时，此时这个key正好失效了，就会导致同一时间，这些请求都会去查询数据库，这样的现象我们称为缓存击穿</p><h3 id="击穿带来的问题"><a href="#击穿带来的问题" class="headerlink" title="击穿带来的问题"></a>击穿带来的问题</h3><p>会造成某一时刻数据库请求量过大</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>1.使用互斥锁(mutex key)</strong></p><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p><p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">String value = redis.get(key);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//代表缓存值过期</span></span><br><span class="line"><span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line"><span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//代表设置成功</span></span><br><span class="line">value = db.get(key);</span><br><span class="line">redis.set(key, value, expire_secs);</span><br><span class="line">redis.del(key_mutex);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">sleep(<span class="number">50</span>);</span><br><span class="line">get(key);</span><br><span class="line"><span class="comment">//重试</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.”永远不过期”**</p><p>这里的“永远不过期”包含两层意思：</p><p>(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。</p><p>(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期</p><p>从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">V v = redis.get(key);</span><br><span class="line">String value = v.getValue();</span><br><span class="line"><span class="keyword">long</span> timeout = v.getTimeout();</span><br><span class="line"><span class="keyword">if</span> (v.timeout &lt;= System.currentTimeMillis()) &#123;</span><br><span class="line"><span class="comment">// 异步更新后台异常执行  </span></span><br><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String keyMutex = <span class="string">"mutex:"</span> + key;</span><br><span class="line"><span class="keyword">if</span> (redis.setnx(keyMutex, <span class="string">"1"</span>)) &#123;</span><br><span class="line"><span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">redis.expire(keyMutex, <span class="number">3</span> * <span class="number">60</span>);</span><br><span class="line">String dbValue = db.get(key);</span><br><span class="line">redis.set(key, dbValue);</span><br><span class="line">redis.delete(keyMutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了</p><h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效</li><li>ehcache本地缓存 + Hystrix限流&amp;降级<br>ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵<br>使用 Hystrix进行限流 &amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑</li><li>在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了</li><li>热点数据永不过期，参考上文</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阻塞、同步、乐观悲观相关概念</title>
      <link href="/2020/06/25/%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E4%B9%90%E8%A7%82%E6%82%B2%E8%A7%82%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/06/25/%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E4%B9%90%E8%A7%82%E6%82%B2%E8%A7%82%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>当某个任务在执行过程中发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；</p><h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><p>当某个任务在执行过程中发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直处于等待状态。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>当多个任务要发生时，这些任务必须逐个地进行，一个任务的执行会导致整个流程的暂时等待，这些事件不是并发地执行的；</p><h2 id="非同步"><a href="#非同步" class="headerlink" title="非同步"></a>非同步</h2><p>当多个任务要发生时，这些任务可以并发地执行，一个任务的执行不会导致整个流程的暂时等待。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。</p><p>共享锁【Shared lock】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p><p>排他锁【Exclusive lock】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized的相关性质</title>
      <link href="/2020/06/24/synchronized%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/"/>
      <url>/2020/06/24/synchronized%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h2><p><strong>反编译后,synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头).当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/30/16315cd5fa7cf91c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="对象，对象监视器，同步队列和线程状态的关系"></p><p>`<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png" alt="synchronized关键字原理"></p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>1.同步一个代码块</p><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.同步一个方法</p><p>作用于同一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.同步一个类</p><p>作用于整个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.同步一个静态方法</p><p>整个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和volatile的对比"><a href="#和volatile的对比" class="headerlink" title="和volatile的对比"></a>和volatile的对比</h2><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。自旋锁的思想是让一个线程在请求一个共享数据的锁时自旋一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。<br>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行循环操作占用 CPU 时间，它只适用于共享数据的<br>锁定状态很短的场景。<br>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数<br>及锁的拥有者的状态来决定。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。<br>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成<br>私有数据对待，也就可以将它们的锁进行消除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String concatString(String s1, String s2, String s3) &#123;</span><br><span class="line">  return s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连<br>续 append() 操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String concatString(String s1, String s2, String s3) &#123;</span><br><span class="line">  StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">  sb.append(s1);</span><br><span class="line">  sb.append(s2);</span><br><span class="line">  sb.append(s3);</span><br><span class="line">  return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line"> StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"> sb.append(s1);</span><br><span class="line"> sb.append(s2);</span><br><span class="line"> sb.append(s3);</span><br><span class="line"> <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次就可以了。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>自旋锁的目标是降低线程切换的成本。</p><blockquote><p><strong>加锁</strong></p></blockquote><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中<strong>创建用于存储锁记录的空间</strong>，并将对象头中的Mark Word复制到锁记录中，官方称为<strong>Displaced Mark Word</strong>。然后线程尝试使用CAS<strong>将对象头中的Mark Word替换为指向锁记录的指针</strong>。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><blockquote><p><strong>解锁</strong></p></blockquote><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗</strong>。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，同时使用 CAS 操作将线程 ID 记录到 Mark Word中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。<br>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定<br>状态或者轻量级锁状态。</p><h2 id="synchronized和volatile的比较"><a href="#synchronized和volatile的比较" class="headerlink" title="synchronized和volatile的比较"></a>synchronized和volatile的比较</h2><p>1.volatile本质是告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取，synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p><p>2.volatile仅能用在变量级别，而synchronized可以使用在变量、方法、类级别。</p><p>3.volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</p><p>4.volatile不会造成线程阻塞，synchronized可能会造成线程阻塞。</p><p>5.volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化。</p><h2 id="发生异常时自动释放锁"><a href="#发生异常时自动释放锁" class="headerlink" title="发生异常时自动释放锁"></a>发生异常时自动释放锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">syntest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" start"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">         count++;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">" count: "</span>+count);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">                System.out.println(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        syntest s=<span class="keyword">new</span> syntest();</span><br><span class="line">        Runnable r=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                s.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如题， 发生异常的时候，synchronized锁释放，线程t2得以执行</p><p>但是要注意的是，对于显式锁， 如ReentrantLock，在发生异常的时候，必须要手动释放锁。 </p><p>如果执行的代码段有可能发生异常，我们通常要这样处理, 需要在finally里面释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//可能发生异常的代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="comment">//释放IO资源</span></span><br><span class="line">    io.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reetest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" count: "</span> + count);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        reetest s=<span class="keyword">new</span> reetest();</span><br><span class="line">        Runnable r=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                s.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和Lock的区别"><a href="#和Lock的区别" class="headerlink" title="和Lock的区别"></a>和Lock的区别</h2><ol><li><p>来源：<br>lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；</p></li><li><p>异常是否释放锁：<br>synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）</p></li><li><p>是否响应中断<br>lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；</p></li><li><p>是否知道获取锁<br>Lock可以通过trylock来知道有没有获取锁，而synchronized不能；</p></li><li><p>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</p></li><li><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p></li><li><p>synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度，</p></li></ol><h2 id="轻量级锁什么时候升级为重量级锁？"><a href="#轻量级锁什么时候升级为重量级锁？" class="headerlink" title="轻量级锁什么时候升级为重量级锁？"></a>轻量级锁什么时候升级为重量级锁？</h2><p>我们必须给线程空循环设置一个次数，当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为<strong>重量级锁</strong>。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。</p><h2 id="偏向锁升级为轻量级"><a href="#偏向锁升级为轻量级" class="headerlink" title="偏向锁升级为轻量级"></a>偏向锁升级为轻量级</h2><p>轻量级锁由偏向锁升级而来，偏向锁运行在一个线程同步块时，第二个线程加入锁竞争的时候，偏向锁就会升级为轻量级锁。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><img src="/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1.png" class title="布隆过滤器">]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CAS</title>
      <link href="/2020/06/24/CAS/"/>
      <url>/2020/06/24/CAS/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="阻塞同步和非阻塞同步"><a href="#阻塞同步和非阻塞同步" class="headerlink" title="阻塞同步和非阻塞同步"></a>阻塞同步和非阻塞同步</h2><p>阻塞同步需要线程阻塞和唤醒所带来的性能问题，它属于一种悲观的并发策略，无论共享数据是否真的会出现竞争，它都要进行加锁。</p><h2 id="CAS是什么"><a href="#CAS是什么" class="headerlink" title="CAS是什么"></a>CAS是什么</h2><p>它是乐观并发策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则不断地重试，直到成功。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。**</span><br></pre></td></tr></table></figure><p>CAS 表示 Compare And Swap，比较并交换，CAS 主要需要三个操作数，分别是内存中存放的实际值V、旧的预期值 A 和准备设置的新值 B。CAS 指令执行时，当且仅当 V 符合 A 时，处理器才会用 B 更新 V 的值，否则它就不执行更新。但不管是否更新都会返回 V 的旧值，这些处理过程是原子操作，执行期间不会被其他线程打断。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。<br>以下代码使用了 AtomicInteger 执行了自增的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示<br>操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt()<br>来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。<br>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">   var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</span><br><span class="line">J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版</span><br><span class="line">本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统</span><br><span class="line">的互斥同步可能会比原子类更高效。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>volatile的性质</title>
      <link href="/2020/06/24/volatile%E7%9A%84%E6%80%A7%E8%B4%A8/"/>
      <url>/2020/06/24/volatile%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="说说你对volatile关键字的理解"><a href="#说说你对volatile关键字的理解" class="headerlink" title="说说你对volatile关键字的理解"></a>说说你对volatile关键字的理解</h2><p>就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性：</p><p>1 . 保证了不同线程对该变量操作的可见性;</p><p>2 . 禁止指令重排序</p><h2 id="volatile关键字如何保证可见性的？"><a href="#volatile关键字如何保证可见性的？" class="headerlink" title="volatile关键字如何保证可见性的？"></a>volatile关键字如何保证可见性的？</h2><p>要知道volatile是如何保证可见性的需要先了解下有关CPU缓存的概念。我们知道<strong>CPU的运算速度</strong>要比<strong>内存的读写速度</strong>快很多，这就造成了内存无法跟上CPU的情况。为了解决这类问题，出现了针对CPU的缓存协议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intel开发了缓存一致性协议，也就是MESI协议</span><br><span class="line"></span><br><span class="line">①当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，那么他会发出信号通知其他CPU将该变量的缓存行设置为无效状态。</span><br><span class="line"></span><br><span class="line">②当其他CPU使用这个变量时，首先会去嗅探是否有对该变量更改的信号，当发现这个变量的缓存行已经无效时，会从新从内存中读取这个变量。</span><br></pre></td></tr></table></figure><p>了解了上面的内容，就可以很容易的理解volatile是如何实现的了。</p><ol><li>被 volatile 修饰的共享变量，在翻译成为机器码的过程中为其<code>赋值操作</code>添加特殊机器码指令前缀<code>Lock xxxx</code></li><li>当CPU发现这个指令时，立即做两件事：<ul><li>使本CPU的缓存写入内存</li><li>上面的写入动作也会引起别的CPU中的缓存无效，</li></ul></li></ol><p><strong>volatile关键字的变量写操作时，强制缓存和主存同步，其他线程读时候发现缓存失效，就去读主存，由此保证了变量的可见性。</strong></p><h2 id="volatile关键字如何保证有序性的？"><a href="#volatile关键字如何保证有序性的？" class="headerlink" title="volatile关键字如何保证有序性的？"></a>volatile关键字如何保证有序性的？</h2><p>在JMM的逻辑实现中，当操作一个变量 执行为变量赋值 时，JVM会检查此变量是否是被volatile修饰的，如果是的话，JVM会为该变量添加内存屏障。保证该变量操作之前的操作不会乱序到其后</p><ol><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1583231-26cc583714507e7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/778/format/webp" alt="img"></p><h2 id="volatile可以保证原子性么？"><a href="#volatile可以保证原子性么？" class="headerlink" title="volatile可以保证原子性么？"></a>volatile可以保证原子性么？</h2><p>例如我们常碰到的i++的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 1; &#x2F;&#x2F;原子性操作，不用使用volatile也不会出现线程安全问题。</span><br><span class="line">复制代码</span><br><span class="line">volatile int i &#x3D; 0;</span><br><span class="line">i++; &#x2F;&#x2F;非原子性操作</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果我们开启200个线程并发执行<code>i++</code>这行代码，每个线程中只执行一遍。如果volatile可以保证原子性的话，那么i的最终结果应该是200；而实际上我们发现这个值是会小于200的，原因是什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; i++ 其可以被拆解为</span><br><span class="line">1、线程读取i</span><br><span class="line">2、temp &#x3D; i + 1</span><br><span class="line">3、i &#x3D; temp</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>例如当 i=5 的时候A,B两个线程同时读入了 i 的值</li><li>然后A线程执行了 <code>temp = i + 1</code>的操作， 要注意，此时的 i 的值还没有变化，然后B线程也执行了<code>temp = i + 1</code>的操作，注意，此时A，B两个线程保存的 i 的值都是5，temp 的值都是6</li><li>然后A线程执行了 <code>i = temp</code> （6）的操作，此时i的值会立即刷新到主存并通知其他线程保存的 i 值失效， 此时B线程需要重新读取 i 的值那么此时B线程保存的 i 就是6</li><li>同时B线程保存的 temp 还仍然是6， 然后B线程执行 <code>i=temp</code> （6），所以导致了计算结果比预期少了1。<br>链接：<a href="https://juejin.im/post/5e01b9aa518825126f373b58" target="_blank" rel="noopener">https://juejin.im/post/5e01b9aa518825126f373b58</a></li></ol><h2 id="volatile底层的实现机制？"><a href="#volatile底层的实现机制？" class="headerlink" title="volatile底层的实现机制？"></a>volatile底层的实现机制？</h2><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p><p>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</p><p>1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置 </p><p>2.将当前处理器缓存行的数据写回到系统内存。</p><p>3.这个写回内存的操作会使其他在CPU里缓存了该内存地址的数据无效。</p><h2 id="有了mesi还要volatile吗？"><a href="#有了mesi还要volatile吗？" class="headerlink" title="有了mesi还要volatile吗？"></a>有了mesi还要volatile吗？</h2><p>在Java中，volatile是个很高层面的规范，保证了指令不会被重排序+对volatile变量的写使得当前cpu缓存中的所有变量写回到主存中，从而保证了内存可见性。</p><p>还是有用的，就算在实现了mesi的cpu上，volatile一样不可或缺。除了禁止指令重排序的作用外，由于mesi只是保证了L1-3 的cache之间的可见性，但是cpu和L1之间</p><p>还有像storebuffer之类的缓存，而volatile规范保证了对它修饰的变量的写指令会使得当前cpu所有缓存写到被mesi保证可见性的L1-3cache中。</p><p>因为 MESI只是保证了多核cpu的独占cache(L1,L2,L3)之间的一致性，但是cpu的并不是直接把数据写入L1 cache的，中间还可能有store buffer或者invalid queue等</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal的原理</title>
      <link href="/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>ThreadLocal 用于提供线程局部变量，在多线程环境可以保证各个线程里的变量独立于其它线程里的变量。</strong></p><p>也就是说 ThreadLocal 可以为每个线程创建一个【单独的变量副本】，相当于线程的 private static 类型变量。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String strLabel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLabel = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        strLabel = <span class="string">"main"</span>;</span><br><span class="line">        threadLabel.set(<span class="string">"main"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                strLabel = <span class="string">"child"</span>;</span><br><span class="line">                threadLabel.set(<span class="string">"child"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保证线程执行完毕</span></span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"strLabel = "</span> + strLabel);</span><br><span class="line">        System.out.println(<span class="string">"threadLabel = "</span> + threadLabel.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strLabel = child</span><br><span class="line">threadLabel = main</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal-set"><a href="#ThreadLocal-set" class="headerlink" title="ThreadLocal.set()"></a>ThreadLocal.set()</h3><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/6.png" alt="img"></p><p><code>ThreadLocal</code>中的<code>set</code>方法原理如上图所示，很简单，主要是判断<code>ThreadLocalMap</code>是否存在，然后使用<code>ThreadLocal</code>中的<code>set</code>方法进行数据处理。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> `ThreadLocalMap`(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>主要的核心逻辑还是在<code>ThreadLocalMap</code>中的，一步步往下看，后面还有更详细的剖析。</p><h3 id="ThreadLocalMap-Hash算法"><a href="#ThreadLocalMap-Hash算法" class="headerlink" title="ThreadLocalMap Hash算法"></a>ThreadLocalMap Hash算法</h3><p>既然是<code>Map</code>结构，那么<code>ThreadLocalMap</code>当然也要实现自己的<code>hash</code>算法来解决散列表数组冲突问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>中<code>hash</code>算法很简单，这里<code>i</code>就是当前key在散列表中对应的数组下标位置。</p><p>这里最关键的就是<code>threadLocalHashCode</code>值的计算，<code>ThreadLocal</code>中有一个属性为<code>HASH_INCREMENT = 0x61c88647</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> `<span class="title">ThreadLocalMap</span>` </span>&#123;</span><br><span class="line">        `ThreadLocalMap`(`ThreadLocal`&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>每当创建一个<code>ThreadLocal</code>对象，这个``ThreadLocal<code>.nextHashCode</code> 这个值就会增长 <code>0x61c88647</code> 。</p><p>这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p><p>我们自己可以尝试下：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/8.png" alt="img"></p><p>可以看到产生的哈希码分布很均匀，这里不去细纠<strong>斐波那契</strong>具体算法，感兴趣的可以自行查阅相关资料。</p><h3 id="ThreadLocalMapHash冲突"><a href="#ThreadLocalMapHash冲突" class="headerlink" title="ThreadLocalMapHash冲突"></a>ThreadLocalMapHash冲突</h3><blockquote><p><strong>注明：</strong> 下面所有示例图中，<strong>绿色块</strong><code>Entry</code>代表<strong>正常数据</strong>，<strong>灰色块</strong>代表<code>Entry</code>的<code>key</code>值为<code>null</code>，<strong>已被垃圾回收</strong>。<strong>白色块</strong>表示<code>Entry</code>为<code>null</code>。</p></blockquote><p>虽然<code>ThreadLocalMap</code>中使用了<strong>黄金分隔数来</strong>作为<code>hash</code>计算因子，大大减少了<code>Hash</code>冲突的概率，但是仍然会存在冲突。</p><p><code>HashMap</code>中解决冲突的方法是在数组上构造一个<strong>链表</strong>结构，冲突的数据挂载到链表上，如果链表长度超过一定数量则会转化成<strong>红黑树</strong>。</p><p>而<code>ThreadLocalMap</code>中并没有链表结构，所以这里不能适用<code>HashMap</code>解决冲突的方式了。</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/7.png" alt="img"></p><p>如上图所示，如果我们插入一个<code>value=27</code>的数据，通过<code>hash</code>计算后应该落入第4个槽位中，而槽位4已经有了<code>Entry</code>数据。</p><p>此时就会线性向后查找，一直找到<code>Entry</code>为<code>null</code>的槽位才会停止查找，将当前元素放入此槽位中。当然迭代过程中还有其他的情况，比如遇到了<code>Entry</code>不为<code>null</code>且<code>key</code>值相等的情况，还有<code>Entry</code>中的<code>key</code>值为<code>null</code>的情况等等都会有不同的处理，后面会一一详细讲解。</p><p>这里还画了一个<code>Entry</code>中的<code>key</code>为<code>null</code>的数据（<strong>Entry=2的灰色块数据</strong>），因为<code>key</code>值是<strong>弱引用</strong>类型，所以会有这种数据存在。在<code>set</code>过程中，如果遇到了<code>key</code>过期的<code>Entry</code>数据，实际上是会进行一轮<strong>探测式清理</strong>操作的，具体操作方式后面会讲到。</p><h3 id="ThreadLocalMap-set"><a href="#ThreadLocalMap-set" class="headerlink" title="ThreadLocalMap.set()"></a>ThreadLocalMap.set()</h3><h4 id="ThreadLocalMap-set-原理图解"><a href="#ThreadLocalMap-set-原理图解" class="headerlink" title="ThreadLocalMap.set()原理图解"></a>ThreadLocalMap.set()原理图解</h4><p>看完了<code>ThreadLocal</code> <strong>hash算法</strong>后，我们再来看<code>set</code>是如何实现的。</p><p>往<code>ThreadLocalMap</code>中<code>set</code>数据（<strong>新增</strong>或者<strong>更新</strong>数据）分为好几种情况，针对不同的情况我们画图来说说明。</p><p><strong>第一种情况：</strong> 通过<code>hash</code>计算后的槽位对应的<code>Entry</code>数据为空：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/9.png" alt="img"></p><p>这里直接将数据放到该槽位即可。</p><p><strong>第二种情况：</strong> 槽位数据不为空，<code>key</code>值与当前<code>ThreadLocal</code>通过<code>hash</code>计算获取的<code>key</code>值一致：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/10.png" alt="img"></p><p>这里直接更新该槽位的数据。</p><p><strong>第三种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code>Entry</code>为<code>null</code>的槽位之前，没有遇到<code>key</code>过期的<code>Entry</code>：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/11.png" alt="img"></p><p>遍历散列数组，线性往后查找，如果找到<code>Entry</code>为<code>null</code>的槽位，则将数据放入该槽位中，或者往后遍历过程中，遇到了<strong>key值相等</strong>的数据，直接更新即可。</p><p><strong>第四种情况：</strong> 槽位数据不为空，往后遍历过程中，在找到<code>Entry</code>为<code>null</code>的槽位之前，遇到<code>key</code>过期的<code>Entry</code>，如下图，往后遍历过程中，一到了<code>index=7</code>的槽位数据<code>Entry</code>的<code>key=null</code>：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/12.png" alt="img"></p><p>散列数组下标为7位置对应的<code>Entry</code>数据<code>key</code>为<code>null</code>，表明此数据<code>key</code>值已经被垃圾回收掉了，此时就会执行<code>replaceStaleEntry()</code>方法，该方法含义是<strong>替换过期数据的逻辑</strong>，以<strong>index=7</strong>位起点开始遍历，进行探测式数据清理工作。</p><p>初始化探测式清理过期数据扫描的开始位置：<code>slotToExpunge = staleSlot = 7</code></p><p>以当前<code>staleSlot</code>开始 向前迭代查找，找其他过期的数据，然后更新过期数据起始扫描下标<code>slotToExpunge</code>。<code>for</code>循环迭代，直到碰到<code>Entry</code>为<code>null</code>结束。</p><p>如果找到了过期的数据，继续向前迭代，直到遇到<code>Entry=null</code>的槽位才停止迭代，如下图所示，<strong>slotToExpunge被更新为0</strong>：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/13.png" alt="img"></p><p>以当前节点(<code>index=7</code>)向前迭代，检测是否有过期的<code>Entry</code>数据，如果有则更新<code>slotToExpunge</code>值。碰到<code>null</code>则结束探测。以上图为例<code>slotToExpunge</code>被更新为0。</p><p>上面向前迭代的操作是为了更新探测清理过期数据的起始下标<code>slotToExpunge</code>的值，这个值在后面会讲解，它是用来判断当前过期槽位<code>staleSlot</code>之前是否还有过期元素。</p><p>接着开始以<code>staleSlot</code>位置(index=7)向后迭代，<strong>如果找到了相同key值的Entry数据：</strong></p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/14.png" alt="img"></p><p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>元素，找到后更新<code>Entry</code>的值并交换<code>staleSlot</code>元素的位置(<code>staleSlot</code>位置为过期元素)，更新<code>Entry</code>数据，然后开始进行过期<code>Entry</code>的清理工作，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f3ba9af057e1e?w=1336&h=361&f=png&s=63049" alt="Yu4oWT.png"></p><p><strong>向后遍历过程中，如果没有找到相同key值的Entry数据：</strong></p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/15.png" alt="img"></p><p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>元素，直到<code>Entry</code>为<code>null</code>则停止寻找。通过上图可知，此时<code>table</code>中没有<code>key</code>值相同的<code>Entry</code>。</p><p>创建新的<code>Entry</code>，替换<code>table[stableSlot]</code>位置：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/16.png" alt="img"></p><p>替换完成后也是进行过期元素清理工作，清理工作主要是有两个方法：<code>expungeStaleEntry()</code>和<code>cleanSomeSlots()</code>，具体细节后面会讲到，请继续往后看。</p><h4 id="ThreadLocalMap-set-源码详解"><a href="#ThreadLocalMap-set-源码详解" class="headerlink" title="ThreadLocalMap.set()源码详解"></a>ThreadLocalMap.set()源码详解</h4><p>上面已经用图的方式解析了<code>set()</code>实现的原理，其实已经很清晰了，我们接着再看下源码：</p><p><code>java.lang.ThreadLocal</code>.<code>ThreadLocalMap.set()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这里会通过<code>key</code>来计算在散列表中的对应位置，然后以当前<code>key</code>对应的桶的位置向后查找，找到可以使用的桶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entry[] tab = table;</span><br><span class="line"><span class="keyword">int</span> len = tab.length;</span><br><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>什么情况下桶才是可以使用的呢？</p><ol><li><code>k = key</code> 说明是替换操作，可以使用</li><li>碰到一个过期的桶，执行替换逻辑，占用过期桶</li><li>查找过程中，碰到桶中<code>Entry=null</code>的情况，直接使用</li></ol><p>接着就是执行<code>for</code>循环遍历，向后查找，我们先看下<code>nextIndex()</code>、<code>prevIndex()</code>方法实现：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/17.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>接着看剩下<code>for</code>循环中的逻辑：</p><ol><li>遍历当前<code>key</code>值对应的桶中<code>Entry</code>数据为空，这说明散列数组这里没有数据冲突，跳出<code>for</code>循环，直接<code>set</code>数据到对应的桶中</li><li>如果<code>key</code>值对应的桶中<code>Entry</code>数据不为空</li><li>1 如果<code>k = key</code>，说明当前<code>set</code>操作是一个替换操作，做替换逻辑，直接返回</li><li>2 如果<code>key = null</code>，说明当前桶位置的<code>Entry</code>是过期数据，执行<code>replaceStaleEntry()</code>方法(核心方法)，然后返回</li><li><code>for</code>循环执行完毕，继续往下执行说明向后迭代的过程中遇到了<code>entry</code>为<code>null</code>的情况</li><li>1 在<code>Entry</code>为<code>null</code>的桶中创建一个新的<code>Entry</code>对象</li><li>2 执行<code>++size</code>操作</li><li>调用<code>cleanSomeSlots()</code>做一次启发式清理工作，清理散列数组中<code>Entry</code>的<code>key</code>过期的数据</li><li>1 如果清理工作完成后，未清理到任何数据，且<code>size</code>超过了阈值(数组长度的2/3)，进行<code>rehash()</code>操作</li><li>2 <code>rehash()</code>中会先进行一轮探测式清理，清理过期<code>key</code>，清理完成后如果<strong>size &gt;= threshold - threshold / 4</strong>，就会执行真正的扩容逻辑(扩容逻辑往后看)</li></ol><p>接着重点看下<code>replaceStaleEntry()</code>方法，<code>replaceStaleEntry()</code>方法提供替换过期数据的功能，我们可以对应上面<strong>第四种情况</strong>的原理图来再回顾下，具体代码如下：</p><p><code>java.lang.ThreadLocal.ThreadLocalMap.replaceStaleEntry()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(`ThreadLocal`&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line">slotToExpunge`表示开始探测式清理过期数据的开始下标，默认从当前的`staleSlot`开始。以当前的`staleSlot`开始，向前迭代查找，找到没有过期的数据，`<span class="keyword">for</span>`循环一直碰到`Entry`为`<span class="keyword">null</span>`才会结束。如果向前找到了过期数据，更新探测清理过期数据的开始下标为i，即`slotToExpunge=i</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">     (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">     i = prevIndex(i, len))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)&#123;</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>接着开始从<code>staleSlot</code>向后查找，也是碰到<code>Entry</code>为<code>null</code>的桶结束。 如果迭代过程中，<strong>碰到k == key</strong>，这说明这里是替换逻辑，替换新数据并且交换当前<code>staleSlot</code>位置。如果<code>slotToExpunge == staleSlot</code>，这说明<code>replaceStaleEntry()</code>一开始向前查找过期数据时并未找到过期的<code>Entry</code>数据，接着向后查找过程中也未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的index，即<code>slotToExpunge = i</code>。最后调用<code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code>进行启发式过期数据清理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">    e.value = value;</span><br><span class="line"></span><br><span class="line">    tab[i] = tab[staleSlot];</span><br><span class="line">    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>cleanSomeSlots()</code>和<code>expungeStaleEntry()</code>方法后面都会细讲，这两个是和清理相关的方法，一个是过期<code>key</code>相关<code>Entry</code>的启发式清理(<code>Heuristically scan</code>)，另一个是过期<code>key</code>相关<code>Entry</code>的探测式清理。</p><p><strong>如果k != key</strong>则会接着往下走，<code>k == null</code>说明当前遍历的<code>Entry</code>是一个过期数据，<code>slotToExpunge == staleSlot</code>说明，一开始的向前查找数据并未找到过期的<code>Entry</code>。如果条件成立，则更新<code>slotToExpunge</code> 为当前位置，这个前提是前驱节点扫描时未发现过期数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">    slotToExpunge = i;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>往后迭代的过程中如果没有找到<code>k == key</code>的数据，且碰到<code>Entry</code>为<code>null</code>的数据，则结束当前的迭代操作。此时说明这里是一个添加的逻辑，将新的数据添加到<code>table[staleSlot]</code> 对应的<code>slot</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>最后判断除了<code>staleSlot</code>以外，还发现了其他过期的<code>slot</code>数据，就要开启清理数据的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap过期key的探测式清理流程"><a href="#ThreadLocalMap过期key的探测式清理流程" class="headerlink" title="ThreadLocalMap过期key的探测式清理流程"></a>ThreadLocalMap过期key的探测式清理流程</h3><p>上面我们有提及<code>ThreadLocalMap</code>的两种过期<code>key</code>数据清理方式：<strong>探测式清理</strong>和<strong>启发式清理</strong>。</p><p>我们先讲下探测式清理，也就是<code>expungeStaleEntry</code>方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的<code>Entry</code>设置为<code>null</code>，沿途中碰到未过期的数据则将此数据<code>rehash</code>后重新在<code>table</code>数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的<code>Entry=null</code>的桶中，使<code>rehash</code>后的<code>Entry</code>数据距离正确的桶的位置更近一些。操作逻辑如下：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/18.png" alt="img"></p><p>如上图，<code>set(27)</code> 经过hash计算后应该落到<code>index=4</code>的桶中，由于<code>index=4</code>桶已经有了数据，所以往后迭代最终数据放入到<code>index=7</code>的桶中，放入后一段时间后<code>index=5</code>中的<code>Entry</code>数据<code>key</code>变为了<code>null</code></p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/19.png" alt="img"></p><p>如果再有其他数据<code>set</code>到<code>map</code>中，就会触发<strong>探测式清理</strong>操作。</p><p>如上图，执行<strong>探测式清理</strong>后，<code>index=5</code>的数据被清理掉，继续往后迭代，到<code>index=7</code>的元素时，经过<code>rehash</code>后发现该元素正确的<code>index=4</code>，而此位置已经已经有了数据，往后查找离<code>index=4</code>最近的<code>Entry=null</code>的节点(刚被探测式清理掉的数据：index=5)，找到后移动<code>index= 7</code>的数据到<code>index=5</code>中，此时桶的位置离正确的位置<code>index=4</code>更近了。</p><p>经过一轮探测式清理后，<code>key</code>过期的数据会被清理掉，没过期的数据经过<code>rehash</code>重定位后所处的桶位置理论上更接近<code>i= key.hashCode &amp; (tab.len - 1)</code>的位置。这种优化会提高整个散列表查询性能。</p><p>接着看下<code>expungeStaleEntry()</code>具体流程，我们还是以先原理图后源码讲解的方式来一步步梳理：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/20.png" alt="img"></p><p>我们假设<code>expungeStaleEntry(3)</code> 来调用此方法，如上图所示，我们可以看到<code>ThreadLocalMap</code>中<code>table</code>的数据情况，接着执行清理操作：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/21.png" alt="img"></p><p>第一步是清空当前<code>staleSlot</code>位置的数据，<code>index=3</code>位置的<code>Entry</code>变成了<code>null</code>。然后接着往后探测：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/22.png" alt="img"></p><p>执行完第二步后，index=4的元素挪到index=3的槽位中。</p><p>继续往后迭代检查，碰到正常数据，计算该数据位置是否偏移，如果被偏移，则重新计算<code>slot</code>位置，目的是让正常数据尽可能存放在正确位置或离正确位置更近的位置</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/23.png" alt="img"></p><p>在往后迭代的过程中碰到空的槽位，终止探测，这样一轮探测式清理工作就完成了，接着我们继续看看具体<strong>实现源代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这里我们还是以<code>staleSlot=3</code> 来做示例说明，首先是将<code>tab[staleSlot]</code>槽位的数据清空，然后设置<code>size--</code> 接着以<code>staleSlot</code>位置往后迭代，如果遇到<code>k==null</code>的过期数据，也是清空该槽位数据，然后<code>size--</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">    e.value = <span class="keyword">null</span>;</span><br><span class="line">    tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">&#125; Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>如果<code>key</code>没有过期，重新计算当前<code>key</code>的下标位置是不是当前槽位下标位置，如果不是，那么说明产生了<code>hash</code>冲突，此时以新计算出来正确的槽位位置往后迭代，找到最近一个可以存放<code>entry</code>的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">    tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">        h = nextIndex(h, len);</span><br><span class="line"></span><br><span class="line">    tab[h] = e;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这里是处理正常的产生<code>Hash</code>冲突的数据，经过迭代后，有过<code>Hash</code>冲突数据的<code>Entry</code>位置会更靠近正确位置，这样的话，查询的时候 效率才会更高。</p><h3 id="ThreadLocalMap扩容机制"><a href="#ThreadLocalMap扩容机制" class="headerlink" title="ThreadLocalMap扩容机制"></a>ThreadLocalMap扩容机制</h3><p>在``ThreadLocalMap.set()<code>方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中</code>Entry<code>的数量已经达到了列表的扩容阈值</code>(len*2/3)<code>，就开始执行</code>rehash()`逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>接着看下<code>rehash()</code>具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这里首先是会进行探测式清理工作，从<code>table</code>的起始位置往后清理，上面有分析清理的详细流程。清理完成之后，<code>table</code>中可能有一些<code>key</code>为<code>null</code>的<code>Entry</code>数据被清理掉，所以此时通过判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold* 3/4</code> 来决定是否扩容。</p><p>我们还记得上面进行<code>rehash()</code>的阈值是<code>size &gt;= threshold</code>，所以当面试官套路我们<code>ThreadLocalMap</code>扩容机制的时候 我们一定要说清楚这两个步骤：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/24.png" alt="img"></p><p>接着看看具体的<code>resize()</code>方法，为了方便演示，我们以<code>oldTab.len=8</code>来举例：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/25.png" alt="img"></p><p>扩容后的<code>tab</code>的大小为<code>oldLen * 2</code>，然后遍历老的散列表，重新计算<code>hash</code>位置，然后放到新的<code>tab</code>数组中，如果出现<code>hash</code>冲突则往后寻找最近的<code>entry</code>为<code>null</code>的槽位，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到新的<code>tab</code>中了。重新计算<code>tab</code>下次扩容的<strong>阈值</strong>，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap-get-详解"><a href="#ThreadLocalMap-get-详解" class="headerlink" title="ThreadLocalMap.get()详解"></a>ThreadLocalMap.get()详解</h3><p>上面已经看完了<code>set()</code>方法的源码，其中包括<code>set</code>数据、清理数据、优化数据桶的位置等操作，接着看看<code>get()</code>操作的原理。</p><h4 id="ThreadLocalMap-get-图解"><a href="#ThreadLocalMap-get-图解" class="headerlink" title="ThreadLocalMap.get()图解"></a>ThreadLocalMap.get()图解</h4><p><strong>第一种情况：</strong> 通过查找<code>key</code>值计算出散列表中<code>slot</code>位置，然后该<code>slot</code>位置中的<code>Entry.key</code>和查找的<code>key</code>一致，则直接返回：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/26.png" alt="img"></p><p><strong>第二种情况：</strong> <code>slot</code>位置中的<code>Entry.key</code>和要查找的<code>key</code>不一致：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/27.png" alt="img"></p><p>我们以<code>get(ThreadLocal1)</code>为例，通过<code>hash</code>计算后，正确的<code>slot</code>位置应该是4，而<code>index=4</code>的槽位已经有了数据，且<code>key</code>值不等于``ThreadLocal<code>1</code>，所以需要继续往后迭代查找。</p><p>迭代到<code>index=5</code>的数据时，此时<code>Entry.key=null</code>，触发一次探测式数据回收操作，执行<code>expungeStaleEntry()</code>方法，执行完后，<code>index 5,8</code>的数据都会被回收，而<code>index 6,7</code>的数据都会前移，此时继续往后迭代，到<code>index = 6</code>的时候即找到了<code>key</code>值相等的<code>Entry</code>数据，如下图所示：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/28.png" alt="img"></p><h4 id="ThreadLocalMap-get-源码详解"><a href="#ThreadLocalMap-get-源码详解" class="headerlink" title="ThreadLocalMap.get()源码详解"></a>ThreadLocalMap.get()源码详解</h4><p><code>java.lang.ThreadLocal.ThreadLocalMap.getEntry()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(`ThreadLocal`&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(`ThreadLocal`&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap过期key的启发式清理流程"><a href="#ThreadLocalMap过期key的启发式清理流程" class="headerlink" title="ThreadLocalMap过期key的启发式清理流程"></a>ThreadLocalMap过期key的启发式清理流程</h3><p>上面多次提及到<code>ThreadLocalMap</code>过期可以的两种清理方式：<strong>探测式清理(expungeStaleEntry())\</strong>、<strong>启发式清理(cleanSomeSlots())</strong></p><p>探测式清理是以当前<code>Entry</code> 往后清理，遇到值为<code>null</code>则结束清理，属于<strong>线性探测清理</strong>。</p><p>而启发式清理被作者定义为：<strong>Heuristically scan some cells looking for stale entries</strong>.</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/29.png" alt="img"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>我们使用<code>ThreadLocal</code>的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。</p><p>为了解决这个问题，JDK中还有一个<code>InheritableThreadLocal</code>类，我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; ThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">        ThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">        ThreadLocal.set(<span class="string">"父类数据:threadLocal"</span>);</span><br><span class="line">        inheritableThreadLocal.set(<span class="string">"父类数据:inheritableThreadLocal"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程获取父类`ThreadLocal`数据："</span> + `ThreadLocal`.get());</span><br><span class="line">                System.out.println(<span class="string">"子线程获取父类inheritableThreadLocal数据："</span> + inheritableThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子线程获取父类`ThreadLocal`数据：<span class="keyword">null</span></span><br><span class="line">子线程获取父类inheritableThreadLocal数据：父类数据:inheritableThreadLocalCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>实现原理是子线程是通过在父线程中通过调用<code>new Thread()</code>方法来创建子线程，<code>Thread#init</code>方法在<code>Thread</code>的构造方法中被调用。在<code>init</code>方法中拷贝父线程数据到子线程中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>但<code>InheritableThreadLocal</code>仍然有缺陷，一般我们做异步化处理都是使用的线程池，而<code>InheritableThreadLocal</code>是在<code>new Thread</code>中的<code>init()</code>方法给赋值的，而线程池是线程复用的逻辑，所以这里会存在问题。</p><p>当然，有问题出现就会有解决问题的方案，阿里巴巴开源了一个<code>TransmittableThreadLocal</code>组件就可以解决这个问题，这里就不再延伸，感兴趣的可自行查阅资料。</p><h2 id="怎么解决内存泄漏"><a href="#怎么解决内存泄漏" class="headerlink" title="怎么解决内存泄漏"></a>怎么解决内存泄漏</h2><p>当使用ThreadLocal保存一个value时，会在ThreadLocalMap中的数组插入一个Entry对象，按理说key-value都应该以强引用保存在Entry对象中，但在ThreadLocalMap的实现中，key被保存到了WeakReference对象中。这就导致了一个问题，ThreadLocal在没有外部强引用时，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><p>解决：使用remove</p><p>调用remove方法，肯定会删除对应的Entry对象</p><img src="/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/1.png" class title="内存模型"><h2 id="为什么要用弱引用"><a href="#为什么要用弱引用" class="headerlink" title="为什么要用弱引用"></a>为什么要用弱引用</h2><p>那换做强引用分析： <code>ThreadLocal</code>对象被两个强引用指向</p><ul><li>强引用： threadlocal1</li><li>强引用： Entry.key</li></ul><p>当我们断开程序中的强引用 <code>threadlocal1</code>时。<code>ThreadLocal</code>对象仍然被强引用<code>Entry.key</code>指向，不会回收，这就造成，<code>ThreadLocal</code>对象与 <code>value</code>都成为了脏数据。</p><h2 id="弱引用带来哪些问题"><a href="#弱引用带来哪些问题" class="headerlink" title="弱引用带来哪些问题"></a>弱引用带来哪些问题</h2><p>不管软引用还是强引用，都可能出现内存泄漏问题，弱引用反而将内存泄漏的程度降低**</p><p>利用弱引用的<strong>Entry会有key为null这个特征</strong>，可以识别哪些是不用的数据，进行清理操作，弱引用 反而提高了ThreadLocal的安全性。事实上当调用<code>ThreadLocal</code>的<code>get(),set(),reomve()</code>方法，都会清除掉线程<code>ThreadLocalMap</code>中所有Entry中Key为null的Value，并将整个Entry设置为null，利于下次内存回收。</p><h2 id="ThreadLocal可能存在哪些问题？"><a href="#ThreadLocal可能存在哪些问题？" class="headerlink" title="ThreadLocal可能存在哪些问题？"></a>ThreadLocal可能存在哪些问题？</h2><p>线程复用会产生脏数据，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用。如果没有调用 remove 清理与线程相关的 ThreadLocal 信息，那么假如下一个线程没有调用 set 设置初始值就可能 get 到重用的线程信息。</p><p>ThreadLocal 还存在内存泄漏的问题，由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放。因此需要及时调用 remove 方法进行清理操作。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的设计原则</title>
      <link href="/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><p><strong>开闭原则：</strong>面向对象设计中最基础的设计原则，指一个软件实体（类、模块、方法等）应该对扩展开放，对修改关闭。它强调用抽象构建框架，用实现扩展细节，提高代码的可复用性和可维护性。例如在版本更新时尽量不修改源代码，但可以增加新功能。</p><p><strong>单一职责原则：</strong>一个类、接口或方法只负责一个职责，可以提高代码可读性和可维护性，降低代码复杂度以及变更引起的风险。</p><p><strong>依赖倒置原则：</strong>程序应该依赖于抽象类或接口，而不是具体的实现类。可以降低代码的耦合度，提高系统的稳定性。</p><p><strong>接口隔离原则：</strong>将不同功能定义在不同接口中实现接口隔离，避免了类依赖它不需要的接口，减少了接口之间依赖的冗余性和复杂性。</p><p><strong>里氏替换原则：</strong>对开闭原则的补充，规定了任何父类可以出现的地方子类都一定可以出现，可以约束继承泛滥，加键程序健壮性。</p><p><strong>迪米特原则：</strong>也叫最少知道原则，每个模块对其他模块都要尽可能少的了解和依赖，可以降低代码耦合度。</p><p><strong>合成/聚合原则：</strong>尽量使用组合(has a)或聚合(contains a)而不是继承关系达到软件复用的目的，可以使系统更加灵活，降低耦合度。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型</title>
      <link href="/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
      <url>/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><strong>静态代理：代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hr</span> <span class="keyword">implements</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我需要找招聘一个员工"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hr hr;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hr = <span class="keyword">new</span> Hr();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hr.findWorker();</span><br><span class="line">        System.out.println(<span class="string">"找到了员工"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Company company=<span class="keyword">new</span> Proxy();</span><br><span class="line">        company.findWorker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理：</strong>动态代理在程序运行时才创建具体的代理类，代理类和被代理类的关系在运行前是不确定的。动态代理的适用性更强，主要分为 JDK 动态代理和 CGLib 动态代理。</p><p> JDK 动态代理：通过 Proxy类的 newInstance 方法获取一个动态代理对象，需要传入三个参数，被代理对象的类加载器、被代理对象实现的接口，以及一个 InvocationHandler 调用处理器实例来指明具体的逻辑，相比静态代理最大的优势是接口中声明的所有方法都被转移到 InvocationHandler 中的 invoke 方法集中处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hr hr = <span class="keyword">new</span> Hr();</span><br><span class="line">        Company proxyHr = (Company) Proxy.newProxyInstance(hr.getClass().getClassLoader(), hr.getClass().getInterfaces(), (proxy, method, args1) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"接收代理请求"</span>);</span><br><span class="line">            Object obj = method.invoke(hr, args1);</span><br><span class="line">            System.out.println(<span class="string">"找到了员工，完成请求"</span>);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;);</span><br><span class="line">        proxyHr.findWorker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VMWARE+Centos8配置静态IP地址</title>
      <link href="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/"/>
      <url>/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/1.png" class title="第一步"><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/2.png" class title="第二步"><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/3.png" class title="第三步"><p>打开网络和共享中心—&gt;更改适配器配置—–&gt;右键VMware Network Adapter—&gt;属性—-&gt;双击IPv4—&gt;</p><p>设置IP地址 以及网关</p><p>网关地址必须和vmwareNAT设置的一致，IP保持同一网段内即可</p><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/4.png" class title="如图所示"><p>重启虚拟机</p><p>使用root 用户修改 linux网络配置</p><p>su root</p><p>vi /etc/sysconfig/network-scripts/ifcfg-ens33</p><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/5.png" class title="如图所示"><p>重启网卡</p><p>nmcli c reload</p><p>配置到这里可以实现本机与虚拟机之间的通信了</p><p>虚拟机连接外网</p><p>如果你本机可以连接外网，但是虚拟机ping baidu.com 返回错误信息了，需要绑定DNS</p><p>vi /etc/resolv.conf （没有此文件新建一个即可）</p><p>nameserver 网关地址</p><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/6.png" class title="如图所示"><blockquote><p>链接：<a href="https://www.jianshu.com/p/6801da089cf2" target="_blank" rel="noopener">https://www.jianshu.com/p/6801da089cf2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker search报错解决方法</title>
      <link href="/2020/06/14/docker-search%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/14/docker-search%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ docker search sameersbn</span><br><span class="line">Error response from daemon: Get https:<span class="comment">//index.docker.io/v1/search?q=sameersbn&amp;n=25: dial tcp: lookup index.docker.io on 192.168.65.1:53: read udp 192.168.65.2:45190-&gt;192.168.65.1:53: i/o timeout</span></span><br></pre></td></tr></table></figure><p>解决方法:</p><p>通过dig @114.114.114.114 registry-1.docker.io找到可用ip</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ dig @<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span> registry-<span class="number">1</span>.docker.io</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG <span class="number">9.8</span><span class="number">.3</span>-P1 &lt;&lt;&gt;&gt; @<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span> registry-<span class="number">1</span>.docker.io</span><br><span class="line">; (<span class="number">1</span> server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: <span class="number">47220</span></span><br><span class="line">;; flags: qr rd ra; QUERY: <span class="number">1</span>, ANSWER: <span class="number">8</span>, AUTHORITY: <span class="number">4</span>, ADDITIONAL: <span class="number">9</span></span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: <span class="number">0</span>, flags:; udp: <span class="number">4096</span></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;registry-<span class="number">1</span>.docker.io.        IN    A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">54.164</span><span class="number">.230</span><span class="number">.151</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">35.169</span><span class="number">.231</span><span class="number">.249</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">34.205</span><span class="number">.207</span><span class="number">.96</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">34.200</span><span class="number">.28</span><span class="number">.105</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">52.204</span><span class="number">.202</span><span class="number">.231</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">54.152</span><span class="number">.209</span><span class="number">.167</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">52.22</span><span class="number">.181</span><span class="number">.254</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">52.54</span><span class="number">.216</span><span class="number">.153</span></span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">1827</span>.awsdns-<span class="number">36</span>.co.uk.</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">1168</span>.awsdns-<span class="number">18</span>.org.</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">513</span>.awsdns-<span class="number">00</span>.net.</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">421</span>.awsdns-<span class="number">52</span>.com.</span><br><span class="line"></span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">ns-<span class="number">421</span>.awsdns-<span class="number">52</span>.com.    <span class="number">148245</span>    IN    A    <span class="number">205.251</span><span class="number">.193</span><span class="number">.165</span></span><br><span class="line">ns-<span class="number">421</span>.awsdns-<span class="number">52</span>.com.    <span class="number">149402</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5301</span>:a500::<span class="number">1</span></span><br><span class="line">ns-<span class="number">513</span>.awsdns-<span class="number">00</span>.net.    <span class="number">149549</span>    IN    A    <span class="number">205.251</span><span class="number">.194</span><span class="number">.1</span></span><br><span class="line">ns-<span class="number">513</span>.awsdns-<span class="number">00</span>.net.    <span class="number">149549</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5302</span>:<span class="number">100</span>::<span class="number">1</span></span><br><span class="line">ns-<span class="number">1168</span>.awsdns-<span class="number">18</span>.org.    <span class="number">148917</span>    IN    A    <span class="number">205.251</span><span class="number">.196</span><span class="number">.144</span></span><br><span class="line">ns-<span class="number">1168</span>.awsdns-<span class="number">18</span>.org.    <span class="number">148917</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5304</span>:<span class="number">9000</span>::<span class="number">1</span></span><br><span class="line">ns-<span class="number">1827</span>.awsdns-<span class="number">36</span>.co.uk. <span class="number">148040</span>    IN    A    <span class="number">205.251</span><span class="number">.199</span><span class="number">.35</span></span><br><span class="line">ns-<span class="number">1827</span>.awsdns-<span class="number">36</span>.co.uk. <span class="number">148040</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5307</span>:<span class="number">2300</span>::<span class="number">1</span></span><br><span class="line"></span><br><span class="line">;; Query time: <span class="number">60</span> msec</span><br><span class="line">;; SERVER: 114.114.114.114#53(114.114.114.114)</span><br><span class="line">;; WHEN: Mon Aug <span class="number">20</span> <span class="number">22</span>:<span class="number">36</span>:<span class="number">29</span> <span class="number">2018</span></span><br><span class="line">;; MSG SIZE  rcvd: <span class="number">493</span></span><br></pre></td></tr></table></figure><p>尝试修改<code>/etc/hosts</code>强制<code>docker.io</code>相关的域名解析到其它可用IP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">54.164</span><span class="number">.230</span><span class="number">.151</span> registry-<span class="number">1</span>.docker.io</span><br></pre></td></tr></table></figure><p>保存后重试，成功！！</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker的安装和基本用法</title>
      <link href="/2020/06/14/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2020/06/14/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Centos安装命令"><a href="#Centos安装命令" class="headerlink" title="Centos安装命令"></a>Centos安装命令</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:<span class="comment">//get.docker.com | bash -s docker --mirror Aliyun</span></span><br></pre></td></tr></table></figure><h2 id="Docker基本用法"><a href="#Docker基本用法" class="headerlink" title="Docker基本用法"></a>Docker基本用法</h2><p>启动docker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>停止docker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p>docker搜索镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p>docker拉取镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull  mysql</span><br></pre></td></tr></table></figure><p>docker启动容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>查看正在运行容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>删除容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm id</span><br></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi id</span><br></pre></td></tr></table></figure><p>查看镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(行为型)</title>
      <link href="/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
      <url>/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CurrentConditionsDisplay implements Observer &#123;</span><br><span class="line">    public CurrentConditionsDisplay(Subject weatherData) &#123;</span><br><span class="line">        weatherData.registerObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(float temp) &#123;</span><br><span class="line">        System.out.println(&quot;Current temp: &quot;+temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StatisticsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">        weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Statistics temp: "</span>+temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            o.update(temperature);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">        CurrentConditionsDisplay currentConditionsDisplay = <span class="keyword">new</span></span><br><span class="line">                CurrentConditionsDisplay(weatherData);</span><br><span class="line">        StatisticsDisplay statisticsDisplay = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">0</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeOrTea</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        boil();</span><br><span class="line">        brew();</span><br><span class="line">        pour();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pour</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"boil"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">CaffeOrTea</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Coffee.brew"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">CaffeOrTea</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Tea.brew"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CaffeeOrTea c=<span class="keyword">new</span> Coffee();</span><br><span class="line">        c.prepare();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>定义一系列算法，封装每个算法，并使它们可以互换。</p><p>设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Quack!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gaga</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Gaga!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> QuackBehavior quackBehavior;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (quackBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">  quackBehavior.quack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.quackBehavior = quackBehavior;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Duck duck = <span class="keyword">new</span> Duck();</span><br><span class="line">    duck.setQuackBehavior(<span class="keyword">new</span> Squeak());</span><br><span class="line">    duck.performQuack();</span><br><span class="line">    duck.setQuackBehavior(<span class="keyword">new</span> Quack());</span><br><span class="line">    duck.performQuack();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(创建型)</title>
      <link href="/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
      <url>/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Ⅰ-懒汉式-线程不安全"><a href="#Ⅰ-懒汉式-线程不安全" class="headerlink" title="Ⅰ 懒汉式-线程不安全"></a>Ⅰ 懒汉式-线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton get <span class="title">uniqueInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅱ-饿汉式-线程安全"><a href="#Ⅱ-饿汉式-线程安全" class="headerlink" title="Ⅱ 饿汉式-线程安全"></a>Ⅱ 饿汉式-线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure><h2 id="Ⅲ-懒汉式-线程安全"><a href="#Ⅲ-懒汉式-线程安全" class="headerlink" title="Ⅲ 懒汉式-线程安全"></a>Ⅲ 懒汉式-线程安全</h2><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待,这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton get <span class="title">uniqueInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅳ-双重校验锁-线程安全"><a href="#Ⅳ-双重校验锁-线程安全" class="headerlink" title="Ⅳ 双重校验锁-线程安全"></a>Ⅳ 双重校验锁-线程安全</h2><p>第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了<br>加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实<br>是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址<br>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在<br>多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用<br>getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被<br>初始化。<br>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    s=<span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                                                                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅴ-静态内部类实现"><a href="#Ⅴ-静态内部类实现" class="headerlink" title="Ⅴ 静态内部类实现"></a>Ⅴ 静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE=<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来<br>实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">  Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// do something with the product</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂方法</p><p>多个工厂，一种抽象产品。例如一个麦当劳店，可以生产多种汉堡，一个肯德基店，也可以生产多种汉堡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">作者：冠状病毒biss</span><br><span class="line">链接：https:<span class="comment">//www.nowcoder.com/discuss/438905?type=all&amp;order=time&amp;pos=&amp;page=1&amp;channel=666&amp;source_id=search_all</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Hamburger <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCFactory</span> <span class="keyword">implements</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MCHamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCFactory</span> <span class="keyword">implements</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KFCHamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃麦当劳汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃肯德基汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HamburgerFactory mcFactory=<span class="keyword">new</span> MCFactory();</span><br><span class="line">    Hamburger hamburger=mcFactory.build();</span><br><span class="line">    hamburger.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>股票问题</title>
      <link href="/2020/06/13/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/06/13/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>股票问题（1）</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min=prices[<span class="number">0</span>],max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            max=Math.max(max,prices[i]-min);</span><br><span class="line">            min=Math.min(min,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>股票问题（2）</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="comment">//    能挣钱就卖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(prices[i]&gt;=prices[i-<span class="number">1</span>])</span><br><span class="line">          &#123;</span><br><span class="line">              ans+=(prices[i]-prices[i-<span class="number">1</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>股票问题 (3)</p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: [3,3,5,0,0,3,1,4]<br>输出: 6<br>解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        对于任意一天考虑四个变量:</span></span><br><span class="line"><span class="comment">        fstBuy: 在该天第一次买入股票可获得的最大收益 </span></span><br><span class="line"><span class="comment">        fstSell: 在该天第一次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secBuy: 在该天第二次买入股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secSell: 在该天第二次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        分别对四个变量进行相应的更新, 最后secSell就是最大</span></span><br><span class="line"><span class="comment">        收益值(secSell &gt;= fstSell)</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">int</span> fstBuy = Integer.MIN_VALUE, fstSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> secBuy = Integer.MIN_VALUE, secSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            fstBuy = Math.max(fstBuy, -p);</span><br><span class="line">            fstSell = Math.max(fstSell, fstBuy + p);</span><br><span class="line">            secBuy = Math.max(secBuy, fstSell - p);</span><br><span class="line">            secSell = Math.max(secSell, secBuy + p); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>股票(4)</p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: [2,4,1], k = 2<br>输出: 2<br>解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        当k大于等于数组长度一半时, 问题退化为贪心问题此时采用 买卖股票的最佳时机 II</span></span><br><span class="line"><span class="comment">        的贪心方法解决可以大幅提升时间性能, 对于其他的k, 可以采用 买卖股票的最佳时机 III</span></span><br><span class="line"><span class="comment">        的方法来解决, 在III中定义了两次买入和卖出时最大收益的变量, 在这里就是k租这样的</span></span><br><span class="line"><span class="comment">        变量, 即问题IV是对问题III的推广, t[i][0]和t[i][1]分别表示第i比交易买入和卖出时</span></span><br><span class="line"><span class="comment">        各自的最大收益</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= prices.length/<span class="number">2</span>) <span class="keyword">return</span> greedy(prices);</span><br><span class="line">        <span class="keyword">int</span>[][] t = <span class="keyword">new</span> <span class="keyword">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            t[i][<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            t[<span class="number">0</span>][<span class="number">0</span>] = Math.max(t[<span class="number">0</span>][<span class="number">0</span>], -p);</span><br><span class="line">            t[<span class="number">0</span>][<span class="number">1</span>] = Math.max(t[<span class="number">0</span>][<span class="number">1</span>], t[<span class="number">0</span>][<span class="number">0</span>] + p);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                t[i][<span class="number">0</span>] = Math.max(t[i][<span class="number">0</span>], t[i-<span class="number">1</span>][<span class="number">1</span>] - p);</span><br><span class="line">                t[i][<span class="number">1</span>] = Math.max(t[i][<span class="number">1</span>], t[i][<span class="number">0</span>] + p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t[k-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>])</span><br><span class="line">                max += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/2020/05/31/ArrayList/"/>
      <url>/2020/05/31/ArrayList/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>[TOC]</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>需要使用 grow() 方法进行扩容，新容量的大小为 oldCapacity + (oldCapacity &gt;&gt; 1) ，也就是旧容量的 1.5 倍。<br>扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建<br>ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">      &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">      int oldCapacity &#x3D; elementData.length;</span><br><span class="line">      int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">      if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">          newCapacity &#x3D; minCapacity;</span><br><span class="line">      if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">          newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">      &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">      elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看<br>出 ArrayList 删除元素的代价是非常高的。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行<br>序列化。<br>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData; &#x2F;&#x2F; non-private to simplify nested class access</span><br></pre></td></tr></table></figure><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p><h2 id="与Vector比较"><a href="#与Vector比较" class="headerlink" title="与Vector比较"></a>与Vector比较</h2><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean add(E e) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + 1);</span><br><span class="line">    elementData[elementCount++] &#x3D; e;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized E get(int index) &#123;</span><br><span class="line">    if (index &gt;&#x3D; elementCount)</span><br><span class="line">    throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 ArrayList的比较</p><p>①Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步<br>操作完全可以由程序员自己来控制；<br>②Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</p><h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><h3 id="synchronizedList"><a href="#synchronizedList" class="headerlink" title="synchronizedList"></a>synchronizedList</h3><p>在SynchronizedList内部维护了一个普通对象Collection，还有排斥锁mutex.创建出synchronizedList之后，再操作List的时候，就会对方法上锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; synList &#x3D; Collections.synchronizedList(arrayList);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.add(e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.remove(o);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean containsAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.containsAll(coll);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; coll) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.addAll(coll);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean removeAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.removeAll(coll);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean retainAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.retainAll(coll);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">    synchronized (mutex) &#123;c.clear();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。<br>写操作需要加锁，防止并发写入时导致写入数据丢失。<br>写操作结束之后需要把原始数组指向新的复制数组。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：<br>①内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；<br>②数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。<br>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>底层<strong>通过双向链表实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个链表存储了 first 和 last 指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h3 id="与-ArrayList-的比较"><a href="#与-ArrayList-的比较" class="headerlink" title="与 ArrayList 的比较"></a>与 ArrayList 的比较</h3><ol><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h3 id="3-1-先从-ArrayList-的构造函数说起"><a href="#3-1-先从-ArrayList-的构造函数说起" class="headerlink" title="3.1. 先从 ArrayList 的构造函数说起"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_31-先从-arraylist-的构造函数说起" target="_blank" rel="noopener">3.1. 先从 ArrayList 的构造函数说起</a></h3><p><strong>ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">            <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">            <span class="comment">//创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">    *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p><h3 id="3-2-一步一步分析-ArrayList-扩容机制"><a href="#3-2-一步一步分析-ArrayList-扩容机制" class="headerlink" title="3.2. 一步一步分析 ArrayList 扩容机制"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_32-一步一步分析-arraylist-扩容机制" target="_blank" rel="noopener">3.2. 一步一步分析 ArrayList 扩容机制</a></h3><p>这里以无参构造函数创建的 ArrayList 为例分析</p><h4 id="3-2-1-先来看-add-方法"><a href="#3-2-1-先来看-add-方法" class="headerlink" title="3.2.1. 先来看 add 方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_321-先来看-add-方法" target="_blank" rel="noopener">3.2.1. 先来看 <code>add</code> 方法</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h4 id="3-2-2-再来看看-ensureCapacityInternal-方法"><a href="#3-2-2-再来看看-ensureCapacityInternal-方法" class="headerlink" title="3.2.2. 再来看看 ensureCapacityInternal() 方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_322-再来看看-ensurecapacityinternal-方法" target="_blank" rel="noopener">3.2.2. 再来看看 <code>ensureCapacityInternal()</code> 方法</a></h4><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p><h4 id="3-2-3-ensureExplicitCapacity-方法"><a href="#3-2-3-ensureExplicitCapacity-方法" class="headerlink" title="3.2.3. ensureExplicitCapacity() 方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_323-ensureexplicitcapacity-方法" target="_blank" rel="noopener">3.2.3. <code>ensureExplicitCapacity()</code> 方法</a></h4><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>我们来仔细分析一下：</p><ul><li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><h4 id="3-2-4-grow-方法"><a href="#3-2-4-grow-方法" class="headerlink" title="3.2.4. grow() 方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_324-grow-方法" target="_blank" rel="noopener">3.2.4. <code>grow()</code> 方法</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p><ul><li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li><li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li><li>以此类推······</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h4 id="3-2-5-hugeCapacity-方法。"><a href="#3-2-5-hugeCapacity-方法。" class="headerlink" title="3.2.5. hugeCapacity() 方法。"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_325-hugecapacity-方法。" target="_blank" rel="noopener">3.2.5. <code>hugeCapacity()</code> 方法。</a></h4><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="3-3-System-arraycopy-和-Arrays-copyOf-方法"><a href="#3-3-System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="3.3. System.arraycopy() 和 Arrays.copyOf()方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_33-systemarraycopy-和-arrayscopyof方法" target="_blank" rel="noopener">3.3. <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</a></h3><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p><h4 id="3-3-1-System-arraycopy-方法"><a href="#3-3-1-System-arraycopy-方法" class="headerlink" title="3.3.1. System.arraycopy() 方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_331-systemarraycopy-方法" target="_blank" rel="noopener">3.3.1. <code>System.arraycopy()</code> 方法</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>我们写一个简单的方法测试以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraycopyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        System.arraycopy(a, <span class="number">2</span>, a, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        a[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 99 2 3 0 0 0 0 0Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="3-3-2-Arrays-copyOf-方法"><a href="#3-3-2-Arrays-copyOf-方法" class="headerlink" title="3.3.2. Arrays.copyOf()方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_332-arrayscopyof方法" target="_blank" rel="noopener">3.3.2. <code>Arrays.copyOf()</code>方法</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"> <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayscopyOfTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] b = Arrays.copyOf(a, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"b.length"</span>+b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="3-3-3-两者联系和区别"><a href="#3-3-3-两者联系和区别" class="headerlink" title="3.3.3. 两者联系和区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_333-两者联系和区别" target="_blank" rel="noopener">3.3.3. 两者联系和区别</a></h4><p><strong>联系：</strong></p><p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong></p><p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h3 id="3-4-ensureCapacity方法"><a href="#3-4-ensureCapacity方法" class="headerlink" title="3.4. ensureCapacity方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_34-ensurecapacity方法" target="_blank" rel="noopener">3.4. <code>ensureCapacity</code>方法</a></h3><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p><p>我们通过下面的代码实际测试以下这个方法的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnsureCapacityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"使用ensureCapacity方法前："</span>+(endTime - startTime));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">使用ensureCapacity方法前：2158Copy to clipboardErrorCopied</span><br><span class="line">public class EnsureCapacityTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list &#x3D; new ArrayList&lt;Object&gt;();</span><br><span class="line">        final int N &#x3D; 10000000;</span><br><span class="line">        list &#x3D; new ArrayList&lt;Object&gt;();</span><br><span class="line">        long startTime1 &#x3D; System.currentTimeMillis();</span><br><span class="line">        list.ensureCapacity(N);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime1 &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;使用ensureCapacity方法后：&quot;+(endTime1 - startTime1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用ensureCapacity方法前：1773Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机面试问题</title>
      <link href="/2020/05/31/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/2020/05/31/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-各个垃圾回收器有什么区别？"><a href="#1-各个垃圾回收器有什么区别？" class="headerlink" title="1.各个垃圾回收器有什么区别？"></a>1.各个垃圾回收器有什么区别？</h2><h2 id="2-什么情况下会Stop-The-World？"><a href="#2-什么情况下会Stop-The-World？" class="headerlink" title="2.什么情况下会Stop The World？"></a>2.什么情况下会Stop The World？</h2><h2 id="3-G1和CMS的区别？"><a href="#3-G1和CMS的区别？" class="headerlink" title="3.G1和CMS的区别？"></a>3.G1和CMS的区别？</h2><h2 id="4-什么时候会STOP-THE-WORLD？"><a href="#4-什么时候会STOP-THE-WORLD？" class="headerlink" title="4.什么时候会STOP THE WORLD？"></a>4.什么时候会STOP THE WORLD？</h2>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型(一)</title>
      <link href="/2020/05/30/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/05/30/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-内存模型的定义"><a href="#1-内存模型的定义" class="headerlink" title="1.内存模型的定义"></a>1.内存模型的定义</h2><p>Java 内存模型试图来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，又在CPU里加了好几层高速缓存。</p><p>在Java内存模型里，对上述的优化又进行了一些抽象。JMM规定所有变量都是存在主存中的，每个线程又包含自己的工作内存，也就是CPU上的寄存器或者高速缓存。所以线程的操作都只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</p><img src="/2020/05/30/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/JMM.png" class title="this is} ## 2.内存间交互操作 {% asset_img 1.png 操作"><p>read：把一个变量的值从主内存传输到工作内存中<br>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中<br>use：把工作内存中一个变量的值传递给执行引擎<br>assign：把一个从执行引擎接收到的值赋给工作内存的变量<br>store：把工作内存的一个变量的值传送到主内存中<br>write：在 store 之后执行，把 store 得到的值放入主内存的变量中<br>lock：作用于主内存的变量<br>unlock</p><h2 id="3-内存模型三大特性"><a href="#3-内存模型三大特性" class="headerlink" title="3.内存模型三大特性"></a>3.内存模型三大特性</h2><p>1.原子性：</p><p><strong>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。</strong></p><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int<br>类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的<br>64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以<br>不具备原子性。</p><p>2.可见性</p><p><strong>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。</strong>Java 内存模型是通过在变量修改后将新<br>值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引<br>用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><p>3.有序性</p><p>有序性是指：<strong>在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因</strong><br><strong>为发生了指令重排序。</strong>在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程<br>程序的执行，却会影响到多线程并发执行的正确性。<br>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test1</title>
      <link href="/2020/05/25/test1/"/>
      <url>/2020/05/25/test1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> hexo相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/05/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/05/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>##第一章</p><p>内容</p><hr><p>##第二章</p><p>##<a href="https://blog.csdn.net/xjm850552586/article/details/84101345?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/25/hello-world/"/>
      <url>/2020/05/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
