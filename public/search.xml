<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>流量控制</title>
      <link href="/2021/02/08/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
      <url>/2021/02/08/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>TCP的流量控制有两种方式：</strong><ul><li><strong>一种是基于速率流量的控制</strong></li><li><strong>一种是基于滑动窗口的流量控制</strong></li></ul></li></ul><h1 id="一、基于速率流量的控制"><a href="#一、基于速率流量的控制" class="headerlink" title="一、基于速率流量的控制"></a>一、<strong>基于速率流量的控制</strong></h1><ul><li><strong>这种方式比较简单：</strong>它是给发送方指定某个速率，同时确保数据永远不能超过这个速率发送</li><li>这种类型的流量控制最<strong><em>\</em>适合流应用程序**</strong>，可被用于广播和组播发现</li></ul><h1 id="二、基于滑动窗口的流量控制"><a href="#二、基于滑动窗口的流量控制" class="headerlink" title="二、基于滑动窗口的流量控制"></a>二、<strong>基于滑动窗口的流量控制</strong></h1><ul><li><strong>详情还可以参阅：</strong><ul><li><a href="https://blog.csdn.net/qq_41453285/article/details/104014872" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/104014872</a></li><li><a href="https://blog.csdn.net/qq_41453285/article/details/104131897" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/104131897</a></li></ul></li><li>TCP通信双方各自都有一个<strong>发送窗口和接收窗口</strong></li><li>发送窗口的大小是由对方接收窗口来决定的，接收窗口用于给对方一个指示（表示自己还有多少可用的缓存空间来接收数据）</li></ul><blockquote><h3 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h3><ul><li><strong>发送窗口主要分为4部分：</strong><ul><li>已发送的并确认的</li><li>已经发送的但是还未确认的</li><li>即将发送的</li><li>不允许发送的</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200203161302611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><blockquote><h3 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h3><ul><li><strong>发送窗口主要分为3部分：</strong><ul><li>已接收的并确认的</li><li>未接收的但是准备接收的</li><li>不能接收的</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200203162455115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><ul><li><strong>基于滑动窗口的流量控制大致流程为：</strong><ul><li>接收端在接收到数据之后会给发送端发送一个ACK（TCP报文），ACK的IP头部中有一个窗口大小字段（见下图的IP头部图），这个大小字段表明接收端自己可用的缓冲大小</li><li>当发送端接收到接收端的ACK之后会获取IP头部中的窗口大小，从而知道接收端的数据缓冲区大小</li><li>之后发送数据使就会受到这个缓冲区大小的限制</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200805182136447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><h1 id="三、附加链接"><a href="#三、附加链接" class="headerlink" title="三、附加链接"></a>三、附加链接</h1><ul><li><a href="https://blog.csdn.net/qq_41453285/article/details/104121395" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/104121395</a></li><li><a href="https://blog.csdn.net/qq_41453285/article/details/104121538" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/104121538</a></li><li><a href="https://blog.csdn.net/qq_41453285/article/details/104131897" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/104131897</a></li><li><a href="https://blog.csdn.net/qq_41453285/article/details/104158540" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/104158540</a></li><li><a href="https://blog.csdn.net/qq_41453285/article/details/104201901" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/104201901</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟地址、逻辑地址、线性地址、物理地址</title>
      <link href="/2021/02/08/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E3%80%81%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/"/>
      <url>/2021/02/08/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E3%80%81%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><ul><li><p>Linux系统中的物理存储空间和虚拟存储空间的地址范围分别都是从0x00000000到0xFFFFFFFF，共4GB，但物理存储空间与虚拟存储空间布局完全不同</p></li><li><p><strong><em>\</em>Linux运行在虚拟存储空间，**</strong>并负责把系统中实际存在的远小于4GB的物理内存根据不同需求映射到整个4GB的虚拟存储空间中</p></li><li><p>Linux主要工作在保护模式下。</p><p><strong>80X86从逻辑地址到物理地址变换中经过了两个阶段：</strong></p><ul><li>第一阶段使用<strong>分段机制把程序的逻辑地址变换成处理器可寻址内存空间（称为线性地址空间）中的地址</strong></li><li>第二阶段的<strong>分页机制把线性地址转换成物理地址</strong></li></ul></li><li><p><strong>第一阶段的分段变换机制是必须使用的，但是第二阶段的分页机制是可选择的</strong>。如果没有开启分页机制，那么分段机制产生的线性地址空间就直接映射到处理器的物理地址空间上。进行研究之前，一定要对概念定义非常清晰，不能混淆</p></li></ul><h1 id="一、虚拟地址"><a href="#一、虚拟地址" class="headerlink" title="一、虚拟地址"></a>一、虚拟地址</h1><ul><li>指的是由<strong><em>\</em>程序产生的由段选择符和段内偏移地址两个部分组成的地址**</strong></li><li>为什么叫它是虚拟的地址呢？因为这两部分组成的地址并没有直接访问物理内存，而是要通过<strong>分段地址</strong>的变换机构处理或映射后才会对应到相应的物理内存地址</li></ul><h1 id="二、逻辑地址"><a href="#二、逻辑地址" class="headerlink" title="二、逻辑地址"></a>二、逻辑地址</h1><ul><li><strong>指由程序产生的与段相关的偏移地址部分</strong>，每一个逻辑地址都<strong><em>\</em>由一个段和偏移量组成**</strong></li><li>在进行C语言指针编程中，可以<strong><em>\</em>读取指针变量本身值(&amp;操作)，实际上这个值就是逻辑地址**</strong></li><li>它是相对于你当前进程数据段的地址，不和绝对物理地址相干。只有在Intel实模式下，逻辑地址才和物理地址相等（因为实模式没有分段或分页机制,Cpu不进行自动地址转换）；逻辑也就是在Intel 保护模式下程序执行代码段限长内的偏移地址（假定代码段、数据段如果完全一样）</li></ul><h1 id="三、线性地址"><a href="#三、线性地址" class="headerlink" title="三、线性地址"></a>三、线性地址</h1><ul><li><strong>是逻辑地址到物理地址变换之间的中间层</strong></li><li>程序代码<strong><em>\</em>会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址**</strong></li><li><strong>如果启用了分页机制，</strong>那么线性地址可以再经变换以产生一个物理地址。<strong><em>\</em>若没有启用分页机制，**</strong>那么线性地址直接就是物理地址</li></ul><h1 id="四、物理地址"><a href="#四、物理地址" class="headerlink" title="四、物理地址"></a>四、物理地址</h1><ul><li>指的是现在 CPU 外部地址总线上的寻址物理内存的地址信号，<strong><em>\</em>是地址变换的最终结果**</strong></li></ul><h1 id="五、虚拟地址如何转换为物理地址"><a href="#五、虚拟地址如何转换为物理地址" class="headerlink" title="五、虚拟地址如何转换为物理地址"></a>五、虚拟地址如何转换为物理地址</h1><ul><li><strong>第一步，先将虚拟地址转换为逻辑地址：</strong>根据程序中的虚拟地址得出其所在的段，然后加上段偏移，我们就能得到一个逻辑地址</li><li><strong>第二步，再将逻辑地址转换为线型地址：</strong>有了逻辑地址之后，我们需要将逻辑地址转换为线型地址（因为线型地址是逻辑地址转换到物理地址的一个中间层），只需要把逻辑地址加上段的基地址就能生成一个线型地址</li><li><strong>第三步，再将线型地址再转换为物理地址：</strong><ul><li>如果启用了分页机制，那么就需要将需要找到段中对应页的地址，然后再找到页内偏移地址，最后得到物理地址</li><li>如果没有启用分页机制，那么线型地址直接就是物理地址了</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BBR是怎么实现的</title>
      <link href="/2021/02/08/BBR%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
      <url>/2021/02/08/BBR%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00.前言"></a>0x00.前言</h2><p>这是TCP/IP协议栈系列的第三篇文章，之前的一篇<strong><a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1MzYzMTI2Ng%3D%3D%26mid%3D2247484387%26idx%3D1%26sn%3D6ddcf24e16e1e363ff696bed6b8184a8%26scene%3D21%23wechat_redirect">面试热点|理解TCP/IP传输层拥塞控制算法</a></strong>讲述了传统的拥塞控制算法基本原理，今天一起来学习下最新Linux内核中增加的拥塞控制算法：<strong>TCP BBR算法。</strong></p><p>鉴于TCP拥塞控制算法背后有一套复杂的数学理论和控制策略，因此本文也只能是<strong>浅谈</strong>，通过本文你将了解到以下内容(温馨提示：文章较长需要一些耐心，也可以先收藏再阅读)：</p><ul><li>回顾传统拥塞控制算法</li><li>TCP BBR算法的概况</li><li>BBR算法的原理简介</li></ul><h2 id="0x01-拥塞控制简史"><a href="#0x01-拥塞控制简史" class="headerlink" title="0x01. 拥塞控制简史"></a>0x01. 拥塞控制简史</h2><p>大约在1988年之前TCP/IP是没有拥塞控制的，但是随着网络接入规模的发展之前仅有的端到端窗口控制已经无法满足要求，在1986年引发大规模网络瘫痪，此时就要提到一个重量级人物：Van Jacobson范·雅各布森。</p><p>这位力挽狂澜的人物入选了<strong>计算机名人堂Internet Hall of Fame</strong>，Van Jacobson大神提出并设计实施了TCP/IP拥塞控制，解决了当时最大的问题，来简单看下Van Jacobson的维基百科简介(<strong>笔者做了部分删减</strong>)：</p><blockquote><p>范·雅各布森Van Jacobson是目前作为互联网技术基础的TCP/IP协议栈的主要起草者，他以其在网络性能的提升和优化的开创性成就而闻名。<br>2006年8月，他加入了帕洛阿尔托研究中心担任研究员，并在位于相邻的施乐建筑群的Packet Design公司担任首席科学家。在此之前，他曾是思科系统公司首席科学家，并在位于劳伦斯伯克利国家实验室的网络研究小组任领导者。<br>范·雅各布森因为在提高IP网络性能提升和优化所作的工作而为人们所知，1988到1989年间，他重新设计了TCP/IP的流控制算法（Jacobson算法），他因设计了RFC 1144中的TCP/IP头压缩协议即范·雅各布森TCP/IP头压缩协议而广为人知。此外他也曾与他人合作设计了一些被广泛使用的网络诊断工具，如traceroute，pathchar以及tcpdump 。<br>范·雅各布森于2012年4月入选第一批计算机名人堂，计算机名人堂简介：<a href="https://link.zhihu.com/?target=https%3A//www.internethalloffame.org/inductees/van-jacobson">www.internethalloffame.org/inductees/v…</a></p></blockquote><p>如图为Van Jacobson计算机名人堂的简介：</p><p><img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0dfdd6839b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>笔者找了Van Jacobson和Michael J. Karels在1988年11月发布的关于拥塞避免和控制的论文，总计25页，感兴趣的读者可以查阅：</p><blockquote><p><a href="https://link.zhihu.com/?target=https%3A//ee.lbl.gov/papers/congavoid.pdf">ee.lbl.gov/papers/cong…</a></p></blockquote><p>我们常用的tracetoute和tcpdump也是van-jacobson大神的杰作，作为互联网时代的受益者不由得对这些互联网发展早期做出巨大贡献的开拓者、创新者、变革者心生赞叹和敬意。</p><h2 id="0x02-传统拥塞控制算法回顾"><a href="#0x02-传统拥塞控制算法回顾" class="headerlink" title="0x02.传统拥塞控制算法回顾"></a>0x02.传统拥塞控制算法回顾</h2><h3 id="2-1-算法目的"><a href="#2-1-算法目的" class="headerlink" title="2.1 算法目的"></a>2.1 算法目的</h3><p>看到一篇文章说到TCP 传输层拥塞控制算法并不是简单的计算机网络的概念，也属于控制论范畴，感觉这个观点很道理。</p><p>TCP拥塞控制算法的目的可以简单概括为：公平竞争、充分利用网络带宽、降低网络延时、优化用户体验，然而就目前而言要实现这些目标就难免有权衡和取舍。</p><p>但是现在的网络通信基础设施水平一直在飞速提高，相信在未来的某个时间点这些目标都可以达到，小孩子才选择，我们大人全都要！</p><h3 id="2-2-算法分类"><a href="#2-2-算法分类" class="headerlink" title="2.2 算法分类"></a>2.2 算法分类</h3><p>在理解拥塞控制算法之前我们需要明确一个核心的思想：<strong>闻道有先后 术业有专攻</strong>，笔者觉得这是一个非常重要的共识问题，把A踩在泥土里，把B吹捧到天上去，都不是很好的做法。</p><p>实际的网络环境十分复杂并且变化很快，并没有哪个拥塞控制算法可以全部搞定，每一种算法都有自己的特定和适用领域，每种算法都是对几个关键点的权衡，在无法兼得的条件下有的算法选择带宽利用率，有的算法选择通信延时等等。</p><p>在明确这个<strong>共识问题</strong>之后，我们对待各个拥塞控制算法的态度要平和一些，不要偏激地认为谁就是最好，几十年前的网络状况和现在是截然不同的，我们永远都是站在巨人的肩膀之上的，这也是科学和文明进步的推动力。</p><p>传统拥塞控制算法并不是一蹴而就的，复杂的网络环境和用户的高要求推动着拥塞控制算法的优化和迭代，我们看下<strong>基于丢包策略</strong>的传统拥塞控制算法的几个迭代版本，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0dfddc157d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>与此同时还有一类算法是<strong>基于RTT延时策略</strong>来进行控制的，但是这类算法在发包速率上可能不够激进，竞争性能不如其他算法，因此在共享网络带宽时有失公平性，但是算法速率曲线却是很平滑，我们暂且把这类算法当做君子吧！</p><p><img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0dff68fe1c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>其中比较有名的Vegas算法是大约在1995年由亚利桑那大学的研究人员拉里·彼得森和劳伦斯·布拉科夫提出，这个新的TCP拥塞算法以内华达州最大的城市拉斯维加斯命名，后成为TCP Vegas算法。</p><p>关于基于RTT的TCP Vegas算法的详细介绍可以查阅文档：</p><blockquote><p><a href="https://link.zhihu.com/?target=http%3A//www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf">www.cs.cmu.edu/~srini/15-7…</a></p></blockquote><p>文档对Vegas算法和New Reno做了一些对比，我们从直观图形上可以看到Vegas算法更加平滑，相反New Reno则表现除了较大的波动呈锯齿状，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0dff6b9d54?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>实际上还有更细粒度的分类，由于不是今天的重点，就不再深入展开了，当前使用的拥塞控制算法还是基于丢包Loss-Based作为主流。</p><h3 id="2-3-算法原则"><a href="#2-3-算法原则" class="headerlink" title="2.3 算法原则"></a>2.3 算法原则</h3><p>我们知道在网络链路中连接的数量是动态变化且数量巨大的，每一条连接都面临着一个黑盒子式的网络环境，这并不像我们平时出行时看看地图就知道哪里堵了，为了维护一个好的网络环境，每一条连接都需要遵守一些约定。</p><p>如果连接端都无所顾忌地发生数据包，那么网络链路很快就到了瓶颈了，数据通信完全无法保障，所以要到达一个稳定高效的网络环境还是需要费很大心思的，这其中有两个重要的概念：公平性和收敛性。</p><p>说来惭愧笔者在网络上找了很多资料去理解TCP拥塞控制的公平性和收敛性，但是仍然没有获得一个很好的权威解释，所以只能结合一些资料和自身的理解去阐述所谓的公平性和收敛性。</p><p>笔者认为公平性是相对于网络链路中的所有连接而言的，这些共享链路的连接启动和结束的时间不同，在实际的交互过程中每条连接占有带宽的机会是均等的，并且由于带宽限制连接双方通信的数据量是动态调整并且近似收敛于某个值，也就是呈现一个锯齿状或者更加平滑的波动曲线，对于基于丢包的拥塞控制算法而言<strong>AIMD线性增乘性减</strong>策略起了关键控制作用。</p><p>接下来我们来重点看下AIMD特性，先来贴一张经典的图，直观看AIMD的过程：</p><p><img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0dfed8ad14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>看看维基百科对于AIMD的定义：</p><blockquote><p>The additive-increase/multiplicative-decrease(AIMD) algorithm is a feedback control algorithm best known for its use in TCP congestion control.<br>AIMD combines linear growth of the congestion window with an exponential reduction when congestion is detected.<br>Multiple flows using AIMD congestion control will eventually converge to use equal amounts of a shared link.<br>The related schemes of multiplicative-increase/multiplicative-decrease (MIMD) and additive-increase/additive-decrease (AIAD) do not reach stability.</p></blockquote><p>简单翻译一下：线性增加乘性减少算法是一个反馈控制算法，因其在TCP拥塞控制中的使用而广为人知，AIMD将线性增加拥塞窗口和拥塞时乘性减少窗口相结合，基于AIMD的多个连接理想状态下会达到最终收敛，共享相同数量的网络带宽，与其相关的乘性增乘性减MIMD策略和增性加增性减少AIAD都无法保证稳定性。</p><p>AIMD相比MIMD和AIAD在连接进入拥塞避免阶段使用试探线性加策略而不是乘性加策略更加安全，在探测丢包时则大幅度乘性减少到1/2这样对于缓解拥塞会有比较好的效果更加快速，相反如果探测到丢包时采用线性减少AD可能拥塞持续的时间会更长，总体来说AIMD算是一个比较简单实用的工程版本的反馈控制，也具备可工程收敛性，因而被广泛实用。</p><h3 id="2-4-弱网络环境下的AIMD"><a href="#2-4-弱网络环境下的AIMD" class="headerlink" title="2.4 弱网络环境下的AIMD"></a>2.4 弱网络环境下的AIMD</h3><p>时间拉回20多年前，在互联网早期几乎所有的设备都是通过有线网络进行连接通信的，这也是拥塞控制在设计之后一直都起到不错作用的重要因素，有线连接的网络稳定性比较好，因此把丢包作为网络拥堵的一个特征也很正常。</p><p>再拉回到现在，从2010年之后移动互联网蓬勃发展，移动终端的持有量已经可以称为海量，无线网络的引入让网络环境变得更加复杂，因此不稳定丢包变得更加频繁，但是这时的丢包就不一定是网络拥堵造成的了，因为整个数据包经过多重路由、交换机、基站等基础通信设备每个环节都可能发生异常。</p><p>在弱网环境下，尤其是移动互联网中之前的基于AIMD的拥塞控制策略可能会由于丢包的出现而大幅降低网络吞吐量，从而对网络带宽的利用率也大大下降，这时我们采用更加激进的控制策略，或许可以获得更好的效果和用户体验。</p><p>恶意丢包的情况下，基于AIMD的拥塞控制确实就相当于被限速了，因为AIMD确实有些保守谨慎了，这个其实也很好理解的哈。</p><p>我们都知道在移动网络环境下是由终端以无线形式和附近的基站交互数据，之后数据传输至核心网，最后落到具体的服务器所在的有线网络，其中最后一公里的区域属于高延时场景，有线网络属于低延时高带宽场景。</p><p>在国外有相关实验证明弱网环境下RTT的变化对于使用传统拥塞控制算法下网络吞吐量的影响，数据和曲线如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0dff85e223?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>  <img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0e23b09984?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>实验含义</strong>：RTT的增大影响了比如CUBIC这类拥塞控制算法的慢启动等阶段，我们知道慢启动阶段每经过1个RTT周期拥塞窗口cwnd将加倍，但是更大的RTT就意味着发送方以很低的速率发送数据，更多的时间是空闲的，发包的加速度极大将低了，所以整个吞吐量就下降很明显。</p><p>看下实验者的原文表述：</p><blockquote><p>The delay before acknowledgment packets are received (= latency) will have an impact on how fast the TCP congestion window increases (hence the throughput).<br>When latency is high, it means that the sender spends more time idle (not sending any new packets), which reduces how fast throughput grows.</p></blockquote><h2 id="0x03-TCP-BBR算法简介"><a href="#0x03-TCP-BBR算法简介" class="headerlink" title="0x03 TCP BBR算法简介"></a>0x03 TCP BBR算法简介</h2><p>BBR算法是个主动的闭环反馈系统，通俗来说就是根据带宽和RTT延时来不断动态探索寻找合适的发送速率和发送量。</p><p>看下维基百科对BBR算法的说明和资料：</p><blockquote><p>相关文献：<a href="https://link.zhihu.com/?target=https%3A//queue.acm.org/detail.cfm%3Fid%3D3022184">queue.acm.org/detail.cfm?…</a><br>TCP BBR(Bottleneck Bandwidth and Round-trip propagation time)是由Google设计，并于2016年发布的拥塞算法，以往大部分拥塞算法是基于丢包来作为降低传输速率的信号，而BBR基于模型主动探测。<br>该算法使用网络最近出站数据分组当时的最大带宽和往返时间来创建网络的显式模型。数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。<br>该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法例如CUBIC。Google在YouTube上应用该算法，将全球平均的YouTube网络吞吐量提高了4%，在一些国家超过了14%。BBR之后移植入Linux内核4.9版本，并且对于QUIC可用。</p></blockquote><h3 id="3-1-基于丢包反馈策略可能在的问题"><a href="#3-1-基于丢包反馈策略可能在的问题" class="headerlink" title="3.1 基于丢包反馈策略可能在的问题"></a>3.1 基于丢包反馈策略可能在的问题</h3><p>基于丢包反馈属于被动式机制，根源在于这些拥塞控制算法依据是否出现丢包事件来判断网络拥塞做减窗调整，这样就可能会出现一些问题：</p><ul><li><strong>丢包即拥塞</strong><br>现实中网络环境很复杂会存在错误丢包，很多算法无法很好区分拥塞丢包和错误丢包，因此在存在一定错误丢包的前提下在某些网络场景中并不能充分利用带宽。</li><li><strong>缓冲区膨胀问题BufferBloat</strong><br>网络连接中路由器、交换机、核心网设备等等为了平滑网络波动而存在缓冲区，这些缓存区就像输液管的膨胀部分让数据更加平稳，但是Loss-Based策略在最初就像网络中发生数据类似于灌水，此时是将Buffer全部算在内的，一旦buffer满了，就可能出现RTT增加丢包等问题，就相当于有的容量本不该算在其中，但是策略是基于包含Buffer进行预测的，特别地在深缓冲区网络就会出现一些问题。</li><li><strong>网络负载高但无丢包事件</strong><br>假设网络中的负载已经很高了，只要没有丢包事件出现，算法就不会主动减窗降低发送速率，这种情况下虽然充分利用了网络带宽，同时由于一直没有丢包事件出现发送方仍然在加窗，表现出了较强的网络带宽侵略性，加重了网络负载压力。</li><li><strong>高负载丢包</strong><br>高负载无丢包情况下算法一直加窗，这样可以预测丢包事件可能很快就出现了，一旦丢包出现窗口将呈现乘性减少，由高位发送速率迅速降低会造成整个网络的瞬时抖动性，总体呈现较大的锯齿状波动。</li><li><strong>低负载高延时丢包</strong><br>在某些弱网环境下RTT会增加甚至出现非拥塞引起丢包，此时基于丢包反馈的拥塞算法的窗口会比较小，对带宽的利用率很低，吞吐量下降很明显，但是实际上网络负载并不高，所以在弱网环境下效果并不是非常理想。</li></ul><h3 id="3-2-TCP-BBR算法基本原理"><a href="#3-2-TCP-BBR算法基本原理" class="headerlink" title="3.2 TCP BBR算法基本原理"></a>3.2 TCP BBR算法基本原理</h3><p>前面我们提到了一些Loss-Based算法存在的问题，TCP BBR算法是一种主动式机制，简单来说BBR算法不再基于丢包判断并且也不再使用AIMD线性增乘性减策略来维护拥塞窗口，而是分别采样估计极大带宽和极小延时，并用二者乘积作为发送窗口，并且BBR引入了Pacing Rate限制数据发送速率，配合cwnd使用来降低冲击。</p><h3 id="3-2-1-一些术语"><a href="#3-2-1-一些术语" class="headerlink" title="3.2.1 一些术语"></a>3.2.1 一些术语</h3><ul><li><strong>BDP</strong>BDP是Bandwidth-Delay Product的缩写，可以翻译为带宽延时积，我们知道带宽的单位是bps(bit per second)，延时的单位是s，这样BDP的量纲单位就是bit，从而我们知道BDP就是衡量一段时间内链路的数据量的指标。这个可以形象理解为<strong>水管灌水</strong>问题，带宽就是水管的水流速度立方米/s，延时就是灌水时间单位s，二者乘积我们就可以知道当前水管内存储的水量了，这是BBR算法的一个关键指标，来看一张陶辉大神文章中的图以及一些网络场景中的BDP计算：</li></ul><p>​              <img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0e22a329d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li><strong>长肥网络</strong><br>我们把具有长RTT往返时间和高带宽的网络成为长肥网络或者长肥管道，它的带宽延时积BDP很大大，这种网络理论上吞吐量很大也是研究的重点。</li><li><strong>TCP Pacing机制</strong><br>可以简单地理解TCP Pacing机制就是将拥塞控制中数据包的做平滑发送处理，避免数据的突发降低网络抖动。</li></ul><h3 id="3-2-2-带宽和延时的测量"><a href="#3-2-2-带宽和延时的测量" class="headerlink" title="3.2.2 带宽和延时的测量"></a>3.2.2 带宽和延时的测量</h3><p>BBR算法的一些思想在之前的基于延时的拥塞控制算法中也有出现，其中必有有名的是TCP WestWood算法。</p><blockquote><p>TCP Westwood改良自New Reno，不同于以往其他拥塞控制算法使用丢失来测量，其通过对确认包测量来确定一个合适的发送速度，并以此调整拥塞窗口和慢启动阈值。其改良了慢启动阶段算法为敏捷探测和设计了一种持续探测拥塞窗口的方法来控制进入敏捷探测，使链接尽可能地使用更多的带宽。</p></blockquote><p>TCP WestWood算法也是基于带宽和延时乘积进行设计的，但是带宽和延时两个指标无法同时测量，因为这两个值是有些矛盾的极值，要测量最大带宽就要发送最大的数据量但是此时的RTT可能会很大，如果要测量最小的RTT那么久意味着数据量非常少最大带宽就无法获得。</p><p>TCP BBR算法采用交替采样测量两个指标，取一段时间内的带宽极大值和延时极小值作为估计值，具体的实现本文就不展开了。</p><h3 id="3-2-3-发送速率和RTT曲线"><a href="#3-2-3-发送速率和RTT曲线" class="headerlink" title="3.2.3 发送速率和RTT曲线"></a>3.2.3 发送速率和RTT曲线</h3><p>前面提到了BBR算法核心是寻找BDP最优工作点，在相关论文中给出了一张组合的曲线图，我们一起来看下：</p><p>​       <img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0e25d01fd9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>1.曲线图示说明：</strong><br>这张图是由两个图组合而成，目前是展示[数据发送速率vs网络数据]和[RTTvs网络数据]的关系，横轴是网络数据数量。</p><p>两个纵轴从上到下分别为RTT和发送速率，并且整个过程分为了3个阶段：应用限制阶段、带宽限制阶段、缓冲区限制阶段。</p><p><strong>2.曲线过程说明：</strong></p><ul><li><strong>app limit应用限制阶段</strong><br>在这个阶段是应用程序开始发送数据，目前网络通畅RTT基本保持固定且很小，发送速率与RTT成反比，因此发送速率也是线性增加的，可以简单认为这个阶段有效带宽并没有达到上限，RTT是几乎固定的没有明显增长。</li><li><strong>band limit带宽限制阶段</strong><br>随着发送速率提高，网络中的数据包越来越多开始占用链路Buffer，此时RTT开始增加发送速率不再上升，有效带宽开始出现瓶颈，但是此时链路中的缓存区并没有占满，因此数据还在增加，RTT也开始增加。</li><li><strong>buffer limit缓冲区限制阶段</strong><br>随着链路中的Buffer被占满，开始出现丢包，这也是探测到的最大带宽，这个节点BDP+BufferSize也是基于丢包的控制策略的作用点。</li></ul><p><strong>3.一些看法</strong></p><p>网上有一些资料都提及到了这张图，其中的一些解释也并不算非常清晰，结合这些资料和自己的认识，笔者认为在网络链路的缓存区没有被使用时RTT为最小延时MinRTT，在网络链路缓冲区被占满时出现最大带宽MaxBW(链路带宽+链路缓存)，但是此时的MaxBW和MinRTT并不是最优的而是水位比较高的水平，有数据表明按照2ln2的增益计算此时为3BDP，整个过程中MinRTT和MaxBW是分开探测的，因为这二者是不能同时被测量的。</p><h3 id="3-2-4-BBR算法的主要过程"><a href="#3-2-4-BBR算法的主要过程" class="headerlink" title="3.2.4 BBR算法的主要过程"></a>3.2.4 BBR算法的主要过程</h3><p>BBR算法和CUBIC算法类似，也同样有几个过程：StartUp、Drain、Probe_BW、Probe_RTT，来看下这几个状态的迁移情况：</p><p><img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0e290a5b20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li><strong>StartUp慢启动阶段</strong><br>BBR的慢启动阶段类似于CUBIC的慢启动，同样是进行探测式加速区别在于BBR的慢启动使用2ln2的增益加速，过程中即使发生丢包也不会引起速率的降低，而是依据返回的确认数据包来判断带宽增长，直到带宽不再增长时就停止慢启动而进入下一个阶段，需要注意的是在寻找最大带宽的过程中产生了多余的2BDP的数据量，关于这块可以看下英文原文的解释：</li></ul><blockquote><p>To handle Internet link bandwidths spanning 12 orders of magnitude, Startup implements a binary search for BtlBw by using a gain of 2/ln2 to double the sending rate while delivery rate is increasing. This discovers BtlBw in log2BDP RTTs but creates up to 2BDP excess queue in the process.</p></blockquote><ul><li><strong>Drain排空阶段</strong><br>排空阶段是为了把慢启动结束时多余的2BDP的数据量清空，此阶段发送速率开始下降，也就是单位时间发送的数据包数量在下降，直到未确认的数据包数量&lt;BDP时认为已经排空，也可以认为是RTT不再下降为止，排空阶段结束。</li><li><strong>ProbeBW带宽探测阶段</strong><br>经过慢启动和排空之后，目前发送方进入稳定状态进行数据的发送，由于网络带宽的变化要比RTT更为频繁，因此ProbeBW阶段也是BBR的主要阶段，在探测期中增加发包速率如果数据包ACK并没有受影响那么就继续增加，探测到带宽降低时也进行发包速率下降。</li><li><strong>ProbeRTT延时探测阶段</strong><br>前面三个过程在运行时都可能进入ProbeRTT阶段，当某个设定时间内都没有更新最小延时状态下开始降低数据包发送量，试图探测到更小的MinRTT，探测完成之后再根据最新数据来确定进入慢启动还是ProbeBW阶段。</li></ul><p>我们来看一下这四个过程的示意图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0e2bf9446d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>曲线说明</strong>：这两个坐标给出了10Mbps和40msRTT的网络环境下CUBIC和BBR的一个对比过程，在上面的图中蓝色表示接收者，红色表示CUBIC，绿色表示BBR，在下面的图中给出了对应上图过程中的RTT波动情况，红色代表CUBIC，绿色代表BBR。</p><h2 id="0x04-TCP-BBR算法的一些效果"><a href="#0x04-TCP-BBR算法的一些效果" class="headerlink" title="0x04.TCP BBR算法的一些效果"></a>0x04.TCP BBR算法的一些效果</h2><p>有一些文章认为BBR有鲜明的特点，把拥塞控制算法分为BBR之前和BBR之后，可见BBR还是有一定影响，但是BBR算法也不是银弹，不过可以先看看BBR算法在谷歌推动下的一些应用效果，其中包括吞吐量、RTT、丢包率影响：</p><p><img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0e2c4401a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0e45d61547?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2020/2/16/1704be0e463a03ff?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>从图中我们可以看到在YouTube应用BBR算法之后，就吞吐量普遍有4%左右的提升，特别地在日本的提升达到14%，RTT的下降更为明显平均降低33%，其中IN(猜测是印度地区)达到50%以上，在丢包率测试中BBR并不想CUBIC那么敏感，在丢包率达到5%是吞吐量才开始明显下降。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05.总结"></a>0x05.总结</h2><p>本文先回顾了以CUBIC为代表传统的拥塞控制算法，之后展开了对BBR算法的一些介绍。</p><p>网络上关于BBR的文章很多，笔者也尝试结合很多文章和外文资料进行理解和归纳，但是由于笔者工作经验和水平所致上述文字中可能存在一些问题，对此表达歉意，并且很多细节也并未展开，所以只能当做是一次浅谈了。</p><p>作者：后端技术指南针<br>链接：<a href="https://juejin.cn/post/6844904065759969287" target="_blank" rel="noopener">https://juejin.cn/post/6844904065759969287</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Arrays.sort使用的什么排序?</title>
      <link href="/2021/02/08/Arrays-sort%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/02/08/Arrays-sort%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><ul><li><strong>双轴快排</strong>(DualPivotQuicksort)，顾名思义有<strong>两个轴元素</strong>pivot1，pivot2，且pivot ≤<br>pivot2，<strong>将序列分成三段</strong>：x &lt; pivot1、pivot1 ≤ x ≤ pivot2、x &gt;pivot2，然后分别对三段进行递归。这个算法通常会比传统的快排效率更高，也因此被作为Arrays.java中给基本类型的数据排序的具体实现。</li></ul><p>下面我们以JDK1.8中Arrays对int型数组的排序为例来介绍其中使用的双轴快排：</p><p>1.判断数组的长度是否大于286，大于则使用归并排序(merge sort)，否则执行2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Use Quicksort on small arrays</span><br><span class="line">   if (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">           sort(a, left, right, true);</span><br><span class="line">           return;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; Merge sort</span><br><span class="line">   ......</span><br></pre></td></tr></table></figure><p>2.判断数组长度是否小于47，小于则直接采用插入排序(insertion sort)，否则执行3。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Use insertion sort on tiny arrays</span><br><span class="line">   if (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">   &#x2F;&#x2F; Insertion sort</span><br><span class="line">   ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>3.用公式length/8+length/64+1近似计算出数组长度的1/7。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Inexpensive approximation of length &#x2F; 7</span><br><span class="line">   int seventh &#x3D; (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span><br></pre></td></tr></table></figure><p>4.取5个根据经验得出的等距点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    * Sort five evenly spaced elements around (and including) the</span><br><span class="line">    * center element in the range. These elements will be used for</span><br><span class="line">    * pivot selection as described below. The choice for spacing</span><br><span class="line">    * these elements was empirically determined to work well on</span><br><span class="line">    * a wide variety of inputs.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   int e3 &#x3D; (left + right) &gt;&gt;&gt; 1; &#x2F;&#x2F; The midpoint</span><br><span class="line">   int e2 &#x3D; e3 - seventh;</span><br><span class="line">   int e1 &#x3D; e2 - seventh;</span><br><span class="line">   int e4 &#x3D; e3 + seventh;</span><br><span class="line">   int e5 &#x3D; e4 + seventh;</span><br></pre></td></tr></table></figure><p>5.将这5个元素进行插入排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Sort these elements using insertion sort</span><br><span class="line">    if (a[e2] &lt; a[e1]) &#123; int t &#x3D; a[e2]; a[e2] &#x3D; a[e1]; a[e1] &#x3D; t; &#125;</span><br><span class="line">    if (a[e3] &lt; a[e2]) &#123; int t &#x3D; a[e3]; a[e3] &#x3D; a[e2]; a[e2] &#x3D; t;</span><br><span class="line">    if (t &lt; a[e1]) &#123; a[e2] &#x3D; a[e1]; a[e1] &#x3D; t; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a[e4] &lt; a[e3]) &#123; int t &#x3D; a[e4]; a[e4] &#x3D; a[e3]; a[e3] &#x3D; t;</span><br><span class="line">        if (t &lt; a[e2]) &#123; a[e3] &#x3D; a[e2]; a[e2] &#x3D; t;</span><br><span class="line">            if (t &lt; a[e1]) &#123; a[e2] &#x3D; a[e1]; a[e1] &#x3D; t; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a[e5] &lt; a[e4]) &#123; int t &#x3D; a[e5]; a[e5] &#x3D; a[e4]; a[e4] &#x3D; t;</span><br><span class="line">        if (t &lt; a[e3]) &#123; a[e4] &#x3D; a[e3]; a[e3] &#x3D; t;</span><br><span class="line">            if (t &lt; a[e2]) &#123; a[e3] &#x3D; a[e2]; a[e2] &#x3D; t;</span><br><span class="line">                if (t &lt; a[e1]) &#123; a[e2] &#x3D; a[e1]; a[e1] &#x3D; t; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>6.选取a[e2]，a[e4]分别作为pivot1，pivot2。由于步骤5进行了排序，所以必有pivot1 &lt;=pivot2。定义两个指针less和great，less从最左边开始向右遍历，一直找到第一个不小于pivot1的元素，great从右边开始向左遍历，一直找到第一个不大于pivot2的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">        * Use the second and fourth of the five sorted elements as pivots.</span><br><span class="line">        * These values are inexpensive approximations of the first and</span><br><span class="line">        * second terciles of the array. Note that pivot1 &lt;&#x3D; pivot2.</span><br><span class="line">        *&#x2F;</span><br><span class="line">       int pivot1 &#x3D; a[e2];</span><br><span class="line">       int pivot2 &#x3D; a[e4];</span><br><span class="line">       &#x2F;*</span><br><span class="line">        * The first and the last elements to be sorted are moved to the</span><br><span class="line">        * locations formerly occupied by the pivots. When partitioning</span><br><span class="line">        * is complete, the pivots are swapped back into their final</span><br><span class="line">        * positions, and excluded from subsequent sorting.</span><br><span class="line">        *&#x2F;</span><br><span class="line">       a[e2] &#x3D; a[left];</span><br><span class="line">       a[e4] &#x3D; a[right];</span><br><span class="line">       &#x2F;*</span><br><span class="line">        * Skip elements, which are less or greater than pivot values.</span><br><span class="line">        *&#x2F;</span><br><span class="line">       while (a[++less] &lt; pivot1);</span><br><span class="line">       while (a[--great] &gt; pivot2);</span><br></pre></td></tr></table></figure><p>7.接着定义指针k从less-1开始向右遍历至</p><p>great，把小于pivot1的元素移动到less左边，大于pivot2的元素移动到great右边。这里要注意，我们已知great处的元素小于pivot2，但是它于pivot1的大小关系，还需要进行判断，如果比pivot1还小，需要移动到到less左边，否则只需要交换到k处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Partitioning:</span><br><span class="line"> *</span><br><span class="line"> *   left part           center part                   right part</span><br><span class="line"> * +--------------------------------------------------------------+</span><br><span class="line"> * |  &lt; pivot1  |  pivot1 &lt;&#x3D; &amp;&amp; &lt;&#x3D; pivot2  |    ?    |  &gt; pivot2  |</span><br><span class="line"> * +--------------------------------------------------------------+</span><br><span class="line"> *               ^                          ^       ^</span><br><span class="line"> *               |                          |       |</span><br><span class="line"> *              less                        k     great</span><br><span class="line"> *</span><br><span class="line"> * Invariants:</span><br><span class="line"> *</span><br><span class="line"> *              all in (left, less)   &lt; pivot1</span><br><span class="line"> *    pivot1 &lt;&#x3D; all in [less, k)     &lt;&#x3D; pivot2</span><br><span class="line"> *              all in (great, right) &gt; pivot2</span><br><span class="line"> *</span><br><span class="line"> * Pointer k is the first index of ?-part.</span><br><span class="line"> *&#x2F;</span><br><span class="line">        outer:</span><br><span class="line">        for (int k &#x3D; less - 1; ++k &lt;&#x3D; great; ) &#123;</span><br><span class="line">            int ak &#x3D; a[k];</span><br><span class="line">            if (ak &lt; pivot1) &#123; &#x2F;&#x2F; Move a[k] to left part</span><br><span class="line">                a[k] &#x3D; a[less];</span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * Here and below we use &quot;a[i] &#x3D; b; i++;&quot; instead</span><br><span class="line">                 * of &quot;a[i++] &#x3D; b;&quot; due to performance issue.</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                a[less] &#x3D; ak;</span><br><span class="line">                ++less;</span><br><span class="line">            &#125; else if (ak &gt; pivot2) &#123; &#x2F;&#x2F; Move a[k] to right part</span><br><span class="line">                while (a[great] &gt; pivot2) &#123;</span><br><span class="line">                    if (great-- &#x3D;&#x3D; k) &#123;</span><br><span class="line">                        break outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (a[great] &lt; pivot1) &#123; &#x2F;&#x2F; a[great] &lt;&#x3D; pivot2</span><br><span class="line">                    a[k] &#x3D; a[less];</span><br><span class="line">                    a[less] &#x3D; a[great];</span><br><span class="line">                    ++less;</span><br><span class="line">                &#125; else &#123; &#x2F;&#x2F; pivot1 &lt;&#x3D; a[great] &lt;&#x3D; pivot2</span><br><span class="line">                    a[k] &#x3D; a[great];</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * Here and below we use &quot;a[i] &#x3D; b; i--;&quot; instead</span><br><span class="line">                 * of &quot;a[i--] &#x3D; b;&quot; due to performance issue.</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                a[great] &#x3D; ak;</span><br><span class="line">                --great;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>8.将less-1处的元素移动到队头，great+1处的元素移动到队尾，并把pivot1和pivot2分别放到less-1和great+1处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swap pivots into their final positions</span><br><span class="line">        a[left]  &#x3D; a[less  - 1]; a[less  - 1] &#x3D; pivot1;</span><br><span class="line">        a[right] &#x3D; a[great + 1]; a[great + 1] &#x3D; pivot2;</span><br></pre></td></tr></table></figure><p>9.至此，less左边的元素都小于pivot1，great右边的元素都大于pivot2，分别对两部分进行同样的递归排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Sort left and right parts recursively, excluding known pivots</span><br><span class="line">        sort(a, left, less - 2, leftmost);</span><br><span class="line">        sort(a, great + 2, right, false);</span><br></pre></td></tr></table></figure><p>10.对于中间的部分，如果大于4/7的数组长度，很可能是因为重复元素的存在，所以把less向右移动到第一个不等于pivot1的地方，把great向左移动到第一个不等于pivot2的地方，然后再对less和great之间的部分进行递归排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">         * If center part is too large (comprises &gt; 4&#x2F;7 of the array),</span><br><span class="line">         * swap internal pivot values to ends.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * Skip elements, which are equal to pivot values.</span><br><span class="line">             *&#x2F;</span><br><span class="line">            while (a[less] &#x3D;&#x3D; pivot1) &#123;</span><br><span class="line">                ++less;</span><br><span class="line">            &#125;</span><br><span class="line">            while (a[great] &#x3D;&#x3D; pivot2) &#123;</span><br><span class="line">                --great;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        &#x2F;&#x2F; Sort center part recursively</span><br><span class="line">        sort(a, less, great, false);</span><br></pre></td></tr></table></figure><p>另外参考了其他博文，算法思路如下：<br>算法步骤<br>1.对于很小的数组（长度小于47），会使用插入排序。<br>2.选择两个点P1,P2作为轴心，比如我们可以使用第一个元素和最后一个元素。<br>3.P1必须比P2要小，否则将这两个元素交换，现在将整个数组分为四部分：<br>（1）第一部分：比P1小的元素。<br>（2）第二部分：比P1大但是比P2小的元素。<br>（3）第三部分：比P2大的元素。<br>（4）第四部分：尚未比较的部分。<br>在开始比较前，除了轴点，其余元素几乎都在第四部分，直到比较完之后第四部分没有元素。<br>4.从第四部分选出一个元素a[K]，与两个轴心比较，然后放到第一二三部分中的一个。<br>5.移动L，K，G指向。<br>6.重复 4 5 步，直到第四部分没有元素。<br>7.将P1与第一部分的最后一个元素交换。将P2与第三部分的第一个元素交换。<br>8.递归的将第一二三部分排序。</p><p><strong>总结：</strong>Arrays.sort对升序数组、降序数组和重复数组的排序效率有了很大的提升，这里面有几个重大的优化。<br><strong>1.对于小数组来说，插入排序效率更高，每次递归到小于47的大小时，用插入排序代替快排，明显提升了性能。<br>2.双轴快排使用两个pivot，每轮把数组分成3段，在没有明显增加比较次数的情况下巧妙地减少了递归次数。<br>3.pivot的选择上增加了随机性，却没有带来随机数的开销。<br>4.对重复数据进行了优化处理，避免了不必要交换和递归。</strong></p><p><img src="https://oscimg.oschina.net/oscnet/aed97ea2fa038313c6d32b3f69c1bf22bdf.png" alt="img"></p><p> 　O(nlogn)只代表增长量级，同一个量级前面的常数也可以不一样，不同数量下面的实际运算时间也可以不一样。</p><p>　　数量非常小的情况下（就像上面说到的，少于47的），插入排序等可能会比快速排序更快。 所以数组少于47的会进入插入排序。  </p><p>　　快排数据越无序越快（加入随机化后基本不会退化），平均常数最小，不需要额外空间，不稳定排序。</p><p>　　归排速度稳定，常数比快排略大，需要额外空间，稳定排序。</p><p>　　所以大于或等于47或少于286会进入快排，而在大于或等于286后，会有个小动作：“// Check if the array is nearly sorted”。这里第一个作用是先梳理一下数据方便后续的归并排序，第二个作用就是即便大于286，但在降序组太多的时候（被判断为没有结构的数据，The array is not highly structured,use Quicksort instead of merge sort.），要转回快速排序。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GEO数据结构</title>
      <link href="/2021/02/07/GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2021/02/07/GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这时问题来了，Sorted Set 元素的权重分数是一个浮点数（float 类型），而一组经纬度包<br>含的是经度和纬度两个值，是没法直接保存为一个浮点数的，那具体该怎么进行保存呢？<br>这就要用到 GEO 类型中的 GeoHash 编码了。</p><p>GeoHash 的编码方法<br>为了能高效地对经纬度进行比较，Redis 采用了业界广泛使用的 GeoHash 编码方法，这<br>个方法的基本原理就是“二分区间，区间编码”。<br>当我们要对一组经纬度进行 GeoHash 编码时，我们要先对经度和纬度分别编码，然后再<br>把经纬度各自的编码组合成一个最终编码。<br>首先，我们来看下经度和纬度的单独编码过程。<br>对于一个地理位置信息来说，它的经度范围是[-180,180]。GeoHash 编码会把一个经度值<br>编码成一个 N 位的二进制值，我们来对经度范围[-180,180]做 N 次的二分区操作，其中 N<br>可以自定义。</p><p>位编码。当做完 N 次的二分区后，经度值就<br>可以用一个 N bit 的数来表示了。<br>举个例子，假设我们要编码的经度值是 116.37，我们用 5 位编码值（也就是 N=5，做 5<br>次分区）。<br>我们先做第一次二分区操作，把经度区间[-180,180]分成了左分区[-180,0) 和右分区<br>[0,180]，此时，经度值 116.37 是属于右分区[0,180]，所以，我们用 1 表示第一次二分区<br>后的编码值。<br>接下来，我们做第二次二分区：把经度值 116.37 所属的[0,180]区间，分成[0,90) 和[90,<br>180]。此时，经度值 116.37 还是属于右分区[90,180]，所以，第二次分区后的编码值仍然<br>为 1。等到第三次对[90,180]进行二分区，经度值 116.37 落在了分区后的左分区[90, 135)<br>中，所以，第三次分区后的编码值就是 0。<br>按照这种方法，做完 5 次分区后，我们把经度值 116.37 定位在[112.5, 123.75]这个区<br>间，并且得到了经度值的 5 位编码值，即 11010。这个编码过程如下表所示：</p><p><img src="/2021/02/07/GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210207195146607.png" alt="image-20210207195146607"></p><p>对纬度的编码方式，和对经度的一样，只是纬度的范围是[-90，90]，下面这张表显示了对<br>纬度值 39.86 的编码过程。</p><p><img src="/2021/02/07/GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210207195537897.png" alt="image-20210207195537897"></p><p>当一组经纬度值都编完码后，我们再把它们的各自编码值组合在一起，组合的规则是：最<br>终编码值的偶数位上依次是经度的编码值，奇数位上依次是纬度的编码值，其中，偶数位<br>从 0 开始，奇数位从 1 开始。<br>我们刚刚计算的经纬度（116.37，39.86）的各自编码值是 11010 和 10111，组合之后，<br>第 0 位是经度的第 0 位 1，第 1 位是纬度的第 0 位 1，第 2 位是经度的第 1 位 1，第 3<br>位是纬度的第 1 位 0，以此类推，就能得到最终编码值 1110011101，如下图所示：</p><p><img src="/2021/02/07/GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210207195618112.png" alt="image-20210207195618112"></p><p>用了 GeoHash 编码后，原来无法用一个权重分数表示的一组经纬度（116.37，39.86）就<br>可以用 1110011101 这一个值来表示，就可以保存为 Sorted Set 的权重分数了。<br>当然，使用 GeoHash 编码后，我们相当于把整个地理空间划分成了一个个方格，每个方<br>格对应了 GeoHash 中的一个分区。</p><p>举个例子。我们把经度区间[-180,180]做一次二分区，把纬度区间[-90,90]做一次二分区，<br>就会得到 4 个分区。我们来看下它们的经度和纬度范围以及对应的 GeoHash 组合编码</p><p><img src="/2021/02/07/GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210207195713105.png" alt="image-20210207195713105"></p><p>这 4 个分区对应了 4 个方格，每个方格覆盖了一定范围内的经纬度值，分区越多，每个方<br>格能覆盖到的地理空间就越小，也就越精准。我们把所有方格的编码值映射到一维空间<br>时，相邻方格的 GeoHash 编码值基本也是接近的，如下图所示：</p><p><img src="/2021/02/07/GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210207195728668.png" alt="image-20210207195728668"></p><p>所以，我们使用 Sorted Set 范围查询得到的相近编码值，在实际的地理空间上，也是相邻<br>的方格，这就可以实现 LBS 应用“搜索附近的人或物”的功能了。<br>分区一：[-180,0) 和[-90,0)，编码 00；<br>分区二：[-180,0) 和[0,90]，编码 01；<br>分区三：[0,180]和[-90,0)，编码 10；<br>分区四：[0,180]和[0,90]，编码 11。</p><p>不过，我要提醒你一句，有的编码值虽然在大小上接近，但实际对应的方格却距离比较<br>远。例如，我们用 4 位来做 GeoHash 编码，把经度区间[-180,180]和纬度区间[-90,90]各<br>分成了 4 个分区，一共 16 个分区，对应了 16 个方格。编码值为 0111 和 1000 的两个方<br>格就离得比较远，如下图所示：</p><p><img src="/2021/02/07/GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210207195744382.png" alt="image-20210207195744382"></p><p>所以，为了避免查询不准确问题，我们可以同时查询给定经纬度所在的方格周围的 4 个或<br>8 个方格。<br>好了，到这里，我们就知道了，GEO 类型是把经纬度所在的区间编码作为 Sorted Set 中<br>元素的权重分数，把和经纬度相关的车辆 ID 作为 Sorted Set 中元素本身的值保存下来，<br>这样相邻经纬度的查询就可以通过编码值的大小范围查询来实现了。接下来，我们再来聊<br>聊具体如何操作 GEO 类型。</p><h1 id="一、CEO概述"><a href="#一、CEO概述" class="headerlink" title="一、CEO概述"></a>一、CEO概述</h1><ul><li><strong>Redis3.2版本提供了GEO（地理信息定位）功能，</strong>支持存储地理位置信 息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能，对于需 要实现这些功能的开发者来说是一大福音</li><li>GEO功能是Redis的另一位作者Matt Stancliff借鉴NoSQL数据库Ardb实现的，Ardb的作者来自中国，它提供了优秀的GEO功能</li></ul><h1 id="二、增加地理位置信息（geoadd）"><a href="#二、增加地理位置信息（geoadd）" class="headerlink" title="二、增加地理位置信息（geoadd）"></a>二、增加地理位置信息（geoadd）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure><ul><li><strong>参数如下：</strong><ul><li>longitude：地址位置的经度</li><li>latitude：地址位置的纬度</li><li>member：成员</li></ul></li><li><strong>相关注意事项：</strong><ul><li>geoadd一次可以添加多个地理位置信息</li><li>geoadd添加成功返回1</li><li>如果member已经存在，那么该命令返回0，此时代表更新member的值</li></ul></li><li><strong>例如：</strong>下面添加5个城市的经纬度</li></ul><p><img src="https://img-blog.csdnimg.cn/20200512150809541.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200512150937504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><h1 id="三、获取地理信息位置（geopos）"><a href="#三、获取地理信息位置（geopos）" class="headerlink" title="三、获取地理信息位置（geopos）"></a>三、获取地理信息位置（geopos）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure><ul><li>该命令用来获取两个地址位置的距离</li><li><strong>unit参数代表返货结果的单位，包含以下4种：</strong><ul><li>m（meters）代表米</li><li>km（kilometers）代表公里</li><li>mi（miles）代表英里</li><li>ft（feet）代表尺</li></ul></li><li><strong>例如：</strong>下面计算天津到北京的距离，以公里为单位</li></ul><p><img src="https://img-blog.csdnimg.cn/20200512151135790.png" alt="img"></p><h1 id="四、获取指定位置范围内的地理信息位置集合（georadius、georadiusbymember）"><a href="#四、获取指定位置范围内的地理信息位置集合（georadius、georadiusbymember）" class="headerlink" title="四、获取指定位置范围内的地理信息位置集合（georadius、georadiusbymember）"></a>四、获取指定位置范围内的地理信息位置集合（georadius、georadiusbymember）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">georadius key longitude latitude radiusm|km|ft|mi [withcoord] [withdist] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</span><br><span class="line">georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</span><br></pre></td></tr></table></figure><ul><li>两个命令作用相同，<strong>都是以一个地理位置为中心算出指定半径内的其他地理信息位置</strong></li><li><strong>不同的是：</strong><ul><li>georadius命令的中心位置<strong>给出了具体的经纬度</strong></li><li>georadiusbymember<strong>只需给出成员即可</strong></li></ul></li><li><strong>其中radiusm|km|ft|mi是必需参数，指定了半径（带单位），其他可选参数意义如下：</strong><ul><li>withcoord：返回结果中包含经纬度</li><li>withdist：返回结果中包含离中心节点位置的距离</li><li>withhash：返回结果中包含geohash，有关geohash后面介绍</li><li>COUNT count：指定返回结果的数量</li><li>asc|desc：返回结果按照离中心节点的距离做升序或者降序</li><li>store key：将返回结果的地理位置信息保存到指定键</li><li>storedist key：将返回结果离中心节点的距离保存到指定键。</li></ul></li><li><strong>例如：</strong>下面计算5个城市中，距离北京150公里以内的城市</li></ul><p><img src="https://img-blog.csdnimg.cn/20200512151606261.png" alt="img"></p><h1 id="五、获取geohash"><a href="#五、获取geohash" class="headerlink" title="五、获取geohash"></a>五、获取geohash</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key member [member ...]</span><br></pre></td></tr></table></figure><ul><li>Redis使用geohash(<a href="https://en.wikipedia.org/wiki/Geohash)**将二维经纬度转换为一维字符串" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Geohash)**将二维经纬度转换为一维字符串</a>**</li><li><strong>例如：</strong>下面操作会返回beijing的geohash值</li></ul><p><img src="https://img-blog.csdnimg.cn/20200512151844124.png" alt="img"></p><ul><li><strong>geohash有如下特点：</strong><ul><li><strong>GEO的数据类型为zset（</strong>见下图），Redis将所有地理位置信息的geohash存放在zset中</li><li><strong>字符串越长，表示的位置更精确，</strong>下图给出了字符串长度对应的精度，例如geohash长度为9时，精度在2米左右</li><li><strong>两个字符串越相似，它们之间的距离越近，</strong>Redis利用字符串前缀匹配算法实现相关的命令</li><li><strong>geohash编码和经纬度是可以相互转换的</strong></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200512152006447.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200512152052500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>Redis正是使用有序集合并结合geohash的特性实现了GEO的若干命令</li></ul><h1 id="六、删除地理位置信息（zrem）"><a href="#六、删除地理位置信息（zrem）" class="headerlink" title="六、删除地理位置信息（zrem）"></a>六、删除地理位置信息（zrem）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member</span><br></pre></td></tr></table></figure><ul><li><strong>GEO没有提供删除成员的命令</strong>，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除</li><li>例如，下面将cities:locations中的所有地理位置信息删除</li></ul><p><img src="https://img-blog.csdnimg.cn/20200512153319651.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis读书笔记</title>
      <link href="/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的<br>偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。</p><p><img src="/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206202418097.png" alt="image-20210206202418097"></p><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段<br>的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查<br>找，此时的复杂度就是 O(N) 了。</p><p>压缩列表之所以能节省内存，就在于它是用一系列连续的 entry 保存数据。每个 entry 的<br>元数据包括下面几部分。</p><p>prev_len，表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。<br>取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数<br>值范围是 0 到 255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认用 255<br>表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上<br>一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节。<br>len：表示自身长度，4 字节；<br>encoding：表示编码方式，1 字节；<br>content：保存实际数据。</p><p>这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指<br>针所占用的空间。<br>我们以保存图片存储对象 ID 为例，来分析一下压缩列表是如何节省内存空间的。<br>每个 entry 保存一个图片存储对象 ID（8 字节），此时，每个 entry 的 prev_len 只需要<br>1 个字节就行，因为每个 entry 的前一个 entry 长度都只有 8 字节，小于 254 字节。这样<br>prev_len，表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。<br>取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数<br>值范围是 0 到 255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认用 255<br>表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上<br>一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节。<br>len：表示自身长度，4 字节；<br>encoding：表示编码方式，1 字节；<br>content：保存实际数据。</p><p>相比String</p><p>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针    <img src="/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206230520050.png" alt="image-20210206230520050"></p><p>Redis 会使用一个全局哈希表保存所有键值对，哈希表的每一项是<br>一个 dictEntry 的结构体，用来指向一个键值对。dictEntry 结构中有三个 8 字节的指针，<br>分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节，如下图所示：</p><p><img src="/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206225823359.png" alt="image-20210206225823359"></p><p>但是，这三个指针只有 24 字节，为什么会占用了 32 字节呢？这就要提到 Redis 使用的内<br>存分配库 jemalloc 了。<br>jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的<br>2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的<br>select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同<br>时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据<br>请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个<br>IO 流的效果。</p><p>Redis 单线程对该事件队列不断进行处理。这样一来，<br>Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，<br>Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件<br>的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升<br>Redis 的响应性能。</p><p>我再以连接请求和读数据请求为例，具体解释一下。</p><p>这两个请求分别对应 Accept 事件和 Read 事件，Redis 分别对这两个事件注册 accept 和<br>get 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件<br>和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。</p><p><img src="/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206210546576.png" alt="image-20210206210546576"></p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF 日志</p><p><img src="/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206210735965.png" alt="image-20210206210735965"></p><p>但是，为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这<br>些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误<br>的命令，Redis 在使用日志恢复数据时，就可能会出错。<br>而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志<br>中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处<br>是，可以避免出现记录错误命令的情况。<br>除此之外，AOF 还有一个好处：它是在命令执行后才记录日志，所以不会阻塞当前的写操<br>作。</p><p>不过，AOF 也有两个潜在的风险。<br>首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数<br>据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行<br>恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就<br>无法用日志进行恢复了。<br>其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因<br>为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就<br>会导致写盘很慢，进而导致后续的操作也无法执行了。</p><p>这两个风险都是和 AOF 写回磁盘的时机相关的。</p><h4 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h4><p>其实，对于这个问题，AOF 机制给我们提供了三个选择，也就是 AOF 配置项<br>appendfsync 的三个可选值。<br>针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美。我们来<br>分析下其中的原因。<br>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；<br>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲<br>区，每隔一秒把缓冲区中的内容写入磁盘；<br>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓<br>冲区，由操作系统决定何时将缓冲区内容写回磁盘。</p><p><img src="/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206211051372.png" alt="image-20210206211051372"></p><p>到这里，我们就可以根据系统对高性能和高可靠性的要求，来选择使用哪种写回策略了。<br>总结一下就是：想要获得高性能，就选择 No 策略；如果想要得到高可靠性保证，就选择<br>Always 策略；如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择<br>Everysec 策略。<br>但是，按照系统的性能需求选定了写回策略，并不是“高枕无忧”了。毕竟，AOF 是以文<br>件的形式在记录接收到的所有写命令。随着接收的写命令越来越多，AOF 文件会越来越<br>大。这也就意味着，我们一定要小心 AOF 文件过大带来的性能问题。<br>这里的“性能问题”，主要在于以下三个方面：一是，文件系统本身对文件大小有限制，<br>无法保存过大的文件；二是，如果文件太大，之后再往里面追加命令记录的话，效率也会<br>变低；三是，如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如<br>果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。<br>所以，我们就要采取一定的控制手段，这个时候，AOF 重写机制就登场了。</p><h4 id="日志文件太大了怎么办？"><a href="#日志文件太大了怎么办？" class="headerlink" title="日志文件太大了怎么办？"></a>日志文件太大了怎么办？</h4><p>简单来说，AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文<br>件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写<br>入。比如说，当读取了键值对“testkey”: “testvalue”之后，重写机制会记录 set<br>testkey testvalue 这条命令。这样，当需要恢复时，可以重新执行该命令，实<br>现“testkey”: “testvalue”的写入。</p><p>为什么重写机制可以把日志文件变小呢? 实际上，重写机制具有“多变一”功能。所谓<br>的“多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命<br>令。<br>我们知道，AOF 文件是以追加的方式，逐一记录接收到的写命令的。当一个键值对被多条<br>写命令反复修改时，AOF 文件会记录相应的多条命令。但是，在重写的时候，是根据这个<br>键值对当前的最新状态，为它生成对应的写入命令。这样一来，一个键值对在重写日志中<br>只用一条命令就行了，而且，在日志恢复时，只用执行这条命令，就可以直接完成这个键<br>值对的写入了。<br>下面这张图就是一个例子：</p><p><img src="/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206211255512.png" alt="image-20210206211255512"></p><p>不过，虽然 AOF 重写后，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志<br>都写回磁盘，仍然是一个非常耗时的过程。这时，我们就要继续关注另一个问题了：重写<br>会不会阻塞主线程？</p><h4 id="AOF-重写会阻塞吗"><a href="#AOF-重写会阻塞吗" class="headerlink" title="AOF 重写会阻塞吗?"></a>AOF 重写会阻塞吗?</h4><p>和 AOF 日志由主线程写回不同，重写过程是由后台线程 bgrewriteaof 来完成的，这也是<br>为了避免阻塞主线程，导致数据库性能下降。<br>我把重写的过程总结为“一个拷贝，两处日志”。</p><p>“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此<br>时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的<br>最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数<br>据写成操作，记入重写日志。<br>“两处日志”又是什么呢？<br>因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指<br>正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这<br>个 AOF 日志的操作仍然是齐全的，可以用于恢复。<br>而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这<br>样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日<br>志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我<br>们就可以用新的 AOF 文件替代旧文件了。</p><p><img src="/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206211447998.png" alt="image-20210206211447998"></p><p>总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个<br>日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行<br>数据重写，所以，这个过程并不会阻塞主线程。</p><p><img src="/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206213323733.png" alt="image-20210206213323733"></p><h4 id="fork子进程"><a href="#fork子进程" class="headerlink" title="fork子进程"></a>fork子进程</h4><p>fork子进程时，子进程是会拷贝父进程的页表，即虚<br>实映射关系，而不会拷贝物理内存。子进程复制了父进程页表，也能共享访问父进程的内存数据<br>了，此时，类似于有了父进程的所有内存数据。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>快照时数据能修改吗?<br>Redis 就会借助操作系统提<br>供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。<br>简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。<br>bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。<br>此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和<br>bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），<br>那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本<br>数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p><p><img src="/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206214738843.png" alt="image-20210206214738843"></p><h4 id="可以每秒做一次快照吗？"><a href="#可以每秒做一次快照吗？" class="headerlink" title="可以每秒做一次快照吗？"></a>可以每秒做一次快照吗？</h4><p>把内存中的所有数据都记录到磁盘中。最好不要，全量快照的基础上做一次增量快照</p><p>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快着。简单来说，内存快照以一<br>定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。<br>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF<br>日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出<br>现文件过大的情况了，也可以避免重写开销。<br>如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可<br>以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。</p><h3 id="Redis做消息队列"><a href="#Redis做消息队列" class="headerlink" title="Redis做消息队列"></a>Redis做消息队列</h3><p>消息队列在存取消息时，必须要满足三个需求，分别是消息保序、处理重复的消息<br>和保证消息可靠性。</p><p>保序：</p><p>BRPOP 命令也称为阻塞式读取，客户端<br>在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。</p><p>处理重复：</p><p>消息的全局唯一 ID 号就需要生产<br>者程序在发送消息前自行生成。生成之后，我们在用 LPUSH 命令把消息插入 List 时，需<br>要在消息中包含这个全局唯一 ID。</p><p>LPUSH mq “101030001:stock:5”</p><p>保证消息可靠性：</p><p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费<br>者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者<br>程序再次启动后，就没法再次从 List 中读取消息了。<br>为了留存消息，List 类型提供了 BRPOPLPUSH 命令，这个命令的作用是让消费者程序从<br>一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份<br>List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从<br>备份 List 中重新读取消息并进行处理了。</p><p><img src="/2021/02/06/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210206231532817.png" alt="image-20210206231532817"></p><p>消息堆积：</p><p>采用streams</p><p>Redis 从 5.0 版本开始提供的 Streams 数据类型了。</p><p>这个时候，我们希望启动多个消费者程序组成一个消费组，一起分担处理 List 中的消息。<br>但是，List 类型并不支持消费组的实现。那么，还有没有更合适的解决方案呢</p><p>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；<br>XREAD：用于读取消息，可以按 ID 读取数据；<br>XREADGROUP：按消费组形式读取消息；<br>XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取<br>但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</p><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hystrix汇总</title>
      <link href="/2021/01/30/hystrix%E6%B1%87%E6%80%BB/"/>
      <url>/2021/01/30/hystrix%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="用-Hystrix-构建高可用服务架构"><a href="#用-Hystrix-构建高可用服务架构" class="headerlink" title="用 Hystrix 构建高可用服务架构"></a>用 Hystrix 构建高可用服务架构</h2><p>参考 <a href="https://github.com/Netflix/Hystrix/wiki#what" target="_blank" rel="noopener">Hystrix Home</a>。</p><h3 id="Hystrix-是什么？"><a href="#Hystrix-是什么？" class="headerlink" title="Hystrix 是什么？"></a>Hystrix 是什么？</h3><p>在分布式系统中，每个服务都可能会调用很多其他服务，被调用的那些服务就是<strong>依赖服务</strong>，有的时候某些依赖服务出现故障也是很正常的。</p><p>Hystrix 可以让我们在分布式系统中对服务间的调用进行控制，加入一些<strong>调用延迟</strong>或者<strong>依赖故障</strong>的<strong>容错机制</strong>。</p><p>Hystrix 通过将依赖服务进行<strong>资源隔离</strong>，进而阻止某个依赖服务出现故障时在整个系统所有的依赖服务调用中进行蔓延；同时Hystrix 还提供故障时的 fallback 降级机制。</p><p>总而言之，Hystrix 通过这些方法帮助我们提升分布式系统的可用性和稳定性。</p><h3 id="Hystrix-的历史"><a href="#Hystrix-的历史" class="headerlink" title="Hystrix 的历史"></a>Hystrix 的历史</h3><p>Hystrix 是高可用性保障的一个框架。Netflix（可以认为是国外的优酷或者爱奇艺之类的视频网站）的 API 团队从 2011 年开始做一些提升系统可用性和稳定性的工作，Hystrix 就是从那时候开始发展出来的。</p><p>在 2012 年的时候，Hystrix 就变得比较成熟和稳定了，Netflix 中，除了 API 团队以外，很多其他的团队都开始使用 Hystrix。</p><p>时至今日，Netflix 中每天都有数十亿次的服务间调用，通过 Hystrix 框架在进行，而 Hystrix 也帮助 Netflix 网站提升了整体的可用性和稳定性。</p><p><a href="https://github.com/Netflix/Hystrix/blob/master/README.md#hystrix-status" target="_blank" rel="noopener">2018 年 11 月，Hystrix 在其 Github 主页宣布，不再开放新功能，推荐开发者使用其他仍然活跃的开源项目</a>。维护模式的转变绝不意味着 Hystrix 不再有价值。相反，Hystrix 激发了很多伟大的想法和项目，我们高可用的这一块知识还是会针对 Hystrix 进行讲解。</p><h3 id="Hystrix-的设计原则"><a href="#Hystrix-的设计原则" class="headerlink" title="Hystrix 的设计原则"></a>Hystrix 的设计原则</h3><ul><li>对依赖服务调用时出现的调用延迟和调用失败进行<strong>控制和容错保护</strong>。</li><li>在复杂的分布式系统中，阻止某一个依赖服务的故障在整个系统中蔓延。比如某一个服务故障了，导致其它服务也跟着故障。</li><li>提供 <code>fail-fast</code>（快速失败）和快速恢复的支持。</li><li>提供 fallback 优雅降级的支持。</li><li>支持近实时的监控、报警以及运维操作。</li></ul><p>举个栗子。</p><p>有这样一个分布式系统，服务 A 依赖于服务 B，服务 B 依赖于服务 C/D/E。在这样一个成熟的系统内，比如说最多可能只有 100 个线程资源。正常情况下，40 个线程并发调用服务 C，各 30 个线程并发调用 D/E。</p><p>调用服务 C，只需要 20ms，现在因为服务 C 故障了，比如延迟，或者挂了，此时线程会 hang 住 2s 左右。40 个线程全部被卡住，由于请求不断涌入，其它的线程也用来调用服务 C，同样也会被卡住。这样导致服务 B 的线程资源被耗尽，无法接收新的请求，甚至可能因为大量线程不断的运转，导致自己宕机。服务 A 也挂。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/service-invoke-road.png" alt="service-invoke-road"></p><p>Hystrix 可以对其进行资源隔离，比如限制服务 B 只有 40 个线程调用服务 C。当此 40 个线程被 hang 住时，其它 60 个线程依然能正常调用工作。从而确保整个系统不会被拖垮。</p><h3 id="Hystrix-更加细节的设计原则"><a href="#Hystrix-更加细节的设计原则" class="headerlink" title="Hystrix 更加细节的设计原则"></a>Hystrix 更加细节的设计原则</h3><ul><li>阻止任何一个依赖服务耗尽所有的资源，比如 tomcat 中的所有线程资源。</li><li>避免请求排队和积压，采用限流和 <code>fail fast</code> 来控制故障。</li><li>提供 fallback 降级机制来应对故障。</li><li>使用资源隔离技术，比如 <code>bulkhead</code>（舱壁隔离技术）、<code>swimlane</code>（泳道技术）、<code>circuit breaker</code>（断路技术）来限制任何一个依赖服务的故障的影响。</li><li>通过近实时的统计/监控/报警功能，来提高故障发现的速度。</li><li>通过近实时的属性和配置<strong>热修改</strong>功能，来提高故障处理和恢复的速度。</li><li>保护依赖服务调用的所有故障情况，而不仅仅只是网络故障情况。</li></ul><h2 id="基于-Hystrix-线程池技术实现资源隔离"><a href="#基于-Hystrix-线程池技术实现资源隔离" class="headerlink" title="基于 Hystrix 线程池技术实现资源隔离"></a>基于 Hystrix 线程池技术实现资源隔离</h2><p>上一讲提到，如果从 Nginx 开始，缓存都失效了，Nginx 会直接通过缓存服务调用商品服务获取最新商品数据（我们基于电商项目做个讨论），有可能出现调用延时而把缓存服务资源耗尽的情况。这里，我们就来说说，怎么通过 Hystrix 线程池技术实现资源隔离。</p><p>资源隔离，就是说，你如果要把对某一个依赖服务的所有调用请求，全部隔离在同一份资源池内，不会去用其它资源了，这就叫资源隔离。哪怕对这个依赖服务，比如说商品服务，现在同时发起的调用量已经到了 1000，但是线程池内就 10 个线程，最多就只会用这 10 个线程去执行，不会说，对商品服务的请求，因为接口调用延时，将 tomcat 内部所有的线程资源全部耗尽。</p><p>Hystrix 进行资源隔离，其实是提供了一个抽象，叫做 command。这也是 Hystrix 最最基本的资源隔离技术。</p><h3 id="利用-HystrixCommand-获取单条数据"><a href="#利用-HystrixCommand-获取单条数据" class="headerlink" title="利用 HystrixCommand 获取单条数据"></a>利用 HystrixCommand 获取单条数据</h3><p>我们通过将调用商品服务的操作封装在 HystrixCommand 中，限定一个 key，比如下面的 <code>GetProductInfoCommandGroup</code>，在这里我们可以简单认为这是一个线程池，每次调用商品服务，就只会用该线程池中的资源，不会再去用其它线程资源了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GetProductInfoCommand extends HystrixCommand&lt;ProductInfo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Long productId;</span><br><span class="line"></span><br><span class="line">    public GetProductInfoCommand(Long productId) &#123;</span><br><span class="line">        super(HystrixCommandGroupKey.Factory.asKey(&quot;GetProductInfoCommandGroup&quot;));</span><br><span class="line">        this.productId &#x3D; productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected ProductInfo run() &#123;</span><br><span class="line">        String url &#x3D; &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;getProductInfo?productId&#x3D;&quot; + productId;</span><br><span class="line">        &#x2F;&#x2F; 调用商品服务接口</span><br><span class="line">        String response &#x3D; HttpClientUtils.sendGetRequest(url);</span><br><span class="line">        return JSONObject.parseObject(response, ProductInfo.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在缓存服务接口中，根据 productId 创建 command 并执行，获取到商品数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;getProductInfo&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String getProductInfo(Long productId) &#123;</span><br><span class="line">    HystrixCommand&lt;ProductInfo&gt; getProductInfoCommand &#x3D; new GetProductInfoCommand(productId);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通过command执行，获取最新商品数据</span><br><span class="line">    ProductInfo productInfo &#x3D; getProductInfoCommand.execute();</span><br><span class="line">    System.out.println(productInfo);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面执行的是 execute() 方法，其实是同步的。也可以对 command 调用 queue() 方法，它仅仅是将 command 放入线程池的一个等待队列，就立即返回，拿到一个 Future 对象，后面可以继续做其它一些事情，然后过一段时间对 Future 调用 get() 方法获取数据。这是异步的。</p><h3 id="利用-HystrixObservableCommand-批量获取数据"><a href="#利用-HystrixObservableCommand-批量获取数据" class="headerlink" title="利用 HystrixObservableCommand 批量获取数据"></a>利用 HystrixObservableCommand 批量获取数据</h3><p>只要是获取商品数据，全部都绑定到同一个线程池里面去，我们通过 HystrixObservableCommand 的一个线程去执行，而在这个线程里面，批量把多个 productId 的 productInfo 拉回来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class GetProductInfosCommand extends HystrixObservableCommand&lt;ProductInfo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private String[] productIds;</span><br><span class="line"></span><br><span class="line">    public GetProductInfosCommand(String[] productIds) &#123;</span><br><span class="line">        &#x2F;&#x2F; 还是绑定在同一个线程池</span><br><span class="line">        super(HystrixCommandGroupKey.Factory.asKey(&quot;GetProductInfoGroup&quot;));</span><br><span class="line">        this.productIds &#x3D; productIds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Observable&lt;ProductInfo&gt; construct() &#123;</span><br><span class="line">        return Observable.unsafeCreate((Observable.OnSubscribe&lt;ProductInfo&gt;) subscriber -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            for (String productId : productIds) &#123;</span><br><span class="line">                &#x2F;&#x2F; 批量获取商品数据</span><br><span class="line">                String url &#x3D; &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;getProductInfo?productId&#x3D;&quot; + productId;</span><br><span class="line">                String response &#x3D; HttpClientUtils.sendGetRequest(url);</span><br><span class="line">                ProductInfo productInfo &#x3D; JSONObject.parseObject(response, ProductInfo.class);</span><br><span class="line">                subscriber.onNext(productInfo);</span><br><span class="line">            &#125;</span><br><span class="line">            subscriber.onCompleted();</span><br><span class="line"></span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在缓存服务接口中，根据传来的 id 列表，比如是以 <code>,</code> 分隔的 id 串，通过上面的 HystrixObservableCommand，执行 Hystrix 的一些 API 方法，获取到所有商品数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public String getProductInfos(String productIds) &#123;</span><br><span class="line">    String[] productIdArray &#x3D; productIds.split(&quot;,&quot;);</span><br><span class="line">    HystrixObservableCommand&lt;ProductInfo&gt; getProductInfosCommand &#x3D; new GetProductInfosCommand(productIdArray);</span><br><span class="line">    Observable&lt;ProductInfo&gt; observable &#x3D; getProductInfosCommand.observe();</span><br><span class="line"></span><br><span class="line">    observable.subscribe(new Observer&lt;ProductInfo&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">            System.out.println(&quot;获取完了所有的商品数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 获取完一条数据，就回调一次这个方法</span><br><span class="line">         * @param productInfo</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(ProductInfo productInfo) &#123;</span><br><span class="line">            System.out.println(productInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们回过头来，看看 Hystrix 线程池技术是如何实现资源隔离的。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/hystrix-thread-pool-isolation.png" alt="hystrix-thread-pool-isolation"></p><p>从 Nginx 开始，缓存都失效了，那么 Nginx 通过缓存服务去调用商品服务。缓存服务默认的线程大小是 10 个，最多就只有 10 个线程去调用商品服务的接口。即使商品服务接口故障了，最多就只有 10 个线程会 hang 死在调用商品服务接口的路上，缓存服务的 tomcat 内其它的线程还是可以用来调用其它的服务，干其它的事情。</p><h2 id="基于-Hystrix-信号量机制实现资源隔离"><a href="#基于-Hystrix-信号量机制实现资源隔离" class="headerlink" title="基于 Hystrix 信号量机制实现资源隔离"></a>基于 Hystrix 信号量机制实现资源隔离</h2><p>Hystrix 里面核心的一项功能，其实就是所谓的<strong>资源隔离</strong>，要解决的最最核心的问题，就是将多个依赖服务的调用分别隔离到各自的资源池内。避免说对某一个依赖服务的调用，因为依赖服务的接口调用的延迟或者失败，导致服务所有的线程资源全部耗费在这个服务的接口调用上。一旦说某个服务的线程资源全部耗尽的话，就可能导致服务崩溃，甚至说这种故障会不断蔓延。</p><p>Hystrix 实现资源隔离，主要有两种技术：</p><ul><li>线程池</li><li>信号量</li></ul><p>默认情况下，Hystrix 使用线程池模式。</p><p>前面已经说过线程池技术了，这一小节就来说说信号量机制实现资源隔离，以及这两种技术的区别与具体应用场景。</p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>信号量的资源隔离只是起到一个开关的作用，比如，服务 A 的信号量大小为 10，那么就是说它同时只允许有 10 个 tomcat 线程来访问服务 A，其它的请求都会被拒绝，从而达到资源隔离和限流保护的作用。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/hystrix-semphore.png" alt="hystrix-semphore"></p><h3 id="线程池与信号量区别"><a href="#线程池与信号量区别" class="headerlink" title="线程池与信号量区别"></a>线程池与信号量区别</h3><p>线程池隔离技术，并不是说去控制类似 tomcat 这种 web 容器的线程。更加严格的意义上来说，Hystrix 的线程池隔离技术，控制的是 tomcat 线程的执行。Hystrix 线程池满后，会确保说，tomcat 的线程不会因为依赖服务的接口调用延迟或故障而被 hang 住，tomcat 其它的线程不会卡死，可以快速返回，然后支撑其它的事情。</p><p>线程池隔离技术，是用 Hystrix 自己的线程去执行调用；而信号量隔离技术，是直接让 tomcat 线程去调用依赖服务。信号量隔离，只是一道关卡，信号量有多少，就允许多少个 tomcat 线程通过它，然后去执行。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/hystrix-semphore-thread-pool.png" alt="hystrix-semphore-thread-pool"></p><p><strong>适用场景</strong>：</p><ul><li><strong>线程池技术</strong>，适合绝大多数场景，比如说我们对依赖服务的网络请求的调用和访问、需要对调用的 timeout 进行控制（捕捉 timeout 超时异常）。</li><li><strong>信号量技术</strong>，适合说你的访问不是对外部依赖的访问，而是对内部的一些比较复杂的业务逻辑的访问，并且系统内部的代码，其实不涉及任何的网络请求，那么只要做信号量的普通限流就可以了，因为不需要去捕获 timeout 类似的问题。</li></ul><h3 id="信号量简单-Demo"><a href="#信号量简单-Demo" class="headerlink" title="信号量简单 Demo"></a>信号量简单 Demo</h3><p>业务背景里，比较适合信号量的是什么场景呢？</p><p>比如说，我们一般来说，缓存服务，可能会将一些量特别少、访问又特别频繁的数据，放在自己的纯内存中。</p><p>举个栗子。一般我们在获取到商品数据之后，都要去获取商品是属于哪个地理位置、省、市、卖家等，可能在自己的纯内存中，比如就一个 Map 去获取。对于这种直接访问本地内存的逻辑，比较适合用信号量做一下简单的隔离。</p><p>优点在于，不用自己管理线程池啦，不用 care timeout 超时啦，也不需要进行线程的上下文切换啦。信号量做隔离的话，性能相对来说会高一些。</p><p>假如这是本地缓存，我们可以通过 cityId，拿到 cityName。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LocationCache &#123;</span><br><span class="line">    private static Map&lt;Long, String&gt; cityMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        cityMap.put(1L, &quot;北京&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过cityId 获取 cityName</span><br><span class="line">     *</span><br><span class="line">     * @param cityId 城市id</span><br><span class="line">     * @return 城市名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String getCityName(Long cityId) &#123;</span><br><span class="line">        return cityMap.get(cityId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个 GetCityNameCommand，策略设置为<strong>信号量</strong>。run() 方法中获取本地缓存。我们目的就是对获取本地缓存的代码进行资源隔离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class GetCityNameCommand extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Long cityId;</span><br><span class="line"></span><br><span class="line">    public GetCityNameCommand(Long cityId) &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置信号量隔离策略</span><br><span class="line">        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;GetCityNameGroup&quot;))</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                        .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)));</span><br><span class="line"></span><br><span class="line">        this.cityId &#x3D; cityId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String run() &#123;</span><br><span class="line">        &#x2F;&#x2F; 需要进行信号量隔离的代码</span><br><span class="line">        return LocationCache.getCityName(cityId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接口层，通过创建 GetCityNameCommand，传入 cityId，执行 execute() 方法，那么获取本地 cityName 缓存的代码将会进行信号量的资源隔离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;getProductInfo&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String getProductInfo(Long productId) &#123;</span><br><span class="line">    HystrixCommand&lt;ProductInfo&gt; getProductInfoCommand &#x3D; new GetProductInfoCommand(productId);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 通过command执行，获取最新商品数据</span><br><span class="line">    ProductInfo productInfo &#x3D; getProductInfoCommand.execute();</span><br><span class="line"></span><br><span class="line">    Long cityId &#x3D; productInfo.getCityId();</span><br><span class="line"></span><br><span class="line">    GetCityNameCommand getCityNameCommand &#x3D; new GetCityNameCommand(cityId);</span><br><span class="line">    &#x2F;&#x2F; 获取本地内存(cityName)的代码会被信号量进行资源隔离</span><br><span class="line">    String cityName &#x3D; getCityNameCommand.execute();</span><br><span class="line"></span><br><span class="line">    productInfo.setCityName(cityName);</span><br><span class="line"></span><br><span class="line">    System.out.println(productInfo);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hystrix-隔离策略细粒度控制"><a href="#Hystrix-隔离策略细粒度控制" class="headerlink" title="Hystrix 隔离策略细粒度控制"></a>Hystrix 隔离策略细粒度控制</h2><p>Hystrix 实现资源隔离，有两种策略：</p><ul><li>线程池隔离</li><li>信号量隔离</li></ul><p>对资源隔离这一块东西，其实可以做一定细粒度的一些控制。</p><h3 id="execution-isolation-strategy"><a href="#execution-isolation-strategy" class="headerlink" title="execution.isolation.strategy"></a>execution.isolation.strategy</h3><p>指定了 HystrixCommand.run() 的资源隔离策略：<code>THREAD</code> or <code>SEMAPHORE</code>，一种基于线程池，一种基于信号量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; to use thread isolation</span><br><span class="line">HystrixCommandProperties.Setter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.THREAD)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; to use semaphore isolation</span><br><span class="line">HystrixCommandProperties.Setter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)</span><br></pre></td></tr></table></figure><p>线程池机制，每个 command 运行在一个线程中，限流是通过线程池的大小来控制的；信号量机制，command 是运行在调用线程中，通过信号量的容量来进行限流。</p><p>如何在线程池和信号量之间做选择？</p><p><strong>默认的策略</strong>就是线程池。</p><p><strong>线程池</strong>其实最大的好处就是对于网络访问请求，如果有超时的话，可以避免调用线程阻塞住。</p><p>而使用信号量的场景，通常是针对超大并发量的场景下，每个服务实例每秒都几百的 <code>QPS</code>，那么此时你用线程池的话，线程一般不会太多，可能撑不住那么高的并发，如果要撑住，可能要耗费大量的线程资源，那么就是用信号量，来进行限流保护。一般用信号量常见于那种基于纯内存的一些业务逻辑服务，而不涉及到任何网络访问请求。</p><h3 id="command-key-amp-command-group"><a href="#command-key-amp-command-group" class="headerlink" title="command key &amp; command group"></a>command key &amp; command group</h3><p>我们使用线程池隔离，要怎么对<strong>依赖服务</strong>、<strong>依赖服务接口</strong>、<strong>线程池</strong>三者做划分呢？</p><p>每一个 command，都可以设置一个自己的名称 command key，同时可以设置一个自己的组 command group。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static final Setter cachedSetter &#x3D; Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;))</span><br><span class="line">                                                .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;HelloWorld&quot;)); </span><br><span class="line"></span><br><span class="line">public CommandHelloWorld(String name) &#123;</span><br><span class="line">    super(cachedSetter);</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>command group 是一个非常重要的概念，默认情况下，就是通过 command group 来定义一个线程池的，而且还会通过 command group 来聚合一些监控和报警信息。同一个 command group 中的请求，都会进入同一个线程池中。</p><h3 id="command-thread-pool"><a href="#command-thread-pool" class="headerlink" title="command thread pool"></a>command thread pool</h3><p>ThreadPoolKey 代表了一个 HystrixThreadPool，用来进行统一监控、统计、缓存。默认的 ThreadPoolKey 就是 command group 的名称。每个 command 都会跟它的 ThreadPoolKey 对应的 ThreadPool 绑定在一起。</p><p>如果不想直接用 command group，也可以手动设置 ThreadPool 的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static final Setter cachedSetter &#x3D; Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;))</span><br><span class="line">                                                .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;HelloWorld&quot;))</span><br><span class="line">                                                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;HelloWorldPool&quot;));</span><br><span class="line"></span><br><span class="line">public CommandHelloWorld(String name) &#123;</span><br><span class="line">    super(cachedSetter);</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="command-key-amp-command-group-amp-command-thread-pool"><a href="#command-key-amp-command-group-amp-command-thread-pool" class="headerlink" title="command key &amp; command group &amp; command thread pool"></a>command key &amp; command group &amp; command thread pool</h3><p><strong>command key</strong> ，代表了一类 command，一般来说，代表了底层的依赖服务的一个接口。</p><p><strong>command group</strong> ，代表了某一个底层的依赖服务，这是很合理的，一个依赖服务可能会暴露出来多个接口，每个接口就是一个 command key。command group 在逻辑上去组织起来一堆 command key 的调用、统计信息、成功次数、timeout 超时次数、失败次数等，可以看到某一个服务整体的一些访问情况。一般来说，<strong>推荐</strong>根据一个服务区划分出一个线程池，command key 默认都是属于同一个线程池的。</p><p>比如说你以一个服务为粒度，估算出来这个服务每秒的所有接口加起来的整体 <code>QPS</code> 在 100 左右，你调用这个服务，当前这个服务部署了 10 个服务实例，每个服务实例上，其实用这个 command group 对应这个服务，给一个线程池，量大概在 10 个左右就可以了，你对整个服务的整体的访问 QPS 就大概在每秒 100 左右。</p><p>但是，如果说 command group 对应了一个服务，而这个服务暴露出来的几个接口，访问量很不一样，差异非常之大。你可能就希望在这个服务 command group 内部，包含的对应多个接口的 command key，做一些细粒度的资源隔离。就是说，对同一个服务的不同接口，使用不同的线程池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command key -&gt; command group</span><br><span class="line"></span><br><span class="line">command key -&gt; 自己的 thread pool key</span><br></pre></td></tr></table></figure><p>逻辑上来说，多个 command key 属于一个command group，在做统计的时候，会放在一起统计。每个 command key 有自己的线程池，每个接口有自己的线程池，去做资源隔离和限流。</p><p>说白点，就是说如果你的 command key 要用自己的线程池，可以定义自己的 thread pool key，就 ok 了。</p><h3 id="coreSize"><a href="#coreSize" class="headerlink" title="coreSize"></a>coreSize</h3><p>设置线程池的大小，默认是 10。一般来说，用这个默认的 10 个线程大小就够了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HystrixThreadPoolProperties.Setter().withCoreSize(int value);</span><br></pre></td></tr></table></figure><h3 id="queueSizeRejectionThreshold"><a href="#queueSizeRejectionThreshold" class="headerlink" title="queueSizeRejectionThreshold"></a>queueSizeRejectionThreshold</h3><p>如果说线程池中的 10 个线程都在工作中，没有空闲的线程来做其它的事情，此时再有请求过来，会先进入队列积压。如果说队列积压满了，再有请求过来，就直接 reject，拒绝请求，执行 fallback 降级的逻辑，快速返回。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/hystrix-thread-pool-queue.png" alt="hystrix-thread-pool-queue"></p><p>控制 queue 满了之后 reject 的 threshold，因为 maxQueueSize 不允许热修改，因此提供这个参数可以热修改，控制队列的最大大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HystrixThreadPoolProperties.Setter().withQueueSizeRejectionThreshold(int value);</span><br></pre></td></tr></table></figure><h3 id="execution-isolation-semaphore-maxConcurrentRequests"><a href="#execution-isolation-semaphore-maxConcurrentRequests" class="headerlink" title="execution.isolation.semaphore.maxConcurrentRequests"></a>execution.isolation.semaphore.maxConcurrentRequests</h3><p>设置使用 SEMAPHORE 隔离策略的时候允许访问的最大并发量，超过这个最大并发量，请求直接被 reject。</p><p>这个并发量的设置，跟线程池大小的设置，应该是类似的，但是基于信号量的话，性能会好很多，而且 Hystrix 框架本身的开销会小很多。</p><p>默认值是 10，尽量设置的小一些，因为一旦设置的太大，而且有延时发生，可能瞬间导致 tomcat 本身的线程资源被占满。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter().withExecutionIsolationSemaphoreMaxConcurrentRequests(int value);</span><br></pre></td></tr></table></figure><h2 id="深入-Hystrix-执行时内部原理"><a href="#深入-Hystrix-执行时内部原理" class="headerlink" title="深入 Hystrix 执行时内部原理"></a>深入 Hystrix 执行时内部原理</h2><p>前面我们了解了 Hystrix 最基本的支持高可用的技术：<strong>资源隔离</strong> + <strong>限流</strong>。</p><ul><li>创建 command；</li><li>执行这个 command；</li><li>配置这个 command 对应的 group 和线程池。</li></ul><p>这里，我们要讲一下，你开始执行这个 command，调用了这个 command 的 execute() 方法之后，Hystrix 底层的执行流程和步骤以及原理是什么。</p><p>在讲解这个流程的过程中，我会带出来 Hystrix 其他的一些核心以及重要的功能。</p><p>这里是整个 8 大步骤的流程图，我会对每个步骤进行细致的讲解。学习的过程中，对照着这个流程图，相信思路会比较清晰。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/hystrix-process.png" alt="hystrix-process"></p><h3 id="步骤一：创建-command"><a href="#步骤一：创建-command" class="headerlink" title="步骤一：创建 command"></a>步骤一：创建 command</h3><p>一个 HystrixCommand 或 HystrixObservableCommand 对象，代表了对某个依赖服务发起的一次请求或者调用。创建的时候，可以在构造函数中传入任何需要的参数。</p><ul><li>HystrixCommand 主要用于仅仅会返回一个结果的调用。</li><li>HystrixObservableCommand 主要用于可能会返回多条结果的调用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建 HystrixCommand</span><br><span class="line">HystrixCommand hystrixCommand &#x3D; new HystrixCommand(arg1, arg2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建 HystrixObservableCommand</span><br><span class="line">HystrixObservableCommand hystrixObservableCommand &#x3D; new HystrixObservableCommand(arg1, arg2);</span><br></pre></td></tr></table></figure><h3 id="步骤二：调用-command-执行方法"><a href="#步骤二：调用-command-执行方法" class="headerlink" title="步骤二：调用 command 执行方法"></a>步骤二：调用 command 执行方法</h3><p>执行 command，就可以发起一次对依赖服务的调用。</p><p>要执行 command，可以在 4 个方法中选择其中的一个：execute()、queue()、observe()、toObservable()。</p><p>其中 execute() 和 queue() 方法仅仅对 HystrixCommand 适用。</p><ul><li>execute()：调用后直接 block 住，属于同步调用，直到依赖服务返回单条结果，或者抛出异常。</li><li>queue()：返回一个 Future，属于异步调用，后面可以通过 Future 获取单条结果。</li><li>observe()：订阅一个 Observable 对象，Observable 代表的是依赖服务返回的结果，获取到一个那个代表结果的 Observable 对象的拷贝对象。</li><li>toObservable()：返回一个 Observable 对象，如果我们订阅这个对象，就会执行 command 并且获取返回结果。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">K             value    &#x3D; hystrixCommand.execute();</span><br><span class="line">Future&lt;K&gt;     fValue   &#x3D; hystrixCommand.queue();</span><br><span class="line">Observable&lt;K&gt; oValue   &#x3D; hystrixObservableCommand.observe();</span><br><span class="line">Observable&lt;K&gt; toOValue &#x3D; hystrixObservableCommand.toObservable();</span><br></pre></td></tr></table></figure><p>execute() 实际上会调用 queue().get() 方法，可以看一下 Hystrix 源码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public R execute() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return queue().get();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw Exceptions.sneakyThrow(decomposeException(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 queue() 方法中，会调用 toObservable().toBlocking().toFuture()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Future&lt;R&gt; delegate &#x3D; toObservable().toBlocking().toFuture();</span><br></pre></td></tr></table></figure><p>也就是说，先通过 toObservable() 获得 Future 对象，然后调用 Future 的 get() 方法。那么，其实无论是哪种方式执行 command，最终都是依赖于 toObservable() 去执行的。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/hystrix-process.png" alt="hystrix-process"></p><h3 id="步骤三：检查是否开启缓存"><a href="#步骤三：检查是否开启缓存" class="headerlink" title="步骤三：检查是否开启缓存"></a>步骤三：检查是否开启缓存</h3><p>从这一步开始，就进入到 Hystrix 底层运行原理啦，看一下 Hystrix 一些更高级的功能和特性。</p><p>如果这个 command 开启了请求缓存 Request Cache，而且这个调用的结果在缓存中存在，那么直接从缓存中返回结果。否则，继续往后的步骤。</p><h3 id="步骤四：检查是否开启了断路器"><a href="#步骤四：检查是否开启了断路器" class="headerlink" title="步骤四：检查是否开启了断路器"></a>步骤四：检查是否开启了断路器</h3><p>检查这个 command 对应的依赖服务是否开启了断路器。如果断路器被打开了，那么 Hystrix 就不会执行这个 command，而是直接去执行 fallback 降级机制，返回降级结果。</p><h3 id="步骤五：检查线程池-队列-信号量是否已满"><a href="#步骤五：检查线程池-队列-信号量是否已满" class="headerlink" title="步骤五：检查线程池/队列/信号量是否已满"></a>步骤五：检查线程池/队列/信号量是否已满</h3><p>如果这个 command 线程池和队列已满，或者 semaphore 信号量已满，那么也不会执行 command，而是直接去调用 fallback 降级机制，同时发送 reject 信息给断路器统计。</p><h3 id="步骤六：执行-command"><a href="#步骤六：执行-command" class="headerlink" title="步骤六：执行 command"></a>步骤六：执行 command</h3><p>调用 HystrixObservableCommand 对象的 construct() 方法，或者 HystrixCommand 的 run() 方法来实际执行这个 command。</p><ul><li>HystrixCommand.run() 返回单条结果，或者抛出异常。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过command执行，获取最新一条商品数据</span><br><span class="line">ProductInfo productInfo &#x3D; getProductInfoCommand.execute();</span><br></pre></td></tr></table></figure><ul><li>HystrixObservableCommand.construct() 返回一个 Observable 对象，可以获取多条结果。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;ProductInfo&gt; observable &#x3D; getProductInfosCommand.observe();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 订阅获取多条结果</span><br><span class="line">observable.subscribe(new Observer&lt;ProductInfo&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCompleted() &#123;</span><br><span class="line">        System.out.println(&quot;获取完了所有的商品数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取完一条数据，就回调一次这个方法</span><br><span class="line">     * </span><br><span class="line">     * @param productInfo 商品信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(ProductInfo productInfo) &#123;</span><br><span class="line">        System.out.println(productInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果是采用线程池方式，并且 HystrixCommand.run() 或者 HystrixObservableCommand.construct() 的执行时间超过了 timeout 时长的话，那么 command 所在的线程会抛出一个 TimeoutException，这时会执行 fallback 降级机制，不会去管 run() 或 construct() 返回的值了。另一种情况，如果 command 执行出错抛出了其它异常，那么也会走 fallback 降级。这两种情况下，Hystrix 都会发送异常事件给断路器统计。</p><p><strong>注意</strong>，我们是不可能终止掉一个调用严重延迟的依赖服务的线程的，只能说给你抛出来一个 TimeoutException。</p><p>如果没有 timeout，也正常执行的话，那么调用线程就会拿到一些调用依赖服务获取到的结果，然后 Hystrix 也会做一些 logging 记录和 metric 度量统计。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/hystrix-process.png" alt="hystrix-process"></p><h3 id="步骤七：断路健康检查"><a href="#步骤七：断路健康检查" class="headerlink" title="步骤七：断路健康检查"></a>步骤七：断路健康检查</h3><p>Hystrix 会把每一个依赖服务的调用成功、失败、Reject、Timeout 等事件发送给 circuit breaker 断路器。断路器就会对这些事件的次数进行统计，根据异常事件发生的比例来决定是否要进行断路（熔断）。如果打开了断路器，那么在接下来一段时间内，会直接断路，返回降级结果。</p><p>如果在之后，断路器尝试执行 command，调用没有出错，返回了正常结果，那么 Hystrix 就会把断路器关闭。</p><h3 id="步骤八：调用-fallback-降级机制"><a href="#步骤八：调用-fallback-降级机制" class="headerlink" title="步骤八：调用 fallback 降级机制"></a>步骤八：调用 fallback 降级机制</h3><p>在以下几种情况中，Hystrix 会调用 fallback 降级机制。</p><ul><li>断路器处于打开状态；</li><li>线程池/队列/semaphore满了；</li><li>command 执行超时；</li><li>run() 或者 construct() 抛出异常。</li></ul><p>一般在降级机制中，都建议给出一些默认的返回值，比如静态的一些代码逻辑，或者从内存中的缓存中提取一些数据，在这里尽量不要再进行网络请求了。</p><p>在降级中，如果一定要进行网络调用的话，也应该将那个调用放在一个 HystrixCommand 中进行隔离。</p><ul><li>HystrixCommand 中，实现 getFallback() 方法，可以提供降级机制。</li><li>HystrixObservableCommand 中，实现 resumeWithFallback() 方法，返回一个 Observable 对象，可以提供降级结果。</li></ul><p>如果没有实现 fallback，或者 fallback 抛出了异常，Hystrix 会返回一个 Observable，但是不会返回任何数据。</p><p>不同的 command 执行方式，其 fallback 为空或者异常时的返回结果不同。</p><ul><li>对于 execute()，直接抛出异常。</li><li>对于 queue()，返回一个 Future，调用 get() 时抛出异常。</li><li>对于 observe()，返回一个 Observable 对象，但是调用 subscribe() 方法订阅它时，立即抛出调用者的 onError() 方法。</li><li>对于 toObservable()，返回一个 Observable 对象，但是调用 subscribe() 方法订阅它时，立即抛出调用者的 onError() 方法。</li></ul><h3 id="不同的执行方式"><a href="#不同的执行方式" class="headerlink" title="不同的执行方式"></a>不同的执行方式</h3><ul><li>execute()，获取一个 Future.get()，然后拿到单个结果。</li><li>queue()，返回一个 Future。</li><li>observe()，立即订阅 Observable，然后启动 8 大执行步骤，返回一个拷贝的 Observable，订阅时立即回调给你结果。</li><li>toObservable()，返回一个原始的 Observable，必须手动订阅才会去执行 8 大步骤。</li></ul><h2 id="基于-request-cache-请求缓存技术优化批量商品数据查询接口"><a href="#基于-request-cache-请求缓存技术优化批量商品数据查询接口" class="headerlink" title="基于 request cache 请求缓存技术优化批量商品数据查询接口"></a>基于 request cache 请求缓存技术优化批量商品数据查询接口</h2><p>Hystrix command 执行时 8 大步骤第三步，就是检查 Request cache 是否有缓存。</p><p>首先，有一个概念，叫做 Request Context 请求上下文，一般来说，在一个 web 应用中，如果我们用到了 Hystrix，我们会在一个 filter 里面，对每一个请求都施加一个请求上下文。就是说，每一次请求，就是一次请求上下文。然后在这次请求上下文中，我们会去执行 N 多代码，调用 N 多依赖服务，有的依赖服务可能还会调用好几次。</p><p>在一次请求上下文中，如果有多个 command，参数都是一样的，调用的接口也是一样的，而结果可以认为也是一样的。那么这个时候，我们可以让第一个 command 执行返回的结果缓存在内存中，然后这个请求上下文后续的其它对这个依赖的调用全部从内存中取出缓存结果就可以了。</p><p>这样的话，好处在于不用在一次请求上下文中反复多次执行一样的 command，<strong>避免重复执行网络请求，提升整个请求的性能</strong>。</p><p>举个栗子。比如说我们在一次请求上下文中，请求获取 productId 为 1 的数据，第一次缓存中没有，那么会从商品服务中获取数据，返回最新数据结果，同时将数据缓存在内存中。后续同一次请求上下文中，如果还有获取 productId 为 1 的数据的请求，直接从缓存中取就好了。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/hystrix-request-cache.png" alt="hystrix-request-cache"></p><p>HystrixCommand 和 HystrixObservableCommand 都可以指定一个缓存 key，然后 Hystrix 会自动进行缓存，接着在同一个 request context 内，再次访问的话，就会直接取用缓存。</p><p>下面，我们结合一个具体的<strong>业务场景</strong>，来看一下如何使用 request cache 请求缓存技术。当然，以下代码只作为一个基本的 Demo 而已。</p><p>现在，假设我们要做一个<strong>批量查询商品数据</strong>的接口，在这个里面，我们是用 HystrixCommand 一次性批量查询多个商品 id 的数据。但是这里有个问题，如果说 Nginx 在本地缓存失效了，重新获取一批缓存，传递过来的 productIds 都没有进行去重，比如 <code>productIds=1,1,1,2,2</code>，那么可能说，商品 id 出现了重复，如果按照我们之前的业务逻辑，可能就会重复对 productId=1 的商品查询三次，productId=2 的商品查询两次。</p><p>我们对批量查询商品数据的接口，可以用 request cache 做一个优化，就是说一次请求，就是一次 request context，对相同的商品查询只执行一次，其余重复的都走 request cache。</p><h3 id="实现-Hystrix-请求上下文过滤器并注册"><a href="#实现-Hystrix-请求上下文过滤器并注册" class="headerlink" title="实现 Hystrix 请求上下文过滤器并注册"></a>实现 Hystrix 请求上下文过滤器并注册</h3><p>定义 HystrixRequestContextFilter 类，实现 Filter 接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Hystrix 请求上下文过滤器</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HystrixRequestContextFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) &#123;</span><br><span class="line">        HystrixRequestContext context &#x3D; HystrixRequestContext.initializeContext();</span><br><span class="line">        try &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; catch (IOException | ServletException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            context.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将该 filter 对象注册到 SpringBoot Application 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class EshopApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(EshopApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean filterRegistrationBean() &#123;</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean &#x3D; new FilterRegistrationBean(new HystrixRequestContextFilter());</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(&quot;&#x2F;*&quot;);</span><br><span class="line">        return filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="command-重写-getCacheKey-方法"><a href="#command-重写-getCacheKey-方法" class="headerlink" title="command 重写 getCacheKey() 方法"></a>command 重写 getCacheKey() 方法</h3><p>在 GetProductInfoCommand 中，重写 getCacheKey() 方法，这样的话，每一次请求的结果，都会放在 Hystrix 请求上下文中。下一次同一个 productId 的数据请求，直接取缓存，无须再调用 run() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class GetProductInfoCommand extends HystrixCommand&lt;ProductInfo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Long productId;</span><br><span class="line"></span><br><span class="line">    private static final HystrixCommandKey KEY &#x3D; HystrixCommandKey.Factory.asKey(&quot;GetProductInfoCommand&quot;);</span><br><span class="line"></span><br><span class="line">    public GetProductInfoCommand(Long productId) &#123;</span><br><span class="line">        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ProductInfoService&quot;))</span><br><span class="line">                .andCommandKey(KEY));</span><br><span class="line">        this.productId &#x3D; productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected ProductInfo run() &#123;</span><br><span class="line">        String url &#x3D; &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;getProductInfo?productId&#x3D;&quot; + productId;</span><br><span class="line">        String response &#x3D; HttpClientUtils.sendGetRequest(url);</span><br><span class="line">        System.out.println(&quot;调用接口查询商品数据，productId&#x3D;&quot; + productId);</span><br><span class="line">        return JSONObject.parseObject(response, ProductInfo.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 每次请求的结果，都会放在Hystrix绑定的请求上下文上</span><br><span class="line">     *</span><br><span class="line">     * @return cacheKey 缓存key</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public String getCacheKey() &#123;</span><br><span class="line">        return &quot;product_info_&quot; + productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将某个商品id的缓存清空</span><br><span class="line">     *</span><br><span class="line">     * @param productId 商品id</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void flushCache(Long productId) &#123;</span><br><span class="line">        HystrixRequestCache.getInstance(KEY,</span><br><span class="line">                HystrixConcurrencyStrategyDefault.getInstance()).clear(&quot;product_info_&quot; + productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里写了一个 flushCache() 方法，用于我们开发手动删除缓存。</p><h3 id="controller-调用-command-查询商品信息"><a href="#controller-调用-command-查询商品信息" class="headerlink" title="controller 调用 command 查询商品信息"></a>controller 调用 command 查询商品信息</h3><p>在一次 web 请求上下文中，传入商品 id 列表，查询多条商品数据信息。对于每个 productId，都创建一个 command。</p><p>如果 id 列表没有去重，那么重复的 id，第二次查询的时候就会直接走缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class CacheController &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 一次性批量查询多条商品数据的请求</span><br><span class="line">     *</span><br><span class="line">     * @param productIds 以,分隔的商品id列表</span><br><span class="line">     * @return 响应状态</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;getProductInfos&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String getProductInfos(String productIds) &#123;</span><br><span class="line">        for (String productId : productIds.split(&quot;,&quot;)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 对每个productId，都创建一个command</span><br><span class="line">            GetProductInfoCommand getProductInfoCommand &#x3D; new GetProductInfoCommand(Long.valueOf(productId));</span><br><span class="line">            ProductInfo productInfo &#x3D; getProductInfoCommand.execute();</span><br><span class="line">            System.out.println(&quot;是否是从缓存中取的结果：&quot; + getProductInfoCommand.isResponseFromCache());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p>调用接口，查询多个商品的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;getProductInfos?productIds&#x3D;1,1,1,2,2,5</span><br></pre></td></tr></table></figure><p>在控制台，我们可以看到以下结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">调用接口查询商品数据，productId&#x3D;1</span><br><span class="line">是否是从缓存中取的结果：false</span><br><span class="line">是否是从缓存中取的结果：true</span><br><span class="line">是否是从缓存中取的结果：true</span><br><span class="line">调用接口查询商品数据，productId&#x3D;2</span><br><span class="line">是否是从缓存中取的结果：false</span><br><span class="line">是否是从缓存中取的结果：true</span><br><span class="line">调用接口查询商品数据，productId&#x3D;5</span><br><span class="line">是否是从缓存中取的结果：false</span><br></pre></td></tr></table></figure><p>第一次查询 productId=1 的数据，会调用接口进行查询，不是从缓存中取结果。而随后再出现查询 productId=1 的请求，就直接取缓存了，这样的话，效率明显高很多。</p><h3 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h3><p>我们写一个 UpdateProductInfoCommand，在更新商品信息之后，手动调用之前写的 flushCache()，手动将缓存删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class UpdateProductInfoCommand extends HystrixCommand&lt;Boolean&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Long productId;</span><br><span class="line"></span><br><span class="line">    public UpdateProductInfoCommand(Long productId) &#123;</span><br><span class="line">        super(HystrixCommandGroupKey.Factory.asKey(&quot;UpdateProductInfoGroup&quot;));</span><br><span class="line">        this.productId &#x3D; productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Boolean run() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里执行一次商品信息的更新</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 然后清空缓存</span><br><span class="line">        GetProductInfoCommand.flushCache(productId);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，以后查询该商品的请求，第一次就会走接口调用去查询最新的商品信息。</p><h2 id="基于本地缓存的-fallback-降级机制"><a href="#基于本地缓存的-fallback-降级机制" class="headerlink" title="基于本地缓存的 fallback 降级机制"></a>基于本地缓存的 fallback 降级机制</h2><p>Hystrix 出现以下四种情况，都会去调用 fallback 降级机制：</p><ul><li>断路器处于打开的状态。</li><li>资源池已满（线程池+队列 / 信号量）。</li><li>Hystrix 调用各种接口，或者访问外部依赖，比如 MySQL、Redis、Zookeeper、Kafka 等等，出现了任何异常的情况。</li><li>访问外部依赖的时候，访问时间过长，报了 TimeoutException 异常。</li></ul><h3 id="两种最经典的降级机制"><a href="#两种最经典的降级机制" class="headerlink" title="两种最经典的降级机制"></a>两种最经典的降级机制</h3><ul><li>纯内存数据<br>在降级逻辑中，你可以在内存中维护一个 ehcache，作为一个纯内存的基于 LRU 自动清理的缓存，让数据放在缓存内。如果说外部依赖有异常，fallback 这里直接尝试从 ehcache 中获取数据。</li><li>默认值<br>fallback 降级逻辑中，也可以直接返回一个默认值。</li></ul><p>在 <code>HystrixCommand</code>，降级逻辑的书写，是通过实现 getFallback() 接口；而在 <code>HystrixObservableCommand</code> 中，则是实现 resumeWithFallback() 方法。</p><p>现在，我们用一个简单的栗子，来演示 fallback 降级是怎么做的。</p><p>比如，有这么个<strong>场景</strong>。我们现在有个包含 brandId 的商品数据，假设正常的逻辑是这样：拿到一个商品数据，根据 brandId 去调用品牌服务的接口，获取品牌的最新名称 brandName。</p><p>假如说，品牌服务接口挂掉了，那么我们可以尝试从本地内存中，获取一份稍过期的数据，先凑合着用。</p><h3 id="步骤一：本地缓存获取数据"><a href="#步骤一：本地缓存获取数据" class="headerlink" title="步骤一：本地缓存获取数据"></a>步骤一：本地缓存获取数据</h3><p>本地获取品牌名称的代码大致如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 品牌名称本地缓存</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class BrandCache &#123;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;Long, String&gt; brandMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        brandMap.put(1L, &quot;Nike&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * brandId 获取 brandName</span><br><span class="line">     *</span><br><span class="line">     * @param brandId 品牌id</span><br><span class="line">     * @return 品牌名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String getBrandName(Long brandId) &#123;</span><br><span class="line">        return brandMap.get(brandId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="步骤二：实现-GetBrandNameCommand"><a href="#步骤二：实现-GetBrandNameCommand" class="headerlink" title="步骤二：实现 GetBrandNameCommand"></a>步骤二：实现 GetBrandNameCommand</h3><p>在 GetBrandNameCommand 中，run() 方法的正常逻辑是去调用品牌服务的接口获取到品牌名称，如果调用失败，报错了，那么就会去调用 fallback 降级机制。</p><p>这里，我们直接<strong>模拟接口调用报错</strong>，给它抛出个异常。</p><p>而在 getFallback() 方法中，就是我们的<strong>降级逻辑</strong>，我们直接从本地的缓存中，<strong>获取到品牌名称</strong>的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 获取品牌名称的command</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class GetBrandNameCommand extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Long brandId;</span><br><span class="line"></span><br><span class="line">    public GetBrandNameCommand(Long brandId) &#123;</span><br><span class="line">        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;BrandService&quot;))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;GetBrandNameCommand&quot;))</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                        &#x2F;&#x2F; 设置降级机制最大并发请求数</span><br><span class="line">                        .withFallbackIsolationSemaphoreMaxConcurrentRequests(15)));</span><br><span class="line">        this.brandId &#x3D; brandId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String run() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里正常的逻辑应该是去调用一个品牌服务的接口获取名称</span><br><span class="line">        &#x2F;&#x2F; 如果调用失败，报错了，那么就会去调用fallback降级机制</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这里我们直接模拟调用报错，抛出异常</span><br><span class="line">        throw new Exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String getFallback() &#123;</span><br><span class="line">        return BrandCache.getBrandName(brandId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FallbackIsolationSemaphoreMaxConcurrentRequests</code> 用于设置 fallback 最大允许的并发请求量，默认值是 10，是通过 semaphore 信号量的机制去限流的。如果超出了这个最大值，那么直接 reject。</p><h3 id="步骤三：CacheController-调用接口"><a href="#步骤三：CacheController-调用接口" class="headerlink" title="步骤三：CacheController 调用接口"></a>步骤三：CacheController 调用接口</h3><p>在 CacheController 中，我们通过 productInfo 获取 brandId，然后创建 GetBrandNameCommand 并执行，去尝试获取 brandName。这里执行会报错，因为我们在 run() 方法中直接抛出异常，Hystrix 就会去调用 getFallback() 方法走降级逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class CacheController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;getProductInfo&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String getProductInfo(Long productId) &#123;</span><br><span class="line">        HystrixCommand&lt;ProductInfo&gt; getProductInfoCommand &#x3D; new GetProductInfoCommand(productId);</span><br><span class="line"></span><br><span class="line">        ProductInfo productInfo &#x3D; getProductInfoCommand.execute();</span><br><span class="line">        Long brandId &#x3D; productInfo.getBrandId();</span><br><span class="line"></span><br><span class="line">        HystrixCommand&lt;String&gt; getBrandNameCommand &#x3D; new GetBrandNameCommand(brandId);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行会抛异常报错，然后走降级</span><br><span class="line">        String brandName &#x3D; getBrandNameCommand.execute();</span><br><span class="line">        productInfo.setBrandName(brandName);</span><br><span class="line"></span><br><span class="line">        System.out.println(productInfo);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于降级逻辑的演示，基本上就结束了。</p><h2 id="深入-Hystrix-断路器执行原理"><a href="#深入-Hystrix-断路器执行原理" class="headerlink" title="深入 Hystrix 断路器执行原理"></a>深入 Hystrix 断路器执行原理</h2><h3 id="RequestVolumeThreshold"><a href="#RequestVolumeThreshold" class="headerlink" title="RequestVolumeThreshold"></a>RequestVolumeThreshold</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">    .withCircuitBreakerRequestVolumeThreshold(int)</span><br></pre></td></tr></table></figure><p>表示在滑动窗口中，至少有多少个请求，才可能触发断路。</p><p>Hystrix 经过断路器的流量超过了一定的阈值，才有可能触发断路。比如说，要求在 10s 内经过断路器的流量必须达到 20 个，而实际经过断路器的流量才 10 个，那么根本不会去判断要不要断路。</p><h3 id="ErrorThresholdPercentage"><a href="#ErrorThresholdPercentage" class="headerlink" title="ErrorThresholdPercentage"></a>ErrorThresholdPercentage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">    .withCircuitBreakerErrorThresholdPercentage(int)</span><br></pre></td></tr></table></figure><p>表示异常比例达到多少，才会触发断路，默认值是 50(%)。</p><p>如果断路器统计到的异常调用的占比超过了一定的阈值，比如说在 10s 内，经过断路器的流量达到了 30 个，同时其中异常访问的数量也达到了一定的比例，比如 60% 的请求都是异常（报错 / 超时 / reject），就会开启断路。</p><h3 id="SleepWindowInMilliseconds"><a href="#SleepWindowInMilliseconds" class="headerlink" title="SleepWindowInMilliseconds"></a>SleepWindowInMilliseconds</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">    .withCircuitBreakerSleepWindowInMilliseconds(int)</span><br></pre></td></tr></table></figure><p>断路开启，也就是由 close 转换到 open 状态（close -&gt; open）。那么之后在 <code>SleepWindowInMilliseconds</code> 时间内，所有经过该断路器的请求全部都会被断路，不调用后端服务，直接走 fallback 降级机制。</p><p>而在该参数时间过后，断路器会变为 <code>half-open</code> 半开闭状态，尝试让一条请求经过断路器，看能不能正常调用。如果调用成功了，那么就自动恢复，断路器转为 close 状态。</p><h3 id="Enabled"><a href="#Enabled" class="headerlink" title="Enabled"></a>Enabled</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">    .withCircuitBreakerEnabled(boolean)</span><br></pre></td></tr></table></figure><p>控制是否允许断路器工作，包括跟踪依赖服务调用的健康状况，以及对异常情况过多时是否允许触发断路。默认值是 <code>true</code>。</p><h3 id="ForceOpen"><a href="#ForceOpen" class="headerlink" title="ForceOpen"></a>ForceOpen</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">    .withCircuitBreakerForceOpen(boolean)</span><br></pre></td></tr></table></figure><p>如果设置为 true 的话，直接强迫打开断路器，相当于是手动断路了，手动降级，默认值是 <code>false</code>。</p><h3 id="ForceClosed"><a href="#ForceClosed" class="headerlink" title="ForceClosed"></a>ForceClosed</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">    .withCircuitBreakerForceClosed(boolean)</span><br></pre></td></tr></table></figure><p>如果设置为 true，直接强迫关闭断路器，相当于手动停止断路了，手动升级，默认值是 <code>false</code>。</p><h2 id="实例-Demo"><a href="#实例-Demo" class="headerlink" title="实例 Demo"></a>实例 Demo</h2><h3 id="HystrixCommand-配置参数"><a href="#HystrixCommand-配置参数" class="headerlink" title="HystrixCommand 配置参数"></a>HystrixCommand 配置参数</h3><p>在 GetProductInfoCommand 中配置 Setter 断路器相关参数。</p><ul><li>滑动窗口中，最少 20 个请求，才可能触发断路。</li><li>异常比例达到 40% 时，才触发断路。</li><li>断路后 3000ms 内，所有请求都被 reject，直接走 fallback 降级，不会调用 run() 方法。3000ms 过后，变为 half-open 状态。</li></ul><p>run() 方法中，我们判断一下 productId 是否为 -1，是的话，直接抛出异常。这么写，我们之后测试的时候就可以传入 productId=-1，<strong>模拟服务执行异常</strong>了。</p><p>在降级逻辑中，我们直接给它返回降级商品就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class GetProductInfoCommand extends HystrixCommand&lt;ProductInfo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Long productId;</span><br><span class="line"></span><br><span class="line">    private static final HystrixCommandKey KEY &#x3D; HystrixCommandKey.Factory.asKey(&quot;GetProductInfoCommand&quot;);</span><br><span class="line"></span><br><span class="line">    public GetProductInfoCommand(Long productId) &#123;</span><br><span class="line">        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ProductInfoService&quot;))</span><br><span class="line">                .andCommandKey(KEY)</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                        &#x2F;&#x2F; 是否允许断路器工作</span><br><span class="line">                        .withCircuitBreakerEnabled(true)</span><br><span class="line">                        &#x2F;&#x2F; 滑动窗口中，最少有多少个请求，才可能触发断路</span><br><span class="line">                        .withCircuitBreakerRequestVolumeThreshold(20)</span><br><span class="line">                        &#x2F;&#x2F; 异常比例达到多少，才触发断路，默认50%</span><br><span class="line">                        .withCircuitBreakerErrorThresholdPercentage(40)</span><br><span class="line">                        &#x2F;&#x2F; 断路后多少时间内直接reject请求，之后进入half-open状态，默认5000ms</span><br><span class="line">                        .withCircuitBreakerSleepWindowInMilliseconds(3000)));</span><br><span class="line">        this.productId &#x3D; productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected ProductInfo run() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;调用接口查询商品数据，productId&#x3D;&quot; + productId);</span><br><span class="line"></span><br><span class="line">        if (productId &#x3D;&#x3D; -1L) &#123;</span><br><span class="line">            throw new Exception();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String url &#x3D; &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;getProductInfo?productId&#x3D;&quot; + productId;</span><br><span class="line">        String response &#x3D; HttpClientUtils.sendGetRequest(url);</span><br><span class="line">        return JSONObject.parseObject(response, ProductInfo.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected ProductInfo getFallback() &#123;</span><br><span class="line">        ProductInfo productInfo &#x3D; new ProductInfo();</span><br><span class="line">        productInfo.setName(&quot;降级商品&quot;);</span><br><span class="line">        return productInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="断路测试类"><a href="#断路测试类" class="headerlink" title="断路测试类"></a>断路测试类</h3><p>我们在测试类中，前 30 次请求，传入 productId=-1，然后休眠 3s，之后 70 次请求，传入 productId=1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class CircuitBreakerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testCircuitBreaker() &#123;</span><br><span class="line">        String baseURL &#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;getProductInfo?productId&#x3D;&quot;;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; ++i) &#123;</span><br><span class="line">            &#x2F;&#x2F; 传入-1，会抛出异常，然后走降级逻辑</span><br><span class="line">            HttpClientUtils.sendGetRequest(baseURL + &quot;-1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeUtils.sleep(3);</span><br><span class="line">        System.out.println(&quot;After sleeping...&quot;);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 31; i &lt; 100; ++i) &#123;</span><br><span class="line">            &#x2F;&#x2F; 传入1，走服务正常调用</span><br><span class="line">            HttpClientUtils.sendGetRequest(baseURL + &quot;1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>测试结果，我们可以明显看出系统断路与恢复的整个过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">调用接口查询商品数据，productId&#x3D;-1</span><br><span class="line">ProductInfo(id&#x3D;null, name&#x3D;降级商品, price&#x3D;null, pictureList&#x3D;null, specification&#x3D;null, service&#x3D;null, color&#x3D;null, size&#x3D;null, shopId&#x3D;null, modifiedTime&#x3D;null, cityId&#x3D;null, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#x2F;&#x2F; 这里重复打印了 20 次上面的结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ProductInfo(id&#x3D;null, name&#x3D;降级商品, price&#x3D;null, pictureList&#x3D;null, specification&#x3D;null, service&#x3D;null, color&#x3D;null, size&#x3D;null, shopId&#x3D;null, modifiedTime&#x3D;null, cityId&#x3D;null, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#x2F;&#x2F; 这里重复打印了 8 次上面的结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 休眠 3s 后</span><br><span class="line">调用接口查询商品数据，productId&#x3D;1</span><br><span class="line">ProductInfo(id&#x3D;1, name&#x3D;iphone7手机, price&#x3D;5599.0, pictureList&#x3D;a.jpg,b.jpg, specification&#x3D;iphone7的规格, service&#x3D;iphone7的售后服务, color&#x3D;红色,白色,黑色, size&#x3D;5.5, shopId&#x3D;1, modifiedTime&#x3D;2017-01-01 12:00:00, cityId&#x3D;1, cityName&#x3D;null, brandId&#x3D;1, brandName&#x3D;null)</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#x2F;&#x2F; 这里重复打印了 69 次上面的结果</span><br></pre></td></tr></table></figure><p>前 30 次请求，我们传入的 productId 为 -1，所以服务执行过程中会抛出异常。我们设置了最少 20 次请求通过断路器并且异常比例超出 40% 就触发断路。因此执行了 21 次接口调用，每次都抛异常并且走降级，21 次过后，断路器就被打开了。</p><p>之后的 9 次请求，都不会执行 run() 方法，也就不会打印以下信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用接口查询商品数据，productId&#x3D;-1</span><br></pre></td></tr></table></figure><p>而是直接走降级逻辑，调用 getFallback() 执行。</p><p>休眠了 3s 后，我们在之后的 70 次请求中，都传入 productId 为 1。由于我们前面设置了 3000ms 过后断路器变为 <code>half-open</code> 状态。因此 Hystrix 会尝试执行请求，发现成功了，那么断路器关闭，之后的所有请求也都能正常调用了。</p><h2 id="深入-Hystrix-线程池隔离与接口限流"><a href="#深入-Hystrix-线程池隔离与接口限流" class="headerlink" title="深入 Hystrix 线程池隔离与接口限流"></a>深入 Hystrix 线程池隔离与接口限流</h2><p>前面讲了 Hystrix 的 request cache 请求缓存、fallback 优雅降级、circuit breaker 断路器快速熔断，这一讲，我们来详细说说 Hystrix 的线程池隔离与接口限流。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/hystrix-process.png" alt="hystrix-process"></p><p>Hystrix 通过判断线程池或者信号量是否已满，超出容量的请求，直接 Reject 走降级，从而达到限流的作用。</p><p>限流是限制对后端的服务的访问量，比如说你对 MySQL、Redis、Zookeeper 以及其它各种后端中间件的资源的访问的限制，其实是为了避免过大的流量直接打死后端的服务。</p><h3 id="线程池隔离技术的设计"><a href="#线程池隔离技术的设计" class="headerlink" title="线程池隔离技术的设计"></a>线程池隔离技术的设计</h3><p>Hystrix 采用了 Bulkhead Partition 舱壁隔离技术，来将外部依赖进行资源隔离，进而避免任何外部依赖的故障导致本服务崩溃。</p><p><strong>舱壁隔离</strong>，是说将船体内部空间区隔划分成若干个隔舱，一旦某几个隔舱发生破损进水，水流不会在其间相互流动，如此一来船舶在受损时，依然能具有足够的浮力和稳定性，进而减低立即沉船的危险。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/bulkhead-partition.jpg" alt="bulkhead-partition"></p><p>Hystrix 对每个外部依赖用一个单独的线程池，这样的话，如果对那个外部依赖调用延迟很严重，最多就是耗尽那个依赖自己的线程池而已，不会影响其他的依赖调用。</p><h3 id="Hystrix-应用线程池机制的场景"><a href="#Hystrix-应用线程池机制的场景" class="headerlink" title="Hystrix 应用线程池机制的场景"></a>Hystrix 应用线程池机制的场景</h3><ul><li>每个服务都会调用几十个后端依赖服务，那些后端依赖服务通常是由很多不同的团队开发的。</li><li>每个后端依赖服务都会提供它自己的 client 调用库，比如说用 thrift 的话，就会提供对应的 thrift 依赖。</li><li>client 调用库随时会变更。</li><li>client 调用库随时可能会增加新的网络请求的逻辑。</li><li>client 调用库可能会包含诸如自动重试、数据解析、内存中缓存等逻辑。</li><li>client 调用库一般都对调用者来说是个黑盒，包括实现细节、网络访问、默认配置等等。</li><li>在真实的生产环境中，经常会出现调用者，突然间惊讶的发现，client 调用库发生了某些变化。</li><li>即使 client 调用库没有改变，依赖服务本身可能有会发生逻辑上的变化。</li><li>有些依赖的 client 调用库可能还会拉取其他的依赖库，而且可能那些依赖库配置的不正确。</li><li>大多数网络请求都是同步调用的。</li><li>调用失败和延迟，也有可能会发生在 client 调用库本身的代码中，不一定就是发生在网络请求中。</li></ul><p>简单来说，就是你必须默认 client 调用库很不靠谱，而且随时可能发生各种变化，所以就要用强制隔离的方式来确保任何服务的故障不会影响当前服务。</p><h3 id="线程池机制的优点"><a href="#线程池机制的优点" class="headerlink" title="线程池机制的优点"></a>线程池机制的优点</h3><ul><li>任何一个依赖服务都可以被隔离在自己的线程池内，即使自己的线程池资源填满了，也不会影响任何其他的服务调用。</li><li>服务可以随时引入一个新的依赖服务，因为即使这个新的依赖服务有问题，也不会影响其他任何服务的调用。</li><li>当一个故障的依赖服务重新变好的时候，可以通过清理掉线程池，瞬间恢复该服务的调用，而如果是 tomcat 线程池被占满，再恢复就很麻烦。</li><li>如果一个 client 调用库配置有问题，线程池的健康状况随时会报告，比如成功/失败/拒绝/超时的次数统计，然后可以近实时热修改依赖服务的调用配置，而不用停机。</li><li>基于线程池的异步本质，可以在同步的调用之上，构建一层异步调用层。</li></ul><p>简单来说，最大的好处，就是资源隔离，确保说任何一个依赖服务故障，不会拖垮当前的这个服务。</p><h3 id="线程池机制的缺点"><a href="#线程池机制的缺点" class="headerlink" title="线程池机制的缺点"></a>线程池机制的缺点</h3><ul><li>线程池机制最大的缺点就是增加了 CPU 的开销。<br>除了 tomcat 本身的调用线程之外，还有 Hystrix 自己管理的线程池。</li><li>每个 command 的执行都依托一个独立的线程，会进行排队，调度，还有上下文切换。</li><li>Hystrix 官方自己做了一个多线程异步带来的额外开销统计，通过对比多线程异步调用+同步调用得出，Netflix API 每天通过 Hystrix 执行 10 亿次调用，每个服务实例有 40 个以上的线程池，每个线程池有 10 个左右的线程。）最后发现说，用 Hystrix 的额外开销，就是给请求带来了 3ms 左右的延时，最多延时在 10ms 以内，相比于可用性和稳定性的提升，这是可以接受的。</li></ul><p>我们可以用 Hystrix semaphore 技术来实现对某个依赖服务的并发访问量的限制，而不是通过线程池/队列的大小来限制流量。</p><p>semaphore 技术可以用来限流和削峰，但是不能用来对调研延迟的服务进行 timeout 和隔离。</p><p><code>execution.isolation.strategy</code> 设置为 <code>SEMAPHORE</code>，那么 Hystrix 就会用 semaphore 机制来替代线程池机制，来对依赖服务的访问进行限流。如果通过 semaphore 调用的时候，底层的网络调用延迟很严重，那么是无法 timeout 的，只能一直 block 住。一旦请求数量超过了 semaphore 限定的数量之后，就会立即开启限流。</p><h3 id="接口限流-Demo"><a href="#接口限流-Demo" class="headerlink" title="接口限流 Demo"></a>接口限流 Demo</h3><p>假设一个线程池大小为 8，等待队列的大小为 10。timeout 时长我们设置长一些，20s。</p><p>在 command 内部，写死代码，做一个 sleep，比如 sleep 3s。</p><ul><li>withCoreSize：设置线程池大小。</li><li>withMaxQueueSize：设置等待队列大小。</li><li>withQueueSizeRejectionThreshold：这个与 withMaxQueueSize 配合使用，等待队列的大小，取得是这两个参数的较小值。</li></ul><p>如果只设置了线程池大小，另外两个 queue 相关参数没有设置的话，等待队列是处于关闭的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class GetProductInfoCommand extends HystrixCommand&lt;ProductInfo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Long productId;</span><br><span class="line"></span><br><span class="line">    private static final HystrixCommandKey KEY &#x3D; HystrixCommandKey.Factory.asKey(&quot;GetProductInfoCommand&quot;);</span><br><span class="line"></span><br><span class="line">    public GetProductInfoCommand(Long productId) &#123;</span><br><span class="line">        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ProductInfoService&quot;))</span><br><span class="line">                .andCommandKey(KEY)</span><br><span class="line">                &#x2F;&#x2F; 线程池相关配置信息</span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        &#x2F;&#x2F; 设置线程池大小为8</span><br><span class="line">                        .withCoreSize(8)</span><br><span class="line">                        &#x2F;&#x2F; 设置等待队列大小为10</span><br><span class="line">                        .withMaxQueueSize(10)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(12))</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                        .withCircuitBreakerEnabled(true)</span><br><span class="line">                        .withCircuitBreakerRequestVolumeThreshold(20)</span><br><span class="line">                        .withCircuitBreakerErrorThresholdPercentage(40)</span><br><span class="line">                        .withCircuitBreakerSleepWindowInMilliseconds(3000)</span><br><span class="line">                        &#x2F;&#x2F; 设置超时时间</span><br><span class="line">                        .withExecutionTimeoutInMilliseconds(20000)</span><br><span class="line">                        &#x2F;&#x2F; 设置fallback最大请求并发数</span><br><span class="line">                        .withFallbackIsolationSemaphoreMaxConcurrentRequests(30)));</span><br><span class="line">        this.productId &#x3D; productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected ProductInfo run() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;调用接口查询商品数据，productId&#x3D;&quot; + productId);</span><br><span class="line"></span><br><span class="line">        if (productId &#x3D;&#x3D; -1L) &#123;</span><br><span class="line">            throw new Exception();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 请求过来，会在这里hang住3秒钟</span><br><span class="line">        if (productId &#x3D;&#x3D; -2L) &#123;</span><br><span class="line">            TimeUtils.sleep(3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String url &#x3D; &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;getProductInfo?productId&#x3D;&quot; + productId;</span><br><span class="line">        String response &#x3D; HttpClientUtils.sendGetRequest(url);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">        return JSONObject.parseObject(response, ProductInfo.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected ProductInfo getFallback() &#123;</span><br><span class="line">        ProductInfo productInfo &#x3D; new ProductInfo();</span><br><span class="line">        productInfo.setName(&quot;降级商品&quot;);</span><br><span class="line">        return productInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们模拟 25 个请求。前 8 个请求，调用接口时会直接被 hang 住 3s，那么后面的 10 个请求会先进入等待队列中等待前面的请求执行完毕。最后的 7 个请求过来，会直接被 reject，调用 fallback 降级逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class RejectTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testReject() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 25; ++i) &#123;</span><br><span class="line">            new Thread(() -&gt; HttpClientUtils.sendGetRequest(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;getProductInfo?productId&#x3D;-2&quot;)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 防止主线程提前结束执行</span><br><span class="line">        TimeUtils.sleep(50);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从执行结果中，我们可以明显看出一共打印出了 7 个降级商品。这也就是请求数超过线程池+队列的数量而直接被 reject 的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ProductInfo(id&#x3D;null, name&#x3D;降级商品, price&#x3D;null, pictureList&#x3D;null, specification&#x3D;null, service&#x3D;null, color&#x3D;null, size&#x3D;null, shopId&#x3D;null, modifiedTime&#x3D;null, cityId&#x3D;null, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">ProductInfo(id&#x3D;null, name&#x3D;降级商品, price&#x3D;null, pictureList&#x3D;null, specification&#x3D;null, service&#x3D;null, color&#x3D;null, size&#x3D;null, shopId&#x3D;null, modifiedTime&#x3D;null, cityId&#x3D;null, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">ProductInfo(id&#x3D;null, name&#x3D;降级商品, price&#x3D;null, pictureList&#x3D;null, specification&#x3D;null, service&#x3D;null, color&#x3D;null, size&#x3D;null, shopId&#x3D;null, modifiedTime&#x3D;null, cityId&#x3D;null, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">ProductInfo(id&#x3D;null, name&#x3D;降级商品, price&#x3D;null, pictureList&#x3D;null, specification&#x3D;null, service&#x3D;null, color&#x3D;null, size&#x3D;null, shopId&#x3D;null, modifiedTime&#x3D;null, cityId&#x3D;null, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">ProductInfo(id&#x3D;null, name&#x3D;降级商品, price&#x3D;null, pictureList&#x3D;null, specification&#x3D;null, service&#x3D;null, color&#x3D;null, size&#x3D;null, shopId&#x3D;null, modifiedTime&#x3D;null, cityId&#x3D;null, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">ProductInfo(id&#x3D;null, name&#x3D;降级商品, price&#x3D;null, pictureList&#x3D;null, specification&#x3D;null, service&#x3D;null, color&#x3D;null, size&#x3D;null, shopId&#x3D;null, modifiedTime&#x3D;null, cityId&#x3D;null, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">调用接口查询商品数据，productId&#x3D;-2</span><br><span class="line">调用接口查询商品数据，productId&#x3D;-2</span><br><span class="line">调用接口查询商品数据，productId&#x3D;-2</span><br><span class="line">调用接口查询商品数据，productId&#x3D;-2</span><br><span class="line">调用接口查询商品数据，productId&#x3D;-2</span><br><span class="line">调用接口查询商品数据，productId&#x3D;-2</span><br><span class="line">调用接口查询商品数据，productId&#x3D;-2</span><br><span class="line">调用接口查询商品数据，productId&#x3D;-2</span><br><span class="line">ProductInfo(id&#x3D;null, name&#x3D;降级商品, price&#x3D;null, pictureList&#x3D;null, specification&#x3D;null, service&#x3D;null, color&#x3D;null, size&#x3D;null, shopId&#x3D;null, modifiedTime&#x3D;null, cityId&#x3D;null, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">&#123;&quot;id&quot;: -2, &quot;name&quot;: &quot;iphone7手机&quot;, &quot;price&quot;: 5599, &quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;, &quot;specification&quot;: &quot;iphone7的规格&quot;, &quot;service&quot;: &quot;iphone7的售后服务&quot;, &quot;color&quot;: &quot;红色,白色,黑色&quot;, &quot;size&quot;: &quot;5.5&quot;, &quot;shopId&quot;: 1, &quot;modifiedTime&quot;: &quot;2017-01-01 12:00:00&quot;, &quot;cityId&quot;: 1, &quot;brandId&quot;: 1&#125;</span><br><span class="line">&#x2F;&#x2F; 后面都是一些正常的商品信息，就不贴出来了</span><br><span class="line">&#x2F;&#x2F;...</span><br></pre></td></tr></table></figure><h2 id="基于-timeout-机制为服务接口调用超时提供安全保护"><a href="#基于-timeout-机制为服务接口调用超时提供安全保护" class="headerlink" title="基于 timeout 机制为服务接口调用超时提供安全保护"></a>基于 timeout 机制为服务接口调用超时提供安全保护</h2><p>一般来说，在调用依赖服务的接口的时候，比较常见的一个问题就是<strong>超时</strong>。超时是在一个复杂的分布式系统中，导致系统不稳定，或者系统抖动。出现大量超时，线程资源会被 hang 死，从而导致吞吐量大幅度下降，甚至服务崩溃。</p><p>你去调用各种各样的依赖服务，特别是在大公司，你甚至都不认识开发一个服务的人，你都不知道那个人的技术水平怎么样，对那个人根本不了解。</p><p>Peter Steiner 说过，”<a href="https://en.wikipedia.org/wiki/On_the_Internet,_nobody_knows_you' target=" _blank" rel="noopener" re_a_dog">On the Internet, nobody knows you’re a dog</a>“，也就是说在互联网的另外一头，你都不知道甚至坐着一条狗。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/220px-Internet_dog.jpg" alt="220px-Internet_dog.jpg"></p><p>像特别复杂的分布式系统，特别是在大公司里，多个团队、大型协作，你可能都不知道服务是谁的，很可能说开发服务的那个哥儿们甚至是一个实习生。依赖服务的接口性能可能很不稳定，有时候 2ms，有时候 200ms，甚至 2s，都有可能。</p><p>如果你不对各种依赖服务接口的调用做超时控制，来给你的服务提供安全保护措施，那么很可能你的服务就被各种垃圾的依赖服务的性能给拖死了。大量的接口调用很慢，大量的线程被卡死。如果你做了资源的隔离，那么也就是线程池的线程被卡死，但其实我们可以做超时控制，没必要让它们全卡死。</p><h3 id="TimeoutMilliseconds"><a href="#TimeoutMilliseconds" class="headerlink" title="TimeoutMilliseconds"></a>TimeoutMilliseconds</h3><p>在 Hystrix 中，我们可以手动设置 timeout 时长，如果一个 command 运行时间超过了设定的时长，那么就被认为是 timeout，然后 Hystrix command 标识为 timeout，同时执行 fallback 降级逻辑。</p><p><code>TimeoutMilliseconds</code> 默认值是 1000，也就是 1000ms。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">    ..withExecutionTimeoutInMilliseconds(int)</span><br></pre></td></tr></table></figure><h3 id="TimeoutEnabled"><a href="#TimeoutEnabled" class="headerlink" title="TimeoutEnabled"></a>TimeoutEnabled</h3><p>这个参数用于控制是否要打开 timeout 机制，默认值是 true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HystrixCommandProperties.Setter()</span><br><span class="line">    .withExecutionTimeoutEnabled(boolean)</span><br></pre></td></tr></table></figure><h2 id="实例-Demo-1"><a href="#实例-Demo-1" class="headerlink" title="实例 Demo"></a>实例 Demo</h2><p>我们在 command 中，将超时时间设置为 500ms，然后在 run() 方法中，设置休眠时间 1s，这样一个请求过来，直接休眠 1s，结果就会因为超时而执行降级逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class GetProductInfoCommand extends HystrixCommand&lt;ProductInfo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Long productId;</span><br><span class="line"></span><br><span class="line">    private static final HystrixCommandKey KEY &#x3D; HystrixCommandKey.Factory.asKey(&quot;GetProductInfoCommand&quot;);</span><br><span class="line"></span><br><span class="line">    public GetProductInfoCommand(Long productId) &#123;</span><br><span class="line">        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ProductInfoService&quot;))</span><br><span class="line">                .andCommandKey(KEY)</span><br><span class="line">                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                        .withCoreSize(8)</span><br><span class="line">                        .withMaxQueueSize(10)</span><br><span class="line">                        .withQueueSizeRejectionThreshold(8))</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                        .withCircuitBreakerEnabled(true)</span><br><span class="line">                        .withCircuitBreakerRequestVolumeThreshold(20)</span><br><span class="line">                        .withCircuitBreakerErrorThresholdPercentage(40)</span><br><span class="line">                        .withCircuitBreakerSleepWindowInMilliseconds(3000)</span><br><span class="line">                        &#x2F;&#x2F; 设置是否打开超时，默认是true</span><br><span class="line">                        .withExecutionTimeoutEnabled(true)</span><br><span class="line">                        &#x2F;&#x2F; 设置超时时间，默认1000(ms)</span><br><span class="line">                        .withExecutionTimeoutInMilliseconds(500)</span><br><span class="line">                        .withFallbackIsolationSemaphoreMaxConcurrentRequests(30)));</span><br><span class="line">        this.productId &#x3D; productId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected ProductInfo run() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;调用接口查询商品数据，productId&#x3D;&quot; + productId);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 休眠1s</span><br><span class="line">        TimeUtils.sleep(1);</span><br><span class="line"></span><br><span class="line">        String url &#x3D; &quot;http:&#x2F;&#x2F;localhost:8081&#x2F;getProductInfo?productId&#x3D;&quot; + productId;</span><br><span class="line">        String response &#x3D; HttpClientUtils.sendGetRequest(url);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">        return JSONObject.parseObject(response, ProductInfo.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected ProductInfo getFallback() &#123;</span><br><span class="line">        ProductInfo productInfo &#x3D; new ProductInfo();</span><br><span class="line">        productInfo.setName(&quot;降级商品&quot;);</span><br><span class="line">        return productInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中，我们直接发起请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class TimeoutTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testTimeout() &#123;</span><br><span class="line">        HttpClientUtils.sendGetRequest(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;getProductInfo?productId&#x3D;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果中可以看到，打印出了降级商品相关信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProductInfo(id&#x3D;null, name&#x3D;降级商品, price&#x3D;null, pictureList&#x3D;null, specification&#x3D;null, service&#x3D;null, color&#x3D;null, size&#x3D;null, shopId&#x3D;null, modifiedTime&#x3D;null, cityId&#x3D;null, cityName&#x3D;null, brandId&#x3D;null, brandName&#x3D;null)</span><br><span class="line">&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iphone7手机&quot;, &quot;price&quot;: 5599, &quot;pictureList&quot;:&quot;a.jpg,b.jpg&quot;, &quot;specification&quot;: &quot;iphone7的规格&quot;, &quot;service&quot;: &quot;iphone7的售后服务&quot;, &quot;color&quot;: &quot;红色,白色,黑色&quot;, &quot;size&quot;: &quot;5.5&quot;, &quot;shopId&quot;: 1, &quot;modifiedTime&quot;: &quot;2017-01-01 12:00:00&quot;, &quot;cityId&quot;: 1, &quot;brandId&quot;: 1&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 汇总 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dubbo的负载均衡</title>
      <link href="/2021/01/30/dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2021/01/30/dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>dubbo 负载均衡策略和集群容错策略都有哪些？动态代理策略呢？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>继续深问吧，这些都是用 dubbo 必须知道的一些东西，你得知道基本原理，知道序列化是什么协议，还得知道具体用 dubbo 的时候，如何负载均衡，如何高可用，如何动态代理。</p><p>说白了，就是看你对 dubbo 熟悉不熟悉：</p><ul><li>dubbo 工作原理：服务注册、注册中心、消费者、代理通信、负载均衡；</li><li>网络通信、序列化：dubbo 协议、长连接、NIO、hessian 序列化协议；</li><li>负载均衡策略、集群容错策略、动态代理策略：dubbo 跑起来的时候一些功能是如何运转的？怎么做负载均衡？怎么做集群容错？怎么生成动态代理？</li><li>dubbo SPI 机制：你了解不了解 dubbo 的 SPI 机制？如何基于 SPI 机制对 dubbo 进行扩展？</li></ul><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><h3 id="dubbo-负载均衡策略"><a href="#dubbo-负载均衡策略" class="headerlink" title="dubbo 负载均衡策略"></a>dubbo 负载均衡策略</h3><h4 id="random-loadbalance"><a href="#random-loadbalance" class="headerlink" title="random loadbalance"></a>random loadbalance</h4><p>默认情况下，dubbo 是 random load balance ，即<strong>随机</strong>调用实现负载均衡，可以对 provider 不同实例<strong>设置不同的权重</strong>，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。</p><h4 id="roundrobin-loadbalance"><a href="#roundrobin-loadbalance" class="headerlink" title="roundrobin loadbalance"></a>roundrobin loadbalance</h4><p>这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。</p><p>举个栗子。</p><p>跟运维同学申请机器，有的时候，我们运气好，正好公司资源比较充足，刚刚有一批热气腾腾、刚刚做好的虚拟机新鲜出炉，配置都比较高：8 核 + 16G 机器，申请到 2 台。过了一段时间，我们感觉 2 台机器有点不太够，我就去找运维同学说，“哥儿们，你能不能再给我一台机器”，但是这时只剩下一台 4 核 + 8G 的机器。我要还是得要。</p><p>这个时候，可以给两台 8 核 16G 的机器设置权重 4，给剩余 1 台 4 核 8G 的机器设置权重 2。</p><h4 id="leastactive-loadbalance"><a href="#leastactive-loadbalance" class="headerlink" title="leastactive loadbalance"></a>leastactive loadbalance</h4><p>这个就是自动感知一下，如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给<strong>不活跃的性能差的机器更少的请求</strong>。</p><h4 id="consistanthash-loadbalance"><a href="#consistanthash-loadbalance" class="headerlink" title="consistanthash loadbalance"></a>consistanthash loadbalance</h4><p>一致性 Hash 算法，相同参数的请求一定分发到一个 provider 上去，provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。<strong>如果你需要的不是随机负载均衡</strong>，是要一类请求都到一个节点，那就走这个一致性 Hash 策略。</p><h3 id="dubbo-集群容错策略"><a href="#dubbo-集群容错策略" class="headerlink" title="dubbo 集群容错策略"></a>dubbo 集群容错策略</h3><h4 id="failover-cluster-模式"><a href="#failover-cluster-模式" class="headerlink" title="failover cluster 模式"></a>failover cluster 模式</h4><p>失败自动切换，自动重试其他机器，<strong>默认</strong>就是这个，常见于读操作。（失败重试其它机器）</p><p>可以通过以下几种方式配置重试次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service retries&#x3D;&quot;2&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference retries&#x3D;&quot;2&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference&gt;</span><br><span class="line">    &lt;dubbo:method name&#x3D;&quot;findFoo&quot; retries&#x3D;&quot;2&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dubbo:reference&gt;</span><br></pre></td></tr></table></figure><h4 id="failfast-cluster-模式"><a href="#failfast-cluster-模式" class="headerlink" title="failfast cluster 模式"></a>failfast cluster 模式</h4><p>一次调用失败就立即失败，常见于非幂等性的写操作，比如新增一条记录（调用失败就立即失败）</p><h4 id="failsafe-cluster-模式"><a href="#failsafe-cluster-模式" class="headerlink" title="failsafe cluster 模式"></a>failsafe cluster 模式</h4><p>出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。</p><p>配置示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service cluster&#x3D;&quot;failsafe&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference cluster&#x3D;&quot;failsafe&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h4 id="failback-cluster-模式"><a href="#failback-cluster-模式" class="headerlink" title="failback cluster 模式"></a>failback cluster 模式</h4><p>失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。</p><h4 id="forking-cluster-模式"><a href="#forking-cluster-模式" class="headerlink" title="forking cluster 模式"></a>forking cluster 模式</h4><p><strong>并行调用</strong>多个 provider，只要一个成功就立即返回。常用于实时性要求比较高的读操作，但是会浪费更多的服务资源，可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</p><h4 id="broadcacst-cluster"><a href="#broadcacst-cluster" class="headerlink" title="broadcacst cluster"></a>broadcacst cluster</h4><p>逐个调用所有的 provider。任何一个 provider 出错则报错（从<code>2.1.0</code> 版本开始支持）。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><h3 id="dubbo动态代理策略"><a href="#dubbo动态代理策略" class="headerlink" title="dubbo动态代理策略"></a>dubbo动态代理策略</h3><p>默认使用 javassist 动态字节码生成，创建代理类。但是可以通过 spi 扩展机制配置自己的动态代理策略。</p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dubbo的序列化协议</title>
      <link href="/2021/01/30/dubbo%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/01/30/dubbo%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>dubbo 支持哪些通信协议？支持哪些序列化协议？说一下 Hessian 的数据结构？PB 知道吗？为什么 PB 的效率是最高的？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>上一个问题，说说 dubbo 的基本工作原理，那是你必须知道的，至少要知道 dubbo 分成哪些层，然后平时怎么发起 rpc 请求的，注册、发现、调用，这些是基本的。</p><p>接着就可以针对底层进行深入的问问了，比如第一步就可以先问问序列化协议这块，就是平时 RPC 的时候怎么走的？</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p><strong>序列化</strong>，就是把数据结构或者是一些对象，转换为二进制串的过程，而<strong>反序列化</strong>是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/serialize-deserialize.png" alt="serialize-deserialize"></p><h3 id="dubbo-支持不同的通信协议"><a href="#dubbo-支持不同的通信协议" class="headerlink" title="dubbo 支持不同的通信协议"></a>dubbo 支持不同的通信协议</h3><ul><li>dubbo 协议</li></ul><p><strong>默认</strong>就是走 dubbo 协议，单一长连接，进行的是 NIO 异步通信，基于 hessian 作为序列化协议。使用的场景是：传输数据量小（每次请求在 100kb 以内），但是并发量很高。</p><p>为了要支持高并发场景，一般是服务提供者就几台机器，但是服务消费者有上百台，可能每天调用量达到上亿次！此时用长连接是最合适的，就是跟每个服务消费者维持一个长连接就可以，可能总共就 100 个连接。然后后面直接基于长连接 NIO 异步通信，可以支撑高并发请求。</p><p>长连接，通俗点说，就是建立连接过后可以持续发送请求，无须再建立连接。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/dubbo-keep-connection.png" alt="dubbo-keep-connection"></p><p>而短连接，每次要发送请求之前，需要先重新建立一次连接。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/dubbo-not-keep-connection.png" alt="dubbo-not-keep-connection"></p><ul><li>rmi 协议</li></ul><p>走 Java 二进制序列化，多个短连接，适合消费者和提供者数量差不多的情况，适用于文件的传输，一般较少用。</p><ul><li>hessian 协议</li></ul><p>走 hessian 序列化协议，多个短连接，适用于提供者数量比消费者数量还多的情况，适用于文件的传输，一般较少用。</p><ul><li>http 协议</li></ul><p>走 json 序列化。</p><ul><li>webservice</li></ul><p>走 SOAP 文本序列化。</p><h3 id="dubbo-支持的序列化协议"><a href="#dubbo-支持的序列化协议" class="headerlink" title="dubbo 支持的序列化协议"></a>dubbo 支持的序列化协议</h3><p>dubbo 支持 hession、Java 二进制序列化、json、SOAP 文本序列化多种序列化协议。但是 hessian 是其默认的序列化协议。</p><h3 id="说一下-Hessian-的数据结构"><a href="#说一下-Hessian-的数据结构" class="headerlink" title="说一下 Hessian 的数据结构"></a>说一下 Hessian 的数据结构</h3><p>Hessian 的对象序列化机制有 8 种原始类型：</p><ul><li>原始二进制数据</li><li>boolean</li><li>64-bit date（64 位毫秒值的日期）</li><li>64-bit double</li><li>32-bit int</li><li>64-bit long</li><li>null</li><li>UTF-8 编码的 string</li></ul><p>另外还包括 3 种递归类型：</p><ul><li>list for lists and arrays</li><li>map for maps and dictionaries</li><li>object for objects</li></ul><p>还有一种特殊的类型：</p><ul><li>ref：用来表示对共享对象的引用。</li></ul><h3 id="为什么-PB-的效率是最高的？"><a href="#为什么-PB-的效率是最高的？" class="headerlink" title="为什么 PB 的效率是最高的？"></a>为什么 PB 的效率是最高的？</h3><p>可能有一些同学比较习惯于 <code>JSON</code> or <code>XML</code> 数据存储格式，对于 <code>Protocol Buffer</code> 还比较陌生。<code>Protocol Buffer</code> 其实是 Google 出品的一种轻量并且高效的结构化数据存储格式，性能比 <code>JSON</code>、<code>XML</code> 要高很多。</p><p>其实 PB 之所以性能如此好，主要得益于两个：<strong>第一</strong>，它使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 <code>XML</code> 和 <code>JSON</code> 快上了 <code>20~100</code> 倍；<strong>第二</strong>，它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。</p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql读写分离</title>
      <link href="/2021/01/30/mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2021/01/30/mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>你们有没有做 MySQL 读写分离？如何实现 MySQL 的读写分离？MySQL 主从复制原理的是啥？如何解决 MySQL 主从同步的延时问题？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>高并发这个阶段，肯定是需要做读写分离的，啥意思？因为实际上大部分的互联网公司，一些网站，或者是 app，其实都是读多写少。所以针对这个情况，就是写一个主库，但是主库挂多个从库，然后从多个从库来读，那不就可以支撑更高的读并发压力了吗？</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><h3 id="如何实现-MySQL-的读写分离？"><a href="#如何实现-MySQL-的读写分离？" class="headerlink" title="如何实现 MySQL 的读写分离？"></a>如何实现 MySQL 的读写分离？</h3><p>其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p><h3 id="MySQL-主从复制原理的是啥？"><a href="#MySQL-主从复制原理的是啥？" class="headerlink" title="MySQL 主从复制原理的是啥？"></a>MySQL 主从复制原理的是啥？</h3><p>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/mysql-master-slave.png" alt="mysql-master-slave"></p><p>这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是<strong>有延时</strong>的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p><p>而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p><p>所以 MySQL 实际上在这一块有两个机制，一个是<strong>半同步复制</strong>，用来解决主库数据丢失问题；一个是<strong>并行复制</strong>，用来解决主从同步延时问题。</p><p>这个所谓<strong>半同步复制</strong>，也叫 <code>semi-sync</code> 复制，指的就是主库写入 binlog 日志之后，就会将<strong>强制</strong>此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库</strong>的 ack 之后才会认为写操作完成了。</p><p>所谓<strong>并行复制</strong>，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后<strong>并行重放不同库的日志</strong>，这是库级别的并行。</p><h3 id="MySQL-主从同步延时问题（精华）"><a href="#MySQL-主从同步延时问题（精华）" class="headerlink" title="MySQL 主从同步延时问题（精华）"></a>MySQL 主从同步延时问题（精华）</h3><p>以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。</p><p>是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。</p><p>我们通过 MySQL 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status</span><br></pre></td></tr></table></figure><p>查看 <code>Seconds_Behind_Master</code>，可以看到从库复制主库的数据落后了几 ms。</p><p>一般来说，如果主从延迟较为严重，有以下解决方案：</p><ul><li>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</li><li>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。</li><li>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</li><li>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。<strong>不推荐</strong>这种方法，你要是这么搞，读写分离的意义就丧失了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分库分表</title>
      <link href="/2021/01/30/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2021/01/30/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>为什么要分库分表（设计高并发系统的时候，数据库层面该如何设计）？用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？你们具体是如何对数据库如何进行垂直拆分或水平拆分的？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>其实这块肯定是扯到<strong>高并发</strong>了，因为分库分表一定是为了<strong>支撑高并发、数据量大</strong>两个问题的。而且现在说实话，尤其是互联网类的公司面试，基本上都会来这么一下，分库分表如此普遍的技术问题，不问实在是不行，而如果你不知道那也实在是说不过去！</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><h3 id="为什么要分库分表？（设计高并发系统的时候，数据库层面该如何设计？）"><a href="#为什么要分库分表？（设计高并发系统的时候，数据库层面该如何设计？）" class="headerlink" title="为什么要分库分表？（设计高并发系统的时候，数据库层面该如何设计？）"></a>为什么要分库分表？（设计高并发系统的时候，数据库层面该如何设计？）</h3><p>说白了，分库分表是两回事儿，大家可别搞混了，可能是光分库不分表，也可能是光分表不分库，都有可能。</p><p>我先给大家抛出来一个场景。</p><p>假如我们现在是一个小创业公司（或者是一个 BAT 公司刚兴起的一个新部门），现在注册用户就 20 万，每天活跃用户就 1 万，每天单表数据量就 1000，然后高峰期每秒钟并发请求最多就 10。天，就这种系统，随便找一个有几年工作经验的，然后带几个刚培训出来的，随便干干都可以。</p><p>结果没想到我们运气居然这么好，碰上个 CEO 带着我们走上了康庄大道，业务发展迅猛，过了几个月，注册用户数达到了 2000 万！每天活跃用户数 100 万！每天单表数据量 10 万条！高峰期每秒最大请求达到 1000！同时公司还顺带着融资了两轮，进账了几个亿人民币啊！公司估值达到了惊人的几亿美金！这是小独角兽的节奏！</p><p>好吧，没事，现在大家感觉压力已经有点大了，为啥呢？因为每天多 10 万条数据，一个月就多 300 万条数据，现在咱们单表已经几百万数据了，马上就破千万了。但是勉强还能撑着。高峰期请求现在是 1000，咱们线上部署了几台机器，负载均衡搞了一下，数据库撑 1000QPS 也还凑合。但是大家现在开始感觉有点担心了，接下来咋整呢……</p><p>再接下来几个月，我的天，CEO 太牛逼了，公司用户数已经达到 1 亿，公司继续融资几十亿人民币啊！公司估值达到了惊人的几十亿美金，成为了国内今年最牛逼的明星创业公司！天，我们太幸运了。</p><p>但是我们同时也是不幸的，因为此时每天活跃用户数上千万，每天单表新增数据多达 50 万，目前一个表总数据量都已经达到了两三千万了！扛不住啊！数据库磁盘容量不断消耗掉！高峰期并发达到惊人的 <code>5000~8000</code>！别开玩笑了，哥。我跟你保证，你的系统支撑不到现在，已经挂掉了！</p><p>好吧，所以你看到这里差不多就理解分库分表是怎么回事儿了，实际上这是跟着你的公司业务发展走的，你公司业务发展越好，用户就越多，数据量越大，请求量越大，那你单个数据库一定扛不住。</p><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>比如你单表都几千万数据了，你确定你能扛住么？绝对不行，<strong>单表数据量太大</strong>，会极大影响你的 sql <strong>执行的性能</strong>，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。</p><p>分表是啥意思？就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>分库是啥意思？就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p><p>这就是所谓的<strong>分库分表</strong>，为啥要分库分表？你明白了吧。</p><table><thead><tr><th>#</th><th>分库分表前</th><th>分库分表后</th></tr></thead><tbody><tr><td>并发支撑情况</td><td>MySQL 单机部署，扛不住高并发</td><td>MySQL从单机到多机，能承受的并发增加了多倍</td></tr><tr><td>磁盘使用情况</td><td>MySQL 单机磁盘容量几乎撑满</td><td>拆分为多个库，数据库服务器磁盘使用率大大降低</td></tr><tr><td>SQL 执行性能</td><td>单表数据量太大，SQL 越跑越慢</td><td>单表数据量减少，SQL 执行效率明显提升</td></tr></tbody></table><h3 id="用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？"><a href="#用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？" class="headerlink" title="用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？"></a>用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？</h3><p>这个其实就是看看你了解哪些分库分表的中间件，各个中间件的优缺点是啥？然后你用过哪些分库分表的中间件。</p><p>比较常见的包括：</p><ul><li>Cobar</li><li>TDDL</li><li>Atlas</li><li>Sharding-jdbc</li><li>Mycat</li></ul><h4 id="Cobar"><a href="#Cobar" class="headerlink" title="Cobar"></a>Cobar</h4><p>阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 JDBC 驱动访问 Cobar 集群，Cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到 MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。</p><h4 id="TDDL"><a href="#TDDL" class="headerlink" title="TDDL"></a>TDDL</h4><p>淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。</p><h4 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h4><p>360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。</p><h4 id="Sharding-jdbc"><a href="#Sharding-jdbc" class="headerlink" title="Sharding-jdbc"></a>Sharding-jdbc</h4><p>当当开源的，属于 client 层方案，目前已经更名为 <a href="https://github.com/apache/incubator-shardingsphere" target="_blank" rel="noopener"><code>ShardingSphere</code></a>（后文所提到的 <code>Sharding-jdbc</code>，等同于 <code>ShardingSphere</code>）。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且截至 2019.4，已经推出到了 <code>4.0.0-RC1</code> 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也<strong>可以选择的方案</strong>。</p><h4 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h4><p>基于 Cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 Sharding jdbc 来说，年轻一些，经历的锤炼少一些。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上，现在其实建议考量的，就是 Sharding-jdbc 和 Mycat，这两个都可以去考虑使用。</p><p>Sharding-jdbc 这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要<strong>耦合</strong> Sharding-jdbc 的依赖；</p><p>Mycat 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了。</p><p>通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 Sharding-jdbc，client 层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；但是中大型公司最好还是选用 Mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护 Mycat，然后大量项目直接透明使用即可。</p><h3 id="你们具体是如何对数据库如何进行垂直拆分或水平拆分的？"><a href="#你们具体是如何对数据库如何进行垂直拆分或水平拆分的？" class="headerlink" title="你们具体是如何对数据库如何进行垂直拆分或水平拆分的？"></a>你们具体是如何对数据库如何进行垂直拆分或水平拆分的？</h3><p><strong>水平拆分</strong>的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/database-split-horizon.png" alt="database-split-horizon"></p><p><strong>垂直拆分</strong>的意思，就是<strong>把一个有很多字段的表给拆分成多个表</strong>，<strong>或者是多个库上去</strong>。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会<strong>将较少的访问频率很高的字段放到一个表里去</strong>，然后<strong>将较多的访问频率很低的字段放到另外一个表里去</strong>。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/database-split-vertically.png" alt="database-split-vertically"></p><p>这个其实挺常见的，不一定我说，大家很多同学可能自己都做过，把一个大表拆开，订单表、订单支付表、订单商品表。</p><p>还有<strong>表层面的拆分</strong>，就是分表，将一个表变成 N 个表，就是<strong>让每个表的数据量控制在一定范围内</strong>，保证 SQL 的性能。否则单表数据量越大，SQL 性能就越差。一般是 200 万行左右，不要太多，但是也得看具体你怎么操作，也可能是 500 万，或者是 100 万。你的SQL越复杂，就最好让单表行数越少。</p><p>好了，无论分库还是分表，上面说的那些数据库中间件都是可以支持的。就是基本上那些中间件可以做到你分库分表之后，<strong>中间件可以根据你指定的某个字段值</strong>，比如说 userid，<strong>自动路由到对应的库上去，然后再自动路由到对应的表里去</strong>。</p><p>你就得考虑一下，你的项目里该如何分库分表？一般来说，垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了，你给拆了，按什么字段来拆，你自己想好；分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都 ok 了，但是每个库的表还是太大了，那么你就分表，将这个表分开，保证每个表的数据量并不是很大。</p><p>而且这儿还有两种<strong>分库分表的方式</strong>：</p><ul><li>一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。</li><li>或者是按照某个字段 hash 一下均匀分散，这个较为常用。</li></ul><p>range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。</p><p>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。</p><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><p>现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表<strong>动态切换</strong>到分库分表上？</p><h2 id="面试官心理分析-1"><a href="#面试官心理分析-1" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>你看看，你现在已经明白为啥要分库分表了，你也知道常用的分库分表中间件了，你也设计好你们如何分库分表的方案了（水平拆分、垂直拆分、分表），那问题来了，你接下来该怎么把你那个单库单表的系统给迁移到分库分表上去？</p><p>所以这都是一环扣一环的，就是看你有没有全流程经历过这个过程。</p><h2 id="面试题剖析-1"><a href="#面试题剖析-1" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>这个其实从 low 到高大上有好几种方案，我们都玩儿过，我都给你说一下。</p><h3 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h3><p>我先给你说一个最 low 的方案，就是很简单，大家伙儿凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。</p><p>接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后你之前得写好一个<strong>导数的一次性工具</strong>，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。</p><p>导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。</p><p>验证一下，ok了，完美，大家伸个懒腰，看看看凌晨 4 点钟的北京夜景，打个滴滴回家吧。</p><p>但是这个方案比较 low，谁都能干，我们来看看高大上一点的方案。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/database-shard-method-1.png" alt="database-shard-method-1"></p><h3 id="双写迁移方案"><a href="#双写迁移方案" class="headerlink" title="双写迁移方案"></a>双写迁移方案</h3><p>这个是我们常用的一种迁移方案，比较靠谱一些，不用停机，不用看北京凌晨 4 点的风景。</p><p>简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，<strong>除了对老库增删改，都加上对新库的增删改</strong>，这就是所谓的<strong>双写</strong>，同时写俩库，老库和新库。</p><p>然后<strong>系统部署</strong>之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据 gmt_modified 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据。</p><p>导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。</p><p>接着当数据完全一致了，就 ok 了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本玩儿数据迁移之类的，都是这么干的。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/database-shard-method-2.png" alt="database-shard-method-2"></p><h2 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h2><p>如何设计可以动态扩容缩容的分库分表方案？</p><h2 id="面试官心理分析-2"><a href="#面试官心理分析-2" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>对于分库分表来说，主要是面对以下问题：</p><ul><li>选择一个数据库中间件，调研、学习、测试；</li><li>设计你的分库分表的一个方案，你要分成多少个库，每个库分成多少个表，比如 3 个库，每个库 4 个表；</li><li>基于选择好的数据库中间件，以及在测试环境建立好的分库分表的环境，然后测试一下能否正常进行分库分表的读写；</li><li>完成单库单表到分库分表的<strong>迁移</strong>，双写方案；</li><li>线上系统开始基于分库分表对外提供服务；</li><li>扩容了，扩容成 6 个库，每个库需要 12 个表，你怎么来增加更多库和表呢？</li></ul><p>这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。</p><p>那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。</p><p>这都是玩儿分库分表线上必须经历的事儿。</p><h2 id="面试题剖析-2"><a href="#面试题剖析-2" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><h3 id="停机扩容（不推荐）"><a href="#停机扩容（不推荐）" class="headerlink" title="停机扩容（不推荐）"></a>停机扩容（不推荐）</h3><p>这个方案就跟停机迁移一样，步骤几乎一致，唯一的一点就是那个导数的工具，是把现有库表的数据抽出来慢慢倒入到新的库和表里去。但是最好别这么玩儿，有点不太靠谱，因为既然<strong>分库分表</strong>就说明数据量实在是太大了，可能多达几亿条，甚至几十亿，你这么玩儿，可能会出问题。</p><p>从单库单表迁移到分库分表的时候，数据量并不是很大，单表最大也就两三千万。那么你写个工具，多弄几台机器并行跑，1小时数据就导完了。这没有问题。</p><p>如果 3 个库 + 12 个表，跑了一段时间了，数据量都 1~2 亿了。光是导 2 亿数据，都要导个几个小时，6 点，刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10 点才可以搞完。所以不能这么搞。</p><h3 id="优化后的方案"><a href="#优化后的方案" class="headerlink" title="优化后的方案"></a>优化后的方案</h3><p>一开始上来就是 32 个库，每个库 32 个表，那么总共是 1024 张表。</p><p>我可以告诉各位同学，这个分法，第一，基本上国内的互联网肯定都是够用了，第二，无论是并发支撑还是数据量支撑都没问题。</p><p>每个库正常承载的写入并发量是 1000，那么 32 个库就可以承载 32 * 1000 = 32000 的写并发，如果每个库承载 1500 的写并发，32 * 1500 = 48000 的写并发，接近 5 万每秒的写入并发，前面再加一个MQ，削峰，每秒写入 MQ 8 万条数据，每秒消费 5 万条数据。</p><p>有些除非是国内排名非常靠前的这些公司，他们的最核心的系统的数据库，可能会出现几百台数据库的这么一个规模，128 个库，256 个库，512 个库。</p><p>1024 张表，假设每个表放 500 万数据，在 MySQL 里可以放 50 亿条数据。</p><p>每秒 5 万的写并发，总共 50 亿条数据，对于国内大部分的互联网公司来说，其实一般来说都够了。</p><p>谈分库分表的扩容，<strong>第一次分库分表，就一次性给他分个够</strong>，32 个库，1024 张表，可能对大部分的中小型互联网公司来说，已经可以支撑好几年了。</p><p>一个实践是利用 <code>32 * 32</code> 来分库分表，即分为 32 个库，每个库里一个表分为 32 张表。一共就是 1024 张表。根据某个 id 先根据 32 取模路由到库，再根据 32 取模路由到库里的表。</p><table><thead><tr><th>orderId</th><th>id % 32 (库)</th><th>id / 32 % 32 (表)</th></tr></thead><tbody><tr><td>259</td><td>3</td><td>8</td></tr><tr><td>1189</td><td>5</td><td>5</td></tr><tr><td>352</td><td>0</td><td>11</td></tr><tr><td>4593</td><td>17</td><td>15</td></tr></tbody></table><p>刚开始的时候，这个库可能就是逻辑库，建在一个数据库上的，就是一个 mysql 服务器可能建了 n 个库，比如 32 个库。后面如果要拆分，就是不断在库和 mysql 服务器之间做迁移就可以了。然后系统配合改一下配置即可。</p><p>比如说最多可以扩展到 32 个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到 1024 个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是 1024 个表。</p><p>这么搞，是不用自己写代码做数据迁移的，都交给 dba 来搞好了，但是 dba 确实是需要做一些库表迁移的工作，但是总比你自己写代码，然后抽数据导数据来的效率高得多吧。</p><p>哪怕是要减少库的数量，也很简单，其实说白了就是按倍数缩容就可以了，然后修改一下路由规则。</p><p>这里对步骤做一个总结：</p><ol><li>设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是 32 库 * 32 表，对于大部分公司来说，可能几年都够了。</li><li>路由的规则，orderId 模 32 = 库，orderId / 32 模 32 = 表</li><li>扩容的时候，申请增加更多的数据库服务器，装好 mysql，呈倍数扩容，4 台服务器，扩到 8 台服务器，再到 16 台服务器。</li><li>由 dba 负责将原先数据库服务器的库，迁移到新的数据库服务器上去，库迁移是有一些便捷的工具的。</li><li>我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址。</li><li>重新发布系统，上线，原先的路由规则变都不用变，直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计一个高并发系统</title>
      <link href="/2021/01/30/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/01/30/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>可以分为以下 6 点：</p><ul><li>系统拆分</li><li>缓存</li><li>MQ</li><li>分库分表</li><li>读写分离</li><li>ElasticSearch</li></ul><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/high-concurrency-system-design.png" alt="high-concurrency-system-design"></p><h3 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h3><p>将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存，必须得用缓存。大部分的高并发场景，都是<strong>读多写少</strong>，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的<strong>读场景，怎么用缓存来抗高并发</strong>。</p><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p>MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，<strong>后边系统消费后慢慢写</strong>，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。</p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表<strong>拆分为多个表</strong>，每个表的数据量保持少一点，提高 sql 跑的性能。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，<strong>主库写</strong>入，<strong>从库读</strong>取，搞一个读写分离。<strong>读流量太多</strong>的时候，还可以<strong>加更多的从库</strong>。</p><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><p>Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。</p><p>上面的 6 点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。</p><p>说句实话，毕竟你真正厉害的一点，不是在于弄明白一些技术，或者大概知道一个高并发系统应该长什么样？其实实际上在真正的复杂的业务系统里，做高并发要远远比上面提到的点要复杂几十倍到上百倍。你需要考虑：哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何 join，哪些数据要放到缓存里去，放哪些数据才可以扛住高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造，这个过程是无比复杂的，一旦做过一次，并且做好了，你在这个市场上就会非常的吃香。</p><p>其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，你了解了，也只能是次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的</p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch汇总</title>
      <link href="/2021/01/29/elasticsearch%E6%B1%87%E6%80%BB/"/>
      <url>/2021/01/29/elasticsearch%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="lucene-和-es-的前世今生"><a href="#lucene-和-es-的前世今生" class="headerlink" title="lucene 和 es 的前世今生"></a>lucene 和 es 的前世今生</h2><p>lucene 是最先进、功能最强大的搜索库。如果直接基于 lucene 开发，非常复杂，即便写一些简单的功能，也要写大量的 Java 代码，需要深入理解原理。</p><p>elasticsearch 基于 lucene，隐藏了 lucene 的复杂性，提供了简单易用的 restful api / Java api 接口（另外还有其他语言的 api 接口）。</p><ul><li>分布式的文档存储引擎</li><li>分布式的搜索引擎和分析引擎</li><li>分布式，支持 PB 级数据</li></ul><h2 id="es-的核心概念"><a href="#es-的核心概念" class="headerlink" title="es 的核心概念"></a>es 的核心概念</h2><h3 id="Near-Realtime"><a href="#Near-Realtime" class="headerlink" title="Near Realtime"></a>Near Realtime</h3><p>近实时，有两层意思：</p><ul><li>从写入数据到数据可以被搜索到有一个小延迟（大概是 1s）</li><li>基于 es 执行搜索和分析可以达到秒级</li></ul><h3 id="Cluster-集群"><a href="#Cluster-集群" class="headerlink" title="Cluster 集群"></a>Cluster 集群</h3><p>集群包含多个节点，每个节点属于哪个集群都是通过一个配置来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常。</p><h3 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h3><p>Node 是集群中的一个节点，节点也有一个名称，默认是随机分配的。默认节点会去加入一个名称为 <code>elasticsearch</code> 的集群。如果直接启动一堆节点，那么它们会自动组成一个 elasticsearch 集群，当然一个节点也可以组成 elasticsearch 集群。</p><h3 id="Document-amp-field"><a href="#Document-amp-field" class="headerlink" title="Document &amp; field"></a>Document &amp; field</h3><p>文档是 es 中最小的数据单元，一个 document 可以是一条客户数据、一条商品分类数据、一条订单数据，通常用 json 数据结构来表示。每个 index 下的 type，都可以存储多条 document。一个 document 里面有多个 field，每个 field 就是一个数据字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;product_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;product_name&quot;: &quot;iPhone X&quot;,</span><br><span class="line">    &quot;product_desc&quot;: &quot;苹果手机&quot;,</span><br><span class="line">    &quot;category_id&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;category_name&quot;: &quot;电子产品&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>索引包含了一堆有相似结构的文档数据，比如商品索引。一个索引包含很多 document，一个索引就代表了一类相似或者相同的 ducument。</p><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>类型，每个索引里可以有一个或者多个 type，type 是 index 的一个逻辑分类，比如商品 index 下有多个 type：日化商品 type、电器商品 type、生鲜商品 type。每个 type 下的 document 的 field 可能不太一样。</p><h3 id="shard"><a href="#shard" class="headerlink" title="shard"></a>shard</h3><p>单台机器无法存储大量数据，es 可以将一个索引中的数据切分为多个 shard，分布在多台服务器上存储。有了 shard 就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个 shard 都是一个 lucene index。</p><h3 id="replica"><a href="#replica" class="headerlink" title="replica"></a>replica</h3><p>任何一个服务器随时可能故障或宕机，此时 shard 可能就会丢失，因此可以为每个 shard 创建多个 replica 副本。replica 可以在 shard 故障时提供备用服务，保证数据不丢失，多个 replica 还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认 5 个），replica shard（随时修改数量，默认 1 个），默认每个索引 10 个 shard，5 个 primary shard，5个 replica shard，最小的高可用配置，是 2 台服务器。</p><p>这么说吧，shard 分为 primary shard 和 replica shard。而 primary shard 一般简称为 shard，而 replica shard 一般简称为 replica。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/es-cluster-0.png" alt="es-cluster-0"></p><h2 id="es-核心概念-vs-db-核心概念"><a href="#es-核心概念-vs-db-核心概念" class="headerlink" title="es 核心概念 vs. db 核心概念"></a>es 核心概念 vs. db 核心概念</h2><table><thead><tr><th>es</th><th>db</th></tr></thead><tbody><tr><td>index</td><td>数据库</td></tr><tr><td>type</td><td>数据表</td></tr><tr><td>docuemnt</td><td>一行数据</td></tr></tbody></table><p>以上是一个简单的类比。</p><p>es 的分布式架构原理能说一下么（es 是如何实现分布式的啊）？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>在搜索这块，lucene 是最流行的搜索库。几年前业内一般都问，你了解 lucene 吗？你知道倒排索引的原理吗？现在早已经 out 了，因为现在很多项目都是直接用基于 lucene 的分布式搜索引擎—— ElasticSearch，简称为 es。</p><p>而现在分布式搜索基本已经成为大部分互联网行业的 Java 系统的标配，其中尤为流行的就是 es，前几年 es 没火的时候，大家一般用 solr。但是这两年基本大部分企业和项目都开始转向 es 了。</p><p>所以互联网面试，肯定会跟你聊聊分布式搜索引擎，也就一定会聊聊 es，如果你确实不知道，那你真的就 out 了。</p><p>如果面试官问你第一个问题，确实一般都会问你 es 的分布式架构设计能介绍一下么？就看看你对分布式搜索引擎架构的一个基本理解。</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>ElasticSearch 设计的理念就是分布式搜索引擎，底层其实还是基于 lucene 的。核心思想就是在多台机器上启动多个 es 进程实例，组成了一个 es 集群。</p><p>es 中存储数据的<strong>基本单位是索引</strong>，比如说你现在要在 es 中存储一些订单数据，你就应该在 es 中创建一个索引 <code>order_idx</code>，所有的订单数据就都写到这个索引里面去，一个索引差不多就是相当于是 mysql 里的一张表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index -&gt; type -&gt; mapping -&gt; document -&gt; field。</span><br></pre></td></tr></table></figure><p>这样吧，为了做个更直白的介绍，我在这里做个类比。但是切记，不要划等号，类比只是为了便于理解。</p><p>index 相当于 mysql 里的一张表。而 type 没法跟 mysql 里去对比，一个 index 里可以有多个 type，每个 type 的字段都是差不多的，但是有一些略微的差别。假设有一个 index，是订单 index，里面专门是放订单数据的。就好比说你在 mysql 中建表，有些订单是实物商品的订单，比如一件衣服、一双鞋子；有些订单是虚拟商品的订单，比如游戏点卡，话费充值。就两种订单大部分字段是一样的，但是少部分字段可能有略微的一些差别。</p><p>所以就会在订单 index 里，建两个 type，一个是实物商品订单 type，一个是虚拟商品订单 type，这两个 type 大部分字段是一样的，少部分字段是不一样的。</p><p>很多情况下，一个 index 里可能就一个 type，但是确实如果说是一个 index 里有多个 type 的情况（<strong>注意</strong>，<code>mapping types</code> 这个概念在 ElasticSearch 7.X 已被完全移除，详细说明可以参考<a href="https://github.com/elastic/elasticsearch/blob/6.5/docs/reference/mapping/removal_of_types.asciidoc" target="_blank" rel="noopener">官方文档</a>），你可以认为 index 是一个类别的表，具体的每个 type 代表了 mysql 中的一个表。每个 type 有一个 mapping，如果你认为一个 type 是具体的一个表，index 就代表多个 type 同属于的一个类型，而 mapping 就是这个 type 的<strong>表结构定义</strong>，你在 mysql 中创建一个表，肯定是要定义表结构的，里面有哪些字段，每个字段是什么类型。实际上你往 index 里的一个 type 里面写的一条数据，叫做一条 document，一条 document 就代表了 mysql 中某个表里的一行，每个 document 有多个 field，每个 field 就代表了这个 document 中的一个字段的值。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/es-index-type-mapping-document-field.png" alt="es-index-type-mapping-document-field"></p><p>你搞一个索引，这个索引可以拆分成多个 <code>shard</code>，每个 shard 存储部分数据。拆分多个 shard 是有好处的，一是<strong>支持横向扩展</strong>，比如你数据量是 3T，3 个 shard，每个 shard 就 1T 的数据，若现在数据量增加到 4T，怎么扩展，很简单，重新建一个有 4 个 shard 的索引，将数据导进去；二是<strong>提高性能</strong>，数据分布在多个 shard，即多台服务器上，所有的操作，都会在多台机器上并行分布式执行，提高了吞吐量和性能。</p><p>接着就是这个 shard 的数据实际是有多个备份，就是说每个 shard 都有一个 <code>primary shard</code>，负责写入数据，但是还有几个 <code>replica shard</code>。<code>primary shard</code> 写入数据之后，会将数据同步到其他几个 <code>replica shard</code> 上去。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/es-cluster.png" alt="es-cluster"></p><p>通过这个 replica 的方案，每个 shard 的数据都有多个备份，如果某个机器宕机了，没关系啊，还有别的数据副本在别的机器上呢。高可用了吧。</p><p>es 集群多个节点，会自动选举一个节点为 master 节点，这个 master 节点其实就是干一些管理的工作的，比如维护索引元数据、负责切换 primary shard 和 replica shard 身份等。要是 master 节点宕机了，那么会重新选举一个节点为 master 节点。</p><p>如果是非 master节点宕机了，那么会由 master 节点，让那个宕机节点上的 primary shard 的身份转移到其他机器上的 replica shard。接着你要是修复了那个宕机机器，重启了之后，master 节点会控制将缺失的 replica shard 分配过去，同步后续修改的数据之类的，让集群恢复正常。</p><p>说得更简单一点，就是说如果某个非 master 节点宕机了。那么此节点上的 primary shard 不就没了。那好，master 会让 primary shard 对应的 replica shard（在其他机器上）切换为 primary shard。如果宕机的机器修复了，修复后的节点也不再是 primary shard，而是 replica shard。</p><p>其实上述就是 ElasticSearch 作为分布式搜索引擎最基本的一个架构设计。</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>es 写入数据的工作原理是什么啊？es 查询数据的工作原理是什么啊？底层的 lucene 介绍一下呗？倒排索引了解吗？</p><h2 id="面试官心理分析-1"><a href="#面试官心理分析-1" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>问这个，其实面试官就是要看看你了解不了解 es 的一些基本原理，因为用 es 无非就是写入数据，搜索数据。你要是不明白你发起一个写入和搜索请求的时候，es 在干什么，那你真的是……</p><p>对 es 基本就是个黑盒，你还能干啥？你唯一能干的就是用 es 的 api 读写数据了。要是出点什么问题，你啥都不知道，那还能指望你什么呢？</p><h2 id="面试题剖析-1"><a href="#面试题剖析-1" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><h3 id="es-写数据过程"><a href="#es-写数据过程" class="headerlink" title="es 写数据过程"></a>es 写数据过程</h3><ul><li>客户端选择一个 node 发送请求过去，这个 node 就是 <code>coordinating node</code>（协调节点）。</li><li><code>coordinating node</code> 对 document 进行<strong>路由</strong>，将请求转发给对应的 node（有 primary shard）。</li><li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到 <code>replica node</code>。</li><li><code>coordinating node</code> 如果发现 <code>primary node</code> 和所有 <code>replica node</code> 都搞定之后，就返回响应结果给客户端。</li></ul><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/es-write.png" alt="es-write"></p><h3 id="es-读数据过程"><a href="#es-读数据过程" class="headerlink" title="es 读数据过程"></a>es 读数据过程</h3><p>可以通过 <code>doc id</code> 来查询，会根据 <code>doc id</code> 进行 hash，判断出来当时把 <code>doc id</code> 分配到了哪个 shard 上面去，从那个 shard 去查询。</p><ul><li>客户端发送请求到<strong>任意</strong>一个 node，成为 <code>coordinate node</code>。</li><li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code> <strong>随机轮询算法</strong>，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li><li>接收请求的 node 返回 document 给 <code>coordinate node</code>。</li><li><code>coordinate node</code> 返回 document 给客户端。</li></ul><h3 id="es-搜索数据过程"><a href="#es-搜索数据过程" class="headerlink" title="es 搜索数据过程"></a>es 搜索数据过程</h3><p>es 最强大的是做全文检索，就是比如你有三条数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java真好玩儿啊</span><br><span class="line">java好难学啊</span><br><span class="line">j2ee特别牛</span><br></pre></td></tr></table></figure><p>你根据 <code>java</code> 关键词来搜索，将包含 <code>java</code>的 <code>document</code> 给搜索出来。es 就会给你返回：java真好玩儿啊，java好难学啊。</p><ul><li>客户端发送请求到一个 <code>coordinate node</code>。</li><li>协调节点将搜索请求转发到<strong>所有</strong>的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code>，都可以。</li><li>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code>）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li><li>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上<strong>拉取实际</strong>的 <code>document</code> 数据，最终返回给客户端。</li></ul><blockquote><p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p></blockquote><h3 id="写数据底层原理"><a href="#写数据底层原理" class="headerlink" title="写数据底层原理"></a>写数据底层原理</h3><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/es-write-detail.png" alt="es-write-detail"></p><p>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</p><p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 <code>refresh</code> 到一个新的 <code>segment file</code> 中，但是此时数据不是直接进入 <code>segment file</code> 磁盘文件，而是先进入 <code>os cache</code> 。这个过程就是 <code>refresh</code>。</p><p>每隔 1 秒钟，es 将 buffer 中的数据写入一个<strong>新的</strong> <code>segment file</code>，每秒钟会产生一个<strong>新的磁盘文件</strong> <code>segment file</code>，这个 <code>segment file</code> 中就存储最近 1 秒内 buffer 中写入的数据。</p><p>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p><p>操作系统里面，磁盘文件其实都有一个东西，叫做 <code>os cache</code>，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 <code>os cache</code>，先进入操作系统级别的一个内存缓存中去。只要 <code>buffer</code> 中的数据被 refresh 操作刷入 <code>os cache</code>中，这个数据就可以被搜索到了。</p><p>为什么叫 es 是<strong>准实时</strong>的？ <code>NRT</code>，全称 <code>near real-time</code>。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的 <code>restful api</code> 或者 <code>java api</code>，<strong>手动</strong>执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 <code>os cache</code>中，让数据立马就可以被搜索到。只要数据被输入 <code>os cache</code> 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p><p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 <code>buffer</code> 数据写入一个又一个新的 <code>segment file</code> 中去，每次 <code>refresh</code> 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 <code>commit</code> 操作。</p><p>commit 操作发生第一步，就是将 buffer 中现有数据 <code>refresh</code> 到 <code>os cache</code> 中去，清空 buffer。然后，将一个 <code>commit point</code> 写入磁盘文件，里面标识着这个 <code>commit point</code> 对应的所有 <code>segment file</code>，同时强行将 <code>os cache</code> 中目前所有的数据都 <code>fsync</code> 到磁盘文件中去。最后<strong>清空</strong> 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p><p>这个 commit 操作叫做 <code>flush</code>。默认 30 分钟自动执行一次 <code>flush</code>，但如果 translog 过大，也会触发 <code>flush</code>。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p><p>translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 <code>translog</code> 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p><p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会<strong>丢失</strong> 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 <code>fsync</code> 到磁盘，但是性能会差很多。</p><p>实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的<strong>数据丢失</strong>。</p><p><strong>总结一下</strong>，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。</p><blockquote><p>数据写入 segment file 之后，同时就建立好了倒排索引。</p></blockquote><h3 id="删除-更新数据底层原理"><a href="#删除-更新数据底层原理" class="headerlink" title="删除/更新数据底层原理"></a>删除/更新数据底层原理</h3><p>如果是删除操作，commit 的时候会生成一个 <code>.del</code> 文件，里面将某个 doc 标识为 <code>deleted</code> 状态，那么搜索的时候根据 <code>.del</code> 文件就知道这个 doc 是否被删除了。</p><p>如果是更新操作，就是将原来的 doc 标识为 <code>deleted</code> 状态，然后新写入一条数据。</p><p>buffer 每 refresh 一次，就会产生一个 <code>segment file</code>，所以默认情况下是 1 秒钟一个 <code>segment file</code>，这样下来 <code>segment file</code> 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 <code>segment file</code> 合并成一个，同时这里会将标识为 <code>deleted</code> 的 doc 给<strong>物理删除掉</strong>，然后将新的 <code>segment file</code> 写入磁盘，这里会写一个 <code>commit point</code>，标识所有新的 <code>segment file</code>，然后打开 <code>segment file</code> 供搜索使用，同时删除旧的 <code>segment file</code>。</p><h3 id="底层-lucene"><a href="#底层-lucene" class="headerlink" title="底层 lucene"></a>底层 lucene</h3><p>简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。</p><p>通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。</p><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。</p><p>那么，倒排索引就是<strong>关键词到文档</strong> ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。</p><p>举个栗子。</p><p>有以下文档：</p><table><thead><tr><th>DocId</th><th>Doc</th></tr></thead><tbody><tr><td>1</td><td>谷歌地图之父跳槽 Facebook</td></tr><tr><td>2</td><td>谷歌地图之父加盟 Facebook</td></tr><tr><td>3</td><td>谷歌地图创始人拉斯离开谷歌加盟 Facebook</td></tr><tr><td>4</td><td>谷歌地图之父跳槽 Facebook 与 Wave 项目取消有关</td></tr><tr><td>5</td><td>谷歌地图之父拉斯加盟社交网站 Facebook</td></tr></tbody></table><p>对文档进行分词之后，得到以下<strong>倒排索引</strong>。</p><table><thead><tr><th>WordId</th><th>Word</th><th>DocIds</th></tr></thead><tbody><tr><td>1</td><td>谷歌</td><td>1,2,3,4,5</td></tr><tr><td>2</td><td>地图</td><td>1,2,3,4,5</td></tr><tr><td>3</td><td>之父</td><td>1,2,4,5</td></tr><tr><td>4</td><td>跳槽</td><td>1,4</td></tr><tr><td>5</td><td>Facebook</td><td>1,2,3,4,5</td></tr><tr><td>6</td><td>加盟</td><td>2,3,5</td></tr><tr><td>7</td><td>创始人</td><td>3</td></tr><tr><td>8</td><td>拉斯</td><td>3,5</td></tr><tr><td>9</td><td>离开</td><td>3</td></tr><tr><td>10</td><td>与</td><td>4</td></tr><tr><td>..</td><td>..</td><td>..</td></tr></tbody></table><p>另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。</p><p>那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 <code>Facebook</code>，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。</p><p>要注意倒排索引的两个重要细节：</p><ul><li>倒排索引中的所有词项对应一个或多个文档；</li><li>倒排索引中的词项<strong>根据字典顺序升序排列</strong></li></ul><blockquote><p>上面只是一个简单的栗子，并没有严格按照字典顺序升序排列。</p></blockquote><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><p>es 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？</p><h2 id="面试官心理分析-2"><a href="#面试官心理分析-2" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>这个问题是肯定要问的，说白了，就是看你有没有实际干过 es，因为啥？其实 es 性能并没有你想象中那么好的。很多时候数据量大了，特别是有几亿条数据的时候，可能你会懵逼的发现，跑个搜索怎么一下 <code>5~10s</code>，坑爹了。第一次搜索的时候，是 <code>5~10s</code>，后面反而就快了，可能就几百毫秒。</p><p>你就很懵，每个用户第一次访问都会比较慢，比较卡么？所以你要是没玩儿过 es，或者就是自己玩玩儿 demo，被问到这个问题容易懵逼，显示出你对 es 确实玩儿的不怎么样？</p><h2 id="面试题剖析-2"><a href="#面试题剖析-2" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>说实话，es 性能优化是没有什么银弹的，啥意思呢？就是<strong>不要期待着随手调一个参数，就可以万能的应对所有的性能慢的场景</strong>。也许有的场景是你换个参数，或者调整一下语法，就可以搞定，但是绝对不是所有场景都可以这样。</p><h3 id="性能优化的杀手锏——filesystem-cache"><a href="#性能优化的杀手锏——filesystem-cache" class="headerlink" title="性能优化的杀手锏——filesystem cache"></a>性能优化的杀手锏——filesystem cache</h3><p>你往 es 里写的数据，实际上都写到磁盘文件里去了，<strong>查询的时候</strong>，操作系统会将磁盘文件里的数据自动缓存到 <code>filesystem cache</code> 里面去。</p><p><img src="https://gitee.com/shishan100/Java-Interview-Advanced/raw/master/images/es-search-process.png" alt="es-search-process"></p><p>es 的搜索引擎严重依赖于底层的 <code>filesystem cache</code>，你如果给 <code>filesystem cache</code> 更多的内存，尽量让内存可以容纳所有的 <code>idx segment file</code>索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</p><p>性能差距究竟可以有多大？我们之前很多的测试和压测，如果走磁盘一般肯定上秒，搜索性能绝对是秒级别的，1秒、5秒、10秒。但如果是走 <code>filesystem cache</code>，是走纯内存的，那么一般来说性能比走磁盘要高一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。</p><p>这里有个真实的案例。某个公司 es 节点有 3 台机器，每台机器看起来内存很多，64G，总内存就是 <code>64 * 3 = 192G</code>。每台机器给 es jvm heap 是 <code>32G</code>，那么剩下来留给 <code>filesystem cache</code> 的就是每台机器才 <code>32G</code>，总共集群里给 <code>filesystem cache</code> 的就是 <code>32 * 3 = 96G</code> 内存。而此时，整个磁盘上索引数据文件，在 3 台机器上一共占用了 <code>1T</code> 的磁盘容量，es 数据量是 <code>1T</code>，那么每台机器的数据量是 <code>300G</code>。这样性能好吗？ <code>filesystem cache</code> 的内存才 100G，十分之一的数据可以放内存，其他的都在磁盘，然后你执行搜索操作，大部分操作都是走磁盘，性能肯定差。</p><p>归根结底，你要让 es 性能要好，最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。</p><p>根据我们自己的生产环境实践经验，最佳的情况下，是仅仅在 es 中就存少量的数据，就是你要<strong>用来搜索的那些索引</strong>，如果内存留给 <code>filesystem cache</code> 的是 100G，那么你就将索引数据控制在 <code>100G</code> 以内，这样的话，你的数据几乎全部走内存来搜索，性能非常之高，一般可以在 1 秒以内。</p><p>比如说你现在有一行数据。<code>id,name,age ....</code> 30 个字段。但是你现在搜索，只需要根据 <code>id,name,age</code> 三个字段来搜索。如果你傻乎乎往 es 里写入一行数据所有的字段，就会导致说 <code>90%</code> 的数据是不用来搜索的，结果硬是占据了 es 机器上的 <code>filesystem cache</code> 的空间，单条数据的数据量越大，就会导致 <code>filesystem cahce</code> 能缓存的数据就越少。其实，仅仅写入 es 中要用来检索的<strong>少数几个字段</strong>就可以了，比如说就写入 es <code>id,name,age</code> 三个字段，然后你可以把其他的字段数据存在 mysql/hbase 里，我们一般是建议用 <code>es + hbase</code> 这么一个架构。</p><p>hbase 的特点是<strong>适用于海量数据的在线存储</strong>，就是对 hbase 可以写入海量数据，但是不要做复杂的搜索，做很简单的一些根据 id 或者范围进行查询的这么一个操作就可以了。从 es 中根据 name 和 age 去搜索，拿到的结果可能就 20 个 <code>doc id</code>，然后根据 <code>doc id</code> 到 hbase 里去查询每个 <code>doc id</code> 对应的<strong>完整的数据</strong>，给查出来，再返回给前端。</p><p>写入 es 的数据最好小于等于，或者是略微大于 es 的 filesystem cache 的内存容量。然后你从 es 检索可能就花费 20ms，然后再根据 es 返回的 id 去 hbase 里查询，查 20 条数据，可能也就耗费个 30ms，可能你原来那么玩儿，1T 数据都放 es，会每次查询都是 5~10s，现在可能性能就会很高，每次查询就是 50ms。</p><h3 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h3><p>假如说，哪怕是你就按照上述的方案去做了，es 集群中每个机器写入的数据量还是超过了 <code>filesystem cache</code> 一倍，比如说你写入一台机器 60G 数据，结果 <code>filesystem cache</code> 就 30G，还是有 30G 数据留在了磁盘上。</p><p>其实可以做<strong>数据预热</strong>。</p><p>举个例子，拿微博来说，你可以把一些大V，平时看的人很多的数据，你自己提前后台搞个系统，每隔一会儿，自己的后台系统去搜索一下热数据，刷到 <code>filesystem cache</code> 里去，后面用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了，很快。</p><p>或者是电商，你可以将平时查看最多的一些商品，比如说 iphone 8，热数据提前后台搞个程序，每隔 1 分钟自己主动访问一次，刷到 <code>filesystem cache</code> 里去。</p><p>对于那些你觉得比较热的、经常会有人访问的数据，最好<strong>做一个专门的缓存预热子系统</strong>，就是对热数据每隔一段时间，就提前访问一下，让数据进入 <code>filesystem cache</code> 里面去。这样下次别人访问的时候，性能一定会好很多。</p><h3 id="冷热分离"><a href="#冷热分离" class="headerlink" title="冷热分离"></a>冷热分离</h3><p>es 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将<strong>冷数据写入一个索引中，然后热数据写入另外一个索引中</strong>，这样可以确保热数据在被预热之后，尽量都让他们留在 <code>filesystem os cache</code> 里，<strong>别让冷数据给冲刷掉</strong>。</p><p>你看，假设你有 6 台机器，2 个索引，一个放冷数据，一个放热数据，每个索引 3 个 shard。3 台机器放热数据 index，另外 3 台机器放冷数据 index。然后这样的话，你大量的时间是在访问热数据 index，热数据可能就占总数据量的 10%，此时数据量很少，几乎全都保留在 <code>filesystem cache</code> 里面了，就可以确保热数据的访问性能是很高的。但是对于冷数据而言，是在别的 index 里的，跟热数据 index 不在相同的机器上，大家互相之间都没什么联系了。如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点，就 10% 的人去访问冷数据，90% 的人在访问热数据，也无所谓了。</p><h3 id="document-模型设计"><a href="#document-模型设计" class="headerlink" title="document 模型设计"></a>document 模型设计</h3><p>对于 MySQL，我们经常有一些复杂的关联查询。在 es 里该怎么玩儿，es 里面的复杂的关联查询尽量别用，一旦用了性能一般都不太好。</p><p>最好是先在 Java 系统里就完成关联，将关联好的数据直接写入 es 中。搜索的时候，就不需要利用 es 的搜索语法来完成 join 之类的关联搜索了。</p><p>document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join/nested/parent-child 搜索都要尽量避免，性能都很差的。</p><h3 id="分页性能优化"><a href="#分页性能优化" class="headerlink" title="分页性能优化"></a>分页性能优化</h3><p>es 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p><p>分布式的，你要查第 100 页的 10 条数据，不可能说从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据吧？你<strong>必须</strong>得从每个 shard 都查 1000 条数据过来，然后根据你的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。你翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，非常坑爹。所以用 es 做分页的时候，你会发现越翻到后面，就越是慢。</p><p>我们之前也是遇到过这个问题，用 es 作分页，前几页就几十毫秒，翻到 10 页或者几十页的时候，基本上就要 5~10 秒才能查出来一页数据了。</p><p>有什么解决方案吗？</p><h4 id="不允许深度分页（默认深度分页性能很差）"><a href="#不允许深度分页（默认深度分页性能很差）" class="headerlink" title="不允许深度分页（默认深度分页性能很差）"></a>不允许深度分页（默认深度分页性能很差）</h4><p>跟产品经理说，你系统不允许翻那么深的页，默认翻的越深，性能就越差。</p><h4 id="类似于-app-里的推荐商品不断下拉出来一页一页的"><a href="#类似于-app-里的推荐商品不断下拉出来一页一页的" class="headerlink" title="类似于 app 里的推荐商品不断下拉出来一页一页的"></a>类似于 app 里的推荐商品不断下拉出来一页一页的</h4><p>类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 <code>scroll api</code>，关于如何使用，自行上网搜索。</p><p>scroll 会一次性给你生成<strong>所有数据的一个快照</strong>，然后每次滑动向后翻页就是通过<strong>游标</strong> <code>scroll_id</code> 移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。</p><p>但是，唯一的一点就是，这个适合于那种类似微博下拉翻页的，<strong>不能随意跳到任何一页的场景</strong>。也就是说，你不能先进入第 10 页，然后去第 120 页，然后又回到第 58 页，不能随意乱跳页。所以现在很多产品，都是不允许你随意翻页的，app，也有一些网站，做的就是你只能往下拉，一页一页的翻。</p><p>初始化时必须指定 <code>scroll</code> 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。</p><p>除了用 <code>scroll api</code>，你也可以用 <code>search_after</code> 来做，<code>search_after</code> 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</p><h2 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h2><p>es 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？</p><h2 id="面试官心理分析-3"><a href="#面试官心理分析-3" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>这个问题，包括后面的 redis 什么的，谈到 es、redis、mysql 分库分表等等技术，面试必问！就是你生产环境咋部署的？说白了，这个问题没啥技术含量，就是看你有没有在真正的生产环境里干过这事儿！</p><p>有些同学可能是没在生产环境中干过的，没实际去拿线上机器部署过 es 集群，也没实际玩儿过，也没往 es 集群里面导入过几千万甚至是几亿的数据量，可能你就不太清楚这里面的一些生产项目中的细节。</p><p>如果你是自己就玩儿过 demo，没碰过真实的 es 集群，那你可能此时会懵。别懵，你一定要云淡风轻的回答出来这个问题，表示你确实干过这事儿。</p><h2 id="面试题剖析-3"><a href="#面试题剖析-3" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>其实这个问题没啥，如果你确实干过 es，那你肯定了解你们生产 es 集群的实际情况，部署了几台机器？有多少个索引？每个索引有多大数据量？每个索引给了多少个分片？你肯定知道！</p><p>但是如果你确实没干过，也别虚，我给你说一个基本的版本，你到时候就简单说一下就好了。</p><ul><li>es 生产集群我们部署了 5 台机器，每台机器是 6 核 64G 的，集群总内存是 320G。</li><li>我们 es 集群的日增量数据大概是 2000 万条，每天日增量数据大概是 500MB，每月增量数据大概是 6 亿，15G。目前系统已经运行了几个月，现在 es 集群里数据总量大概是 100G 左右。</li><li>目前线上有 5 个索引（这个结合你们自己业务来，看看自己有哪些数据可以放 es 的），每个索引的数据量大概是 20G，所以这个数据量之内，我们每个索引分配的是 8 个 shard，比默认的 5 个 shard 多了 3 个 shard。</li></ul><p>大概就这么说一下就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rpc的相关问题以及解答</title>
      <link href="/2021/01/19/rpc%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E7%AD%94/"/>
      <url>/2021/01/19/rpc%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><h3 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h3><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 <em>HTTP请求</em> 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p><p>最终解决的问题：<strong>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。</strong></p><h3 id="RPC-简要原理"><a href="#RPC-简要原理" class="headerlink" title="RPC 简要原理"></a>RPC 简要原理</h3><p><img src="https://uploadfiles.nowcoder.com/images/20210115/6796629_1610698824988/A5B6F28E3286E3F920698A1D904CE4B0" alt="图片说明"> </p><ol><li>服务消费方（client）调用以本地调用方式调用服务； </li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </li><li>client stub找到服务地址，并将消息发送到服务端； </li><li>server stub收到消息后进行解码； </li><li>server stub根据解码结果调用本地的服务； </li><li>本地服务执行并将结果返回给server stub； </li><li>server stub将返回结果打包成消息并发送至消费方； </li><li>client stub接收到消息，并进行解码； </li><li>服务消费方得到最终结果。 </li></ol><h3 id="业界常用的-RPC-框架"><a href="#业界常用的-RPC-框架" class="headerlink" title="业界常用的 RPC 框架"></a>业界常用的 RPC 框架</h3><ul><li><strong>Dubbo:</strong> Dubbo 是<a href>阿里巴巴</a>公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。 </li><li><strong>gRPC</strong> ：gRPC 是可以在任何环境中运行的现***源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。 </li><li><strong>Hessian：</strong> Hessian是一个轻量级的 remoting-on-http 工具，使用简单的方法提供了 RMI 的功能。 相比 WebService，Hessian 更简单、快捷。采用的是二进制 RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。 </li></ul><h3 id="为什么用-RPC，不用-HTTP"><a href="#为什么用-RPC，不用-HTTP" class="headerlink" title="为什么用 RPC，不用 HTTP"></a>为什么用 RPC，不用 HTTP</h3><p>首先需要指正，这两个并不是并行概念。RPC 是一种<strong>设计</strong>，就是为了解决<strong>不同服务之间的调用问题</strong>，完整的 RPC 实现一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p><p>而 HTTP 是一种传输协议，RPC 框架完全可以使用 HTTP 作为传输协议，也可以直接使用 TCP，使用不同的协议一般也是为了适应不同的场景。</p><p>使用 TCP 和使用 HTTP 各有优势：</p><p><strong>传输效率</strong>：</p><ul><li>TCP，通常自定义上层协议，可以让请求报文体积更小 </li><li>HTTP：如果是基于HTTP 1.1 的协议，请求中会包含很多无用的内容 </li></ul><p><strong>性能消耗</strong>，主要在于序列化和反序列化的耗时</p><ul><li>TCP，可以基于各种序列化框架进行，效率比较高 </li><li>HTTP，大部分是通过 json 来实现的，字节大小和序列化耗时都要更消耗性能 </li></ul><p><strong>跨平台</strong>：</p><ul><li>TCP：通常要求<a href>客户端</a>和服务器为统一平台 </li><li>HTTP：可以在各种异构系统上运行 </li></ul><p><strong>总结</strong>：<br>  RPC 的 TCP 方式主要用于公司内部的服务调用，性能消耗低，传输效率高。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="调用如何在客户端无感（动态代理）"><a href="#调用如何在客户端无感（动态代理）" class="headerlink" title="调用如何在客户端无感（动态代理）"></a>调用如何在<a href>客户端</a>无感（动态代理）</h3><p>基于动态代理生成代理对象，当调用代理对象的方法时，由代理进行相关信息（方法、参数等）的组装并发送到服务器进行远程调用，并由代理接收调用结果并返回。</p><h3 id="动态代理和静态代理的区别"><a href="#动态代理和静态代理的区别" class="headerlink" title="动态代理和静态代理的区别"></a>动态代理和静态代理的区别</h3><p>静态代理的代理对象和被代理对象在代理之前就已经确定，它们都实现相同的接口或继承相同的抽象类。静态代理模式一般由业务实现类和业务代理类组成，业务实现类里面实现主要的业务逻辑，业务代理类负责在业务方法调用的前后作一些你需要的处理，以实现业务逻辑与业务方法外的功能解耦，减少了对业务方法的入侵。静态代理又可细分为：基于继承的方式和基于聚合的方式实现。</p><p>静态代理模式的代理类，只是实现了特定类的代理，代理类对象的方法越多，你就得写越多的重复的代码。动态代理就可以动态的生成代理类，实现对不同类下的不同方法的代理。</p><p>JDK 动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用业务方法前调用<code>InvocationHandler</code> 处理。代理类必须实现 <code>InvocationHandler</code> 接口，并且，JDK 动态代理只能代理实现了接口的类</p><h3 id="JDK-动态代理的步骤"><a href="#JDK-动态代理的步骤" class="headerlink" title="JDK 动态代理的步骤"></a>JDK 动态代理的步骤</h3><p>使用 JDK 动态代理类基本步骤：</p><p>1、编写需要被代理的类和接口</p><p>2、编写代理类，需要实现 <code>InvocationHandler</code> 接口，重写 <code>invoke()</code> 方法；</p><p>3、使用<code>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>动态创建代理类对象，通过代理类对象调用业务方法。</p><h3 id="如果想代理没有实现接口的对象"><a href="#如果想代理没有实现接口的对象" class="headerlink" title="如果想代理没有实现接口的对象"></a>如果想代理没有实现接口的对象</h3><p>CGLIB 框架实现了对无接口的对象进行代理的方式。JDK 动态代理是基于接口实现的，而 CGLIB 是基于继承实现的。它会对目标类产生一个代理子类，通过方法拦截技术对过滤父类的方法调用。代理子类需要实现 <code>MethodInterceptor</code> 接口。</p><p>CGLIB 底层是通过 asm 字节码框架实时生成类的字节码，达到动态创建类的目的，效率较 JDK 动态代理低。Spring 中的 AOP 就是基于动态代理的，如果被代理类实现了某个接口，Spring 会采用 JDK 动态代理，否则会采用 CGLIB。</p><h3 id="可以写一个动态代理的例子吗"><a href="#可以写一个动态代理的例子吗" class="headerlink" title="可以写一个动态代理的例子吗"></a>可以写一个动态代理的例子吗</h3><p><del>不可以</del></p><p><a href="#">复制代码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface&#96; &#96;DemoInterface &#123;&#96;&#96;  &#96;&#96;String hello(String msg);&#96;&#96;&#125;&#96; &#96;class&#96; &#96;DemoImpl &#96;&#96;implements&#96; &#96;DemoInterface &#123;&#96;&#96;  &#96;&#96;@Override&#96;&#96;  &#96;&#96;public&#96; &#96;String hello(String msg) &#123;&#96;&#96;    &#96;&#96;System.out.println(&#96;&#96;&quot;msg &#x3D; &quot;&#96; &#96;+ msg);&#96;&#96;    &#96;&#96;return&#96; &#96;&quot;hello&quot;&#96;&#96;;&#96;&#96;  &#96;&#96;&#125;&#96;&#96;&#125;&#96; &#96;class&#96; &#96;DemoProxy &#96;&#96;implements&#96; &#96;InvocationHandler &#123;&#96; &#96;  &#96;&#96;private&#96; &#96;DemoInterface service;&#96; &#96;  &#96;&#96;public&#96; &#96;DemoProxy(DemoInterface service) &#123;&#96;&#96;    &#96;&#96;this&#96;&#96;.service &#x3D; service;&#96;&#96;  &#96;&#96;&#125;&#96; &#96;  &#96;&#96;@Override&#96;&#96;  &#96;&#96;public&#96; &#96;Object invoke(Object obj, Method method, Object[] args) &#96;&#96;throws&#96; &#96;Throwable &#123;&#96;&#96;    &#96;&#96;System.out.println(&#96;&#96;&quot;调用方法前...&quot;&#96;&#96;);&#96;&#96;    &#96;&#96;Object returnValue &#x3D; method.invoke(service, args);&#96;&#96;    &#96;&#96;System.out.println(&#96;&#96;&quot;调用方法后...&quot;&#96;&#96;);&#96;&#96;    &#96;&#96;return&#96; &#96;returnValue;&#96;&#96;  &#96;&#96;&#125;&#96; &#96;&#125;&#96; &#96;public&#96; &#96;class&#96; &#96;Solution &#123;&#96;&#96;  &#96;&#96;public&#96; &#96;static&#96; &#96;void&#96; &#96;main(String[] args) &#123;&#96;&#96;    &#96;&#96;DemoProxy proxy &#x3D; &#96;&#96;new&#96; &#96;DemoProxy(&#96;&#96;new&#96; &#96;DemoImpl());&#96;&#96;    &#96;&#96;DemoInterface service &#x3D; Proxy.newInstance(&#96;&#96;      &#96;&#96;DemoInterface.&#96;&#96;class&#96;&#96;.getClassLoader(),&#96;&#96;      &#96;&#96;new&#96; &#96;Class&lt;?&gt;[]&#123;DemoInterface.&#96;&#96;class&#96;&#96;&#125;,&#96;&#96;      &#96;&#96;proxy&#96;&#96;    &#96;&#96;);&#96;&#96;    &#96;&#96;System.out.println(service.hello(&#96;&#96;&quot;呀哈喽！&quot;&#96;&#96;));&#96;&#96;  &#96;&#96;&#125;&#96;&#96;&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><a href="#">复制代码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用方法前...&#96;&#96;msg &#x3D; 呀哈喽！&#96;&#96;调用方法后...&#96;&#96;hello</span><br></pre></td></tr></table></figure><h3 id="对象是怎么在网络中传输的（序列化）"><a href="#对象是怎么在网络中传输的（序列化）" class="headerlink" title="对象是怎么在网络中传输的（序列化）"></a>对象是怎么在网络中传输的（序列化）</h3><p>通过将对象序列化成字节数组，即可将对象发送到网络中。</p><blockquote><p><strong>序列化</strong>（serialization）在计算机科学的资料处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p>在 Java 中，想要序列化一个对象，这个对象所属的类必须实现了 <code>Serializable</code> 接口，并且其内部属性必须都是可序列化的。如果有一个属性不是可序列化的，则该属性必须被声明为 <code>transient</code>。</p><p>JDK 中提供了 ObjectOutStream 类来对对象进行序列化。</p><h3 id="你的框架实现了哪几种序列化方式，可以介绍下吗"><a href="#你的框架实现了哪几种序列化方式，可以介绍下吗" class="headerlink" title="你的框架实现了哪几种序列化方式，可以介绍下吗"></a>你的框架实现了哪几种序列化方式，可以介绍下吗</h3><p>实现了 JSON、Kryo、Hessian 和 <a href>Proto</a>buf 的序列化。</p><p>JSON 是一种轻量级的数据交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象，类似 xml，Json 比 xml更小、更快更容易解析。JSON 由于采用字符方式存储，占用相对于字节方式较大，并且序列化后类的信息会丢失，可能导致反序列化失败。</p><p>剩下的都是基于字节的序列化。</p><p>Kryo 是一个快速高效的 Java 序列化框架，旨在提供快速、高效和易用的 API。无论文件、数据库或网络数据 Kryo 都可以随时完成序列化。 Kryo 还可以执行自动深拷贝、浅拷贝。这是对象到对象的直接拷贝，而不是对象-&gt;字节-&gt;对象的拷贝。kryo 速度较快，序列化后体积较小，但是跨语言支持较复杂。</p><p>Hessian 是一个基于二进制的协议，Hessian 支持很多种语言，例如 Java、python、c++,、net/c#、D、Erlang、PHP、Ruby、object-c等，它的序列化和反序列化也是非常高效。速度较慢，序列化后的体积较大。</p><p>protobuf（<a href>Proto</a>col Buffers）是由 Google 发布的数据交换格式，提供跨语言、跨平台的序列化和反序列化实现，底层由 C++ 实现，其他平台使用时必须使用 protocol compiler 进行预编译生成 protoc 二进制文件。性能主要消耗在文件的预编译上。序列化反序列化性能较高，平台无关。</p><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="简单介绍一下-Netty"><a href="#简单介绍一下-Netty" class="headerlink" title="简单介绍一下 Netty"></a>简单介绍一下 Netty</h3><p>Netty 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和<a href>客户端</a>。Netty 基于 NIO 的，封装了 JDK 的 NIO，让我们使用起来更加方法灵活。</p><p>特点和优势：</p><ul><li>使用简单：封装了 NIO 的很多细节，使用更简单。 </li><li>功能强大：预置了多种编解码功能，支持多种主流协议。 </li><li>定制能力强：可以通过 ChannelHandler 对通信框架进行灵活地扩展。 </li><li>性能高：通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优。 </li></ul><h3 id="为什么-Netty-性能高"><a href="#为什么-Netty-性能高" class="headerlink" title="为什么 Netty 性能高"></a>为什么 Netty 性能高</h3><ul><li>IO 线程模型：同步非阻塞，用最少的资源做更多的事。 </li><li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。 </li><li>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。 </li><li>串行化处理读写：避免使用锁带来的性能开销。 </li><li>高性能序列化协议：支持 protobuf 等高性能序列化协议。 </li></ul><h3 id="简单说下-BIO、NIO-和-AIO"><a href="#简单说下-BIO、NIO-和-AIO" class="headerlink" title="简单说下 BIO、NIO 和 AIO"></a>简单说下 BIO、NIO 和 AIO</h3><p>BIO：一个连接一个线程，<a href>客户端</a>有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</p><p>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。</p><p>NIO：一个请求一个线程，但<a href>客户端</a>发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p><p>AIO：一个有效请求一个线程，<a href>客户端</a>的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p><h3 id="Netty的线程模型？"><a href="#Netty的线程模型？" class="headerlink" title="Netty的线程模型？"></a>Netty的线程模型？</h3><p>Netty 通过 Reactor 模型基于多路复用器接收并处理用户请求，内部实现了两个线程池， boss 线程池和 worker 线程池，其中 boss 线程池的线程负责处理请求的 accept 事件，当接收到 accept 事件的请求时，把对应的 socket 封装到一个 NioSocketChannel 中，并交给 worker 线程池，其中 worker 线程池负责请求的 read 和 write 事件，由对应的Handler 处理。</p><p>单线程模型：所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor 线程上完成的。既要接收<a href>客户端</a>的连接请求,向服务端发起连接，又要发送/读取请求或应答/响应消息。一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。</p><p>多线程模型：有一个NIO 线程（Acceptor） 只负责监听服务端，接收<a href>客户端</a>的TCP 连接请求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题。但在并发百万<a href>客户端</a>连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。</p><p>主从多线程模型：Acceptor 线程用于绑定监听端口，接收<a href>客户端</a>连接，将SocketChannel 从主线程池的 Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I/O 的读写等操作，从而保证 mainReactor 只负责接入认证、握手等操作；</p><h3 id="如何解决-TCP-的粘包拆包问题"><a href="#如何解决-TCP-的粘包拆包问题" class="headerlink" title="如何解决 TCP 的粘包拆包问题"></a>如何解决 TCP 的粘包拆包问题</h3><p>TCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</p><p>TCP 粘包/分包的原因：应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</p><p>Netty 自带解决方式：</p><ul><li>消息定长：FixedLengthFrameDecoder 类</li><li>包尾增加特殊字符分割：<ul><li>行分隔符类：LineBasedFrameDecoder </li><li>自定义分隔符类 ：DelimiterBasedFrameDecoder </li></ul></li><li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li></ul><p>框架解决方式：</p><p>自定义协议，其中有字段标明包长度。</p><h3 id="说下-Netty-零拷贝"><a href="#说下-Netty-零拷贝" class="headerlink" title="说下 Netty 零拷贝"></a>说下 Netty 零拷贝</h3><p>Netty 的零拷贝主要包含三个方面：</p><ul><li>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。 </li><li>Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。 </li><li>Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。 </li></ul><h3 id="简单说下-Netty-中的重要组件"><a href="#简单说下-Netty-中的重要组件" class="headerlink" title="简单说下 Netty 中的重要组件"></a>简单说下 Netty 中的重要组件</h3><ul><li>Channel：Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 等。 </li><li>EventLoop：主要是配合 Channel 处理 I/O 操作，用来处理连接的生命周期中所发生的事情。 </li><li>ChannelFuture：Netty 框架中所有的 I/O 操作都为异步的，因此我们需要 ChannelFuture 的 addListener()注册一个 ChannelFutureListener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。 </li><li>ChannelHandler：充当了所有处理入站和出站数据的逻辑容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。 </li><li>ChannelPipeline：为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 ChannelPipeline，这个关联是永久性的。 </li></ul><h3 id="Netty-中责任链"><a href="#Netty-中责任链" class="headerlink" title="Netty 中责任链"></a>Netty 中责任链</h3><p>首先说明责任链模式：</p><p>适用场景:</p><ul><li>对于一个请求来说,如果有个对象都有机会处理它,而且不明确到底是哪个对象会处理请求时,我们可以考虑使用责任链模式实现它,让请求从链的头部往后移动,直到链上的一个节点成功处理了它为止 </li></ul><p>优点:</p><ul><li>发送者不需要知道自己发送的这个请求到底会被哪个对象处理掉,实现了发送者和接受者的解耦 </li><li>简化了发送者对象的设计 </li><li>可以动态的添加节点和删除节点 </li></ul><p>缺点:</p><ul><li>所有的请求都从链的头部开始遍历,对性能有损耗 </li><li>极差的情况,不保证请求一定会被处理 </li></ul><p>Netty的责任链：</p><p>netty 的 pipeline 设计,就采用了责任链设计模式, 底层采用双向<a href>链表</a>的数据结构, 将链上的各个处理器串联起来</p><p><a href>客户端</a>每一个请求的到来，netty 都认为，pipeline 中的所有的处理器都有机会处理它，因此，对于入栈的请求，全部从头节点开始往后传播，一直传播到尾节点（来到尾节点的 msg 会被释放掉）。</p><p>责任终止机制</p><ul><li>在pipeline中的任意一个节点，只要我们不手动的往下传播下去，这个事件就会终止传播在当前节点 </li><li>对于入站数据，默认会传递到尾节点，进行回收，如果我们不进行下一步传播，事件就会终止在当前节点 </li></ul><h3 id="Netty-是如何保持长连接的（心跳）"><a href="#Netty-是如何保持长连接的（心跳）" class="headerlink" title="Netty 是如何保持长连接的（心跳）"></a>Netty 是如何保持长连接的（心跳）</h3><p>首先 TCP 协议的实现中也提供了 <a href>keep</a>alive 报文用来探测对端是否可用。TCP 层将在定时时间到后发送相应的 KeepAlive 探针以确定连接可用性。</p><p><code>ChannelOption.SO_KEEPALIVE, true</code> 表示打开 TCP 的 <a href>keep</a>Alive 设置。</p><p>TCP 心跳的问题：</p><p>考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态，对<a href>客户端</a>而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态一直向当前服务器发送些必然会失败的请求。</p><p>Netty 中提供了 <code>IdleStateHandler</code> 类专门用于处理心跳。</p><p><code>IdleStateHandler</code> 的构造函数如下：</p><p><a href="#">复制代码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public&#96; &#96;IdleStateHandler(&#96;&#96;long&#96; &#96;readerIdleTime, &#96;&#96;long&#96; &#96;writerIdleTime, &#96;&#96;            &#96;&#96;long&#96; &#96;allIdleTime,TimeUnit unit)&#123;&#96;&#96;&#125;</span><br></pre></td></tr></table></figure><p>第一个参数是隔多久检查一下读事件是否发生，如果 <code>channelRead()</code> 方法超过 readerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p><p>第二个参数是隔多久检查一下写事件是否发生，writerIdleTime 写空闲超时时间设定，如果 <code>write()</code> 方法超过 writerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p><p>第三个参数是全能型参数，隔多久检查读写事件；</p><p>第四个参数表示当前的时间单位。</p><p>所以这里可以分别控制读，写，读写超时的时间，单位为秒，如果是0表示不检测，所以如果全是0，则相当于没添加这个 IdleStateHandler，连接是个普通的短连接。</p>]]></content>
      
      
      <categories>
          
          <category> rpc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop的启动</title>
      <link href="/2021/01/13/Hadoop%E7%9A%84%E5%90%AF%E5%8A%A8/"/>
      <url>/2021/01/13/Hadoop%E7%9A%84%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>3.1 虚拟机环境准备</p><ol><li>克隆虚拟机        </li><li>修改克隆虚拟机的静态IP</li><li>修改主机名</li><li>关闭防火墙</li><li>创建atguigu用户</li><li>配置atguigu用户具有root权限（详见《尚硅谷大数据技术之Linux》）<br>7．在/opt目录下创建文件夹<br>（1）在/opt目录下创建module、software文件夹<br>[atguigu@hadoop101 opt]$ sudo mkdir module<br>[atguigu@hadoop101 opt]$ sudo mkdir software<br>（2）修改module、software文件夹的所有者cd<br>[atguigu@hadoop101 opt]$ sudo chown atguigu:atguigu module/ software/<br>[atguigu@hadoop101 opt]$ ll<br>总用量 8<br>drwxr-xr-x. 2 atguigu atguigu 4096 1月  17 14:37 module<br>drwxr-xr-x. 2 atguigu atguigu 4096 1月  17 14:38 software</li><li>2 安装JDK</li><li>卸载现有JDK<br>（1）查询是否安装Java软件：<br>[atguigu@hadoop101 opt]$ rpm -qa | grep java<br>（2）如果安装的版本低于1.7，卸载该JDK：<br>[atguigu@hadoop101 opt]$ sudo rpm -e 软件包<br>（3）查看JDK安装路径：<br>[atguigu@hadoop101 ~]$ which java</li><li>用SecureCRT工具将JDK导入到opt目录下面的software文件夹下面，如图2-28所示</li></ol><p>图2-28  导入JDK<br>“alt+p”进入sftp模式，如图2-29所示</p><p>图2-29 进入sftp模式<br>选择jdk1.8拖入，如图2-30，2-31所示</p><p>图2-30 拖入jdk1.8</p><p>图2-31 拖入jdk1.8完成<br>3.    在Linux系统下的opt目录中查看软件包是否导入成功<br>[atguigu@hadoop101 opt]$ cd software/<br>[atguigu@hadoop101 software]$ ls<br>hadoop-2.7.2.tar.gz  jdk-8u144-linux-x64.tar.gz<br>4.    解压JDK到/opt/module目录下<br>[atguigu@hadoop101 software]$ tar -zxvf jdk-8u144-linux-x64.tar.gz -C /opt/module/<br>5.    配置JDK环境变量<br>    （1）先获取JDK路径<br>[atguigu@hadoop101 jdk1.8.0_144]$ pwd<br>/opt/module/jdk1.8.0_144<br>    （2）打开/etc/profile文件<br>[atguigu@hadoop101 software]$ sudo vi /etc/profile<br>在profile文件末尾添加JDK路径<br>#JAVA_HOME<br>export JAVA_HOME=/opt/module/jdk1.8.0_144<br>export PATH=$PATH:$JAVA_HOME/bin<br>    （3）保存后退出<br>:wq<br>    （4）让修改后的文件生效<br>[atguigu@hadoop101 jdk1.8.0_144]$ source /etc/profile<br>6.    测试JDK是否安装成功<br>[atguigu@hadoop101 jdk1.8.0_144]# java -version<br>java version “1.8.0_144”<br>      注意：重启（如果java -version可以用就不用重启）<br>[atguigu@hadoop101 jdk1.8.0_144]$ sync<br>[atguigu@hadoop101 jdk1.8.0_144]$ sudo reboot<br>3.3 安装Hadoop<br>0.  Hadoop下载地址：<br><a href="https://archive.apache.org/dist/hadoop/common/hadoop-2.7.2/" target="_blank" rel="noopener">https://archive.apache.org/dist/hadoop/common/hadoop-2.7.2/</a></p><ol><li>用SecureCRT工具将hadoop-2.7.2.tar.gz导入到opt目录下面的software文件夹下面<br>切换到sftp连接页面，选择Linux下编译的hadoop jar包拖入，如图2-32所示</li></ol><p>图2-32 拖入hadoop的tar包</p><p>图2-33 拖入Hadoop的tar包成功<br>2.    进入到Hadoop安装包路径下<br>[atguigu@hadoop101 ~]$ cd /opt/software/<br>3.    解压安装文件到/opt/module下面<br>[atguigu@hadoop101 software]$ tar -zxvf hadoop-2.7.2.tar.gz -C /opt/module/<br>4.    查看是否解压成功<br>[atguigu@hadoop101 software]$ ls /opt/module/<br>hadoop-2.7.2<br>5.    将Hadoop添加到环境变量<br>    （1）获取Hadoop安装路径<br>[atguigu@hadoop101 hadoop-2.7.2]$ pwd<br>/opt/module/hadoop-2.7.2<br>    （2）打开/etc/profile文件<br>[atguigu@hadoop101 hadoop-2.7.2]$ sudo vi /etc/profile<br>在profile文件末尾添加JDK路径：（shitf+g）<br>##HADOOP_HOME<br>export HADOOP_HOME=/opt/module/hadoop-2.7.2<br>export PATH=$PATH:$HADOOP_HOME/bin<br>export PATH=$PATH:$HADOOP_HOME/sbin<br>（3）保存后退出<br>:wq<br>    （4）让修改后的文件生效<br>[atguigu@ hadoop101 hadoop-2.7.2]$ source /etc/profile<br>6.    测试是否安装成功<br>[atguigu@hadoop101 hadoop-2.7.2]$ hadoop version<br>Hadoop 2.7.2<br>7.    重启(如果Hadoop命令不能用再重启)<br>[atguigu@ hadoop101 hadoop-2.7.2]$ sync<br>[atguigu@ hadoop101 hadoop-2.7.2]$ sudo reboot<br>3.4 Hadoop目录结构<br>1、查看Hadoop目录结构<br>[atguigu@hadoop101 hadoop-2.7.2]$ ll<br>总用量 52<br>drwxr-xr-x. 2 atguigu atguigu  4096 5月  22 2017 bin<br>drwxr-xr-x. 3 atguigu atguigu  4096 5月  22 2017 etc<br>drwxr-xr-x. 2 atguigu atguigu  4096 5月  22 2017 include<br>drwxr-xr-x. 3 atguigu atguigu  4096 5月  22 2017 lib<br>drwxr-xr-x. 2 atguigu atguigu  4096 5月  22 2017 libexec<br>-rw-r–r–. 1 atguigu atguigu 15429 5月  22 2017 LICENSE.txt<br>-rw-r–r–. 1 atguigu atguigu   101 5月  22 2017 NOTICE.txt<br>-rw-r–r–. 1 atguigu atguigu  1366 5月  22 2017 README.txt<br>drwxr-xr-x. 2 atguigu atguigu  4096 5月  22 2017 sbin<br>drwxr-xr-x. 4 atguigu atguigu  4096 5月  22 2017 share<br>2、重要目录<br>（1）bin目录：存放对Hadoop相关服务（HDFS,YARN）进行操作的脚本<br>（2）etc目录：Hadoop的配置文件目录，存放Hadoop的配置文件<br>（3）lib目录：存放Hadoop的本地库（对数据进行压缩解压缩功能）<br>（4）sbin目录：存放启动或停止Hadoop相关服务的脚本<br>（5）share目录：存放Hadoop的依赖jar包、文档、和官方案例<br>第4章 Hadoop运行模式<br>Hadoop运行模式包括：本地模式、伪分布式模式以及完全分布式模式。<br>Hadoop官方网站：<a href="http://hadoop.apache.org/" target="_blank" rel="noopener">http://hadoop.apache.org/</a><br>4.1 本地运行模式<br>4.1.1 官方Grep案例</p><ol><li>创建在hadoop-2.7.2文件下面创建一个input文件夹<br>[atguigu@hadoop101 hadoop-2.7.2]$ mkdir input</li><li>将Hadoop的xml配置文件复制到input<br>[atguigu@hadoop101 hadoop-2.7.2]$ cp etc/hadoop/*.xml input</li><li>执行share目录下的MapReduce程序<br>[atguigu@hadoop101 hadoop-2.7.2]$ bin/hadoop jar<br>share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar grep input output ‘dfs[a-z.]+’</li><li>查看输出结果<br>[atguigu@hadoop101 hadoop-2.7.2]$ cat output/*</li><li>1.2 官方WordCount案例</li><li>创建在hadoop-2.7.2文件下面创建一个wcinput文件夹<br>[atguigu@hadoop101 hadoop-2.7.2]$ mkdir wcinput</li><li>在wcinput文件下创建一个wc.input文件<br>[atguigu@hadoop101 hadoop-2.7.2]$ cd wcinput<br>[atguigu@hadoop101 wcinput]$ touch wc.input</li><li>编辑wc.input文件<br>[atguigu@hadoop101 wcinput]$ vi wc.input<br>在文件中输入如下内容<br>hadoop yarn<br>hadoop mapreduce<br>atguigu<br>atguigu<br>保存退出：：wq</li><li>回到Hadoop目录/opt/module/hadoop-2.7.2</li><li>执行程序<br>[atguigu@hadoop101 hadoop-2.7.2]$ hadoop jar<br>share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount wcinput wcoutput</li><li>查看结果<br>[atguigu@hadoop101 hadoop-2.7.2]$ cat wcoutput/part-r-00000<br>atguigu 2<br>hadoop  2<br>mapreduce       1<br>yarn    1</li><li>2 伪分布式运行模式</li><li>2.1 启动HDFS并运行MapReduce程序</li><li>分析<br>（1）配置集群<br>（2）启动、测试集群增、删、查<br>（3）执行WordCount案例</li><li>执行步骤<br>（1）配置集群<br>  （a）配置：hadoop-env.sh<br>Linux系统中获取JDK的安装路径：<br>[atguigu@ hadoop101 ~]# echo $JAVA_HOME<br>/opt/module/jdk1.8.0_144<br>修改JAVA_HOME 路径：<br>export JAVA_HOME=/opt/module/jdk1.8.0_144<br>（b）配置：core-site.xml<!-- 指定HDFS中NameNode的地址 --><property><name>fs.defaultFS</name><value>hdfs://hadoop101:9000</value></property></li></ol><!-- 指定Hadoop运行时产生文件的存储目录 --><property>    <name>hadoop.tmp.dir</name>    <value>/opt/module/hadoop-2.7.2/data/tmp</value></property>（c）配置：hdfs-site.xml<!-- 指定HDFS副本的数量 --><property>    <name>dfs.replication</name>    <value>1</value></property>（2）启动集群（a）格式化NameNode（第一次启动时格式化，以后就不要总格式化）[atguigu@hadoop101 hadoop-2.7.2]$ bin/hdfs namenode -format        （b）启动NameNode[atguigu@hadoop101 hadoop-2.7.2]$ sbin/hadoop-daemon.sh start namenode        （c）启动DataNode[atguigu@hadoop101 hadoop-2.7.2]$ sbin/hadoop-daemon.sh start datanode（3）查看集群        （a）查看是否启动成功[atguigu@hadoop101 hadoop-2.7.2]$ jps13586 NameNode13668 DataNode13786 Jps注意：jps是JDK中的命令，不是Linux命令。不安装JDK不能使用jps        （b）web端查看HDFS文件系统http://hadoop101:50070/dfshealth.html#tab-overview注意：如果不能查看，看如下帖子处理http://www.cnblogs.com/zlslch/p/6604189.html<p><a href="https://blog.csdn.net/stpeace/article/details/79426471?utm_source=blogxgwz7" target="_blank" rel="noopener">https://blog.csdn.net/stpeace/article/details/79426471?utm_source=blogxgwz7</a></p><p><a href="https://blog.csdn.net/stpeace/article/details/79426471" target="_blank" rel="noopener">https://blog.csdn.net/stpeace/article/details/79426471</a>        </p><p>（c）查看产生的Log日志<br>          说明：在企业中遇到Bug时，经常根据日志提示信息去分析问题、解决Bug。<br>当前目录：/opt/module/hadoop-2.7.2/logs<br>[atguigu@hadoop101 logs]$ ls<br>hadoop-atguigu-datanode-hadoop.atguigu.com.log<br>hadoop-atguigu-datanode-hadoop.atguigu.com.out<br>hadoop-atguigu-namenode-hadoop.atguigu.com.log<br>hadoop-atguigu-namenode-hadoop.atguigu.com.out<br>SecurityAuth-root.audit<br>[atguigu@hadoop101 logs]# cat hadoop-atguigu-datanode-hadoop101.log<br>（d）思考：为什么不能一直格式化NameNode，格式化NameNode，要注意什么？<br>[atguigu@hadoop101 hadoop-2.7.2]$ cd data/tmp/dfs/name/current/<br>[atguigu@hadoop101 current]$ cat VERSION<br>clusterID=CID-f0330a58-36fa-4a2a-a65f-2688269b5837</p><p>[atguigu@hadoop101 hadoop-2.7.2]$ cd data/tmp/dfs/data/current/<br>clusterID=CID-f0330a58-36fa-4a2a-a65f-2688269b5837</p><p>注意：格式化NameNode，会产生新的集群id,导致NameNode和DataNode的集群id不一致，集群找不到已往数据。所以，格式NameNode时，一定要先删除data数据和log日志，然后再格式化NameNode。<br>（4）操作集群<br>        （a）在HDFS文件系统上创建一个input文件夹<br>[atguigu@hadoop101 hadoop-2.7.2]$ bin/hdfs dfs -mkdir -p /user/atguigu/input<br>        （b）将测试文件内容上传到文件系统上<br>[atguigu@hadoop101 hadoop-2.7.2]$bin/hdfs dfs -put wcinput/wc.input<br>  /user/atguigu/input/<br>        （c）查看上传的文件是否正确<br>[atguigu@hadoop101 hadoop-2.7.2]$ bin/hdfs dfs -ls  /user/atguigu/input/<br>[atguigu@hadoop101 hadoop-2.7.2]$ bin/hdfs dfs -cat  /user/atguigu/ input/wc.input<br>        （d）运行MapReduce程序<br>[atguigu@hadoop101 hadoop-2.7.2]$ bin/hadoop jar<br>share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/atguigu/input/ /user/atguigu/output<br>        （e）查看输出结果<br>命令行查看：<br>[atguigu@hadoop101 hadoop-2.7.2]$ bin/hdfs dfs -cat /user/atguigu/output/*<br>浏览器查看，如图2-34所示</p><p>图2-34 查看output文件<br>        （f）将测试文件内容下载到本地<br>[atguigu@hadoop101 hadoop-2.7.2]$ hdfs dfs -get /user/atguigu/output/part-r-00000 ./wcoutput/<br>（g）删除输出结果<br>[atguigu@hadoop101 hadoop-2.7.2]$ hdfs dfs -rm -r /user/atguigu/output<br>4.2.2 启动YARN并运行MapReduce程序</p><ol><li>分析<br>（1）配置集群在YARN上运行MR<br>（2）启动、测试集群增、删、查<br>（3）在YARN上执行WordCount案例</li><li>执行步骤<br>（1）配置集群<br>  （a）配置yarn-env.sh<br>配置一下JAVA_HOME<br>export JAVA_HOME=/opt/module/jdk1.8.0_144<br>（b）配置yarn-site.xml<!-- Reducer获取数据的方式 --><property>   <name>yarn.nodemanager.aux-services</name>   <value>mapreduce_shuffle</value></property></li></ol><!-- 指定YARN的ResourceManager的地址 --><property><name>yarn.resourcemanager.hostname</name><value>hadoop101</value></property>        （c）配置：mapred-env.sh配置一下JAVA_HOMEexport JAVA_HOME=/opt/module/jdk1.8.0_144        （d）配置： (对mapred-site.xml.template重新命名为) mapred-site.xml[atguigu@hadoop101 hadoop]$ mv mapred-site.xml.template mapred-site.xml[atguigu@hadoop101 hadoop]$ vi mapred-site.xml<!-- 指定MR运行在YARN上 --><property>        <name>mapreduce.framework.name</name>        <value>yarn</value></property>（2）启动集群（a）启动前必须保证NameNode和DataNode已经启动（b）启动ResourceManager[atguigu@hadoop101 hadoop-2.7.2]$ sbin/yarn-daemon.sh start resourcemanager（c）启动NodeManager[atguigu@hadoop101 hadoop-2.7.2]$ sbin/yarn-daemon.sh start nodemanager    （3）集群操作（a）YARN的浏览器页面查看，如图2-35所示http://hadoop101:8088/cluster<p>图2-35 YARN的浏览器页面<br>        （b）删除文件系统上的output文件<br>[atguigu@hadoop101 hadoop-2.7.2]$ bin/hdfs dfs -rm -R /user/atguigu/output<br>        （c）执行MapReduce程序<br>[atguigu@hadoop101 hadoop-2.7.2]$ bin/hadoop jar<br> share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/atguigu/input  /user/atguigu/output<br>        （d）查看运行结果，如图2-36所示<br>[atguigu@hadoop101 hadoop-2.7.2]$ bin/hdfs dfs -cat /user/atguigu/output/*</p><p>图2-36 查看运行结果<br>4.2.3 配置历史服务器<br>为了查看程序的历史运行情况，需要配置一下历史服务器。具体配置步骤如下：</p><ol><li>配置mapred-site.xml<br>[atguigu@hadoop101 hadoop]$ vi mapred-site.xml<br>在该文件里面增加如下配置。<!-- 历史服务器端地址 --><property><name>mapreduce.jobhistory.address</name><value>hadoop101:10020</value></property><!-- 历史服务器web端地址 --><property><name>mapreduce.jobhistory.webapp.address</name><value>hadoop101:19888</value></property></li><li>启动历史服务器<br>[atguigu@hadoop101 hadoop-2.7.2]$ sbin/mr-jobhistory-daemon.sh start historyserver</li><li>查看历史服务器是否启动<br>[atguigu@hadoop101 hadoop-2.7.2]$ jps</li><li>查看JobHistory<br><a href="http://hadoop101:19888/jobhistory" target="_blank" rel="noopener">http://hadoop101:19888/jobhistory</a></li><li>2.4 配置日志的聚集<br>日志聚集概念：应用运行完成以后，将程序运行日志信息上传到HDFS系统上。<br>日志聚集功能好处：可以方便的查看到程序运行详情，方便开发调试。<br>注意：开启日志聚集功能，需要重新启动NodeManager 、ResourceManager和HistoryManager。<br>开启日志聚集功能具体步骤如下：</li><li>配置yarn-site.xml<br>[atguigu@hadoop101 hadoop]$ vi yarn-site.xml<br>在该文件里面增加如下配置。<!-- 日志聚集功能使能 --><property><name>yarn.log-aggregation-enable</name><value>true</value></property></li></ol><!-- 日志保留时间设置7天 --><property><name>yarn.log-aggregation.retain-seconds</name><value>604800</value></property>2.    关闭NodeManager 、ResourceManager和HistoryManager[atguigu@hadoop101 hadoop-2.7.2]$ sbin/yarn-daemon.sh stop resourcemanager[atguigu@hadoop101 hadoop-2.7.2]$ sbin/yarn-daemon.sh stop nodemanager[atguigu@hadoop101 hadoop-2.7.2]$ sbin/mr-jobhistory-daemon.sh stop historyserver3.    启动NodeManager 、ResourceManager和HistoryManager[atguigu@hadoop101 hadoop-2.7.2]$ sbin/yarn-daemon.sh start resourcemanager[atguigu@hadoop101 hadoop-2.7.2]$ sbin/yarn-daemon.sh start nodemanager[atguigu@hadoop101 hadoop-2.7.2]$ sbin/mr-jobhistory-daemon.sh start historyserver4.    删除HDFS上已经存在的输出文件[atguigu@hadoop101 hadoop-2.7.2]$ bin/hdfs dfs -rm -R /user/atguigu/output5.    执行WordCount程序[atguigu@hadoop101 hadoop-2.7.2]$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/atguigu/input /user/atguigu/output6.    查看日志，如图2-37，2-38，2-39所示http://hadoop101:19888/jobhistory<p>图2-37  Job History</p><p>图2-38 job运行情况</p><p>图2-39 查看日志<br>4.2.5 配置文件说明<br>Hadoop配置文件分两类：默认配置文件和自定义配置文件，只有用户想修改某一默认配置值时，才需要修改自定义配置文件，更改相应属性值。<br>（1）默认配置文件：<br>表2-1<br>要获取的默认文件    文件存放在Hadoop的jar包中的位置<br>[core-default.xml]    hadoop-common-2.7.2.jar/ core-default.xml<br>[hdfs-default.xml]    hadoop-hdfs-2.7.2.jar/ hdfs-default.xml<br>[yarn-default.xml]    hadoop-yarn-common-2.7.2.jar/ yarn-default.xml<br>[mapred-default.xml]    hadoop-mapreduce-client-core-2.7.2.jar/ mapred-default.xml<br>    （2）自定义配置文件：<br>    core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml四个配置文件存放在$HADOOP_HOME/etc/hadoop这个路径上，用户可以根据项目需求重新进行修改配置。<br>4.3 完全分布式运行模式（开发重点）<br>分析：<br>    1）准备3台客户机（关闭防火墙、静态ip、主机名称）<br>    2）安装JDK<br>    3）配置环境变量<br>    4）安装Hadoop<br>    5）配置环境变量<br>6）配置集群<br>7）单点启动<br>    8）配置ssh<br>    9）群起并测试集群<br>4.3.1 虚拟机准备<br>详见3.1章。<br>4.3.2 编写集群分发脚本xsync</p><ol><li>scp（secure copy）安全拷贝<br>（1）scp定义：<br>scp可以实现服务器与服务器之间的数据拷贝。（from server1 to server2）<br>（2）基本语法<br>scp    -r          $pdir/$fname              $user@hadoop$host:$pdir/$fname<br>命令   递归       要拷贝的文件路径/名称    目的用户@主机:目的路径/名称<br>（3）案例实操<br>（a）在hadoop101上，将hadoop101中/opt/module目录下的软件拷贝到hadoop102上。<br>[atguigu@hadoop101 /]$ scp -r /opt/module  root@hadoop102:/opt/module<br>（b）在hadoop103上，将hadoop101服务器上的/opt/module目录下的软件拷贝到hadoop103上。<br>[atguigu@hadoop103 opt]$sudo scp -r atguigu@hadoop101:/opt/module root@hadoop103:/opt/module<br>（c）在hadoop103上操作将hadoop101中/opt/module目录下的软件拷贝到hadoop104上。<br>[atguigu@hadoop103 opt]$ scp -r atguigu@hadoop101:/opt/module root@hadoop104:/opt/module<br>注意：拷贝过来的/opt/module目录，别忘了在hadoop102、hadoop103、hadoop104上修改所有文件的，所有者和所有者组。sudo chown atguigu:atguigu -R /opt/module<br>（d）将hadoop101中/etc/profile文件拷贝到hadoop102的/etc/profile上。<br>[atguigu@hadoop101 ~]$ sudo scp /etc/profile root@hadoop102:/etc/profile<br>（e）将hadoop101中/etc/profile文件拷贝到hadoop103的/etc/profile上。<br>[atguigu@hadoop101 ~]$ sudo scp /etc/profile root@hadoop103:/etc/profile<br>（f）将hadoop101中/etc/profile文件拷贝到hadoop104的/etc/profile上。<br>[atguigu@hadoop101 ~]$ sudo scp /etc/profile root@hadoop104:/etc/profile<br>注意：拷贝过来的配置文件别忘了source一下/etc/profile，。</li><li>rsync 远程同步工具<br>rsync主要用于备份和镜像。具有速度快、避免复制相同内容和支持符号链接的优点。<br>rsync和scp区别：用rsync做文件的复制要比scp的速度快，rsync只对差异文件做更新。scp是把所有文件都复制过去。<br>（1）基本语法<br>rsync    -rvl       $pdir/$fname              $user@hadoop$host:$pdir/$fname<br>命令   选项参数   要拷贝的文件路径/名称    目的用户@主机:目的路径/名称<br>选项参数说明<br>表2-2<br>选项    功能</li></ol><p>-r    递归<br>-v    显示复制过程<br>-l    拷贝符号连接<br>（2）案例实操<br>        （a）把hadoop101机器上的/opt/software目录同步到hadoop102服务器的root用户下的/opt/目录<br>[atguigu@hadoop101 opt]$ rsync -rvl /opt/software/ root@hadoop102:/opt/software<br>3.    xsync集群分发脚本<br>（1）需求：循环复制文件到所有节点的相同目录下<br>    （2）需求分析：<br>（a）rsync命令原始拷贝：<br>rsync  -rvl     /opt/module           root@hadoop103:/opt/<br>        （b）期望脚本：<br>xsync要同步的文件名称<br>        （c）说明：在/home/atguigu/bin这个目录下存放的脚本，atguigu用户可以在系统任何地方直接执行。<br>（3）脚本实现<br>（a）在/home/atguigu目录下创建bin目录，并在bin目录下xsync创建文件，文件内容如下：<br>[atguigu@hadoop102 ~]$ mkdir bin<br>[atguigu@hadoop102 ~]$ cd bin/<br>[atguigu@hadoop102 bin]$ touch xsync<br>[atguigu@hadoop102 bin]$ vi xsync<br>在该文件中编写如下代码<br>#!/bin/bash<br>#1 获取输入参数个数，如果没有参数，直接退出<br>pcount=$#<br>if((pcount==0)); then<br>echo no args;<br>exit;<br>fi</p><p>#2 获取文件名称<br>p1=$1<br>fname=<code>basename $p1</code><br>echo fname=$fname</p><p>#3 获取上级目录到绝对路径<br>pdir=<code>cd -P $(dirname $p1); pwd</code><br>echo pdir=$pdir</p><p>#4 获取当前用户名称<br>user=<code>whoami</code></p><p>#5 循环<br>for((host=103; host&lt;105; host++)); do<br>        echo ——————- hadoop$host ————–<br>        rsync -rvl $pdir/$fname $user@hadoop$host:$pdir<br>done<br>（b）修改脚本 xsync 具有执行权限<br>[atguigu@hadoop102 bin]$ chmod 777 xsync<br>（c）调用脚本形式：xsync 文件名称<br>[atguigu@hadoop102 bin]$ xsync /home/atguigu/bin<br>注意：如果将xsync放到/home/atguigu/bin目录下仍然不能实现全局使用，可以将xsync移动到/usr/local/bin目录下。<br>4.3.3 集群配置</p><ol><li>集群部署规划<br>表2-3<br>hadoop102     hadoop103    hadoop104<br>HDFS<br>NameNode<br>DataNode<br>DataNode    SecondaryNameNode<br>DataNode<br>YARN<br>NodeManager    ResourceManager<br>NodeManager<br>NodeManager</li><li>配置集群<br>（1）核心配置文件<br>配置core-site.xml<br>[atguigu@hadoop102 hadoop]$ vi core-site.xml<br>在该文件中编写如下配置<!-- 指定HDFS中NameNode的地址 --><property>  <name>fs.defaultFS</name><value>hdfs://hadoop102:9000</value></property></li></ol><!-- 指定Hadoop运行时产生文件的存储目录 --><property>        <name>hadoop.tmp.dir</name>        <value>/opt/module/hadoop-2.7.2/data/tmp</value></property>    （2）HDFS配置文件配置hadoop-env.sh[atguigu@hadoop102 hadoop]$ vi hadoop-env.shexport JAVA_HOME=/opt/module/jdk1.8.0_144配置hdfs-site.xml[atguigu@hadoop102 hadoop]$ vi hdfs-site.xml在该文件中编写如下配置<property>        <name>dfs.replication</name>        <value>3</value></property><!-- 指定Hadoop辅助名称节点主机配置 --><property>      <name>dfs.namenode.secondary.http-address</name>      <value>hadoop104:50090</value></property>（3）YARN配置文件配置yarn-env.sh[atguigu@hadoop102 hadoop]$ vi yarn-env.shexport JAVA_HOME=/opt/module/jdk1.8.0_144配置yarn-site.xml[atguigu@hadoop102 hadoop]$ vi yarn-site.xml在该文件中增加如下配置<!-- Reducer获取数据的方式 --><property>        <name>yarn.nodemanager.aux-services</name>        <value>mapreduce_shuffle</value></property><!-- 指定YARN的ResourceManager的地址 --><property>        <name>yarn.resourcemanager.hostname</name>        <value>hadoop103</value></property>（4）MapReduce配置文件配置mapred-env.sh[atguigu@hadoop102 hadoop]$ vi mapred-env.shexport JAVA_HOME=/opt/module/jdk1.8.0_144配置mapred-site.xml[atguigu@hadoop102 hadoop]$ cp mapred-site.xml.template mapred-site.xml<p>[atguigu@hadoop102 hadoop]$ vi mapred-site.xml<br>在该文件中增加如下配置</p><!-- 指定MR运行在Yarn上 --><property>        <name>mapreduce.framework.name</name>        <value>yarn</value></property>3．在集群上分发配置好的Hadoop配置文件[atguigu@hadoop102 hadoop]$ xsync /opt/module/hadoop-2.7.2/4．查看文件分发情况[atguigu@hadoop103 hadoop]$ cat /opt/module/hadoop-2.7.2/etc/hadoop/core-site.xml4.3.4 集群单点启动（1）如果集群是第一次启动，需要格式化NameNode[atguigu@hadoop102 hadoop-2.7.2]$ hadoop namenode -format（2）在hadoop102上启动NameNode[atguigu@hadoop102 hadoop-2.7.2]$ hadoop-daemon.sh start namenode[atguigu@hadoop102 hadoop-2.7.2]$ jps3461 NameNode（3）在hadoop102、hadoop103以及hadoop104上分别启动DataNode[atguigu@hadoop102 hadoop-2.7.2]$ hadoop-daemon.sh start datanode[atguigu@hadoop102 hadoop-2.7.2]$ jps3461 NameNode3608 Jps3561 DataNode[atguigu@hadoop103 hadoop-2.7.2]$ hadoop-daemon.sh start datanode[atguigu@hadoop103 hadoop-2.7.2]$ jps3190 DataNode3279 Jps[atguigu@hadoop104 hadoop-2.7.2]$ hadoop-daemon.sh start datanode[atguigu@hadoop104 hadoop-2.7.2]$ jps3237 Jps3163 DataNode（4）思考：每次都一个一个节点启动，如果节点数增加到1000个怎么办？    早上来了开始一个一个节点启动，到晚上下班刚好完成，下班？ 4.3.5 SSH无密登录配置1.    配置ssh（1）基本语法ssh另一台电脑的ip地址（2）ssh连接时出现Host key verification failed的解决方法[atguigu@hadoop102 opt] $ ssh 192.168.1.103The authenticity of host '192.168.1.103 (192.168.1.103)' can't be established.RSA key fingerprint is cf:1e:de:d7:d0:4c:2d:98:60:b4:fd:ae:b1:2d:ad:06.Are you sure you want to continue connecting (yes/no)? Host key verification failed.（3）解决方案如下：直接输入yes2.    无密钥配置（1）免密登录原理，如图2-40所示 图2-40  免密登陆原理（2）生成公钥和私钥：[atguigu@hadoop102 .ssh]$ ssh-keygen -t rsa然后敲（三个回车），就会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥）（3）将公钥拷贝到要免密登录的目标机器上[atguigu@hadoop102 .ssh]$ ssh-copy-id hadoop102[atguigu@hadoop102 .ssh]$ ssh-copy-id hadoop103[atguigu@hadoop102 .ssh]$ ssh-copy-id hadoop104注意：还需要在hadoop102上采用root账号，配置一下无密登录到hadoop102、hadoop103、hadoop104；还需要在hadoop103上采用atguigu账号配置一下无密登录到hadoop102、hadoop103、hadoop104服务器上。3.    .ssh文件夹下（~/.ssh）的文件功能解释表2-4known_hosts    记录ssh访问过计算机的公钥(public key)id_rsa    生成的私钥id_rsa.pub    生成的公钥authorized_keys    存放授权过得无密登录服务器公钥4.3.6 群起集群1.    配置slaves/opt/module/hadoop-2.7.2/etc/hadoop/slaves[atguigu@hadoop102 hadoop]$ vi slaves在该文件中增加如下内容：hadoop102hadoop103hadoop104注意：该文件中添加的内容结尾不允许有空格，文件中不允许有空行。同步所有节点配置文件[atguigu@hadoop102 hadoop]$ xsync slaves2.    启动集群    （1）如果集群是第一次启动，需要格式化NameNode（注意格式化之前，一定要先停止上次启动的所有namenode和datanode进程，然后再删除data和log数据）[atguigu@hadoop102 hadoop-2.7.2]$ bin/hdfs namenode -format（2）启动HDFS[atguigu@hadoop102 hadoop-2.7.2]$ sbin/start-dfs.sh[atguigu@hadoop102 hadoop-2.7.2]$ jps4166 NameNode4482 Jps4263 DataNode[atguigu@hadoop103 hadoop-2.7.2]$ jps3218 DataNode3288 Jps<p>[atguigu@hadoop104 hadoop-2.7.2]$ jps<br>3221 DataNode<br>3283 SecondaryNameNode<br>3364 Jps<br>（3）启动YARN<br>[atguigu@hadoop103 hadoop-2.7.2]$ sbin/start-yarn.sh<br>注意：NameNode和ResourceManger如果不是同一台机器，不能在NameNode上启动 YARN，应该在ResouceManager所在的机器上启动YARN。<br>（4）Web端查看SecondaryNameNode<br>（a）浏览器中输入：<a href="http://hadoop104:50090/status.html" target="_blank" rel="noopener">http://hadoop104:50090/status.html</a><br>        （b）查看SecondaryNameNode信息，如图2-41所示。</p><p>图2-41 SecondaryNameNode的Web端<br>3.    集群基本测试<br>（1）上传文件到集群<br>      上传小文件<br>[atguigu@hadoop102 hadoop-2.7.2]$ hdfs dfs -mkdir -p /user/atguigu/input<br>[atguigu@hadoop102 hadoop-2.7.2]$ hdfs dfs -put wcinput/wc.input /user/atguigu/input<br>      上传大文件<br>[atguigu@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -put<br> /opt/software/hadoop-2.7.2.tar.gz  /user/atguigu/input<br>（2）上传文件后查看文件存放在什么位置<br>（a）查看HDFS文件存储路径<br>[atguigu@hadoop102 subdir0]$ pwd<br>/opt/module/hadoop-2.7.2/data/tmp/dfs/data/current/BP-938951106-192.168.10.107-1495462844069/current/finalized/subdir0/subdir0<br>（b）查看HDFS在磁盘存储文件内容<br>[atguigu@hadoop102 subdir0]$ cat blk_1073741825<br>hadoop yarn<br>hadoop mapreduce<br>atguigu<br>atguigu<br>（3）拼接<br>-rw-rw-r–. 1 atguigu atguigu 134217728 5月  23 16:01 blk_1073741836<br>-rw-rw-r–. 1 atguigu atguigu   1048583 5月  23 16:01 blk_1073741836_1012.meta<br>-rw-rw-r–. 1 atguigu atguigu  63439959 5月  23 16:01 blk_1073741837<br>-rw-rw-r–. 1 atguigu atguigu    495635 5月  23 16:01 blk_1073741837_1013.meta<br>[atguigu@hadoop102 subdir0]$ cat blk_1073741836&gt;&gt;tmp.file<br>[atguigu@hadoop102 subdir0]$ cat blk_1073741837&gt;&gt;tmp.file<br>[atguigu@hadoop102 subdir0]$ tar -zxvf tmp.file<br>（4）下载<br>[atguigu@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -get<br> /user/atguigu/input/hadoop-2.7.2.tar.gz ./<br>4.3.7 集群启动/停止方式总结</p><ol><li>各个服务组件逐一启动/停止<br>（1）分别启动/停止HDFS组件<br>  hadoop-daemon.sh  start / stop  namenode / datanode / secondarynamenode<br>（2）启动/停止YARN<br>  yarn-daemon.sh  start / stop  resourcemanager / nodemanager</li><li>各个模块分开启动/停止（配置ssh是前提）常用<br>（1）整体启动/停止HDFS<br>  start-dfs.sh   /  stop-dfs.sh<br>（2）整体启动/停止YARN<br>  start-yarn.sh  /  stop-yarn.sh</li><li>3.8 集群时间同步<br>时间同步的方式：找一个机器，作为时间服务器，所有的机器与这台集群时间进行定时的同步，比如，每隔十分钟，同步一次时间。</li></ol><p>配置时间同步具体实操：</p><ol><li>时间服务器配置（必须root用户）<br>（1）检查ntp是否安装<br>[root@hadoop102 桌面]# rpm -qa|grep ntp<br>ntp-4.2.6p5-10.el6.centos.x86_64<br>fontpackages-filesystem-1.41-1.1.el6.noarch<br>ntpdate-4.2.6p5-10.el6.centos.x86_64<br>（2）修改ntp配置文件<br>[root@hadoop102 桌面]# vi /etc/ntp.conf<br>修改内容如下<br>a）修改1（授权192.168.1.0-192.168.1.255网段上的所有机器可以从这台机器上查询和同步时间）<br>#restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap为<br>restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap<br>  b）修改2（集群在局域网中，不使用其他互联网上的时间）<br>server 0.centos.pool.ntp.org iburst<br>server 1.centos.pool.ntp.org iburst<br>server 2.centos.pool.ntp.org iburst<br>server 3.centos.pool.ntp.org iburst为<br>#server 0.centos.pool.ntp.org iburst<br>#server 1.centos.pool.ntp.org iburst<br>#server 2.centos.pool.ntp.org iburst<br>#server 3.centos.pool.ntp.org iburst<br>c）添加3（当该节点丢失网络连接，依然可以采用本地时间作为时间服务器为集群中的其他节点提供时间同步）<br>server 127.127.1.0<br>fudge 127.127.1.0 stratum 10<br>（3）修改/etc/sysconfig/ntpd 文件<br>[root@hadoop102 桌面]# vim /etc/sysconfig/ntpd<br>增加内容如下（让硬件时间与系统时间一起同步）<br>SYNC_HWCLOCK=yes<br>（4）重新启动ntpd服务<br>[root@hadoop102 桌面]# service ntpd status<br>ntpd 已停<br>[root@hadoop102 桌面]# service ntpd start<br>正在启动 ntpd：                                            [确定]<br>（5）设置ntpd服务开机启动<br>[root@hadoop102 桌面]# chkconfig ntpd on</li><li>其他机器配置（必须root用户）<br>（1）在其他机器配置10分钟与时间服务器同步一次<br>[root@hadoop103桌面]# crontab -e<br>编写定时任务如下：</li></ol><p>*/10 * * * * /usr/sbin/ntpdate hadoop102<br>（2）修改任意机器时间<br>[root@hadoop103桌面]# date -s “2017-9-11 11:11:11”<br>（3）十分钟后查看机器是否与时间服务器同步<br>[root@hadoop103桌面]# date<br>说明：测试的时候可以将10分钟调整为1分钟，节省时间。<br>第5章 Hadoop编译源码（面试重点）<br>5.1 前期准备工作</p><ol><li>CentOS联网<br>配置CentOS能连接外网。Linux虚拟机ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 是畅通的<br>注意：采用root角色编译，减少文件夹权限出现问题</li><li>jar包准备(hadoop源码、JDK8、maven、ant 、protobuf)<br>（1）hadoop-2.7.2-src.tar.gz<br>（2）jdk-8u144-linux-x64.tar.gz<br>（3）apache-ant-1.9.9-bin.tar.gz（build工具，打包用的）<br>（4）apache-maven-3.0.5-bin.tar.gz<br>（5）protobuf-2.5.0.tar.gz（序列化的框架）</li><li>2 jar包安装<br>注意：所有操作必须在root用户下完成</li><li>JDK解压、配置环境变量 JAVA_HOME和PATH，验证java-version(如下都需要验证是否配置成功)<br>[root@hadoop101 software] # tar -zxf jdk-8u144-linux-x64.tar.gz -C /opt/module/</li></ol><p>[root@hadoop101 software]# vi /etc/profile<br>#JAVA_HOME：<br>export JAVA_HOME=/opt/module/jdk1.8.0_144<br>export PATH=$PATH:$JAVA_HOME/bin</p><p>[root@hadoop101 software]#source /etc/profile<br>验证命令：java -version</p><ol start="2"><li>Maven解压、配置  MAVEN_HOME和PATH<br>[root@hadoop101 software]# tar -zxvf apache-maven-3.0.5-bin.tar.gz -C /opt/module/</li></ol><p>[root@hadoop101 apache-maven-3.0.5]# vi conf/settings.xml</p><mirrors>    <!-- mirror     | Specifies a repository mirror site to use instead of a given repository. The repository that     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.     |<mirror>       <id>mirrorId</id>       <mirrorOf>repositoryId</mirrorOf>       <name>Human Readable Name for this Mirror.</name>       <url>http://my.repository.com/repo/path</url>      </mirror>     -->        <mirror>                <id>nexus-aliyun</id>                <mirrorOf>central</mirrorOf>                <name>Nexus aliyun</name>                <url>http://maven.aliyun.com/nexus/content/groups/public</url>        </mirror></mirrors><p>[root@hadoop101 apache-maven-3.0.5]# vi /etc/profile<br>#MAVEN_HOME<br>export MAVEN_HOME=/opt/module/apache-maven-3.0.5<br>export PATH=$PATH:$MAVEN_HOME/bin</p><p>[root@hadoop101 software]#source /etc/profile<br>验证命令：mvn -version<br>3.    ant解压、配置  ANT _HOME和PATH<br>[root@hadoop101 software]# tar -zxvf apache-ant-1.9.9-bin.tar.gz -C /opt/module/</p><p>[root@hadoop101 apache-ant-1.9.9]# vi /etc/profile<br>#ANT_HOME<br>export ANT_HOME=/opt/module/apache-ant-1.9.9<br>export PATH=$PATH:$ANT_HOME/bin</p><p>[root@hadoop101 software]#source /etc/profile<br>验证命令：ant -version<br>4.    安装  glibc-headers 和  g++  命令如下<br>[root@hadoop101 apache-ant-1.9.9]# yum install glibc-headers<br>[root@hadoop101 apache-ant-1.9.9]# yum install gcc-c++<br>5.    安装make和cmake<br>[root@hadoop101 apache-ant-1.9.9]# yum install make<br>[root@hadoop101 apache-ant-1.9.9]# yum install cmake<br>6.    解压protobuf ，进入到解压后protobuf主目录，/opt/module/protobuf-2.5.0，然后相继执行命令<br>[root@hadoop101 software]# tar -zxvf protobuf-2.5.0.tar.gz -C /opt/module/<br>[root@hadoop101 opt]# cd /opt/module/protobuf-2.5.0/</p><p>[root@hadoop101 protobuf-2.5.0]#./configure<br>[root@hadoop101 protobuf-2.5.0]# make<br>[root@hadoop101 protobuf-2.5.0]# make check<br>[root@hadoop101 protobuf-2.5.0]# make install<br>[root@hadoop101 protobuf-2.5.0]# ldconfig </p><p>[root@hadoop101 hadoop-dist]# vi /etc/profile<br>#LD_LIBRARY_PATH<br>export LD_LIBRARY_PATH=/opt/module/protobuf-2.5.0<br>export PATH=$PATH:$LD_LIBRARY_PATH</p><p>[root@hadoop101 software]#source /etc/profile<br>验证命令：protoc –version<br>7.    安装openssl库<br>[root@hadoop101 software]#yum install openssl-devel<br>8.    安装 ncurses-devel库<br>[root@hadoop101 software]#yum install ncurses-devel<br>到此，编译工具安装基本完成。<br>5.3 编译源码</p><ol><li>解压源码到/opt/目录<br>[root@hadoop101 software]# tar -zxvf hadoop-2.7.2-src.tar.gz -C /opt/</li><li>进入到hadoop源码主目录<br>[root@hadoop101 hadoop-2.7.2-src]# pwd<br>/opt/hadoop-2.7.2-src</li><li>通过maven执行编译命令<br>[root@hadoop101 hadoop-2.7.2-src]#mvn package -Pdist,native -DskipTests -Dtar<br>等待时间30分钟左右，最终成功是全部SUCCESS，如图2-42所示。</li></ol><p>图2-42 编译源码<br>4.    成功的64位hadoop包在/opt/hadoop-2.7.2-src/hadoop-dist/target下<br>[root@hadoop101 target]# pwd<br>/opt/hadoop-2.7.2-src/hadoop-dist/target<br>5. 编译源码过程中常见的问题及解决方案<br>（1）MAVEN install时候JVM内存溢出<br>处理方式：在环境配置文件和maven的执行文件均可调整MAVEN_OPT的heap大小。（详情查阅MAVEN 编译 JVM调优问题，如：<a href="http://outofmemory.cn/code-snippet/12652/maven-outofmemoryerror-method）" target="_blank" rel="noopener">http://outofmemory.cn/code-snippet/12652/maven-outofmemoryerror-method）</a><br>（2）编译期间maven报错。可能网络阻塞问题导致依赖库下载不完整导致，多次执行命令（一次通过比较难）：<br>[root@hadoop101 hadoop-2.7.2-src]#mvn package -Pdist,nativeN -DskipTests -Dtar<br>（3）报ant、protobuf等错误，插件下载未完整或者插件版本问题，最开始链接有较多特殊情况，同时推荐<br>2.7.0版本的问题汇总帖子 <a href="http://www.tuicool.com/articles/IBn63qf" target="_blank" rel="noopener">http://www.tuicool.com/articles/IBn63qf</a><br>第6章 常见错误及解决方案<br>1）防火墙没关闭、或者没有启动YARN<br>INFO client.RMProxy: Connecting to ResourceManager at hadoop108/192.168.10.108:8032<br>2）主机名称配置错误<br>3）IP地址配置错误<br>4）ssh没有配置好<br>5）root用户和atguigu两个用户启动集群不统一<br>6）配置文件修改不细心<br>7）未编译源码<br>Unable to load native-hadoop library for your platform… using builtin-java classes where applicable<br>17/05/22 15:38:58 INFO client.RMProxy: Connecting to ResourceManager at hadoop108/192.168.10.108:8032<br>8）不识别主机名称<br>java.net.UnknownHostException: hadoop102: hadoop102<br>        at java.net.InetAddress.getLocalHost(InetAddress.java:1475)<br>        at org.apache.hadoop.mapreduce.JobSubmitter.submitJobInternal(JobSubmitter.java:146)<br>        at org.apache.hadoop.mapreduce.Job$10.run(Job.java:1290)<br>        at org.apache.hadoop.mapreduce.Job$10.run(Job.java:1287)<br>        at java.security.AccessController.doPrivileged(Native Method)<br>at javax.security.auth.Subject.doAs(Subject.java:415)<br>解决办法：<br>（1）在/etc/hosts文件中添加192.168.1.102 hadoop102<br>    （2）主机名称不要起hadoop  hadoop000等特殊名称<br>9）DataNode和NameNode进程同时只能工作一个。</p><p>10）执行命令不生效，粘贴word中命令时，遇到-和长–没区分开。导致命令失效<br>解决办法：尽量不要粘贴word中代码。<br>11）jps发现进程已经没有，但是重新启动集群，提示进程已经开启。原因是在linux的根目录下/tmp目录中存在启动的进程临时文件，将集群相关进程删除掉，再重新启动集群。<br>12）jps不生效。<br>原因：全局变量hadoop java没有生效。解决办法：需要source /etc/profile文件。<br>13）8088端口连接不上<br>[atguigu@hadoop102 桌面]$ cat /etc/hosts<br>注释掉如下代码<br>#127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4<br>#::1         hadoop102</p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些大数据的面经</title>
      <link href="/2021/01/13/%E4%B8%80%E4%BA%9B%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%9D%A2%E7%BB%8F/"/>
      <url>/2021/01/13/%E4%B8%80%E4%BA%9B%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Spark相关"><a href="#Spark相关" class="headerlink" title="Spark相关"></a>Spark相关</h2><h3 id="1-阶段划分"><a href="#1-阶段划分" class="headerlink" title="1. 阶段划分"></a>1. 阶段划分</h3><p>Spark通过分析各个RDD的依赖关系生成了DAG，再通过分析各个RDD中的分区之间的依赖关系来决定如何划分阶段，具体划分方法是：在DAG中进行反向解析，遇到宽依赖就断开，遇到窄依赖就把当前的RDD加入到当前的阶段中；将窄依赖尽量划分在同一个阶段中，可以实现流水线计算（具体的阶段划分算法请参见AMP实验室发表的论文《Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing》）。例如，下图所示，假设从HDFS中读入数据生成3个不同的RDD（即A、C和E），通过一系列转换操作后再将计算结果保存回HDFS。对DAG进行解析时，在依赖图中进行反向解析，由于从RDD A到RDD B的转换以及从RDD B和F到RDD G的转换，都属于宽依赖，因此，在宽依赖处断开后可以得到三个阶段，即阶段1、阶段2和阶段3。可以看出，在阶段2中，从map到union都是窄依赖，这两步操作可以形成一个流水线操作，比如，分区7通过map操作生成的分区9，可以不用等待分区8到分区9这个转换操作的计算结束，而是继续进行union操作，转换得到分区13，这样流水线执行大大提高了计算的效率。</p><p>对于窄依赖，partition的转换处理在Stage中完成计算。对于宽依赖，由于有Shuffle的存在，只能在parent RDD处理完成后，才能开始接下来的计算，因此宽依赖是划分Stage的依据。 <a href="https://github.com/tzhou2018/CSNoteSolarzhou/blob/master/_v_images/20200118103348674_11071.png" target="_blank" rel="noopener"><img src="https://github.com/tzhou2018/CSNoteSolarzhou/raw/master/_v_images/20200118103348674_11071.png" alt="img"></a></p><p>由上述论述可知，把一个DAG图划分成多个“阶段”以后，每个阶段都代表了一组关联的、相互之间没有Shuffle依赖关系的任务组成的任务集合。每个任务集合会被提交给任务调度器（TaskScheduler）进行处理，由任务调度器将任务分发给Executor运行。</p><p><a href="http://dblab.xmu.edu.cn/blog/985-2/" target="_blank" rel="noopener">参考文章-厦门大学大数据实验室</a></p><h3 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2. 缓存"></a>2. 缓存</h3><h4 id="cache-persist"><a href="#cache-persist" class="headerlink" title="cache persist"></a>cache persist</h4><p>RDD通过persist方法或cache方法可以将前面的计算结果缓存，默认情况下 persist() 会把数据以序列化的形式缓存在 JVM 的堆空间中。</p><p>但是并不是这两个方法被调用时立即缓存，而是触发后面的action时，该RDD将会被缓存在计算节点的内存中，并供后面重用。</p><p>通过查看源码发现cache最终也是调用了persist方法，默认的存储级别都是仅在内存存储一份，Spark的存储级别还有好多种，存储级别在object StorageLevel中定义的。</p><p><a href="https://github.com/tzhou2018/CSNoteSolarzhou/blob/master/_v_images/20200118105925211_22595.png" target="_blank" rel="noopener"><img src="https://github.com/tzhou2018/CSNoteSolarzhou/raw/master/_v_images/20200118105925211_22595.png" alt="img"></a></p><p>在存储级别的末尾加上“_2”来把持久化数据存为两份</p><p><a href="https://github.com/tzhou2018/CSNoteSolarzhou/blob/master/_v_images/20200118110003862_32697.png" target="_blank" rel="noopener"><img src="https://github.com/tzhou2018/CSNoteSolarzhou/raw/master/_v_images/20200118110003862_32697.png" alt="img"></a></p><h4 id="checkPoint"><a href="#checkPoint" class="headerlink" title="checkPoint"></a>checkPoint</h4><p>Spark中对于数据的保存除了持久化操作之外，还提供了一种检查点的机制，检查点（本质是通过将RDD写入Disk做检查点）是为了通过lineage做容错的辅助，lineage过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果之后有节点出现问题而丢失分区，从做检查点的RDD开始重做Lineage，就会减少开销。检查点通过将数据写入到HDFS文件系统实现了RDD的检查点功能。</p><p>为当前RDD设置检查点。该函数将会创建一个二进制的文件，并存储到checkpoint目录中，该目录是用SparkContext.setCheckpointDir()设置的。在checkpoint的过程中，该RDD的所有依赖于父RDD中的信息将全部被移除。对RDD进行checkpoint操作并不会马上被执行，必须执行Action操作才能触发。</p><h3 id="3-RDD-运行过程"><a href="#3-RDD-运行过程" class="headerlink" title="3. RDD 运行过程"></a>3. RDD 运行过程</h3><p><code>RDD</code> 在<code>Spark</code>架构中的运行过程：</p><p>创建<code>RDD</code>对象； <code>SparkContext</code>负责计算<code>RDD</code>之间的依赖关系，构建<code>DAG</code>; <code>DGAScheduler</code>负责把<code>DAG</code>分解成多个阶段，每个阶段中包含了多个任务，每个任务都会被任务调度器分发给各个工作节点（<code>Worker Node</code>）上的<code>Executor</code>去执行。</p><p><a href="https://github.com/tzhou2018/CSNoteSolarzhou/blob/master/_v_images/20200118104938522_9021.png" target="_blank" rel="noopener"><img src="https://github.com/tzhou2018/CSNoteSolarzhou/raw/master/_v_images/20200118104938522_9021.png" alt="img"></a></p><h3 id="4-任务划分"><a href="#4-任务划分" class="headerlink" title="4. 任务划分"></a>4. 任务划分</h3><p>RDD任务切分中间分为：Application、Job、Stage和Task</p><p>1）Application：初始化一个SparkContext即生成一个Application 2）Job：一个Action算子就会生成一个Job 3）Stage：根据RDD之间的依赖关系的不同将Job划分成不同的Stage，遇到一个宽依赖则划分一个Stage。 4）Task：Stage是一个TaskSet，将Stage划分的结果发送到不同的Executor执行即为一个Task。 <strong>注意：Application-&gt;Job-&gt;Stage-&gt; Task每一层都是1对n的关系。</strong> ![](<em>v</em>images/20200118105455064_11119.png =686x)</p><h3 id="5-数据倾斜"><a href="#5-数据倾斜" class="headerlink" title="5. 数据倾斜"></a>5. 数据倾斜</h3><p><a href="https://blog.csdn.net/u010039929/article/details/55044407" target="_blank" rel="noopener">解决方案</a> <a href="https://blog.csdn.net/weixin_35353187/article/details/84303518?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">解决方案2-CSDN***</a></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>数据倾斜的原理很简单：在进行shuffle的时候，必须将各个节点上相同的key拉取到某个节点上的一个task来进行处理，比如按照key进行聚合或join等操作。此时如果某个key对应的数据量特别大的话，就会发生数据倾斜。比如大部分key对应10条数据，但是个别key却对应了100万条数据，那么大部分task可能就只会分配到10条数据，然后1秒钟就运行完了；但是个别task可能分配到了100万数据，要运行一两个小时。因此，整个Spark作业的运行进度是由运行时间最长的那个task决定的。</p><p>　　因此出现数据倾斜的时候，Spark作业看起来会运行得非常缓慢，甚至可能因为某个task处理的数据量过大导致内存溢出。</p><p>　　下图就是一个很清晰的例子：hello这个key，在三个节点上对应了总共7条数据，这些数据都会被拉取到同一个task中进行处理；而world和you这两个key分别才对应1条数据，所以另外两个task只要分别处理1条数据即可。此时第一个task的运行时间可能是另外两个task的7倍，而整个stage的运行速度也由运行最慢的那个task所决定。</p><p><a href="https://github.com/tzhou2018/CSNoteSolarzhou/blob/master/_v_images/20200118192102480_30998.png" target="_blank" rel="noopener"><img src="https://github.com/tzhou2018/CSNoteSolarzhou/raw/master/_v_images/20200118192102480_30998.png" alt="img"></a></p><h4 id="预聚合处理"><a href="#预聚合处理" class="headerlink" title="预聚合处理"></a>预聚合处理</h4><p>如： <code>groupByKey</code>和<code>reduceByKey</code> <a href="https://github.com/tzhou2018/CSNoteSolarzhou/blob/master/_v_images/20200212115239343_11968.png" target="_blank" rel="noopener"><img src="https://github.com/tzhou2018/CSNoteSolarzhou/raw/master/_v_images/20200212115239343_11968.png" alt="img"></a></p><ol><li>reduceByKey：按照key进行聚合，在shuffle之前有combine（预聚合）操作，返回结果是RDD[k,v].</li><li>groupByKey：按照key进行分组，直接进行shuffle。</li><li>开发指导：reduceByKey比groupByKey，建议使用。但是需要注意是否会影响业务逻辑。</li></ol><h3 id="6-Spark-Pipeline"><a href="#6-Spark-Pipeline" class="headerlink" title="6. Spark Pipeline"></a>6. Spark Pipeline</h3><p><a href="https://cloud.tencent.com/developer/article/1365923" target="_blank" rel="noopener">Spark Pipeline初探–腾讯云社区</a></p><p>ML管道提供了一组构建在DataFrames之上的统一的高级api，帮助用户创建和优化实际的机器学习管道。</p><h3 id="7-Spark列式存储，Spark中Join连接"><a href="#7-Spark列式存储，Spark中Join连接" class="headerlink" title="7. Spark列式存储，Spark中Join连接"></a>7. Spark列式存储，Spark中Join连接</h3><p><a href="https://blog.csdn.net/yu616568/article/details/50993491" target="_blank" rel="noopener">列式存储-CSDN</a> 1)作用：在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素对在一起的(K,(V,W))的RDD 2)需求：创建两个pairRDD，并将key相同的数据聚合到一个元组。</p><h3 id="8-共享变量"><a href="#8-共享变量" class="headerlink" title="8. 共享变量"></a>8. 共享变量</h3><ul><li>累加器</li><li>广播变量</li></ul><h3 id="Spark运行模式（任务执行流程）"><a href="#Spark运行模式（任务执行流程）" class="headerlink" title="Spark运行模式（任务执行流程）"></a>Spark运行模式（任务执行流程）</h3><p>见<code>./大数据学习/Spark编程</code></p><h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p>HiveSQL底层是怎么实现的？比如两张表Join的时候会有哪些操作？需要shuffle这一步吗？</p><p><a href="http://lxw1234.com/archives/2015/06/313.htm" target="_blank" rel="noopener">hiveSql-Join操作</a></p><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><h3 id="hdfs小文件过多会怎么样"><a href="#hdfs小文件过多会怎么样" class="headerlink" title="hdfs小文件过多会怎么样"></a>hdfs小文件过多会怎么样</h3><p><a href="https://blog.csdn.net/SunnyYoona/article/details/53870077" target="_blank" rel="noopener">参考文章–CSDN</a> <a href="https://cloud.tencent.com/developer/article/1512285" target="_blank" rel="noopener">参考文章–腾讯云社区</a> 因为在hdfs 中，数据的元数据信息是保存在NameNode上的，hdfs本身的作用就是用来存储海量文件的，首先小文件过多的话，会增加NameNode 的压力，，因为NameNode是要接收集群中所有的DataNode的心跳信息，来确定元数据的信息变化的，另外，文件中可使用的block块的个数是有限制的，hadoop用来处理数据的话，小文件的延迟，和数据量虽然很小，但是有些地方和大文件所耗的时间相同，所以最好做优化，避免这种情况的发生。</p><p>小文件除了可能会撑爆NameNode。另一个是hive或者spark计算的时候会影响它的速度，因为spark计算时会将数据从硬盘读到内存，零碎的文件将产生较多的寻道过程。</p><h3 id="namenode-损坏，如何恢复"><a href="#namenode-损坏，如何恢复" class="headerlink" title="namenode 损坏，如何恢复"></a>namenode 损坏，如何恢复</h3><p>如果运行 namenode服务的机器毁坏，文件系统上所有文件将会丢失，因为不知道如何根据 datanode 的块重建文件。因此，对namenode实现容错很重要，hadoop实现了两种容错机制。</p><ol><li>备份那些组成文件系统元数据持久状态的文件；</li><li>运行一个辅助的namenode。但它不能被用作namenode。这个辅助 namenode 的重要作用是定期合并编辑日志与命名空间镜像，以防止编辑日志过大</li></ol><h3 id="HDFS上传流程以及操作命令"><a href="#HDFS上传流程以及操作命令" class="headerlink" title="HDFS上传流程以及操作命令"></a>HDFS上传流程以及操作命令</h3><p>客户端请求上传，dfs底层与服务端建立通信，服务端（NameNode）创建元数据信息，其中包括文件名，文件路径，数据块； 接着客户端创建一个输出流把文件切块，上传第一个数据块，通过水平复制，达到冗余度的要求，这里会通过循环，直至上传完所有的数据块。 ![](<em>v</em>images/20200826130726740_7501.png =1144x)</p><p><a href="https://juejin.im/post/6844903656794357773" target="_blank" rel="noopener">HDFS上传流程以及操作命令-掘金</a></p><hr><h1 id="一些面经"><a href="#一些面经" class="headerlink" title="一些面经"></a>一些面经</h1><h1 id="熟悉的"><a href="#熟悉的" class="headerlink" title="熟悉的"></a>熟悉的</h1><h2 id="与Spark相关"><a href="#与Spark相关" class="headerlink" title="与Spark相关"></a>与Spark相关</h2><ol><li>spark rdd介绍一下 RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据（计算）抽象。代码中是一个抽象类，它代表一个不可变、可分区、里面的元素可并行计算的集合。</li><li>spark的宽依赖和窄依赖</li><li>Spark任务执行流程</li><li>谈谈MapReduce和Spark处理数据的区别 <a href="https://blog.csdn.net/dashujuedu/article/details/53487199" target="_blank" rel="noopener">MapReduce和Spark处理数据的区别</a></li><li>Spark的Stage是怎么划分的，如何优化。宽窄依赖。</li><li>Spark生态体系.和优化</li><li>说对hadoop的理解，都有哪些组件，分别是干什么的</li><li>说下spark中的transform和action</li><li>为什么spark要把操作分为transform和action</li><li>spark中有了RDD，为什么还要有Dataframe和DataSet？ DataFrame也是懒执行的。性能上比RDD要高，主要原因：优化的执行计划,查询计划通过<code>Spark catalyst optimiser</code>进行<code>filter</code>过滤掉无用的数据量后在进行<code>join</code>操作。 比如：进行人口分析，可以先进行 <code>Dataset</code>有用户友好的API风格，既具有类型安全检查也具有Dataframe的查询优化特性。<code>Dataframe</code>是<code>Dataset</code>的特列，<code>DataFrame=Dataset[Row]</code>。</li><li>spark - 自由发挥 能说多少说多少</li><li>Spark执行任务流程 容错机制 结构 RDD算子 宽窄依赖（具体举例） shuffle细节</li><li>sparkSql Spark SQL是Spark用来处理结构化数据的一个模块，它提供了2个编程抽象：DataFrame和DataSet，并且作为分布式SQL查询引擎的作用。 我们已经学习了Hive，它是将Hive SQL转换成MapReduce然后提交到集群上执行，大大简化了编写MapReduc的程序的复杂性，由于MapReduce这种计算模型执行效率比较慢。所有Spark SQL的应运而生，它是将Spark SQL转换成RDD，然后提交到集群执行，执行效率非常快！</li></ol><h2 id="Hive-1"><a href="#Hive-1" class="headerlink" title="Hive"></a>Hive</h2><ol><li>Hive的作用</li></ol><h2 id="HDFS-1"><a href="#HDFS-1" class="headerlink" title="HDFS"></a>HDFS</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>Yarn</li><li>编程说思路：1G文件，每行是一个词，内存1M，求词频最大的前100个词</li><li><strong>HDFS的NameNode怎么知道它手下有多少DataNode的。容错机制。副本存放策略。</strong></li><li>Yarn的架构</li><li>Yarn的Resource Manager, Node Manager,AppMaster等怎么工作的，有任务来的时候的工作流程</li><li>Spark的2种运行模式，standalone和cluster模式的区别，内部工作流程。</li><li>了解函数式编程吗？说下c/c++和scala这种函数式编程语言的区别</li><li>Hadoop生态圈</li><li>对Hive Hbase的了解 (简历项目里面用了什么)</li><li>Hadoop vs Spark (自由发挥 说到你说不出来)</li><li></li></ol><h1 id="模糊的"><a href="#模糊的" class="headerlink" title="模糊的"></a>模糊的</h1><h2 id="与Spark相关-1"><a href="#与Spark相关-1" class="headerlink" title="与Spark相关"></a>与Spark相关</h2><ol><li><code>Spark</code>列式存储，<code>Spark</code>中<code>Join</code>连接 <a href="https://blog.csdn.net/yu616568/article/details/50993491" target="_blank" rel="noopener">列式存储-CSDN</a> <a href="https://www.zhihu.com/question/29380943" target="_blank" rel="noopener">列式存储一定快吗？–知乎</a> <a href="https://blog.csdn.net/dc_726/article/details/41143175" target="_blank" rel="noopener">用图文解释列式存储–CSDN</a> <a href="https://cloud.tencent.com/developer/article/1528525" target="_blank" rel="noopener">数据库中的 “行式存储”和“列式存储”—腾讯云社区</a> 1)作用：在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素对在一起的(K,(V,W))的RDD 2)需求：创建两个pairRDD，并将key相同的数据聚合到一个元组。</li><li>stage划分的依据是什么</li><li>数据倾斜</li><li>Spark哪些部分可以优化</li><li>解决Spark性能瓶颈问题<ul><li>基础调优 提交参数设置；并行度设置；设置缓存/检查点；使用广播变量；Kryo序列化（重要）</li><li>Rdd算子优化 RDD复用；尽早filter；读取大量小 文件用wholeTextFiles；mapPartition和foreachPartition；repartition调节并行度，也可以通过conf参数配置；本地预聚合，能用reduceBykey，就不用了groupBykey；</li><li>shuflle优化 当数据量更多的时候，把map和reduce端的缓冲区大小调大，reduce端重试和等待时间间隔调大；bypass机制开启阈值</li><li>数据倾斜优化</li><li>JVM 调优</li></ul></li></ol><h2 id="与HDFS相关"><a href="#与HDFS相关" class="headerlink" title="与HDFS相关"></a>与HDFS相关</h2><ol><li>hdfs小文件过多会怎么样 <a href="https://blog.csdn.net/SunnyYoona/article/details/53870077" target="_blank" rel="noopener">参考文章–CSDN</a> <a href="https://cloud.tencent.com/developer/article/1512285" target="_blank" rel="noopener">参考文章–腾讯云社区</a> 因为在hdfs 中，数据的元数据信息是保存在NameNode上的，hdfs本身的作用就是用来存储海量文件的，首先小文件过多的话，会增加NameNode 的压力，，因为NameNode是要接收集群中所有的DataNode的心跳信息，来确定元数据的信息变化的，另外，文件中可使用的block块的个数是有限制的，hadoop用来处理数据的话，小文件的延迟和数据量虽然很小，但是有些地方和大文件所耗的时间相同，所以最好做优化，避免这种情况的发生。</li></ol><p>太多的小文件除了可能会撑爆NameNode，还会影响hive和spark计算速度。由于spark计算时会将数据从磁盘读取到内存，零碎的文件将产生较多的寻址过程。</p><ol><li>spark的job,stage,task</li><li>DAGscheduler干了什么活 <code>DGAScheduler</code>负责把<code>DAG</code>分解成多个阶段，每个阶段中包含了多个任务，每个任务都会被任务调度器分发给各个工作节点（<code>Worker Node</code>）上的<code>Executor</code>去执行。</li></ol><h2 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h2><ul><li>Hive Hbase你的了解</li><li></li></ul><h1 id="不了解的"><a href="#不了解的" class="headerlink" title="不了解的"></a>不了解的</h1><h2 id="与Spark相关-2"><a href="#与Spark相关-2" class="headerlink" title="与Spark相关"></a>与Spark相关</h2><ol><li>用spark求一下dau</li><li>spark统计日活，日志文件每行是日期和user_id <a href="https://blog.csdn.net/dkl12/article/details/80256688" target="_blank" rel="noopener">spark 统计每天新增用户数</a></li><li><strong>Spark的TaskScheduler是怎么分配task的，源码看过吗</strong></li></ol><h2 id="一些其他组件"><a href="#一些其他组件" class="headerlink" title="一些其他组件"></a>一些其他组件</h2><ol><li>kafka在什么地方需要用到zookeeper</li><li>了解HBase吗？</li><li><strong>给一个日志文件，有用户ID，时间戳，url，用mapreduce如何给出每天每个站点的访问任务</strong></li><li>Kafuka原理</li><li>Hadoop MR全部过程</li><li><strong>大表join优化方法</strong></li></ol><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="数据仓库与数据库"><a href="#数据仓库与数据库" class="headerlink" title="数据仓库与数据库"></a>数据仓库与数据库</h2><p><a href="https://www.zhihu.com/question/20623931" target="_blank" rel="noopener">数据库与数据仓库的本质区别是什么?—知乎</a></p><ol><li><p>100亿个数怎么求中位数 <a href="https://blog.csdn.net/niaolianjiulin/article/details/76129578" target="_blank" rel="noopener">参考文章-CSDN</a> 存储够用时用快排；否则用桶排序；</p></li><li><p>数组求top k</p></li><li><p>求每组top 3</p></li><li><p>多核CPU和多CPU区别 <a href="https://www.zhihu.com/question/20998226/answer/18659825" target="_blank" rel="noopener">多核 CPU 和多个 CPU 有何区别？ - 卧闻海棠花的回答 - 知乎</a> 多核CPU和多CPU的区别主要在于性能和成本</p><p>如果我们选择多个单核CPU，那么每一个CPU都需要有较为独立的电路支持，有自己的Cache，而他们之间通过板上的总线进行通信。假如在这样的架构上，我们要跑一个多线程的程序（常见典型情况），不考虑超线程，那么每一个线程就要跑在一个独立的CPU上，线程间的所有协作都要走总线，而共享的数据更是有可能要在好几个Cache里同时存在。这样的话，总线开销相比较而言是很大的，怎么办？那么多Cache，即使我们不心疼存储能力的浪费，一致性怎么保证？如果真正做出来，还要在主板上占多块地盘，给布局布线带来更大的挑战，怎么搞定？</p><p>如果我们选择多核单CPU，那么我们只需要一套芯片组，一套存储，多核之间通过芯片内部总线进行通信，共享使用内存。在这样的架构上，如果我们跑一个多线程的程序，那么线程间通信将比上一种情形更快。如果最终实现出来，对板上空间的占用较小，布局布线的压力也较小。</p></li><li><p>TCP的三次握手、四次挥手大致流程。Time_wait和close_wait是什么。拥塞控制和流量控制。</p></li><li><p><strong>操作系统的页式存储是怎样的。有什么优点和缺点。Linux的进程调度。</strong></p></li><li><p>进程和线程的区别。</p></li><li><p>怎么对10亿个数字进行排序</p></li><li><p>如何把多个Hadoop集群连接起来</p></li><li><p>数据库都有哪些引擎</p></li><li><p>数据库的锁了解哪些，说说</p></li><li><p>应用层协议有哪些</p></li><li><p>什么场景用TCP，什么场景用UDP</p></li><li><p>HTTP状态码都有哪些，具体说一下</p></li><li><p><strong>HTTP长连接和短连接</strong> <a href="https://www.cnblogs.com/0201zcr/p/4694945.html" target="_blank" rel="noopener">长连接与短连接</a> 在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：<code>Connection:keep-alive</code></p><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p></li><li><p>url和uri的区别 <a href="https://www.jianshu.com/p/ba15d066f777" target="_blank" rel="noopener">参考文章—简书</a> <code>URI</code>：<code>Uniform Resource Identifier</code>，统一资源标识符 <code>URL</code>：<code>Uniform Resource Location</code>统一资源定位符</p></li><li><p>线程和进程的区别</p></li><li><p><strong>hashmap的实现</strong></p></li><li><p><strong>hashmap的扩容</strong></p></li><li><p>一条直线可以把一个平面分成2个平面，两条直线最多分成4个，问n条直线最多分成几个面 <a href="https://www.nowcoder.com/questionTerminal/6568b3d008174b11bcae238d4872770a" target="_blank" rel="noopener">一个直线将一个平面分成 2 部分，两条直线分成 4 部分</a></p></li><li><p>TCP（连接 断开） UDP</p></li><li><p>进程的用户栈和内核栈</p></li><li><p><strong>操作系统 同步IO 异步IO</strong></p></li><li><p>FIFO的缺点</p></li><li><p>同步 异步 谈谈你的理解</p></li><li><p>进程通信 线程通信</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop的配置</title>
      <link href="/2021/01/12/hadoop%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/01/12/hadoop%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop单机版环境搭建"><a href="#Hadoop单机版环境搭建" class="headerlink" title="Hadoop单机版环境搭建"></a>Hadoop单机版环境搭建</h1><nav><a href="#一前置条件">一、前置条件</a><br><a href="#二配置-SSH-免密登录">二、配置 SSH 免密登录</a><br><a href="#三HadoopHDFS环境搭建">三、Hadoop(HDFS)环境搭建</a><br><a href="#四HadoopYARN环境搭建">四、Hadoop(YARN)环境搭建</a><br></nav><h2 id="一、前置条件"><a href="#一、前置条件" class="headerlink" title="一、前置条件"></a>一、前置条件</h2><p>Hadoop 的运行依赖 JDK，需要预先安装，安装步骤见：</p><ul><li><a href="https://github.com/heibaiying/BigData-Notes/blob/master/notes/installation/Linux下JDK安装.md" target="_blank" rel="noopener">Linux 下 JDK 的安装</a></li></ul><h2 id="二、配置免密登录"><a href="#二、配置免密登录" class="headerlink" title="二、配置免密登录"></a>二、配置免密登录</h2><p>Hadoop 组件之间需要基于 SSH 进行通讯。</p><h4 id="2-1-配置映射"><a href="#2-1-配置映射" class="headerlink" title="2.1 配置映射"></a>2.1 配置映射</h4><p>配置 ip 地址和主机名映射：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件末尾增加</span></span><br><span class="line">192.168.43.202  hadoop001</span><br></pre></td></tr></table></figure><h3 id="2-2-生成公私钥"><a href="#2-2-生成公私钥" class="headerlink" title="2.2  生成公私钥"></a>2.2  生成公私钥</h3><p>执行下面命令行生成公匙和私匙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><h3 id="3-3-授权"><a href="#3-3-授权" class="headerlink" title="3.3 授权"></a>3.3 授权</h3><p>进入 <code>~/.ssh</code> 目录下，查看生成的公匙和私匙，并将公匙写入到授权文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@@hadoop001 sbin]#  cd ~/.ssh</span><br><span class="line">[root@@hadoop001 .ssh]# ll</span><br><span class="line">-rw-------. 1 root root 1675 3 月  15 09:48 id_rsa</span><br><span class="line">-rw-r--r--. 1 root root  388 3 月  15 09:48 id_rsa.pub</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 写入公匙到授权文件</span></span><br><span class="line">[root@hadoop001 .ssh]# cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line">[root@hadoop001 .ssh]# chmod 600 authorized_keys</span><br></pre></td></tr></table></figure><h2 id="三、Hadoop-HDFS-环境搭建"><a href="#三、Hadoop-HDFS-环境搭建" class="headerlink" title="三、Hadoop(HDFS)环境搭建"></a>三、Hadoop(HDFS)环境搭建</h2><h3 id="3-1-下载并解压"><a href="#3-1-下载并解压" class="headerlink" title="3.1 下载并解压"></a>3.1 下载并解压</h3><p>下载 Hadoop 安装包，这里我下载的是 CDH 版本的，下载地址为：<a href="http://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zvxf hadoop-2.6.0-cdh5.15.2.tar.gz</span><br></pre></td></tr></table></figure><h3 id="3-2-配置环境变量"><a href="#3-2-配置环境变量" class="headerlink" title="3.2 配置环境变量"></a>3.2 配置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vi /etc/profile</span></span><br></pre></td></tr></table></figure><p>配置环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME&#x3D;&#x2F;usr&#x2F;app&#x2F;hadoop-2.6.0-cdh5.15.2</span><br><span class="line">export  PATH&#x3D;$&#123;HADOOP_HOME&#125;&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure><p>执行 <code>source</code> 命令，使得配置的环境变量立即生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure><h3 id="3-3-修改Hadoop配置"><a href="#3-3-修改Hadoop配置" class="headerlink" title="3.3 修改Hadoop配置"></a>3.3 修改Hadoop配置</h3><p>进入 <code>${HADOOP_HOME}/etc/hadoop/</code> 目录下，修改以下配置：</p><h4 id="1-hadoop-env-sh"><a href="#1-hadoop-env-sh" class="headerlink" title="1. hadoop-env.sh"></a>1. hadoop-env.sh</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> JDK安装路径</span></span><br><span class="line">export  JAVA_HOME=/usr/java/jdk1.8.0_201/</span><br></pre></td></tr></table></figure><h4 id="2-core-site-xml"><a href="#2-core-site-xml" class="headerlink" title="2. core-site.xml"></a>2. core-site.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 namenode 的 hdfs 协议文件系统的通信地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 hadoop 存储临时文件的目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-hdfs-site-xml"><a href="#3-hdfs-site-xml" class="headerlink" title="3. hdfs-site.xml"></a>3. hdfs-site.xml</h4><p>指定副本系数和临时文件存储位置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--由于我们这里搭建是单机版本，所以指定 dfs 的副本系数为 1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-slaves"><a href="#4-slaves" class="headerlink" title="4. slaves"></a>4. slaves</h4><p>配置所有从属节点的主机名或 IP 地址，由于是单机版本，所以指定本机即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop001</span><br></pre></td></tr></table></figure><h3 id="3-4-关闭防火墙"><a href="#3-4-关闭防火墙" class="headerlink" title="3.4 关闭防火墙"></a>3.4 关闭防火墙</h3><p>不关闭防火墙可能导致无法访问 Hadoop 的 Web UI 界面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙状态</span></span><br><span class="line">sudo firewall-cmd --state</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭防火墙:</span></span><br><span class="line">sudo systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><h3 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h3><p>第一次启动 Hadoop 时需要进行初始化，进入 <code>${HADOOP_HOME}/bin/</code> 目录下，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop001 bin]# ./hdfs namenode -format</span><br></pre></td></tr></table></figure><h3 id="3-6-启动HDFS"><a href="#3-6-启动HDFS" class="headerlink" title="3.6 启动HDFS"></a>3.6 启动HDFS</h3><p>进入 <code>${HADOOP_HOME}/sbin/</code> 目录下，启动 HDFS：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop001 sbin]# ./start-dfs.sh</span><br></pre></td></tr></table></figure><h3 id="3-7-验证是否启动成功"><a href="#3-7-验证是否启动成功" class="headerlink" title="3.7 验证是否启动成功"></a>3.7 验证是否启动成功</h3><p>方式一：执行 <code>jps</code> 查看 <code>NameNode</code> 和 <code>DataNode</code> 服务是否已经启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop001 hadoop-2.6.0-cdh5.15.2]# jps</span><br><span class="line">9137 DataNode</span><br><span class="line">9026 NameNode</span><br><span class="line">9390 SecondaryNameNode</span><br></pre></td></tr></table></figure><p>方式二：查看 Web UI 界面，端口为 <code>50070</code>：</p><div align="center"> <img width="700px" src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hadoop安装验证.png"> </div><h2 id="四、Hadoop-YARN-环境搭建"><a href="#四、Hadoop-YARN-环境搭建" class="headerlink" title="四、Hadoop(YARN)环境搭建"></a>四、Hadoop(YARN)环境搭建</h2><h3 id="4-1-修改配置"><a href="#4-1-修改配置" class="headerlink" title="4.1 修改配置"></a>4.1 修改配置</h3><p>进入 <code>${HADOOP_HOME}/etc/hadoop/</code> 目录下，修改以下配置：</p><h4 id="1-mapred-site-xml"><a href="#1-mapred-site-xml" class="headerlink" title="1. mapred-site.xml"></a>1. mapred-site.xml</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果没有mapred-site.xml，则拷贝一份样例文件后再修改</span></span><br><span class="line">cp mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-yarn-site-xml"><a href="#2-yarn-site-xml" class="headerlink" title="2. yarn-site.xml"></a>2. yarn-site.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置 NodeManager 上运行的附属服务。需要配置成 mapreduce_shuffle 后才可以在 Yarn 上运行 MapReduce 程序。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-启动服务"><a href="#4-2-启动服务" class="headerlink" title="4.2 启动服务"></a>4.2 启动服务</h3><p>进入 <code>${HADOOP_HOME}/sbin/</code> 目录下，启动 YARN：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start-yarn.sh</span><br></pre></td></tr></table></figure><h4 id="4-3-验证是否启动成功"><a href="#4-3-验证是否启动成功" class="headerlink" title="4.3 验证是否启动成功"></a>4.3 验证是否启动成功</h4><p>方式一：执行 <code>jps</code> 命令查看 <code>NodeManager</code> 和 <code>ResourceManager</code> 服务是否已经启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop001 hadoop-2.6.0-cdh5.15.2]# jps</span><br><span class="line">9137 DataNode</span><br><span class="line">9026 NameNode</span><br><span class="line">12294 NodeManager</span><br><span class="line">12185 ResourceManager</span><br><span class="line">9390 SecondaryNameNode</span><br></pre></td></tr></table></figure><p>方式二：查看 Web UI 界面，端口号为 <code>8088</code>：</p><div align="center"> <img width="700px" src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hadoop-yarn安装验证.png"> </div><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/weixin-desc.png"> </div>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS是什么</title>
      <link href="/2021/01/11/HDFS%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2021/01/11/HDFS%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Hadoop分布式文件系统——HDFS"><a href="#Hadoop分布式文件系统——HDFS" class="headerlink" title="Hadoop分布式文件系统——HDFS"></a>Hadoop分布式文件系统——HDFS</h1><nav><a href="#一介绍">一、介绍</a><br><a href="#二HDFS-设计原理">二、HDFS 设计原理</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#21-HDFS-架构">2.1 HDFS 架构</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#22-文件系统命名空间">2.2 文件系统命名空间</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#23-数据复制">2.3 数据复制</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#24-数据复制的实现原理">2.4 数据复制的实现原理</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#25--副本的选择">2.5  副本的选择</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#26-架构的稳定性">2.6 架构的稳定性</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#1-心跳机制和重新复制">1. 心跳机制和重新复制</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#2-数据的完整性">2. 数据的完整性</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#3元数据的磁盘故障">3.元数据的磁盘故障</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#4支持快照">4.支持快照</a><br><a href="#三HDFS-的特点">三、HDFS 的特点</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#31-高容错">3.1 高容错</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#32-高吞吐量">3.2 高吞吐量</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#33--大文件支持">3.3  大文件支持</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#33-简单一致性模型">3.3 简单一致性模型</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#34-跨平台移植性">3.4 跨平台移植性</a><br><a href="#附图解HDFS存储原理">附：图解HDFS存储原理</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#1-HDFS写数据原理">1. HDFS写数据原理</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#2-HDFS读数据原理">2. HDFS读数据原理</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#3-HDFS故障类型和其检测方法">3. HDFS故障类型和其检测方法</a><br></nav><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>HDFS</strong> （<strong>Hadoop Distributed File System</strong>）是 Hadoop 下的分布式文件系统，具有高容错、高吞吐量等特性，可以部署在低成本的硬件上。</p><h2 id="二、HDFS-设计原理"><a href="#二、HDFS-设计原理" class="headerlink" title="二、HDFS 设计原理"></a>二、HDFS 设计原理</h2><div align="center"> <img width="600px" src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hdfsarchitecture.png"> </div><h3 id="2-1-HDFS-架构"><a href="#2-1-HDFS-架构" class="headerlink" title="2.1 HDFS 架构"></a>2.1 HDFS 架构</h3><p>HDFS 遵循主/从架构，由单个 NameNode(NN) 和多个 DataNode(DN) 组成：</p><ul><li><strong>NameNode</strong> : 负责执行有关 <code>文件系统命名空间</code> 的操作，例如打开，关闭、重命名文件和目录等。它同时还负责集群元数据的存储，记录着文件中各个数据块的位置信息。</li><li><strong>DataNode</strong>：负责提供来自客户端的读写请求，执行块的创建，删除等操作。</li></ul><h3 id="2-2-文件系统命名空间"><a href="#2-2-文件系统命名空间" class="headerlink" title="2.2 文件系统命名空间"></a>2.2 文件系统命名空间</h3><p>HDFS 的 <code>文件系统命名空间</code> 的层次结构与大多数文件系统类似 (如 Linux)， 支持目录和文件的创建、移动、删除和重命名等操作，支持配置用户和访问权限，但不支持硬链接和软连接。<code>NameNode</code> 负责维护文件系统名称空间，记录对名称空间或其属性的任何更改。</p><h3 id="2-3-数据复制"><a href="#2-3-数据复制" class="headerlink" title="2.3 数据复制"></a>2.3 数据复制</h3><p>由于 Hadoop 被设计运行在廉价的机器上，这意味着硬件是不可靠的，为了保证容错性，HDFS 提供了数据复制机制。HDFS 将每一个文件存储为一系列<strong>块</strong>，每个块由多个副本来保证容错，块的大小和复制因子可以自行配置（默认情况下，块大小是 128M，默认复制因子是 3）。</p><div align="center"> <img width="600px" src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hdfsdatanodes.png"> </div><h3 id="2-4-数据复制的实现原理"><a href="#2-4-数据复制的实现原理" class="headerlink" title="2.4 数据复制的实现原理"></a>2.4 数据复制的实现原理</h3><p>大型的 HDFS 实例在通常分布在多个机架的多台服务器上，不同机架上的两台服务器之间通过交换机进行通讯。在大多数情况下，同一机架中的服务器间的网络带宽大于不同机架中的服务器之间的带宽。因此 HDFS 采用机架感知副本放置策略，对于常见情况，当复制因子为 3 时，HDFS 的放置策略是：</p><p>在写入程序位于 <code>datanode</code> 上时，就优先将写入文件的一个副本放置在该 <code>datanode</code> 上，否则放在随机 <code>datanode</code> 上。之后在另一个远程机架上的任意一个节点上放置另一个副本，并在该机架上的另一个节点上放置最后一个副本。此策略可以减少机架间的写入流量，从而提高写入性能。</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hdfs-机架.png"> </div><p>如果复制因子大于 3，则随机确定第 4 个和之后副本的放置位置，同时保持每个机架的副本数量低于上限，上限值通常为 <code>（复制系数 - 1）/机架数量 + 2</code>，需要注意的是不允许同一个 <code>dataNode</code> 上具有同一个块的多个副本。</p><h3 id="2-5-副本的选择"><a href="#2-5-副本的选择" class="headerlink" title="2.5  副本的选择"></a>2.5  副本的选择</h3><p>为了最大限度地减少带宽消耗和读取延迟，HDFS 在执行读取请求时，优先读取距离读取器最近的副本。如果在与读取器节点相同的机架上存在副本，则优先选择该副本。如果 HDFS 群集跨越多个数据中心，则优先选择本地数据中心上的副本。</p><h3 id="2-6-架构的稳定性"><a href="#2-6-架构的稳定性" class="headerlink" title="2.6 架构的稳定性"></a>2.6 架构的稳定性</h3><h4 id="1-心跳机制和重新复制"><a href="#1-心跳机制和重新复制" class="headerlink" title="1. 心跳机制和重新复制"></a>1. 心跳机制和重新复制</h4><p>每个 DataNode 定期向 NameNode 发送心跳消息，如果超过指定时间没有收到心跳消息，则将 DataNode 标记为死亡。NameNode 不会将任何新的 IO 请求转发给标记为死亡的 DataNode，也不会再使用这些 DataNode 上的数据。 由于数据不再可用，可能会导致某些块的复制因子小于其指定值，NameNode 会跟踪这些块，并在必要的时候进行重新复制。</p><h4 id="2-数据的完整性"><a href="#2-数据的完整性" class="headerlink" title="2. 数据的完整性"></a>2. 数据的完整性</h4><p>由于存储设备故障等原因，存储在 DataNode 上的数据块也会发生损坏。为了避免读取到已经损坏的数据而导致错误，HDFS 提供了数据完整性校验机制来保证数据的完整性，具体操作如下：</p><p>当客户端创建 HDFS 文件时，它会计算文件的每个块的 <code>校验和</code>，并将 <code>校验和</code> 存储在同一 HDFS 命名空间下的单独的隐藏文件中。当客户端检索文件内容时，它会验证从每个 DataNode 接收的数据是否与存储在关联校验和文件中的 <code>校验和</code> 匹配。如果匹配失败，则证明数据已经损坏，此时客户端会选择从其他 DataNode 获取该块的其他可用副本。</p><h4 id="3-元数据的磁盘故障"><a href="#3-元数据的磁盘故障" class="headerlink" title="3.元数据的磁盘故障"></a>3.元数据的磁盘故障</h4><p><code>FsImage</code> 和 <code>EditLog</code> 是 HDFS 的核心数据，这些数据的意外丢失可能会导致整个 HDFS 服务不可用。为了避免这个问题，可以配置 NameNode 使其支持 <code>FsImage</code> 和 <code>EditLog</code> 多副本同步，这样 <code>FsImage</code> 或 <code>EditLog</code> 的任何改变都会引起每个副本 <code>FsImage</code> 和 <code>EditLog</code> 的同步更新。</p><h4 id="4-支持快照"><a href="#4-支持快照" class="headerlink" title="4.支持快照"></a>4.支持快照</h4><p>快照支持在特定时刻存储数据副本，在数据意外损坏时，可以通过回滚操作恢复到健康的数据状态。</p><h2 id="三、HDFS-的特点"><a href="#三、HDFS-的特点" class="headerlink" title="三、HDFS 的特点"></a>三、HDFS 的特点</h2><h3 id="3-1-高容错"><a href="#3-1-高容错" class="headerlink" title="3.1 高容错"></a>3.1 高容错</h3><p>由于 HDFS 采用数据的多副本方案，所以部分硬件的损坏不会导致全部数据的丢失。</p><h3 id="3-2-高吞吐量"><a href="#3-2-高吞吐量" class="headerlink" title="3.2 高吞吐量"></a>3.2 高吞吐量</h3><p>HDFS 设计的重点是支持高吞吐量的数据访问，而不是低延迟的数据访问。</p><h3 id="3-3-大文件支持"><a href="#3-3-大文件支持" class="headerlink" title="3.3  大文件支持"></a>3.3  大文件支持</h3><p>HDFS 适合于大文件的存储，文档的大小应该是是 GB 到 TB 级别的。</p><h3 id="3-3-简单一致性模型"><a href="#3-3-简单一致性模型" class="headerlink" title="3.3 简单一致性模型"></a>3.3 简单一致性模型</h3><p>HDFS 更适合于一次写入多次读取 (write-once-read-many) 的访问模型。支持将内容追加到文件末尾，但不支持数据的随机访问，不能从文件任意位置新增数据。</p><h3 id="3-4-跨平台移植性"><a href="#3-4-跨平台移植性" class="headerlink" title="3.4 跨平台移植性"></a>3.4 跨平台移植性</h3><p>HDFS 具有良好的跨平台移植性，这使得其他大数据计算框架都将其作为数据持久化存储的首选方案。</p><h2 id="附：图解HDFS存储原理"><a href="#附：图解HDFS存储原理" class="headerlink" title="附：图解HDFS存储原理"></a>附：图解HDFS存储原理</h2><blockquote><p>说明：以下图片引用自博客：<a href="https://blog.csdn.net/hudiefenmu/article/details/37655491" target="_blank" rel="noopener">翻译经典 HDFS 原理讲解漫画</a></p></blockquote><h3 id="1-HDFS写数据原理"><a href="#1-HDFS写数据原理" class="headerlink" title="1. HDFS写数据原理"></a>1. HDFS写数据原理</h3><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hdfs-write-1.jpg"> </div><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hdfs-write-2.jpg"> </div><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hdfs-write-3.jpg"> </div><h3 id="2-HDFS读数据原理"><a href="#2-HDFS读数据原理" class="headerlink" title="2. HDFS读数据原理"></a>2. HDFS读数据原理</h3><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hdfs-read-1.jpg"> </div><h3 id="3-HDFS故障类型和其检测方法"><a href="#3-HDFS故障类型和其检测方法" class="headerlink" title="3. HDFS故障类型和其检测方法"></a>3. HDFS故障类型和其检测方法</h3><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hdfs-tolerance-1.jpg"> </div><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hdfs-tolerance-2.jpg"> </div><p><strong>第二部分：读写故障的处理</strong></p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hdfs-tolerance-3.jpg"> </div><p><strong>第三部分：DataNode 故障处理</strong></p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hdfs-tolerance-4.jpg"> </div><p><strong>副本布局策略</strong>：</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/hdfs-tolerance-5.jpg"> </div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" target="_blank" rel="noopener">Apache Hadoop 2.9.2 &gt; HDFS Architecture</a></li><li>Tom White . hadoop 权威指南 [M] . 清华大学出版社 . 2017.</li><li><a href="https://blog.csdn.net/hudiefenmu/article/details/37655491" target="_blank" rel="noopener">翻译经典 HDFS 原理讲解漫画</a></li></ol><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/weixin-desc.png"> </div>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink的windows</title>
      <link href="/2021/01/09/Flink%E7%9A%84windows/"/>
      <url>/2021/01/09/Flink%E7%9A%84windows/</url>
      
        <content type="html"><![CDATA[<h1 id="Flink-Windows"><a href="#Flink-Windows" class="headerlink" title="Flink Windows"></a>Flink Windows</h1><nav><a href="#一窗口概念">一、窗口概念</a><br><a href="#二Time-Windows">二、Time Windows</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#21-Tumbling-Windows">2.1 Tumbling Windows</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#22-Sliding-Windows">2.2 Sliding Windows</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#23-Session-Windows">2.3 Session Windows</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#24-Global-Windows">2.4 Global Windows</a><br><a href="#三Count-Windows">三、Count Windows</a><br></nav><h2 id="一、窗口概念"><a href="#一、窗口概念" class="headerlink" title="一、窗口概念"></a>一、窗口概念</h2><p>在大多数场景下，我们需要统计的数据流都是无界的，因此我们无法等待整个数据流终止后才进行统计。通常情况下，我们只需要对某个时间范围或者数量范围内的数据进行统计分析：如每隔五分钟统计一次过去一小时内所有商品的点击量；或者每发生1000次点击后，都去统计一下每个商品点击率的占比。在 Flink 中，我们使用窗口 (Window) 来实现这类功能。按照统计维度的不同，Flink 中的窗口可以分为 时间窗口 (Time Windows) 和 计数窗口 (Count Windows) 。</p><h2 id="二、Time-Windows"><a href="#二、Time-Windows" class="headerlink" title="二、Time Windows"></a>二、Time Windows</h2><p>Time Windows 用于以时间为维度来进行数据聚合，具体分为以下四类：</p><h3 id="2-1-Tumbling-Windows"><a href="#2-1-Tumbling-Windows" class="headerlink" title="2.1 Tumbling Windows"></a>2.1 Tumbling Windows</h3><p>滚动窗口 (Tumbling Windows) 是指彼此之间没有重叠的窗口。例如：每隔1小时统计过去1小时内的商品点击量，那么 1 天就只能分为 24 个窗口，每个窗口彼此之间是不存在重叠的，具体如下：</p><div align="center"> <img width="600px" src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-tumbling-windows.png"> </div><p>这里我们以词频统计为例，给出一个具体的用例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">// 接收socket上的数据输入</span></span><br><span class="line">DataStreamSource&lt;String&gt; streamSource = env.socketTextStream(<span class="string">"hadoop001"</span>, <span class="number">9999</span>, <span class="string">"\n"</span>, <span class="number">3</span>);</span><br><span class="line">streamSource.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Long&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] words = value.split(<span class="string">"\t"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(word, <span class="number">1L</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).keyBy(<span class="number">0</span>).timeWindow(Time.seconds(<span class="number">3</span>)).sum(<span class="number">1</span>).print(); <span class="comment">//每隔3秒统计一次每个单词出现的数量</span></span><br><span class="line">env.execute(<span class="string">"Flink Streaming"</span>);</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-window-word-count.png"> </div><h3 id="2-2-Sliding-Windows"><a href="#2-2-Sliding-Windows" class="headerlink" title="2.2 Sliding Windows"></a>2.2 Sliding Windows</h3><p>滑动窗口用于滚动进行聚合分析，例如：每隔 6 分钟统计一次过去一小时内所有商品的点击量，那么统计窗口彼此之间就是存在重叠的，即 1天可以分为 240 个窗口。图示如下：</p><div align="center"> <img width="600px" src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-sliding-windows.png"> </div><p>可以看到 window 1 - 4 这四个窗口彼此之间都存在着时间相等的重叠部分。想要实现滑动窗口，只需要在使用 timeWindow 方法时额外传递第二个参数作为滚动时间即可，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每隔3秒统计一次过去1分钟内的数据</span></span><br><span class="line">timeWindow(Time.minutes(<span class="number">1</span>),Time.seconds(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h3 id="2-3-Session-Windows"><a href="#2-3-Session-Windows" class="headerlink" title="2.3 Session Windows"></a>2.3 Session Windows</h3><p>当用户在进行持续浏览时，可能每时每刻都会有点击数据，例如在活动区间内，用户可能频繁的将某类商品加入和移除购物车，而你只想知道用户本次浏览最终的购物车情况，此时就可以在用户持有的会话结束后再进行统计。想要实现这类统计，可以通过 Session Windows 来进行实现。</p><div align="center"> <img width="600px" src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-session-windows.png"> </div><p>具体的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以处理时间为衡量标准，如果10秒内没有任何数据输入，就认为会话已经关闭，此时触发统计</span></span><br><span class="line">window(ProcessingTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br><span class="line"><span class="comment">// 以事件时间为衡量标准    </span></span><br><span class="line">window(EventTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure><h3 id="2-4-Global-Windows"><a href="#2-4-Global-Windows" class="headerlink" title="2.4 Global Windows"></a>2.4 Global Windows</h3><p>最后一个窗口是全局窗口， 全局窗口会将所有 key 相同的元素分配到同一个窗口中，其通常配合触发器 (trigger) 进行使用。如果没有相应触发器，则计算将不会被执行。</p><div align="center"> <img width="600px" src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-non-windowed.png"> </div><p>这里继续以上面词频统计的案例为例，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当单词累计出现的次数每达到10次时，则触发计算，计算整个窗口内该单词出现的总数</span></span><br><span class="line">window(GlobalWindows.create()).trigger(CountTrigger.of(<span class="number">10</span>)).sum(<span class="number">1</span>).print();</span><br></pre></td></tr></table></figure><h2 id="三、Count-Windows"><a href="#三、Count-Windows" class="headerlink" title="三、Count Windows"></a>三、Count Windows</h2><p>Count Windows 用于以数量为维度来进行数据聚合，同样也分为滚动窗口和滑动窗口，实现方式也和时间窗口完全一致，只是调用的 API 不同，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动计数窗口，每1000次点击则计算一次</span></span><br><span class="line">countWindow(<span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 滑动计数窗口，每10次点击发生后，则计算过去1000次点击的情况</span></span><br><span class="line">countWindow(<span class="number">1000</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>实际上计数窗口内部就是调用的我们上一部分介绍的全局窗口来实现的，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title">countWindow</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create()).trigger(PurgingTrigger.of(CountTrigger.of(size)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title">countWindow</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">long</span> slide)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create())</span><br><span class="line">        .evictor(CountEvictor.of(size))</span><br><span class="line">        .trigger(CountTrigger.of(slide));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Flink Windows： <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/stream/operators/windows.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/stream/operators/windows.html</a> </p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/weixin-desc.png"> </div>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDF、UDAF、UDTF相关概念</title>
      <link href="/2021/01/09/UDF%E3%80%81UDAF%E3%80%81UDTF%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/01/09/UDF%E3%80%81UDAF%E3%80%81UDTF%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Flink Table &amp; SQL中的用户自定义函数: UDF、UDAF、UDTF。</p><ol><li><p>UDF: 自定义标量函数(User Defined Scalar Function)。一行输入一行输出。</p></li><li><p>UDAF: 自定义聚合函数。多行输入一行输出。</p></li><li><p>UDTF: 自定义表函数。一行输入多行输出或一列输入多列输出。</p><p>需求分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">今日目标: </span><br><span class="line">    (1) 会用Flink Java API</span><br><span class="line">    (2) 会写Flink SQL 的UDF、UDAF、UDTF</span><br><span class="line"></span><br><span class="line">案例:</span><br><span class="line"></span><br><span class="line">1. 先把本地flink开发环境弄好(maven + flink 1.10.0)</span><br><span class="line">2. 基于开源flink 写一个Demo</span><br><span class="line">    (1) 用Flink Java API 向 Kafka 写事件。事件的业务含义: 某个用户在某个时刻点击或浏览了某个页面。</span><br><span class="line">        写到Kafka的数据格式是JSON字符串。</span><br><span class="line">        &#123;&quot;uid&quot;:&quot;用户ID, 取1-10的随机数&quot;, &quot;name&quot;: &quot;user_1-10的随机数&quot;, &quot;event_time&quot;: &quot;北京时间，时间格式为yyyy-MM-dd HH:mm:ss&quot;, &quot;event_name&quot;:&quot;click&#x2F;browse&quot;, &quot;page&quot;: 1-10的随机数 &#125;</span><br><span class="line">        如&#123;&quot;uid&quot;: &quot;1&quot;, &quot;name&quot;: &quot;user_2&quot;, &quot;event_time&quot;: &quot;2021-01-06 11:22:00&quot;, &quot;event_name&quot;: &quot;click&quot;, &quot;page&quot;: 5&#125;</span><br><span class="line"></span><br><span class="line">    (2) 用Flink SQL 消费Kafka数据</span><br><span class="line">        (a) 自定义UDF, 每条数据增加一个字段uuid, uuid &#x3D; uid+时间(event_time)+page</span><br><span class="line">        (b) 自定义UDTF, 将每条数据中的event_time, 拆分出日期dt和时间time两个字段</span><br><span class="line">        (c) 自定义UDAF, 求每个用户每天点击的总次数</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">发送数据: &#123;&quot;d&quot;:&quot;2021-01-08 18:09:37&quot;,&quot;event_name&quot;:&quot;click&#x2F;browse&quot;,&quot;name&quot;:&quot;user_10&quot;,&quot;page&quot;:10,&quot;uid&quot;:5&#125;</span><br><span class="line">发送数据: &#123;&quot;d&quot;:&quot;2021-01-08 18:09:37&quot;,&quot;event_name&quot;:&quot;click&#x2F;browse&quot;,&quot;name&quot;:&quot;user_10&quot;,&quot;page&quot;:10,&quot;uid&quot;:5&#125;</span><br><span class="line">发送数据: &#123;&quot;d&quot;:&quot;2021-01-08 18:09:37&quot;,&quot;event_name&quot;:&quot;click&#x2F;browse&quot;,&quot;name&quot;:&quot;user_10&quot;,&quot;page&quot;:10,&quot;uid&quot;:5&#125;</span><br><span class="line">发送数据: &#123;&quot;d&quot;:&quot;2021-01-08 18:09:37&quot;,&quot;event_name&quot;:&quot;click&#x2F;browse&quot;,&quot;name&quot;:&quot;user_10&quot;,&quot;page&quot;:10,&quot;uid&quot;:5&#125;</span><br><span class="line">发送数据: &#123;&quot;d&quot;:&quot;2021-01-08 18:09:37&quot;,&quot;event_name&quot;:&quot;click&#x2F;browse&quot;,&quot;name&quot;:&quot;user_10&quot;,&quot;page&quot;:10,&quot;uid&quot;:5&#125;</span><br><span class="line">发送数据: &#123;&quot;d&quot;:&quot;2021-01-08 18:09:37&quot;,&quot;event_name&quot;:&quot;click&#x2F;browse&quot;,&quot;name&quot;:&quot;user_10&quot;,&quot;page&quot;:10,&quot;uid&quot;:5&#125;</span><br><span class="line">发送数据: &#123;&quot;d&quot;:&quot;2021-01-08 18:09:37&quot;,&quot;event_name&quot;:&quot;click&#x2F;browse&quot;,&quot;name&quot;:&quot;user_10&quot;,&quot;page&quot;:10,&quot;uid&quot;:5&#125;</span><br><span class="line">发送数据: &#123;&quot;d&quot;:&quot;2021-01-08 18:09:37&quot;,&quot;event_name&quot;:&quot;click&#x2F;browse&quot;,&quot;name&quot;:&quot;user_10&quot;,&quot;page&quot;:10,&quot;uid&quot;:5&#125;</span><br></pre></td></tr></table></figure><p>Producer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.flink.java.course02;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import org.apache.flink.api.common.serialization.SimpleStringSchema;</span><br><span class="line">import org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line">import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line">import org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class Producer &#123;</span><br><span class="line">    private static final String broker_list &#x3D; &quot;localhost:9092&quot;;</span><br><span class="line">    private static final String topic &#x3D; &quot;test&quot;;  &#x2F;&#x2F;kafka topic 需要和 flink 程序用同一个 topic</span><br><span class="line"></span><br><span class="line">    public static void writeToKafka() throws InterruptedException &#123;</span><br><span class="line">        Properties props &#x3D; new Properties();</span><br><span class="line">        props.put(&quot;bootstrap.servers&quot;, broker_list);</span><br><span class="line">        props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">        props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">        KafkaProducer producer &#x3D; new KafkaProducer&lt;String, String&gt;(props);&#x2F;&#x2F;老版本producer已废弃</span><br><span class="line">       &#x2F;&#x2F; Producer&lt;String, String&gt; producer &#x3D; new org.apache.kafka.clients.producer.KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;Student student &#x3D; new Student(i, &quot;itzzy&quot; + i, &quot;password&quot; + i, 18 + i);</span><br><span class="line">        Data data &#x3D; new Data();</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        data.setUid(random.nextInt(10) + 1);</span><br><span class="line">        data.setName(&quot;user_&quot;+(random.nextInt(10) + 1));</span><br><span class="line">        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String time &#x3D; sdf.format(new Date());</span><br><span class="line">        data.setD(time);</span><br><span class="line">        data.setEvent_name(&quot;click&#x2F;browse&quot;);</span><br><span class="line">        data.setPage(random.nextInt(10) + 1);</span><br><span class="line">        String message &#x3D; JSON.toJSONString(data);</span><br><span class="line"></span><br><span class="line">        while (true)&#123;</span><br><span class="line">            ProducerRecord record &#x3D; new ProducerRecord&lt;String, String&gt;(topic, null, null, JSON.toJSONString(data));</span><br><span class="line">            producer.send(record);</span><br><span class="line">            producer.flush();</span><br><span class="line">            System.out.println(&quot;发送数据: &quot; + JSON.toJSONString(data));</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        writeToKafka();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">&#x2F;&#x2F;        writeToKafka();</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        Data data &#x3D; new Data();</span><br><span class="line">&#x2F;&#x2F;        Random random &#x3D; new Random();</span><br><span class="line">&#x2F;&#x2F;        data.setUid(random.nextInt(10) + 1);</span><br><span class="line">&#x2F;&#x2F;        data.setName(random.nextInt(10) + 1);</span><br><span class="line">&#x2F;&#x2F;        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">&#x2F;&#x2F;        String time &#x3D; sdf.format(new Date());</span><br><span class="line">&#x2F;&#x2F;        data.setDate(time);</span><br><span class="line">&#x2F;&#x2F;        data.setEvent_name(&quot;click&#x2F;browse&quot;);</span><br><span class="line">&#x2F;&#x2F;        data.setPage(random.nextInt(10) + 1);</span><br><span class="line">&#x2F;&#x2F;        String message &#x3D; JSON.toJSONString(data);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;            &#x2F;&#x2F; 创建Flink执行环境</span><br><span class="line">&#x2F;&#x2F;        StreamExecutionEnvironment env &#x3D; StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        DataStream&lt;String&gt; stream &#x3D; ;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        Properties properties &#x3D; new Properties();</span><br><span class="line">&#x2F;&#x2F;        properties.setProperty(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F; properties.setProperty(&quot;group.id&quot;,&quot;test-consumer-group&quot;);</span><br><span class="line">&#x2F;&#x2F;        FlinkKafkaProducer&lt;String&gt; myProducer &#x3D; new FlinkKafkaProducer&lt;&gt;(</span><br><span class="line">&#x2F;&#x2F;                &quot;test&quot;,                  &#x2F;&#x2F; target topic</span><br><span class="line">&#x2F;&#x2F;                new SimpleStringSchema(),    &#x2F;&#x2F; serialization schema</span><br><span class="line">&#x2F;&#x2F;                properties,                  &#x2F;&#x2F; producer config</span><br><span class="line">&#x2F;&#x2F;                FlinkKafkaProducer.Semantic.EXACTLY_ONCE); &#x2F;&#x2F; fault-tolerance</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        stream.addSink(myProducer);</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Data</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.flink.java.course02;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Data &#123;</span><br><span class="line">    private  int uid;</span><br><span class="line">    private String  name;</span><br><span class="line">&#x2F;&#x2F;    SimpleDateFormat sdf&#x3D;new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">&#x2F;&#x2F;    String time&#x3D; sdf.format( new Date());</span><br><span class="line">    private String d;</span><br><span class="line">    private String event_name;</span><br><span class="line">    private int page;</span><br><span class="line">    private String uuid;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Data&#123;&quot; +</span><br><span class="line">                &quot;uid&#x3D;&quot; + uid +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, d&#x3D;&#39;&quot; + d + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, event_name&#x3D;&#39;&quot; + event_name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, page&#x3D;&quot; + page +</span><br><span class="line">                &quot;, uuid&#x3D;&#39;&quot; + uuid + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUuid() &#123;</span><br><span class="line">        return uuid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUuid(String uuid) &#123;</span><br><span class="line">        this.uuid &#x3D; uuid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getUid() &#123;</span><br><span class="line">        return uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUid(int uid) &#123;</span><br><span class="line">        this.uid &#x3D; uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getD() &#123;</span><br><span class="line">        return d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setD(String d) &#123;</span><br><span class="line">        this.d &#x3D; d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getEvent_name() &#123;</span><br><span class="line">        return event_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEvent_name(String event_name) &#123;</span><br><span class="line">        this.event_name &#x3D; event_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPage() &#123;</span><br><span class="line">        return page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPage(int page) &#123;</span><br><span class="line">        this.page &#x3D; page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Data() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.flink.java.course02;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import org.apache.flink.api.common.serialization.SimpleStringSchema;</span><br><span class="line">import org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line">import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line">import org.apache.flink.streaming.api.functions.ProcessFunction;</span><br><span class="line">import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer010;</span><br><span class="line">import org.apache.flink.table.api.EnvironmentSettings;</span><br><span class="line">import org.apache.flink.table.api.Table;</span><br><span class="line">import org.apache.flink.table.api.java.StreamTableEnvironment;</span><br><span class="line">import org.apache.flink.table.functions.ScalarFunction;</span><br><span class="line">import org.apache.flink.types.Row;</span><br><span class="line">import org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class UDFConsumer1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        EnvironmentSettings settings &#x3D; EnvironmentSettings.newInstance().inStreamingMode().useBlinkPlanner().build();</span><br><span class="line">        StreamExecutionEnvironment streamEnv &#x3D; StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        StreamTableEnvironment tableEnv &#x3D; StreamTableEnvironment.getTableEnvironment(streamEnv);</span><br><span class="line">        StreamTableEnvironment tableEnv &#x3D; StreamTableEnvironment.create(streamEnv, settings);</span><br><span class="line"></span><br><span class="line">        streamEnv.setParallelism(1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3、注册Kafka数据源</span><br><span class="line">        Properties browseProperties &#x3D; new Properties();</span><br><span class="line">        browseProperties.put(&quot;bootstrap.servers&quot;,&quot;localhost:9092&quot;);</span><br><span class="line">        browseProperties.put(&quot;group.id&quot;,&quot;test-consumer-group&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        &#x2F;**</span><br><span class="line">&#x2F;&#x2F;         * 没有processFunction</span><br><span class="line">&#x2F;&#x2F;         *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;-------------------&quot;);</span><br><span class="line">&#x2F;&#x2F;        FlinkKafkaConsumer&lt;String&gt; myConsumer &#x3D; new FlinkKafkaConsumer&lt;&gt;(&quot;test&quot;, new SimpleStringSchema(), browseProperties);</span><br><span class="line">&#x2F;&#x2F;        DataStream&lt;Data&gt; stream &#x3D; streamEnv.addSource(myConsumer)</span><br><span class="line">&#x2F;&#x2F;                .process(new BrowseKafkaProcessFunction());</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        stream.print();</span><br><span class="line">&#x2F;&#x2F;        streamEnv.execute(&quot;hello&quot;);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;-------------------&quot;);</span><br><span class="line">        &#x2F;**</span><br><span class="line">         *</span><br><span class="line">         * 有processFunction</span><br><span class="line">         *&#x2F;</span><br><span class="line">        DataStream&lt;Data&gt; browseStream&#x3D;streamEnv</span><br><span class="line">                .addSource(new FlinkKafkaConsumer010&lt;&gt;(&quot;test&quot;, new SimpleStringSchema(), browseProperties))</span><br><span class="line">                .process(new BrowseKafkaProcessFunction());</span><br><span class="line">        &#x2F;&#x2F; 增加uuid</span><br><span class="line">        System.out.println(&quot;----------------------------&quot;);</span><br><span class="line">     &#x2F;&#x2F;   browseStream.print();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------------------------&quot;);</span><br><span class="line">        tableEnv.registerDataStream(&quot;source_kafka&quot;,browseStream,&quot;uid,name,d,event_name,page,uuid&quot;);</span><br><span class="line">        &#x2F;&#x2F;注册函数</span><br><span class="line">        tableEnv.registerFunction(&quot;f&quot;,new helper());</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Data&#123;uid&#x3D;5, name&#x3D;&#39;user_5&#39;, date&#x3D;&#39;2021-01-08 13:01:20&#39;,</span><br><span class="line">         * event_name&#x3D;&#39;click&#x2F;browse&#39;, page&#x3D;1, uuid&#x3D;&#39;null&#39;&#125;</span><br><span class="line">         *&#x2F;</span><br><span class="line">      &#x2F;&#x2F;  tableEnv.toAppendStream(tableEnv.scan(&quot;source_kafka&quot;), Row.class).print();</span><br><span class="line">&#x2F;&#x2F;        streamEnv.execute();</span><br><span class="line">&#x2F;&#x2F;    tableEnv.execEnv();</span><br><span class="line">        String sql&#x3D;&quot;select uid, name, d, event_name, page, f(uid,d,page) from source_kafka&quot;;</span><br><span class="line"></span><br><span class="line">        Table table&#x3D;tableEnv.sqlQuery(sql);</span><br><span class="line">        tableEnv.toAppendStream(table, Row.class).print();</span><br><span class="line">        tableEnv.execute(&quot;test&quot;);</span><br><span class="line">&#x2F;&#x2F;        streamEnv.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 实现自定义的ScalarFunction</span><br><span class="line">    public static class helper extends ScalarFunction &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public String eval(int uid,String date,int page)&#123;</span><br><span class="line">            String res&#x3D;uid+date+page;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class BrowseKafkaProcessFunction extends ProcessFunction&lt;String, Data&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void processElement(String value, Context ctx, Collector&lt;Data&gt; out) throws Exception &#123;</span><br><span class="line">                Data data&#x3D; JSON.parseObject(value, Data.class);</span><br><span class="line">                out.collect(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDTF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.flink.java.course02;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import org.apache.flink.api.common.serialization.SimpleStringSchema;</span><br><span class="line">import org.apache.flink.api.common.typeinfo.TypeInformation;</span><br><span class="line">import org.apache.flink.api.common.typeinfo.Types;</span><br><span class="line">import org.apache.flink.api.java.typeutils.RowTypeInfo;</span><br><span class="line">import org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line">import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line">import org.apache.flink.streaming.api.functions.ProcessFunction;</span><br><span class="line">import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer010;</span><br><span class="line">import org.apache.flink.table.api.EnvironmentSettings;</span><br><span class="line">import org.apache.flink.table.api.Table;</span><br><span class="line">import org.apache.flink.table.api.java.StreamTableEnvironment;</span><br><span class="line">import org.apache.flink.table.functions.ScalarFunction;</span><br><span class="line">import org.apache.flink.table.functions.TableFunction;</span><br><span class="line">import org.apache.flink.types.Row;</span><br><span class="line">import org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class UDTFConsumer1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        EnvironmentSettings settings &#x3D; EnvironmentSettings.newInstance().inStreamingMode().useBlinkPlanner().build();</span><br><span class="line">        StreamExecutionEnvironment streamEnv &#x3D; StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        StreamTableEnvironment tableEnv &#x3D; StreamTableEnvironment.getTableEnvironment(streamEnv);</span><br><span class="line">        StreamTableEnvironment tableEnv &#x3D; StreamTableEnvironment.create(streamEnv, settings);</span><br><span class="line"></span><br><span class="line">        streamEnv.setParallelism(1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3、注册Kafka数据源</span><br><span class="line">        Properties browseProperties &#x3D; new Properties();</span><br><span class="line">        browseProperties.put(&quot;bootstrap.servers&quot;,&quot;localhost:9092&quot;);</span><br><span class="line">        browseProperties.put(&quot;group.id&quot;,&quot;test-consumer-group&quot;);</span><br><span class="line">        &#x2F;**</span><br><span class="line">         *</span><br><span class="line">         * 有processFunction</span><br><span class="line">         *&#x2F;</span><br><span class="line">        DataStream&lt;Data&gt; browseStream&#x3D;streamEnv</span><br><span class="line">                .addSource(new FlinkKafkaConsumer010&lt;&gt;(&quot;test&quot;, new SimpleStringSchema(), browseProperties))</span><br><span class="line">                .process(new BrowseKafkaProcessFunction());</span><br><span class="line">        &#x2F;&#x2F; 增加uuid</span><br><span class="line">        System.out.println(&quot;----------------------------&quot;);</span><br><span class="line">     &#x2F;&#x2F;   browseStream.print();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------------------------&quot;);</span><br><span class="line">        tableEnv.registerDataStream(&quot;source_kafka&quot;,browseStream,&quot;uid,name,d,event_name,page,uuid&quot;);</span><br><span class="line">        &#x2F;&#x2F;注册函数</span><br><span class="line">        tableEnv.registerFunction(&quot;f&quot;,new helper());</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Data&#123;uid&#x3D;5, name&#x3D;&#39;user_5&#39;, date&#x3D;&#39;2021-01-08 13:01:20&#39;,</span><br><span class="line">         * event_name&#x3D;&#39;click&#x2F;browse&#39;, page&#x3D;1, uuid&#x3D;&#39;null&#39;&#125;</span><br><span class="line">         *&#x2F;</span><br><span class="line">      &#x2F;&#x2F;  tableEnv.toAppendStream(tableEnv.scan(&quot;source_kafka&quot;), Row.class).print();</span><br><span class="line">&#x2F;&#x2F;        streamEnv.execute();</span><br><span class="line">&#x2F;&#x2F;    tableEnv.execEnv();</span><br><span class="line">        String sql&#x3D;&quot;select uid, name, d, event_name, page, date1, time1 &quot; +</span><br><span class="line">                &quot;from source_kafka ,&quot;</span><br><span class="line">                + &quot;lateral table(f(d)) as T(date1,time1)&quot;;</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        Table table&#x3D;tableEnv.sqlQuery(sql);</span><br><span class="line">        tableEnv.toAppendStream(table, Row.class).print();</span><br><span class="line">        tableEnv.execute(&quot;test&quot;);</span><br><span class="line">&#x2F;&#x2F;        streamEnv.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class BrowseKafkaProcessFunction extends ProcessFunction&lt;String, Data&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void processElement(String value, Context ctx, Collector&lt;Data&gt; out) throws Exception &#123;</span><br><span class="line">                Data data&#x3D; JSON.parseObject(value, Data.class);</span><br><span class="line">                out.collect(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class helper extends TableFunction&lt;Row&gt; &#123;</span><br><span class="line">        public void eval(String value) &#123;</span><br><span class="line">            String[] valueSplits &#x3D; value.split(&quot; &quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;一行，两列</span><br><span class="line">            Row row &#x3D; new Row(2);</span><br><span class="line">            row.setField(0,valueSplits[0]);</span><br><span class="line">            row.setField(1,valueSplits[1]);</span><br><span class="line">            collect(row);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public TypeInformation&lt;Row&gt; getResultType() &#123;</span><br><span class="line">            return new RowTypeInfo(Types.STRING,Types.STRING);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDAF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.flink.java.course02;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import org.apache.flink.api.common.serialization.SimpleStringSchema;</span><br><span class="line">import org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line">import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line">import org.apache.flink.streaming.api.functions.ProcessFunction;</span><br><span class="line">import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer010;</span><br><span class="line">import org.apache.flink.table.api.EnvironmentSettings;</span><br><span class="line">import org.apache.flink.table.api.Table;</span><br><span class="line">import org.apache.flink.table.api.java.StreamTableEnvironment;</span><br><span class="line">import org.apache.flink.table.functions.AggregateFunction;</span><br><span class="line">import org.apache.flink.table.functions.ScalarFunction;</span><br><span class="line">import org.apache.flink.types.Row;</span><br><span class="line">import org.apache.flink.util.Collector;</span><br><span class="line">import scala.Int;</span><br><span class="line"></span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class UDAFConsumer1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        EnvironmentSettings settings &#x3D; EnvironmentSettings.newInstance().inStreamingMode().useBlinkPlanner().build();</span><br><span class="line">        StreamExecutionEnvironment streamEnv &#x3D; StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        StreamTableEnvironment tableEnv &#x3D; StreamTableEnvironment.getTableEnvironment(streamEnv);</span><br><span class="line">        StreamTableEnvironment tableEnv &#x3D; StreamTableEnvironment.create(streamEnv, settings);</span><br><span class="line"></span><br><span class="line">        streamEnv.setParallelism(1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3、注册Kafka数据源</span><br><span class="line">        Properties browseProperties &#x3D; new Properties();</span><br><span class="line">        browseProperties.put(&quot;bootstrap.servers&quot;,&quot;localhost:9092&quot;);</span><br><span class="line">        browseProperties.put(&quot;group.id&quot;,&quot;test-consumer-group&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        &#x2F;**</span><br><span class="line">&#x2F;&#x2F;         * 没有processFunction</span><br><span class="line">&#x2F;&#x2F;         *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;-------------------&quot;);</span><br><span class="line">&#x2F;&#x2F;        FlinkKafkaConsumer&lt;String&gt; myConsumer &#x3D; new FlinkKafkaConsumer&lt;&gt;(&quot;test&quot;, new SimpleStringSchema(), browseProperties);</span><br><span class="line">&#x2F;&#x2F;        DataStream&lt;Data&gt; stream &#x3D; streamEnv.addSource(myConsumer)</span><br><span class="line">&#x2F;&#x2F;                .process(new BrowseKafkaProcessFunction());</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        stream.print();</span><br><span class="line">&#x2F;&#x2F;        streamEnv.execute(&quot;hello&quot;);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;-------------------&quot;);</span><br><span class="line">        &#x2F;**</span><br><span class="line">         *</span><br><span class="line">         * 有processFunction</span><br><span class="line">         *&#x2F;</span><br><span class="line">        DataStream&lt;Data&gt; browseStream&#x3D;streamEnv</span><br><span class="line">                .addSource(new FlinkKafkaConsumer010&lt;&gt;(&quot;test&quot;, new SimpleStringSchema(), browseProperties))</span><br><span class="line">                .process(new BrowseKafkaProcessFunction());</span><br><span class="line">        &#x2F;&#x2F; 增加uuid</span><br><span class="line">        System.out.println(&quot;----------------------------&quot;);</span><br><span class="line">     &#x2F;&#x2F;   browseStream.print();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------------------------&quot;);</span><br><span class="line">        tableEnv.registerDataStream(&quot;source_kafka&quot;,browseStream,&quot;uid,name,d,event_name,page,uuid&quot;);</span><br><span class="line">        &#x2F;&#x2F;注册函数</span><br><span class="line">        tableEnv.registerFunction(&quot;f&quot;,new helper());</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Data&#123;uid&#x3D;5, name&#x3D;&#39;user_5&#39;, date&#x3D;&#39;2021-01-08 13:01:20&#39;,</span><br><span class="line">         * event_name&#x3D;&#39;click&#x2F;browse&#39;, page&#x3D;1, uuid&#x3D;&#39;null&#39;&#125;</span><br><span class="line">         *&#x2F;</span><br><span class="line">      &#x2F;&#x2F;  tableEnv.toAppendStream(tableEnv.scan(&quot;source_kafka&quot;), Row.class).print();</span><br><span class="line">&#x2F;&#x2F;        streamEnv.execute();</span><br><span class="line">&#x2F;&#x2F;    tableEnv.execEnv();</span><br><span class="line">        String sql&#x3D;&quot;select uid, f(uid) &quot; +</span><br><span class="line">             &#x2F;&#x2F;   &quot;, name, d, event_name, page, f(uid) &quot; +</span><br><span class="line">                &quot;from source_kafka &quot; +</span><br><span class="line">                &quot;group by uid&quot;;</span><br><span class="line"></span><br><span class="line">        Table table&#x3D;tableEnv.sqlQuery(sql);</span><br><span class="line">        tableEnv.toRetractStream(table, Row.class).print();</span><br><span class="line">        tableEnv.execute(&quot;test&quot;);</span><br><span class="line">&#x2F;&#x2F;        streamEnv.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class helper extends AggregateFunction&lt;Integer,helper.Account&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public static class Account&#123;</span><br><span class="line">            public Integer cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public Integer getValue(Account account) &#123;</span><br><span class="line">            return account.cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Account createAccumulator() &#123;</span><br><span class="line">            Account account&#x3D;new Account();</span><br><span class="line">            account.cnt&#x3D;0;</span><br><span class="line">            return account;</span><br><span class="line">        &#125;</span><br><span class="line">        public void accumulate(Account accumulator, Object iValue) &#123;</span><br><span class="line">            accumulator.cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static class BrowseKafkaProcessFunction extends ProcessFunction&lt;String, Data&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void processElement(String value, Context ctx, Collector&lt;Data&gt; out) throws Exception &#123;</span><br><span class="line">                Data data&#x3D; JSON.parseObject(value, Data.class);</span><br><span class="line">                out.collect(data);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Flink的pom.xml</title>
      <link href="/2021/01/09/Flink%E7%9A%84pom-xml/"/>
      <url>/2021/01/09/Flink%E7%9A%84pom-xml/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;bigdata&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.bigdata&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;flink-1.10.0&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.encoding&gt;UTF-8&lt;&#x2F;maven.compiler.encoding&gt;</span><br><span class="line">        &lt;sl4j-version&gt;1.7.13&lt;&#x2F;sl4j-version&gt;</span><br><span class="line">        &lt;junit-version&gt;4.12&lt;&#x2F;junit-version&gt;</span><br><span class="line">        &lt;lombok-version&gt;1.18.8&lt;&#x2F;lombok-version&gt;</span><br><span class="line">        &lt;fastjson-version&gt;1.2.5&lt;&#x2F;fastjson-version&gt;</span><br><span class="line">        &lt;commons-cli-version&gt;1.4&lt;&#x2F;commons-cli-version&gt;</span><br><span class="line">        &lt;mysql-connector-version&gt;5.1.6&lt;&#x2F;mysql-connector-version&gt;</span><br><span class="line">        &lt;hadoop-version&gt;3.0.0.3.0.0.0-829&lt;&#x2F;hadoop-version&gt;</span><br><span class="line">        &lt;flink-version&gt;1.10.0&lt;&#x2F;flink-version&gt;</span><br><span class="line">        &lt;guava-version&gt;18.0&lt;&#x2F;guava-version&gt;</span><br><span class="line">        &lt;common-beanutil-version&gt;1.9.3&lt;&#x2F;common-beanutil-version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.1&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--日志依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;sl4j-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;sl4j-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--单元测试--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;junit-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--Lombok注解--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;lombok-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--Fastjson解析--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;fastjson-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--命令行工具--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-cli&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-cli&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;commons-cli-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--Guava工具库--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;guava-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--BeanUtils--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-beanutils&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-beanutils&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;common-beanutil-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--Flink核心依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-streaming-java_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-table-api-java-bridge_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">        &lt;!--    &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;--&gt;</span><br><span class="line">        &lt;!--    &lt;artifactId&gt;flink-table-api-java&lt;&#x2F;artifactId&gt;--&gt;</span><br><span class="line">        &lt;!--    &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;&#x2F;dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">        &lt;!--    &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;--&gt;</span><br><span class="line">        &lt;!--    &lt;artifactId&gt;flink-table&lt;&#x2F;artifactId&gt;--&gt;</span><br><span class="line">        &lt;!--    &lt;version&gt;1.10.0&lt;&#x2F;version&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;&#x2F;dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-table-planner-blink_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-table-planner_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-streaming-scala_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-table-common&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-statebackend-rocksdb_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-yarn_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-clients_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.elasticsearch&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;elasticsearch-x-content&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;6.4.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.elasticsearch.client&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;7.3.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-connector-kafka-0.10_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-json&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.httpcomponents&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;httpclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.5.3&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">        &lt;!--    &lt;groupId&gt;org.elasticsearch.client&lt;&#x2F;groupId&gt;--&gt;</span><br><span class="line">        &lt;!--    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;&#x2F;artifactId&gt;--&gt;</span><br><span class="line">        &lt;!--    &lt;version&gt;6.3.1&lt;&#x2F;version&gt;--&gt;</span><br><span class="line">        &lt;!--    --&gt;</span><br><span class="line">        &lt;!--&lt;&#x2F;dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-connector-kafka-0.10_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-jdbc_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.10.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.18&lt;&#x2F;version&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.1&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink Transformation</title>
      <link href="/2021/01/09/Flink-Transformation/"/>
      <url>/2021/01/09/Flink-Transformation/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、Transformations-分类"><a href="#一、Transformations-分类" class="headerlink" title="一、Transformations 分类"></a>一、Transformations 分类</h2><p>Flink 的 Transformations 操作主要用于将一个和多个 DataStream 按需转换成新的 DataStream。它主要分为以下三类：</p><ul><li><strong>DataStream Transformations</strong>：进行数据流相关转换操作；</li><li><strong>Physical partitioning</strong>：物理分区。Flink 提供的底层 API ，允许用户定义数据的分区规则；</li><li><strong>Task chaining and resource groups</strong>：任务链和资源组。允许用户进行任务链和资源组的细粒度的控制。</li></ul><p>以下分别对其主要 API 进行介绍：</p><h2 id="二、DataStream-Transformations"><a href="#二、DataStream-Transformations" class="headerlink" title="二、DataStream Transformations"></a>二、DataStream Transformations</h2><h3 id="2-1-Map-DataStream-→-DataStream"><a href="#2-1-Map-DataStream-→-DataStream" class="headerlink" title="2.1 Map [DataStream → DataStream]"></a>2.1 Map [DataStream → DataStream]</h3><p>对一个 DataStream 中的每个元素都执行特定的转换操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Integer&gt; integerDataStream = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">integerDataStream.map((MapFunction&lt;Integer, Object&gt;) value -&gt; value * <span class="number">2</span>).print();</span><br><span class="line"><span class="comment">// 输出 2,4,6,8,10</span></span><br></pre></td></tr></table></figure><h3 id="2-2-FlatMap-DataStream-→-DataStream"><a href="#2-2-FlatMap-DataStream-→-DataStream" class="headerlink" title="2.2 FlatMap [DataStream → DataStream]"></a>2.2 FlatMap [DataStream → DataStream]</h3><p>FlatMap 与 Map 类似，但是 FlatMap 中的一个输入元素可以被映射成一个或者多个输出元素，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件读取数据</span></span><br><span class="line">    DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">"/Users/didi/SSG-Flink/4.代码/FlinkTutorial/src/main/resources/sensor.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. map，把String转换成长度输出</span></span><br><span class="line">    DataStream&lt;Integer&gt; mapStream = inputStream.map(<span class="keyword">new</span> MapFunction&lt;String, Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. flatmap，按逗号分字段</span></span><br><span class="line">    DataStream&lt;String&gt; flatMapStream = inputStream.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            String[] fields = value.split(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">for</span>( String field: fields )</span><br><span class="line">                out.collect(field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. filter, 筛选sensor_1开头的id对应的数据</span></span><br><span class="line">    DataStream&lt;String&gt; filterStream = inputStream.filter(<span class="keyword">new</span> FilterFunction&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value.startsWith(<span class="string">"sensor_1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印输出</span></span><br><span class="line">    mapStream.print(<span class="string">"map"</span>);</span><br><span class="line">    flatMapStream.print(<span class="string">"flatMap"</span>);</span><br><span class="line">    filterStream.print(<span class="string">"filter"</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Filter-DataStream-→-DataStream"><a href="#2-3-Filter-DataStream-→-DataStream" class="headerlink" title="2.3 Filter [DataStream → DataStream]"></a>2.3 Filter [DataStream → DataStream]</h3><p>用于过滤符合条件的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).filter(x -&gt; x &gt; <span class="number">3</span>).print();</span><br></pre></td></tr></table></figure><h3 id="2-4-KeyBy-和-Reduce"><a href="#2-4-KeyBy-和-Reduce" class="headerlink" title="2.4 KeyBy 和 Reduce"></a>2.4 KeyBy 和 Reduce</h3><p><a href="https://www.jianshu.com/p/0cdf1112d995" target="_blank" rel="noopener">https://www.jianshu.com/p/0cdf1112d995</a></p><ul><li><strong>KeyBy [DataStream → KeyedStream]</strong> ：用于将相同 Key 值的数据分到相同的分区中；</li><li><strong>Reduce [KeyedStream → DataStream]</strong> ：用于对数据执行归约计算。</li></ul><p>如下例子将数据按照 key 值分区后，滚动进行求和计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; dataStream = inputStream.map( line -&gt; &#123;</span><br><span class="line">    String[] fields = line.split(<span class="string">","</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SensorReading(fields[<span class="number">0</span>], <span class="keyword">new</span> Long(fields[<span class="number">1</span>]), <span class="keyword">new</span> Double(fields[<span class="number">2</span>]));</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分组</span></span><br><span class="line">KeyedStream&lt;SensorReading, Tuple&gt; keyedStream = dataStream.keyBy(<span class="string">"id"</span>);</span><br><span class="line">KeyedStream&lt;SensorReading, String&gt; keyedStream1 = dataStream.keyBy(data -&gt; data.getId());</span><br><span class="line"></span><br><span class="line">DataStream&lt;Long&gt; dataStream1 = env.fromElements(<span class="number">1L</span>, <span class="number">34L</span>, <span class="number">4L</span>, <span class="number">657L</span>, <span class="number">23L</span>);</span><br><span class="line">KeyedStream&lt;Long, Integer&gt; keyedStream2 = dataStream1.keyBy(<span class="keyword">new</span> KeySelector&lt;Long, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getKey</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.intValue() % <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        KeyedStream&lt;SensorReading, String&gt; keyedStream1 = dataStream.keyBy(SensorReading::getId);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动聚合，取当前最大的温度值</span></span><br><span class="line">DataStream&lt;SensorReading&gt; resultStream = keyedStream.maxBy(<span class="string">"temperature"</span>);</span><br><span class="line"></span><br><span class="line">resultStream.print(<span class="string">"result"</span>);</span><br><span class="line"></span><br><span class="line">keyedStream1.print(<span class="string">"key1"</span>);</span><br><span class="line">keyedStream2.sum(<span class="number">0</span>).print(<span class="string">"key2"</span>);</span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure><p>KeyBy 操作存在以下两个限制：</p><ul><li>KeyBy 操作用于用户自定义的 POJOs 类型时，该自定义类型必须重写 hashCode 方法；</li><li>KeyBy 操作不能用于数组类型。</li></ul><h3 id="2-5-Aggregations-KeyedStream-→-DataStream"><a href="#2-5-Aggregations-KeyedStream-→-DataStream" class="headerlink" title="2.5 Aggregations [KeyedStream → DataStream]"></a>2.5 Aggregations [KeyedStream → DataStream]</h3><p>Aggregations 是官方提供的聚合算子，封装了常用的聚合操作，如上利用 Reduce 进行求和的操作也可以利用 Aggregations 中的 sum 算子重写为下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple2DataStream.keyBy(<span class="number">0</span>).sum(<span class="number">1</span>).print();</span><br></pre></td></tr></table></figure><p>除了 sum 外，Flink 还提供了 min , max , minBy，maxBy 等常用聚合算子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动计算指定key的最小值，可以通过index或者fieldName来指定key</span></span><br><span class="line">keyedStream.min(<span class="number">0</span>);</span><br><span class="line">keyedStream.min(<span class="string">"key"</span>);</span><br><span class="line"><span class="comment">// 滚动计算指定key的最大值</span></span><br><span class="line">keyedStream.max(<span class="number">0</span>);</span><br><span class="line">keyedStream.max(<span class="string">"key"</span>);</span><br><span class="line"><span class="comment">// 滚动计算指定key的最小值，并返回其对应的元素</span></span><br><span class="line">keyedStream.minBy(<span class="number">0</span>);</span><br><span class="line">keyedStream.minBy(<span class="string">"key"</span>);</span><br><span class="line"><span class="comment">// 滚动计算指定key的最大值，并返回其对应的元素</span></span><br><span class="line">keyedStream.maxBy(<span class="number">0</span>);</span><br><span class="line">keyedStream.maxBy(<span class="string">"key"</span>);</span><br></pre></td></tr></table></figure><h3 id="2-6-Union-DataStream-→-DataStream"><a href="#2-6-Union-DataStream-→-DataStream" class="headerlink" title="2.6 Union [DataStream* → DataStream]"></a>2.6 Union [DataStream* → DataStream]</h3><p>用于连接两个或者多个元素类型相同的 DataStream 。当然一个 DataStream 也可以与其本生进行连接，此时该 DataStream 中的每个元素都会被获取两次：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataStreamSource&lt;Tuple2&lt;String, Integer&gt;&gt; streamSource01 = env.fromElements(new Tuple2&lt;&gt;("a", 1), </span><br><span class="line">                                                                            new Tuple2&lt;&gt;("a", 2));</span><br><span class="line">DataStreamSource&lt;Tuple2&lt;String, Integer&gt;&gt; streamSource02 = env.fromElements(new Tuple2&lt;&gt;("b", 1), </span><br><span class="line">                                                                            new Tuple2&lt;&gt;("b", 2));</span><br><span class="line">streamSource01.union(streamSource02);</span><br><span class="line">streamSource01.union(streamSource01,streamSource02);</span><br></pre></td></tr></table></figure><h3 id="2-7-Connect-DataStream-DataStream-→-ConnectedStreams"><a href="#2-7-Connect-DataStream-DataStream-→-ConnectedStreams" class="headerlink" title="2.7 Connect [DataStream,DataStream → ConnectedStreams]"></a>2.7 Connect [DataStream,DataStream → ConnectedStreams]</h3><p>Connect 操作用于连接两个或者多个类型不同的 DataStream ，其返回的类型是 ConnectedStreams ，此时被连接的多个 DataStreams 可以共享彼此之间的数据状态。但是需要注意的是由于不同 DataStream 之间的数据类型是不同的，如果想要进行后续的计算操作，还需要通过 CoMap 或 CoFlatMap 将 ConnectedStreams  转换回 DataStream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DataStreamSource&lt;Tuple2&lt;String, Integer&gt;&gt; streamSource01 = env.fromElements(<span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"a"</span>, <span class="number">3</span>), </span><br><span class="line">                                                                            <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"b"</span>, <span class="number">5</span>));</span><br><span class="line">DataStreamSource&lt;Integer&gt; streamSource02 = env.fromElements(<span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line"><span class="comment">// 使用connect进行连接</span></span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;String, Integer&gt;, Integer&gt; connect = streamSource01.connect(streamSource02);</span><br><span class="line">connect.map(<span class="keyword">new</span> CoMapFunction&lt;Tuple2&lt;String, Integer&gt;, Integer, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">map1</span><span class="params">(Tuple2&lt;String, Integer&gt; value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.f1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">map2</span><span class="params">(Integer value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).map(x -&gt; x * <span class="number">100</span>).print();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="number">300</span> <span class="number">500</span> <span class="number">200</span> <span class="number">900</span> <span class="number">300</span></span><br></pre></td></tr></table></figure><h3 id="2-8-Split-和-Select"><a href="#2-8-Split-和-Select" class="headerlink" title="2.8 Split 和 Select"></a>2.8 Split 和 Select</h3><ul><li><strong>Split [DataStream → SplitStream]</strong>：用于将一个 DataStream 按照指定规则进行拆分为多个 DataStream，需要注意的是这里进行的是逻辑拆分，即 Split 只是将数据贴上不同的类型标签，但最终返回的仍然只是一个 SplitStream；</li><li><strong>Select [SplitStream → DataStream]</strong>：想要从逻辑拆分的 SplitStream 中获取真实的不同类型的 DataStream，需要使用 Select 算子，示例如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DataStreamSource&lt;Integer&gt; streamSource = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 标记</span></span><br><span class="line">SplitStream&lt;Integer&gt; split = streamSource.split(<span class="keyword">new</span> OutputSelector&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">select</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; output = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        output.add(value % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">"even"</span> : <span class="string">"odd"</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获取偶数数据集</span></span><br><span class="line">split.select(<span class="string">"even"</span>).print();</span><br><span class="line"><span class="comment">// 输出 2,4,6,8</span></span><br></pre></td></tr></table></figure><h3 id="2-9-project-DataStream-→-DataStream"><a href="#2-9-project-DataStream-→-DataStream" class="headerlink" title="2.9 project [DataStream → DataStream]"></a>2.9 project [DataStream → DataStream]</h3><p>project 主要用于获取 tuples 中的指定字段集，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DataStreamSource&lt;Tuple3&lt;String, Integer, String&gt;&gt; streamSource = env.fromElements(</span><br><span class="line">                                                                         <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="string">"li"</span>, <span class="number">22</span>, <span class="string">"2018-09-23"</span>),</span><br><span class="line">                                                                         <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="string">"ming"</span>, <span class="number">33</span>, <span class="string">"2020-09-23"</span>));</span><br><span class="line">streamSource.project(<span class="number">0</span>,<span class="number">2</span>).print();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">(li,<span class="number">2018</span>-<span class="number">09</span>-<span class="number">23</span>)</span><br><span class="line">(ming,<span class="number">2020</span>-<span class="number">09</span>-<span class="number">23</span>)</span><br></pre></td></tr></table></figure><h2 id="三、物理分区"><a href="#三、物理分区" class="headerlink" title="三、物理分区"></a>三、物理分区</h2><p>物理分区 (Physical partitioning) 是 Flink 提供的底层的 API，允许用户采用内置的分区规则或者自定义的分区规则来对数据进行分区，从而避免数据在某些分区上过于倾斜，常用的分区规则如下：</p><h3 id="3-1-Random-partitioning-DataStream-→-DataStream"><a href="#3-1-Random-partitioning-DataStream-→-DataStream" class="headerlink" title="3.1 Random partitioning [DataStream → DataStream]"></a>3.1 Random partitioning [DataStream → DataStream]</h3><p>随机分区 (Random partitioning) 用于随机的将数据分布到所有下游分区中，通过 shuffle 方法来进行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataStream.shuffle();</span><br></pre></td></tr></table></figure><h3 id="3-2-Rebalancing-DataStream-→-DataStream"><a href="#3-2-Rebalancing-DataStream-→-DataStream" class="headerlink" title="3.2 Rebalancing [DataStream → DataStream]"></a>3.2 Rebalancing [DataStream → DataStream]</h3><p>Rebalancing 采用轮询的方式将数据进行分区，其适合于存在数据倾斜的场景下，通过 rebalance 方法进行实现：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataStream.rebalance();</span><br></pre></td></tr></table></figure><h3 id="3-3-Rescaling-DataStream-→-DataStream"><a href="#3-3-Rescaling-DataStream-→-DataStream" class="headerlink" title="3.3 Rescaling [DataStream → DataStream]"></a>3.3 Rescaling [DataStream → DataStream]</h3><p>当采用 Rebalancing 进行分区平衡时，其实现的是全局性的负载均衡，数据会通过网络传输到其他节点上并完成分区数据的均衡。 而 Rescaling 则是低配版本的 rebalance，它不需要额外的网络开销，它只会对上下游的算子之间进行重新均衡，通过 rescale 方法进行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataStream.rescale();</span><br></pre></td></tr></table></figure><p>ReScale 这个单词具有重新缩放的意义，其对应的操作也是如此，具体如下：如果上游 operation 并行度为 2，而下游的 operation 并行度为 6，则其中 1 个上游的 operation 会将元素分发到 3 个下游 operation，另 1 个上游 operation 则会将元素分发到另外 3 个下游 operation。反之亦然，如果上游的 operation 并行度为 6，而下游 operation 并行度为 2，则其中 3 个上游 operation 会将元素分发到 1 个下游 operation，另 3 个上游 operation 会将元素分发到另外 1 个下游operation：</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-Rescaling.png"> </div><h3 id="3-4-Broadcasting-DataStream-→-DataStream"><a href="#3-4-Broadcasting-DataStream-→-DataStream" class="headerlink" title="3.4 Broadcasting [DataStream → DataStream]"></a>3.4 Broadcasting [DataStream → DataStream]</h3><p>将数据分发到所有分区上。通常用于小数据集与大数据集进行关联的情况下，此时可以将小数据集广播到所有分区上，避免频繁的跨分区关联，通过 broadcast 方法进行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataStream.broadcast();</span><br></pre></td></tr></table></figure><h3 id="3-5-Custom-partitioning-DataStream-→-DataStream"><a href="#3-5-Custom-partitioning-DataStream-→-DataStream" class="headerlink" title="3.5 Custom partitioning [DataStream → DataStream]"></a>3.5 Custom partitioning [DataStream → DataStream]</h3><p>Flink 运行用户采用自定义的分区规则来实现分区，此时需要通过实现 Partitioner 接口来自定义分区规则，并指定对应的分区键，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> DataStreamSource&lt;Tuple2&lt;String, Integer&gt;&gt; streamSource = env.fromElements(<span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"Hadoop"</span>, <span class="number">1</span>),</span><br><span class="line">                <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"Spark"</span>, <span class="number">1</span>),</span><br><span class="line">                <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"Flink-streaming"</span>, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"Flink-batch"</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"Storm"</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"HBase"</span>, <span class="number">3</span>));</span><br><span class="line">streamSource.partitionCustom(<span class="keyword">new</span> Partitioner&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String key, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将第一个字段包含flink的Tuple2分配到同一个分区</span></span><br><span class="line">        <span class="keyword">return</span> key.toLowerCase().contains(<span class="string">"flink"</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">0</span>).print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下：</span></span><br><span class="line"><span class="number">1</span>&gt; (Flink-streaming,<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span>&gt; (Flink-batch,<span class="number">4</span>)</span><br><span class="line"><span class="number">2</span>&gt; (Hadoop,<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span>&gt; (Spark,<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span>&gt; (Storm,<span class="number">4</span>)</span><br><span class="line"><span class="number">2</span>&gt; (HBase,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="四、任务链和资源组"><a href="#四、任务链和资源组" class="headerlink" title="四、任务链和资源组"></a>四、任务链和资源组</h2><p>任务链和资源组 ( Task chaining and resource groups ) 也是 Flink 提供的底层 API，用于控制任务链和资源分配。默认情况下，如果操作允许 (例如相邻的两次 map 操作) ，则 Flink 会尝试将它们在同一个线程内进行，从而可以获取更好的性能。但是 Flink 也允许用户自己来控制这些行为，这就是任务链和资源组 API：</p><h3 id="4-1-startNewChain"><a href="#4-1-startNewChain" class="headerlink" title="4.1 startNewChain"></a>4.1 startNewChain</h3><p>startNewChain 用于基于当前 operation 开启一个新的任务链。如下所示，基于第一个 map 开启一个新的任务链，此时前一个 map 和 后一个 map 将处于同一个新的任务链中，但它们与 filter 操作则分别处于不同的任务链中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someStream.filter(...).map(...).startNewChain().map(...);</span><br></pre></td></tr></table></figure><h3 id="4-2-disableChaining"><a href="#4-2-disableChaining" class="headerlink" title="4.2 disableChaining"></a>4.2 disableChaining</h3><p> disableChaining 操作用于禁止将其他操作与当前操作放置于同一个任务链中，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someStream.map(...).disableChaining();</span><br></pre></td></tr></table></figure><h3 id="4-3-slotSharingGroup"><a href="#4-3-slotSharingGroup" class="headerlink" title="4.3 slotSharingGroup"></a>4.3 slotSharingGroup</h3><p>slot 是任务管理器  (TaskManager) 所拥有资源的固定子集，每个操作 (operation) 的子任务 (sub task) 都需要获取 slot 来执行计算，但每个操作所需要资源的大小都是不相同的，为了更好地利用资源，Flink 允许不同操作的子任务被部署到同一 slot 中。slotSharingGroup 用于设置操作的 slot 共享组 (slot sharing group) ，Flink 会将具有相同 slot 共享组的操作放到同一个 slot 中 。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someStream.filter(...).slotSharingGroup(<span class="string">"slotSharingGroupName"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>检查点</title>
      <link href="/2021/01/09/%E6%A3%80%E6%9F%A5%E7%82%B9/"/>
      <url>/2021/01/09/%E6%A3%80%E6%9F%A5%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="CheckPoints"><a href="#CheckPoints" class="headerlink" title="CheckPoints"></a>CheckPoints</h3><p>为了使 Flink 的状态具有良好的容错性，Flink 提供了检查点机制 (CheckPoints)  。通过检查点机制，Flink 定期在数据流上生成 checkpoint barrier ，当某个算子收到 barrier 时，即会基于当前状态生成一份快照，然后再将该 barrier 传递到下游算子，下游算子接收到该 barrier 后，也基于当前状态生成一份快照，依次传递直至到最后的 Sink 算子上。当出现异常后，Flink 就可以根据最近的一次的快照数据将所有算子恢复到先前的状态。</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-stream-barriers.png"> </div><h3 id="开启检查点"><a href="#开启检查点" class="headerlink" title="开启检查点"></a>开启检查点</h3><p>默认情况下，检查点机制是关闭的，需要在程序中进行开启：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启检查点机制，并指定状态检查点之间的时间间隔</span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他可选配置如下：</span></span><br><span class="line"><span class="comment">// 设置语义</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line"><span class="comment">// 设置两个检查点之间的最小时间间隔</span></span><br><span class="line">env.getCheckpointConfig().setMinPauseBetweenCheckpoints(<span class="number">500</span>);</span><br><span class="line"><span class="comment">// 设置执行Checkpoint操作时的超时时间</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointTimeout(<span class="number">60000</span>);</span><br><span class="line"><span class="comment">// 设置最大并发执行的检查点的数量</span></span><br><span class="line">env.getCheckpointConfig().setMaxConcurrentCheckpoints(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将检查点持久化到外部存储</span></span><br><span class="line">env.getCheckpointConfig().enableExternalizedCheckpoints(</span><br><span class="line">    ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);</span><br><span class="line"><span class="comment">// 如果有更近的保存点时，是否将作业回退到该检查点</span></span><br><span class="line">env.getCheckpointConfig().setPreferCheckpointForRecovery(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="保存点机制"><a href="#保存点机制" class="headerlink" title="保存点机制"></a>保存点机制</h3><p>保存点机制 (Savepoints) 是检查点机制的一种特殊的实现，它允许你通过手工的方式来触发 Checkpoint，并将结果持久化存储到指定路径中，主要用于避免 Flink 集群在重启或升级时导致状态丢失。示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 触发指定id的作业的Savepoint，并将结果存储到指定目录下</span></span><br><span class="line">bin/flink savepoint :jobId [:targetDirectory]</span><br></pre></td></tr></table></figure><p>更多命令和配置可以参考官方文档：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/ops/state/savepoints.html" target="_blank" rel="noopener">savepoints</a></p><h2 id="状态后端"><a href="#状态后端" class="headerlink" title="状态后端"></a>状态后端</h2><h3 id="状态管理器分类"><a href="#状态管理器分类" class="headerlink" title="状态管理器分类"></a>状态管理器分类</h3><p>默认情况下，所有的状态都存储在 JVM 的堆内存中，在状态数据过多的情况下，这种方式很有可能导致内存溢出，因此 Flink 该提供了其它方式来存储状态数据，这些存储方式统一称为状态后端 (或状态管理器)：</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-checkpoints-backend.png"> </div><p>主要有以下三种：</p><h4 id="1-MemoryStateBackend"><a href="#1-MemoryStateBackend" class="headerlink" title="1. MemoryStateBackend"></a>1. MemoryStateBackend</h4><p>默认的方式，即基于 JVM 的堆内存进行存储，主要适用于本地开发和调试。</p><h4 id="2-FsStateBackend"><a href="#2-FsStateBackend" class="headerlink" title="2. FsStateBackend"></a>2. FsStateBackend</h4><p>基于文件系统进行存储，可以是本地文件系统，也可以是 HDFS 等分布式文件系统。 需要注意而是虽然选择使用了 FsStateBackend ，但正在进行的数据仍然是存储在 TaskManager 的内存中的，只有在 checkpoint 时，才会将状态快照写入到指定文件系统上。</p><h4 id="3-RocksDBStateBackend"><a href="#3-RocksDBStateBackend" class="headerlink" title="3. RocksDBStateBackend"></a>3. RocksDBStateBackend</h4><p>RocksDBStateBackend 是 Flink 内置的第三方状态管理器，采用嵌入式的 key-value 型数据库 RocksDB 来存储正在进行的数据。等到 checkpoint 时，再将其中的数据持久化到指定的文件系统中，所以采用 RocksDBStateBackend 时也需要配置持久化存储的文件系统。之所以这样做是因为 RocksDB 作为嵌入式数据库安全性比较低，但比起全文件系统的方式，其读取速率更快；比起全内存的方式，其存储空间更大，因此它是一种比较均衡的方案。</p><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>Flink 支持使用两种方式来配置后端管理器：</p><p><strong>第一种方式</strong>：基于代码方式进行配置，只对当前作业生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 FsStateBackend</span></span><br><span class="line">env.setStateBackend(<span class="keyword">new</span> FsStateBackend(<span class="string">"hdfs://namenode:40010/flink/checkpoints"</span>));</span><br><span class="line"><span class="comment">// 配置 RocksDBStateBackend</span></span><br><span class="line">env.setStateBackend(<span class="keyword">new</span> RocksDBStateBackend(<span class="string">"hdfs://namenode:40010/flink/checkpoints"</span>));</span><br></pre></td></tr></table></figure><p>配置 RocksDBStateBackend 时，需要额外导入下面的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-statebackend-rocksdb_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第二种方式</strong>：基于 <code>flink-conf.yaml</code> 配置文件的方式进行配置，对所有部署在该集群上的作业都生效：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">state.backend:</span> <span class="string">filesystem</span></span><br><span class="line"><span class="attr">state.checkpoints.dir:</span> <span class="string">hdfs://namenode:40010/flink/checkpoints</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Source的概念以及用法</title>
      <link href="/2021/01/09/Source%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
      <url>/2021/01/09/Source%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="一、内置-Data-Source"><a href="#一、内置-Data-Source" class="headerlink" title="一、内置 Data Source"></a>一、内置 Data Source</h2><p>Flink Data Source 用于定义 Flink 程序的数据来源，Flink 官方提供了多种数据获取方法，用于帮助开发者简单快速地构建输入流，具体如下：</p><h3 id="1-1-基于文件构建"><a href="#1-1-基于文件构建" class="headerlink" title="1.1 基于文件构建"></a>1.1 基于文件构建</h3><p><strong>1. readTextFile(path)</strong>：按照 TextInputFormat 格式读取文本文件，并将其内容以字符串的形式返回。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件读取数据</span></span><br><span class="line">    DataStream&lt;String&gt; dataStream = env.readTextFile(<span class="string">"D:\\Projects\\BigData\\FlinkTutorial\\src\\main\\resources\\sensor.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印输出</span></span><br><span class="line">    dataStream.print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. readFile(fileInputFormat, path)</strong> ：按照指定格式读取文件。</p><p><strong>3. readFile(inputFormat, filePath, watchType, interval, typeInformation)</strong>：按照指定格式周期性的读取文件。其中各个参数的含义如下：</p><ul><li><strong>inputFormat</strong>：数据流的输入格式。</li><li><strong>filePath</strong>：文件路径，可以是本地文件系统上的路径，也可以是 HDFS 上的文件路径。</li><li><strong>watchType</strong>：读取方式，它有两个可选值，分别是 <code>FileProcessingMode.PROCESS_ONCE</code> 和 <code>FileProcessingMode.PROCESS_CONTINUOUSLY</code>：前者表示对指定路径上的数据只读取一次，然后退出；后者表示对路径进行定期地扫描和读取。需要注意的是如果 watchType 被设置为 <code>PROCESS_CONTINUOUSLY</code>，那么当文件被修改时，其所有的内容 (包含原有的内容和新增的内容) 都将被重新处理，因此这会打破 Flink 的 <em>exactly-once</em> 语义。</li><li><strong>interval</strong>：定期扫描的时间间隔。</li><li><strong>typeInformation</strong>：输入流中元素的类型。</li></ul><p>使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String filePath = <span class="string">"D:\\log4j.properties"</span>;</span><br><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.readFile(<span class="keyword">new</span> TextInputFormat(<span class="keyword">new</span> Path(filePath)),</span><br><span class="line">             filePath,</span><br><span class="line">             FileProcessingMode.PROCESS_ONCE,</span><br><span class="line">             <span class="number">1</span>,</span><br><span class="line">             BasicTypeInfo.STRING_TYPE_INFO).print();</span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure><h3 id="1-2-基于集合构建"><a href="#1-2-基于集合构建" class="headerlink" title="1.2 基于集合构建"></a>1.2 基于集合构建</h3><p><strong>1. fromCollection(Collection)</strong>：基于集合构建，集合中的所有元素必须是同一类型。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 创建执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从集合中读取数据</span></span><br><span class="line">    DataStream&lt;SensorReading&gt; dataStream = env.fromCollection(Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> SensorReading(<span class="string">"sensor_1"</span>, <span class="number">1547718199L</span>, <span class="number">35.8</span>),</span><br><span class="line">            <span class="keyword">new</span> SensorReading(<span class="string">"sensor_6"</span>, <span class="number">1547718201L</span>, <span class="number">15.4</span>),</span><br><span class="line">            <span class="keyword">new</span> SensorReading(<span class="string">"sensor_7"</span>, <span class="number">1547718202L</span>, <span class="number">6.7</span>),</span><br><span class="line">            <span class="keyword">new</span> SensorReading(<span class="string">"sensor_10"</span>, <span class="number">1547718205L</span>, <span class="number">38.1</span>)</span><br><span class="line">    ));</span><br><span class="line">    DataStream&lt;Integer&gt; integerDataStream = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">67</span>, <span class="number">189</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印输出</span></span><br><span class="line">    dataStream.print(<span class="string">"data"</span>);</span><br><span class="line">    integerDataStream.print(<span class="string">"int"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. fromElements(T …)</strong>： 基于元素构建，所有元素必须是同一类型。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.fromElements(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).print();</span><br></pre></td></tr></table></figure><p><strong>3. generateSequence(from, to)</strong>：基于给定的序列区间进行构建。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.generateSequence(<span class="number">0</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><strong>4. fromCollection(Iterator, Class)</strong>：基于迭代器进行构建。第一个参数用于定义迭代器，第二个参数用于定义输出元素的类型。使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.fromCollection(<span class="keyword">new</span> CustomIterator(), BasicTypeInfo.INT_TYPE_INFO).print();</span><br></pre></td></tr></table></figure><p>其中 CustomIterator 为自定义的迭代器，这里以产生 1 到 100 区间内的数据为例，源码如下。需要注意的是自定义迭代器除了要实现 Iterator 接口外，还必须要实现序列化接口 Serializable ，否则会抛出序列化失败的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. fromParallelCollection(SplittableIterator, Class)</strong>：方法接收两个参数，第二个参数用于定义输出元素的类型，第一个参数 SplittableIterator 是迭代器的抽象基类，它用于将原始迭代器的值拆分到多个不相交的迭代器中。</p><h3 id="1-3-基于-Socket-构建"><a href="#1-3-基于-Socket-构建" class="headerlink" title="1.3  基于 Socket 构建"></a>1.3  基于 Socket 构建</h3><p>Flink 提供了 socketTextStream 方法用于构建基于 Socket 的数据流，socketTextStream 方法有以下四个主要参数：</p><ul><li><strong>hostname</strong>：主机名；</li><li><strong>port</strong>：端口号，设置为 0 时，表示端口号自动分配；</li><li><strong>delimiter</strong>：用于分隔每条记录的分隔符；</li><li><strong>maxRetry</strong>：当 Socket 临时关闭时，程序的最大重试间隔，单位为秒。设置为 0 时表示不进行重试；设置为负值则表示一直重试。示例如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.socketTextStream("192.168.0.229", 9999, "\n", 3).print();</span><br></pre></td></tr></table></figure><h2 id="二、自定义-Data-Source"><a href="#二、自定义-Data-Source" class="headerlink" title="二、自定义 Data Source"></a>二、自定义 Data Source</h2><h3 id="2-1-SourceFunction"><a href="#2-1-SourceFunction" class="headerlink" title="2.1 SourceFunction"></a>2.1 SourceFunction</h3><p>除了内置的数据源外，用户还可以使用 <code>addSource</code> 方法来添加自定义的数据源。自定义的数据源必须要实现 SourceFunction 接口，这里以产生 [0 , 1000) 区间内的数据为例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">env.addSource(<span class="keyword">new</span> SourceFunction&lt;Long&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Long&gt; ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isRunning &amp;&amp; count &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过collect将输入发送出去 </span></span><br><span class="line">            ctx.collect(count);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isRunning = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;).print();</span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure><h3 id="2-2-ParallelSourceFunction-和-RichParallelSourceFunction"><a href="#2-2-ParallelSourceFunction-和-RichParallelSourceFunction" class="headerlink" title="2.2 ParallelSourceFunction 和 RichParallelSourceFunction"></a>2.2 ParallelSourceFunction 和 RichParallelSourceFunction</h3><p>上面通过 SourceFunction 实现的数据源是不具有并行度的，即不支持在得到的 DataStream 上调用 <code>setParallelism(n)</code> 方法，此时会抛出如下的异常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" java.lang.IllegalArgumentException: Source: 1 is not a parallel source</span><br></pre></td></tr></table></figure><p>如果你想要实现具有并行度的输入流，则需要实现 ParallelSourceFunction 或 RichParallelSourceFunction 接口，其与 SourceFunction 的关系如下图： </p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-RichParallelSourceFunction.png"> </div><p>ParallelSourceFunction 直接继承自 ParallelSourceFunction，具有并行度的功能。RichParallelSourceFunction 则继承自 AbstractRichFunction，同时实现了 ParallelSourceFunction 接口，所以其除了具有并行度的功能外，还提供了额外的与生命周期相关的方法，如 open() ，closen() 。</p><h2 id="三、Streaming-Connectors"><a href="#三、Streaming-Connectors" class="headerlink" title="三、Streaming Connectors"></a>三、Streaming Connectors</h2><h3 id="3-1-内置连接器"><a href="#3-1-内置连接器" class="headerlink" title="3.1 内置连接器"></a>3.1 内置连接器</h3><p>除了自定义数据源外， Flink 还内置了多种连接器，用于满足大多数的数据收集场景。当前内置连接器的支持情况如下：</p><ul><li>Apache Kafka (支持 source 和 sink)</li><li>Apache Cassandra (sink)</li><li>Amazon Kinesis Streams (source/sink)</li><li>Elasticsearch (sink)</li><li>Hadoop FileSystem (sink)</li><li>RabbitMQ (source/sink)</li><li>Apache NiFi (source/sink)</li><li>Twitter Streaming API (source)</li><li>Google PubSub (source/sink)</li></ul><p>除了上述的连接器外，你还可以通过 Apache Bahir 的连接器扩展 Flink。Apache Bahir 旨在为分布式数据分析系统 (如 Spark，Flink) 等提供功能上的扩展，当前其支持的与 Flink 相关的连接器如下：</p><ul><li>Apache ActiveMQ (source/sink)</li><li>Apache Flume (sink)</li><li>Redis (sink)</li><li>Akka (sink)</li><li>Netty (source)</li></ul><p>随着 Flink 的不断发展，可以预见到其会支持越来越多类型的连接器，关于连接器的后续发展情况，可以查看其官方文档：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/connectors/index.html" target="_blank" rel="noopener">Streaming Connectors</a> 。在所有 DataSource 连接器中，使用的广泛的就是 Kafka，所以这里我们以其为例，来介绍 Connectors 的整合步骤。</p><h3 id="3-2-整合-Kakfa"><a href="#3-2-整合-Kakfa" class="headerlink" title="3.2 整合 Kakfa"></a>3.2 整合 Kakfa</h3><h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1. 导入依赖"></a>1. 导入依赖</h4><p>整合 Kafka 时，一定要注意所使用的 Kafka 的版本，不同版本间所需的 Maven 依赖和开发时所调用的类均不相同，具体如下：</p><table><thead><tr><th align="left">Maven 依赖</th><th align="left">Flink 版本</th><th align="left">Consumer and Producer 类的名称</th><th align="left">Kafka 版本</th></tr></thead><tbody><tr><td align="left">flink-connector-kafka-0.8_2.11</td><td align="left">1.0.0 +</td><td align="left">FlinkKafkaConsumer08 <br>FlinkKafkaProducer08</td><td align="left">0.8.x</td></tr><tr><td align="left">flink-connector-kafka-0.9_2.11</td><td align="left">1.0.0 +</td><td align="left">FlinkKafkaConsumer09<br> FlinkKafkaProducer09</td><td align="left">0.9.x</td></tr><tr><td align="left">flink-connector-kafka-0.10_2.11</td><td align="left">1.2.0 +</td><td align="left">FlinkKafkaConsumer010 <br>FlinkKafkaProducer010</td><td align="left">0.10.x</td></tr><tr><td align="left">flink-connector-kafka-0.11_2.11</td><td align="left">1.4.0 +</td><td align="left">FlinkKafkaConsumer011 <br>FlinkKafkaProducer011</td><td align="left">0.11.x</td></tr><tr><td align="left">flink-connector-kafka_2.11</td><td align="left">1.7.0 +</td><td align="left">FlinkKafkaConsumer <br>FlinkKafkaProducer</td><td align="left">&gt;= 1.0.0</td></tr></tbody></table><p>这里我使用的 Kafka 版本为 kafka_2.12-2.2.0，添加的依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-代码开发"><a href="#2-代码开发" class="headerlink" title="2. 代码开发"></a>2. 代码开发</h4><p>这里以最简单的场景为例，接收 Kafka 上的数据并打印，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.setProperty(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">    properties.setProperty(<span class="string">"group.id"</span>, <span class="string">"consumer-group"</span>);</span><br><span class="line">    properties.setProperty(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">    properties.setProperty(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">    properties.setProperty(<span class="string">"auto.offset.reset"</span>, <span class="string">"latest"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件读取数据</span></span><br><span class="line">    DataStream&lt;String&gt; dataStream = env.addSource( <span class="keyword">new</span> FlinkKafkaConsumer011&lt;String&gt;(<span class="string">"sensor"</span>, <span class="keyword">new</span> SimpleStringSchema(), properties));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印输出</span></span><br><span class="line">    dataStream.print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-整合测试"><a href="#3-3-整合测试" class="headerlink" title="3.3 整合测试"></a>3.3 整合测试</h3><h4 id="1-启动-Kakfa"><a href="#1-启动-Kakfa" class="headerlink" title="1. 启动 Kakfa"></a>1. 启动 Kakfa</h4><p>Kafka 的运行依赖于 zookeeper，需要预先启动，可以启动 Kafka 内置的 zookeeper，也可以启动自己安装的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> zookeeper启动命令</span></span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 内置zookeeper启动命令</span></span><br><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></td></tr></table></figure><p>启动单节点 kafka 用于测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bin/kafka-server-start.sh config/server.properties</span></span><br></pre></td></tr></table></figure><h4 id="2-创建-Topic"><a href="#2-创建-Topic" class="headerlink" title="2. 创建 Topic"></a>2. 创建 Topic</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建用于测试主题</span></span><br><span class="line">bin/kafka-topics.sh --create \</span><br><span class="line">                    --bootstrap-server hadoop001:9092 \</span><br><span class="line">                    --replication-factor 1 \</span><br><span class="line">                    --partitions 1  \</span><br><span class="line">                    --topic flink-stream-in-topic</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有主题</span></span><br><span class="line"> bin/kafka-topics.sh --list --bootstrap-server hadoop001:9092</span><br></pre></td></tr></table></figure><h4 id="3-启动-Producer"><a href="#3-启动-Producer" class="headerlink" title="3. 启动 Producer"></a>3. 启动 Producer</h4><p>这里 启动一个 Kafka 生产者，用于发送测试数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list hadoop001:9092 --topic flink-stream-in-topic</span><br></pre></td></tr></table></figure><h4 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4. 测试结果"></a>4. 测试结果</h4><p>在 Producer 上输入任意测试数据，之后观察程序控制台的输出：</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-kafka-datasource-producer.png"> </div><p>程序控制台的输出如下：</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-kafka-datasource-console.png"> </div><p>可以看到已经成功接收并打印出相关的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sink的概念</title>
      <link href="/2021/01/08/Sink%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/01/08/Sink%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p><img src="https://upload-images.jianshu.io/upload_images/2143704-208990a509ce4657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p><h2 id="一、Data-Sinks"><a href="#一、Data-Sinks" class="headerlink" title="一、Data Sinks"></a>一、Data Sinks</h2><p>在使用 Flink 进行数据处理时，数据经 Data Source 流入，然后通过系列 Transformations 的转化，最终可以通过 Sink 将计算结果进行输出，Flink Data Sinks 就是用于定义数据流最终的输出位置。Flink 提供了几个较为简单的 Sink API 用于日常的开发，具体如下：</p><h3 id="1-1-writeAsText"><a href="#1-1-writeAsText" class="headerlink" title="1.1 writeAsText"></a>1.1 writeAsText</h3><p><code>writeAsText</code> 用于将计算结果以文本的方式并行地写入到指定文件夹下，除了路径参数是必选外，该方法还可以通过指定第二个参数来定义输出模式，它有以下两个可选值：</p><ul><li><strong>WriteMode.NO_OVERWRITE</strong>：当指定路径上不存在任何文件时，才执行写出操作；</li><li><strong>WriteMode.OVERWRITE</strong>：不论指定路径上是否存在文件，都执行写出操作；如果原来已有文件，则进行覆盖。</li></ul><p>使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamSource.writeAsText(<span class="string">"D:\\out"</span>, FileSystem.WriteMode.OVERWRITE);</span><br></pre></td></tr></table></figure><p>以上写出是以并行的方式写出到多个文件，如果想要将输出结果全部写出到一个文件，需要设置其并行度为 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamSource.writeAsText(<span class="string">"D:\\out"</span>, FileSystem.WriteMode.OVERWRITE).setParallelism(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="1-2-writeAsCsv"><a href="#1-2-writeAsCsv" class="headerlink" title="1.2 writeAsCsv"></a>1.2 writeAsCsv</h3><p><code>writeAsCsv</code> 用于将计算结果以 CSV 的文件格式写出到指定目录，除了路径参数是必选外，该方法还支持传入输出模式，行分隔符，和字段分隔符三个额外的参数，其方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeAsCsv(String path, WriteMode writeMode, String rowDelimiter, String fieldDelimiter)</span><br></pre></td></tr></table></figure><h3 id="1-3-print-printToErr"><a href="#1-3-print-printToErr" class="headerlink" title="1.3 print \ printToErr"></a>1.3 print \ printToErr</h3><p><code>print \ printToErr</code> 是测试当中最常用的方式，用于将计算结果以标准输出流或错误输出流的方式打印到控制台上。</p><h3 id="1-4-writeUsingOutputFormat"><a href="#1-4-writeUsingOutputFormat" class="headerlink" title="1.4 writeUsingOutputFormat"></a>1.4 writeUsingOutputFormat</h3><p>采用自定义的输出格式将计算结果写出，上面介绍的 <code>writeAsText</code> 和 <code>writeAsCsv</code> 其底层调用的都是该方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DataStreamSink&lt;T&gt; <span class="title">writeAsText</span><span class="params">(String path, WriteMode writeMode)</span> </span>&#123;</span><br><span class="line">    TextOutputFormat&lt;T&gt; tof = <span class="keyword">new</span> TextOutputFormat&lt;&gt;(<span class="keyword">new</span> Path(path));</span><br><span class="line">    tof.setWriteMode(writeMode);</span><br><span class="line">    <span class="keyword">return</span> writeUsingOutputFormat(tof);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-writeToSocket"><a href="#1-5-writeToSocket" class="headerlink" title="1.5 writeToSocket"></a>1.5 writeToSocket</h3><p><code>writeToSocket</code> 用于将计算结果以指定的格式写出到 Socket 中，使用示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamSource.writeToSocket("192.168.0.226", 9999, new SimpleStringSchema());</span><br></pre></td></tr></table></figure><h2 id="二、Streaming-Connectors"><a href="#二、Streaming-Connectors" class="headerlink" title="二、Streaming Connectors"></a>二、Streaming Connectors</h2><p>除了上述 API 外，Flink 中还内置了系列的 Connectors 连接器，用于将计算结果输入到常用的存储系统或者消息中间件中，具体如下：</p><ul><li>Apache Kafka (支持 source 和 sink)</li><li>Apache Cassandra (sink)</li><li>Amazon Kinesis Streams (source/sink)</li><li>Elasticsearch (sink)</li><li>Hadoop FileSystem (sink)</li><li>RabbitMQ (source/sink)</li><li>Apache NiFi (source/sink)</li><li>Google PubSub (source/sink)</li></ul><p>除了内置的连接器外，你还可以通过 Apache Bahir 的连接器扩展 Flink。Apache Bahir 旨在为分布式数据分析系统 (如 Spark，Flink) 等提供功能上的扩展，当前其支持的与 Flink Sink 相关的连接器如下：</p><ul><li>Apache ActiveMQ (source/sink)</li><li>Apache Flume (sink)</li><li>Redis (sink)</li><li>Akka (sink)</li></ul><p>这里接着在 Data Sources 章节介绍的整合 Kafka Source 的基础上，将 Kafka Sink 也一并进行整合，具体步骤如下。</p><h2 id="三、整合-Kafka-Sink"><a href="#三、整合-Kafka-Sink" class="headerlink" title="三、整合 Kafka Sink"></a>三、整合 Kafka Sink</h2><h3 id="3-1-addSink"><a href="#3-1-addSink" class="headerlink" title="3.1 addSink"></a>3.1 addSink</h3><p>Flink 提供了 addSink 方法用来调用自定义的 Sink 或者第三方的连接器，想要将计算结果写出到 Kafka，需要使用该方法来调用 Kafka 的生产者 FlinkKafkaProducer，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.指定Kafka的相关配置属性</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.setProperty(<span class="string">"bootstrap.servers"</span>, <span class="string">"192.168.200.0:9092"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.接收Kafka上的数据</span></span><br><span class="line">DataStream&lt;String&gt; stream = env</span><br><span class="line">    .addSource(<span class="keyword">new</span> FlinkKafkaConsumer&lt;&gt;(<span class="string">"flink-stream-in-topic"</span>, <span class="keyword">new</span> SimpleStringSchema(), properties));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.定义计算结果到 Kafka ProducerRecord 的转换</span></span><br><span class="line">KafkaSerializationSchema&lt;String&gt; kafkaSerializationSchema = <span class="keyword">new</span> KafkaSerializationSchema&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProducerRecord&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; serialize(String element, <span class="meta">@Nullable</span> Long timestamp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"flink-stream-out-topic"</span>, element.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 4. 定义Flink Kafka生产者</span></span><br><span class="line">FlinkKafkaProducer&lt;String&gt; kafkaProducer = <span class="keyword">new</span> FlinkKafkaProducer&lt;&gt;(<span class="string">"flink-stream-out-topic"</span>,</span><br><span class="line">                                                                    kafkaSerializationSchema,</span><br><span class="line">                                                                    properties,</span><br><span class="line">                                               FlinkKafkaProducer.Semantic.AT_LEAST_ONCE, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 5. 将接收到输入元素*2后写出到Kafka</span></span><br><span class="line">stream.map((MapFunction&lt;String, String&gt;) value -&gt; value + value).addSink(kafkaProducer);</span><br><span class="line">env.execute(<span class="string">"Flink Streaming"</span>);</span><br></pre></td></tr></table></figure><h3 id="3-2-创建输出主题"><a href="#3-2-创建输出主题" class="headerlink" title="3.2 创建输出主题"></a>3.2 创建输出主题</h3><p>创建用于输出测试的主题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create \</span><br><span class="line">                    --bootstrap-server hadoop001:9092 \</span><br><span class="line">                    --replication-factor 1 \</span><br><span class="line">                    --partitions 1  \</span><br><span class="line">                    --topic flink-stream-out-topic</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有主题</span></span><br><span class="line"> bin/kafka-topics.sh --list --bootstrap-server hadoop001:9092</span><br></pre></td></tr></table></figure><h3 id="3-3-启动消费者"><a href="#3-3-启动消费者" class="headerlink" title="3.3 启动消费者"></a>3.3 启动消费者</h3><p>启动一个 Kafka 消费者，用于查看 Flink 程序的输出情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server hadoop001:<span class="number">9092</span> --topic flink-stream-out-topic</span><br></pre></td></tr></table></figure><h3 id="3-4-测试结果"><a href="#3-4-测试结果" class="headerlink" title="3.4 测试结果"></a>3.4 测试结果</h3><p>在 Kafka 生产者上发送消息到 Flink 程序，观察 Flink 程序转换后的输出情况，具体如下：</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-kafka-producer-consumer.png"> </div><p>可以看到 Kafka 生成者发出的数据已经被 Flink 程序正常接收到，并经过转换后又输出到 Kafka 对应的 Topic 上。</p><h2 id="四、自定义-Sink"><a href="#四、自定义-Sink" class="headerlink" title="四、自定义 Sink"></a>四、自定义 Sink</h2><p>除了使用内置的第三方连接器外，Flink 还支持使用自定义的 Sink 来满足多样化的输出需求。想要实现自定义的 Sink ，需要直接或者间接实现 SinkFunction 接口。通常情况下，我们都是实现其抽象类 RichSinkFunction，相比于 SinkFunction ，其提供了更多的与生命周期相关的方法。两者间的关系如下：</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-richsink.png"> </div><p>这里我们以自定义一个 FlinkToMySQLSink 为例，将计算结果写出到 MySQL 数据库中，具体步骤如下：</p><h3 id="4-1-导入依赖"><a href="#4-1-导入依赖" class="headerlink" title="4.1 导入依赖"></a>4.1 导入依赖</h3><p>首先需要导入 MySQL 相关的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-自定义-Sink"><a href="#4-2-自定义-Sink" class="headerlink" title="4.2 自定义 Sink"></a>4.2 自定义 Sink</h3><p>继承自 RichSinkFunction，实现自定义的 Sink ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkToMySQLSink</span> <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PreparedStatement stmt;</span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://192.168.0.229:3306/employees"</span> +</span><br><span class="line">                                           <span class="string">"?characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false"</span>, </span><br><span class="line">                                           <span class="string">"root"</span>, </span><br><span class="line">                                           <span class="string">"123456"</span>);</span><br><span class="line">        String sql = <span class="string">"insert into emp(name, age, birthday) values(?, ?, ?)"</span>;</span><br><span class="line">        stmt = conn.prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Employee value, Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        stmt.setString(<span class="number">1</span>, value.getName());</span><br><span class="line">        stmt.setInt(<span class="number">2</span>, value.getAge());</span><br><span class="line">        stmt.setDate(<span class="number">3</span>, value.getBirthday());</span><br><span class="line">        stmt.executeUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-使用自定义-Sink"><a href="#4-3-使用自定义-Sink" class="headerlink" title="4.3 使用自定义 Sink"></a>4.3 使用自定义 Sink</h3><p>想要使用自定义的 Sink，同样是需要调用 addSink 方法，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">Date date = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">DataStreamSource&lt;Employee&gt; streamSource = env.fromElements(</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"hei"</span>, <span class="number">10</span>, date),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"bai"</span>, <span class="number">20</span>, date),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"ying"</span>, <span class="number">30</span>, date));</span><br><span class="line">streamSource.addSink(<span class="keyword">new</span> FlinkToMySQLSink());</span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure><h3 id="4-4-测试结果"><a href="#4-4-测试结果" class="headerlink" title="4.4 测试结果"></a>4.4 测试结果</h3><p>启动程序，观察数据库写入情况：</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-mysql-sink.png"> </div><p>数据库成功写入，代表自定义 Sink 整合成功。</p><blockquote><p>以上所有用例的源码见本仓库：[flink-kafka-integration](</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Flink概念</title>
      <link href="/2021/01/05/Flink%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/01/05/Flink%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><ul><li><h2 id="一、Flink-简介"><a href="#一、Flink-简介" class="headerlink" title="一、Flink 简介"></a>一、Flink 简介</h2><p>简单来说，Flink 是一个分布式的流处理框架，它能够对有界和无界的数据流进行高效的处理。Flink 的核心是流处理，当然它也能支持批处理，Flink 将批处理看成是流处理的一种特殊情况，即数据流是有明确界限的。这和 Spark Streaming 的思想是完全相反的，Spark Streaming 的核心是批处理，它将流处理看成是批处理的一种特殊情况， 即把数据流进行极小粒度的拆分，拆分为多个微批处理。</p><p>Flink 有界数据流和无界数据流：</p><div align="center"> <img width="600px" src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-bounded-unbounded.png"> </div></li></ul><p>  Spark Streaming 数据流的拆分：</p>  <div align="center"> <img width="600px" src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/streaming-flow.png"> </div><h2 id="二、Flink-核心架构"><a href="#二、Flink-核心架构" class="headerlink" title="二、Flink 核心架构"></a>二、Flink 核心架构</h2><p>  Flink 采用分层的架构设计，从而保证各层在功能和职责上的清晰。如下图所示，由上而下分别是 API &amp; Libraries 层、Runtime 核心层以及物理部署层：</p>  <div align="center"> <img width="600px" src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-stack.png"> </div><h3 id="2-1-API-amp-Libraries-层"><a href="#2-1-API-amp-Libraries-层" class="headerlink" title="2.1 API &amp; Libraries 层"></a>2.1 API &amp; Libraries 层</h3><p>  这一层主要提供了编程 API 和 顶层类库：</p><ul><li><p>编程 API : 用于进行流处理的 DataStream API 和用于进行批处理的 DataSet API；</p></li><li><p>顶层类库：包括用于复杂事件处理的 CEP 库；用于结构化数据查询的 SQL &amp; Table 库，以及基于批处理的机器学习库 FlinkML 和 图形处理库 Gelly。</p><h3 id="2-2-Runtime-核心层"><a href="#2-2-Runtime-核心层" class="headerlink" title="2.2 Runtime 核心层"></a>2.2 Runtime 核心层</h3><p>这一层是 Flink 分布式计算框架的核心实现层，包括作业转换，任务调度，资源分配，任务执行等功能，基于这一层的实现，可以在流式引擎下同时运行流处理程序和批处理程序。</p><h3 id="2-3-物理部署层"><a href="#2-3-物理部署层" class="headerlink" title="2.3 物理部署层"></a>2.3 物理部署层</h3><p>Flink 的物理部署层，用于支持在不同平台上部署运行 Flink 应用。</p><h2 id="三、Flink-分层-API"><a href="#三、Flink-分层-API" class="headerlink" title="三、Flink 分层 API"></a>三、Flink 分层 API</h2><p>在上面介绍的 API &amp; Libraries 这一层，Flink 又进行了更为具体的划分。具体如下：</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-api-stack.png"> </div></li></ul><p>  按照如上的层次结构，API 的一致性由下至上依次递增，接口的表现能力由下至上依次递减，各层的核心功能如下：</p><h3 id="3-1-SQL-amp-Table-API"><a href="#3-1-SQL-amp-Table-API" class="headerlink" title="3.1 SQL &amp; Table API"></a>3.1 SQL &amp; Table API</h3><p>  SQL &amp; Table API 同时适用于批处理和流处理，这意味着你可以对有界数据流和无界数据流以相同的语义进行查询，并产生相同的结果。除了基本查询外， 它还支持自定义的标量函数，聚合函数以及表值函数，可以满足多样化的查询需求。 </p><h3 id="3-2-DataStream-amp-DataSet-API"><a href="#3-2-DataStream-amp-DataSet-API" class="headerlink" title="3.2 DataStream &amp; DataSet API"></a>3.2 DataStream &amp; DataSet API</h3><p>  DataStream &amp;  DataSet API 是 Flink 数据处理的核心 API，支持使用 Java 语言或 Scala 语言进行调用，提供了数据读取，数据转换和数据输出等一系列常用操作的封装。</p><h3 id="3-3-Stateful-Stream-Processing"><a href="#3-3-Stateful-Stream-Processing" class="headerlink" title="3.3 Stateful Stream Processing"></a>3.3 Stateful Stream Processing</h3><p>  Stateful Stream Processing 是最低级别的抽象，它通过 Process Function 函数内嵌到 DataStream API 中。 Process Function 是 Flink 提供的最底层 API，具有最大的灵活性，允许开发者对于时间和状态进行细粒度的控制。</p><h2 id="四、Flink-集群架构"><a href="#四、Flink-集群架构" class="headerlink" title="四、Flink 集群架构"></a>四、Flink 集群架构</h2><h3 id="4-1-核心组件"><a href="#4-1-核心组件" class="headerlink" title="4.1  核心组件"></a>4.1  核心组件</h3><p>  按照上面的介绍，Flink 核心架构的第二层是 Runtime 层， 该层采用标准的 Master - Slave 结构， 其中，Master 部分又包含了三个核心组件：Dispatcher、ResourceManager 和 JobManager，而 Slave 则主要是 TaskManager 进程。它们的功能分别如下：</p><ul><li><p><strong>JobManagers</strong> (也称为 <em>masters</em>) ：JobManagers 接收由 Dispatcher 传递过来的执行程序，该执行程序包含了作业图 (JobGraph)，逻辑数据流图 (logical dataflow graph) 及其所有的 classes 文件以及第三方类库 (libraries) 等等 。紧接着 JobManagers 会将 JobGraph 转换为执行图 (ExecutionGraph)，然后向 ResourceManager 申请资源来执行该任务，一旦申请到资源，就将执行图分发给对应的 TaskManagers 。因此每个作业 (Job) 至少有一个 JobManager；高可用部署下可以有多个 JobManagers，其中一个作为 <em>leader*，其余的则处于 *standby</em> 状态。</p></li><li><p><strong>TaskManagers</strong> (也称为 <em>workers</em>) : TaskManagers 负责实际的子任务 (subtasks) 的执行，每个 TaskManagers 都拥有一定数量的 slots。Slot 是一组固定大小的资源的合集 (如计算能力，存储空间)。TaskManagers 启动后，会将其所拥有的 slots 注册到 ResourceManager 上，由 ResourceManager 进行统一管理。</p></li><li><p><strong>Dispatcher</strong>：负责接收客户端提交的执行程序，并传递给 JobManager 。除此之外，它还提供了一个 WEB UI 界面，用于监控作业的执行情况。</p></li><li><p><strong>ResourceManager</strong> ：负责管理 slots 并协调集群资源。ResourceManager 接收来自 JobManager 的资源请求，并将存在空闲 slots 的 TaskManagers 分配给 JobManager 执行任务。Flink 基于不同的部署平台，如 YARN , Mesos，K8s 等提供了不同的资源管理器，当 TaskManagers 没有足够的 slots 来执行任务时，它会向第三方平台发起会话来请求额外的资源。</p><div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-application-submission.png"> </div></li></ul><h3 id="4-2-Task-amp-SubTask"><a href="#4-2-Task-amp-SubTask" class="headerlink" title="4.2  Task &amp; SubTask"></a>4.2  Task &amp; SubTask</h3><p>  上面我们提到：TaskManagers 实际执行的是 SubTask，而不是 Task，这里解释一下两者的区别：</p><p>  在执行分布式计算时，Flink 将可以链接的操作 (operators) 链接到一起，这就是 Task。之所以这样做， 是为了减少线程间切换和缓冲而导致的开销，在降低延迟的同时可以提高整体的吞吐量。 但不是所有的 operator 都可以被链接，如下 keyBy 等操作会导致网络 shuffle 和重分区，因此其就不能被链接，只能被单独作为一个 Task。  简单来说，一个 Task 就是一个可以链接的最小的操作链 (Operator Chains) 。如下图，source 和 map 算子被链接到一块，因此整个作业就只有三个 Task：</p>  <div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-task-subtask.png"> </div><p>  解释完 Task ，我们在解释一下什么是 SubTask，其准确的翻译是： <em>A subtask is one parallel slice of a task</em>，即一个 Task 可以按照其并行度拆分为多个 SubTask。如上图，source &amp; map 具有两个并行度，KeyBy 具有两个并行度，Sink 具有一个并行度，因此整个虽然只有 3 个 Task，但是却有 5 个 SubTask。Jobmanager 负责定义和拆分这些 SubTask，并将其交给 Taskmanagers 来执行，每个 SubTask 都是一个单独的线程。</p><h3 id="4-3-资源管理"><a href="#4-3-资源管理" class="headerlink" title="4.3  资源管理"></a>4.3  资源管理</h3><p>  理解了 SubTasks ，我们再来看看其与 Slots 的对应情况。一种可能的分配情况如下：</p>  <div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-tasks-slots.png"> </div><p>  这时每个 SubTask 线程运行在一个独立的 TaskSlot， 它们共享所属的 TaskManager 进程的TCP 连接（通过多路复用技术）和心跳信息 (heartbeat messages)，从而可以降低整体的性能开销。此时看似是最好的情况，但是每个操作需要的资源都是不尽相同的，这里假设该作业 keyBy 操作所需资源的数量比 Sink 多很多 ，那么此时 Sink 所在 Slot 的资源就没有得到有效的利用。</p><p>  基于这个原因，Flink 允许多个 subtasks 共享 slots，即使它们是不同 tasks 的 subtasks，但只要它们来自同一个 Job 就可以。假设上面 souce &amp; map 和 keyBy 的并行度调整为 6，而 Slot 的数量不变，此时情况如下：</p>  <div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-subtask-slots.png"> </div><p>  可以看到一个 Task Slot 中运行了多个 SubTask 子任务，此时每个子任务仍然在一个独立的线程中执行，只不过共享一组 Sot 资源而已。那么 Flink 到底如何确定一个 Job 至少需要多少个 Slot 呢？Flink 对于这个问题的处理很简单，默认情况一个 Job 所需要的 Slot 的数量就等于其 Operation 操作的最高并行度。如下， A，B，D 操作的并行度为 4，而 C，E 操作的并行度为 2，那么此时整个 Job 就需要至少四个 Slots 来完成。通过这个机制，Flink 就可以不必去关心一个 Job 到底会被拆分为多少个 Tasks 和 SubTasks。</p>  <div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-task-parallelism.png"> </div><h3 id="4-4-组件通讯"><a href="#4-4-组件通讯" class="headerlink" title="4.4 组件通讯"></a>4.4 组件通讯</h3><p>  Flink 的所有组件都基于 Actor System 来进行通讯。Actor system是多种角色的 actor 的容器，它提供调度，配置，日志记录等多种服务，并包含一个可以启动所有 actor 的线程池，如果 actor 是本地的，则消息通过共享内存进行共享，但如果 actor 是远程的，则通过 RPC 的调用来传递消息。</p>  <div align="center"> <img src="https://gitee.com/heibaiying/BigData-Notes/raw/master/pictures/flink-process.png"> </div><h2 id="五、Flink-的优点"><a href="#五、Flink-的优点" class="headerlink" title="五、Flink 的优点"></a>五、Flink 的优点</h2><p>  最后基于上面的介绍，来总结一下 Flink 的优点：</p><ul><li>Flink 是基于事件驱动 (Event-driven) 的应用，能够同时支持流处理和批处理；</li><li>基于内存的计算，能够保证高吞吐和低延迟，具有优越的性能表现；</li><li>支持精确一次 (Exactly-once) 语意，能够完美地保证一致性和正确性；</li><li>分层 API ，能够满足各个层次的开发需求；</li><li>支持高可用配置，支持保存点机制，能够提供安全性和稳定性上的保证；</li><li>具有横向扩展架构，能够按照用户的需求进行动态扩容；</li><li>活跃度极高的社区和完善的生态圈的支持。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字节</title>
      <link href="/2020/12/25/%E5%AD%97%E8%8A%82/"/>
      <url>/2020/12/25/%E5%AD%97%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p>java中Object类中有哪些方法，他们的作用分别是什么？</p><p>java中的多态的含义？</p><p>java常用的会抛出哪些异常类型？</p><p>代理模式的API</p><p>集合</p><p>HashMap多线程下会有什么问题？</p><p>基本数据类型</p><p>装箱拆箱？（-128到127）</p><p>说说String、StringBuilder和StringBuffer吧</p><p>创建一个String对象，内部怎么说？（字符串池那一套）</p><p>StringBuffer <a href="https://www.nowcoder.com/jump/super-jump/word?word=源码" target="_blank" rel="noopener">源码</a>如何实现 ？</p><p>String s = new String(“abc”) 创建了几个 String 对象</p><p>a=a+b 与 a+=b 有什么区别吗</p><p>switch 中能否使用 String 做参数 </p><p> 什么是编译期常量? 使用它有什么风险 </p><p><a href="https://blog.csdn.net/qq_34802416/article/details/83548369?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control" target="_blank" rel="noopener">https://blog.csdn.net/qq_34802416/article/details/83548369?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control</a></p><p> 为什么Java 中只有值传递  </p><p> Static Nested Class 和 Inner Class 有什么不同</p><p>构造器 Constructor 是否可被重写</p><p>final，finalize() 和 finally{} 的区别</p><p><a href="https://blog.csdn.net/qq_39135287/article/details/78455525" target="_blank" rel="noopener">https://blog.csdn.net/qq_39135287/article/details/78455525</a></p><p>深拷贝和浅拷贝的区别是什么</p><p>快速失败 和 安全失败 的区别是什么</p><p>Iterator 和 ListIterator 的区别是什么</p><p>将 Java 代码编译成字节码的过程</p><p>Java 是解释执行还是编译执行，Java 为什么采用这种执行模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">解释运行： 一边对程序进行翻译，翻译成计算机可以执行的指令，一边交给计算机执行，翻译一句执行一句。</span><br><span class="line"></span><br><span class="line">编译运行： 对整个程序先翻译成计算机可以理解的指令，然后计算机可以直接执行。</span><br><span class="line">1. Java代码经过javac编译成class文件（字节码）</span><br><span class="line">2. class（字节码）文件经过JVM编译成机器码进行解释执行**（解释执行）**</span><br><span class="line">   1. 对于热点代码，JIT（JustInTime）编译器会在运行时将其编译为机器码执行**（编译运行）**</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">编译型语言，执行速度快、效率高；依靠编译器、跨平台性差。</span><br><span class="line">解释型语言，执行速度慢、效率低；依靠解释器、跨平台性好。</span><br><span class="line"></span><br><span class="line">编译型的语言包括：C、C++、Delphi、Pascal、Fortran</span><br><span class="line">Python是一门解释型语言</span><br></pre></td></tr></table></figure><p>Arrays.sort()使用的什么排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在数组的数量小于47的情况下使用插入排序,在大于或等于47或少于286会进入快速排序（双轴快排）</span><br><span class="line">大于286采用归并排序</span><br></pre></td></tr></table></figure><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>线程池的七大参数<br>核心线程数 和 最大线程数的作用和使用过程中的变化</p><p>volatile</p><p> 原子类的实现方式</p><p>锁的AQS的实现方式</p><p>阻塞队列的Java API有那些</p><p>JUC包下的锁以及用法(CyclicBrarry,CondownLatch,ReentrantLock,信号量以及其用法) </p><p> Synchronized底层实现(偏向锁,轻量级锁,重量级锁具体实现,包括重量级锁中cxq队列以及EntryList,WaitSet) </p><p> Synchronized与ReentrantLock区别(可打断,非阻塞获取,Condition)</p><p>ThreadLocal的实现(ThreadLocalMap,WeakRefence的使用,内存泄漏问题,ThreadLocal的启发式清理以及段落式清理</p><p>两个线程交替打印</p><p>保证线程安全</p><p>线程间是如何通信的</p><p>如何停止一个正在运行的线程 ？</p><p>常见的原子类有哪些，它有什么不足 ？如何进行优化 ？</p><p>什么是公平锁，什么是非公平锁？有哪些常见的公平锁和非公平锁？为什么说synchronized 是非公平锁？ </p><p> 什么是乐观锁，什么是悲观锁？为什么说 synchronized 是悲观锁？乐观锁的实现原理是什么？乐观锁一定好吗？</p><p>Condition 接口及其实现原理 ？</p><p>什么是 Callable ？ 什么是 Future ？</p><p>线程池是自己创建的吗？</p><p>线程池七大参数都是什么？</p><p>各个参数都是怎样设置的？</p><p>线程池核心线程数和最大线程数为什么要设置成这样？</p><p>线程池池化技术<br>何时创建核心线程，何时创建最大线程<br>线程池拒绝策略</p><p>由RPC<a href="https://www.nowcoder.com/jump/super-jump/word?word=项目" target="_blank" rel="noopener">项目</a>问到了序列化反序列化，问到了对象有一个属性是对象引用，怎么序列化。</p><p>可重入锁和synchronized区别</p><p>volatile为什么使用缓存行</p><p>volatile对于64位缓存行的优化</p><p>手撕生产者、消费者模型。10个生产者，10个消费者，队列容量为30个</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>JMM内存模型(主要说的工作内存以及共享内存,volatile关键字的实现,按需禁用缓存以及编译优化,Happens-before原则) </p><p> JVM运行时数据区(堆栈方法区,方法区为什么要从永久代改为元空间)</p><p>类加载机制说说吧</p><p>说说双亲委派机制吧</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>sql入侵？如何防止sql侵入</p><p>http请求行的各个字段及含义，发生重定向时返回的状态码是多少？正常是多少？</p><p>http和https的区别？</p><p>说一下应用层常用的几个协议？</p><p>浏览器输入URL之后的过程？</p><p>域名投毒</p><p>计算机网络的7层模型</p><p>Http状态码中的302和401是什么用的</p><p>证书在ssl过程中的作用</p><p>网络通道非常拥塞时，TCP如何保证数据可以正确到达对方</p><p>三次握手的过程中有哪些攻击方式，举例子</p><p>应用程序如何将数据从网卡上面读取到进程当中<br>同步IO和异步IO<br>reactor模型<br>IO多路复用<br> Linux中有那些多路复用方式</p><p>计算机在设置ip的时候会设置哪些参数(ip地址,子网掩码,网关地址)</p><p>说说子网掩码以及网关的作用</p><p>301，302有什么区别</p><p>三次握手</p><p> 那为什么它们的seq需要不同的seq呢，我可以直接在seq上加个1，把收到的seq置为相同的不久行了吗，为什么我服务器端要单独发送自己的seq呢 </p><p> 为什么建立连接需要三次握手，断开连接需要四次挥手 </p><p> 为什么会有一个半关闭的状态，明明客户端已经要求断开连接了呀，你还向客户端发送报文（不知道，瞎猜数据没传输完） </p><p> 这个数据没传输完指的什么，客户端请求断开连接的时候数据没有传输完吗，谁的数据没有传输完（尴尬了2分多钟） </p><p> TCP连接他有一个四元组知道吧 </p><p> ICMP这个协议他位于网络的第几层知道吧 </p><p> 那链路层的协议有哪些啊</p><p>TCP三次握手四次挥手？为什么四次挥手等待2MSL？</p><p>转发和重定向区别?</p><p>操作系统分配的进程空间是怎样的？线程能共享哪些</p><p>滑动窗口大小如何确定</p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>进程和线程的区别？</p><p>进程的几种状态，CPU如何在这几种状态中调度</p><p>操作系统为什么要设置用户态和内核态</p><p>讲一下DMA的作用</p><p>进程间的通信方式(无名管道,命名管道,共享内存,消息队列,套接字)</p><p>分别有哪些例子</p><p>协程有了解吗 ？</p><p>内存的缺页中断、页面置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a></p><p>CPU调度</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>谈谈幻读<br>幻读和脏读的区别<br>MySQL中 redo log 和 binary log 的区别和场景的使用意义</p><p>redo log 和 undo log 实现了什么功能</p><p>为什么innoDB使用B+树</p><p>mysql事务的隔离级别以及分别如何实现 以及解决什么问题</p><p>mysql索引的数据结构以及分类(B+树以及和B-树,<a href="https://www.nowcoder.com/jump/super-jump/word?word=红黑树" target="_blank" rel="noopener">红黑树</a>,<a href="https://www.nowcoder.com/jump/super-jump/word?word=二叉树" target="_blank" rel="noopener">二叉树</a>优缺点,聚集索引,非聚集索引,Hash索引的优缺点以及实现)</p><p>锁</p><p>explain 的用法，ref 代表什么意思 ？ index 代表什么意思 ？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferPool 内部的数据结构</span><br><span class="line"></span><br><span class="line">InnoDB 的页结构，有哪些常见的压缩[算法](https:&#x2F;&#x2F;www.nowcoder.com&#x2F;jump&#x2F;super-jump&#x2F;word?word&#x3D;算法)，行记录通常有包含哪些字段</span><br></pre></td></tr></table></figure><p>唯一性索引和主键索引的区别？</p><p>聚簇索引与非聚簇索引的区别？</p><p>什么是覆盖索引？</p><p>什么情况下索引会失效？</p><p>什么是最左匹配原则？</p><p>在 MySQL 中怎么给 Select 语句显示加锁呢 ？ </p><p> MVCC 机制能解决幻读问题吗？ </p><p> InnoDB 是怎么解决幻读问题的？ </p><p> 说一下 nextkey lock 的原理? </p><p> 既然在可重复读隔离级别下结合nextkey lock可以解决幻读问题，为什么还需要 S 可串行化呢？</p><p>行锁什么时候变表锁</p><p>select语句什么时候行锁变表锁</p><p>索引下推</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查到符合条件的索引-&gt;逐个回表，判断别的条件是否满足；</span><br><span class="line">索引下推：根据联合查询的其他索引做一个筛选，筛选通过的才回表查询，减少回表次数；</span><br></pre></td></tr></table></figure><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><a href="https://www.nowcoder.com/jump/super-jump/word?word=redis" target="_blank" rel="noopener">redis</a>是用来干什么的？<a href="https://www.nowcoder.com/jump/super-jump/word?word=redis" target="_blank" rel="noopener">redis</a>如何做缓存</p><p>Redis是单线程模型还是多线程模型?</p><p>Redis单线程模型为什么可以那么快(说了非阻塞IO的实现,Selector,定时任务的实现)</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>AOP解决了什么问题</p><p>说说AOP(面向切面编程,动态代理的实现jdk实现以及CGLib实现) </p><p> 说说循环依赖的实现(一级缓存缓存以及创建完成的对象,二级缓存没有创建完成,三级缓存解决被代理对象的循环依赖) </p><p> Spring中对象的生命周期(单例,多例,globl session,session,application)</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>策略模式</p><p>手写DCL</p><p>说说你用到过的设计模式(主要说了Spring里面的几个) </p><p> 简单工厂模式-&gt;BeanFactory </p><p> 策略模式 </p><p> 装饰者模式-&gt;Wapper</p><p> 单例模式(Spring的Bean默认生命周期,好处) </p><p> 模版方法模式(jdbcTemplate这种,好处)</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列说一下</p><p>sql的索引是什么，常见的索引方式，什么时候索引失效？</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>linux用户权限最大的是谁？root与普通用户之间转换的指令？</p><p>如何找到一个进程并杀死他？</p><h3 id="设计题"><a href="#设计题" class="headerlink" title="设计题"></a>设计题</h3><ul><li>100亿黑名单URL，每个64B,判断一个URL是否在黑名单中  </li><li>2GB内存在20亿整数中找到出现次数最多的数  </li><li>40亿个非负整数中找到没有出现的数  </li><li>40亿个非负整数中找到一个没有出现的数，内存限制10MB  </li><li>找到100亿个URL中重复的URL  </li><li>海量搜索词汇，找到最热TOP100词汇的方法  </li><li>40亿个无符号整数，1GB内存，找到所有出现两次的数  </li><li>10MB内存，找到40亿整数的中位数  </li><li>设计短域名系统，将长URL转化成短的URL.(<a href>知乎</a>老哥给出了答案，博客有人根据他的总结了一下，很好) </li><li>让你系统的设计一个高并发的架构，你会从哪几个方面考虑？  </li><li>一个千万级的APP，你要搞定关注和粉丝列表，你用什么来做。要求最后一个关注的在最前面。新增和取关都要比较快的反馈你怎么做？如果一个人关注了之后，服务器宕机了怎么办？  </li><li>OOD design：计费停车场  </li><li>假设有这么一个场景，有一条新闻，新闻的评论量可能很大，如何设计评论的读和写  </li><li>显示网站的用户在线数的解决思路 </li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>排序方法，并给出他们的时间复杂度？</p><p>交换俩个对象swap（Object obj1， Object obj2）{}  </p><p>快排 堆排评价（时空复杂度 最优 最差 是否稳定）</p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>还是问了RPC<a href>项目</a>，问到了注册中心怎么进行心跳检测 </p><p> 注册中心对于服务端掉线时怎么处理 </p><p> 服务端用的哪个类监听的（ServerSocket） </p><p> 自己实现的定时器是啥？ </p><p> 动态代理 </p><p> NIO</p><p>除了MD5，你还知道哪些加密<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>？</p><p>设计学生成绩系统，如何建表，如何建索引</p><p>主键和索引的区别</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节跳动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交替打印ABC</title>
      <link href="/2020/12/23/%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0ABC/"/>
      <url>/2020/12/23/%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0ABC/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B,C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。</p><h2 id="二、Synchronized同步法"><a href="#二、Synchronized同步法" class="headerlink" title="二、Synchronized同步法"></a>二、Synchronized同步法</h2><h3 id="1、基本思路"><a href="#1、基本思路" class="headerlink" title="1、基本思路"></a>1、基本思路</h3><p>使用同步块和wait、notify的方法控制三个线程的执行次序。具体方法如下：从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能进行打印操作。一个对象锁是prev，就是前一个线程所对应的对象锁，其主要作用是保证当前线程一定是在前一个线程操作完成后（即前一个线程释放了其对应的对象锁）才开始执行。还有一个锁就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁（也就前一个线程要释放其自身对象锁），然后当前线程再申请自己对象锁，两者兼备时打印。之后首先调用self.notify()唤醒下一个等待线程（注意notify不会立即释放对象锁，只有等到同步块代码执行完毕后才会释放），再调用prev.wait()立即释放prev对象锁，当前线程进入休眠，等待其他线程的notify操作再次唤醒。</p><h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><p>经博友：璐璐的宝宝的指点，原程序虽然也能完成任务，但是存在一个很大的缺陷。为了对比一下，这里保留原实现，并给出新的改进实现。<br><strong>原实现</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class ABC_Synch &#123;</span><br><span class="line">    public static class ThreadPrinter implements Runnable &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private Object prev;</span><br><span class="line">        private Object self;</span><br><span class="line"></span><br><span class="line">        private ThreadPrinter(String name, Object prev, Object self) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">            this.prev &#x3D; prev;</span><br><span class="line">            this.self &#x3D; self;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int count &#x3D; 10;</span><br><span class="line">            while (count &gt; 0) &#123;&#x2F;&#x2F; 多线程并发，不能用if，必须使用whil循环</span><br><span class="line">                synchronized (prev) &#123; &#x2F;&#x2F; 先获取 prev 锁</span><br><span class="line">                    synchronized (self) &#123;&#x2F;&#x2F; 再获取 self 锁</span><br><span class="line">                        System.out.print(name);&#x2F;&#x2F;打印</span><br><span class="line">                        count--;</span><br><span class="line"></span><br><span class="line">                        self.notifyAll();&#x2F;&#x2F; 唤醒其他线程竞争self锁，注意此时self锁并未立即释放。</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;此时执行完self的同步块，这时self锁才释放。</span><br><span class="line">                    try &#123;</span><br><span class="line">                        prev.wait(); &#x2F;&#x2F; 立即释放 prev锁，当前线程休眠，等待唤醒</span><br><span class="line">                        &#x2F;**</span><br><span class="line">                         * JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。</span><br><span class="line">                         *&#x2F;</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Object a &#x3D; new Object();</span><br><span class="line">        Object b &#x3D; new Object();</span><br><span class="line">        Object c &#x3D; new Object();</span><br><span class="line">        ThreadPrinter pa &#x3D; new ThreadPrinter(&quot;A&quot;, c, a);</span><br><span class="line">        ThreadPrinter pb &#x3D; new ThreadPrinter(&quot;B&quot;, a, b);</span><br><span class="line">        ThreadPrinter pc &#x3D; new ThreadPrinter(&quot;C&quot;, b, c);</span><br><span class="line"></span><br><span class="line">        new Thread(pa).start();</span><br><span class="line">        Thread.sleep(10);&#x2F;&#x2F;保证初始ABC的启动顺序</span><br><span class="line">        new Thread(pb).start();</span><br><span class="line">        Thread.sleep(10);</span><br><span class="line">        new Thread(pc).start();</span><br><span class="line">        Thread.sleep(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdn.net/20170817153052332" alt="这里写图片描述"><br>可以看到程序一共定义了a,b,c三个对象锁，分别对应A、B、C三个线程。A线程最先运行，A线程按顺序申请c,a对象锁，打印操作后按顺序释放a,c对象锁，并且通过notify操作唤醒线程B。线程B首先等待获取A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C。线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程必须按照A,B,C的顺序来启动，但是这种假设依赖于JVM中线程调度、执行的顺序。</p><p><strong>原实现存在的问题</strong>：<br>如果把上述代码放到eclipse上运行，可以发现程序虽然完成了交替打印ABC十次的任务，但是打印完毕后无法自动结束线程。这是为什么呢？原因就在于下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">            prev.wait(); &#x2F;&#x2F; 立即释放 prev锁，当前线程休眠，等待唤醒</span><br><span class="line">            &#x2F;**</span><br><span class="line">            * JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。</span><br><span class="line">            *&#x2F;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;12345678</span><br></pre></td></tr></table></figure><p>prev.wait(); 是释放prev锁并休眠线程，等待唤醒。在最后一次打印完毕后，因为count为0，无法进入while循环的同步代码块，自然就不会触发notifyAll操作。这样一来，执行完打印操作后，线程就一直处于休眠待唤醒状态，导致线程无法正常结束。</p><p><strong>改进实现</strong>：<br>我们找到了了问题的原因，解决起来就简单了。最直接的思路就是在最后一次打印操作时在不休眠线程的情况下释放对象锁，这可以通过notifyAll操作实现。于是改进的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class ABC_Synch &#123;</span><br><span class="line">    public static class ThreadPrinter implements Runnable &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private Object prev;</span><br><span class="line">        private Object self;</span><br><span class="line"></span><br><span class="line">        private ThreadPrinter(String name, Object prev, Object self) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">            this.prev &#x3D; prev;</span><br><span class="line">            this.self &#x3D; self;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int count &#x3D; 10;</span><br><span class="line">            while (count &gt; 0) &#123;&#x2F;&#x2F; 多线程并发，不能用if，必须使用whil循环</span><br><span class="line">                synchronized (prev) &#123; &#x2F;&#x2F; 先获取 prev 锁</span><br><span class="line">                    synchronized (self) &#123;&#x2F;&#x2F; 再获取 self 锁</span><br><span class="line">                        System.out.print(name);&#x2F;&#x2F; 打印</span><br><span class="line">                        count--;</span><br><span class="line"></span><br><span class="line">                        self.notifyAll();&#x2F;&#x2F; 唤醒其他线程竞争self锁，注意此时self锁并未立即释放。</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 此时执行完self的同步块，这时self锁才释放。</span><br><span class="line">                    try &#123;</span><br><span class="line">                        if (count &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; 如果count&#x3D;&#x3D;0,表示这是最后一次打印操作，通过notifyAll操作释放对象锁。</span><br><span class="line">                            prev.notifyAll();</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            prev.wait(); &#x2F;&#x2F; 立即释放 prev锁，当前线程休眠，等待唤醒</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Object a &#x3D; new Object();</span><br><span class="line">        Object b &#x3D; new Object();</span><br><span class="line">        Object c &#x3D; new Object();</span><br><span class="line">        ThreadPrinter pa &#x3D; new ThreadPrinter(&quot;A&quot;, c, a);</span><br><span class="line">        ThreadPrinter pb &#x3D; new ThreadPrinter(&quot;B&quot;, a, b);</span><br><span class="line">        ThreadPrinter pc &#x3D; new ThreadPrinter(&quot;C&quot;, b, c);</span><br><span class="line"></span><br><span class="line">        new Thread(pa).start();</span><br><span class="line">        Thread.sleep(10);&#x2F;&#x2F; 保证初始ABC的启动顺序</span><br><span class="line">        new Thread(pb).start();</span><br><span class="line">        Thread.sleep(10);</span><br><span class="line">        new Thread(pc).start();</span><br><span class="line">        Thread.sleep(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354</span><br></pre></td></tr></table></figure><p>上述代码放到eclipse上运行，就可以自动结束线程了。从这里，我们也可以得出wait和notify操作的异同：</p><ul><li>wait() 与 notify/notifyAll() 是Object类的方法，在执行两个方法时，要先获得锁。</li><li>当线程执行wait()时，会把当前的锁释放，然后让出CPU，进入等待状态。</li><li>当执行notify/notifyAll方法时，会唤醒一个处于等待该 对象锁 的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁。</li></ul><p>从这里可以看出，notify/notifyAll()执行后，并不立即释放锁，而是要等到执行完临界区中代码后，再释放。所以在实际编程中，我们应该尽量在线程调用notify/notifyAll()后，立即退出临界区。即不要在notify/notifyAll()后面再写一些耗时的代码。</p><h2 id="二、Lock锁方法"><a href="#二、Lock锁方法" class="headerlink" title="二、Lock锁方法"></a>二、Lock锁方法</h2><h3 id="1、基本思路-1"><a href="#1、基本思路-1" class="headerlink" title="1、基本思路"></a>1、基本思路</h3><p>通过ReentrantLock我们可以很方便的进行显式的锁操作，即获取锁和释放锁，对于同一个对象锁而言，统一时刻只可能有一个线程拿到了这个锁，此时其他线程通过lock.lock()来获取对象锁时都会被阻塞，直到这个线程通过lock.unlock()操作释放这个锁后，其他线程才能拿到这个锁。</p><h3 id="2、代码-1"><a href="#2、代码-1" class="headerlink" title="2、代码"></a>2、代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ABC_Lock &#123;</span><br><span class="line">    private static Lock lock &#x3D; new ReentrantLock();&#x2F;&#x2F; 通过JDK5中的Lock锁来保证线程的访问的互斥</span><br><span class="line">    private static int state &#x3D; 0;&#x2F;&#x2F;通过state的值来确定是否打印</span><br><span class="line"></span><br><span class="line">    static class ThreadA extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10;) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    while (state % 3 &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; 多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒</span><br><span class="line">                        System.out.print(&quot;A&quot;);</span><br><span class="line">                        state++;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();&#x2F;&#x2F; unlock()操作必须放在finally块中</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ThreadB extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10;) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    while (state % 3 &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F; 多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒</span><br><span class="line">                        System.out.print(&quot;B&quot;);</span><br><span class="line">                        state++;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();&#x2F;&#x2F; unlock()操作必须放在finally块中</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ThreadC extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10;) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    while (state % 3 &#x3D;&#x3D; 2) &#123;&#x2F;&#x2F; 多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒</span><br><span class="line">                        System.out.print(&quot;C&quot;);</span><br><span class="line">                        state++;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();&#x2F;&#x2F; unlock()操作必须放在finally块中</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ThreadA().start();</span><br><span class="line">        new ThreadB().start();</span><br><span class="line">        new ThreadC().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://img-blog.csdn.net/20170817155504338" alt="这里写图片描述"></p><p>值得注意的是ReentrantLock是可重入锁，它持有一个锁计数器，当已持有锁的线程再次获得该锁时计数器值加1，每调用一次lock.unlock()时所计数器值减一，直到所计数器值为0，此时线程释放锁。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ReentrantLockTest &#123;</span><br><span class="line"></span><br><span class="line">    private ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void testReentrantLock() &#123;</span><br><span class="line">        &#x2F;&#x2F; 线程获得锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; get lock&quot;);</span><br><span class="line">            long beginTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            while (System.currentTimeMillis() - beginTime &lt; 100) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;线程再次获得该锁（可重入）</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; get lock again&quot;);</span><br><span class="line">                long beginTime2 &#x3D; System.currentTimeMillis();</span><br><span class="line">                while (System.currentTimeMillis() - beginTime2 &lt; 100) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; 线程第一次释放锁</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; release lock&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 线程再次释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; release lock again&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final ReentrantLockTest test &#x3D; new ReentrantLockTest();</span><br><span class="line">        Thread thread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test.testReentrantLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;A&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20170817160325068" alt="这里写图片描述"></p><h2 id="三、ReentrantLock结合Condition"><a href="#三、ReentrantLock结合Condition" class="headerlink" title="三、ReentrantLock结合Condition"></a>三、ReentrantLock结合Condition</h2><h3 id="1、基本思路-2"><a href="#1、基本思路-2" class="headerlink" title="1、基本思路"></a>1、基本思路</h3><p>与ReentrantLock搭配的通行方式是Condition，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock &#x3D; new ReentrantLock();  </span><br><span class="line">private Condition condition &#x3D; lock.newCondition(); </span><br><span class="line">condition.await();&#x2F;&#x2F;this.wait();  </span><br><span class="line">condition.signal();&#x2F;&#x2F;this.notify();  </span><br><span class="line">condition.signalAll();&#x2F;&#x2F;this.notifyAll();12345</span><br></pre></td></tr></table></figure><p>Condition是被绑定到Lock上的，必须使用lock.newCondition()才能创建一个Condition。从上面的代码可以看出，Synchronized能实现的通信方式，Condition都可以实现，功能类似的代码写在同一行中。这样解题思路就和第一种方法基本一致，只是采用的方法不同。</p><h3 id="2、代码-2"><a href="#2、代码-2" class="headerlink" title="2、代码"></a>2、代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ABC_Condition &#123;</span><br><span class="line">    private static Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    private static Condition A &#x3D; lock.newCondition();</span><br><span class="line">    private static Condition B &#x3D; lock.newCondition();</span><br><span class="line">    private static Condition C &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    private static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    static class ThreadA extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    while (count % 3 !&#x3D; 0)&#x2F;&#x2F;注意这里是不等于0，也就是说在count % 3为0之前，当前线程一直阻塞状态</span><br><span class="line">                        A.await(); &#x2F;&#x2F; A释放lock锁</span><br><span class="line">                    System.out.print(&quot;A&quot;);</span><br><span class="line">                    count++;</span><br><span class="line">                    B.signal(); &#x2F;&#x2F; A执行完唤醒B线程</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ThreadB extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    while (count % 3 !&#x3D; 1)</span><br><span class="line">                        B.await();&#x2F;&#x2F; B释放lock锁，当前面A线程执行后会通过B.signal()唤醒该线程</span><br><span class="line">                    System.out.print(&quot;B&quot;);</span><br><span class="line">                    count++;</span><br><span class="line">                    C.signal();&#x2F;&#x2F; B执行完唤醒C线程</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ThreadC extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    while (count % 3 !&#x3D; 2)</span><br><span class="line">                        C.await();&#x2F;&#x2F; C释放lock锁</span><br><span class="line">                    System.out.print(&quot;C&quot;);</span><br><span class="line">                    count++;</span><br><span class="line">                    A.signal();&#x2F;&#x2F; C执行完唤醒A线程</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new ThreadA().start();</span><br><span class="line">        new ThreadB().start();</span><br><span class="line">        new ThreadC().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20170817162420278" alt="这里写图片描述"></p><h2 id="四、Semaphore信号量方式"><a href="#四、Semaphore信号量方式" class="headerlink" title="四、Semaphore信号量方式"></a>四、Semaphore信号量方式</h2><h3 id="1、基本思路-3"><a href="#1、基本思路-3" class="headerlink" title="1、基本思路"></a>1、基本思路</h3><p>Semaphore又称信号量，是操作系统中的一个概念，在Java并发编程中，信号量控制的是线程并发的数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Semaphore(int permits)1</span><br></pre></td></tr></table></figure><p>其中参数permits就是允许同时运行的线程数目;<br>Semaphore是用来保护一个或者多个共享资源的访问，Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p><p>Semaphore使用时需要先构建一个参数来指定共享资源的数量，Semaphore构造完成后即是获取Semaphore、共享资源使用完毕后释放Semaphore。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore &#x3D; new Semaphore(10,true);  </span><br><span class="line">semaphore.acquire();  </span><br><span class="line">&#x2F;&#x2F;do something here  </span><br><span class="line">semaphore.release();  1234</span><br></pre></td></tr></table></figure><h3 id="2、代码-3"><a href="#2、代码-3" class="headerlink" title="2、代码"></a>2、代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">public class ABC_Semaphore &#123;</span><br><span class="line">    &#x2F;&#x2F; 以A开始的信号量,初始信号量数量为1</span><br><span class="line">    private static Semaphore A &#x3D; new Semaphore(1);</span><br><span class="line">    &#x2F;&#x2F; B、C信号量,A完成后开始,初始信号数量为0</span><br><span class="line">    private static Semaphore B &#x3D; new Semaphore(0);</span><br><span class="line">    private static Semaphore C &#x3D; new Semaphore(0);</span><br><span class="line"></span><br><span class="line">    static class ThreadA extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    A.acquire();&#x2F;&#x2F; A获取信号执行,A信号量减1,当A为0时将无法继续获得该信号量</span><br><span class="line">                    System.out.print(&quot;A&quot;);</span><br><span class="line">                    B.release();&#x2F;&#x2F; B释放信号，B信号量加1（初始为0），此时可以获取B信号量</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ThreadB extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    B.acquire();</span><br><span class="line">                    System.out.print(&quot;B&quot;);</span><br><span class="line">                    C.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ThreadC extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    C.acquire();</span><br><span class="line">                    System.out.println(&quot;C&quot;);</span><br><span class="line">                    A.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new ThreadA().start();</span><br><span class="line">        new ThreadB().start();</span><br><span class="line">        new ThreadC().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://img-blog.csdn.net/20170817163551932" alt="这里写图片描述"></p><p>可以看到信号量的变化情况如下：<br>初始(A=1,B=0,C=0)—&gt;第一次执行线程A时(A=1,B=0,C=0)—-&gt;第一次执行线程B时（A=0,B=1,C=0）—-&gt;第一次执行线程C时(A=0,B=0,C=1)—&gt;第二次执行线程A(A=1,B=0,C=0)如此循环。</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成</title>
      <link href="/2020/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
      <url>/2020/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>CPU 32 64位啥意思，内存最小单位，CPU如何寻址</p><p>计算机中的位数指的是<em>CPU</em>一次能处理的最大位数</p><p>内存是由很多个内存单元组成的，每个内存单元占8个bit位（1字节），也就是说内存中有多少个内存单元就意味着可以存储多少个字节，下面是一个只有两个内存单元的内存概念图：</p><p><img src="https://img-blog.csdn.net/20171111212105103" alt="img"></p><p>计算机有哪些存储设备，cpu cache置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=算法" target="_blank" rel="noopener">算法</a>，提了lru</p><p>intel CPU2核为啥电脑上会显示4核</p><p>intel运用独家的超bai线程技术du再虚拟出两个逻辑核zhi心，使CPU可以工作在四线dao程的状态下。超流水线</p><p>在CPU中由5—6个不同功能的电路单元组成一条指令处理流水线，然后将一条指令分成5—6步后再由这些电路单元分别执行，这样就能实现在一个<a href="https://baike.baidu.com/item/CPU时钟周期" target="_blank" rel="noopener">CPU时钟周期</a>完成一条指令，因此提高CPU的<a href="https://baike.baidu.com/item/运算速度/2682364" target="_blank" rel="noopener">运算速度</a>。经典奔腾每条整数流水线都分为四级流水，即取指令、<a href="https://baike.baidu.com/item/译码/3431840" target="_blank" rel="noopener">译码</a>、执行、写回结果</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线可分为三类：数据总线，地址总线，控制总线</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不用uuid当主键</title>
      <link href="/2020/12/19/%E4%B8%8D%E7%94%A8uuid%E5%BD%93%E4%B8%BB%E9%94%AE/"/>
      <url>/2020/12/19/%E4%B8%8D%E7%94%A8uuid%E5%BD%93%E4%B8%BB%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a><strong>前置知识</strong></h1><p><strong>聚簇索引：</strong>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</p><p><strong>非聚簇索引：</strong>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置</p><p><strong>Mysql Btree 索引结构</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTgxMTM2OS01Y2YzYTIzYTI5YjJjODhjLnBuZw?x-oss-process=image/format,png" alt="img"></p><p>如果是聚簇索引，那么索引的叶节点保存了索引值以及数据data。</p><p><strong>Page 页：</strong>是Innodb存储的最基本结构，也是Innodb磁盘管理的最小单位，与数据库相关的所有内容都存储在Page结构里。简单理解就是将数据分块成页，每个页里面包含部分数据。</p><h1 id="接下里进入主题"><a href="#接下里进入主题" class="headerlink" title="接下里进入主题"></a><strong>接下里进入主题</strong></h1><p>许多数据库相关的博客或书上会提到主键的选择上，尽量有序，UUID等无序的串会导致性能降低，为什么呢？</p><p>这其实和数据底层存储结构以及设计有关。</p><h1 id="顺序值作为主键"><a href="#顺序值作为主键" class="headerlink" title="顺序值作为主键"></a><strong>顺序值作为主键</strong></h1><p>我们先来看下 如果使用的是顺序的存储模式，聚簇索引在插入的时，存储应该是如何分布的。</p><p><img src="https://img-blog.csdnimg.cn/20200726222258210.png" alt="img"></p><p>因为主键得值是有序得，所以InnoDB把每一条记录都存储在上一条记录得后面，当达到页面的最大填充因子时（InnoDB默认的最大填充因子是页面大小的15/16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满，这也正是所期望的结果。</p><h1 id="了解了基本的存储，那么UUID又是如何影响性能的？"><a href="#了解了基本的存储，那么UUID又是如何影响性能的？" class="headerlink" title="了解了基本的存储，那么UUID又是如何影响性能的？"></a><strong>了解了基本的存储，那么UUID又是如何影响性能的？</strong></h1><p>从性能得角度考虑，使用UUID来作为局促索引则会很糟糕：它使得聚簇索引（主键值和行数据存放在一起）的插入变得完全随机，这是最坏得情况，使得数据没有任何得聚集性。</p><p>同时，使用UUID主键插入行不仅花费得时间更长，而且所有占用得空间也更大。主要是由于主键字段更长，另一方面毫无疑问是由于页分裂和碎片导致得。</p><p>因为UUID是随机生成的串，虽然能保证唯一性，但是因为新行的主键值不一定比之前插入的大，索引InnoDB无法简单地总是把新行插入到索引的最好，而是需要为新的行寻找合适的位置，通常是已有数据的中间位置，并且分配空间，这也会增加很多的额外工作，并导致数据分布不够优化。会导致以下情况：</p><blockquote><ul><li>写的的目标页可能已经刷入到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机I/O。</li><li>因为写是乱序的，InnoDB不得不频繁的做页分裂操作，以便新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页不是一个页。</li><li>由于频繁的也分裂。页会变得稀疏并被不规则地填充，最终导致数据会有碎片。</li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/20200726223416214.png" alt="img"></p><p>也正是因为上面一些影响性能的因素，索引尽量避免在生成中使用UUID作为数据库主键，但是如果项目确实有需要使用的必要，就根据实际情况而定。 </p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring中的设计模式</title>
      <link href="/2020/12/17/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/12/17/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h3><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。一个工厂生产多种产品</p><h4 id="工厂-1"><a href="#工厂-1" class="headerlink" title="工厂"></a>工厂</h4><p>每种工厂生产不同的产品</p><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建<br>出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p><h3 id="代理模式（AOP）"><a href="#代理模式（AOP）" class="headerlink" title="代理模式（AOP）"></a>代理模式（AOP）</h3><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>把一些操作延迟到子类进行实现</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>IO</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>定义一系列算法，封装每个算法，并使它们可以互换。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希冲突</title>
      <link href="/2020/12/16/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/"/>
      <url>/2020/12/16/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2020/12/16/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201216214531233.png" alt="image-20201216214531233"></p><p>问题一、什么是哈希冲突</p><p>由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突。（两个不同的数据计算后的结果一样）</p><p>问题二、如何解决哈希冲突</p><p>1、开放地址法（再散列法）</p><ul><li>线性探查法</li><li>二次探测</li></ul><p><img src="/2020/12/16/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201216214410891.png" alt="image-20201216214410891"></p><ul><li>随机探测再散列，</li></ul><p><img src="/2020/12/16/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201216214444307.png" alt="image-20201216214444307"></p><p>2、链地址法（拉链法）</p><p>3、再哈希法</p><p>4、创建公共溢出区</p><p>详细解释：</p><p>1、开放地址法（前提是散列表的长度大于等于所要存放的元素）</p><p>发生哈希冲突后，按照某一次序找到下一个空闲的单元，把冲突的元素放入。</p><ul><li><p>线性探查法：</p><p>从发生冲突的单元开始探查，依次查看下一个单元是否为空，如果到了最后一个单元还是空，那么再从表首依次判断。如此执行直到碰到了空闲的单元或者已经探查完所有单元。</p></li><li><p>平方探查法</p><p>从发生冲突的单元加上1^2,2^2,3^2,…,n^2，直到遇到空闲的单元</p></li><li><p>双散列函数探查法</p><p>定义两个散列函数，分别为s1和s2，s1的算法和前面一致，s2取一个1～m-1之间并和m互为素数的数。s2作为步长。</p></li></ul><p>2、链地址法</p><p>  将哈希值相同的元素构成一个链表，head放在散列表中。一般链表长度超过了8就转为红黑树，长度少于6个就变为链表。 </p><p>3、再哈希法</p><p>  同时构造多个不同的哈希函数，Hi = RHi(key) i= 1,2,3 … k;<br>当H1 = RH1(key) 发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p><p>4、建立公共溢出区</p><p>  把哈希表分为公共表和溢出表，如果发生了溢出，溢出的数据全部放在溢出区。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot相关问题</title>
      <link href="/2020/12/13/SpringBoot%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/13/SpringBoot%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>@SpringBootApplication看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制(<code>@Configuration</code>配置都加载到当前SpringBoot创建并使用的IoC容器)</li><li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描该类所在的包下所有的类。</li><li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li></ul><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application/json</strong> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;sign-up&quot;)</span><br><span class="line">public ResponseEntity signUp(@RequestBody @Valid UserRegisterRequest userRegisterRequest) &#123;</span><br><span class="line">  userService.save(userRegisterRequest);</span><br><span class="line">  return ResponseEntity.ok().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a><strong>@ConfigurationProperties</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;library&quot;)</span><br><span class="line">class LibraryProperties &#123;</span><br><span class="line">    @NotEmpty</span><br><span class="line">    private String location;</span><br><span class="line">    private List&lt;Book&gt; books;</span><br><span class="line"></span><br><span class="line">    @Setter</span><br><span class="line">    @Getter</span><br><span class="line">    @ToString</span><br><span class="line">    static class Book &#123;</span><br><span class="line">        String name;</span><br><span class="line">        String description;</span><br><span class="line">    &#125;</span><br><span class="line">  省略getter&#x2F;setter</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局处理-Controller-层异常"><a href="#全局处理-Controller-层异常" class="headerlink" title="全局处理 Controller 层异常"></a>全局处理 Controller 层异常</h3><ol><li><code>@ControllerAdvice</code> :注解定义全局异常处理类</li><li><code>@ExceptionHandler</code> :注解声明异常处理方法</li><li>如果方法参数不对的话就会抛出<code>MethodArgumentNotValidException</code>，我们来处理这个异常。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">@ResponseBody</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 请求参数异常处理</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(MethodArgumentNotValidException.class)</span><br><span class="line">    public ResponseEntity&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletRequest request) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>刷过的面经</title>
      <link href="/2020/12/08/%E5%88%B7%E8%BF%87%E7%9A%84%E9%9D%A2%E7%BB%8F/"/>
      <url>/2020/12/08/%E5%88%B7%E8%BF%87%E7%9A%84%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><p>x~2020.12.23</p><p><a href="https://www.nowcoder.com/discuss/576402?type=2&amp;channel=-1&amp;source_id=discuss_terminal_discuss_hot_nctrack" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/576402?type=2&amp;channel=-1&amp;source_id=discuss_terminal_discuss_hot_nctrack</a> （网络)</p><p><a href="https://www.nowcoder.com/discuss/571830?source_id=profile_create_nctrack&amp;channel=-1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/571830?source_id=profile_create_nctrack&amp;channel=-1</a> （鹤哥)</p><p><a href="https://www.nowcoder.com/discuss/576065" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/576065</a> (阿里、美团、头条)</p><p><a href="https://www.nowcoder.com/discuss/576220（域名投毒+IO+HTTP）" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/576220（域名投毒+IO+HTTP）</a></p><p>2020.12.24</p><p><a href="https://www.nowcoder.com/discuss/550791" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/550791</a>  (简单)</p><p>2020.12.25</p><p><a href="https://www.nowcoder.com/discuss/546746?source_id=profile_create_nctrack&amp;channel=-1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/546746?source_id=profile_create_nctrack&amp;channel=-1</a>  (线程同步+CAS+排序)</p><p><a href="https://www.nowcoder.com/discuss/580241（含有线程池+财经）" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/580241（含有线程池+财经）</a></p><p><a href="https://www.nowcoder.com/discuss/573905" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/573905</a> （RPC+SWAP对象+序列化)</p><p><a href="https://www.nowcoder.com/discuss/573219" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/573219</a>   （零拷贝+业务圈)</p><p><a href="https://www.nowcoder.com/discuss/572233" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/572233</a>   （Linux+行锁变表锁）</p><p><a href="https://www.nowcoder.com/discuss/570755" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/570755</a>    （超哥）</p><p><a href="https://www.nowcoder.com/discuss/489164" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/489164</a>   （resuful+缺页中断+间隙锁)</p><p><a href="https://www.nowcoder.com/discuss/567889" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/567889</a>   （进程通信+判断死锁+缓存行原理+滑动窗口大小+pagefaul）</p><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><p><a href="https://www.nowcoder.com/discuss/571141?source_id=profile_create_nctrack&amp;channel=-1（kafka+Springboot" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/571141?source_id=profile_create_nctrack&amp;channel=-1（kafka+Springboot</a>)</p><h3 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h3><p><a href="https://www.nowcoder.com/discuss/546065?source_id=profile_create_nctrack&amp;channel=-1（装箱拆箱+泛型" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/546065?source_id=profile_create_nctrack&amp;channel=-1（装箱拆箱+泛型</a>)</p><h3 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h3>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP千层套路</title>
      <link href="/2020/12/08/TCP%E5%8D%83%E5%B1%82%E5%A5%97%E8%B7%AF/"/>
      <url>/2020/12/08/TCP%E5%8D%83%E5%B1%82%E5%A5%97%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h3><p>信息对等和防止超时</p><h3 id="两次握手不行吗？"><a href="#两次握手不行吗？" class="headerlink" title="两次握手不行吗？"></a>两次握手不行吗？</h3><p>防止失效的链接突然到达</p><h3 id="ack-值是-seq-加-1？"><a href="#ack-值是-seq-加-1？" class="headerlink" title="ack 值是 seq 加 1？"></a>ack 值是 seq 加 1？</h3><p>ack表示告诉前面的数据我已经收到了。</p><h3 id="SYN洪泛攻击？"><a href="#SYN洪泛攻击？" class="headerlink" title="SYN洪泛攻击？"></a>SYN洪泛攻击？</h3><p>什么是SYN洪范泛攻击？  </p><ul><li>SYN Flood利用TCP协议缺陷，发送大量伪造的TCP连接请求，常用假冒的IP或IP号段发来海量的<strong>请求连接的第一个握手包（SYN包）</strong>，被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。<strong>导致被攻击服务器保持大量SYN_RECV状态的“半连接”</strong>，并且会重试默认5次回应第二个握手包，<strong>大量随机的恶意syn占满了未完成连接队列，导致正常合法的syn排不上队列，让正常的业务请求连接不进来</strong>。【服务器端的资源分配是在二次握手时分配的，而<a href>客户端</a>的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击】 </li></ul><p>检测 SYN 攻击非常的方便，<strong>当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击</strong>【在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击】 </p><p>怎么解决？  </p><ul><li>缩短超时（SYN Timeout）时间 </li><li>增加最大半连接数 </li><li>过滤网关防护 </li><li><strong>SYN cookies技术</strong>： </li></ul><ol><li><strong>当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源</strong>，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源 Id，目的 Id，端口号以及只有服务器自己知道的一个秘密函数<strong>生成一个 cookie，并把 cookie 作为序列号响应给<a href>客户端</a></strong>。 </li><li><strong>如果<a href>客户端</a>是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段</strong>。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，<strong>如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的<a href>客户端</a>，这时候才为该 TCP 分配资源</strong></li></ol><h3 id="关闭的时候却是四次握手？"><a href="#关闭的时候却是四次握手？" class="headerlink" title="关闭的时候却是四次握手？"></a>关闭的时候却是四次握手？</h3><p>服务器还有数据要发送</p><h3 id="为什么TCP挥手每两次中间有一个-FIN-WAIT2等待时间？"><a href="#为什么TCP挥手每两次中间有一个-FIN-WAIT2等待时间？" class="headerlink" title="为什么TCP挥手每两次中间有一个 FIN-WAIT2等待时间？"></a>为什么TCP挥手每两次中间有一个 FIN-WAIT2等待时间？</h3><ul><li>主动关闭的一端调用完close以后（即发FIN给被动关闭的一端， 并且收到其对FIN的确认ACK）则进入FIN_WAIT_2状态。<strong>如果这个时候因为网络突然断掉、被动关闭的一段宕机等原因，导致主动关闭的一端不能收到被动关闭的一端发来的FIN（防止对端不发送关闭连接的FIN包给本端）</strong>，这个时候就需要FIN_WAIT_2定时器， 如果在该定时器超时的时候，还是没收到被动关闭一端发来的FIN，那么直接释放这个链接，进入CLOSE状态</li></ul><h3 id="TIME-WAIT？"><a href="#TIME-WAIT？" class="headerlink" title="TIME-WAIT？"></a>TIME-WAIT？</h3><p>在<strong>高并发短连接</strong>的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，<strong>此时部分客户端就会显示连接不上</strong></p><p>服务器上出现大量的TIME_WAIT连接，<strong>占据大量的tuple /tApl/ ，严重消耗着服务器的资源</strong>，此时部分客户端就会显示连接不上 </p><p>作为客户端，短时间内大量的短连接，会大量消耗的Client机器的端口，毕竟端口只有65535个，端口被耗尽了，后续就无法在发起新的连接了</p><h3 id="CLOSE-WAIT？"><a href="#CLOSE-WAIT？" class="headerlink" title="CLOSE-WAIT？"></a>CLOSE-WAIT？</h3><ul><li>程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。</li><li>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。</li></ul><p>需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。</p><p>增大TIME out</p><h3 id="可靠"><a href="#可靠" class="headerlink" title="可靠"></a>可靠</h3><p>1.使用序号来检测丢失的分组和冗余副本</p><p>2.使用确认来告诉发送方确认的分组信息</p><p>3.检验和来检测一个传输分组中的比特错误</p><p>4.使用定时器来用于超时重传一个分组</p><p>5.ARQ<br>    连续ARQ<br>    回退N步<br>    选择重传</p><p>6.流量控制和拥塞控制</p><h3 id="TCP有哪些计时器"><a href="#TCP有哪些计时器" class="headerlink" title="TCP有哪些计时器"></a>TCP有哪些计时器</h3><p> <strong>TCP共使用以下四种计时器，即重传计时器、坚持计时器、保活计时器和时间等待计时器</strong> 。这几个计时器的主要特点如下：<br>   1、重传计时器<br>   <strong>当TCP发送报文段时，就创建该特定报文段的重传计时器</strong> 。可能发生两种情况：<br>  （1）、若在计时器截止时间到（ <strong>通常是60秒</strong> ）之前收到了对此特定报文段的确认，则撤销此计时器。<br>  （2）、若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。<br>   2、坚持计时器<br>  为了对付零窗口大小通知，TCP需要另一个计时器。假定接收TCP宣布了窗口大小为零。发送TCP就停止传送报文段，直到接收TCP发送确认并宣布一个非零的窗口大小。但这个确认可能会丢失。我们知道在TCP中，对确认是不需要发送确认的。若确认丢失了，接收TCP并不知道，而是会认为它已经完成任务了，并等待着发送TCP接着会发送更多的报文段。但发送TCP由于没有收到确认，就等待对方发送确认来通知窗口的大小。双方的TCP都在永远地等待着对方。<br>  要打开这种死锁，TCP为每一个连接使用一个坚持计时器。 <strong>当发送TCP收到一个窗口大小为零的确认时，就启动坚持计时器</strong> 。 <strong>当坚持计时器期限到时，发送TCP就发送一个特殊的报文段，</strong> 叫做 探测报文段 。这个报文段只有一个字节的数据。它有一个序号，但它的序号永远不需要确认；甚至在计算对其他部分的数据的确认时该序号也被忽略。探测报文段提醒对端：确认已丢失，必须重传。<br>  坚持计时器的值设置为重传时间的数值。但是，若没有收到从接收端来的响应，则需发送另一个探测报文段，并将坚持计时器的值加倍和复位。发送端继续发送探测报文段，将坚持计时器设定的值加倍和复位，直到这个值增大到门限值（ <strong>通常是60秒</strong> ）为止。在这以后，发送端每隔60秒就发送一个探测报文段，直到窗口重新打开。<br>   3、保活计时器<br>   <strong>保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲</strong>。假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处理打开状态。<br>要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。每当服务器收到客户的信息，就将计时器复位。保活计时器 <strong>通常设置为2小时</strong> 。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户出了故障，因而就终止该连接。<br>   4、时间等待计时器<br>  <strong>时间等待计时器是在连接终止期间使用的</strong> 。当TCP关闭一个连接时，它并不认为这个连接马上就真正地关闭了。在时间等待期间中，连接还处于一种中间过渡状态。这就可以使重复的FIN报文段（如果有的话）可以到达目的站因而可将其丢弃。这个计时器的值 <strong>通常设置为一个报文段的寿命期待值的两倍</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mybatis的xml标签</title>
      <link href="/2020/12/05/mybatis%E7%9A%84xml%E6%A0%87%E7%AD%BE/"/>
      <url>/2020/12/05/mybatis%E7%9A%84xml%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<p>一、SQL语句标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.liuyanzhao.mybatis.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;!--查询用户--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findUserById&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;com.liuyanzhao.mybatis.po.User&quot;&gt;</span><br><span class="line">        SELECT * FROM user WHERE id&#x3D;#&#123;value&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;!--根据用户名称模糊查询,可能返回多条--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findUserByName&quot; parameterType&#x3D;&quot;java.lang.String&quot; resultType&#x3D;&quot;com.liuyanzhao.mybatis.po.User&quot;&gt;</span><br><span class="line">        SELECT * FROM user WHERE username LIKE &#39;%$&#123;value&#125;%&#39;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;!--添加用户--&gt;</span><br><span class="line">    &lt;insert id&#x3D;&quot;insertUser&quot; parameterType&#x3D;&quot;com.liuyanzhao.mybatis.po.User&quot;&gt;</span><br><span class="line">        &lt;selectKey keyProperty&#x3D;&quot;id&quot; order&#x3D;&quot;AFTER&quot; resultType&#x3D;&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">            SELECT LAST_INSERT_ID()</span><br><span class="line">        &lt;&#x2F;selectKey&gt;</span><br><span class="line">        INSERT INTO user(username,birthday,gender,address) VALUE(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;gender&#125;,#&#123;address&#125;)</span><br><span class="line">    &lt;&#x2F;insert&gt;</span><br><span class="line">    &lt;!--删除用户--&gt;</span><br><span class="line">    &lt;delete id&#x3D;&quot;deleteUserById&quot; parameterType&#x3D;&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">        DELETE FROM user WHERE id&#x3D;#&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;delete&gt;</span><br><span class="line">    &lt;!--更新用户--&gt;</span><br><span class="line">    &lt;update id&#x3D;&quot;updateUserById&quot; parameterType&#x3D;&quot;com.liuyanzhao.mybatis.po.User&quot;&gt;</span><br><span class="line">        UPDATE user SET username&#x3D;#&#123;username&#125;,birthday&#x3D;#&#123;birthday&#125;,gender&#x3D;#&#123;gender&#125;,address&#x3D;#&#123;address&#125; WHERE id&#x3D;#&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;update&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure><p>需要配置的属性：</p><ul><li>id=”xxxx” &gt;&gt;&gt; 表示此段sql执行语句的唯一标识，也是接口的方法名称【必须一致才能找到】</li><li>parameterType=”” &gt;&gt;&gt;表示该sql语句中需要传入的参数， 类型要与对应的接口方法的类型一致【可选】</li><li>resultMap=“ ”&gt;&gt;&gt; 定义出参，调用已定义的<resultMap>映射管理器的id值</resultMap></li><li>resultType=“ ”&gt;&gt;&gt;定义出参，匹配普通Java类型或自定义的pojo【出参类型若不指定，将为语句类型默认类型，如<insert>语句返回值为int】</insert></li></ul><p>p.s： 至于为何<insert><delete><update> 语句的返回值类型为什么是int，有过JDBC操作经验的朋友可能会有印象，增删改操作实际上返回的是操作的条数。而<a href="https://liuyanzhao.com/tag/mybatis/" target="_blank" rel="noopener">Mybatis</a>框架本身是基于JDBC的，所以此处也沿袭这种返回值类型。</update></delete></insert></p><p>还有 int会自动转成 Integer，别名</p><p>传参和取值：mapper.xml 的灵活性还体现在SQL执行语句可以传参，参数类型通过parameterType= “” 定义</p><p>取值方式1：#{value jdbcType = valuetype}：jdbcType 表示该属性的数据类型在数据库中对应的类型，如 #{user jdbcType=varchar} 等价于 String username；</p><p>取值方式2：${value } : 这种方式不建议大量使用，可能会发送sql注入而导致安全性问题。一般该取值方式可用在非经常变化的值上，如orderby ${columnName}；</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id&#x3D;&quot;selectFields&quot;&gt;</span><br><span class="line">    id, from_id, to_id, conversation_id, content, status, create_time</span><br><span class="line">&lt;&#x2F;sql&gt;</span><br></pre></td></tr></table></figure><h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;if test&#x3D;&quot;name!&#x3D;null&quot;&gt;</span><br><span class="line">where name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)</span><br><span class="line">&lt;&#x2F;if&gt;</span><br></pre></td></tr></table></figure><h3 id="Foreach标签"><a href="#Foreach标签" class="headerlink" title="Foreach标签"></a>Foreach标签</h3><p>1、首先在po类中定义一个集合或者数组 比如 private List<Integer> ids;</Integer></p><p>2、在映射文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;foreach collection&#x3D;&quot;ids&quot; item&#x3D;&quot;ids&quot; item&#x3D;&quot;user_id&quot; open&#x3D;&quot;AND(&quot; close&#x3D;&quot;)&quot; seperator&#x3D;&quot;or&quot;&gt;&lt;foreach&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>collection:指定输入对象中集合属性</p><p>item：每次遍历生成的对象</p><p>open:开始遍历时拼接的串</p><p>close:结束遍历时两个对象需要拼接的串</p><h2 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h2><p><img src="https://img-blog.csdnimg.cn/20190617214513154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9feGlhbzM2MDE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当数据库方法返回的是复合数据类型（如list等），通常使用<code>resultMap</code>而非<code>resultType</code>。</p><h3 id="一对一："><a href="#一对一：" class="headerlink" title="一对一："></a>一对一：</h3><p>使用一对一查询时，在一个实体类中添加另一实体类属性。用resultMap实现映射关系时，使用association连接，<strong>javaType为封装的类型。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultType</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private Integer pid;&#x2F;&#x2F;人的id</span><br><span class="line">    private String pname;&#x2F;&#x2F;人的姓名</span><br><span class="line">    private Card card;&#x2F;&#x2F;人的身份证</span><br><span class="line">    public Integer getPid() &#123;</span><br><span class="line">        return pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPid(Integer pid) &#123;</span><br><span class="line">        this.pid &#x3D; pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPname() &#123;</span><br><span class="line">        return pname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPname(String pname) &#123;</span><br><span class="line">        this.pname &#x3D; pname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Card getCard() &#123;</span><br><span class="line">        return card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCard(Card card) &#123;</span><br><span class="line">        this.card &#x3D; card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(Integer pid, String pname, Card card) &#123;</span><br><span class="line">        this.pid &#x3D; pid;</span><br><span class="line">        this.pname &#x3D; pname;</span><br><span class="line">        this.card &#x3D; card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(Integer pid, String pname) &#123;</span><br><span class="line">        this.pid &#x3D; pid;</span><br><span class="line">        this.pname &#x3D; pname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;getPersonByPid&quot; resultMap&#x3D;&quot;person_card&quot; parameterType&#x3D;&quot;int&quot; &gt;</span><br><span class="line">    select *  from person p,card c where p.cid&#x3D;c.cid and p.pid&#x3D;#&#123;pid&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--自定义返回结果集--&gt;</span><br><span class="line">&lt;!--id是这个结果集的唯一标识符，方便根据Id调用，type是主体返回的实体类--&gt;</span><br><span class="line">&lt;resultMap id&#x3D;&quot;person_card&quot; type&#x3D;&quot;Person&quot; &gt;</span><br><span class="line">    &lt;!--主键--&gt;</span><br><span class="line">    &lt;id column&#x3D;&quot;pid&quot; property&#x3D;&quot;pid&quot;&gt;&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;!--普通属性--&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;pname&quot; property&#x3D;&quot;pname&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">    &lt;!--一对一的映射:人对应他的卡 javaType代表对应的类的类型，column代表是通过哪一列段进行关联--&gt;</span><br><span class="line">    &lt;association property&#x3D;&quot;card&quot; javaType&#x3D;&quot;Card&quot; column&#x3D;&quot;cid&quot; &gt;</span><br><span class="line">        &lt;id property&#x3D;&quot;cid&quot; column&#x3D;&quot;cid&quot;&gt;&lt;&#x2F;id&gt;</span><br><span class="line">        &lt;result property&#x3D;&quot;cnumber&quot; column&#x3D;&quot;cnumber&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">    &lt;&#x2F;association&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br></pre></td></tr></table></figure><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p>一对多是在一个类中包含另一个类list的集合，在映射时，使用Collection，<strong>ofType为封装类型。注意封装类型与一对一不同</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!--</span><br><span class="line">    id：指定主键列的封装规则（主键也可以使用result来定义）</span><br><span class="line">    column：指定哪一列</span><br><span class="line">    property：指定对应的javaBean属性</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot;&gt;&lt;&#x2F;id&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">    PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">    &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">    &lt;mapper namespace&#x3D;&quot;com.how2java.pojo&quot;&gt;</span><br><span class="line">        &lt;resultMap type&#x3D;&quot;Category&quot; id&#x3D;&quot;categoryBean&quot;&gt;</span><br><span class="line">            &lt;id column&#x3D;&quot;cid&quot; property&#x3D;&quot;id&quot; &#x2F;&gt;</span><br><span class="line">            &lt;result column&#x3D;&quot;cname&quot; property&#x3D;&quot;name&quot; &#x2F;&gt;</span><br><span class="line">     </span><br><span class="line">            &lt;!-- 一对多的关系 --&gt;</span><br><span class="line">            &lt;!-- property: 指的是集合属性的值, ofType：指的是集合中元素的类型 --&gt;</span><br><span class="line">            &lt;collection property&#x3D;&quot;products&quot; ofType&#x3D;&quot;Product&quot;&gt;</span><br><span class="line">                &lt;id column&#x3D;&quot;pid&quot; property&#x3D;&quot;id&quot; &#x2F;&gt;</span><br><span class="line">                &lt;result column&#x3D;&quot;pname&quot; property&#x3D;&quot;name&quot; &#x2F;&gt;</span><br><span class="line">                &lt;result column&#x3D;&quot;price&quot; property&#x3D;&quot;price&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;collection&gt;</span><br><span class="line">        &lt;&#x2F;resultMap&gt;</span><br><span class="line">     </span><br><span class="line">        &lt;!-- 关联查询分类和产品表 --&gt;</span><br><span class="line">        &lt;select id&#x3D;&quot;listCategory&quot; resultMap&#x3D;&quot;categoryBean&quot;&gt;</span><br><span class="line">            select c.*, p.*, c.id &#39;cid&#39;, p.id &#39;pid&#39;, c.name &#39;cname&#39;, p.name &#39;pname&#39; from category_ c left join product_ p on c.id &#x3D; p.cid</span><br><span class="line">        &lt;&#x2F;select&gt;   </span><br><span class="line">    &lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure><h2 id="二、if-标签"><a href="#二、if-标签" class="headerlink" title="二、if 标签"></a>二、if 标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--统计用户数量--&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;countUserByNameAndGender&quot; parameterType&#x3D;&quot;com.liuyanzhao.mybatis.po.User&quot; resultType&#x3D;&quot;int&quot;&gt;</span><br><span class="line">    SELECT COUNT(*) FROM user</span><br><span class="line">    &lt;!--where标签可以去掉首部的AND符号--&gt;</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;if test&#x3D;&quot;gender!&#x3D;null and gender!&#x3D;&#39;&#39;&quot;&gt;</span><br><span class="line">            AND gender &#x3D; #&#123;gender&#125;</span><br><span class="line">        &lt;&#x2F;if&gt;</span><br><span class="line">        &lt;if test&#x3D;&quot;username!&#x3D;null and gender!&#x3D;&#39;&#39;&quot;&gt;</span><br><span class="line">            AND username LIKE &#39;%$&#123;username&#125;%&#39;</span><br><span class="line">        &lt;&#x2F;if&gt;</span><br><span class="line">    &lt;&#x2F;where&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h2 id="三、sql-片段"><a href="#三、sql-片段" class="headerlink" title="三、sql 片段"></a>三、sql 片段</h2><p>在没有使用 sql 片段之前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--查询用户--&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findUserById&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;com.liuyanzhao.mybatis.po.User&quot;&gt;</span><br><span class="line">    SELECT id,username,gender,birthday,address FROM user WHERE id&#x3D;#&#123;value&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>定义和使用 sql 片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--定义sql片段--&gt;</span><br><span class="line">&lt;sql id&#x3D;&quot;user_table_all_columns&quot;&gt;</span><br><span class="line">    id,username,gender,birthday,address</span><br><span class="line">&lt;&#x2F;sql&gt;</span><br><span class="line">&lt;!--查询用户--&gt;</span><br><span class="line">&lt;select id&#x3D;&quot;findUserById&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;com.liuyanzhao.mybatis.po.User&quot;&gt;</span><br><span class="line">    SELECT</span><br><span class="line">    &lt;include refid&#x3D;&quot;user_table_all_columns&quot;&#x2F;&gt;</span><br><span class="line">    FROM user WHERE id&#x3D;#&#123;value&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>其中 sql 标签的 di 表示 sql 片段的唯一标识符</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring启动过程</title>
      <link href="/2020/12/05/Spring%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/12/05/Spring%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>使用spring配置,都需要在web.xml中配置一个spring的监听器和启动参数（context-param），如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;</span><br><span class="line">        classpath:spring-*.xml</span><br><span class="line">    &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br><span class="line"></span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;12345678910</span><br></pre></td></tr></table></figure><p>web容器启动时，下面为spring加载执行步骤：</p><ol><li>执行web.xml中的ContextLoaderListener监听器</li><li>初始化ContextLoaderListener中的contextInitialized方法<br><img src="https://img-blog.csdn.net/20180413105423967?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdXV1c2Vh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="初始化加载contextInitialized方法"></li><li>contextInitialized方法中调用父类（ContextLoader）的initWebApplicationContext方法<br><img src="https://img-blog.csdn.net/20180413105734579?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdXV1c2Vh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>initWebApplicationContext方法中执行了三个任务<ul><li>创建WebApplicationContext容器<br><img src="https://img-blog.csdn.net/20180413110225550?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdXV1c2Vh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li><li>加载context-param中配置的spring配置文件</li><li>初始化配置文件中及创建配置文件中的bean<br><img src="https://img-blog.csdn.net/20180413110235544?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdXV1c2Vh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180413110243703?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdXV1c2Vh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li></ul></li></ol><hr><p>web容器停止时候会执行ContextLoaderListener的contextDestroyed方法销毁context容器<br><img src="https://img-blog.csdn.net/20180413111005822?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdXV1c2Vh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>子网掩码</title>
      <link href="/2020/12/05/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/"/>
      <url>/2020/12/05/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="IP地址划分"><a href="#IP地址划分" class="headerlink" title="IP地址划分"></a>IP地址划分</h3><p><img src="https://img-blog.csdn.net/20160712182446560" alt="网络地址的划分"></p><h3 id="A类，B类，C类"><a href="#A类，B类，C类" class="headerlink" title="A类，B类，C类"></a>A类，B类，C类</h3><hr><table><thead><tr><th>概念</th><th>特征</th><th>网络范围</th><th>默认掩码</th></tr></thead><tbody><tr><td>A类地址</td><td>第1个8位中的第1位始终为0</td><td>0-127.x.x.x</td><td>255.0.0.0/8</td></tr><tr><td>B类地址</td><td>第1个8位中的第1、2位始终为10</td><td>128-191.x.x.x</td><td>255.255.0.0/16</td></tr><tr><td>C类地址</td><td>第1个8位中的第1、2、3位始终为110</td><td>192-y.x.x.x</td><td>255.255.255.0/24</td></tr></tbody></table><p>D类 以1110开始 用于组播<br>E类 以11110开始 用于科研保留</p><p>A类 从1.0.0.0 到126.255.255.255<br>B类 从128.0.0.0到191.255.255.255<br>C类 从192.0.0.0到223.255.255.255<br>其中127.x.x.x段地址空间是被保留的回环地址</p><p>路由器可以实现网关的功能，但是路由器功能不仅仅是实现网关。</p><p>比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1<del>192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1</del>192.168.2.254”，子网掩码为255.255.255.0。</p><p>在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。</p><p>而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。</p><p>所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。</p><h3 id="网关IP地址"><a href="#网关IP地址" class="headerlink" title="网关IP地址"></a>网关IP地址</h3><p>网关(Gateway)又称网间连接器、协议转换器。默认网关在网络层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。</p><h3 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h3><p><strong>因特网上的每个网络都有一个IP地址，其主机号部分为“0”。</strong></p><p>网络地址的一般表达式为：</p><p><strong>{<Network-number>，<Host-number>}={<Network-number>，0}</Network-number></Host-number></Network-number></strong></p><p>该地址用于标识网络，不能分配给主机，<strong>因此不能作为数据的源地址和目的地址。</strong></p><ul><li>A类网络的网络地址为：Network-number.0.0.0。例如，120.0.0.0；</li><li>B类网络的网络地址为：Network-number.0.0。例如，139.22.0.0；</li><li>C类网络的网络地址为：Network-number.0。例如，203.120.16.0。</li></ul><h3 id="直接广播地址"><a href="#直接广播地址" class="headerlink" title="直接广播地址"></a>直接广播地址</h3><p>直接广播（Direct Broadcast Address）：向某个网络上所有的主机发送报文。<strong>TCP/IP规定，主机号各位全部为“1”的IP地址用于广播，叫作广播地址。</strong>路由器在目标网络处将IP直接广播地址映射为物理网络的广播地址，以太网的广播地址为6个字节的全“1”二进制位，即：ff:ff:ff:ff:ff:ff 。</p><p>直接广播地址的一般表达式为：</p><p><strong>{<Network-number>，<Host-number>}={<Network-number>, -1}</Network-number></Host-number></Network-number></strong></p><p>这里的“-1”表示全“1”。 </p><p><strong>直接广播地址只能作为目的地址。</strong></p><ul><li>A类网络的直接广播地址为：Network-number.255.255.255。例如，120.255.255.255；</li><li>B类网络的直接广播地址为：Network-number.255.255。例如，139.22.255.255；</li><li>C类网络的直接广播地址为：Network-number.255。例如，203.120.16.255。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>网络号各位全部为“0”时表示的是本网络，127用作环回地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;yngzmiao.blog.csdn.net&#x2F;article&#x2F;details&#x2F;80980749?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-OPENSEARCH-2.control&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-OPENSEARCH-2.control</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题</title>
      <link href="/2020/12/04/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-1/"/>
      <url>/2020/12/04/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>restful风格的api</title>
      <link href="/2020/12/04/restful%E9%A3%8E%E6%A0%BC%E7%9A%84api/"/>
      <url>/2020/12/04/restful%E9%A3%8E%E6%A0%BC%E7%9A%84api/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>请求 = 动词 + 宾语</p><p>动词 使用五种 HTTP 方法，对应 CRUD 操作。</p><p>宾语 URL 应该全部使用名词复数</p><p><img src="/2020/12/04/restful%E9%A3%8E%E6%A0%BC%E7%9A%84api/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201204193457082.png" alt="image-20201204193457082"></p><p>使用 HTTP 的状态码</p><p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p><p><img src="/2020/12/04/restful%E9%A3%8E%E6%A0%BC%E7%9A%84api/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201204193514554.png" alt="image-20201204193514554"></p><p>服务器回应数据</p><p>客户端请求时，要明确告诉服务器，接受 JSON 格式，请求的 HTTP 头的 ACCEPT 属性要设成 application/json</p><p>服务端返回的数据，不应该是纯文本，而应该是一个 JSON 对象。服务器回应的 HTTP 头的 Content-Type 属性要设为 application/json</p><p><img src="/2020/12/04/restful%E9%A3%8E%E6%A0%BC%E7%9A%84api/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201204193625778.png" alt="image-20201204193625778"></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MESI协议</title>
      <link href="/2020/12/02/MESI%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/12/02/MESI%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>现在的处理器都是多核处理器，并且每个核都带有多个缓存（指令缓存和数据缓存，见下图）。为什么需要缓存呢，这是因为CPU访问内存的速度比较慢，所以在CPU和内存之间加了个缓存以提高访问速度。既然每个核都有缓存，那么假设两个核或者多个核同时访问同一个变量时这些缓存是如何进行同步的呢（缓存细分为一个个缓存行），这就有了MESI协议。</p><p><img src="https://img-blog.csdnimg.cn/2019043011202338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW93ZW5tdTE=,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong><em>\</em>缓存行的四个状态：**</strong></p><p>MESI中每个缓存行都有四个状态，分别是E（exclusive）、M（modified）、S（shared）、I（invalid）。下面我们介绍一下这四个状态分别代表什么意思。</p><p>M：代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中。这个状态的缓存行中的数据和内存中的不一样，在未来的某个时刻它会被写入到内存中（当其他CPU要读取该缓存行的内容时。或者其他CPU要修改该缓存对应的内存中的内容时（个人理解CPU要修改该内存时先要读取到缓存中再进行修改），这样的话和读取缓存中的内容其实是一个道理）。</p><p>E：E代表该缓存行对应内存中的内容只被该CPU缓存，其他CPU没有缓存该缓存对应内存行中的内容。这个状态的缓存行中的内容和内存中的内容一致。该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。</p><p>S:该状态意味着数据不止存在本地CPU缓存中，还存在别的CPU的缓存中。这个状态的数据和内存中的数据是一致的。当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态。</p><p>I：代表该缓存行中的内容时无效的。</p><p><strong>EMSI状态转移图：</strong></p><p><img src="https://img-blog.csdnimg.cn/20190430121514251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW93ZW5tdTE=,size_16,color_FFFFFF,t_70" alt="img"></p><p>local read和local write分别代表本地CPU读写。remote read和remote write分别代表其他CPU读写。建议首次看EMSI内容的可以自己把下面这个表格写下来（我自己就是这么做的），这样理解会深一点。</p><table><thead><tr><th>当前状态</th><th>事件</th><th>行为</th><th>下一个状态</th></tr></thead><tbody><tr><td>I（invalid）</td><td>local read</td><td>1.如果其他处理器中没有这份数据，本缓存从内存中取该数据，状态变为E2.如果其他处理器中有这份数据，且缓存行状态为M，则先把缓存行中的内容写回到内存。本地cache再从内存读取数据，这时两个cache的状态都变为S3.如果其他缓存行中有这份数据，并且其他缓存行的状态为S或E，则本地cache从内存中取数据，并且这些缓存行的状态变为S</td><td>E或S</td></tr><tr><td></td><td>local write</td><td>1.先从内存中取数据，如果其他缓存中有这份数据，且状态为M，则先将数据更新到内存再读取（个人认为顺序是这样的，其他CPU的缓存内容更新到内存中并且被本地cache读取时，两个cache状态都变为S，然后再写时把其他CPU的状态变为I，自己的变为M）2.如果其他缓存中有这份数据，且状态为E或S，那么其他缓存行的状态变为I</td><td>M</td></tr><tr><td>remote read</td><td>remote read不影响本地cache的状态</td><td>I</td><td></td></tr><tr><td>remote write</td><td>remote read不影响本地cache的状态</td><td>I</td><td></td></tr><tr><td>E（exclusive）</td><td>local read</td><td>状态不变</td><td>E</td></tr><tr><td></td><td>local write</td><td>状态变为M</td><td>M</td></tr><tr><td>remote read</td><td>数据和其他核共享，状态变为S</td><td>S</td><td></td></tr><tr><td>remote write</td><td>其他CPU修改了数据，状态变为I</td><td>I</td><td></td></tr><tr><td>S（shared）</td><td>local read</td><td>不影响状态</td><td>S</td></tr><tr><td></td><td>local write</td><td>其他CPU的cache状态变为I，本地cache状态变为M</td><td>M</td></tr><tr><td>remote read</td><td>不影响状态</td><td>S</td><td></td></tr><tr><td>remote write</td><td>本地cache状态变为I，修改内容的CPU的cache状态变为M</td><td>I</td><td></td></tr><tr><td>M（modified）</td><td>local read</td><td>状态不变</td><td>M</td></tr><tr><td></td><td>local write</td><td>状态不变</td><td>M</td></tr><tr><td>remote read</td><td>先把cache中的数据写到内存中，其他CPU的cache再读取，状态都变为S</td><td>S</td><td></td></tr><tr><td>remote write</td><td>先把cache中的数据写到内存中，其他CPU的cache再读取并修改后，本地cache状态变为I。修改的那个cache状态变为M</td><td></td><td></td></tr></tbody></table><h3 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h3><p>当其他CPU使用这个变量时，首先会去嗅探是否有对该变量更改的信号，当发现这个变量的缓存行已经无效时，会从新从内存中读取这个变量。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法题的具体细节</title>
      <link href="/2020/12/01/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82/"/>
      <url>/2020/12/01/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h3><p>注意最后一个结点, while(parent!=null)</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OOM的区域?</title>
      <link href="/2020/11/24/OOM%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
      <url>/2020/11/24/OOM%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="OutOfMemoryError原因分析"><a href="#OutOfMemoryError原因分析" class="headerlink" title="OutOfMemoryError原因分析"></a>OutOfMemoryError原因分析</h3><p>从我前面分析的数据区的角度，除了程序计数器，其他区域都有可能会因为可能的空间不足发生 OutOfMemoryError，简单总结如下：</p><ul><li>堆内存不足是最常见的 OOM 原因之一，抛出的错误信息是“java.lang.OutOfMemoryError:Java heap pace”，原因可能千奇百怪，例如，可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小；或者出现 JVM 处理引用不及时，导致堆积起来，内存无法释放等。</li><li>而对于 Java 虚拟机栈和本地方法栈，这里要稍微复杂一点。如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 StackOverFlowError；当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。</li><li>对于老版本的 JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 Intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError: PermGen space”。</li><li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现 OOM，异常信息则变成了：“java.lang.OutOfMemoryError: Metaspace”。</li><li>直接内存不足，也会导致 OOM，这个已经专栏第 11 讲介绍过。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>netty相关总结</title>
      <link href="/2020/11/24/netty%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
      <url>/2020/11/24/netty%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Netty-是什么？"><a href="#Netty-是什么？" class="headerlink" title="Netty 是什么？"></a>Netty 是什么？</h2><ol><li>Netty 是一个 <strong>基于 NIO</strong> 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</li><li>它极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</li></ol><p>用官方的总结就是：<strong>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</strong></p><h2 id="为啥不直接用NIO呢"><a href="#为啥不直接用NIO呢" class="headerlink" title="为啥不直接用NIO呢?"></a>为啥不直接用NIO呢?</h2><p>不用NIO主要是因为NIO的编程模型复杂而且存在一些BUG，并且对编程功底要求比较高。下图就是一个典型的使用 NIO 进行编程的案例：而且，NIO在面对断连重连、包丢失、粘包等问题时处理过程非常复杂。Netty的出现正是为了解决这些问题，更多关于Netty的特点可以看下面的内容。</p><h2 id="Netty-应用场景了解么？"><a href="#Netty-应用场景了解么？" class="headerlink" title="Netty 应用场景了解么？"></a>Netty 应用场景了解么？</h2><ol><li><strong>作为 RPC 框架的网络通信工具</strong> ： 我们在分布式系统中，不同服务节点之间经常需要相互调用，这个时候就需要 RPC 框架了。不同服务指点的通信是如何做的呢？可以使用 Netty 来做。比如我调用另外一个节点的方法的话，至少是要让对方知道我调用的是哪个类中的哪个方法以及相关参数吧！</li><li><strong>实现一个自己的 HTTP 服务器</strong> ：通过 Netty 我们可以自己实现一个简单的 HTTP 服务器，这个大家应该不陌生。说到 HTTP 服务器的话，作为 Java 后端开发，我们一般使用 Tomcat 比较多。一个最基本的 HTTP 服务器可要以处理常见的 HTTP Method 的请求，比如 POST 请求、GET 请求等等。</li><li><strong>实现一个即时通讯系统</strong> ： 使用 Netty 我们可以实现一个可以聊天类似微信的即时通讯系统，这方面的开源项目还蛮多的，可以自行去 Github 找一找。</li><li><strong>实现消息推送系统</strong> ：市面上有很多消息推送系统都是基于 Netty 来做的。</li><li>我们平常经常接触的 Dubbo、RocketMQ、Elasticsearch、gRPC 等等都用到了 Netty。</li></ol><h2 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h2><p>(线程模型-&gt;主从Reactor、BossGroup、WorkerGroup区别、EventLoopGroup与线程池的关系、EventLoop、Pipeline、ChannelHandler、Context）)</p><p>(NIO介绍一下（Selector、Channel、ByteBuffer，IO多路复用，底层的select、poll、epoll（这里我只是了解，不清楚具体实现）)</p><p>总结：</p><hr><ul><li>BossGroup:  用于处理客户端的 TCP 连接请求。</li><li>WorkerGroup:  负责每一条连接的具体读写数据的处理逻辑，真正负责 I/O 读写操作，交由对应的 Handler 处理。</li><li>EventLoopGroup和EventLoop:  EventLoopGroup包含多个 EventLoop（每一个 EventLoop 通常内部包含一个线程），它管理着所有的 EventLoop 的生命周期。并且，<strong><code>EventLoop</code> 处理的 I/O 事件都将在它专有的 <code>Thread</code> 上被处理，即 <code>Thread</code> 和 <code>EventLoop</code> 属于 1 : 1 的关系，从而保证线程安全。</strong></li><li>Channel:  <strong><code>Channel</code> 为 Netty 网络读写等操作的接口，<code>EventLoop</code> 处理连接中所发生的事件，两者配合进行 I/O 操作。</strong>每个channel都会分配一个EventLoop</li><li>Pipeline:   一个<code>Channel</code>包含一个 <code>ChannelPipeline</code>。 <code>ChannelPipeline</code> 为 <code>ChannelHandler</code> 的链，一个 pipeline 上可以有多个 <code>ChannelHandler</code></li><li>ChannelHandler:   <strong><code>ChannelHandler</code> 是消息的具体处理器，主要负责处理客户端/服务端接收和发送的数据。</strong></li></ul><p>ChannelPipeline<code>上通过</code>addLast()<code>方法添加一个或者多个</code>ChannelHandler<code>（一个数据或者事件可能会被多个 Handler 处理） 。当一个</code>ChannelHandler<code>处理完之后就将数据交给下一个</code>ChannelHandler` 。</p><ul><li>Context:   </li></ul><p>当 <code>ChannelHandler</code> 被添加到的 <code>ChannelPipeline</code> 它得到一个 <code>ChannelHandlerContext</code>，它代表一个 <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的“绑定”。 <code>ChannelPipeline</code> 通过 <code>ChannelHandlerContext</code>来间接管理 <code>ChannelHandler</code> 。</p><p>异步： 监听器的回调⽅法operationComplete()，将会在对应的操作完成时被调⽤。 然后监听器可以判断该操作是成功地完成了还是出错了。   c 每个 Netty 的出站 I/O 操作都将返回⼀个 ChannelFuture，也就是说， 它们都不会阻塞。所以说，Netty完全是异步和事件驱动的。</p><p><strong>Reactor是一种经典的线程模型，Reactor模式基于事件驱动，特别适合处理海量的I/O事件。</strong></p><p>Reactor线程模型分为单线程模型、多线程模型以及主从多线程模型。</p><blockquote><p>以下图片来源于网络，原出处不明，如有侵权请联系我。</p></blockquote><h3 id="单线程Reactor"><a href="#单线程Reactor" class="headerlink" title="单线程Reactor"></a>单线程Reactor</h3><p>所有的IO操作都由同一个NIO线程处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.eventGroup既用于处理客户端连接，又负责具体的处理。</span><br><span class="line">EventLoopGroup eventGroup &#x3D; new NioEventLoopGroup(1);</span><br><span class="line">&#x2F;&#x2F;2.创建服务端启动引导&#x2F;辅助类：ServerBootstrap</span><br><span class="line">ServerBootstrap b &#x3D; new ServerBootstrap();</span><br><span class="line">          boobtstrap.group(eventGroup, eventGroup)</span><br><span class="line">          &#x2F;&#x2F;......</span><br></pre></td></tr></table></figure><p><img src="https://images.xiaozhuanlan.com/photo/2020/6d32fa6864dca981b603c68bada2074e.png" alt="单线程Reactor"></p><p>单线程Reactor</p><h3 id="多线程Reactor"><a href="#多线程Reactor" class="headerlink" title="多线程Reactor"></a>多线程Reactor</h3><p>一个线程负责接受请求,一组NIO线程处理IO操作。</p><p><img src="https://images.xiaozhuanlan.com/photo/2020/45c3e2cd0d14c7d59a5d40be22edeb59.png" alt="多线程Reactor"></p><p>多线程Reactor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span><br><span class="line">EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup(1);</span><br><span class="line">EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">try &#123;</span><br><span class="line">  &#x2F;&#x2F;2.创建服务端启动引导&#x2F;辅助类：ServerBootstrap</span><br><span class="line">  ServerBootstrap b &#x3D; new ServerBootstrap();</span><br><span class="line">  &#x2F;&#x2F;3.给引导类配置两大线程组,确定了线程模型</span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    &#x2F;&#x2F;......</span><br></pre></td></tr></table></figure><h3 id="主从多线程Reactor"><a href="#主从多线程Reactor" class="headerlink" title="主从多线程Reactor"></a>主从多线程Reactor</h3><p>一组NIO线程负责接受请求，一组NIO线程处理IO操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span><br><span class="line">EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">try &#123;</span><br><span class="line">  &#x2F;&#x2F;2.创建服务端启动引导&#x2F;辅助类：ServerBootstrap</span><br><span class="line">  ServerBootstrap b &#x3D; new ServerBootstrap();</span><br><span class="line">  &#x2F;&#x2F;3.给引导类配置两大线程组,确定了线程模型</span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    &#x2F;&#x2F;......</span><br></pre></td></tr></table></figure><p><img src="https://images.xiaozhuanlan.com/photo/2020/c437e9d3e8f6e1bf884eb25e04b5d112.png" alt="主从多线程"></p><h3 id="Bytebuf（字节容器）"><a href="#Bytebuf（字节容器）" class="headerlink" title="Bytebuf（字节容器）"></a>Bytebuf（字节容器）</h3><p><strong>网络通信最终都是通过字节流进行传输的。 <code>ByteBuf</code> 就是 Netty 提供的一个字节容器，其内部是一个字节数组。</strong> 当我们通过 Netty 传输数据的时候，就是通过 <code>ByteBuf</code> 进行的。</p><p>我们可以将 <code>ByteBuf</code> 看作是 Netty 对 Java NIO 提供了 <code>ByteBuffer</code> 字节容器的封装和抽象。</p><h3 id="Channel（网络操作抽象类）"><a href="#Channel（网络操作抽象类）" class="headerlink" title="Channel（网络操作抽象类）"></a>Channel（网络操作抽象类）</h3><p><code>Channel</code> 接口是 Netty 对网络操作抽象类。通过 <code>Channel</code> 我们可以进行 I/O 操作。</p><p>一旦客户端成功连接服务端，就会新建一个 <code>Channel</code> 同该用户端进行绑定，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过 Bootstrap 的 connect 方法连接到服务端</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">doConnect</span><span class="params">(InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">     CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">     bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">         <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">             completableFuture.complete(future.channel());</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">return</span> completableFuture.get();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>比较常用的<code>Channel</code>接口实现类是 ：</p><ul><li><code>NioServerSocketChannel</code>（服务端）</li><li><code>NioSocketChannel</code>（客户端）</li></ul><p>这两个 <code>Channel</code> 可以和 BIO 编程模型中的<code>ServerSocket</code>以及<code>Socket</code>两个概念对应上。</p><h3 id="EventLoop（事件循环）"><a href="#EventLoop（事件循环）" class="headerlink" title="EventLoop（事件循环）"></a>EventLoop（事件循环）</h3><h4 id="EventLoop-介绍"><a href="#EventLoop-介绍" class="headerlink" title="EventLoop 介绍"></a>EventLoop 介绍</h4><p>说白了，<strong><code>EventLoop</code> 的主要作用实际就是责监听网络事件并调用事件处理器进行相关 I/O 操作（读写）的处理。</strong></p><h4 id="Channel-和-EventLoop-的关系"><a href="#Channel-和-EventLoop-的关系" class="headerlink" title="Channel 和 EventLoop 的关系"></a>Channel 和 EventLoop 的关系</h4><p>那 <code>Channel</code> 和 <code>EventLoop</code> 直接有啥联系呢？</p><p><strong><code>Channel</code> 为 Netty 网络操作(读写等操作)抽象类，<code>EventLoop</code> 负责处理注册到其上的<code>Channel</code> 的 I/O 操作，两者配合进行 I/O 操作。</strong></p><h4 id="EventloopGroup-和-EventLoop-的关系"><a href="#EventloopGroup-和-EventLoop-的关系" class="headerlink" title="EventloopGroup 和 EventLoop 的关系"></a>EventloopGroup 和 EventLoop 的关系</h4><p><code>EventLoopGroup</code> 包含多个 <code>EventLoop</code>（每一个 <code>EventLoop</code> 通常内部包含一个线程），它管理着所有的 <code>EventLoop</code> 的生命周期。</p><p>并且，<strong><code>EventLoop</code> 处理的 I/O 事件都将在它专有的 <code>Thread</code> 上被处理，即 <code>Thread</code> 和 <code>EventLoop</code> 属于 1 : 1 的关系，从而保证线程安全。</strong></p><p>下图是 Netty <strong>NIO</strong> 模型对应的 <code>EventLoop</code> 模型。通过这个图应该可以将<code>EventloopGroup</code>、<code>EventLoop</code>、 <code>Channel</code>三者联系起来。</p><p><img src="https://images.xiaozhuanlan.com/photo/2020/1881a727d8d69621f3533f07045e3bc9." alt="img"></p><p><a href="https://www.jianshu.com/p/128ddc36e713" target="_blank" rel="noopener">https://www.jianshu.com/p/128ddc36e713</a></p><h3 id="ChannelHandler（消息处理器）-和-ChannelPipeline（ChannelHandler-对象链表）"><a href="#ChannelHandler（消息处理器）-和-ChannelPipeline（ChannelHandler-对象链表）" class="headerlink" title="ChannelHandler（消息处理器） 和 ChannelPipeline（ChannelHandler 对象链表）"></a>ChannelHandler（消息处理器） 和 ChannelPipeline（ChannelHandler 对象链表）</h3><p>下面这段代码使用过 Netty 的小伙伴应该不会陌生，我们指定了序列化编解码器以及自定义的 <code>ChannelHandler</code> 处理消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b.group(eventLoopGroup)</span><br><span class="line">        .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> NettyKryoDecoder(kryoSerializer, RpcResponse<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> NettyKryoEncoder(kryoSerializer, RpcRequest<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> KryoClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><strong><code>ChannelHandler</code> 是消息的具体处理器，主要负责处理客户端/服务端接收和发送的数据。</strong></p><p>当 <code>Channel</code> 被创建时，它会被自动地分配到它专属的 <code>ChannelPipeline</code>。 一个<code>Channel</code>包含一个 <code>ChannelPipeline</code>。 <code>ChannelPipeline</code> 为 <code>ChannelHandler</code> 的链，一个 pipeline 上可以有多个 <code>ChannelHandler</code>。</p><p>我们可以在 <code>ChannelPipeline</code> 上通过 <code>addLast()</code> 方法添加一个或者多个<code>ChannelHandler</code> （_一个数据或者事件可能会被多个 Handler 处理_） 。当一个 <code>ChannelHandler</code> 处理完之后就将数据交给下一个 <code>ChannelHandler</code> 。</p><p>当 <code>ChannelHandler</code> 被添加到的 <code>ChannelPipeline</code> 它得到一个 <code>ChannelHandlerContext</code>，它代表一个 <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的“绑定”。 <code>ChannelPipeline</code> 通过 <code>ChannelHandlerContext</code>来间接管理 <code>ChannelHandler</code> 。</p><p><img src="https://images.xiaozhuanlan.com/photo/2020/c672d845c91d137eddcde71343d13f34." alt="img"></p><p><a href="https://www.javadoop.com/post/netty-part-4" target="_blank" rel="noopener">https://www.javadoop.com/post/netty-part-4</a></p><h3 id="ChannelFuture（操作执行结果）"><a href="#ChannelFuture（操作执行结果）" class="headerlink" title="ChannelFuture（操作执行结果）"></a>ChannelFuture（操作执行结果）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; var1)</span></span>;</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netty 是异步非阻塞的，所有的 I/O 操作都为异步的。</p><p>因此，我们不能立刻得到操作是否执行成功，但是，你可以通过 <code>ChannelFuture</code> 接口的 <code>addListener()</code> 方法注册一个 <code>ChannelFutureListener</code>，当操作执行成功或者失败时，监听就会自动触发返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f = b.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"连接成功!"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.err.println(<span class="string">"连接失败!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).sync();</span><br></pre></td></tr></table></figure><p>并且，你还可以通过<code>ChannelFuture</code> 的 <code>channel()</code> 方法获取连接相关联的<code>Channel</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = f.channel();</span><br></pre></td></tr></table></figure><p>另外，我们还可以通过 <code>ChannelFuture</code> 接口的 <code>sync()</code>方法让异步的操作编程同步的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bind()是异步的，但是，你可以通过 `sync()`方法将其变为同步。</span></span><br><span class="line">ChannelFuture f = b.bind(port).sync();</span><br></pre></td></tr></table></figure><h2 id="NioEventLoopGroup-默认的构造函数会起多少线程？"><a href="#NioEventLoopGroup-默认的构造函数会起多少线程？" class="headerlink" title="NioEventLoopGroup 默认的构造函数会起多少线程？"></a>NioEventLoopGroup 默认的构造函数会起多少线程？</h2><p>综上，我们发现 <code>NioEventLoopGroup</code> 默认的构造函数实际会起的线程数为 <strong><code>CPU核心数\*2</code></strong>。</p><h2 id="Netty-服务端和客户端的启动过程了解么？"><a href="#Netty-服务端和客户端的启动过程了解么？" class="headerlink" title="Netty 服务端和客户端的启动过程了解么？"></a>Netty 服务端和客户端的启动过程了解么？</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">            <span class="comment">// (非必备)打印日志</span></span><br><span class="line">            .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">            <span class="comment">// 4.指定 IO 模型</span></span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                    ChannelPipeline p = ch.pipeline();</span><br><span class="line">                    <span class="comment">//5.可以自定义客户端消息的业务处理逻辑</span></span><br><span class="line">                    p.addLast(<span class="keyword">new</span> HelloServerHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">// 6.绑定端口,调用 sync 方法阻塞知道绑定完成</span></span><br><span class="line">    ChannelFuture f = b.bind(port).sync();</span><br><span class="line">    <span class="comment">// 7.阻塞等待直到服务器Channel关闭(closeFuture()方法获取Channel 的CloseFuture对象,然后调用sync()方法)</span></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//8.优雅关闭相关线程组资源</span></span><br><span class="line">    bossGroup.shutdownGracefully();</span><br><span class="line">    workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解析一下服务端的创建过程具体是怎样的：</p><p>1.首先你创建了两个 <code>NioEventLoopGroup</code> 对象实例：<code>bossGroup</code> 和 <code>workerGroup</code>。</p><ul><li><code>bossGroup</code> : 用于处理客户端的 TCP 连接请求。</li><li><code>workerGroup</code> ： 负责每一条连接的具体读写数据的处理逻辑，真正负责 I/O 读写操作，交由对应的 Handler 处理。</li></ul><p>2.接下来 我们创建了一个服务端启动引导/辅助类： <code>ServerBootstrap</code>，这个类将引导我们进行服务端的启动工作。</p><p>3.通过 <code>.group()</code> 方法给引导类 <code>ServerBootstrap</code> 配置两大线程组，确定了线程模型。</p><p>通过下面的代码，我们实际配置的是多线程模型，这个在上面提到过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure><p>4.通过<code>channel()</code>方法给引导类 <code>ServerBootstrap</code>指定了 IO 模型为<code>NIO</code></p><ul><li><p><code>NioServerSocketChannel</code> ：指定服务端的 IO 模型为 NIO，与 BIO 编程模型中的<code>ServerSocket</code>对应</p></li><li><p><code>NioSocketChannel</code> : 指定客户端的 IO 模型为 NIO， 与 BIO 编程模型中的<code>Socket</code>对应</p></li></ul><p>5.通过 <code>.childHandler()</code>给引导类创建一个<code>ChannelInitializer</code> ，然后指定了服务端消息的业务处理逻辑 <code>HelloServerHandler</code> 对象</p><p>6.调用 <code>ServerBootstrap</code> 类的 <code>bind()</code>方法绑定端口</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个 NioEventLoopGroup 对象实例</span></span><br><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//2.创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    <span class="comment">//3.指定线程组</span></span><br><span class="line">    b.group(group)</span><br><span class="line">            <span class="comment">//4.指定 IO 模型</span></span><br><span class="line">            .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline p = ch.pipeline();</span><br><span class="line">                    <span class="comment">// 5.这里可以自定义消息的业务处理逻辑</span></span><br><span class="line">                    p.addLast(<span class="keyword">new</span> HelloClientHandler(message));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">// 6.尝试建立连接</span></span><br><span class="line">    ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">    <span class="comment">// 7.等待连接关闭（阻塞，直到Channel关闭）</span></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续分析一下客户端的创建流程：</p><p>1.创建一个 <code>NioEventLoopGroup</code> 对象实例</p><p>2.创建客户端启动的引导类是 <code>Bootstrap</code></p><p>3.通过 <code>.group()</code> 方法给引导类 <code>Bootstrap</code> 配置一个线程组</p><p>4.通过<code>channel()</code>方法给引导类 <code>Bootstrap</code>指定了 IO 模型为<code>NIO</code></p><p>5.通过 <code>.childHandler()</code>给引导类创建一个<code>ChannelInitializer</code> ，然后指定了客户端消息的业务处理逻辑 <code>HelloClientHandler</code> 对象</p><p>6.调用 <code>Bootstrap</code> 类的 <code>connect()</code>方法进行连接，这个方法需要指定两个参数：</p><ul><li><code>inetHost</code> : ip 地址</li><li><code>inetPort</code> : 端口号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.connect(InetSocketAddress.createUnresolved(inetHost, inetPort));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(remoteAddress, <span class="string">"remoteAddress"</span>);</span><br><span class="line">    <span class="keyword">this</span>.validate();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doResolveAndConnect(remoteAddress, <span class="keyword">this</span>.config.localAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>connect</code> 方法返回的是一个 <code>Future</code> 类型的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说这个方是异步的，我们通过 <code>addListener</code> 方法可以监听到连接是否成功，进而打印出连接信息。具体做法很简单，只需要对代码进行以下改动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f = b.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"连接成功!"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.err.println(<span class="string">"连接失败!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).sync();</span><br></pre></td></tr></table></figure><h2 id="什么是-TCP-粘包-拆包-有什么解决办法呢？"><a href="#什么是-TCP-粘包-拆包-有什么解决办法呢？" class="headerlink" title="什么是 TCP 粘包/拆包?有什么解决办法呢？"></a>什么是 TCP 粘包/拆包?有什么解决办法呢？</h2><p>👨‍💻<strong>面试官</strong> ：什么是 TCP 粘包/拆包?</p><p>🙋 <strong>我</strong> ：TCP 粘包/拆包 就是你基于 TCP 发送数据的时候，出现了多个字符串“粘”在了一起或者一个字符串被“拆”开的问题。比如你多次发送：“你好,你真帅啊！哥哥！”，但是客户端接收到的可能是下面这样的：</p><p><img src="https://images.xiaozhuanlan.com/photo/2020/dc9333dd36170d22dbf701451f9b49c3.png" alt="img"></p><p>👨‍💻<strong>面试官</strong> ：那有什么解决办法呢?</p><p>🙋 <strong>我</strong> ：</p><p><strong>1.使用 Netty 自带的解码器</strong></p><ul><li><strong><code>LineBasedFrameDecoder</code></strong> : 发送端发送数据包的时候，每个数据包之间以换行符作为分隔，<code>LineBasedFrameDecoder</code> 的工作原理是它依次遍历 <code>ByteBuf</code> 中的可读字节，判断是否有换行符，然后进行相应的截取。</li><li><strong><code>DelimiterBasedFrameDecoder</code></strong> : 可以自定义分隔符解码器，<strong><code>LineBasedFrameDecoder</code></strong> 实际上是一种特殊的 <code>DelimiterBasedFrameDecoder</code> 解码器。</li><li><strong><code>FixedLengthFrameDecoder</code></strong>: 固定长度解码器，它能够按照指定的长度对消息进行相应的拆包。</li><li><strong><code>LengthFieldBasedFrameDecoder</code></strong>：<em>LengthFieldBased</em>FrameDecoder解码器自定义长度</li></ul><p><strong>2.自定义序列化编解码器</strong></p><p>在 Java 中自带的有实现 <code>Serializable</code> 接口来实现序列化，但由于它性能、安全性等原因一般情况下是不会被使用到的。</p><p>通常情况下，我们使用 Protostuff、Hessian2、json 序列方式比较多，另外还有一些序列化性能非常好的序列化方式也是很好的选择：</p><h2 id="Netty-长连接、心跳机制了解么？"><a href="#Netty-长连接、心跳机制了解么？" class="headerlink" title="Netty 长连接、心跳机制了解么？"></a>Netty 长连接、心跳机制了解么？</h2><p>👨‍💻<strong>面试官</strong> ：TCP 长连接和短连接了解么？</p><p>所谓，短连接说的就是 server 端 与 client 端建立连接之后，读写完成之后就关闭掉连接，如果下一次再要互相发送消息，就要重新连接。短连接的有点很明显，就是管理和实现都比较简单，缺点也很明显，每一次的读写都要建立连接必然会带来大量网络资源的消耗，并且连接的建立也需要耗费时间。</p><p>长连接说的就是 client 向 server 双方建立连接之后，即使 client 与 server 完成一次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。长连接的可以省去较多的 TCP 建立和关闭的操作，降低对网络资源的依赖，节约时间。对于频繁请求资源的客户来说，非常适用长连接。</p><p>👨‍💻<strong>面试官</strong> ：为什么需要心跳机制？Netty 中心跳机制了解么？</p><p>🙋 <strong>我</strong> ：</p><p>在 TCP 保持长连接的过程中，可能会出现断网等网络异常出现，异常发生的时候， client 与 server 之间如果没有交互的话，它们是无法发现对方已经掉线的。为了解决这个问题, 我们就需要引入 <strong>心跳机制</strong> 。</p><p>心跳机制的工作原理是: 在 client 与 server 之间在一定时间内没有数据交互时, 即处于 idle 状态时, 客户端或服务器就会发送一个特殊的数据包给对方, 当接收方收到这个数据报文后, 也立即发送一个特殊的数据报文, 回应发送方, 此即一个 PING-PONG 交互。所以, 当某一端收到心跳消息后, 就知道了对方仍然在线, 这就确保 TCP 连接的有效性.</p><p>通过 Netty 实现心跳机制的话，核心类是 <code>IdleStateHandler</code> 。</p><h2 id="Netty-的零拷贝了解么？"><a href="#Netty-的零拷贝了解么？" class="headerlink" title="Netty 的零拷贝了解么？"></a>Netty 的零拷贝了解么？</h2><p>👨‍💻<strong>面试官</strong> ：讲讲 Netty 的零拷贝？</p><p>🙋 <strong>我</strong> ：</p><p>维基百科是这样介绍零拷贝的：</p><blockquote><p>零复制（英语：Zero-copy；也译零拷贝）技术是指计算机执行操作时，CPU 不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省 CPU 周期和内存带宽。</p></blockquote><p>在 OS 层面上的 <code>Zero-copy</code> 通常指避免在 <code>用户态(User-space)</code> 与 <code>内核态(Kernel-space)</code> 之间来回拷贝数据。而在 Netty 层面 ，零拷贝主要体现在对于数据操作的优化。</p><p>Netty 中的零拷贝体现在以下几个方面</p><ol><li>使用 Netty 提供的 <code>CompositeByteBuf</code> 类, 可以将多个<code>ByteBuf</code> 合并为一个逻辑上的 <code>ByteBuf</code>, 避免了各个 <code>ByteBuf</code> 之间的拷贝。</li><li><code>ByteBuf</code> 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 <code>ByteBuf</code>, 避免了内存的拷贝。</li><li>通过 <code>FileRegion</code> 包装的<code>FileChannel.tranferTo</code> 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 <code>Channel</code>, 避免了传统通过循环 write 方式导致的内存拷贝问题.</li></ol><h3 id="Nio"><a href="#Nio" class="headerlink" title="Nio"></a>Nio</h3>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何设计一个消息队列</title>
      <link href="/2020/11/24/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2020/11/24/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>首先我们需要明确地提出消息中间件的几个重要角色，分别是生产者、消费者、Broker、注册中心。</p><p>简述下消息中间件数据流转过程，无非就是生产者生成消息，发送至 Broker，Broker 可以暂缓消息，然后消费者再从 Broker 获取消息，用于消费。</p><p>而注册中心用于服务的发现包括：Broker 的发现、生产者的发现、消费者的发现，当然还包括下线，可以说服务的高可用离不开注册中心。</p><p>然后开始简述实现要点，可以同通信讲起：各模块的通信可以基于 Netty 然后自定义协议来实现，注册中心可以利用 zoo<a href>keep</a>er、consul、eureka、nacos 等等，也可以像 RocketMQ 自己实现简单的 namesrv （这一句话就都是关键词）。</p><p>为了考虑扩容和整体的性能，采用分布式的思想，像 Kafka 一样采取分区理念，一个 Topic 分为多个 partition，并且为保证数据可靠性，采取多副本存储，即 Leader 和 follower，根据性能和数据可靠的权衡提供异步和同步的刷盘存储。</p><p>并且利用选举<a href>算法</a>保证 Leader 挂了之后 follower 可以顶上，保证消息队列的高可用。</p><p>也同样为了提高消息队列的可靠性利用本地文件系统来存储消息，并且采用顺序写的方式来提高性能。</p><p>可根据消息队列的特性利用内存映射、零拷贝进一步的提升性能，还可利用像 Kafka 这种批处理思想提高整体的吞吐。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>页中断</title>
      <link href="/2020/11/23/%E9%A1%B5%E4%B8%AD%E6%96%AD/"/>
      <url>/2020/11/23/%E9%A1%B5%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>缺页中断的过程：</p><ul><li>首先硬件会陷入内核，在堆栈中保存程序计数器，并将当前指令的各种状态信息保存在CPU中的特殊寄存器</li><li>操作系统查找出发生缺页中断的虚拟页面。这个虚拟页面通常保存在一个硬件寄存器中，如果没有，操作系统会检索程序计数器，取出产生缺页中断的指令，分析出发生缺页中断的虚拟页面</li><li>操作系统找到内存中一个空闲的页框，如果没有空闲的页框则需要通过页面置换算法找到一个需要换出的页框</li><li>如果需要置换的页框中内容已经被修改，则需要将修改的内容保存到磁盘上，此时会发生一个磁盘调用，发生上下文切换</li><li>页框保存完毕后，操作系统根据虚拟地址对应到磁盘上的位置，将磁盘上的页复制到也狂中，此时会发生一个磁盘调用，发生上下文切换</li><li>当磁盘中的页面保存完毕，会向操作系统发生一个中断，操作系统更新内存中的页表项，将虚拟页面映射的页框号更新写入的页框<br>恢复到缺页中断发前的状态，将程序计数器重新指向引起缺页中断的指令</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>drop、delete、truncate的区别</title>
      <link href="/2020/11/22/drop%E3%80%81delete%E3%80%81truncate%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/11/22/drop%E3%80%81delete%E3%80%81truncate%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://link.jianshu.com?t=http://51code.com/" target="_blank" rel="noopener">drop</a>直接删掉表；</p><p><a href="https://link.jianshu.com?t=http://51code.com/" target="_blank" rel="noopener">truncate</a>删除的是表中的数据，再插入数据时自增长的数据id又重新从1开始；</p><p><a href="https://link.jianshu.com?t=http://51code.com/" target="_blank" rel="noopener">delete</a>删除表中数据，可以在后面添加where字句。</p><p>（1）DELETE语句执行删除操作的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p><p>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>零拷贝是什么</title>
      <link href="/2020/11/22/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2020/11/22/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于Web服务器来说，经常需要从磁盘中读取数据到内存，然后再通过网卡传输给用户：</p><p>对于引入DMA的系统，流程如下</p><p>直接内存访问（Direct Memory Access），是一种硬件设备绕开CPU独立直接访问内存的机制。所以DMA在一定程度上解放了CPU，把之前CPU的杂活让硬件直接自己做了，提高了CPU效率。</p><p>目前支持DMA的硬件包括：网卡、声卡、显卡、磁盘控制器等。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ8N2VL8Qh7vghYXgUU4oR9wD6dUEicMApoFRiaaibbot4ABAqIjcm5ZIqL9zTtzrwgJkn3SRdicicDVwg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ8N2VL8Qh7vghYXgUU4oR9CxswcETSC5652RTWzQFg1Ks1uETZ81XAmkOR6ia4vR4cfpIQ5fzkfPw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><ul><li>当应用程序需要读取磁盘数据时，调用read()从用户态陷入内核态，read()这个系统调用最终由CPU来完成；</li><li>CPU向DMA发起I/O请求，由DMA向磁盘发送IO请求，磁盘收到之后开始准备数据；</li><li>磁盘准备好之后发送完成信号，DMA会拷贝数据，吧数据从磁盘缓冲区拷贝到内核缓冲区</li><li>CPU收到DMA的信号之后，开始拷贝数据，完成之后read()返回，再从内核态切换到用户态</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ8N2VL8Qh7vghYXgUU4oR98TkWCmHakjZhxu6Ms9LdfPWa83Yicyfic8NzXHDPc6aRtgxYwYczZib0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>来看下完整的数据拷贝过程简图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ8N2VL8Qh7vghYXgUU4oR9OYUR0e1sicJTG0KIT5aX8picXEialEdrZZyomNciaqDnGbOlZOyxQA5Ydw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><strong>读数据过程：</strong></p><ul><li>应用程序要读取磁盘数据，调用read()函数从而实现用户态切换内核态，这是第1次状态切换；</li><li>DMA控制器将数据从磁盘拷贝到内核缓冲区，这是第1次DMA拷贝；</li><li>CPU将数据从内核缓冲区复制到用户缓冲区，这是第1次CPU拷贝；</li><li>CPU完成拷贝之后，read()函数返回实现用户态切换用户态，这是第2次状态切换；</li></ul><p><strong>写数据过程：</strong></p><ul><li>应用程序要向网卡写数据，调用write()函数实现用户态切换内核态，这是第1次切换；</li><li>CPU将用户缓冲区数据拷贝到套接字缓冲区，这是第1次CPU拷贝；</li><li>DMA控制器将数据从套接字缓冲区复制到网卡，这是第1次DMA拷贝；</li><li>完成拷贝之后，write()函数返回实现内核态切换用户态，这是第2次切换；</li></ul><p><strong>综上所述：</strong></p><ul><li>读过程涉及2次空间切换、1次DMA拷贝、1次CPU拷贝；</li><li>写过程涉及2次空间切换、1次DMA拷贝、1次CPU拷贝；</li></ul><p>可见传统模式下，涉及多次空间切换和数据冗余拷贝，效率并不高，接下来就该零拷贝技术出场了。</p><h2 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h2><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>我们可以看到，如果应用程序不对数据做修改，从内核缓冲区到用户缓冲区，再从用户缓冲区到内核缓冲区。两次数据拷贝都需要CPU的参与，并且涉及用户态与内核态的多次切换，加重了CPU负担。</p><p><strong>我们需要降低冗余数据拷贝、解放CPU，这也就是零拷贝Zero-Copy技术。</strong></p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>目前来看，零拷贝技术的几个实现手段包括：mmap+write、sendfile、sendfile+DMA收集、splice等。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ8N2VL8Qh7vghYXgUU4oR976EiahKicrYhZ9qR5Eibezdjq1LblIeA32ztTxaCRzMHialxxFpOcfUDnw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><h4 id="4-2-1-mmap方式"><a href="#4-2-1-mmap方式" class="headerlink" title="4.2.1 mmap方式"></a>4.2.1 mmap方式</h4><p>mmap是Linux提供的一种内存映射文件的机制，它实现了将内核中读缓冲区地址与用户空间缓冲区地址进行映射，从而实现内核缓冲区与用户缓冲区的共享。</p><p>这样就减少了一次用户态和内核态的CPU拷贝，但是在内核空间内仍然有一次CPU拷贝。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ8N2VL8Qh7vghYXgUU4oR9DTicibzib0KbFCM9Yl1pUcMot5uIyhCh3HNxicfbr3ia6c1jIibzM2S7JkTw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>mmap对大文件传输有一定优势，但是小文件可能出现碎片，并且在多个进程同时操作文件时可能产生引发coredump的signal。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你的程序map了一个文件，但是当这个文件被另一个进程截断(truncate)时, write系统调用会因为访问非法地址而被SIGBUS信号终止</span><br></pre></td></tr></table></figure><h4 id="4-2-2-sendfile方式"><a href="#4-2-2-sendfile方式" class="headerlink" title="4.2.2 sendfile方式"></a>4.2.2 sendfile方式</h4><p>mmap+write方式有一定改进，但是由系统调用引起的状态切换并没有减少。</p><p>sendfile系统调用是在 Linux 内核2.1版本中被引入，它建立了两个文件之间的传输通道。</p><p>sendfile方式只使用一个函数就可以完成之前的read+write 和 mmap+write的功能，这样就少了2次状态切换，由于数据不经过用户缓冲区，因此该数据无法被修改。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ8N2VL8Qh7vghYXgUU4oR9FziaBH9Nxqyf7RTCUET3ErOWnSbevanSiaEibzSN9WaltqPFbDB5QvItg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ8N2VL8Qh7vghYXgUU4oR9dfQ7hicicNHib0P8XbjLKGbIQS2kJ7EdHsCDNvcWAKGjy4vFwByIge0lA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>从图中可以看到，应用程序只需要调用sendfile函数即可完成，只有2次状态切换、1次CPU拷贝、2次DMA拷贝。</p><p>但是sendfile在内核缓冲区和socket缓冲区仍然存在一次CPU拷贝，或许这个还可以优化。</p><h4 id="4-2-3-sendfile-DMA收集"><a href="#4-2-3-sendfile-DMA收集" class="headerlink" title="4.2.3 sendfile+DMA收集"></a>4.2.3 sendfile+DMA收集</h4><p>Linux 2.4 内核对 sendfile 系统调用进行优化，但是需要硬件DMA控制器的配合。</p><p>升级后的sendfile将内核空间缓冲区中对应的数据描述信息（文件描述符、地址偏移量等信息）记录到socket缓冲区中。</p><p>DMA控制器根据socket缓冲区中的地址和偏移量将数据从内核缓冲区拷贝到网卡中，从而省去了内核空间中仅剩1次CPU拷贝。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ8N2VL8Qh7vghYXgUU4oR9qib5USJfo26Ng7qu5Lm1AOzIRpSzpiakpdAoIXPDl1MaQQC5P8ZetStA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>这种方式有2次状态切换、0次CPU拷贝、2次DMA拷贝，但是仍然无法对数据进行修改，并且需要硬件层面DMA的支持，并且sendfile只能将文件数据拷贝到socket描述符上，有一定的局限性。</p><h4 id="4-2-4-splice方式"><a href="#4-2-4-splice方式" class="headerlink" title="4.2.4 splice方式"></a>4.2.4 splice方式</h4><p>splice系统调用是Linux 在 2.6 版本引入的，其不需要硬件支持，并且不再限定于socket上，实现两个普通文件之间的数据零拷贝。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ8N2VL8Qh7vghYXgUU4oR9wDCLQXAMxjvdrXcJYkkBrsiap73VibrS2oBbxricgBoUNXE5pS2TkInmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>splice 系统调用可以在内核缓冲区和socket缓冲区之间建立管道来传输数据，避免了两者之间的 CPU 拷贝操作。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qZ8N2VL8Qh7vghYXgUU4oR9krxghBYaGPgcBOqbYTNVbicYnAiclWiaCzwoRaLocejicVx0rnPNicQ9Hjg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>splice也有一些局限，它的两个文件描述符参数中有一个必须是管道设备。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>for、foreach和Iterator</title>
      <link href="/2020/11/22/for%E3%80%81foreach%E5%92%8CIterator/"/>
      <url>/2020/11/22/for%E3%80%81foreach%E5%92%8CIterator/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-在形式上"><a href="#1-在形式上" class="headerlink" title="1.在形式上"></a>1.在形式上</h3><p>for的形式是<br> <code>for（int i=0;i&lt;arr.size();i++）{...}</code></p><p>foreach的形式是<br> <code>for（int　i：arr）{...}</code></p><p>iterator的形式是</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = arr.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123; <span class="keyword">object</span> o =it.next(); ...&#125;</span><br></pre></td></tr></table></figure><h3 id="2-条件上"><a href="#2-条件上" class="headerlink" title="2.条件上"></a>2.条件上</h3><ul><li>for需要知道集合或数组的大小，而且需要是有序的，不然无法遍历；</li><li>foreach和iterator都不需要知道集合或数组的大小，他们都是得到集合内的每个元素然后进行处理；</li></ul><h3 id="3-多态差别"><a href="#3-多态差别" class="headerlink" title="3.多态差别"></a>3.多态差别</h3><p>for和foreach都需要先知道集合的类型，甚至是集合内元素的类型，即需要访问内部的成员，不能实现态；<br> <strong>iterator</strong>是一个<strong>接口</strong>类型，他不关心集合或者数组的类型，而且他还能随时修改和删除集合的元素，举个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> display（Iterator&lt;<span class="keyword">object</span>&gt; it）&#123;</span><br><span class="line">               <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                     system.<span class="keyword">out</span>.print(it.next()+<span class="string">""</span>);</span><br><span class="line">              &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当我们需要遍历不同的集合时，我们只需要传递集合的iterator（如arr.iterator()）看懂了吧，这就是iterator的好处，他不包含任何有关他所遍历的序列的类型信息，能够将遍历序列的操作与序列底层的结构分离。迭代器统一了对容器的访问方式。这也是接口的解耦的最好体现。</p><h3 id="3-用法差别"><a href="#3-用法差别" class="headerlink" title="3.用法差别"></a>3.用法差别</h3><ul><li>for循环一般用来处理比较简单的有序的，可预知大小的集合或数组</li><li>foreach可用于遍历任何集合或数组，而且操作简单易懂，他唯一的不好就是需要了解集合内部类型</li><li>iterator是最强大的，他可以随时修改或者删除集合内部的元素，并且是在不需要知道元素和集合的类   型的情况下进行的（原因可参考第三点：多态差别），当你需要对不同的容器实现同样的遍历方式时，迭代器是最好的选择！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hyperloglog底层剖析</title>
      <link href="/2020/11/21/hyperloglog%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/"/>
      <url>/2020/11/21/hyperloglog%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>举一个例子，假设你抛很多次硬币，如果抛到正面，就继续抛；如果抛到反面，就记录下在这之前连续抛到了多少次正面k，然后开始下一轮。</p><p>如果你告诉我，你最多的时候，连续抛了2次正面后就抛到反面了。那我认为你可能并没有抛多少轮，可能是3轮或者4轮就会发生这样的情况。</p><p>但如果你告诉我，你最多的时候，连续抛了10次正面后就抛到反面了，那我认为你可能抛的轮次比较多，因为连续抛到10次正面的概率是非常小的。那如果要根据这个已知信息估计你总共抛了多少轮硬币呢？这就是HLL的原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们想想抛硬币，反面记0，正面记1，正反面的概率都是1&#x2F;2。第一次出现正面的位置记为ρ(x)，那么ρ(0001)&#x3D;3，0001出现的概率是1&#x2F;23&#x3D;1&#x2F;16。换句话讲，就是进行16次实验，很可能出现一次或以上0001。再换句话讲，进行n轮实验，最大ρ(x)为y，那么可以估算进行出n&#x3D;2y。</span><br><span class="line">我们可以通过多次抛硬币实验的最大抛到正面的次数来预估总共进行了多少次实验，同样可以可以通过第一个1出现位置的最大值k_max来预估总共有多少个不同的数字（整体基数）。</span><br><span class="line">我们只要把要去重的key，转换成一串01字符串，就能套用上面的统计方法了。在数据量小时，误差会比较大.于是引入了桶的概念，计算m个桶的加权平均值，这样就能得到比较准确的答案了</span><br></pre></td></tr></table></figure><p><img src="/2020/11/21/hyperloglog%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201226154059005.png" alt="image-20201226154059005"></p><ul><li>对于一个输入的字符串，首先得到64位的hash值，用前14位来定位桶的位置（共有 2的14次方 ，即16384个桶）。后面50位即为伯努利过程，每个桶有6bit，记录第一次出现1的位置count，如果count&gt;oldcount，就用count替换oldcount。</li></ul><p>模仿上面的流程，多个不同的用户 id，就被分散到不同的桶中去了，且每个桶有其 k_max。然后当要统计出页面有多少用户点击量的时候，就是一次估算。最终结合所有桶中的 k_max，代入估算公式，便能得出估算值。<br>每个桶有6bit，即[000 000],最大为[111 111]，表示63。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>于是引入了桶的概念，计算m个桶的加权平均值，这样就能得到比较准确的答案了（实际上还要进行其他修正）。最终的公式如图</p><img src="https://user-gold-cdn.xitu.io/2019/3/6/169539f8269d09d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="HyperLogLog公式 hei" style="zoom:80%;"><p>其中m是桶的数量，const是修正常数，它的取值会根据m而变化。p=log2m</p><p>我们回到Redis，对于一个输入的字符串，首先得到64位的hash值，用前14位来定位桶的位置（共有214，即16384个桶）。后面50位即为伯努利过程，每个桶有6bit，记录第一次出现1的位置count，如果count&gt;oldcount，就用count替换oldcount。</p><h3 id="为什么要统计-Hash-值中第一个-1-出现的位置？"><a href="#为什么要统计-Hash-值中第一个-1-出现的位置？" class="headerlink" title="为什么要统计 Hash 值中第一个 1 出现的位置？"></a>为什么要统计 Hash 值中第一个 1 出现的位置？</h3><p>因为第一个 1 出现的位置可以同我们抛硬币的游戏中第一次抛到正面的抛掷次数对应起来，根据上面掷硬币实验的结论，记录每个数据的第一个出现的位置 <code>K</code>，就可以通过其中最大值 Kmax 来推导出数据集合中的基数：<strong>N = 2Kmax</strong></p><h4 id="1-比特串"><a href="#1-比特串" class="headerlink" title="1.比特串"></a>1.比特串</h4><p>通过<code>hash</code>函数，将数据转为<code>比特串</code>，例如输入5，便转为：101。为什么要这样转化呢？</p><p>是因为要和抛硬币对应上，<code>比特串</code>中，0 代表了反面，1 代表了正面，如果一个数据最终被转化了 <code>10010000</code>，那么从右往左，从低位往高位看，我们可以认为，首次出现 1 的时候，就是正面。</p><p>那么基于上面的估算结论，我们可以通过多次抛硬币实验的最大抛到正面的次数来预估总共进行了多少次实验，同样也就可以根据存入数据中，转化后的出现了 1 的最大的位置 k_max 来估算存入了多少数据。</p><h4 id="2-分桶"><a href="#2-分桶" class="headerlink" title="2.分桶"></a>2.分桶</h4><p>在<code>Redis</code>中的<code>HyperLogLog</code>中，共分为<code>2^14</code>个桶，每个桶有<code>6</code>个<code>bit</code>，占用内存为=<code>2^14*6/8/1024=12K</code>。 </p><p><img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c167c6e4e954088bcdc352c5732e99b~tplv-k3u1fbpfcp-zoom-1.image" alt="redis-hyperloglog"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而Redis 最大能够统计的数据量是 264，即每个桶的 maxbit 需要 6 个 bit 来存储，最大可以表示 maxbit &#x3D; 63，于是总共占用内存就是：(214) x 6 &#x2F; 8 (每个桶 6 bit，而这么多桶本身要占用 16384 bit，再除以 8 转换成 KB),算出来的结果就是 12 KB</span><br></pre></td></tr></table></figure><p>当我们执行命令<code>pfadd key value</code>时，首先会通过<code>hash</code>函数将<code>value</code>转换为<code>64</code>位比特串。其中，前14位用来确定分桶(刚好有<code>2^14</code>个桶)，后<code>50</code>位用来获取第一个出现<code>1</code>的位数(从右向左)，因为最大为<code>50</code>，因此使用<code>6</code>个<code>bit</code>完全可以表示。 <img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bae26dd2cd3a47099dc787068ab3db29~tplv-k3u1fbpfcp-zoom-1.image" alt="pfadd"></p><p>不同的<code>value</code>，会被设置到不同桶中去，如果出现了在同一个桶的，但是后面第一个出现<code>1</code>的位数不同。那么比较这个桶新的值是否比原来的值大，如果大于，则替换。否则，保持不变。</p><h3 id="底层源码剖析"><a href="#底层源码剖析" class="headerlink" title="底层源码剖析"></a>底层源码剖析</h3><h3 id="Redis-源码分析"><a href="#Redis-源码分析" class="headerlink" title="Redis 源码分析"></a>Redis 源码分析</h3><p>我们首先来看一下 HyperLogLog 对象的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct hllhdr &#123;</span><br><span class="line">    char magic[4];      &#x2F;* 魔法值 &quot;HYLL&quot; *&#x2F;</span><br><span class="line">    uint8_t encoding;   &#x2F;* 密集结构或者稀疏结构 HLL_DENSE or HLL_SPARSE. *&#x2F;</span><br><span class="line">    uint8_t notused[3]; &#x2F;* 保留位, 全为0. *&#x2F;</span><br><span class="line">    uint8_t card[8];    &#x2F;* 基数大小的缓存 *&#x2F;</span><br><span class="line">    uint8_t registers[]; &#x2F;* 数据字节数组 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>HyperLogLog 对象中的 <code>registers</code> 数组就是桶，它有两种存储结构，分别为密集存储结构和稀疏存储结构，两种结构只涉及存储和桶的表现形式，从中我们可以看到 Redis 对节省内存极致地追求。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/17/16b65c0399c60b74?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="密集存储结构"></p><p>密集型的存储结构非常简单，就是 <strong>16384 个 6 bit 连续串成</strong> 的字符串位图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/2/1709a63dc7ef91de?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>我们都知道，一个字节是由 8 个 bit 组成的，这样 6 bit 排列的结构就会导致，有一些桶会 <strong>跨越字节边界</strong>，我们需要 <strong>对这一个或者两个字节进行适当的移位拼接</strong> 才可以得到具体的计数值。</p><p>假设桶的编号为 <code>index</code>，这个 6 bity 计数值的起始字节偏移用 <code>offset_bytes</code> 表示，它在这个字节的其实比特位置偏移用 <code>offset_bits</code> 表示，于是我们有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">offset_bytes &#x3D; (index * 6) &#x2F; 8</span><br><span class="line">offset_bits &#x3D; (index * 6) % 8</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>前者是商，后者是余数。比如 <code>bucket 2</code> 的字节偏移是 1，也就是第 2 个字节。它的位偏移是 4，也就是第 2 个字节的第 5 个位开始是 bucket 2 的计数值。需要注意的是 <strong>字节位序是左边低位右边高位</strong>，而通常我们使用的字节都是左边高位右边低位。</p><p>这里就涉及到两种情况，<strong>如果 <code>offset_bits</code> 小于等于 2</strong>，说明这 <strong>6 bit 在一个字节的内部</strong>，可以直接使用下面的表达式得到计数值 <code>val</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val &#x3D; buffer[offset_bytes] &gt;&gt; offset_bits  # 向右移位</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>如果 <code>offset_bits</code> 大于 2</strong>，那么就会涉及到 <strong>跨越字节边界</strong>，我们需要拼接两个字节的位片段：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/17/16b65c03caeee530?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="示意图">稀疏存储结构</p><p>稀疏存储适用于很多计数值都是零的情况。下图表示了一般稀疏存储计数值的状态：</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/2/1709a63de16bc015?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>当 <strong>多个连续桶的计数值都是零</strong> 时，Redis 提供了几种不同的表达形式：</p><p>（XX+1）</p><p>(连续多少个桶)</p><ul><li><code>00xxxxxx</code>：前缀两个零表示接下来的 6bit 整数值加 1 就是零值计数器的数量，注意这里要加 1 是因为数量如果为零是没有意义的。比如 <code>00010101</code> 表示连续 <code>22</code> 个桶为0。</li><li><code>01xxxxxx yyyyyyyy</code>：6bit 最多只能表示连续 <code>64</code> 个零值计数器，这样扩展出的  14bit 可以表示最多连续 <code>16384</code> 个桶计数值。这意味着 HyperLogLog 数据结构中 <code>16384</code> 个桶的初始状态，所有的计数器都是零值，可以直接使用 2 个字节来表示。</li><li><code>1vvvvvxx</code>：中间 5bit 表示计数值，尾部 2bit 表示连续几个桶。它的意思是连续 <code>(xx +1)</code> 个桶计数值都是 <code>(vvvvv + 1)</code>。比如 <code>10101011</code> 表示连续 <code>4</code> 个计数值都是 <code>11</code>。</li></ul><p>1vvvvxx (xx+1)-&gt; (vvvv+1)</p><p>注意</p><p>上面第三种方式</p><p> 的计数值最大只能表示到 <code>32</code>，而 HyperLogLog 的密集存储单个计数值用 6bit 表示，最大可以表示到 <code>63</code>。<strong>当稀疏存储的某个计数值需要调整到大于 <code>32</code> 时，Redis 就会立即转换 HyperLogLog 的存储结构，将稀疏存储转换成密集存储。</strong></p><p>作者：我没有三颗心脏<br>链接：<a href="https://juejin.cn/post/6844904079601188877" target="_blank" rel="noopener">https://juejin.cn/post/6844904079601188877</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目描述</title>
      <link href="/2020/11/20/%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0/"/>
      <url>/2020/11/20/%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>社区论坛项目</strong></p><p><strong>项目描述</strong>：该项目是设计一个社区论坛，方便用户发言与讨论</p><p><strong>使用技术</strong>：本项目使用SpringBoot进行开发，使用的技术主要有 MySQL，Redis , Kafka , Quartz</p><p><strong>主要功能</strong>：登录注册，发帖评论，点赞关注，消息提醒，热帖排行</p><p><strong>项目亮点</strong>：</p><ul><li><p>通过Kaptcha来生成验证码图片，作登录和注册的验证。</p></li><li><p>通过自定义注解和拦截器，防止用户在未登录的情况下通过url访问没有权限的页面。</p></li><li><p>利用数据结构Trie实现前缀树，对发表帖子评论进行简单的敏感词过滤。</p></li><li><p>对点赞关注等高频功能利用Redis的Set来提升性能，并通过Redis的Hyperloglog统计UV, Bitmap统计DAU。</p></li><li><p>利用Kafka来实现消息提醒功能，起到异步和解耦的功能。</p></li><li><p>利用本地缓存优化社区主页的加载，测试其QPS从9提高到196。</p></li></ul><p><strong>分布式RPC框架</strong></p><p><strong>项目描述</strong>：该项目是编写一个RPC调度框架，实现跨服务调度</p><p><strong>使用技术</strong>：本项目使用的技术主要有Netty, Kryo , Hook</p><p><strong>主要功能</strong>：实现了网络传输，注册中心，序列化，动态均衡，自动注销服务等功能</p><p><strong>项目亮点</strong>：</p><ul><li><p>通过Netty基于Nio的方式实现了网络传输。</p></li><li><p>通过自定义编码器解码器，使用Kryo的方式实现了数据格式的序列化。</p></li><li><p>使用Nacos方式实现服务的注册与发现，并使用ConcurrentHashMap来重用服务。</p></li><li><p>实现了随机算法和轮询算法来实现负载均衡。</p></li><li><p>使用单例模式获取Runtime 对象，采用线程池的方式实现服务的注销。</p></li><li><p>基于注解进行服务的自动注册，避免了手动创建服务对象</p></li></ul><p><strong>专业技能栏</strong></p><p>语言能力：英语CET4 (527) ，英语CET6（511）</p><p>Java基础 ：基础扎实，了解各种关键字，熟悉反射，继承，面向对象等相关知识</p><p>虚拟机：掌握JVM运行数据区，垃圾收集算法，垃圾收集器，内存分配策略等</p><p>并发：了解AQS，ReentrantLock，Synchronized，CAS，线程池等的源码分析及其原理</p><p>Redis：掌握Redis五种数据结构的底层实现，Redis主从复制，集群同步的相关原理</p><p>数据库：了解事务相关特性，B+树的索引原理等</p><p>数据结构与算法：掌握常用的数据结构（栈，队列，树等）和排序算法（冒泡，快排，堆排等）</p><p>计算机网络：掌握TCP/IP网络模型，掌握TCP、UDP、HTTP等协议</p><p>数据结构与算法：掌握常用的数据结构（栈，队列，树等）和排序算法（冒泡，快排，堆排等）</p><p>操作系统：掌握进程线程概念，进程通信，进程同步，线程同步和死锁等</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rpc项目总结</title>
      <link href="/2020/11/19/rpc%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2020/11/19/rpc%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>分布式RPC框架</strong></p><p><strong>项目描述</strong>：该项目是编写一个RPC调度框架，实现跨服务调度</p><p><strong>使用技术</strong>：本项目使用的技术主要有Netty, Kryo , Hook</p><p><strong>主要功能</strong>：实现了网络传输，注册中心，序列化，动态均衡，自动注销服务等功能</p><p><strong>项目亮点</strong>：</p><p>1、 通过 Netty基于 Nio的方式实现了网络传输。<br>2、 自定义编码器解码器，并使用自定义的协议来封装消息。<br>3、 使用 Kryo的方式实现了数据格式的序列化，提升效率。<br>4、 使用 Nacos作为注册中心，并使用 ConcurrentHashMap来重用服务。<br>5、 实现了随机算法和轮询算法来实现负载均衡。<br>6、 使用单例模式获取 Runtime 对象，采用 线程池 的方式实现服务的注销。</p><h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>客户端启动过程：我们会先new一个NettyClient的对象，</p><ul><li>这个对象有服务发现的功能 (NacosUtil.getAllInstance(serviceName))</li><li>随后有一个select方法，根据我们选择的策略进行发现（ Instance instance = loadBalancer.select(instances);)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class NacosServiceDiscovery implements ServiceDiscovery &#123;</span><br><span class="line">    ...</span><br><span class="line">    public NacosServiceDiscovery(LoadBalancer loadBalancer) &#123;</span><br><span class="line">        if(loadBalancer &#x3D;&#x3D; null) this.loadBalancer &#x3D; new RandomLoadBalancer();</span><br><span class="line">        else this.loadBalancer &#x3D; loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    @Override</span><br><span class="line">    public InetSocketAddress lookupService(String serviceName) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;Instance&gt; instances &#x3D; NacosUtil.getAllInstance(serviceName);</span><br><span class="line">            Instance instance &#x3D; loadBalancer.select(instances);</span><br><span class="line">            return new InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; catch (NacosException e) &#123;</span><br><span class="line">            logger.error(&quot;获取服务时有错误发生:&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还有sendRequest发送消息的功能。</li></ul><p>接下来new一个代理方法，传入这个NettyClient对象，我们会通过代理消息发送的功能，然后在invoke方法里进行功能增强。</p><p>具体功能的增强就是把我们要调用的服务具体信息包装成一个RpcRequest，里面有请求号，接口名称，调用方法名称，调用方法的参数，调用方法的参数类型，是否是心跳包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RpcRequest rpcRequest &#x3D; new RpcRequest(UUID.randomUUID().toString(), method.getDeclaringClass().getName(),</span><br><span class="line">        method.getName(), args, method.getParameterTypes(), false);</span><br></pre></td></tr></table></figure><p>接下来调用NettyClient的发送方法，返回值会封装在CompletableFuture<Respnose>里面，调用服务发现功能，根据接口的名称获取地址,放在InetSocketAddress里面</Respnose></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InetSocketAddress inetSocketAddress &#x3D; serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br></pre></td></tr></table></figure><p>取到地址后我们就可以根据地址，调用Netty进行发送消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel channel &#x3D; ChannelProvider.get(inetSocketAddress, serializer);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class ChannelProvider &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(ChannelProvider.class);</span><br><span class="line">    private static EventLoopGroup eventLoopGroup;</span><br><span class="line">    private static Bootstrap bootstrap &#x3D; initializeBootstrap();</span><br><span class="line"></span><br><span class="line">    private static Map&lt;String, Channel&gt; channels &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static Channel get(InetSocketAddress inetSocketAddress, CommonSerializer serializer) throws InterruptedException &#123;</span><br><span class="line">        String key &#x3D; inetSocketAddress.toString() + serializer.getCode();</span><br><span class="line">        if (channels.containsKey(key)) &#123;</span><br><span class="line">            Channel channel &#x3D; channels.get(key);</span><br><span class="line">            if(channels !&#x3D; null &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                return channel;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                channels.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                &#x2F;*自定义序列化编解码器*&#x2F;</span><br><span class="line">                &#x2F;&#x2F; RpcResponse -&gt; ByteBuf</span><br><span class="line">                ch.pipeline().addLast(new CommonEncoder(serializer))</span><br><span class="line">                        .addLast(new IdleStateHandler(0, 5, 0, TimeUnit.SECONDS))</span><br><span class="line">                        .addLast(new CommonDecoder())</span><br><span class="line">                        .addLast(new NettyClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Channel channel &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            channel &#x3D; connect(bootstrap, inetSocketAddress);</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            logger.error(&quot;连接客户端时有错误发生&quot;, e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        channels.put(key, channel);</span><br><span class="line">        return channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Channel connect(Bootstrap bootstrap, InetSocketAddress inetSocketAddress) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Channel&gt; completableFuture &#x3D; new CompletableFuture&lt;&gt;();</span><br><span class="line">        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            if (future.isSuccess()) &#123;</span><br><span class="line">                logger.info(&quot;客户端连接成功!&quot;);</span><br><span class="line">                completableFuture.complete(future.channel());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return completableFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Bootstrap initializeBootstrap() &#123;</span><br><span class="line">        eventLoopGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap &#x3D; new Bootstrap();</span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                &#x2F;&#x2F;连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)</span><br><span class="line">                &#x2F;&#x2F;是否开启 TCP 底层心跳机制</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                &#x2F;&#x2F;TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, true);</span><br><span class="line">        return bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在pipeline里自定义编码器，设置心跳时间，设置解码器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) &#123;</span><br><span class="line">        &#x2F;*自定义序列化编解码器*&#x2F;</span><br><span class="line">        &#x2F;&#x2F; RpcResponse -&gt; ByteBuf</span><br><span class="line">        ch.pipeline().addLast(new CommonEncoder(serializer))</span><br><span class="line">                .addLast(new IdleStateHandler(0, 5, 0, TimeUnit.SECONDS))</span><br><span class="line">                .addLast(new CommonDecoder())</span><br><span class="line">                .addLast(new NettyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后连接服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel &#x3D; connect(bootstrap, inetSocketAddress);</span><br></pre></td></tr></table></figure><p>设置连接的监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static Channel connect(Bootstrap bootstrap, InetSocketAddress inetSocketAddress) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;Channel&gt; completableFuture &#x3D; new CompletableFuture&lt;&gt;();</span><br><span class="line">    bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">        if (future.isSuccess()) &#123;</span><br><span class="line">            logger.info(&quot;客户端连接成功!&quot;);</span><br><span class="line">            completableFuture.complete(future.channel());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return completableFuture.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置发送消息的监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">channel.writeAndFlush(rpcRequest).addListener((ChannelFutureListener) future1 -&gt; &#123;</span><br><span class="line">    if (future1.isSuccess()) &#123;</span><br><span class="line">        logger.info(String.format(&quot;客户端发送消息: %s&quot;, rpcRequest.toString()));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        future1.channel().close();</span><br><span class="line">        resultFuture.completeExceptionally(future1.cause());</span><br><span class="line">        logger.error(&quot;发送消息时有错误发生: &quot;, future1.cause());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.writeAndFlush(rpcRequest)</span><br></pre></td></tr></table></figure><h3 id="获取服务名字"><a href="#获取服务名字" class="headerlink" title="获取服务名字"></a>获取服务名字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NacosUtil.getAllInstance(serviceName);</span><br></pre></td></tr></table></figure><h4 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadBalancer.select(instances);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return instances.get(new Random().nextInt(instances.size()));</span><br></pre></td></tr></table></figure><h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><p>客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.addLast(new IdleStateHandler(0, 5, 0, TimeUnit.SECONDS))</span><br></pre></td></tr></table></figure><p>1）readerIdleTime：为读超时时间（即测试端一定时间内未接受到被测试端消息）</p><p>2）writerIdleTime：为写超时时间（即测试端一定时间内向被测试端发送消息）</p><p>3）allIdleTime：所有类型的超时时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">        if (evt instanceof IdleStateEvent) &#123;</span><br><span class="line">            IdleState state &#x3D; ((IdleStateEvent) evt).state();</span><br><span class="line">            if (state &#x3D;&#x3D; IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                logger.info(&quot;发送心跳包 [&#123;&#125;]&quot;, ctx.channel().remoteAddress());</span><br><span class="line">                Channel channel &#x3D; ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">                RpcRequest rpcRequest &#x3D; new RpcRequest();</span><br><span class="line">                rpcRequest.setHeartBeat(true);</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">    if (evt instanceof IdleStateEvent) &#123;</span><br><span class="line">        IdleState state &#x3D; ((IdleStateEvent) evt).state();</span><br><span class="line">        if (state &#x3D;&#x3D; IdleState.READER_IDLE) &#123;</span><br><span class="line">            logger.info(&quot;长时间未收到心跳包，断开连接...&quot;);</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        super.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br></pre></td></tr></table></figure><p>在NettyClientHandler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unprocessedRequests.complete(msg);</span><br></pre></td></tr></table></figure><p>在sendRequest方法里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br></pre></td></tr></table></figure><h3 id="kyrio序列化"><a href="#kyrio序列化" class="headerlink" title="kyrio序列化"></a>kyrio序列化</h3><p>Kryo序列化机制比默认的Java序列化机制速度要快，序列化后的数据要更小，大概是Java序列化机制的1/10。所以Kryo序列化优化以后，可以让网络传输的数据变少，在集群中耗费的内存资源大大减少。</p><p><a href="https://www.cnblogs.com/520playboy/p/6341490.html" target="_blank" rel="noopener">https://www.cnblogs.com/520playboy/p/6341490.html</a></p><p>java原生序列化时间:8281 ms<br>java原生反序列化时间:5899 ms</p><p>和</p><p>Kryo 序列化时间:630 ms<br>Kryo 反序列化时间:15 ms</p><p>经过对比，可以发现kryo是java原生序列化性能十几倍</p><p>1、Kryo序列化后比Hessian小很多。（kryo优于hessian）</p><p>2、由于Kryo没有将类field的描述信息序列化，所以Kryo需要以自己加载该类的filed。这意味着如果该类没有在kryo中注册，或者该类是第一次被kryo序列化时，kryo需要时间去加载该类（hessian优于kryo）</p><p>3、由于2的原因，如果该类已经被kryo加载过，那么kryo保存了其类的信息，就可以很快的将byte数组填入到类的field中,而hessian则需要解析序列化后的byte数组中的field信息，对于序列化过的类，kryo优于hessian。</p><p><img src="/2020/11/19/rpc%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201229165346572.png" alt="image-20201229165346572"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Kryo序列化类，Kryo序列化效率很高，但是只兼容 Java 语言</span><br><span class="line"> *</span><br><span class="line"> * @author shuang.kou</span><br><span class="line"> * @createTime 2020年05月13日 19:29:00</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Slf4j</span><br><span class="line">public class KryoSerializer implements Serializer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 由于 Kryo 不是线程安全的。每个线程都应该有自己的 Kryo，Input 和 Output 实例。</span><br><span class="line">     * 所以，使用 ThreadLocal 存放 Kryo 对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final ThreadLocal&lt;Kryo&gt; kryoThreadLocal &#x3D; ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        Kryo kryo &#x3D; new Kryo();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        kryo.setReferences(true); &#x2F;&#x2F;默认值为true,是否关闭注册行为,关闭之后可能存在序列化问题，一般推荐设置为 true</span><br><span class="line">        kryo.setRegistrationRequired(false); &#x2F;&#x2F;默认值为false,是否关闭循环引用，可以提高性能，但是一般不推荐设置为 true</span><br><span class="line">        return kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte[] serialize(Object obj) &#123;</span><br><span class="line">        try (ByteArrayOutputStream byteArrayOutputStream &#x3D; new ByteArrayOutputStream();</span><br><span class="line">             Output output &#x3D; new Output(byteArrayOutputStream)) &#123;</span><br><span class="line">            Kryo kryo &#x3D; kryoThreadLocal.get();</span><br><span class="line">            &#x2F;&#x2F; Object-&gt;byte:将对象序列化为byte数组</span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            return output.toBytes();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new SerializeException(&quot;序列化失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T deserialize(byte[] bytes, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        try (ByteArrayInputStream byteArrayInputStream &#x3D; new ByteArrayInputStream(bytes);</span><br><span class="line">             Input input &#x3D; new Input(byteArrayInputStream)) &#123;</span><br><span class="line">            Kryo kryo &#x3D; kryoThreadLocal.get();</span><br><span class="line">            &#x2F;&#x2F; byte-&gt;Object:从byte数组中反序列化出对对象</span><br><span class="line">            Object o &#x3D; kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            return clazz.cast(o);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new SerializeException(&quot;反序列化失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><h4 id="自定义协议与编解码器"><a href="#自定义协议与编解码器" class="headerlink" title="自定义协议与编解码器"></a>自定义协议与编解码器</h4><p>在传输过程中，我们可以在发送的数据上加上各种必要的数据，形成自定义的协议，而自动加上这个数据就是编码器的工作，解析数据获得原始数据就是解码器的工作。</p><p>我们定义的协议是这样的：</p><p><img src="/2020/11/19/rpc%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201120101454330.png" alt="image-20201120101454330"></p><p>首先是 4 字节魔数，表识一个协议包。接着是 Package Type，标明这是一个调用请求还是调用响应，Serializer Type 标明了实际数据使用的序列化器，这个服务端和客户端应当使用统一标准；Data Length 就是实际数据的长度，设置这个字段主要防止<strong>粘包</strong>，最后就是经过序列化后的实际数据，可能是 RpcRequest 也可能是 RpcResponse 经过序列化后的字节，取决于 Package Type。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CommonEncoder extends MessageToByteEncoder</span><br><span class="line">&#123;</span><br><span class="line">  protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception &#123;</span><br><span class="line">     out.writeInt(MAGIC_NUMBER);</span><br><span class="line">     if (msg instanceof RpcRequest) &#123;</span><br><span class="line">         out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">     &#125;</span><br><span class="line">     out.writeInt(serializer.getCode());</span><br><span class="line">     byte[] bytes &#x3D; serializer.serialize(msg);</span><br><span class="line">     out.writeInt(bytes.length);</span><br><span class="line">     out.writeBytes(bytes);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CommonDecoder extends ReplayingDecoder</span><br><span class="line">&#123;</span><br><span class="line">protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">        int magic &#x3D; in.readInt();</span><br><span class="line">        if (magic !&#x3D; MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(&quot;不识别的协议包: &#123;&#125;&quot;, magic);</span><br><span class="line">            throw new RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        int packageCode &#x3D; in.readInt();</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        if (packageCode &#x3D;&#x3D; PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass &#x3D; RpcRequest.class;</span><br><span class="line">        &#125; else if (packageCode &#x3D;&#x3D; PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass &#x3D; RpcResponse.class;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.error(&quot;不识别的数据包: &#123;&#125;&quot;, packageCode);</span><br><span class="line">            throw new RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        int serializerCode &#x3D; in.readInt();</span><br><span class="line">        CommonSerializer serializer &#x3D; CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        if (serializer &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;不识别的反序列化器: &#123;&#125;&quot;, serializerCode);</span><br><span class="line">            throw new RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        int length &#x3D; in.readInt();</span><br><span class="line">        byte[] bytes &#x3D; new byte[length];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        Object obj &#x3D; serializer.deserialize(bytes, packageClass);</span><br><span class="line">        out.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception &#123;</span><br><span class="line">    out.writeInt(MAGIC_NUMBER);</span><br><span class="line">    if (msg instanceof RpcRequest) &#123;</span><br><span class="line">        out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">    out.writeInt(serializer.getCode());</span><br><span class="line">    byte[] bytes &#x3D; serializer.serialize(msg);</span><br><span class="line">    out.writeInt(bytes.length);</span><br><span class="line">    out.writeBytes(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class KryoSerializer implements CommonSerializer &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(KryoSerializer.class);</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;Kryo&gt; kryoThreadLocal &#x3D; ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        Kryo kryo &#x3D; new Kryo();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        kryo.setReferences(true);</span><br><span class="line">        kryo.setRegistrationRequired(false);</span><br><span class="line">        return kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public byte[] serialize(Object obj) &#123;</span><br><span class="line">        try (ByteArrayOutputStream byteArrayOutputStream &#x3D; new ByteArrayOutputStream();</span><br><span class="line">             Output output &#x3D; new Output(byteArrayOutputStream)) &#123;</span><br><span class="line">            Kryo kryo &#x3D; kryoThreadLocal.get();</span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            return output.toBytes();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;序列化时有错误发生:&quot;, e);</span><br><span class="line">            throw new SerializeException(&quot;序列化时有错误发生&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object deserialize(byte[] bytes, Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        try (ByteArrayInputStream byteArrayInputStream &#x3D; new ByteArrayInputStream(bytes);</span><br><span class="line">             Input input &#x3D; new Input(byteArrayInputStream)) &#123;</span><br><span class="line">            Kryo kryo &#x3D; kryoThreadLocal.get();</span><br><span class="line">            Object o &#x3D; kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            return o;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;反序列化时有错误发生:&quot;, e);</span><br><span class="line">            throw new SerializeException(&quot;反序列化时有错误发生&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCode() &#123;</span><br><span class="line">        return SerializerCode.valueOf(&quot;KRYO&quot;).getCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NettyServerHandler-和-NettyClientHandler"><a href="#NettyServerHandler-和-NettyClientHandler" class="headerlink" title="NettyServerHandler 和 NettyClientHandler"></a>NettyServerHandler 和 NettyClientHandler</h4><h3 id="（Server）汇总"><a href="#（Server）汇总" class="headerlink" title="（Server）汇总"></a>（Server）汇总</h3><p>对于Server端来说，先初始化一个服务(HelloService),再启动一个NettyServer</p><ul><li><p>这个NettyServer会在构造器里初始化 host、port和serviceRegistry方法以及serviceProvider方法。前者是Nacos服务注册中心，用于向nacos注册和获取服务，后者是本地保存和提供服务实例对象</p></li><li><p>除此之外，还有一个publishService，它会传入服务（object）和接口的类，然后在这个类里，调用相应的方法，把服务保存本地，然后向nacos注册</p></li><li><p>会在 start()方法里，初始化ServerBoostrap,自定义编码器和解码器，添加handler,绑定相应的ip地址和端口号进行监听</p></li></ul><h4 id="NacosServiceRegistry"><a href="#NacosServiceRegistry" class="headerlink" title="NacosServiceRegistry"></a>NacosServiceRegistry</h4><p>静态代码块li向nacos进行注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class NacosUtil &#123;</span><br><span class="line">  ....</span><br><span class="line">  public void register(String serviceName, InetSocketAddress inetSocketAddress) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          namingService.registerInstance(serviceName, inetSocketAddress.getHostName(), inetSocketAddress.getPort());&#x2F;&#x2F;top.guoziyang.rpc.api.HelloService</span><br><span class="line">      &#125; catch (NacosException e) &#123;</span><br><span class="line">          logger.error(&quot;注册服务时有错误发生:&quot;, e);</span><br><span class="line">          throw new RpcException(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  namingService&#x3D;NamingFactory.createNamingService(SERVER_ADDR);</span><br></pre></td></tr></table></figure><h4 id="ServiceProviderImpl-默认的服务注册表，保存服务端本地服务"><a href="#ServiceProviderImpl-默认的服务注册表，保存服务端本地服务" class="headerlink" title="ServiceProviderImpl(默认的服务注册表，保存服务端本地服务)"></a>ServiceProviderImpl(默认的服务注册表，保存服务端本地服务)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final Map&lt;String, Object&gt; serviceMap &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">private static final Set&lt;String&gt; registeredService &#x3D; ConcurrentHashMap.newKeySet();</span><br><span class="line">addServiceProvider(T service)</span><br><span class="line">getServiceProvider(String serviceName)</span><br></pre></td></tr></table></figure><p>向registeredService  集合添加服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registeredService.add(serviceName);</span><br></pre></td></tr></table></figure><p>向serviceMap里放入服务的名字和具体的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceMap.put(serviceName, service);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; void addServiceProvider(T service, Class&lt;T&gt; serviceClass) &#123;&#x2F;&#x2F;top.guoziyang.rpc.api.HelloService  &#x2F;&#x2F;interface top.guoziyang.rpc.api.HelloService</span><br><span class="line">    String serviceName &#x3D; serviceClass.getCanonicalName();</span><br><span class="line">    if (registeredService.contains(serviceName)) return;&#x2F;&#x2F;重用服务</span><br><span class="line">    registeredService.add(serviceName);</span><br><span class="line">    serviceMap.put(serviceName, service);</span><br><span class="line">    logger.info(&quot;向接口: &#123;&#125; 注册服务: &#123;&#125;&quot;, service.getClass().getInterfaces(), serviceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .handler(new LoggingHandler(LogLevel.INFO))</span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, 256)</span><br><span class="line">        .option(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">        .childOption(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">        .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">                ChannelPipeline pipeline &#x3D; ch.pipeline();</span><br><span class="line">                pipeline.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS))</span><br><span class="line">                        .addLast(new CommonEncoder(serializer))</span><br><span class="line">                        .addLast(new CommonDecoder())</span><br><span class="line">                        .addLast(new NettyServerHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">ChannelFuture future &#x3D; serverBootstrap.bind(host, port).sync();</span><br><span class="line">future.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure><h4 id="NettyServerhandler"><a href="#NettyServerhandler" class="headerlink" title="NettyServerhandler"></a>NettyServerhandler</h4><p>初始化一个线程池,线程池里调用requestHandler，这个requestHandler用于处理客户端传过来的rpcRequest, 通过serviceProvider和传过来的rpcRequest的接口，返回一个服务，并返回相应的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestHandler.handle(msg);</span><br></pre></td></tr></table></figure><p>调用requestHandler来处理信息</p><p>这个requestHandler通过本地的serviceProvider来处理信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object service &#x3D; serviceProvider.getServiceProvider(rpcRequest.getInterfaceName());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public Object getServiceProvider(String serviceName) &#123;</span><br><span class="line">       Object service &#x3D; serviceMap.get(serviceName);</span><br><span class="line">       if (service &#x3D;&#x3D; null) &#123;</span><br><span class="line">           throw new RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">       &#125;</span><br><span class="line">       return service;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过反射来获取相应的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method &#x3D; service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">result &#x3D; method.invoke(service, rpcRequest.getParameters());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.writeAndFlush(RpcResponse.success(result, msg.getRequestId())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; RpcResponse&lt;T&gt; success(T data, String requestId) &#123;</span><br><span class="line">    RpcResponse&lt;T&gt; response &#x3D; new RpcResponse&lt;&gt;();</span><br><span class="line">    response.setRequestId(requestId);</span><br><span class="line">    response.setStatusCode(ResponseCode.SUCCESS.getCode());</span><br><span class="line">    response.setData(data);</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; RpcResponse&lt;T&gt; success(T data, String requestId) &#123;</span><br><span class="line">    RpcResponse&lt;T&gt; response &#x3D; new RpcResponse&lt;&gt;();</span><br><span class="line">    response.setRequestId(requestId);</span><br><span class="line">    response.setStatusCode(ResponseCode.SUCCESS.getCode());</span><br><span class="line">    response.setData(data);</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务自动注销"><a href="#服务自动注销" class="headerlink" title="服务自动注销"></a>服务自动注销</h3><p>注销的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class NacosUtil &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public static NamingService getNacosNamingService() </span><br><span class="line"></span><br><span class="line">    public static void registerService(String serviceName, InetSocketAddress address) </span><br><span class="line"></span><br><span class="line">    public static List&lt;Instance&gt; getAllInstance(String serviceName) </span><br><span class="line"></span><br><span class="line">    public static void clearRegistry() &#123;</span><br><span class="line">        if(!serviceNames.isEmpty() &amp;&amp; address !&#x3D; null) &#123;</span><br><span class="line">            String host &#x3D; address.getHostName();</span><br><span class="line">            int port &#x3D; address.getPort();</span><br><span class="line">            Iterator&lt;String&gt; iterator &#x3D; serviceNames.iterator();</span><br><span class="line">            while(iterator.hasNext()) &#123;</span><br><span class="line">                String serviceName &#x3D; iterator.next();</span><br><span class="line">                try &#123;</span><br><span class="line">                    namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">                &#125; catch (NacosException e) &#123;</span><br><span class="line">                    logger.error(&quot;注销服务 &#123;&#125; 失败&quot;, serviceName, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>钩子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ShutdownHook &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(ShutdownHook.class);</span><br><span class="line"></span><br><span class="line">    private final ExecutorService threadPool &#x3D; ThreadPoolFactory.createDefaultThreadPool(&quot;shutdown-hook&quot;);</span><br><span class="line">    private static final ShutdownHook shutdownHook &#x3D; new ShutdownHook();</span><br><span class="line"></span><br><span class="line">    public static ShutdownHook getShutdownHook() &#123;</span><br><span class="line">        return shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addClearAllHook() &#123;</span><br><span class="line">        logger.info(&quot;关闭后将自动注销所有服务&quot;);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了单例模式创建其对象，在 addClearAllHook 中，Runtime 对象是 JVM 虚拟机的运行时环境，调用其 addShutdownHook 方法增加一个钩子函数，创建一个新线程调用 clearRegistry 方法完成注销工作。这个钩子函数会在 JVM 关闭之前被调用。</p><p>这样在 RpcServer 启动之前，只需要调用 addClearAllHook，就可以注册这个钩子了。例如在 NettyServer 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future &#x3D; serverBootstrap.bind(host, port).sync();</span><br><span class="line">ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">future.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>负载均衡大家应该都熟悉，在上一节中客户端在 lookupService 方法中，从 Nacos 获取到的是所有提供这个服务的服务端信息列表，我们就需要从中选择一个，这便涉及到客户端侧的负载均衡策略。我们新建一个接口：LoadBalancer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line">    <span class="function">Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>接口中的 select 方法用于从一系列 Instance 中选择一个。这里我就实现两个比较经典的算法：随机和转轮。</p><p>随机算法顾名思义，就是随机选一个，毫无技术含量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instances.get(<span class="keyword">new</span> Random().nextInt(instances.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而转轮算法大家也应该了解，按照顺序依次选择第一个、第二个、第三个……这里就需要一个变量来表示当前选到了第几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= instances.size()) &#123;</span><br><span class="line">            index %= instances.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instances.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index 就表示当前选到了第几个服务器，并且每次选择后都会自增一。</p><p>最后在 NacosServiceRegistry 中集成就可以了，这里选择外部传入的方式传入 LoadBalancer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class NacosServiceDiscovery implements ServiceDiscovery &#123;</span><br><span class="line">    private final LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    public NacosServiceDiscovery(LoadBalancer loadBalancer) &#123;</span><br><span class="line">        if(loadBalancer &#x3D;&#x3D; null) this.loadBalancer &#x3D; new RandomLoadBalancer();</span><br><span class="line">        else this.loadBalancer &#x3D; loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public InetSocketAddress lookupService(String serviceName) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;Instance&gt; instances &#x3D; NacosUtil.getAllInstance(serviceName);</span><br><span class="line">            Instance instance &#x3D; loadBalancer.select(instances);</span><br><span class="line">            return new InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; catch (NacosException e) &#123;</span><br><span class="line">            logger.error(&quot;获取服务时有错误发生:&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务自动注册"><a href="#服务自动注册" class="headerlink" title="服务自动注册"></a>服务自动注册</h3><h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><p>首先我们需要定义两个注解：Service 和 ServiceScan：</p><p>Service.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceScan.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Service 放在一个类上，标识这个类提供一个服务，@ServiceScan 放在启动的入口类上（main 方法所在的类），标识服务的扫描的包的范围。Service 注解的值定义为该服务的名称，默认值是该类的完整类名，而 ServiceScan 的值定义为扫描范围的根包，默认值为入口类所在的包，扫描时会扫描该包及其子包下所有的类，找到标记有 Service 的类，并注册。</p><h4 id="工具类ReflectUtil"><a href="#工具类ReflectUtil" class="headerlink" title="工具类ReflectUtil"></a>工具类ReflectUtil</h4><p>主要就是 <code>getClasses</code> 方法，传入一个包名，用于扫描该包及其子包下所有的类，并将其 Class 对象放入一个 Set 中返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectUtil &#123;</span><br><span class="line">    public static Set&lt;Class&lt;?&gt;&gt; getClasses(String packageName) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void findAndAddClassesInPackageByFile&#123;</span><br><span class="line">            &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扫描服务"><a href="#扫描服务" class="headerlink" title="扫描服务"></a>扫描服务</h3><p>由于扫描服务这一步是一个比较公共的方法，无论是 Socket 还是 Netty 的服务端都需要这个方法，于是我对项目做了一点重构，使用了一个抽象类 AbstractRpcServer 实现了 RpcServer 接口，而 NettyServer 和 SocketServer 继承自 AbstractRpcServer，将 scanServices 方法放在抽象类中，而 start 方法则由具体实现类来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void scanServices() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先需要获得要扫描的包的范围，就需要获取到 ServiceScan 注解的值，而我们前面说过，这个注解是加在启动类上的，那么，我们怎么知道启动类是哪一个呢？答案是通过调用栈。方法的调用和返回是通过方法调用栈来实现的，当调用一个方法时，该方法入栈，该方法返回时，该方法出站，控制回到栈顶的方法。那么，main 方法一定位于调用栈的最底端，在 ReflectUtils 中，我写了一个 getStackTrace 方法（名字起得不好），用于获取 main 所在的类。通过 Class 对象的 isAnnotationPresent 方法来判断该类是否有 ServiceScan 注解。如果有，通过<code>startClass.getAnnotation(ServiceScan.class).value();</code> 获取注解的值。</p><p>当获得扫描的范围后，就可以通过<code>ReflectUtil.getClasses(basePackage)</code> 获取到所有的 Class 了，逐个判断是否有 Service 注解，如果有的话，通过反射创建该对象，并且调用 publishService 注册即可。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Instance select(List&lt;Instance&gt; instances) &#123;</span><br><span class="line">    if(index &gt;&#x3D; instances.size()) &#123;</span><br><span class="line">        index %&#x3D; instances.size();</span><br><span class="line">    &#125;</span><br><span class="line">    return instances.get(index++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Runtime（服务注销）"><a href="#Runtime（服务注销）" class="headerlink" title="Runtime（服务注销）"></a>Runtime（服务注销）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void clearRegistry() &#123;</span><br><span class="line">    if(!serviceNames.isEmpty() &amp;&amp; address !&#x3D; null) &#123;</span><br><span class="line">        String host &#x3D; address.getHostName();</span><br><span class="line">        int port &#x3D; address.getPort();</span><br><span class="line">        Iterator&lt;String&gt; iterator &#x3D; serviceNames.iterator();</span><br><span class="line">        while(iterator.hasNext()) &#123;</span><br><span class="line">            String serviceName &#x3D; iterator.next();</span><br><span class="line">            try &#123;</span><br><span class="line">                namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">            &#125; catch (NacosException e) &#123;</span><br><span class="line">                logger.error(&quot;注销服务 &#123;&#125; 失败&quot;, serviceName, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开启自动注册并测试"><a href="#开启自动注册并测试" class="headerlink" title="开启自动注册并测试"></a>开启自动注册并测试</h2><p>以 NettyServer 为例，在 NettyServer 的构造方法最后，调用 scanServices 方法，即可自动注册所有服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port, Integer serializer)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.host = host;</span><br><span class="line">      <span class="keyword">this</span>.port = port;</span><br><span class="line">      serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">      serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">      <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">      scanServices();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>不要忘了在 HelloServiceImpl 类上加上 @service 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在服务器启动类上加上注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServiceScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NettyServer server = <span class="keyword">new</span> NettyServer(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>, CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用启动类所在的包作为扫描根包。</p><p>启动类变得无比简洁！启动后应该能看到和之前相同的结果</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ThreadPoolExecutor(10, 100, 1, 分钟, 数组（10）, threadFactory)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.简单的实现</title>
      <link href="/2020/11/19/1-%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/11/19/1-%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_40856284/article/details/106972652" target="_blank" rel="noopener">https://blog.csdn.net/qq_40856284/article/details/106972652</a></p><p>本章对应的commit为<a href="https://github.com/CN-GuoZiyang/My-RPC-Framework/commit/73aa960b0c457770859f81a3210de56370862439" target="_blank" rel="noopener">73aa960</a>，完整项目为<a href="https://github.com/CN-GuoZiyang/My-RPC-Framework/tree/73aa960b0c457770859f81a3210de56370862439" target="_blank" rel="noopener">https://github.com/CN-GuoZiyang/My-RPC-Framework/tree/73aa960b0c457770859f81a3210de56370862439</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用（抄）一下Guide哥的一张图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jbi1ndW96aXlhbmcuZ2l0aHViLmlvL015LVJQQy1GcmFtZXdvcmsvaW1nL1JQQyVFNiVBMSU4NiVFNiU5RSVCNiVFNiU4MCU5RCVFOCVCNyVBRi5qcGVn?x-oss-process=image/format,png" alt="RPC框架思路"></p><p>那么我们首先要思考，RPC框架的原理。</p><p>原理很简单，客户端和服务端都可以访问到通用的接口，但是只有服务端有这个接口的实现类，客户端调用这个接口的方式，是通过网络传输，告诉服务端我要调用这个接口，服务端收到之后找到这个接口的实现类，并且执行，将执行的结果返回给客户端，作为客户端调用接口方法的返回值。</p><p>原理很简单，但是实现值得商榷，例如客户端怎么知道服务端的地址？客户端怎么告诉服务端我要调用的接口？客户端怎么传递参数？只有接口客户端怎么生成实现类……等等等等。</p><p>这一章，我们就来探讨一个最简单的实现。一个最简单的实现，基于这样一个假设，那就是客户端已经知道了服务端的地址，这部分会由后续的服务发现机制完善。</p><h2 id="通用接口"><a href="#通用接口" class="headerlink" title="通用接口"></a>通用接口</h2><p>我们先把通用的接口写好，然后再来看怎么实现客户端和服务端。</p><p>接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(HelloObject object)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>hello方法需要传递一个对象，HelloObject对象，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>注意这个对象需要实现<code>Serializable</code>接口，因为它需要在调用过程中从客户端传递给服务端。</p><p>接着我们在服务端对这个接口进行实现，实现的方式也很简单，返回一个字符串就行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(HelloObject object)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"接收到：&#123;&#125;"</span>, object.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是掉用的返回值，id="</span> + object.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><p>严格来说，这并不能算是协议……但也大致算一个传输格式吧。</p><p>我们来思考一下，服务端需要哪些信息，才能唯一确定服务端需要调用的接口的方法呢？</p><p>首先，就是接口的名字，和方法的名字，但是由于方法重载的缘故，我们还需要这个方法的所有参数的类型，最后，客户端调用时，还需要传递参数的实际值，那么服务端知道以上四个条件，就可以找到这个方法并且调用了。我们把这四个条件写到一个对象里，到时候传输时传输这个对象就行了。即<code>RpcRequest</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用接口名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数类型我是直接使用Class对象，其实用字符串也是可以的。</p><p>那么服务器调用完这个方法后，需要给客户端返回哪些信息呢？如果调用成功的话，显然需要返回值，如果调用失败了，就需要失败的信息，这里封装成一个<code>RpcResponse</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer statusCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态补充信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setStatusCode(ResponseCode.SUCCESS.getCode());</span><br><span class="line">        response.setData(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">fail</span><span class="params">(ResponseCode code)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setStatusCode(code.getCode());</span><br><span class="line">        response.setMessage(code.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还多写了两个静态方法，用于快速生成成功与失败的响应对象。其中，statusCode属性可以自行定义，客户端服务端一致即可。</p><h2 id="客户端的实现——动态代理"><a href="#客户端的实现——动态代理" class="headerlink" title="客户端的实现——动态代理"></a>客户端的实现——动态代理</h2><p>客户端方面，由于在客户端这一侧我们并没有接口的具体实现类，就没有办法直接生成实例对象。这时，我们可以通过动态代理的方式生成实例，并且调用方法时生成需要的RpcRequest对象并且发送给服务端。</p><p>这里我们采用JDK动态代理，代理类是需要实现<code>InvocationHandler</code>接口的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要传递host和port来指明服务端的位置。并且使用getProxy()方法来生成代理对象。</p><p><code>InvocationHandler</code>接口需要实现invoke()方法，来指明代理对象的方法被调用时的动作。在这里，我们显然就需要生成一个RpcRequest对象，发送出去，然后返回从服务端接收到的结果即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    RpcRequest rpcRequest = RpcRequest.builder()</span><br><span class="line">            .interfaceName(method.getDeclaringClass().getName())</span><br><span class="line">            .methodName(method.getName())</span><br><span class="line">            .parameters(args)</span><br><span class="line">            .paramTypes(method.getParameterTypes())</span><br><span class="line">            .build();</span><br><span class="line">    RpcClient rpcClient = <span class="keyword">new</span> RpcClient();</span><br><span class="line">    <span class="keyword">return</span> ((RpcResponse) rpcClient.sendRequest(rpcRequest, host, port)).getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成RpcRequest很简单，我使用Builder模式来生成这个对象。发送的逻辑我使用了一个RpcClient对象来实现，这个对象的作用，就是将一个对象发过去，并且接受返回的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest, String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(host, port)) &#123;</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">            objectOutputStream.writeObject(rpcRequest);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            <span class="keyword">return</span> objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"调用时有错误发生："</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的实现很简单，直接使用Java的序列化方式，通过Socket传输。创建一个Socket，获取ObjectOutputStream对象，然后把需要发送的对象传进去即可，接收时获取ObjectInputStream对象，readObject()方法就可以获得一个返回的对象。</p><h2 id="服务端的实现——反射调用"><a href="#服务端的实现——反射调用" class="headerlink" title="服务端的实现——反射调用"></a>服务端的实现——反射调用</h2><p>服务端的实现就简单多了，使用一个ServerSocket监听某个端口，循环接收连接请求，如果发来了请求就创建一个线程，在新线程中处理调用。这里创建线程采用线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">60</span>;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS, workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简化了一下，RpcServer暂时只能注册一个接口，即对外提供一个接口的调用服务，添加register方法，在注册完一个服务后立刻开始监听：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object service, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">        logger.info(<span class="string">"服务器正在启动..."</span>);</span><br><span class="line">        Socket socket;</span><br><span class="line">        <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">"客户端连接！Ip为："</span> + socket.getInetAddress());</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> WorkerThread(socket, service));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"连接时有错误发生："</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里向工作线程WorkerThread传入了socket和用于服务端实例service。</p><p>WorkerThread实现了Runnable接口，用于接收RpcRequest对象，解析并且调用，生成RpcResponse对象并传输回去。run方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">         ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;</span><br><span class="line">        RpcRequest rpcRequest = (RpcRequest) objectInputStream.readObject();</span><br><span class="line">        Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">        Object returnObject = method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">        objectOutputStream.writeObject(RpcResponse.success(returnObject));</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"调用或发送时有错误发生："</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，通过class.getMethod方法，传入方法名和方法参数类型即可获得Method对象。如果你上面RpcRequest中使用String数组来存储方法参数类型的话，这里你就需要通过反射生成对应的Class数组了。通过method.invoke方法，传入对象实例和参数，即可调用并且获得返回值。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>服务端侧，我们已经在上面实现了一个HelloService的实现类HelloServiceImpl的实现类了，我们只需要创建一个RpcServer并且把这个实现类注册进去就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        RpcServer rpcServer = <span class="keyword">new</span> RpcServer();</span><br><span class="line">        rpcServer.register(helloService, <span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端开放在9000端口。</p><p>客户端方面，我们需要通过动态代理，生成代理对象，并且调用，动态代理会自动帮我们向服务端发送请求的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">"This is a message"</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里生成了一个HelloObject对象作为方法的参数。</p><p>首先启动服务端，再启动客户端，服务端输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务器正在启动...</span><br><span class="line">客户端连接！Ip为：127.0.0.1</span><br><span class="line">接收到：This is a message</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>客户端输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是调用的返回值，id&#x3D;12</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rpc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unsafe包</title>
      <link href="/2020/11/18/Unsafe%E5%8C%85/"/>
      <url>/2020/11/18/Unsafe%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>Java和C++语言的一个重要区别就是Java中我们无法直接操作一块内存区域，不能像C++中那样可以自己申请内存和释放内存。Java中的Unsafe类为我们提供了类似C++手动管理内存的能力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class RevisedObjectInHeap</span><br><span class="line">&#123;</span><br><span class="line">    public Unsafe getUnsafe() throws IllegalAccessException &#123;</span><br><span class="line">        Field unsafeField &#x3D; Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(true);</span><br><span class="line">        Unsafe unsafe &#x3D; (Unsafe) unsafeField.get(null);</span><br><span class="line">        return unsafe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long address &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private Unsafe unsafe &#x3D; getUnsafe();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 让对象占用堆内存,触发[Full GC</span><br><span class="line">    private byte[] bytes &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public RevisedObjectInHeap() throws IllegalAccessException &#123;</span><br><span class="line">        address &#x3D; unsafe.allocateMemory(2 * 1024 * 1024);</span><br><span class="line">        bytes &#x3D; new byte[1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.out.println(&quot;finalize.&quot; + bytes.length);</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException &#123;</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            RevisedObjectInHeap heap &#x3D; new RevisedObjectInHeap();</span><br><span class="line">            System.out.println(&quot;memory address&#x3D;&quot; + heap.address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>Unsafe的功能如下图：</p><p>​    <img src="https://user-gold-cdn.xitu.io/2019/2/24/1691f484296ba537?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Unsafe-xmind"></p><h2 id="普通读写"><a href="#普通读写" class="headerlink" title="普通读写"></a>普通读写</h2><p>通过Unsafe可以读写一个类的属性，即使这个属性是私有的，也可以对这个属性进行读写。</p><p><strong>读写一个Object属性的相关方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public native int getInt(Object var1, long var2);</span><br><span class="line"></span><br><span class="line">public native void putInt(Object var1, long var2, int var4);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>getInt用于从对象的指定偏移地址处读取一个int。putInt用于在对象指定偏移地址处写入一个int。其他的primitive type也有对应的方法。</p><p><strong>Unsafe还可以直接在一个地址上读写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public native byte getByte(long var1);</span><br><span class="line"></span><br><span class="line">public native void putByte(long var1, byte var3);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>getByte用于从指定内存地址处开始读取一个byte。putByte用于从指定内存地址写入一个byte。其他的primitive type也有对应的方法。</p><h2 id="volatile读写"><a href="#volatile读写" class="headerlink" title="volatile读写"></a>volatile读写</h2><p>普通的读写无法保证可见性和有序性，而volatile读写就可以保证可见性和有序性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public native int getIntVolatile(Object var1, long var2);</span><br><span class="line"></span><br><span class="line">public native void putIntVolatile(Object var1, long var2, int var4);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>getIntVolatile方法用于在对象指定偏移地址处volatile读取一个int。putIntVolatile方法用于在对象指定偏移地址处volatile写入一个int。</p><p>volatile读写相对普通读写是更加昂贵的，因为需要保证可见性和有序性，而与volatile写入相比putOrderedXX写入代价相对较低，putOrderedXX写入不保证可见性，但是保证有序性，所谓有序性，就是保证指令不会重排序。</p><h2 id="有序写入"><a href="#有序写入" class="headerlink" title="有序写入"></a>有序写入</h2><p>有序写入只保证写入的有序性，不保证可见性，就是说一个线程的写入不保证其他线程立马可见。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public native void putOrderedObject(Object var1, long var2, Object var4);</span><br><span class="line"></span><br><span class="line">public native void putOrderedInt(Object var1, long var2, int var4);</span><br><span class="line"></span><br><span class="line">public native void putOrderedLong(Object var1, long var2, long var4);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="直接内存操作"><a href="#直接内存操作" class="headerlink" title="直接内存操作"></a>直接内存操作</h2><p>我们都知道Java不可以直接对内存进行操作，对象内存的分配和回收都是由JVM帮助我们实现的。但是Unsafe为我们在Java中提供了直接操作内存的能力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分配内存</span><br><span class="line">public native long allocateMemory(long var1);</span><br><span class="line">&#x2F;&#x2F; 重新分配内存</span><br><span class="line">public native long reallocateMemory(long var1, long var3);</span><br><span class="line">&#x2F;&#x2F; 内存初始化</span><br><span class="line">public native void setMemory(long var1, long var3, byte var5);</span><br><span class="line">&#x2F;&#x2F; 内存复制</span><br><span class="line">public native void copyMemory(Object var1, long var2, Object var4, long var5, long var7);</span><br><span class="line">&#x2F;&#x2F; 清除内存</span><br><span class="line">public native void freeMemory(long var1);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="CAS相关"><a href="#CAS相关" class="headerlink" title="CAS相关"></a>CAS相关</h2><p>JUC中大量运用了CAS操作，可以说CAS操作是JUC的基础，因此CAS操作是非常重要的。Unsafe中提供了int,long和Object的CAS操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>CAS一般用于乐观锁，它在Java中有广泛的应用，ConcurrentHashMap，ConcurrentLinkedQueue中都有用到CAS来实现乐观锁。</p><h2 id="偏移量相关"><a href="#偏移量相关" class="headerlink" title="偏移量相关"></a>偏移量相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public native long staticFieldOffset(Field var1);</span><br><span class="line"></span><br><span class="line">public native long objectFieldOffset(Field var1);</span><br><span class="line"></span><br><span class="line">public native Object staticFieldBase(Field var1);</span><br><span class="line"></span><br><span class="line">public native int arrayBaseOffset(Class&lt;?&gt; var1);</span><br><span class="line"></span><br><span class="line">public native int arrayIndexScale(Class&lt;?&gt; var1);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>staticFieldOffset方法用于获取静态属性Field在对象中的偏移量，读写静态属性时必须获取其偏移量。objectFieldOffset方法用于获取非静态属性Field在对象实例中的偏移量，读写对象的非静态属性时会用到这个偏移量。staticFieldBase方法用于返回Field所在的对象。arrayBaseOffset方法用于返回数组中第一个元素实际地址相对整个数组对象的地址的偏移量。arrayIndexScale方法用于计算数组中第一个元素所占用的内存空间。</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public native void unpark(Object var1);</span><br><span class="line"></span><br><span class="line">public native void park(boolean var1, long var2);</span><br><span class="line"></span><br><span class="line">public native void monitorEnter(Object var1);</span><br><span class="line"></span><br><span class="line">public native void monitorExit(Object var1);</span><br><span class="line"></span><br><span class="line">public native boolean tryMonitorEnter(Object var1);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>park方法和unpark方法相信看过LockSupport类的都不会陌生，这两个方法主要用来挂起和唤醒线程。LockSupport中的park和unpark方法正是通过Unsafe来实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 挂起线程</span><br><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker); &#x2F;&#x2F; 通过Unsafe的putObject方法设置阻塞阻塞当前线程的blocker</span><br><span class="line">    UNSAFE.park(false, 0L); &#x2F;&#x2F; 通过Unsafe的park方法来阻塞当前线程，注意此方法将当前线程阻塞后，当前线程就不会继续往下走了，直到其他线程unpark此线程</span><br><span class="line">    setBlocker(t, null); &#x2F;&#x2F; 清除blocker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 唤醒线程</span><br><span class="line">public static void unpark(Thread thread) &#123;</span><br><span class="line">    if (thread !&#x3D; null)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>monitorEnter方法和monitorExit方法用于加锁，Java中的synchronized锁就是通过这两个指令来实现的。</p><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public native Class&lt;?&gt; defineClass(String var1, byte[] var2, int var3, int var4, ClassLoader var5, ProtectionDomain var6);</span><br><span class="line"></span><br><span class="line">public native Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; var1, byte[] var2, Object[] var3);</span><br><span class="line"></span><br><span class="line">public native Object allocateInstance(Class&lt;?&gt; var1) throws InstantiationException;</span><br><span class="line"></span><br><span class="line">public native boolean shouldBeInitialized(Class&lt;?&gt; var1);</span><br><span class="line"></span><br><span class="line">public native void ensureClassInitialized(Class&lt;?&gt; var1);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>defineClass方法定义一个类，用于动态地创建类。 defineAnonymousClass用于动态的创建一个匿名内部类。 allocateInstance方法用于创建一个类的实例，但是不会调用这个实例的构造方法，如果这个类还未被初始化，则初始化这个类。 shouldBeInitialized方法用于判断是否需要初始化一个类。 ensureClassInitialized方法用于保证已经初始化过一个类。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public native void loadFence();</span><br><span class="line"></span><br><span class="line">public native void storeFence();</span><br><span class="line"></span><br><span class="line">public native void fullFence();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>loadFence：保证在这个屏障之前的所有读操作都已经完成。 storeFence：保证在这个屏障之前的所有写操作都已经完成。 fullFence：保证在这个屏障之前的所有读写操作都已经完成。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP的RTT、RTO?</title>
      <link href="/2020/11/18/TCP%E7%9A%84RTT%E3%80%81RTO/"/>
      <url>/2020/11/18/TCP%E7%9A%84RTT%E3%80%81RTO/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><ul><li><code>RTT(Round Trip Time)</code>：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值；</li><li><code>RTO(Retransmission Time Out)</code>：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队头阻塞</title>
      <link href="/2020/11/18/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E/"/>
      <url>/2020/11/18/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常我们提到队头阻塞，指的可能是TCP协议中的队头阻塞，但是HTTP1.1中也有一个类似TCP队头阻塞的问题，下面各自介绍一下。</p><h2 id="TCP队头阻塞"><a href="#TCP队头阻塞" class="headerlink" title="TCP队头阻塞"></a>TCP队头阻塞</h2><p>队头阻塞（head-of-line blocking）发生在一个TCP分节丢失，导致其后续分节不按序到达接收端的时候。该后续分节将被接收端一直保持直到丢失的第一个分节被发送端重传并到达接收端为止。该后续分节的延迟递送确保接收应用进程能够按照发送端的发送顺序接收数据。这种为了达到完全有序而引入的延迟机制非常有用，但也有不利之处。</p><p>假设在单个TCP连接上发送语义独立的消息，比如说服务器可能发送3幅不同的图像供Web浏览器显示。为了营造这几幅图像在用户屏幕上并行显示的效果，服务器先发送第一幅图像的一个断片，再发送第二幅图像的一个断片，然后再发送第三幅图像的一个断片；服务器重复这个过程，直到这3幅图像全部成功地发送到浏览器为止。</p><p>要是第一幅图像的某个断片内容的TCP分节丢失了，客户端将保持已到达的不按序的所有数据，直到丢失的分节重传成功。这样不仅延缓了第一幅图像数据的递送，也延缓了第二幅和第三幅图像数据的递送。</p><h2 id="HTTP队头阻塞"><a href="#HTTP队头阻塞" class="headerlink" title="HTTP队头阻塞"></a>HTTP队头阻塞</h2><p>上面用浏览器请求图片资源举例子，但实际上HTTP自身也有类似TCP队头阻塞的情况。要介绍HTTP队头阻塞，就需要先讲讲HTTP的管道化（pipelining）。</p><h3 id="HTTP管道化是什么"><a href="#HTTP管道化是什么" class="headerlink" title="HTTP管道化是什么"></a>HTTP管道化是什么</h3><p>HTTP1.1 允许在持久连接上可选的使用请求管道。这是相对于keep-alive连接的又一性能优化。在相应到达之前，可以将多条请求放入队列，当第一条请求发往服务器的时候，第二第三条请求也可以开始发送了，在高延时网络条件下，这样做可以降低网络的环回时间，提高性能。</p><p>非管道化与管道化的区别示意</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/21/16ad9415ebab724b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="HTTP管道化产生的背景"><a href="#HTTP管道化产生的背景" class="headerlink" title="HTTP管道化产生的背景"></a>HTTP管道化产生的背景</h3><p>在一般情况下，HTTP遵守“请求-响应”的模式，也就是客户端每次发送一个请求到服务端，服务端返回响应。这种模式非常容易理解，但是效率并不是那么高，为了提高速度和效率，人们做了很多尝试：</p><ul><li>最简单的情况下，服务端一旦返回响应后就会把对应的连接关闭，客户端的多个请求实际上是串行发送的。</li><li>除此之外，客户端可以选择同时创建多个连接，在多个连接上并行的发送不同请求。但是创建更多连接也带来了更多的消耗，当前大部分浏览器都会限制对同一个域名的连接数。</li><li>从HTTP1.0开始增加了持久连接的概念（HTTP1.0的Keep-Alive和HTTP1.1的persistent），可以使HTTP能够复用已经创建好的连接。客户端在收到服务端响应后，可以复用上次的连接发送下一个请求，而不用重新建立连接。</li><li>现代浏览器大多采用并行连接与持久连接共用的方式提高访问速度，对每个域名建立并行地少量持久连接。</li><li>而在持久连接的基础上，HTTP1.1进一步地支持在持久连接上使用管道化（pipelining）特性。管道化允许客户端在已发送的请求收到服务端的响应之前发送下一个请求，借此来减少等待时间提高吞吐；如果多个请求能在同一个TCP分节发送的话，还能提高网络利用率。但是因为HTTP管道化本身可能会导致队头阻塞的问题，以及一些其他的原因，现代浏览器默认都关闭了管道化。</li></ul><h3 id="HTTP管道化的限制"><a href="#HTTP管道化的限制" class="headerlink" title="HTTP管道化的限制"></a>HTTP管道化的限制</h3><ol><li>管道化要求服务端按照请求发送的顺序返回响应（FIFO），原因很简单，HTTP请求和响应并没有序号标识，无法将乱序的响应与请求关联起来。</li><li>客户端需要保持未收到响应的请求，当连接意外中断时，需要重新发送这部分请求。</li><li>只有幂等的请求才能进行管道化，也就是只有GET和HEAD请求才能管道化，否则可能会出现意料之外的结果</li></ol><h3 id="HTTP管道化引起的请求队头阻塞"><a href="#HTTP管道化引起的请求队头阻塞" class="headerlink" title="HTTP管道化引起的请求队头阻塞"></a>HTTP管道化引起的请求队头阻塞</h3><p>前面提到HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。</p><h2 id="如何解决队头阻塞"><a href="#如何解决队头阻塞" class="headerlink" title="如何解决队头阻塞"></a>如何解决队头阻塞</h2><h3 id="如何解决HTTP队头阻塞"><a href="#如何解决HTTP队头阻塞" class="headerlink" title="如何解决HTTP队头阻塞"></a>如何解决HTTP队头阻塞</h3><p>对于HTTP1.1中管道化导致的请求/响应级别的队头阻塞，可以使用HTTP2解决。HTTP2不使用管道化的方式，而是引入了帧、消息和数据流等概念，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后在组装成消息，这样就避免了请求/响应阻塞。</p><p>当然，即使使用HTTP2，如果HTTP2底层使用的是TCP协议，仍可能出现TCP队头阻塞。</p><h3 id="如何解决TCP队头阻塞"><a href="#如何解决TCP队头阻塞" class="headerlink" title="如何解决TCP队头阻塞"></a>如何解决TCP队头阻塞</h3><p>TCP中的队头阻塞的产生是由TCP自身的实现机制决定的，无法避免。想要在应用程序当中避免TCP队头阻塞带来的影响，只有舍弃TCP协议。</p><p>比如google推出的<a href="https://km.sankuai.com/page/108687233" target="_blank" rel="noopener">quic</a>协议，在某种程度上可以说避免了TCP中的队头阻塞，因为它根本不使用TCP协议，而是在UDP协议的基础上实现了可靠传输。而UDP是面向数据报的协议，数据报之间不会有阻塞约束。</p><p>此外还有一个SCTP（流控制传输协议），它是和TCP、UDP在同一层次的传输协议。SCTP的多流特性也可以尽可能的避免队头阻塞的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从TCP队头阻塞和HTTP队头阻塞的原因我们可以看到，出现队头阻塞的原因有两个：</p><ol><li>独立的消息数据都在一个链路上传输，也就是有一个“队列”。比如TCP只有一个流，多个HTTP请求共用一个TCP连接</li><li>队列上传输的数据有严格的顺序约束。比如TCP要求数据严格按照序号顺序，HTTP管道化要求响应严格按照请求顺序返回</li></ol><p>所以要避免队头阻塞，就需要从以上两个方面出发，比如quic协议不使用TCP协议而是使用UDP协议，SCTP协议支持一个连接上存在多个数据流等等。</p><p>作者：熊纪元<br>链接：<a href="https://juejin.im/post/6844903853985366023" target="_blank" rel="noopener">https://juejin.im/post/6844903853985366023</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>半打开，半关闭，半连接</title>
      <link href="/2020/11/18/%E5%8D%8A%E6%89%93%E5%BC%80%EF%BC%8C%E5%8D%8A%E5%85%B3%E9%97%AD%EF%BC%8C%E5%8D%8A%E8%BF%9E%E6%8E%A5/"/>
      <url>/2020/11/18/%E5%8D%8A%E6%89%93%E5%BC%80%EF%BC%8C%E5%8D%8A%E5%85%B3%E9%97%AD%EF%BC%8C%E5%8D%8A%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h1><p>close：全关闭，不再输出，也不能接收输入</p><p>shutdown:半关闭</p><p>当半关闭输出时：对应TCP四次挥手的 FIN_WAIT_2状态</p><p><img src="https://img2018.cnblogs.com/blog/1383984/201904/1383984-20190417145024224-277153479.png" alt="img"></p><h1 id="半打开："><a href="#半打开：" class="headerlink" title="半打开："></a>半打开：</h1><p>如果一方异常关闭（断网，断电），而另一方并不知情。处于半打开的状态，如果双方不进行数据通信，是无法发现问题的。可以引入心跳机制，以检测半打开状态，检测到了发送RST重新建立连接</p><h1 id="半连接："><a href="#半连接：" class="headerlink" title="半连接："></a>半连接：</h1><p>三次握手中，主动发起握手的一方不发最后一次ACK，使得服务器端阻塞在SYN_RECV状态</p><p>半连接攻击（SYN攻击）：会耗尽服务器资源，使得真正的请求无法建立连接。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些特殊的TCP选项</title>
      <link href="/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/"/>
      <url>/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>TCP异常终止（reset报文）</strong></p><p><strong>TCP的异常终止是相对于正常释放TCP连接的过程而言的</strong>，我们都知道，TCP连接的建立是通过三次握手完成的，而TCP正常释放连接是通过四次挥手来完成，但是有些情况下，TCP在交互的过程中会出现一些意想不到的情况，导致TCP无法按照正常的四次挥手来释放连接，如果此时不<strong>通过其他的方式来释放TCP连接</strong>的话，这个TCP连接将会一直存在，占用系统的部分资源。在这种情况下，我们就需要有一种能够释放TCP连接的机制，这种机制就是TCP的reset报文。reset报文是指TCP报头的标志字段中的reset位置一的报文，如下图所示：</p><p><img src="https://img-my.csdn.net/uploads/201210/08/1349695916_7871.png" alt="img"></p><p><strong>TCP异常终止的常见情形</strong></p><p>我们在实际的工作环境中，导致某一方发送reset报文的情形主要有以下几种：</p><p><strong><em>\</em>1，客户端尝试与服务器\</strong>*<em>未对外提供服务的端口*</em>*<em>建立TCP连接，服务器将会直接向客户端发送reset报文。***</em></p><p><img src="/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201118224909130.png" alt="image-20201118224909130"></p><p><strong>*\</strong>*2**<em>*</em>*，客户端和服务器的某一方在交互的过程中发生异常（如程序崩溃等），该方系统将向对端发送*<em>*</em>**TCP reset**<em>*</em>*报文，告之对方释放相关的*<em>*</em>**TCP**<em>*</em>*连接****，如下图所示：</p><p><img src="/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201118224917728.png" alt="image-20201118224917728"></p><p>3<strong><em>\</em>，接收端收到TCP报文，但是发现该TCP的报文，并不在其\</strong>*<em>已建立的TCP连接列表*</em>*<em>内，则其直接向对端发送reset报文***</em>，如下图所示：</p><p><img src="/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201118224926584.png" alt="image-20201118224926584"></p><p><strong>*\</strong>*4**<em>*</em>*<em>\</em>，在交互的双方中的某一方长期未收到来自对方的确认报文，则其在超出一定的重传次数或时间后，会****主动****向对端发送**<em>*</em>*<em>\</em>reset**<em>*</em>*报文释放该*<em>*</em>**TCP**<em>*****</em>*连接****，如下图所示：</p><p><img src="/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201118224938327.png" alt="image-20201118224938327"></p><p><strong>*\</strong>*5**<em>*</em>*<em>\</em>，有些应用开发者在设计应用系统时，会****利用**<em>*</em>*<em>\</em>**reset******报文快速释放已经完成数据交互的******TCP******连接，以提高业务交互的效率**<em>**</em>，如下图所示：</p><p><img src="/2020/11/18/%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%9A%84TCP%E9%80%89%E9%A1%B9/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201118224947724.png" alt="image-20201118224947724"></p><p><strong>Reset报文的利用</strong></p><p><strong><em>\</em>1\</strong> *<em>安全设备利用*</em>*<em>reset*</em>*<em>报文阻断异常连接***</em></p><p>安全设备（如防火墙、入侵检测系统等）在发现某些可疑的TCP连接时，会构造交互双方的reset报文发给对端，让对端释放该TCP连接。比如入侵检测检测到黑客攻击的TCP连接，其构造成被攻击端给黑客主机发送reset报文，让黑客主机释放攻击连接。</p><p><strong><em>\</em>2\</strong> *<em>利用*</em>*<em>reset*</em>*<em>报文实施攻击***</em></p><p>安全设备可以利用reset报文达到安全防护的效果，黑客和攻击者也可以利用reset报文实现对某些主机的入侵和攻击，最常见的就是TCP会话劫持攻击。关于TCP会话劫持的相关知识请参考第三章《TCP会话劫持》一文。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题</title>
      <link href="/2020/11/18/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/18/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h3><p><strong>域名，协议，端口</strong>只要有一个不同，就是跨域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.123.com&#x2F;index.html 调用 http:&#x2F;&#x2F;www.123.com&#x2F;server.php （非跨域）</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;www.123.com&#x2F;index.html 调用 http:&#x2F;&#x2F;www.456.com&#x2F;server.php （主域名不同:123&#x2F;456，跨域）</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;abc.123.com&#x2F;index.html 调用 http:&#x2F;&#x2F;def.123.com&#x2F;server.php （子域名不同:abc&#x2F;def，跨域）</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;www.123.com:8080&#x2F;index.html 调用 http:&#x2F;&#x2F;www.123.com:8081&#x2F;server.php （端口不同:8080&#x2F;8081，跨域）</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;www.123.com&#x2F;index.html 调用 https:&#x2F;&#x2F;www.123.com&#x2F;server.php （协议不同:http&#x2F;https，跨域）</span><br></pre></td></tr></table></figure><h3 id="后台解决方法"><a href="#后台解决方法" class="headerlink" title="后台解决方法"></a>后台解决方法</h3><p>1、后台配置解决跨域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--跨域依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.thetransactioncompany&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cors-filter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.thetransactioncompany&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;java-property-utils&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br></pre></td></tr></table></figure><p>并在web.xml配置过滤器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--为了允许跨域访问--&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CorsFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;com.thetransactioncompany.cors.CORSFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CorsFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure><p>2.使用Filter方式进行设置</p><p>使用Filter过滤器来过滤服务请求，向请求端设置Response Header(响应头部)的Access-Control-Allow-Origin属性声明允许跨域访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter</span><br><span class="line">public class CorsFilter implements Filter &#123;  </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123;  </span><br><span class="line">        HttpServletResponse response &#x3D; (HttpServletResponse) res;  </span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  </span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);  </span><br><span class="line">        response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);  </span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">        chain.doFilter(req, res);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者继承 HandlerInterceptorAdapter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CrossInterceptor extends HandlerInterceptorAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, PUT, DELETE, OPTIONS&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.WebMVC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@SuppressWarnings(&quot;SpringJavaAutowiredFieldsWarningInspection&quot;)</span><br><span class="line">public class AppConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">        registry.addMapping(&quot;&#x2F;**&quot;)  &#x2F;&#x2F; 拦截所有的请求</span><br><span class="line">                .allowedOrigins(&quot;http:&#x2F;&#x2F;www.abc.com&quot;)  &#x2F;&#x2F; 可跨域的域名，可以为 *</span><br><span class="line">                .allowCredentials(true)</span><br><span class="line">                .allowedMethods(&quot;*&quot;)   &#x2F;&#x2F; 允许跨域的方法，可以单独配置</span><br><span class="line">                .allowedHeaders(&quot;*&quot;);  &#x2F;&#x2F; 允许跨域的请求头，可以单独配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用 <code>@CrossOrgin</code> 注解（也可以加在Controller)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">@CrossOrigin</span><br><span class="line">@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public User get(@PathVariable Long id) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public void remove(@PathVariable Long id) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最左匹配的一些情况</title>
      <link href="/2020/11/18/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%85%E5%86%B5/"/>
      <url>/2020/11/18/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<p>看了好多博客，讲讲自己的理解：索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。<br>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的</p><p><img src="https://img-blog.csdnimg.cn/20190401113210176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxOTE3MTA5,size_16,color_FFFFFF,t_70" alt="img"></p><p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p><p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a&gt;1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p><p><strong>最左匹配原则：</strong>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。</p><p> 假如建立联合索引（a,b,c）</p><p><strong>1 全值匹配查询时</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = <span class="string">'1'</span> <span class="keyword">and</span> b = <span class="string">'2'</span> <span class="keyword">and</span> c = <span class="string">'3'</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> b = <span class="string">'2'</span> <span class="keyword">and</span> a = <span class="string">'1'</span> <span class="keyword">and</span> c = <span class="string">'3'</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> c = <span class="string">'3'</span> <span class="keyword">and</span> b = <span class="string">'2'</span> <span class="keyword">and</span> a = <span class="string">'1'</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>用到了索引</p><p>where子句几个搜索条件顺序调换不影响查询结果，因为Mysql中有查询优化器，会自动优化查询顺序 </p><p><strong>2 匹配左边的列时</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = <span class="string">'1'</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = <span class="string">'1'</span> <span class="keyword">and</span> b = <span class="string">'2'</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = <span class="string">'1'</span> <span class="keyword">and</span> b = <span class="string">'2'</span> <span class="keyword">and</span> c = <span class="string">'3'</span></span><br></pre></td></tr></table></figure><p>都从最左边开始<strong>连续</strong>匹配，用到了索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  b = <span class="string">'2'</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  c = <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  b = <span class="string">'1'</span> <span class="keyword">and</span> c = <span class="string">'3'</span></span><br></pre></td></tr></table></figure><p>这些没有从最左边开始，最后查询没有用到索引，用的是全表扫描 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a = <span class="string">'1'</span> <span class="keyword">and</span> c = <span class="string">'3'</span></span><br></pre></td></tr></table></figure><p>如果不连续时，只用到了a列的索引，b列和c列都没有用到 </p><p> <strong>3 匹配列前缀</strong></p><p>如果列是字符型的话它的比较规则是先比较字符串的第一个字符，第一个字符小的哪个字符串就比较小，如果两个字符串第一个字符相通，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小，依次类推，比较字符串。</p><p>如果a是字符类型，那么前缀匹配用的是索引，后缀和中缀只能全表扫描了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">'As%'</span>; //前缀都是排好序的，走索引查询</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  a <span class="keyword">like</span> <span class="string">'%As'</span>//全表查询</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  a <span class="keyword">like</span> <span class="string">'%As%'</span>//全表查询</span><br></pre></td></tr></table></figure><p><strong>4 匹配范围值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  a &gt; <span class="number">1</span> <span class="keyword">and</span> a &lt; <span class="number">3</span></span><br></pre></td></tr></table></figure><p>可以对最左边的列进行范围查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  a &gt; <span class="number">1</span> <span class="keyword">and</span> a &lt; <span class="number">3</span> <span class="keyword">and</span> b &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>多个列同时进行范围查找时，只有对索引最左边的那个列进行范围查找才用到B+树索引，也就是只有a用到索引，在1&lt;a&lt;3的范围内b是无序的，不能用索引，找到1&lt;a&lt;3的记录后，只能根据条件 b &gt; 1继续逐条过滤</p><p> <strong>5 精确匹配某一列并范围匹配另外一列</strong></p><p>如果左边的列是精确查找的，右边的列可以进行范围查找</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span>  a = <span class="number">1</span> <span class="keyword">and</span> b &gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p> a=1的情况下b是有序的，进行范围查找走的是联合索引</p><p><strong>6 排序</strong></p><p>一般情况下，我们只能把记录加载到内存中，再用一些排序算法，比如快速排序，归并排序等在内存中对这些记录进行排序，有时候查询的结果集太大不能在内存中进行排序的话，还可能暂时借助磁盘空间存放中间结果，排序操作完成后再把排好序的结果返回客户端。Mysql中把这种再内存中或磁盘上进行排序的方式统称为文件排序。文件排序非常慢，但如果order子句用到了索引列，就有可能省去文件排序的步骤</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> a,b,c <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>因为b+树索引本身就是按照上述规则排序的，所以可以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了</p><p>order by的子句后面的顺序也必须按照索引列的顺序给出，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> b,c,a <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p> 这种颠倒顺序的没有用到索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> a <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> a,b <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这种用到部分索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> a =<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> b,c <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>联合索引左边列为常量，后边的列排序可以用到索引</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>B+树分裂?</title>
      <link href="/2020/11/18/B-%E6%A0%91%E5%88%86%E8%A3%82/"/>
      <url>/2020/11/18/B-%E6%A0%91%E5%88%86%E8%A3%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h1><p>1）若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。</p><p>2）针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2+1个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。</p><p>3）针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。</p><h1 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h1><p>如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤</p><p>1）删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2，删除操作结束,否则执行第2步。</p><p>2）若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。</p><p>3）若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。</p><p>4）若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步</p><p>5）若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步</p><p>6）当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。</p><p>注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。</p><p><img src="https://img-blog.csdnimg.cn/20200413111039577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTU2MzE2MQ==,size_16,color_FFFFFF,t_70" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用户态、内核态</title>
      <link href="/2020/11/18/%E7%94%A8%E6%88%B7%E6%80%81%E3%80%81%E5%86%85%E6%A0%B8%E6%80%81/"/>
      <url>/2020/11/18/%E7%94%A8%E6%88%B7%E6%80%81%E3%80%81%E5%86%85%E6%A0%B8%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="内核态和用户态？为什么？"><a href="#内核态和用户态？为什么？" class="headerlink" title="内核态和用户态？为什么？"></a>内核态和用户态？为什么？</h3><p> 假设没有这种内核态和用户态之分，程序随随便便就能访问硬件资源，比如说分配内存，程序能随意的读写所有的内存空间，如果程序员一不小心将不适当的内容写到了不该写的地方，就很可能导致系统崩溃。用户程序是不可信的，不管程序员是有意的还是无意的，都很容易将系统干到崩溃。</p><p>​    正因为如此，Intel就发明了ring0-ring3这些访问控制级别来保护硬件资源，ring0的就是我们所说的内核级别,要想使用硬件资源就必须获取相应的权限（设置PSW寄存器，这个操作只能由操作系统设置）。操作系统对内核级别的指令进行封装，统一管理硬件资源，然后向用户程序提供系统服务，用户程序进行系统调用后，操作系统执行一系列的检查验证，确保这次调用是安全的，再进行相应的资源访问操作。<strong>内核态能有效保护硬件资源的安全。</strong></p><p>补充：Unix/Linux的特权级<br>特权级是非常有效的管理和控制程序执行的手段，因此在硬件上对特权级做了很多支持，就Intel x86架构的CPU来说一共有0~3四个特权级，0级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查。对于Unix/Linux来说，只使用了0级特权级和3级特权级。也就是说在Unix/Linux系统中，一条工作在0级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力。当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在0级特权级上时，就可以称之为运行在内核态。</p><h3 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h3><ol><li>大内核<br>大内核是将操作系统功能作为一个紧密结合的整体放到内核。<br>由于各模块共享信息，因此有很高的性能。</li><li>微内核<br>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则<br>划分成若干服务，相互独立。<br>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在<br>用户态。<br>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</li></ol><h3 id="用户态到内核态切换的三种方式："><a href="#用户态到内核态切换的三种方式：" class="headerlink" title="用户态到内核态切换的三种方式："></a>用户态到内核态切换的三种方式：</h3><ol><li>外中断<br>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输<br>入/输出请求。此外还有时钟中断、控制台中断等。</li><li>异常<br> 由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</li><li>系统调用：用户态的进程通过系统调用申请试用操作系统提供的服务程序完成工作，比如fork()就是执行了一个创建新进程的系统调用</li></ol><h3 id="常见的内核态"><a href="#常见的内核态" class="headerlink" title="常见的内核态"></a>常见的内核态</h3><p><img src="/2020/11/18/%E7%94%A8%E6%88%B7%E6%80%81%E3%80%81%E5%86%85%E6%A0%B8%E6%80%81/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201203193354517.png" alt="image-20201203193354517"></p><h3 id="用户态和内核态对于读写文件的操作有什么区别"><a href="#用户态和内核态对于读写文件的操作有什么区别" class="headerlink" title="用户态和内核态对于读写文件的操作有什么区别?"></a>用户态和内核态对于读写文件的操作有什么区别?</h3><p>内核态：CPU可以访问内存的所有数据，包括外围设备，例如网卡、硬盘，CPU也可以将自己从一个程序切换到另一个程序<br>用户态：CPU只能受限地访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取<br>所有的用户程序都是运行在用户态的，但是有的时候需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.</p><h3 id="用户态进入内核态的方式"><a href="#用户态进入内核态的方式" class="headerlink" title="用户态进入内核态的方式"></a>用户态进入内核态的方式</h3><ol><li>外中断<br>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输<br>入/输出请求。此外还有时钟中断、控制台中断等。</li><li>异常<br>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</li><li>陷入<br>在用户程序中使用系统调用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统疑问?</title>
      <link href="/2020/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%96%91%E9%97%AE/"/>
      <url>/2020/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%96%91%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="线程组成？"><a href="#线程组成？" class="headerlink" title="线程组成？"></a>线程组成？</h3><p>一个标准的线程由线程id，当前指令指针(pc)，寄存器集合和堆栈组成</p><h3 id="进程切换发生哪些事情"><a href="#进程切换发生哪些事情" class="headerlink" title="进程切换发生哪些事情?"></a>进程切换发生哪些事情?</h3><ul><li>保存CPU的上下文环境，包括程序计数器和寄存器，处理具体的中断、异常</li><li>调整被中断进程的PCB信息，比如进程状态</li><li>把进程移入相应的队列，比如就绪或者阻塞队列</li><li>选择另一个进程执行并更新其PCB</li><li>恢复CPU的上下文</li></ul><h3 id="为什么进程切换慢，线程切换快"><a href="#为什么进程切换慢，线程切换快" class="headerlink" title="为什么进程切换慢，线程切换快?"></a>为什么进程切换慢，线程切换快?</h3><ul><li><p>进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用TLB(Translation Lookaside Buffer)来缓存页地址，用来加速页表查找。当进程切换后页表也要进行切换，页表切换后TLB就失效了，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p></li><li><p>而且保存CPU的上下文环境</p></li></ul><h3 id="进程切换的时机"><a href="#进程切换的时机" class="headerlink" title="进程切换的时机?"></a>进程切换的时机?</h3><p>其中主动放弃处理器的场景是</p><ol><li><p>进程正常结束，主动放弃。</p></li><li><p>进程在执行时发生了异常。</p></li></ol><p>被动放弃处理器的场景是</p><ol><li><p>进程在执行时有个更紧急的任务(比如IO操作)</p></li><li><p>遇到有更高优先级的进程</p></li><li><p>进程的时间片过期</p></li></ol><h3 id="中断一定会引起进程切换吗"><a href="#中断一定会引起进程切换吗" class="headerlink" title="中断一定会引起进程切换吗?"></a>中断一定会引起进程切换吗?</h3><p>不一定</p><p>有一些中断／异常不会引起进程状态转换，不会引起进程切换，只是在处理完成后把控制权交还给被中断进程。</p><p>以下是处理流程：</p><p>1、（中断／异常等触发）正向模式切换并压入PSW／PC 。 </p><p>2、保存被中断进程的现场信息。</p><p>3、处理具体中断、异常。</p><p>4、恢复被中断进程的现场信息。</p><p>5、（中断返回指令触发）逆向模式转换并弹出PSW／PC。</p><h3 id="进程中打开文件其他线程可以直接读写那个文件吗？"><a href="#进程中打开文件其他线程可以直接读写那个文件吗？" class="headerlink" title="进程中打开文件其他线程可以直接读写那个文件吗？"></a>进程中打开文件其他线程可以直接读写那个文件吗？</h3><p>1.两个进程中分别产生生成两个独立的fd</p><p>2.两个进程可以任意对文件进行读写操作，操作系统并不保证写的原子性<br>3.进程可以通过系统调用对文件加锁，从而实现对文件内容的保护<br>4.<br>任何一个进程删除该文件时，另外一个进程不会立即出现读写失败</p><p>5.两个进程可以分别读取文件的不同部分而不会相互影响</p><p>6.一个进程对文件长度和内容的修改另外一个进程可以立即感知</p><p>内核中，对应于每个进程都有一个文件描述符表，表示这个进程打开的所有文件。文件描述表中每一项都是一个指针，指向一个用 于描述打开的文件的数据块———file对象，file对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的file对象。</p><p><img src="https://img-blog.csdn.net/20181014110752978?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWJvMTIzMDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h3 id="为什么要设计成三级缓存？"><a href="#为什么要设计成三级缓存？" class="headerlink" title="为什么要设计成三级缓存？"></a>为什么要设计成三级缓存？</h3><p>1、一级缓存基本上都是内置在cpu的内部和cpu一个速度进行运行，能有效的提升cpu的工作效率。一级缓存越多，cpu的工作效率就会越来越高，是cpu的内部结构限制了一级缓存的容量大小，使一级缓存的容量都是很小的。<br>2、二级缓存主要作用是协调一级缓存和内存之间的工作效率。cpu首先用的是一级内存，当cpu的速度慢慢提升之后，一级缓存就不够cpu的使用量了，这就需要用到二级内存。<br>3、CPU三级缓存，就是指CPU的第三层级的高速缓存，其作用是进一步降低内存的延迟，同时提升海量数据量计算时的性能。和一级缓存、二级缓存不同的是，三级缓存是核心共享的，能够将容量做的很大。</p><h3 id="Linux的buffer内存和cache内存"><a href="#Linux的buffer内存和cache内存" class="headerlink" title="Linux的buffer内存和cache内存"></a>Linux的buffer内存和cache内存</h3><ul><li>Buffers 是对原始磁盘块的临时存储，也就是用来<strong>缓存磁盘的数据</strong>，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写等等。合并这里似乎和大数据生态中的Hadoop组件中的小文件合并有相似。</li><li>Cached 是从磁盘读取文件的页缓存，也就是用来<strong>缓存从文件读取的数据</strong>。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。</li></ul><h3 id="操作系统除了堆，栈还包括哪些段呢？"><a href="#操作系统除了堆，栈还包括哪些段呢？" class="headerlink" title="操作系统除了堆，栈还包括哪些段呢？"></a>操作系统除了堆，栈还包括哪些段呢？</h3><p> 代码段 数据段</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各种join的区别</title>
      <link href="/2020/11/18/%E5%90%84%E7%A7%8Djoin%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/11/18/%E5%90%84%E7%A7%8Djoin%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>哈，好久没更新文章了，今天来说说关于mySQL那些年的小事。说到mySQL啊，用了挺久的了，但是有个问题一直在困扰着我，就是left join、join、right join和inner join等等各种join的区别。网上搜，最常见的就是一张图解图，如下：</p><p><img src="https://segmentfault.com/img/bVbk2mR?w=966&h=760" alt="clipboard.png"></p><p>真的是一张图道清所有join的区别啊，可惜我还是看不懂，可能人比较懒，然后基本一个left join给我就是够用的了，所以就没怎么去仔细研究了，但是现实还是逼我去搞清楚，索性自己动手，总算理解图中的含义了，下面就听我一一道来。</p><p>首先，我们先来建两张表，第一张表命名为kemu，第二张表命名为score：</p><p><img src="https://segmentfault.com/img/bVbk2or?w=118&h=92" alt="clipboard.png">)<img src="https://segmentfault.com/img/bVbk2oz?w=128&h=94" alt="clipboard.png"></p><p><strong>一、left join</strong><br>顾名思义，就是“左连接”，表1左连接表2，以左为主，表示以表1为主，关联上表2的数据，查出来的结果显示左边的所有数据，然后右边显示的是和左边有交集部分的数据。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">   *</span><br><span class="line">from</span><br><span class="line">   kemu</span><br><span class="line">left join score on kemu.id &#x3D; score.id</span><br></pre></td></tr></table></figure><p>结果集：<br><img src="https://segmentfault.com/img/bVbk2uE?w=205&h=144" alt="clipboard.png">)<img src="https://segmentfault.com/img/bVbk2qQ?w=238&h=103" alt="clipboard.png"></p><p><strong>二、right join</strong></p><p>“右连接”，表1右连接表2，以右为主，表示以表2为主，关联查询表1的数据，查出表2所有数据以及表1和表2有交集的数据，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">   *</span><br><span class="line">from</span><br><span class="line">   kemu</span><br><span class="line">right join score on kemu.id &#x3D; score.id</span><br></pre></td></tr></table></figure><p>结果集：</p><p><img src="https://segmentfault.com/img/bVbk2uI?w=222&h=143" alt="clipboard.png">)<img src="https://segmentfault.com/img/bVbk2uP?w=228&h=104" alt="clipboard.png"></p><p><strong>三、join</strong><br>join，其实就是“inner join”，为了简写才写成join，两个是表示一个的，内连接，表示以两个表的交集为主，查出来是两个表有交集的部分，其余没有关联就不额外显示出来，这个用的情况也是挺多的，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">   *</span><br><span class="line">from</span><br><span class="line">   kemu</span><br><span class="line">join score on kemu.id &#x3D; score.id</span><br></pre></td></tr></table></figure><p>结果集：</p><p><img src="https://segmentfault.com/img/bVbk2v1?w=227&h=145" alt="clipboard.png">)<img src="https://segmentfault.com/img/bVbk2MW?w=231&h=69" alt="clipboard.png"></p><p>以上就是三种连接的区别！</p><p> 从算法上来看，根据mysql文档，<code>inner join</code>在连接的时候，mysql会自动选择较小的表来作为驱动表，从而达到减少循环次数的目的。我们在使用<code>left join</code>表的时候，默认是使用左表作为驱动表，那么此时左表的大小是我们来控制的，如果控制不当，左表比较大，那么自然循环次数也会变多，效率会下降。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>捕获线程的异常</title>
      <link href="/2020/11/18/%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/11/18/%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="多线程之运行线程异常捕获"><a href="#多线程之运行线程异常捕获" class="headerlink" title="多线程之运行线程异常捕获"></a>多线程之运行线程异常捕获</h1><h2 id="单个线程异常捕获"><a href="#单个线程异常捕获" class="headerlink" title="单个线程异常捕获"></a>单个线程异常捕获</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程异常捕捉</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-12-23 22:22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程抛出异常</span></span><br><span class="line">        <span class="comment">//thread1();</span></span><br><span class="line">        <span class="comment">//捕获异常</span></span><br><span class="line">        thread2();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2_000</span>);</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2_000</span>);</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出异常信息</span></span><br><span class="line">        thread.setUncaughtExceptionHandler((t, e) -&gt; &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread1()方法运行结果</p><p><img src="https://img-blog.csdnimg.cn/20191223223356236.png" alt="在这里插入图片描述"><br>捕获线程异常使用 setUncaughtExceptionHandler（Thread t,Exception e）方法捕捉异常信息返回，然后再进行处理</p><p>thread1()方法运行结果<br><img src="https://img-blog.csdnimg.cn/20191223223420287.png" alt="在这里插入图片描述"></p><h2 id="线程池捕捉异常"><a href="#线程池捕捉异常" class="headerlink" title="线程池捕捉异常"></a>线程池捕捉异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置异常处理器</span></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ThreadTask());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span>  <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"捕获到异常 : 线程名["</span> + t.getName() + <span class="string">"], 异常名["</span> + e + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常栈的信息</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO ... 如果对异常还需要做特殊处理,可以在此处继续实现处理方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义抛出异常的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//运行异常</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">     System.out.println(<span class="string">"异常被谁处理："</span> + t.getUncaughtExceptionHandler());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常捕获</p><p><img src="https://img-blog.csdnimg.cn/20200118175528316.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程间通信?</title>
      <link href="/2020/11/18/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2020/11/18/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><ol><li>volatile</li><li>等待/通知机制</li><li>join方式</li><li>threadLocal</li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>冷备份和热备份</title>
      <link href="/2020/11/18/%E5%86%B7%E5%A4%87%E4%BB%BD%E5%92%8C%E7%83%AD%E5%A4%87%E4%BB%BD/"/>
      <url>/2020/11/18/%E5%86%B7%E5%A4%87%E4%BB%BD%E5%92%8C%E7%83%AD%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<p>数据库热备：一般bai用于保证du服务正常不zhi间断运行，用两台机dao器作为服务机4102器，一台用于实际1653数据库操作应用,另外一台实时的从前者中获取数据以保持数据一致.如果当前的机器熄火,备份的机器立马取代当前的机器继续提供服务</p><p>冷备：.冷备份指在数据库关闭后,进行备份,适用于所有模式的数据库.</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>可重入锁</title>
      <link href="/2020/11/18/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
      <url>/2020/11/18/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>什么是 “可重入”，可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.test.reen;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 演示可重入锁是什么意思，可重入，就是可以重复获取相同的锁，synchronized和ReentrantLock都是可重入的</span><br><span class="line">&#x2F;&#x2F; 可重入降低了编程复杂性</span><br><span class="line">public class WhatReentrant &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">System.out.println(&quot;第1次获取锁，这个锁是：&quot; + this);</span><br><span class="line">int index &#x3D; 1;</span><br><span class="line">while (true) &#123;</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">System.out.println(&quot;第&quot; + (++index) + &quot;次获取锁，这个锁是：&quot; + this);</span><br><span class="line">&#125;</span><br><span class="line">if (index &#x3D;&#x3D; 10) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.test.reen;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 演示可重入锁是什么意思</span><br><span class="line">public class WhatReentrant2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(&quot;第1次获取锁，这个锁是：&quot; + lock);</span><br><span class="line"></span><br><span class="line">int index &#x3D; 1;</span><br><span class="line">while (true) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(&quot;第&quot; + (++index) + &quot;次获取锁，这个锁是：&quot; + lock);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(new Random().nextInt(200));</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (index &#x3D;&#x3D; 10) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么时候使用myisam?</title>
      <link href="/2020/11/17/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8myisam/"/>
      <url>/2020/11/17/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8myisam/</url>
      
        <content type="html"><![CDATA[<p>1、平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。</p><p>2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。<br>3.MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出该值。<br>　　<br>　　MyISAM适合：<br>(1)做很多count 的计算；<br>(2)插入不频繁，查询非常频繁；<br>(3)没有事务。 </p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引汇总</title>
      <link href="/2020/11/17/%E7%B4%A2%E5%BC%95%E6%B1%87%E6%80%BB/"/>
      <url>/2020/11/17/%E7%B4%A2%E5%BC%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Inoodb的底层原理和具体结构</title>
      <link href="/2020/11/17/Inoodb%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%B7%E4%BD%93%E7%BB%93%E6%9E%84/"/>
      <url>/2020/11/17/Inoodb%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%B7%E4%BD%93%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor中的keepAliveTime详解</title>
      <link href="/2020/11/17/ThreadPoolExecutor%E4%B8%AD%E7%9A%84keepAliveTime%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/11/17/ThreadPoolExecutor%E4%B8%AD%E7%9A%84keepAliveTime%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>阅读这篇文章，你将会知道：</p><ol><li>keepAliveTime的概念。</li><li>keepAliveTime是如何设置的。</li><li>线程是如何根据keepAliveTime进行销毁的。</li></ol></blockquote><h2 id="一-keepAliveTime的概念："><a href="#一-keepAliveTime的概念：" class="headerlink" title="一.keepAliveTime的概念："></a>一.keepAliveTime的概念：</h2><ol><li>keepAliveTime的单位是纳秒，即1s=1000000000ns，1秒等于10亿纳秒。</li><li>keepAliveTime是线程池中空闲线程等待工作的超时时间。</li><li>当线程池中线程数量大于corePoolSize（核心线程数量）或设置了allowCoreThreadTimeOut（是否允许空闲核心线程超时）时，线程会根据keepAliveTime的值进行活性检查，一旦超时便销毁线程。</li><li>否则，线程会永远等待新的工作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Timeout in nanoseconds for idle threads waiting for work.</span></span><br><span class="line"><span class="comment"> * Threads use this timeout when there are more than corePoolSize</span></span><br><span class="line"><span class="comment"> * present or if allowCoreThreadTimeOut. Otherwise they wait</span></span><br><span class="line"><span class="comment"> * forever for new work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br></pre></td></tr></table></figure><h2 id="二-keepAliveTime的设置方法"><a href="#二-keepAliveTime的设置方法" class="headerlink" title="二. keepAliveTime的设置方法"></a>二. keepAliveTime的设置方法</h2><h3 id="1-通过构造函数设置"><a href="#1-通过构造函数设置" class="headerlink" title="1.通过构造函数设置"></a>1.通过构造函数设置</h3><p>通过 keepAliveTime 、unit共同决定实际的 keepAliveTime值，最终会转化成纳秒单位。<br><img src="https://img-blog.csdnimg.cn/20190420151619845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDEyOTY=,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-通过setKeepAliveTime方法动态设置"><a href="#2-通过setKeepAliveTime方法动态设置" class="headerlink" title="2.通过setKeepAliveTime方法动态设置"></a>2.通过setKeepAliveTime方法动态设置</h3><p>重新设置线程池的keepAliveTime属性，如果发现将要设置的值比原来的keepAliveTime值要小（即减小keepAliveTime），则触发interruptIdleWorkers()，中断空闲线程。<br><img src="https://img-blog.csdnimg.cn/20190420152745847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDEyOTY=,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>interruptIdleWorkers()是怎么中断线程的呢？</strong><br>（1）interruptIdleWorkers先拿出所有的工作者进行遍历，判断工作者对应的线程是否已经中断。<br>（2）如果没有产生中断，则判断是否可以获得锁，如果能获得锁，则代表是空闲线程，然后中断该线程。<br>（3）至于线程的中断在什么时候会抛出中断异常，同学们可以自己找下资料，也可以参考下别人写的这篇文章<a href="https://www.cnblogs.com/yangming1996/p/7612653.html" target="_blank" rel="noopener">Java并发之线程中断</a><br><img src="https://img-blog.csdnimg.cn/20190420155452451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDEyOTY=,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="三-线程是如何根据keepAliveTime进行销毁的"><a href="#三-线程是如何根据keepAliveTime进行销毁的" class="headerlink" title="三.线程是如何根据keepAliveTime进行销毁的"></a>三.线程是如何根据keepAliveTime进行销毁的</h2><ol><li>线程池中的线程通过工作者（Worker）这个类进行包装，Worker通过 ThreadPoolExecutor.runWorker() 这个方法进行自旋，从队列中获得task，并完成工作。</li><li>如果拿不到task（即firstTask == null 或 getTask() == null），则会退出自旋，进入finally代码块。finally中会调用processWorkerExit方法，注销当前Worker，实现worker的销毁。对keepAliveTime的使用，就在getTask()方法中，这个在后面讲解。<br><img src="https://img-blog.csdnimg.cn/20190420162707287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDEyOTY=,size_16,color_FFFFFF,t_70" alt="img"></li><li>getTask 怎么使用 keepAliveTime<br>（1）首先也是一个自旋，当allowCoreThreadTimeout(运行空闲核心线程超时) 或 wc&gt;corePoolSize(当前线程数量大于核心线程数量) 时，timed会标识为true，表示需要进行超时判断。<br>（2）当wc（当前工作者数量）大于 最大线程数 或 空闲线程的空闲时间大于keepAliveTime（timed &amp;&amp; timeout），以及wc&gt;1或（workQueue）任务队列为空时，会进入compareAndDecrementWorkerCount方法，对wc的值减1。<br>（3）当compareAndDecrementWorkerCount方法返回true时，则getTask方法会返回null，终止getTask方法的自旋。这时候回到runWorker方法，就会进入到processWorkerExit方法，进行销毁worker。<br><img src="https://img-blog.csdnimg.cn/20190420161304138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDEyOTY=,size_16,color_FFFFFF,t_70" alt="img"></li><li>compareAndDecrementWorkerCount中操作的是ctl属性：<br>（1）ctl是中心控制器，一个AtomicInteger类型的整数，通过数字的二进制编码的位进行分段，不同的二进制位段表示有不同的含义。<br>（2）在ctl中，低29为表示线程池的容量，即线程池最大容量为 536870911 = 000 11111111111111111111111111111。<br><img src="https://img-blog.csdnimg.cn/20190420170422593.png" alt="img"></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The main pool control state, ctl, is an atomic integer packing</span></span><br><span class="line"><span class="comment">    * two conceptual fields</span></span><br><span class="line"><span class="comment">    *   workerCount, indicating the effective number of threads</span></span><br><span class="line"><span class="comment">    *   runState,    indicating whether running, shutting down etc</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">   <span class="comment">// COUNT_BITS = 29</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">   <span class="comment">// CAPACITY = 536870911 = 000 11111111111111111111111111111</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; </span><br><span class="line"><span class="keyword">return</span> c &amp; CAPACITY; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Http3.0的特点?</title>
      <link href="/2020/11/17/Http3-0%E7%9A%84%E7%89%B9%E7%82%B9/"/>
      <url>/2020/11/17/Http3-0%E7%9A%84%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h2><p><a href="https://www.mobibrw.com/2020/23190" target="_blank" rel="noopener">https://www.mobibrw.com/2020/23190</a></p><p>HTTP2.0 也是基于TCP协议的，tcp协议在处理包时是有严格顺序的</p><p>当其中一个数据包遇到问题，TCP连接需要等待找个包完成重传之后才能继续进行，虽然HTTP2.0通过多个stream，使得逻辑上一个tcp连接上的并行内容，进行多路数据的传输，然而这中间没有关联的数据，一前一后，前面stream2的帧没有收到，后面stream1的帧也会因此堵塞</p><p>于是google的 QUIC协议从TCP切换到UDP</p><ul><li>机制一：自定义连接机制<br>一条tcp连接是由四元组标识的，分别是源ip、源端口、目的端口，一旦一个元素发生变化时，就会断开重连，重新连接。在次进行三次握手，导致一定的延时</li></ul><p>在TCP是没有办法的，但是基于UDP，就可以在QUIC自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个64<br>位的随机数作为ID来标识，而且UDP是无连接的，所以当ip或者端口变化的时候，只要ID不变，就不需要重新建立连接</p><ul><li>机制二：自定义重传机制<br>tcp为了保证可靠性，通过使用序号和应答机制，来解决顺序问题和丢包问题</li></ul><p>任何一个序号的包发过去，都要在一定的时间内得到应答，否则一旦超时，就会重发这个序号的包，通过自适应重传算法（通过采样往返时间RTT不断调整）</p><p>但是，在TCP里面超时的采样存在不准确的问题。例如发送一个包，序号100，发现没有返回，于是在发送一个100，过一阵返回ACK101.客户端收到了，但是往返的时间是多少，没法计算。是ACK到达的时候减去第一还是第二。</p><p>QUIC也有个序列号，是递增的，任何宇哥序列号的包只发送一次，下次就要加1，那样就计算可以准确了</p><p>但是有一个问题，就是怎么知道包100和包101发送的是同样的内容呢？quic定义了一个offset概念。QUIC既然是面向连接的，也就像TCP一样，是一个数据流，发送的数据在这个数据流里面有个偏移量offset，可以通过offset查看数据发送到了那里，这样只有这个offset的包没有来，就要重发。如果来了，按照offset拼接，还是能够拼成一个流。</p><p><img src="http://www.chenjinxinlove.com/cdn/offsetbbb.png" alt="image"></p><ul><li>机制三： 无阻塞的多路复用</li></ul><p>有了自定义的连接和重传机制，就可以解决上面HTTP2.0的多路复用问题</p><p>同HTTP2.0一样，同一条 QUIC连接上可以创建多个stream，来发送多个HTTP请求，但是，QUIC是基于UDP的，一个连接上的多个stream之间没有依赖。这样，假如stream2丢了一个UDP包，后面跟着stream3的一个UDP包，虽然stream2的那个包需要重新传，但是stream3的包无需等待，就可以发给用户。</p><ul><li>机制四：自定义流量控制</li></ul><p>TCP的流量控制是通过滑动窗口协议。QUIC的流量控制也是通过window_update，来告诉对端它可以接受的字节数。但是QUIC的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个steam控制窗口。</p><p>在TCP协议中，接收端的窗口的起始点是下一个要接收并且ACK的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，因为TCP的ACK机制是基于序列号的累计应答，一旦ACK了一个序列号，就说明前面的都到了，所以是要前面的没到，后面的到了也不能ACK,就会导致后面的到了，也有可能超时重传，浪费带宽</p><p>QUIC的ACK是基于offset的，每个offset的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空档会等待到来或者重发，而窗口的起始位置为当前收到的最大offset，从这个offset到当前的stream所能容纳的最大缓存，是真正的窗口的大小，显然，那样更加准确。<br><img src="http://www.chenjinxinlove.com/cdn/offsetoss.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>限流算法</title>
      <link href="/2020/11/16/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
      <url>/2020/11/16/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>限流顾名思义是限制流量，限制流量的目的是为了保障服务稳定运行，避免服务被流量冲垮。当流量超出服务处理能力时，部分请求将会被限流组件拦截。被拦截的请求可能会被丢弃，如果是 C 端请求，那么这个请求可能会被导向指定的错误页上，而不是生硬的拒绝。这里我们丢弃掉一部分请求，以保证大部分请求可以正常响应。如果我们不这样做，那么服务崩溃后，所有请求都将无法响应了。当一台机器崩溃后，该机器的所有流量将由其他机器承担，这样就会造成剩余机器压力增大，进而导致奔溃，最后形成雪崩。除此之外，服务崩溃还会造成数据不一致的严重问题，特别是一些敏感数据。比如对于电商网站，如果后台服务准备将某笔订单数据存入数据库时，服务突然崩溃，导致数据没有落库。这个时候，开发同学就要想办法修订数据了。</p><p>综上，我们可以看出来限流的重要性。接下来，我将向大家介绍三种常用的限流算法，分别是计数器、漏桶算法和令牌桶算法。下面我们从最简单的计数器开始说起。</p><h2 id="2-限流算法"><a href="#2-限流算法" class="headerlink" title="2.限流算法"></a>2.限流算法</h2><h3 id="2-1-计数器"><a href="#2-1-计数器" class="headerlink" title="2.1 计数器"></a>2.1 计数器</h3><p>计数器算法的思想很简单，每当一个请求到来时，我们就将计数器加一，当计数器数值超过阈值后，就拒绝余下请求。一秒钟后，我们将计数器清零，开始新一轮的计数。计数器算法简单粗暴，易于实现。但是缺点也是有的，也就是所谓的”突刺现象”。举例说明一下，假如我们给计数器设置的阈值为100。系统瞬间内（比如10毫秒内）有200个请求到来，这个时候计数器只能放过其中的100个请求，余下的100个请求全部被拒绝掉。如果第二秒内没有请求到来，那么系统就处于空闲状态。也就是上一秒忙的要死，这一秒又闲的要死。如果我们能用一个容器将剩余的100个请求缓存起来，待计数器重置后再将这些请求放出来。这样系统在这两秒内的吞吐量就由100变成了200，提升了一倍。基于这个思考，下面我们再来看看漏桶算法。</p><h3 id="2-2-漏桶算法"><a href="#2-2-漏桶算法" class="headerlink" title="2.2 漏桶算法"></a>2.2 漏桶算法</h3><p>漏桶算法由流量容器、流量入口和出口组成。其中流量出口流速即为我们期望的限速值，比如 100 QPS。漏桶算法除了具备限流能力，还具备流量整型功能。下面我们通过一张图来了解漏桶算法。</p><p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15581714015488.jpg" alt="img"></p><p><strong>图片出处：未知</strong></p><p>如上图，流入漏桶流量的流速是不恒定的，经过漏桶限速后，流出流量的速度是恒定的。需要说明的是，漏桶的容量是有限的，一旦流入流量超出漏桶容量，这部分流量只能被丢弃了。</p><p>漏桶是一个比较好的限流整型工具，不过漏桶不能处理突发流量，一些观点认为这是它的一个缺点。不过如果较起真来，我觉得这个缺点是不成立的。毕竟漏桶本就是用来平滑流量的，如果支持突发，那么输出流量反而不平滑了。如果要找一种能够支持突发流量的限流算法，那么令牌桶算法可以满足需求。</p><h3 id="2-3-令牌桶算法"><a href="#2-3-令牌桶算法" class="headerlink" title="2.3 令牌桶算法"></a>2.3 令牌桶算法</h3><p>令牌桶和漏桶颇有几分相似，只不过令牌通里存放的是令牌。它的运行过程是这样的，一个令牌工厂按照设定值定期向令牌桶发放令牌。当令牌桶满了后，多出的令牌会被丢弃掉。每当一个请求到来时，该请求对应的线程会从令牌桶中取令牌。初期由于令牌桶中存放了很多个令牌，因此允许多个请求同时取令牌。当桶中没有令牌后，无法获取到令牌的请求可以丢弃，或者重试。下面我们来看一下的令牌桶示意图：</p><p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15581714388053.jpg" alt="img"></p><p><strong>图片出处：未知</strong></p><p>尽管令牌桶允许突发流量，但突发流量速率 R1 + 限流速率 R2 不能超过系统最大的处理能力 Rt，即 R1 + R2 ≤ Rt,否则会冲垮系统。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>以上就是本篇文章的全部内容。本篇文章简单分析几种常见限流算法的运行过程，限于能力原因，文章若有错误不妥之处还请指明。除了文字性描述，这里也把三种算法的简单实现代码贴出来 <a href="https://github.com/code4wt/RateLimiter" target="_blank" rel="noopener">RateLimiter</a>，有兴趣的同学自取。</p><p>好了，本篇文章到这里就结束了，感谢大家的阅读。</p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>binlog,redolog,undolog的区别?</title>
      <link href="/2020/11/16/binlog-redolog-undolog%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/11/16/binlog-redolog-undolog%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何设计一个秒杀系统?</title>
      <link href="/2020/11/16/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/11/16/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>​    <strong>1**</strong>：这个项目主要是针对处理高并发问题。主要考虑的问题有以下几个方面：**</p><p><strong>一、正确性。核心问题就是防止超卖，和重复下单。</strong></p><p><strong>二、高并发。主要是采用**</strong>Redis<strong>**进行缓存常用查询、消息队列异步下单、页面资源静态化等方面减去数据库压力。</strong></p><p><strong>三、安全性。主要有动态地址生成和接口放刷，双重**</strong>MD5<strong>**加密密码。</strong></p><p><strong>四、高可用性。一方面使用**</strong>Redis<strong><strong>集群的主从复制和主从切换保证</strong></strong>redis<strong><strong>的高可用性，另一方面，为防止</strong></strong>redsi<strong>**服务器宕</strong>   <strong>机，使用限流来防止**</strong>mysql<strong>**承受过多的请求。</strong></p><p>第二个项目介绍：</p><p>​    <strong>这个项目是我们实验室的项目，是和军方合作的项目。项目的流程，投标，竞标，开发和需求对接我都有参与。</strong></p><p><strong>项目主要是关于知识图谱的。主要是将客户的数据导入系统进行处理，定义**</strong>shcema,<strong>**建立本体以及本体之间的关系，然后按照一定的将数据导入图数据中，并提供搜索展示。</strong></p><p>​    <strong>数据的切割，就是将大的数据表切割成几张小表，表于表之间用外键关联，每个表生成一个实体，外键关联生成表与表之间的关系。</strong></p><p><strong>一如何防止超卖：</strong></p><p>​    1、利用数据库自带排他锁，当减库存的时候，进位where判断，只有库存余量大于0的时候才进行进库存; update goods set num = num - 1 WHERE id = 1001 and num &gt; 0; 2、也可以可用乐观锁CAS版本号机制。select version from goods WHERE id= 1001；update goods set num = num - 1, version = version + 1 WHERE id= 1001 AND num &gt; 0 AND version = @version(上面查到的version);</p><p><strong>二、服务器抗压思路：</strong></p><p>​    一、使用消息队列、异步生成订单；</p><p>​    二、redis库存量预缓存。只将少量的请求流入到服务器。如果全部卖完，拦截请求。</p><p>​    三、生成订单前，进行一系列的检验：是否还有库存，是否重复下单，这些数据都可以缓存。</p><p><strong>三、前端设计</strong></p><p>​    <strong>静态资源缓存：</strong>将活动页面上的所有可以静态的元素全部静态化，尽量减少动态元素；通过CDN缓存静态资源，来抗峰值。在url后面加上？即可。</p><p>​    <strong>禁止重复提交</strong>：前端:用户提交之后按钮置灰，禁止重复提交；后端：在进入页面时，服务器生成token并存到缓存或者session中，form表单使用隐藏域来存储这个token，提交之后带有token.后端收到这个token,看是否与服务器生成的token一致，如果不一致就是重复提交。如果一致，处理完之后清除token.</p><p>服务器返回表单页面时，会先生成一个subToken保存于session，并把该subToen传给表单页面。当表单提交时会带上subToken，服务器拦截器Interceptor会拦截该请求，拦截器判断session保存的subToken和表单提交subToken是否一致。若不一致或session的subToken为空或表单未携带subToken则不通过。</p><p>首次提交表单时session的subToken与表单携带的subToken一致走正常流程，然后拦截器内会删除session保存的subToken。当再次提交表单时由于session的subToken为空则不通过。从而实现了防止表单重复提交。</p><p>​    <strong>用户限流：某一时间段内只允许用户提交少数次请求，**</strong>IP<strong><strong>限流</strong></strong>(Nginx<strong><strong>设置</strong></strong>IP<strong><strong>地址限流</strong></strong>)<strong>**。</strong></p><p>​    </p><p><strong>中间代理层：</strong></p><p>​    <strong>利用负载均衡（例如反响代理**</strong>Nginx<strong>**等）使用多个服务器并发处理请求，减小服务器压力。</strong>   </p><p>​    <strong>(**</strong>正向代理代理客户端<strong><strong>VPN</strong></strong>，反向代理代理服务器。<strong>**NGINX)</strong> </p><p>​    横向增加服务器数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。普通轮询算法、比例加权轮询、ip路由负载、基于服务器响应时间负载分配、根据域名负载。</p><p>轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><p>指定权重：指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><p>IP绑定ip_hash：每个请求按ip的hash结果分配，<strong>这样每个访客固定访问一个后端服务器</strong>，<strong>可以解决**</strong>session<strong>**的问题。</strong></p><p>url_hash：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p><p>fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><p><strong>服务层：</strong></p><p>​    <strong>业务分离**</strong>:**将秒杀业务系统和其他业务分离，单独放在高配服务器上。</p><p>​    采<strong>用消息队列缓存请求</strong>：将大流量请求写到消息队列缓存，利用服务器根据自己的处理能力主动到消息缓存队列中抓取任务处理请求。</p><p>​    <strong>利用缓存应对读请求</strong>：对于读多写少业务，大部分请求是查询请求，所以可以读写分离，利用缓存分担数据库压力。</p><p><strong>数据库层：</strong></p><p>​    上游就需要把请求拦截掉，数据库层只承担“能力范围内”的访问请求。所以，上面通过在服务层引入队列和缓存，让最底层的数据库高枕无忧。可以对数据库进行优化，减少数据库压力。</p><p>​    如果redis挂掉的话，如果提高数据库的并发能力：</p><p>​    <strong>业务拆分</strong>：将不同功能的模块拆分，使用不同的数据库。</p><p>​    MySQL<strong>主从复制，读写分离</strong>：</p><p>​    <strong>分表分库：</strong></p><p><strong>其他策略：为请求分配成功状态或者分配秒杀资格，将没有资格的请求全部过滤，</strong>只有有资格的才能参与秒杀。说到底的秒杀这个高并发，并不是真正的处理高并发请求，而是如何应对高并发。将大量请求拦截然后放小量请求到数据库执行抢单是完全可以的，不用担心请求丢失的问题。</p><p><strong>四、怎么保证**</strong>redis<strong>**缓存和数据库的一致性</strong></p><p>​    <strong>延时双删；</strong></p><p>​    存在不一致问题的，基本都是库存量。秒杀系统的设计，最重要的是不能超卖，这个问题我们已经谈过，用mysql排他锁或者乐观CAS版本号机制可以防止。而即使redis库存量比实际mysql库存量大，依然不会超卖。而redis库存量比mysql库存量小，可能发生没少卖的情况。少卖，问题不大。如果不能少卖，可以将redis预库存调大，他主要起到拦截请求降流的作用，一致不一致问题不大。</p><p><strong>五、安全性问题</strong></p><p>​    <strong>1**</strong>、动态地址生成**  </p><p>​    <strong>2**</strong>、接口防刷**</p><p>​    </p><p><strong>六、消息队列</strong></p><p>​    <strong>防止重复消费</strong>：重复消费在消息队列所存在的问题中，从来都不是一个严重的问题。如果是消息是读，那多消费一次没啥影响。如果是写，例如我们这个订单生成，消费之前，查询一下是否之前已经存在用户ID商品ID构成的订单，我们可以将生成的订单存入缓存，所以查询一次也不费劲。</p><p>​    <strong>消息的消费结果如何返回给消息发送方</strong>：客户端轮询订单生成结果。</p><p>​    <strong>消息丢失：</strong>秒杀系统中，本来就是万中选一的，丢失无所谓。如果是重要的信息，我们可以从三个角度来避免。如果是发送者丢失，开启confirm机制，如果队列丢失，开始queue持久化和消息持久化。如果是消费者丢失，关闭自动ACK,当我们消费完之后，调用API给queue发送确认信息。</p><p><strong>七、秒杀流程、画架构图</strong></p><p>​    1、登录进入商品列表页面，静态资源缓存</p><p>​    2、点击进入商品详情页面，静态资源缓存，ajax获取验证码(服务器生成三个数的预算，并将结果缓存到redis);</p><p>​    3、点击秒杀, 将验证码结果和商品ID传给后端，如果结果正确。动态生成随机串UUID,结合用户ID和商品ID存入redis，并将path传给前端。前端获取path后，再根据path地址调用秒杀服务；</p><p>​    4、服务端获取请求的path参数，去查缓存是否在；</p><p>​    5、如果存在，预减redis库存，如果还有库存，看是否已经生成订单，没有的话就将请求入消息队列。</p><p>​    6、从消息队列中取消息：获取商品Id和用户ID,判断库存，重复下单；然后下单。</p><p>​    7、下单：减库存，生成订单； </p><p>​    8、前端轮询订单生成结果。50ms继续轮询或者秒杀是否成功和失败;</p><p><strong>八、优化策略</strong></p><p>​    多服务器负载均衡、</p><p><strong>简单介绍一下**</strong>Nginx** </p><p>​    Nginx是一款<strong>轻量级的**</strong>Web** <strong>服务器**</strong>/<strong><strong>反向代理服务器及电子邮件（</strong></strong>IMAP/POP3<strong>**）代理服务器</strong>。 <strong>Nginx</strong> <strong>主要提供反向代理、负载均衡、动静分离**</strong>(<strong><strong>静态资源服务</strong></strong>)<strong>**等服务</strong>。下面我简单地介绍一下这些名词。</p><p>​    正向代理：某些情况下，<strong>代理我们用户去访问服务器</strong>，<strong>需要用户手动的设置代理服务器的**</strong>ip<strong>**和端口号。</strong>正向代理比较常见的一个例子就是 VPN了。</p><p>​    反向代理：<strong>是用来代理服务器的，代理我们要访问的目标服务器。代理服务器接受请求，然后将请求转发给内</strong></p><p><strong>部网络的服务器，</strong>并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。</p><p>​    <strong>负载均衡</strong> </p><p>​    在高并发情况下需要使用，其原理就是将并发请求分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集</p><p>群)共同完成工作任务，从而提高了数据的吞吐量。Nginx支持的<strong>weight**</strong>轮询（默认）、<strong><strong>ip_hash</strong></strong>、<strong><strong>fair</strong></strong>、<strong><strong>url_hash</strong></strong>这四种负载均衡调度算法**，感兴趣的可以自行查阅。负载均衡相比于反向代理更侧重的时将请求分担到多台服务器上去，所以谈论负载均衡只有在提供某服务的服务器大于两台时才有意义。</p><p>​    <strong>动静分离</strong> </p><p>​    动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以</p><p>后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p><p>22.设计秒杀方案（从高并发、快速响应、高可用三方面回答，高并发（增加网络带宽、DNS域名解析分发多台服务器、使用前置代理服务器ngnix、CDN内容分发、数据库查询优化（读写分离、分库分表）），快速响应（缓存服务器（memcached、redis）、能使用静态页面就用静态页面，减少容器解析、把常访问的图片等内容缓存）、高可用（热备，如数据库服务器的热备、集群监控（如使用zabbix，重点关注IO、内存、带宽和机器load）））</p><p>服务器返回表单页面时，会先生成一个subToken保存于session，并把该subToen传给表单页面。当表单提交时会带上subToken，服务器拦截器Interceptor会拦截该请求，拦截器判断session保存的subToken和表单提交subToken是否一致。若不一致或session的subToken为空或表单未携带subToken则不通过。</p><p>首次提交表单时session的subToken与表单携带的subToken一致走正常流程，然后拦截器内会删除session保存的subToken。当再次提交表单时由于session的subToken为空则不通过。从而实现了防止表单重复提交。</p><p><strong>缓存、降级和限流：</strong></p><p><strong>在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流：</strong></p><p>​    <strong>缓存：缓存的目的是提升系统访问速度和增大系统处理容量</strong></p><p>​    <strong>降级：降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉，待高峰或者问题解决后再打开</strong></p><p>​    <strong>限流：限流的目的是通过对并发访问**</strong>/<strong>**请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理。</strong></p><p>​    计数器法：设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置 counter。缺点：统计的精度太低，无法处理临界问题。如果我在单位时间<strong>1s**</strong>内的前<strong><strong>10ms</strong></strong>，已经通过了<strong><strong>100</strong></strong>个请求，那后面的<strong><strong>990ms</strong></strong>，只能眼巴巴的把请求拒绝，我们把这种现象称为<strong><strong>“</strong></strong>突刺现象<strong>**”</strong></p><p> public boolean grant() {</p><p>​    long now = getNowTime();</p><p>​    if (now &lt; timeStamp + interval) {</p><p>​      // 在时间窗口内</p><p>​      reqCount++;</p><p>​      // 判断当前时间窗口内是否超过最大请求控制数</p><p>​      return reqCount &lt;= limit;</p><p>​     } else {</p><p>​      timeStamp = now;</p><p>​      // 超时后重置</p><p>​      reqCount = 1;</p><p>​      return true;</p><p>​    }</p><p>  }</p><p>滑动窗口算法：将窗口更加细分，每个窗口都有自己的计数器，当总计算达到限定时，限流。这个滑动窗口只是将计算法变得更平滑而已。本质一样。</p><p>漏斗法：将容器比作一个漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。</p><p>在<strong>令牌桶算法</strong>中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。通过Google开源的guava包，我们可以很轻松的创建一个令牌桶算法的限流器。</p><p>Google开源工具包Guava提供了限流工具类<strong>RateLimiter</strong>，该类基于令牌桶算法(Token Bucket)来完成限流，非常易于使用。RateLimiter经常用于限制对一些物理资源或者逻辑资源的访问速率，它支持两种获取permits接口，一<strong>种是如果拿不到立刻返回**</strong>false<strong><strong>（</strong></strong>tryAcquire()<strong><strong>），一种会阻塞等待一段时间看能不能拿到（</strong></strong>tryAcquire(long timeout, TimeUnit unit)<strong>**）。</strong></p><p>缺点：传<strong>统的方式整合**</strong>RateLimiter** <strong>有很大的缺点</strong>：<strong>代码重复量特别大**</strong>，而且本身不支持注解方式。**</p><p><strong>ES:</strong></p><p>Elasticsearch是一个近乎实时的搜索平台。这意味着从索引文档到可以搜索的时间只有轻微的延迟（通常是1秒）.</p><p>集群是一个或多个节点(服务器)的集合. 节点是一个单独的服务器，它是集群的一部分，存储数据，并参与集群的索引和搜索功能。</p><p>索引是具有某种相似特征的文档的集合。例如，你可以有一个顾客数据索引，产品目录索引和订单数据索引。文档是可以被索引的基本信息单元。文档用JSON表示,有多个field,如年龄，性别，地址。</p><p>Elasticsearch提供了将你的索引细分为多个碎片（或者叫分片）的能力。在创建索引时，可以简单地定义所需的分片数量。每个分片本身就是一个功能完全独立的“索引”，可以驻留在集群中的任何节点上。Shards &amp; Replicas.每个分片又有副本。</p><p><strong>正向索引是通过**</strong>key<strong><strong>找</strong></strong>value<strong><strong>，反向索引则是通过</strong></strong>value<strong><strong>找</strong></strong>key<strong>**。</strong></p><p>首先将文本分割成一系列被称为语汇单元(token)的独立原子元素，此过程即为文档分析，然后建立倒排索引，也就是每个term关键词出现在哪些文档之中。ID TERM DOCUMENT List.，Elasticsearch分别为每个field都建立了一个倒排索引。</p><p>Elasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是Term Dictionary。又有一个Term Index，就像字典里的索引页一样，A开头的有哪些term，分别在哪页，可以理<strong>解**</strong>term index<strong>**是一颗树</strong>：这棵树不会包含所有的term，它包含的是term的一些前缀。通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。再结合FST(Finite State Transducers)<strong>的压缩技术，可以使**</strong>term index<strong><strong>缓存到内存中。从</strong></strong>term index<strong><strong>查到对应的</strong></strong>term dictionary<strong><strong>的</strong></strong>block<strong><strong>位置之后，再去磁盘上找</strong></strong>term<strong>**，大大减少了磁盘随机读的次数。</strong></p><p><strong>用**</strong>FST<strong><strong>压缩</strong></strong>term index<strong><strong>外，对</strong></strong>posting list<strong><strong>也有压缩技巧，如</strong></strong>bitmap<strong>**；</strong></p><p><strong>联合索引直接利用跳表**</strong>(Skip list)<strong><strong>的数据结构快速做“与”运算，或者利用上面提到的</strong></strong>bitset<strong>**按位“与”。</strong></p><p><strong>shard = hash(document_id) % (num_of_primary_shards)</strong></p><p>字典树：</p><p>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</p><p>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</p><p>每个节点的所有子节点包含的字符都不相同。</p><p><strong>系统设计问题：</strong></p><p>​    <strong>1**</strong>、**让你系统的设计一个高并发的架构，你会从哪几个方面考虑？</p><p>​    <strong>2**</strong>、一个千万级的<strong><strong>APP</strong></strong>，你要搞定关注和粉丝列表，你用什么来做。要求最后一个关注的在最前面。新增和取关都要比较快的反馈你怎么做？如果一个人关注了之后，服务器宕机了怎么办？**</p><p>​    <strong>3**</strong>、**设计一个榨汁机类，面向对象怎么设计 </p><p>​    <strong>4**</strong>、**OOD design：计费停车场</p><p>​    5、多个服务器间共享session的解决方案</p><p>​    问了new一个对象的加载顺序, 答了从父类到子类的加载过程 静态变量和静态块, 哪个先加载, 答了静态变量。</p><p>​    假设有这么一个场景，有一条新闻，新闻的评论量可能很大，如何设计评论的读和写</p><p>​    你如果写用InnoDB，读用Myisam的话，主从同步怎么做</p><p>​    假设如果有同一时间海量数据入库，你怎么做（期间扯到了鹿晗关晓彤，这种微博大 V给他安排上，还提了消息队列做削峰）</p><p>​    你对Elasticsearch有什么了解</p><p>然后就问开放题了，问12306怎么处理大量请求。 </p><p>  问12306怎么处理大量的读请求。 </p><p>  问12306为什么有的时候会有看的时候有票，但是买的时候没票的情况，问我有可能会是什么原因。 </p><p>  问12306可能存在第三方软件帮忙抢票，怎么防止。</p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Springg事务</title>
      <link href="/2020/11/16/Springg%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/11/16/Springg%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-中的事务传播行为了解吗-TransactionDefinition-接口中哪五个表示隔离级别的常量"><a href="#Spring-中的事务传播行为了解吗-TransactionDefinition-接口中哪五个表示隔离级别的常量" class="headerlink" title="Spring 中的事务传播行为了解吗?TransactionDefinition 接口中哪五个表示隔离级别的常量?"></a>Spring 中的事务传播行为了解吗?TransactionDefinition 接口中哪五个表示隔离级别的常量?</h2><h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p><a href="https://segmentfault.com/a/1190000013341344" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013341344</a></p><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void methodA()&#123;</span><br><span class="line">   methodB();</span><br><span class="line">   &#x2F;&#x2F;doSomething</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transaction(Propagation&#x3D;XXX)</span><br><span class="line">public void methodB()&#123;</span><br><span class="line">   &#x2F;&#x2F;doSomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>支持当前事务的情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><p><strong><code>ropagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外围主事务回滚，子事务一定回滚，而内部子事务可以单独回滚而不影响外围主事务和其他子事务</strong></p><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><ul><li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别.</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GC调优</title>
      <link href="/2020/11/16/GC%E8%B0%83%E4%BC%98/"/>
      <url>/2020/11/16/GC%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Java内存区域常见配置参数概览"><a href="#Java内存区域常见配置参数概览" class="headerlink" title="Java内存区域常见配置参数概览"></a>Java内存区域常见配置参数概览</h3><blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/内存区域常见配置参数.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0.png" alt="img"></a></p><h3 id="堆参数"><a href="#堆参数" class="headerlink" title="堆参数"></a>堆参数</h3><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/media/pictures/jvm/java_jvm_heap_parameters.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/media/pictures/jvm/java_jvm_heap_parameters.png" alt="堆参数"></a></p><h3 id="回收器参数"><a href="#回收器参数" class="headerlink" title="回收器参数"></a>回收器参数</h3><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/media/pictures/jvm/java_jvm_garbage_collector_parameters.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/media/pictures/jvm/java_jvm_garbage_collector_parameters.png" alt="垃圾回收器参数"></a></p><p>如上表所示，目前<strong>主要有串行、并行和并发三种</strong>，对于大内存的应用而言，串行的性能太低，因此使用到的主要是并行和并发两种。并行和并发 GC 的策略通过 <code>UseParallelGC</code>和<code>UseConcMarkSweepGC</code> 来指定，还有一些细节的配置参数用来配置策略的执行方式。例如：<code>XX:ParallelGCThreads</code>， <code>XX:CMSInitiatingOccupancyFraction</code> 等。 通常：Young 区对象回收只可选择并行（耗时间），Old 区选择并发（耗 CPU）。</p><h3 id="项目中常用配置"><a href="#项目中常用配置" class="headerlink" title="项目中常用配置"></a>项目中常用配置</h3><blockquote><p>备注：在Java8中永久代的参数<code>-XX:PermSize</code> 和<code>-XX：MaxPermSize</code>已经失效。</p></blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/media/pictures/jvm/java_jvm_suggest_parameters.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/media/pictures/jvm/java_jvm_suggest_parameters.png" alt="项目中垃圾回收器常用配置"></a></p><h3 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h3><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/media/pictures/jvm/java_jvm_compose_garbage_collector.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/media/pictures/jvm/java_jvm_compose_garbage_collector.png" alt="垃圾回收器常用组合"></a></p><h2 id="常用-GC-调优策略"><a href="#常用-GC-调优策略" class="headerlink" title="常用 GC 调优策略"></a>常用 GC 调优策略</h2><ol><li>GC 调优原则；</li><li>GC 调优目的；</li><li>GC 调优策略；</li></ol><h3 id="GC-调优原则"><a href="#GC-调优原则" class="headerlink" title="GC 调优原则"></a>GC 调优原则</h3><p>在调优之前，我们需要记住下面的原则：</p><blockquote><p>多数的 Java 应用不需要在服务器上进行 GC 优化； 多数导致 GC 问题的 Java 应用，都不是因为我们参数设置错误，而是代码问题； 在应用上线之前，先考虑将机器的 JVM 参数设置到最优（最适合）； 减少创建对象的数量； 减少使用全局变量和大对象； GC 优化是到最后不得已才采用的手段； 在实际使用中，分析 GC 情况优化代码比优化 GC 参数要多得多。</p></blockquote><h3 id="GC-调优目的"><a href="#GC-调优目的" class="headerlink" title="GC 调优目的"></a>GC 调优目的</h3><p>将转移到老年代的对象数量降低到最小； 减少 GC 的执行时间。</p><h3 id="GC-调优策略"><a href="#GC-调优策略" class="headerlink" title="GC 调优策略"></a>GC 调优策略</h3><p><strong>策略 1：</strong>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p><p><strong>策略 2：</strong>大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。<code>-XX:PretenureSizeThreshold</code> 可以设置直接进入老年代的对象大小。</p><p><strong>策略 3：</strong>合理设置进入老年代对象的年龄，<code>-XX:MaxTenuringThreshold</code> 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。</p><p><strong>策略 4：</strong>设置稳定的堆大小，堆大小设置有两个参数：<code>-Xms</code> 初始化堆大小，<code>-Xmx</code> 最大堆大小。</p><p><strong>策略5：</strong>注意： 如果满足下面的指标，<strong>则一般不需要进行 GC 优化：</strong></p><blockquote><p>MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring如何解决循环依赖?</title>
      <link href="/2020/11/15/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2020/11/15/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实际工作中，经常由于设计不佳或者各种因素，导致类之间相互依赖。这些类可能单独使用时不会出问题，但是在使用Spring进行管理的时候可能就会抛出BeanCurrentlyInCreationException等异常 。当抛出这种异常时表示Spring解决不了该循环依赖，本文将简要说明Spring对于循环依赖的解决方法。</p><h2 id="循环依赖的产生和解决的前提"><a href="#循环依赖的产生和解决的前提" class="headerlink" title="循环依赖的产生和解决的前提"></a>循环依赖的产生和解决的前提</h2><p>也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：</p><p><img src="/2020/11/15/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201213163743980.png" alt="image-20201213163743980"></p><p>Spring中循环依赖场景有：<br>（1）构造器的循环依赖<br>（2）field属性的循环依赖。</p><h2 id="Spring对于循环依赖的解决"><a href="#Spring对于循环依赖的解决" class="headerlink" title="Spring对于循环依赖的解决"></a>Spring对于循环依赖的解决</h2><p>Spring循环依赖的理论依据其实是Java基于引用传递，当我们获取到对象的引用时，对象的field或者或属性是可以延后设置的。<br> Spring单例对象的初始化其实可以分为三步：</p><ul><li>createBeanInstance， 调用对应的构造方法构造对象，此时只是调用了构造方法，spring xml中指定的property并没有进行populate</li><li>populateBean，填充属性，这步对spring xml中指定的property进行populate</li><li>initializeBean，调用spring xml中指定的init方法，或者AfterPropertiesSet方法<br> 会发生循环依赖的步骤集中在第一步和第二步。</li></ul><p><img src="/2020/11/15/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201213164005723.png" alt="image-20201213164005723"></p><h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>对于单例对象来说，在Spring的整个容器的生命周期内，有且只存在一个对象，很容易想到这个对象应该存在Cache中，Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至使用了“三级缓存”。</p><p>“三级缓存”主要是指</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="emphasis">** Cache of singleton objects: bean name --&gt; bean instance *</span>/</span></span></span><br><span class="line">private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment"><span class="markdown">/<span class="emphasis">** Cache of singleton factories: bean name --&gt; ObjectFactory *</span>/</span></span></span><br><span class="line">private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment"><span class="markdown">/<span class="emphasis">** Cache of early singleton objects: bean name --&gt; bean instance *</span>/</span></span></span><br><span class="line">private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>从字面意思来说：singletonObjects指单例对象的cache，singletonFactories指单例对象工厂的cache，earlySingletonObjects指提前曝光的单例对象的cache。以上三个cache构成了三级缓存，Spring就用这三级缓存巧妙的解决了循环依赖问题。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>回想上篇文章中关于Bean创建的过程，首先Spring会尝试从缓存中获取，这个缓存就是指singletonObjects，主要调用的方法是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">   Object singletonObject = <span class="keyword">this</span>.singletonObjects.<span class="keyword">get</span>(beanName);</span><br><span class="line">   <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      synchronized (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">         singletonObject = <span class="keyword">this</span>.earlySingletonObjects.<span class="keyword">get</span>(beanName);</span><br><span class="line">         <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.<span class="keyword">get</span>(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">               singletonObject = singletonFactory.getObject();</span><br><span class="line">               <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">               <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);&#125;</span><br></pre></td></tr></table></figure><p>首先解释两个参数：</p><ul><li>isSingletonCurrentlyInCreation 判断对应的单例对象是否在创建中，当单例对象没有被初始化完全(例如A定义的构造函数依赖了B对象，得先去创建B对象，或者在populatebean过程中依赖了B对象，得先去创建B对象，此时A处于创建中)</li><li>allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象</li></ul><p>分析getSingleton的整个过程，Spring首先从singletonObjects（一级缓存）中尝试获取，如果获取不到并且对象在创建中，则尝试从earlySingletonObjects(二级缓存)中获取，如果还是获取不到并且允许从singletonFactories通过getObject获取，则通过singletonFactory.getObject()(三级缓存)获取。如果获取到了则</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">this</span><span class="selector-class">.earlySingletonObjects</span><span class="selector-class">.put</span>(<span class="selector-tag">beanName</span>, <span class="selector-tag">singletonObject</span>);</span><br><span class="line"><span class="selector-tag">this</span><span class="selector-class">.singletonFactories</span><span class="selector-class">.remove</span>(<span class="selector-tag">beanName</span>);</span><br></pre></td></tr></table></figure><p>则移除对应的singletonFactory,将singletonObject放入到earlySingletonObjects，其实就是将三级缓存提升到二级缓存中！</p><p>Spring解决循环依赖的诀窍就在于singletonFactories这个cache，这个cache中存的是类型为ObjectFactory，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;&#125;</span><br></pre></td></tr></table></figure><p>在bean创建过程中，有两处比较重要的匿名内部类实现了该接口。一处是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span>   <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">      &#125;      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         destroySingleton(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;   &#125;</span><br></pre></td></tr></table></figure><p>在上文已经提到，Spring利用其创建bean（这样做真的很不明确呀…）</p><p>另一处就是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span>   <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">   &#125;&#125;);</span><br></pre></td></tr></table></figure><p>此处就是解决循环依赖的关键，这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来的。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p><p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。</p><ul><li>A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，</li><li>此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。</li><li>此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，长大成人，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象也蜕变完美了！一切都是这么神奇！！</li></ul><p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring通过三级缓存加上“提前曝光”机制，配合Java的对象引用原理，比较完美地解决了某些情况下的循环依赖问题！</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解</title>
      <link href="/2020/11/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/11/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：<br>　　　　1.@Target, Annotation所修饰的对象范围<br>　　　　2.@Retention,该Annotation被保留的时间长短<br>　　　　3.@Documented, 应该被作为被标注的程序成员的公共API<br>　　　　4.@Inherited @Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。<br>　　这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明</p><p><strong>@Target：</strong></p><p>　　　@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。</p><p>　　<strong>作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</strong></p><p>　　<strong>取值(ElementType)有：</strong></p><p>　　　　1.CONSTRUCTOR:用于描述构造器<br>　　　　2.FIELD:用于描述域<br>　　　　3.LOCAL_VARIABLE:用于描述局部变量<br>　　　　4.METHOD:用于描述方法<br>　　　　5.PACKAGE:用于描述包<br>　　　　6.PARAMETER:用于描述参数<br>　　　　7.TYPE:用于描述类、接口(包括注解类型) 或enum声明</p><p><strong>@Retention：</strong></p><p>　　<strong>@Retention</strong>定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。</p><p>　　<strong>作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</strong></p><p>　　<strong>取值（RetentionPoicy）有：</strong></p><p>　　　　1.SOURCE:在源文件中有效（即源文件保留）<br>　　　　2.CLASS:在class文件中有效（即class保留）<br>　　　　3.RUNTIME:在运行时有效（即运行时保留）</p><p>　<strong>@Documented:</strong></p><p>　　<strong><em>\</em>@**</strong>Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。</p><p><strong>@Inherited：</strong></p><p>　　@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</p><p>　　注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。</p><p>　　当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper的leader选举</title>
      <link href="/2020/11/14/Zookeeper%E7%9A%84leader%E9%80%89%E4%B8%BE/"/>
      <url>/2020/11/14/Zookeeper%E7%9A%84leader%E9%80%89%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Zookeeper的Leader选举"><a href="#Zookeeper的Leader选举" class="headerlink" title="Zookeeper的Leader选举"></a>Zookeeper的Leader选举</h1><p>前面我们聊了一下ZAB协议以及Zookeeper的基础概念，心想着都到这个份上了，那还是把剩下的“Leader选举”、“分布式锁”、“惊群和脑裂”都跟大家简单聊聊,这些知识应该足够准备校招的你<code>造火箭</code>了。</p><p>今天首先说一下Zookeeper的<code>Leader选举流程</code>以及其中涉及的<code>FastLeaderElection选举算法</code>。</p><h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p><strong>ZAB协议是保证Zookeeper集群数据一致性协议其中会涉及选举流程，FastLeaderElection是Zookeeper选举Leader的算法之一。这两点概念一定要搞清楚，不然很容易混为一谈。</strong></p><h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>两个关键时期：</p><ul><li>启动Zookeeper集群时</li><li>Leader崩溃进行崩溃恢复时</li></ul><p><strong>一些基础概念你需要提前预知：</strong></p><p><img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/887a4826415141fda9e48fbf29503ccd~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>1.对选举Leader的要求:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选出的leader节点上要持有最高zxid</span><br><span class="line">选出的leader要有过半数节点同意</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>2.内置实现的选举算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LeaderElection</span><br><span class="line">FastLeaderElection（默认的）</span><br><span class="line">AuthFastLeaderElection</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>3.选举状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LOOKING：竞选状态</span><br><span class="line">FOLLOWING：跟随状态，同步leader状态，参与投票</span><br><span class="line">OBSERVING：管擦状态，同步leader状态，不参与投票</span><br><span class="line">LEADING：领导者状态</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>4.部分名词</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务器id---myid(或后文的sid，集群模式下必有该配置项) </span><br><span class="line">事务id---服务器中存放的最大zxid</span><br><span class="line">逻辑时钟---发起的投票轮数计数</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h2><blockquote><p>Zookeeper要求集群机器必须是<code>奇数个</code>(避免脑裂，下文会讲)，那么我们假设有三台服务器。接着介绍一下三台服务器的Leader选举流程。</p></blockquote><ul><li>每个Server发出一个投票。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID，使用(myid, ZXID)来表示，此时Server1的投票为(1, 0)，Server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS：不懂什么叫为自己投票(不知道票的数据结构？)，别急后面带你看源码！！！</span><br></pre></td></tr></table></figure><ul><li>接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。</li><li>处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行比较，比较规则如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 优先判断ZXID。ZXID（事务ID）比较大的服务器优先作为Leader。</span><br><span class="line"> </span><br><span class="line"> 如果ZXID相同，那么就比较myid。myid（服务器ID）较大的服务器作为Leader服务器。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>对于Server1而言，它的投票是(1, 0)，接收Server2的投票为(2, 0)，首先会比较两者的ZXID，均为0，再比较myid，此时Server2的myid最大，于是更新自己的投票为(2, 0)，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS:于是更新自己的投票为(2, 0)?</span><br></pre></td></tr></table></figure><p>其涵义指的是将自己下次发出的投票信息更新为(2, 0)，以该票作为新的投票依据。</p><ul><li>统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于Server1、Server2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出了Leader。</li><li>改变服务器状态。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。</li></ul><hr><p><strong>简而言之</strong></p><p>1.每个服务实例均发起选举自己为leader的投票。</p><p>2.其他服务实例收到投票邀请时，比较发起者的数据事务id是否比自己最新的事务ID大，大则给它投一票，小则不投票，相等则比较发起者的服务器ID，大则投票给它 。</p><p>3.发起者收到大家的投票反馈后，看投票数（包括自己的票数）是否大于集群的半数，大于则成为leader，未超过半数且leader未选出，则再次发起投票。</p><h3 id="Leader选举算法"><a href="#Leader选举算法" class="headerlink" title="Leader选举算法"></a>Leader选举算法</h3><blockquote><p>在了解了选举流程后我们介绍一下Zookeeper源码中对于算法中的实现细节。</p></blockquote><p>借助网上随处可以百度到的算法描述，我再一次针对其中涉及的<code>疑难点</code>做一个解说，其大致流程如下：</p><p><strong>第一次投票</strong>。无论哪种导致进行Leader选举，集群的所有机器都处于试图选举出一个Leader的状态，即LOOKING状态，LOOKING机器会向所有其他机器发送消息，该消息称为投票。投票中包含了SID（服务器的唯一标识）和ZXID（事务ID），(SID, ZXID)形式来标识一次投票信息。</p><p>假定Zookeeper由5台机器组成，SID分别为1、2、3、4、5，ZXID分别为9、9、9、8、8，并且此时SID为2的机器是Leader机器，某一时刻，1、2所在机器出现故障，因此集群开始进行Leader选举。在第一次投票时，每台机器都会将自己作为投票对象，于是SID为3、4、5的机器投票情况分别为(3, 9)，(4, 8)， (5, 8)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">此时五台机器手里的投票分别为：</span><br><span class="line">服务器一：（1，9）假设故障 ×</span><br><span class="line">服务器二：（2，9）假设故障 ×</span><br><span class="line">服务器三：（3，9）</span><br><span class="line">服务器四：（4，8）</span><br><span class="line">服务器五：（5，8）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>变更投票</strong>。每台机器发出投票后，也会收到其他机器的投票，每台机器会根据一定规则来处理收到的其他机器的投票，并以此来决定是否需要变更自己的投票，这个规则也是整个Leader选举算法的核心所在，其中术语描述如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vote_sid：接收到的投票中所推举Leader服务器的SID。</span><br><span class="line"></span><br><span class="line">vote_zxid：接收到的投票中所推举Leader服务器的ZXID。</span><br><span class="line"></span><br><span class="line">self_sid：当前服务器自己的SID。</span><br><span class="line"></span><br><span class="line">self_zxid：当前服务器自己的ZXID。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>每次对收到的投票的处理，都是对(vote_sid, vote_zxid)和(self_sid, self_zxid)对比的过程。</p><p>规则一：如果vote_zxid大于self_zxid，就认可当前收到的投票，并再次将该投票发送出去。(接收到的事务id大于自己当前事务id)</p><p>规则二：如果vote_zxid小于self_zxid，那么坚持自己的投票，不做任何变更。(接收到的事务id小于自己当前事务id)</p><p>规则三：如果vote_zxid等于self_zxid，那么就对比两者的SID，如果vote_sid大于self_sid，那么就认可当前收到的投票，并再次将该投票发送出去。（事务ID相等比较服务器ID及zxid）</p><p>规则四：如果vote_zxid等于self_zxid，并且vote_sid小于self_sid，那么坚持自己的投票，不做任何变更。</p><p><strong>具体流程如图：</strong></p><p><img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba3f5da1aad24e7da6ef1309643d10e9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p><strong>确定Leader</strong>。经过第二轮投票后，集群中的每台机器都会再次接收到其他机器的投票，然后开始统计投票，如果一台机器收到了超过半数的相同投票，那么这个投票对应的SID机器即为Leader。此时Server3将成为Leader。</p><h2 id="选举流程源码"><a href="#选举流程源码" class="headerlink" title="选举流程源码"></a>选举流程源码</h2><blockquote><p>光说不练假把式，搞懂了Leader选举的基本流程，再来探究一下源码，源码之下无秘密！</p></blockquote><p>用我的地址去拉取源码可能会快些。<a href="https://hub.fastgit.org/Xxianglei/zookeeper.git" target="_blank" rel="noopener">Zookeeper源码 git clone</a></p><h3 id="投票数据结构"><a href="#投票数据结构" class="headerlink" title="投票数据结构"></a>投票数据结构</h3><p>我们先解决前面的疑惑投票（或者说票）到底是什么结构？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vote</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> version;<span class="comment">// 版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id;<span class="comment">//被推举的Leader的SID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> zxid;<span class="comment">//被推举的Leader事务ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> electionEpoch;<span class="comment">//逻辑时钟，用来判断多个投票是否在同一轮选举周期中，每轮自加1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> peerEpoch;<span class="comment">//被推举的Leader的epoch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerState state;<span class="comment">//当前服务器的状态</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务器状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ServerState &#123;</span><br><span class="line">        LOOKING,</span><br><span class="line">        FOLLOWING,</span><br><span class="line">        LEADING,</span><br><span class="line">        OBSERVING</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>知道我们投的是什么票了，接下来我们理一下整个算法流程。</p><h3 id="源码入口"><a href="#源码入口" class="headerlink" title="源码入口"></a>源码入口</h3><blockquote><p>zookeeper\zookeeper-server\src\main\java\org\apache\zookeeper\server\quorum下</p></blockquote><p>非核心代码我给大家省去了，如果有兴趣想研究，可以按着我的分析流程查看源码细节。</p><h4 id="QuorumPeerMain-java"><a href="#QuorumPeerMain-java" class="headerlink" title="QuorumPeerMain.java"></a>QuorumPeerMain.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * To start the replicated server specify the configuration file name on</span></span><br><span class="line"><span class="comment"> * the command line.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args path to the configfile</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    QuorumPeerMain main = <span class="keyword">new</span> QuorumPeerMain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        main.initializeAndRun(args);<span class="comment">//入口</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(<span class="string">"Exiting normally"</span>);</span><br><span class="line">    ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeAndRun</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ConfigException, IOException, AdminServerException </span>&#123;</span><br><span class="line">    QuorumPeerConfig config = <span class="keyword">new</span> QuorumPeerConfig();</span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">        config.parse(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start and schedule the the purge task</span></span><br><span class="line">    DatadirCleanupManager purgeMgr = <span class="keyword">new</span> DatadirCleanupManager(</span><br><span class="line">        config.getDataDir(),</span><br><span class="line">        config.getDataLogDir(),</span><br><span class="line">        config.getSnapRetainCount(),</span><br><span class="line">        config.getPurgeInterval());</span><br><span class="line">    purgeMgr.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是standalone模式还是集群模式</span></span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span> &amp;&amp; config.isDistributed()) &#123;</span><br><span class="line">        <span class="comment">//集群模式</span></span><br><span class="line">        runFromConfig(config);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG.warn(<span class="string">"Either no config or no quorum defined in config, running in standalone mode"</span>);</span><br><span class="line">        <span class="comment">// there is only server in the quorum -- run as standalone</span></span><br><span class="line">        ZooKeeperServerMain.main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFromConfig</span><span class="params">(QuorumPeerConfig config)</span> <span class="keyword">throws</span> IOException, AdminServerException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ManagedUtil.registerLog4jMBeans();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JMException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">"Unable to register log4j JMX control"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG.info(<span class="string">"Starting quorum peer"</span>);</span><br><span class="line">    MetricsProvider metricsProvider;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        metricsProvider = MetricsProviderBootstrap.startMetricsProvider(</span><br><span class="line">            config.getMetricsProviderClassName(),</span><br><span class="line">            config.getMetricsProviderConfiguration());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MetricsProviderLifeCycleException error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Cannot boot MetricsProvider "</span> + config.getMetricsProviderClassName(), error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServerMetrics.metricsProviderInitialized(metricsProvider);</span><br><span class="line">        ServerCnxnFactory cnxnFactory = <span class="keyword">null</span>;</span><br><span class="line">        ServerCnxnFactory secureCnxnFactory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为客户端提供读写的server 及2181的端口</span></span><br><span class="line">        <span class="keyword">if</span> (config.getClientPortAddress() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config.getSecureClientPortAddress() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            secureCnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">//启动主线程</span></span><br><span class="line">        quorumPeer.start();</span><br><span class="line">        ZKAuditProvider.addZKStartStopAuditLog();</span><br><span class="line">        quorumPeer.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// warn, but generally this is ok</span></span><br><span class="line">        LOG.warn(<span class="string">"Quorum Peer interrupted"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="调用-QuorumPeer-的-start方法"><a href="#调用-QuorumPeer-的-start方法" class="headerlink" title="调用 QuorumPeer 的 start方法"></a>调用 QuorumPeer 的 start方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getView().containsKey(myid)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"My id "</span> + myid + <span class="string">" not in the peer list"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//loaddatabase主要是从本地文件中恢复数据，以及获取最新的 zxid</span></span><br><span class="line">    loadDataBase();</span><br><span class="line">    startServerCnxnFactory();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        adminServer.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AdminServerException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">"Problem starting AdminServer"</span>, e);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//选举初始化</span></span><br><span class="line">    startLeaderElection();</span><br><span class="line">    startJvmPauseMonitor();</span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startLeaderElection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前节点状态是LOOKING 投票给自己</span></span><br><span class="line">        <span class="keyword">if</span> (getPeerState() == ServerState.LOOKING) &#123;</span><br><span class="line">            currentVote = <span class="keyword">new</span> Vote(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        RuntimeException re = <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        re.setStackTrace(e.getStackTrace());</span><br><span class="line">        <span class="keyword">throw</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据配置获取选举算法 可以通过在 zoo.cfg 里面进行配置，默认是 fast 选举</span></span><br><span class="line">    <span class="keyword">this</span>.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Election <span class="title">createElectionAlgorithm</span><span class="params">(<span class="keyword">int</span> electionAlgorithm)</span> </span>&#123;</span><br><span class="line">    Election le = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> use a factory rather than a switch</span></span><br><span class="line">    <span class="keyword">switch</span> (electionAlgorithm) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Election Algorithm 1 is not supported."</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Election Algorithm 2 is not supported."</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="comment">//leader选举网络io负责类（负责底层网络处理接收和发送队列中的消息）</span></span><br><span class="line">        QuorumCnxManager qcm = createCnxnManager();</span><br><span class="line">        QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);</span><br><span class="line">        <span class="keyword">if</span> (oldQcm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LOG.warn(<span class="string">"Clobbering already-set QuorumCnxManager (restarting leader election?)"</span>);</span><br><span class="line">            oldQcm.halt();</span><br><span class="line">        &#125;</span><br><span class="line">        QuorumCnxManager.Listener listener = qcm.listener;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//启动已绑定的选举线程 等待集群中其他机器连接</span></span><br><span class="line">            listener.start();</span><br><span class="line">            <span class="comment">//基于TCP的选举算法 FastLeaderElection</span></span><br><span class="line">            FastLeaderElection fle = <span class="keyword">new</span> FastLeaderElection(<span class="keyword">this</span>, qcm);</span><br><span class="line">            fle.start();</span><br><span class="line">            le = fle;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.error(<span class="string">"Null listener when initializing cnx manager"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> le;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中FastLeaderElection fle = new FastLeaderElection(this, qcm);会调用一下构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FastLeaderElection</span><span class="params">(QuorumPeer self, QuorumCnxManager manager)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.stop = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">this</span>.manager = manager;</span><br><span class="line">   starter(self, manager);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一目了然不多解释</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">starter</span><span class="params">(QuorumPeer self, QuorumCnxManager manager)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.self = self;</span><br><span class="line">   proposedLeader = -<span class="number">1</span>;</span><br><span class="line">   proposedZxid = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   sendqueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;ToSend&gt;();</span><br><span class="line">   recvqueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Notification&gt;();</span><br><span class="line">   <span class="keyword">this</span>.messenger = <span class="keyword">new</span> Messenger(manager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FastLeaderElection的start方法被调用会构建Messenger</span></span><br><span class="line"><span class="comment">//Starts instances of WorkerSender and WorkerReceiver启动消息接收器和发送器线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messenger.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructor of class Messenger.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> manager   Connection manager</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> Messenger(QuorumCnxManager manager) &#123;</span><br><span class="line">  <span class="keyword">this</span>.ws = <span class="keyword">new</span> WorkerSender(manager);</span><br><span class="line">  <span class="keyword">this</span>.wsThread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>.ws, <span class="string">"WorkerSender[myid="</span> + self.getId() + <span class="string">"]"</span>);</span><br><span class="line">  <span class="keyword">this</span>.wsThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.wr = <span class="keyword">new</span> WorkerReceiver(manager);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.wrThread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>.wr, <span class="string">"WorkerReceiver[myid="</span> + self.getId() + <span class="string">"]"</span>);</span><br><span class="line">  <span class="keyword">this</span>.wrThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Starts instances of WorkerSender and WorkerReceiver</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.wsThread.start();</span><br><span class="line">  <span class="keyword">this</span>.wrThread.start();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 以上执行完成后QuorumPeer的run方法被调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Main loop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">//判断当前节点状态</span></span><br><span class="line">            <span class="keyword">switch</span> (getPeerState()) &#123;</span><br><span class="line">            <span class="keyword">case</span> LOOKING:</span><br><span class="line">                <span class="comment">//如果是LOOKING 则进入选举流程</span></span><br><span class="line">                LOG.info(<span class="string">"LOOKING"</span>);</span><br><span class="line">                ServerMetrics.getMetrics().LOOKING_COUNT.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"readonlymode.enabled"</span>)) &#123;</span><br><span class="line">                    LOG.info(<span class="string">"Attempting to start ReadOnlyZooKeeperServer"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Create read-only server but don't start it immediately</span></span><br><span class="line">                    <span class="keyword">final</span> ReadOnlyZooKeeperServer roZk = <span class="keyword">new</span> ReadOnlyZooKeeperServer(logFactory, <span class="keyword">this</span>, <span class="keyword">this</span>.zkDb);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Instead of starting roZk immediately, wait some grace</span></span><br><span class="line">                    <span class="comment">// period before we decide we're partitioned.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// Thread is used here because otherwise it would require</span></span><br><span class="line">                    <span class="comment">// changes in each of election strategy classes which is</span></span><br><span class="line">                    <span class="comment">// unnecessary code coupling.</span></span><br><span class="line">                    Thread roZkMgr = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// lower-bound grace period to 2 secs</span></span><br><span class="line">                                sleep(Math.max(<span class="number">2000</span>, tickTime));</span><br><span class="line">                                <span class="keyword">if</span> (ServerState.LOOKING.equals(getPeerState())) &#123;</span><br><span class="line">                                    roZk.startup();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                LOG.info(<span class="string">"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started"</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                LOG.error(<span class="string">"FAILED to start ReadOnlyZooKeeperServer"</span>, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        roZkMgr.start();</span><br><span class="line">                        reconfigFlagClear();</span><br><span class="line">                        <span class="keyword">if</span> (shuttingDownLE) &#123;</span><br><span class="line">                            shuttingDownLE = <span class="keyword">false</span>;</span><br><span class="line">                            startLeaderElection();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//此处通过策略模式来决定当前用哪个选举算法来进行领导选举</span></span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// If the thread is in the the grace period, interrupt</span></span><br><span class="line">                        <span class="comment">// to come out of waiting.</span></span><br><span class="line">                        roZkMgr.interrupt();</span><br><span class="line">                        roZk.shutdown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        reconfigFlagClear();</span><br><span class="line">                        <span class="keyword">if</span> (shuttingDownLE) &#123;</span><br><span class="line">                            shuttingDownLE = <span class="keyword">false</span>;</span><br><span class="line">                            startLeaderElection();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//此处通过策略模式决定当前用哪个选举算法来进行领导选举</span></span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEADING:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="执行核心选举算法"><a href="#执行核心选举算法" class="headerlink" title="执行核心选举算法"></a>执行核心选举算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口前文：setCurrentVote(makeLEStrategy().lookForLeader());</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vote <span class="title">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            self.jmxLeaderElectionBean = <span class="keyword">new</span> LeaderElectionBean();</span><br><span class="line">            MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.warn(<span class="string">"Failed to register with JMX"</span>, e);</span><br><span class="line">            self.jmxLeaderElectionBean = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.start_fle = Time.currentElapsedTime();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * The votes from the current leader election are stored in recvset. In other words, a vote v is in recvset</span></span><br><span class="line"><span class="comment">             * if v.electionEpoch == logicalclock. The current participant uses recvset to deduce on whether a majority</span></span><br><span class="line"><span class="comment">             * of participants has voted for it.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//保存收到的投票</span></span><br><span class="line">            Map&lt;Long, Vote&gt; recvset = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * The votes from previous leader elections, as well as the votes from the current leader election are</span></span><br><span class="line"><span class="comment">             * stored in outofelection. Note that notifications in a LOOKING state are not stored in outofelection.</span></span><br><span class="line"><span class="comment">             * Only FOLLOWING or LEADING notifications are stored in outofelection. The current participant could use</span></span><br><span class="line"><span class="comment">             * outofelection to learn which participant is the leader if it arrives late (i.e., higher logicalclock than</span></span><br><span class="line"><span class="comment">             * the electionEpoch of the received notifications) in a leader election.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//存储选举结果</span></span><br><span class="line">            Map&lt;Long, Vote&gt; outofelection = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> notTimeout = minNotificationInterval;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">//增加逻辑时钟  +1原子操作</span></span><br><span class="line">                logicalclock.incrementAndGet();</span><br><span class="line">                <span class="comment">//更新自己的zxid和epoch</span></span><br><span class="line">                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LOG.info(</span><br><span class="line">                <span class="string">"New election. My id = &#123;&#125;, proposed zxid=0x&#123;&#125;"</span>,</span><br><span class="line">                self.getId(),</span><br><span class="line">                Long.toHexString(proposedZxid));</span><br><span class="line">            <span class="comment">//发送投票 包括发送给自己（广播）</span></span><br><span class="line">            sendNotifications();</span><br><span class="line"></span><br><span class="line">            SyncedLearnerTracker voteSet;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Loop in which we exchange notifications until we find a leader</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//进行while循环 直到选举出leader</span></span><br><span class="line">            <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp; (!stop)) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Remove next notification from queue, times out after 2 times</span></span><br><span class="line"><span class="comment">                 * the termination time</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//从接收IO线程里拿到投票信息 自己的投票也在这里处理</span></span><br><span class="line">                Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Sends more notifications if haven't received enough.</span></span><br><span class="line"><span class="comment">                 * Otherwise processes new notification.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//如果为空 消息发完了 继续发送 一直到选出leader为止</span></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (manager.haveDelivered()) &#123;</span><br><span class="line">                        sendNotifications();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//消息还没投递出去 可能是其他server还没启动 尝试再连接</span></span><br><span class="line">                        manager.connectAll();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Exponential backoff</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="comment">//延长超时时间</span></span><br><span class="line">                    <span class="keyword">int</span> tmpTimeOut = notTimeout * <span class="number">2</span>;</span><br><span class="line">                    notTimeout = Math.min(tmpTimeOut, maxNotificationInterval);</span><br><span class="line">                    LOG.info(<span class="string">"Notification time out: &#123;&#125;"</span>, notTimeout);</span><br><span class="line">                    <span class="comment">//收到投票消息 判断收到的消息是不是属于这个集群内</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (validVoter(n.sid) &amp;&amp; validVoter(n.leader)) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Only proceed if the vote comes from a replica in the current or next</span></span><br><span class="line"><span class="comment">                     * voting view for a replica in the current or next voting view.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="comment">//判断收到的消息的节点的状态</span></span><br><span class="line">                    <span class="keyword">switch</span> (n.state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> LOOKING:</span><br><span class="line">                        <span class="keyword">if</span> (getInitLastLoggedZxid() == -<span class="number">1</span>) &#123;</span><br><span class="line">                            LOG.debug(<span class="string">"Ignoring notification as our zxid is -1"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (n.zxid == -<span class="number">1</span>) &#123;</span><br><span class="line">                            LOG.debug(<span class="string">"Ignoring notification from member with -1 zxid &#123;&#125;"</span>, n.sid);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// If notification &gt; current, replace and send messages out</span></span><br><span class="line">                        <span class="comment">//判断接收到的节点epoch大于logicalclock  则表示当前是新一轮的选举</span></span><br><span class="line">                        <span class="keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;</span><br><span class="line">                            <span class="comment">//更新本地logicalclock</span></span><br><span class="line">                            logicalclock.set(n.electionEpoch);</span><br><span class="line">                            <span class="comment">//清空接收队列</span></span><br><span class="line">                            recvset.clear();</span><br><span class="line">                            <span class="comment">//检查收到的消息是否可以胜出 依次比较epoch zxid myid</span></span><br><span class="line">                            <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;</span><br><span class="line">                                <span class="comment">//胜出后 把投票改为对方的票据</span></span><br><span class="line">                                updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//否则 票据不变</span></span><br><span class="line">                                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//继续广播 让其他节点知道我现在的票据</span></span><br><span class="line">                            sendNotifications();</span><br><span class="line">                            <span class="comment">//如果收到的消息epoch小于当前节点的epoch 则忽略这条消息</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;</span><br><span class="line">                                LOG.debug(</span><br><span class="line">                                    <span class="string">"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x&#123;&#125;, logicalclock=0x&#123;&#125;"</span>,</span><br><span class="line">                                    Long.toHexString(n.electionEpoch),</span><br><span class="line">                                    Long.toHexString(logicalclock.get()));</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                            <span class="comment">//如果epoch相同 继续比较zxid myid 如果胜出 则更新自己的票据 并发出广播</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) &#123;</span><br><span class="line">                            updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                            sendNotifications();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        LOG.debug(</span><br><span class="line">                            <span class="string">"Adding vote: from=&#123;&#125;, proposed leader=&#123;&#125;, proposed zxid=0x&#123;&#125;, proposed election epoch=0x&#123;&#125;"</span>,</span><br><span class="line">                            n.sid,</span><br><span class="line">                            n.leader,</span><br><span class="line">                            Long.toHexString(n.zxid),</span><br><span class="line">                            Long.toHexString(n.electionEpoch));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// don't care about the version if it's in LOOKING state</span></span><br><span class="line">                        <span class="comment">//添加到本机投票集合 用来做选举终结判断</span></span><br><span class="line">                        recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line"></span><br><span class="line">                        voteSet = getVoteTracker(recvset, <span class="keyword">new</span> Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//判断选举是否结束 默认算法是超过半数server同意</span></span><br><span class="line">                        <span class="keyword">if</span> (voteSet.hasAllQuorums()) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Verify if there is any change in the proposed leader</span></span><br><span class="line">                            <span class="comment">//一直等到新的通知到达 直到超时</span></span><br><span class="line">                            <span class="keyword">while</span> ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) &#123;</span><br><span class="line">                                    recvqueue.put(n);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * This predicate is true once we don't read any new</span></span><br><span class="line"><span class="comment">                             * relevant message from the reception queue</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="comment">//确定leader</span></span><br><span class="line">                            <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//修改状态</span></span><br><span class="line">                                setPeerState(proposedLeader, voteSet);</span><br><span class="line">                                Vote endVote = <span class="keyword">new</span> Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);</span><br><span class="line">                                leaveInstance(endVote);</span><br><span class="line">                                <span class="keyword">return</span> endVote;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//OBSERVING 不参与选举投票</span></span><br><span class="line">                    <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                        LOG.debug(<span class="string">"Notification from observer: &#123;&#125;"</span>, n.sid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//这两种需要参与选举</span></span><br><span class="line">                    <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                    <span class="keyword">case</span> LEADING:</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Consider all notifications from the same epoch</span></span><br><span class="line"><span class="comment">                         * together.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="comment">//判断epoch是否相同</span></span><br><span class="line">                        <span class="keyword">if</span> (n.electionEpoch == logicalclock.get()) &#123;</span><br><span class="line">                            <span class="comment">//如果相同 加入本机的投票集合</span></span><br><span class="line">                            recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line">                            voteSet = getVoteTracker(recvset, <span class="keyword">new</span> Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line">                            <span class="comment">//判断是否结束 如果结束 确认leader是否有效</span></span><br><span class="line">                            <span class="keyword">if</span> (voteSet.hasAllQuorums() &amp;&amp; checkLeader(recvset, n.leader, n.electionEpoch)) &#123;</span><br><span class="line">                                <span class="comment">//修改自己的状态并返回投票结果</span></span><br><span class="line">                                setPeerState(n.leader, voteSet);</span><br><span class="line">                                Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);</span><br><span class="line">                                leaveInstance(endVote);</span><br><span class="line">                                <span class="keyword">return</span> endVote;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Before joining an established ensemble, verify that</span></span><br><span class="line"><span class="comment">                         * a majority are following the same leader.</span></span><br><span class="line"><span class="comment">                         *</span></span><br><span class="line"><span class="comment">                         * Note that the outofelection map also stores votes from the current leader election.</span></span><br><span class="line"><span class="comment">                         * See ZOOKEEPER-1732 for more information.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        outofelection.put(n.sid, <span class="keyword">new</span> Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line">                        voteSet = getVoteTracker(outofelection, <span class="keyword">new</span> Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (voteSet.hasAllQuorums() &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;</span><br><span class="line">                            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                                logicalclock.set(n.electionEpoch);</span><br><span class="line">                                setPeerState(n.leader, voteSet);</span><br><span class="line">                            &#125;</span><br><span class="line">                            Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);</span><br><span class="line">                            leaveInstance(endVote);</span><br><span class="line">                            <span class="keyword">return</span> endVote;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        LOG.warn(<span class="string">"Notification state unrecoginized: &#123;&#125; (n.state), &#123;&#125;(n.sid)"</span>, n.state, n.sid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!validVoter(n.leader)) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">"Ignoring notification for non-cluster member sid &#123;&#125; from sid &#123;&#125;"</span>, n.leader, n.sid);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!validVoter(n.sid)) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">"Ignoring notification for sid &#123;&#125; from non-quorum member sid &#123;&#125;"</span>, n.leader, n.sid);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (self.jmxLeaderElectionBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOG.warn(<span class="string">"Failed to unregister with JMX"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            self.jmxLeaderElectionBean = <span class="keyword">null</span>;</span><br><span class="line">            LOG.debug(<span class="string">"Number of connection processing threads: &#123;&#125;"</span>, manager.getConnectionThreadCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Send notifications to all peers upon a change in our vote</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   广播消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendNotifications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//循环发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> sid : self.getCurrentAndNextConfigVoters()) &#123;</span><br><span class="line">            QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">            <span class="comment">//消息实体</span></span><br><span class="line">            ToSend notmsg = <span class="keyword">new</span> ToSend(</span><br><span class="line">                ToSend.mType.notification,</span><br><span class="line">                proposedLeader,</span><br><span class="line">                logicalclock.get(),</span><br><span class="line">                QuorumPeer.ServerState.LOOKING,</span><br><span class="line">                sid,</span><br><span class="line">                proposedEpoch,</span><br><span class="line">                qv.toString().getBytes());</span><br><span class="line"></span><br><span class="line">            LOG.debug(</span><br><span class="line">                <span class="string">"Sending Notification: &#123;&#125; (n.leader), 0x&#123;&#125; (n.zxid), 0x&#123;&#125; (n.round), &#123;&#125; (recipient),"</span></span><br><span class="line">                    + <span class="string">" &#123;&#125; (myid), 0x&#123;&#125; (n.peerEpoch) "</span>,</span><br><span class="line">                proposedLeader,</span><br><span class="line">                Long.toHexString(proposedZxid),</span><br><span class="line">                Long.toHexString(logicalclock.get()),</span><br><span class="line">                sid,</span><br><span class="line">                self.getId(),</span><br><span class="line">                Long.toHexString(proposedEpoch));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加到发送队列 这个队列会被workersender消费</span></span><br><span class="line">            sendqueue.offer(notmsg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>借助一张网络图片，该图对于选举流程中涉及到数据的流向的描述还是很清楚的。</p><p><img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3e4e95bf12d42c5b54cd862dea068e6~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>其中涉及一个<code>网络IO管理器</code>：负责维护处理发送和接收两个线程。及选举算法从<code>队列消费</code>和<code>生产</code>投票消息。最终执行核心的<code>选票PK</code>，按照一定策略进行更新和丢弃，直到选<code>举出一个</code>Leader。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要想理解清楚Leader选举流程，其中几个重要的概念及名词要清楚。</p><ul><li>事务ID和Zxid的概念要明确</li><li>Zxid和Sid比较的先后顺序及比较策略</li><li>如何理解更新选票并广播自己的选票</li></ul><p>OK！关于Zookeeper的Leader选举流程暂时就聊这么多，后期还会对ZK实现的分布式锁以及涉及到的”惊群和脑裂的概念做一个介绍”，如果还有时间的话，再聊聊Zk是进行数据同步的几种模式！欢迎关注公众号：“<code>Java编程之道</code>”！🌹</p><p>作者：爱唠嗑的阿磊<br>链接：<a href="https://juejin.im/post/6883483460686594061" target="_blank" rel="noopener">https://juejin.im/post/6883483460686594061</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZAB协议</title>
      <link href="/2020/11/14/ZAB%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/11/14/ZAB%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><blockquote><p>百度百科：ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。</p><p>它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等</p></blockquote><p>zookeeper是一个很热门的分布式框架，熟练掌握ZK的基本使用、分布式锁的实现以及相关场景的运用是必不可少的。鄙人有幸在<code>Shopee</code>的面试中被问过ZAB协议以及Learder选举流程，所以在此做一个总结，分享给大家自己的理解，愿对你有所帮助。</p><p>今天不介绍ZK的基础使用，仅对ZK中的ZAB协议的理解进行一个分享，如有不足之处欢迎大家指出。</p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><blockquote><p>ZAB 协议全称：Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。</p></blockquote><p>Zookeeper 是一个为分布式应用提供高效且可靠的分布式协调服务。在CAP理论中Zookeeper 属于CP模型，强调各个节点间数据强一致性，通过zab协议建立一个高可用可扩展的分布式数据主备系统。</p><ol><li>深刻理解ZAB协议，才能更好的理解zookeeper对于分布式系统建设的重要性。以及为什么采用zookeeper就能保证分布式系统中数据最终一致性，服务的高可用性。</li></ol><h2 id="ZAB协议原理"><a href="#ZAB协议原理" class="headerlink" title="ZAB协议原理"></a>ZAB协议原理</h2><p>ZAB协议要求每个leader都要经历三个阶段，即发现，同步，广播。</p><ul><li><strong>发现</strong>：即要求zookeeper集群必须选择出一个leader进程，同时leader会维护一个follower可用列表。将来客户端可以这follower中的节点进行通信。</li><li><strong>同步</strong>：leader要负责将本身的数据与follower完成同步，做到多副本存储。这样也是体现了CAP中高可用和分区容错。follower将队列中未处理完的请求消费完成后，写入本地事物日志中。</li><li><strong>广播</strong>：leader可以接受客户端新的proposal请求，将新的proposal请求广播给所有的follower。</li></ul><h2 id="应用范畴"><a href="#应用范畴" class="headerlink" title="应用范畴"></a>应用范畴</h2><ul><li>原子广播（Leader可用时）</li><li>崩溃恢复（Leader不可用时）</li></ul><p>下面我会重点讲这两个东西。</p><p>zookeeper根据ZAB协议建立了主备模型完成zookeeper集群中数据的同步。这里所说的主备系统架构模型是指，在zookeeper集群中，只有<code>一台leader</code>负责处理外部客户端的<code>事务请求</code>(或写操作)，然后leader服务器将客户端的<code>写操作数据</code>同步到<code>所有的followe</code>r节点中。</p><p><strong>注意：</strong></p><ul><li>所有的操作都有Learder发出，即时客户端向Fllower发出请求，最终它会把这个请求交给Leader处理。</li></ul><p><img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24100c7784c84a038a540c3b0fa427a1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h4 id="数据是如何复制的呢？"><a href="#数据是如何复制的呢？" class="headerlink" title="数据是如何复制的呢？"></a>数据是如何复制的呢？</h4><p>其实zab协议下的数据复制类似于2PC。但ZAB只需要Follower有<code>一半以上返回Ack</code>信息就可以执行<code>commit</code>提交。接收到半数Ack就提交的方式，可以大大减少同步阻塞，避免过长等待所有节点的反馈才进行操作（要么全部成功要么全部失败）。</p><p>如何理解这句话将直接影响你对於ZAB的理解。所以请继续往后看！ <img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99470d1e344e49d8a034cd6e5f9d188a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><ol><li>zk集群中只有一个节点即Leader将客户端的写操作<code>转化为事务</code>(或提议-proposal)–记住这个proposal的含义他会贯穿zk的整个体系。</li><li>Leader节点再数据写完之后，将向所有的follower节点发送数据广播（复制）请求，等待所有的follower节点<code>反馈（Ack</code>）。</li><li>待Leader接收到超过半数follower节点反馈（Ack），Leader节点就会向所有的follower服务器<code>发送commit（事务提交）</code>消息。</li><li>最后数据同步到follower上，完成数据同步。</li></ol><h2 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h2><p>在Zookeeper集群中，Fllower和Leader之间的通信是通过消息队列来实现的，消息队列的加入降低了耦合度，解除了同步阻塞。</p><p><img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48356152f70648de8540dc1cab12537e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p><strong>Zookeeper中消息广播的具体步骤如下</strong>：</p><ul><li>客户端发起一个写操作请求 ，Leader服务器将客户端的request请求转化为事物proposql提案，同时为每个proposal分配一个<code>全局递增唯一</code>的ID，即ZXID（事务ID）。</li><li>leader服务器与每个follower之间都有一个队列，leader将消息发送到该队列 。</li><li>follower机器从队列中取出消息处理完(<code>写入本地事物日志中</code>)毕后，向leader服务器发送ACK确认。</li><li>leader服务器收到半数以上的follower的ACK后，即认为可以发送commit 。leader向所有的follower服务器发送commit消息。</li></ul><h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><blockquote><p>在刚刚我们说的消息广播过程中，Leader在某个时间节点突然崩溃下线了我们又该如何保证数据的一致性，比如Leader本地提交了，但是commit没有发送？</p></blockquote><p>Zab协议在原Leader崩溃后会立即要求zookeeper集群进行<code>崩溃恢复</code>和<code>leader选举</code>。我们先简单聊一下崩溃恢复的机制。</p><p>ZAB协议崩溃恢复要求满足如下2个原则：</p><ul><li>确保已经被leader提交的proposal（提议）<code>必须最终</code>被所有的follower服务器提交。</li><li>确保<code>丢弃</code>已经被leader发出的但是没有被提交的proposal。</li></ul><p>所以，ZAB设计了一下的选举算法：</p><p>前面我们提交到每个客户端请求都会被Leader包装成一个拥有唯一递增的事务ID，如果我们可以保证新选举的leader节点中含有最高的ZXID。那么就可以满足ZAB协议的两个重要原则。这样做<code>可以省去 Leader 服务器检查事务的提交和丢弃工作的这一步操作</code></p><p><strong>Why？</strong></p><p>在Leader崩溃之前，所有的从队列里面取出事务来处理的Fllower的事务ID应该是一样的。如果我们从现有的Fllower中可以选举出最高的ZXID所在的服务器：</p><ul><li>假设：leader在提出proposal时未提交之前就崩溃，那么我们找到的最大的ZXID所在的服务器一定不包含未提交的提议（proposal）。</li><li>假设：leader在发送commit消息之后崩溃。即消息已经发送到队列中，期间该被提交（commit）的提议（proposal）会被Fllower处理，那么我们一定可以找到一个ZXID最大的服务器。即该follower节点将会被选举为最新的Leader。</li></ul><p><strong>在选举出Leader后需要进行的就是Leader和Fllower之间的数据同步。</strong></p><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><blockquote><p>关于数据同步Zookeeper中数据同步一共有四类，如下：</p><ul><li>DIFF：直接差异化同步</li><li>TRUNC+DIFF：先回滚再差异化同步</li><li>TRUNC：仅回滚同步</li><li>SNAP：全量同步</li></ul></blockquote><p>本次就不对其中的四种方式一一细说，大家可以参阅《<a href="https://www.cnblogs.com/youngchaolin/p/13211752.html" target="_blank" rel="noopener">Zookeeper-数据同步</a>》这篇文章，在此我只是笼统的介绍一下ZK的数据同步概念。</p><p>Zookeeper集群中新的leader选举成功之后，leader会将自身的提交的最大提议（proposal）的事务ZXID发送给其他的follower节点。follower节点会根据leader的消息进行<code>回退</code>或者是<code>数据同步</code>操作。具体流程请移步《Zookeeper-数据同步》。</p><p><strong>Zookeeper集群如何保证新选举的leader分配的ZXID是全局唯一呢？</strong></p><p>ZXID是一个长度64位的数字，其中低32位是按照<code>数字递增</code>，即每次客户端发起一个proposal,低32位的数字简单加1。高32位是leader周期的<code>epoch编号</code>，每当选举出一个新的leader时，新的leader就从<code>本地事物日志中取出ZXID</code>,然后解析出高32位的epoch编号，<code>进行加1</code>，再将低32位的<code>全部设置为0</code>。这样就保证了每次新选举的leader后，保证了ZXID的唯一性而且是<code>保证递增</code>的。 <img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f336c11472dd425bac74cacdcede634e~tplv-k3u1fbpfcp-zoom-1.image" alt="网络图片"></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于ZAB协议的介绍暂时就这么多了，Zookeeper通过ZAB协议来保证Zookeeper集群的强一致性其核心在于<code>类2PC的数据复制</code>方法以及<code>ZXID的唯一性设计</code>。</p><p>关于Zookeeper后续还会再出一篇Zookeeper实现分布式锁的原理及Leader选举算法的介绍，这些都是Zookeeper面试中的高频考点，感兴趣的同学可以关注我的公众号 <strong>“Java编程之道”</strong> 哦！</p><p>作者：爱唠嗑的阿磊<br>链接：<a href="https://juejin.im/post/6882277384112832519" target="_blank" rel="noopener">https://juejin.im/post/6882277384112832519</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 2.0具体？</title>
      <link href="/2020/11/14/HTTP-2-0%E5%85%B7%E4%BD%93%EF%BC%9F/"/>
      <url>/2020/11/14/HTTP-2-0%E5%85%B7%E4%BD%93%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a><strong>二进制传输</strong></h3><p>HTTP/2 采用二进制格式传输数据，而非 HTTP/1 的文本格式，二进制协议解析起来更高效。</p><p>HTTP/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。<strong>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码</strong>。</p><p>接下来我们介绍几个重要的概念：</p><ul><li><strong>流（stream）：</strong>流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）</li><li><strong>消息（message）：</strong>指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成</li><li><strong>帧（frame）：</strong>HTTP/2 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷等</li></ul><p>​        <img src="https://oscimg.oschina.net/oscnet/909bd5cf6598834690fac8da866915a742c.jpg" alt="img"></p><p>HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</p><ul><li>并行交错地发送多个请求，请求之间互不影响</li><li>并行交错地发送多个响应，响应之间互不干扰</li></ul><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客<br>户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><p><img src="/2020/11/14/HTTP-2-0%E5%85%B7%E4%BD%93%EF%BC%9F/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201114160941824.png" alt="image-20201114160941824"></p><h3 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a><strong>Header 压缩</strong></h3><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。<br>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。<br>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p><p><img src="/2020/11/14/HTTP-2-0%E5%85%B7%E4%BD%93%EF%BC%9F/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201114161042689.png" alt="image-20201114161042689"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>攻击技术</title>
      <link href="/2020/11/14/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/"/>
      <url>/2020/11/14/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="arp欺骗"><a href="#arp欺骗" class="headerlink" title="arp欺骗"></a>arp欺骗</h3><p>在使用以太网交换机的网络中，攻击者向某个以太网交换机发送大量的伪造源 MAC 地址，以太网交换机收到这样的帧就把虚假的 MAC 源地址填入到交换表中，由于伪造的数量很大很快就填满了表，导致以太网交换机无法正常工作。</p><p> 1.解决方法：</p><p>利用交换机防止ARP攻击</p><p>在交换机上绑定MAC地址与IP地址，为每台主机添加一条IP地址和MAC地址对应的关系静态地址表。用户发送数据包时，若交换机获得的IP和MAC地址与之前建立的映射表匹配，则发送的包能通过，否则将丢弃该数据包，从而有效地防止ARP欺骗。</p><p>2.DHCP snooping，网上设备可借由DHCP保留网络上各计算机的MAC地址。</p><h3 id="SYN-flood"><a href="#SYN-flood" class="headerlink" title="SYN flood"></a>SYN flood</h3><p>Syn-Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问。</p><p>解决方法</p><p>1.缩短超时（SYN Timeout）时间</p><p>2.增加最大半连接数</p><p>3.延缓TCB分配方法</p><p>从前面SYN Flood原理可以看到，消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用SYN Cache和SYN Cookie技术。</p><p>SYN cookies技术： </p><ol><li><strong>当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源</strong>，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源 Id，目的 Id，端口号以及只有服务器自己知道的一个秘密函数**生成一个 cookie，并把 cookie 作为序列号响应给客户端。 </li><li><strong>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段</strong>。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，<strong>如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源</strong></li></ol><h3 id="DNS欺骗？"><a href="#DNS欺骗？" class="headerlink" title="DNS欺骗？"></a>DNS欺骗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先欺骗者向目标机器发送构造好的ARP应答数据包，ARP欺骗成功后，嗅探到对方发出的DNS请求数据包，分析数据包取得ID和端口号后，向目标发送自己构造好的一个DNS返回包，对方收到DNS应答包后，发现ID和端口号全部正确，即把返回数据包中的域名和对应的IP地址保存进DNS缓存表中，而后来的当真实的DNS应答包返回时则被丢弃。</span><br></pre></td></tr></table></figure><p>原理：如果可以冒充域名服务器，把域名指往不正确的IP地址。</p><p>1.预防ARP欺骗攻击</p><p>2.直接使用IP地址访问</p><p>3.对DNS数据包进行监测</p><p>   在DNS欺骗攻击中，Client会接收到至少两个DNS的数据响应包，一个是真实的数据包，另一个是攻击数据包。欺骗攻击数据包为了抢在真实应答包之前回复给Client，它的信息数据结构与真实的数据包相比十分简单，只有应答域，而不包括授权域和附加域。。</p><h3 id="中间人攻击？"><a href="#中间人攻击？" class="headerlink" title="中间人攻击？"></a>中间人攻击？</h3><p>中间人（MITM）攻击是一种攻击类型，其中攻击者将它自己放到两方之间，通常是客户端和服务端通信线路的中间。这可以通过破坏原始频道之后拦截一方的消息并将它们转发（有时会有改变）给另一方来实现。(DNS欺骗等攻击都是典型的MITM攻击)</p><p>攻击者常考虑的方式是ARP欺骗或DNS欺骗等，将会话双方的通讯流暗中改变</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>final finally finalize的区别</title>
      <link href="/2020/11/14/final-finally-finalize%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/11/14/final-finally-finalize%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>1. final</strong> </p><p>　　在java中，final可以用来修饰类，方法和变量（成员变量或局部变量）。下面将对其详细介绍。</p><p><strong>1.1 修饰类</strong></p><p>　　当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰，但要注意：</p><p>final类中所有的成员方法都会隐式的定义为final方法。</p><p><strong>1.2 修饰方法</strong></p><p>final方法意味着“最后的、最终的”含义，即此方法不能被重写。</p><p><strong>注意：若父类中final方法的访问权限为private，将导致子类中不能直接继承该方法，因此，此时可以在子类中定义相同方法名的函数，此时不会与重写final的矛盾，而是在子类中重新地定义了新方法。</strong></p><p><strong>1.3 修饰变量</strong></p><p> 　final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。类似于C++中的const。</p><p>　　当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。　</p><p><strong>2. finally</strong></p><p> 　finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。（×）（这句话其实存在一定的问题）</p><p>　　很多人都认为finally语句块一定会执行，但真的是这样么？答案是否定的，例如下面这个例子：</p><p><strong>3. finalize</strong>　　</p><p>　　finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。 </p><p>　　一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象</p><p>在finalize()方法中重新引用到”GC  Roots”链上（如把当前对象的引用this赋值给某对象的类变量/成员变量，重新建立可达的引用）</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis的IO复用?</title>
      <link href="/2020/11/13/redis%E7%9A%84IO%E5%A4%8D%E7%94%A8/"/>
      <url>/2020/11/13/redis%E7%9A%84IO%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的<br>事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p><p><img src="/2020/11/13/redis%E7%9A%84IO%E5%A4%8D%E7%94%A8/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201113211529798.png" alt="image-20201113211529798"></p><h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的<br>时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。<br>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def aeProcessEvents():</span><br><span class="line">    # 获取到达时间离当前时间最接近的时间事件</span><br><span class="line">    time_event &#x3D; aeSearchNearestTimer()</span><br><span class="line">    # 计算最接近的时间事件距离到达还有多少毫秒</span><br><span class="line">    remaind_ms &#x3D; time_event.when - unix_ts_now()</span><br><span class="line">    # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span><br><span class="line">    if remaind_ms &lt; 0:</span><br><span class="line">    remaind_ms &#x3D; 0</span><br><span class="line">    # 根据 remaind_ms 的值，创建 timeval</span><br><span class="line">    timeval &#x3D; create_timeval_with_ms(remaind_ms)</span><br><span class="line">    # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">    # 处理所有已产生的文件事件</span><br><span class="line">    procesFileEvents()</span><br><span class="line">    # 处理所有已到达的时间事件</span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如<br>下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    # 初始化服务器</span><br><span class="line">    init_server()</span><br><span class="line">    # 一直处理事件，直到服务器关闭为止</span><br><span class="line">    while server_is_not_shutdown():</span><br><span class="line">    aeProcessEvents()</span><br><span class="line">    # 服务器关闭，执行清理操作</span><br><span class="line">    clean_server()</span><br></pre></td></tr></table></figure><p>从事件处理的角度来看，服务器运行流程如下：</p><p><img src="/2020/11/13/redis%E7%9A%84IO%E5%A4%8D%E7%94%A8/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201113211637841.png" alt="image-20201113211637841"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大量time_wait出现的原因?</title>
      <link href="/2020/11/13/%E5%A4%A7%E9%87%8Ftime-wait%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>/2020/11/13/%E5%A4%A7%E9%87%8Ftime-wait%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="大量TIME-WAIT出现场景"><a href="#大量TIME-WAIT出现场景" class="headerlink" title="大量TIME_WAIT出现场景"></a><strong>大量TIME_WAIT出现场景</strong></h3><p>　　在<strong>高并发短连接</strong>的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p><h3 id="大量TIME-WAIT解决方案"><a href="#大量TIME-WAIT解决方案" class="headerlink" title="大量TIME_WAIT解决方案"></a><strong>大量TIME_WAIT解决方案</strong></h3><h4 id="应用层面"><a href="#应用层面" class="headerlink" title="应用层面"></a><strong>应用层面</strong></h4><p>　　尽量避免频繁关闭连接，如业务优化，或者使用长连接等；</p><h4 id="系统层面"><a href="#系统层面" class="headerlink" title="系统层面"></a><strong>系统层面</strong></h4><ol><li>缩短MSL时间。</li><li>增加可用端口数量。可用端口数量=单进程可打开的连接数量*机器数量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大量close_wait出现的原因?</title>
      <link href="/2020/11/13/%E5%A4%A7%E9%87%8Fclose-wait%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>/2020/11/13/%E5%A4%A7%E9%87%8Fclose-wait%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<p>通常，CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的 CLOSE_WAIT 状态，那么就意味着被动关闭的一方没有及时发出 FIN 包，一般有如下几种可能：</p><ul><li>程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。</li><li>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。</li></ul><p><a href="https://www.cnblogs.com/grey-wolf/p/10936657.html" target="_blank" rel="noopener">https://www.cnblogs.com/grey-wolf/p/10936657.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器排查问题</title>
      <link href="/2020/11/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="TOP指令"><a href="#TOP指令" class="headerlink" title="TOP指令"></a>TOP指令</h3><p>图一(ubuntu)：</p><p><img src="https://img-blog.csdn.net/2018080815173689?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqY2xzeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><strong>第1行：top - 05:43:27 up 4:52, 2 users, load average: 0.58, 0.41, 0.30</strong><br>第1行是任务队列信息，其参数如下：</p><table><thead><tr><th align="left">内容</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">05:43:27</td><td align="left">表示当前时间</td></tr><tr><td align="left">up 4:52</td><td align="left">系统运行时间 格式为时：分</td></tr><tr><td align="left">2 users</td><td align="left">当前登录用户数</td></tr><tr><td align="left">load average: 0.58, 0.41, 0.30</td><td align="left">系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</td></tr></tbody></table><p>load average: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">系统平均负载被定义为在特定时间间隔内运行队列中的平均进程数。</span><br></pre></td></tr></table></figure><p><strong>第2行：Tasks: 159 total, 1 running, 158 sleeping, 0 stopped, 0 zombie</strong><br><strong>第3行：%Cpu(s): 37.0 us, 3.7 sy, 0.0 ni, 59.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</strong><br>第2、3行为进程和CPU的信息<br>当有多个CPU时，这些内容可能会超过两行，其参数如下：</p><table><thead><tr><th align="left">内容</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">159 total</td><td align="left">进程总数</td></tr><tr><td align="left">1 running</td><td align="left">正在运行的进程数</td></tr><tr><td align="left">158 sleeping</td><td align="left">睡眠的进程数</td></tr><tr><td align="left">0 stopped</td><td align="left">停止的进程数</td></tr><tr><td align="left">0 zombie</td><td align="left">僵尸进程数</td></tr><tr><td align="left">37.0 us</td><td align="left">用户空间占用CPU百分比</td></tr><tr><td align="left">3.7 sy</td><td align="left">内核空间占用CPU百分比</td></tr><tr><td align="left"><strong>0.0 ni</strong></td><td align="left">用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td align="left">59.3 id</td><td align="left">空闲CPU百分比</td></tr><tr><td align="left">0.0 wa</td><td align="left">等待输入输出的CPU时间百分比</td></tr><tr><td align="left"><strong>0.0 hi</strong></td><td align="left">硬中断（Hardware IRQ）占用CPU的百分比</td></tr><tr><td align="left"><strong>0.0 si</strong></td><td align="left">软中断（Software Interrupts）占用CPU的百分比</td></tr><tr><td align="left"><strong>0.0 st</strong></td><td align="left"></td></tr></tbody></table><p>第4行：KiB Mem: 1530752 total, 1481968 used, 48784 free, 70988 buffers<br>第5行：KiB Swap: 3905532 total, 267544 used, 3637988 free. 617312 cached Mem<br>第4、5行为内存信息<br>其参数如下：</p><table><thead><tr><th align="left">内容</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">KiB Mem: 1530752 total</td><td align="left">物理内存总量</td></tr><tr><td align="left">1481968 used</td><td align="left">使用的物理内存总量</td></tr><tr><td align="left">48784 free</td><td align="left">空闲内存总量</td></tr><tr><td align="left">70988 buffers（buff/cache）</td><td align="left">用作内核缓存的内存量</td></tr><tr><td align="left">KiB Swap: 3905532 total</td><td align="left">交换区总量</td></tr><tr><td align="left">267544 used</td><td align="left">使用的交换区总量</td></tr><tr><td align="left">3637988 free</td><td align="left">空闲交换区总量</td></tr><tr><td align="left">617312 cached Mem</td><td align="left">缓冲的交换区总量。</td></tr><tr><td align="left">3156100 avail Mem</td><td align="left">代表可用于进程下一次分配的物理内存数量</td></tr></tbody></table><p>上述最后提到的缓冲的交换区总量，这里解释一下，所谓缓冲的交换区总量，即内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。 </p><p>计算可用内存数有一个近似的公式：<br>第四行的free + 第四行的buffers + 第五行的cached</p><h4 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h4><table><thead><tr><th align="left">列名</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">PID</td><td align="left">进程id</td></tr><tr><td align="left">PPID</td><td align="left">父进程id</td></tr><tr><td align="left">RUSER</td><td align="left">Real user name</td></tr><tr><td align="left">UID</td><td align="left">进程所有者的用户id</td></tr><tr><td align="left">USER</td><td align="left">进程所有者的用户名</td></tr><tr><td align="left">GROUP</td><td align="left">进程所有者的组名</td></tr><tr><td align="left">TTY</td><td align="left">启动进程的终端名。不是从终端启动的进程则显示为 ?</td></tr><tr><td align="left">PR</td><td align="left">优先级</td></tr><tr><td align="left">NI</td><td align="left">nice值。负值表示高优先级，正值表示低优先级</td></tr><tr><td align="left">P</td><td align="left">最后使用的CPU，仅在多CPU环境下有意义</td></tr><tr><td align="left">%CPU</td><td align="left">上次更新到现在的CPU时间占用百分比</td></tr><tr><td align="left">TIME</td><td align="left">进程使用的CPU时间总计，单位秒</td></tr><tr><td align="left">TIME+</td><td align="left">进程使用的CPU时间总计，单位1/100秒</td></tr><tr><td align="left">%MEM</td><td align="left">进程使用的物理内存百分比</td></tr><tr><td align="left">VIRT</td><td align="left">进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td></tr><tr><td align="left">SWAP</td><td align="left">进程使用的虚拟内存中，被换出的大小，单位kb</td></tr><tr><td align="left">RES</td><td align="left">进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td></tr><tr><td align="left">CODE</td><td align="left">可执行代码占用的物理内存大小，单位kb</td></tr><tr><td align="left">DATA</td><td align="left">可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</td></tr><tr><td align="left">SHR</td><td align="left">共享内存大小，单位kb</td></tr><tr><td align="left">nFLT</td><td align="left">页面错误次数</td></tr><tr><td align="left">nDRT</td><td align="left">最后一次写入到现在，被修改过的页面数。</td></tr><tr><td align="left">S</td><td align="left">进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</td></tr><tr><td align="left">COMMAND</td><td align="left">命令名/命令行</td></tr><tr><td align="left">WCHAN</td><td align="left">若该进程在睡眠，则显示睡眠中的系统函数名</td></tr><tr><td align="left">Flags</td><td align="left">任务标志</td></tr></tbody></table><h3 id="服务器IO延时高"><a href="#服务器IO延时高" class="headerlink" title="服务器IO延时高"></a>服务器IO延时高</h3><p>iotop+p</p><p>Linux系统出现了性能问题，一般我们可以通过top、iostat、iotop、free、vmstat等命令来查看初步定位问题。</p><p>今天我们讲解就是iostat和iotop，定位问题的一般步骤：</p><p>Step-1】 iostat这个命令可以给我们提供丰富的IO状态数据，一般我们先通过该命令来查看是否存在性能瓶颈</p><p>Step-2】用iotop找出io高的进程</p><p>1、iostat常见用法：</p><p>iostat -d -k 1 10    #查看TPS和吞吐量信息</p><p>参数 -d 表示，显示设备（磁盘）使用状态；</p><p>-k某些使用block为单位的列强制使用Kilobytes为单位；</p><p>1 10表示，数据显示每隔1秒刷新一次，共显示10次</p><p><img src="https://img-blog.csdnimg.cn/20190525103401667.png" alt="img"></p><p>iostat -d -x -k 1 10   #查看设备使用率（%util）、响应时间（await）</p><p>使用-x参数我们可以获得更多统计信息。<br>注意】一般%util大于70%,I/O压力就比较大，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。磁盘可能存在瓶颈。</p><p><img src="https://img-blog.csdnimg.cn/20190525103444926.png" alt="img"></p><p>iostat还可以用来获取cpu部分状态值：</p><p>iostat -c 1 10  #查看cpu状态</p><p>注意】idle小于70% IO压力就较大了,一般读取速度有较多的wait。</p><p><img src="https://img-blog.csdnimg.cn/20190525103534337.png" alt="img"></p><p>2、我们通过上面iostat的常用命令基本可以判断IO是否存在瓶颈了，然后我们通过iotop命令来抓出罪魁祸首的进程，这里比较简单直接输入命令，然后执行（一般抓到的是java进程、mysqld，干的越多问题越多）    <img src="https://img-blog.csdnimg.cn/20190525103609528.png" alt="img"></p><p> <img src="https://img-blog.csdnimg.cn/20190525103625220.png" alt="img"></p><p><strong>只显示正在产生I/O的进程或线程。除了传参，可以在运行过程中按o生效。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node105 ~]# iotop  -o</span><br></pre></td></tr></table></figure><h3 id="CPU延时高"><a href="#CPU延时高" class="headerlink" title="CPU延时高"></a>CPU延时高</h3><p>在最近上线过程中遇到cpu占用率过高问题</p><p><img src="https://img-blog.csdn.net/20180516093934334?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>由于问题已解决,此时仅重现操作方法</p><p>1.先用top命令,找到cpu占用最高的进程 PID 如上图</p><ol start="2"><li>top –p pid </li></ol><p>(再用ps -mp pid -o THREAD,tid,time  查询进程中,那个线程的cpu占用率高 记住TID)</p><p><img src="https://img-blog.csdn.net/20180516095941290?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>3.jstack 29099 &gt;&gt; xxx.log  打印出该进程下线程日志</p><p><img src="https://img-blog.csdn.net/20180516100207813?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>4.sz xxx.log 将日志文件下载到本地</p><p><img src="https://img-blog.csdn.net/20180516100356373?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>5.将查找到的 线程占用最高的 tid 上上上图中 29108  转成16进制 — 71b4</p><p><img src="https://img-blog.csdn.net/20180516100651297?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/20180516100717935?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>6.打开下载好的 xxx.log 通过 查找方式 找到 对应线程 进行排查</p><p><img src="https://img-blog.csdn.net/20180516100825613?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVyUE9QTw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf &#39;%x&#39; 32826 获取16进制的线程id，用于dump信息查询，结果为 803a。最后我们执行jstack 32805 |grep -A 20 803a</span><br><span class="line"></span><br><span class="line"> grep -A -B -C -A -B -C 后面都跟阿拉伯数字 -A是显示匹配后和它后面的n行</span><br></pre></td></tr></table></figure><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><ul><li><p>-a 显示所有socket，包括正在监听的。</p><p>-c 每隔1秒就重新显示一遍，直到用户中断它。</p><p>-i 显示所有网络接口的信息，格式“netstat -i”。</p><p>-n 以网络IP地址代替名称，显示出网络连接情形。</p><p>-r显示核心路由表，格式同“route -e”。</p><p>-t 显示TCP协议的连接情况</p><p>-u 显示UDP协议的连接情况。</p><p>-v 显示正在进行的工作。</p><p>-p 显示建立相关连接的程序名和PID。</p><p>-b 显示在创建每个连接或侦听端口时涉及的可执行程序。</p><p>-e 显示以太网统计。此选项可以与 -s 选项结合使用。</p><p>-f 显示外部地址的完全限定域名(FQDN)。</p><p>-o显示与与网络计时器相关的信息。</p><p>-s 显示每个协议的统计。</p><p>-x 显示 NetworkDirect 连接、侦听器和共享端点。</p><p>-y 显示所有连接的 TCP 连接模板。无法与其他选项结合使用。</p></li></ul><p>查看当前所有tcp端口使用情况：</p><p>netstat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xiesshavip002 ~]# netstat -a      # 列出所有端口</span><br><span class="line">[root@xiesshavip002 ~]# netstat -at     # 列出所有TCP端口</span><br><span class="line">[root@xiesshavip002 ~]# netstat -au     # 列出所有UDP端口</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160617153120931" alt="è¿éåå¾çæè¿°"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# netstat -an | grep 3306   &#x2F;&#x2F;查看所有3306端口使用情况·</span><br></pre></td></tr></table></figure><h3 id="CPU暴增"><a href="#CPU暴增" class="headerlink" title="CPU暴增"></a>CPU暴增</h3><p><strong>如果服务器在运行中cpu突然暴增怎么排查</strong><br>首先通过ps命令查看一下占用cpu最多的进程，再根据请求选择是否要杀死它还是用其他的解决方案。</p><p>然后通过stack工具打印Java的方法栈，查看是否有死锁的存在。</p><p>然后通过其他排查工具定位问题所在。如果是数据库连接的的问题，就用回滚策略解决。如果只是单纯的请求量暴增导致的，那么就先重启服务，并在以后的开发中多进行压测。</p><h3 id="查看端口是否占用"><a href="#查看端口是否占用" class="headerlink" title="查看端口是否占用"></a>查看端口是否占用</h3><h2 id="netstat-1"><a href="#netstat-1" class="headerlink" title="netstat"></a>netstat</h2><p><strong>①.\</strong>查看所有的端口占用情况****</p><p>C:&gt;<strong>netstat -ano</strong></p><p><img src="https://img-blog.csdn.net/20180519232705552" alt="img"></p><h4 id="查看端口号-netstat"><a href="#查看端口号-netstat" class="headerlink" title="查看端口号 netstat"></a>查看端口号 netstat</h4><p>如果发现某个端口被占用后，可以用命令查看，该端口到底是被哪个进程所占用。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -pan | grep 5623</span><br><span class="line">#其中5623位端口号</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlcy5jbmJsb2dzLmNvbS9jbmJsb2dzX2NvbS9idWdpbmdjb2RlLzExNDY5NTgvb19saW51eC1uZXRzdGF0MS5wbmc?x-oss-process=image/format,png" alt="img"></p><p>发现5623的端口，被28425的进程id所占用，继续进一步跟踪，到底是哪个程序所占用了。</p><h4 id="通过进程id查找程序–ps"><a href="#通过进程id查找程序–ps" class="headerlink" title="通过进程id查找程序–ps"></a>通过进程id查找程序–ps</h4><p>直接通过：ps -aux | grep pid 查看，进程程序名称，</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlcy5jbmJsb2dzLmNvbS9jbmJsb2dzX2NvbS9idWdpbmdjb2RlLzExNDY5NTgvb19saW51eC1uZXRzdGF0Mi5wbmc?x-oss-process=image/format,png" alt="img"></p><p>通过netstat查找端口占用的pid，再通过pid进一步的查找程序名称，能够确认目前冲突的端口是哪个程序已经占用了，我们是重新启用换一个端口号，还是结束已经占用的端口号所用的程序，清空被占用的端口号。</p><h4 id="netstat-中参数选项"><a href="#netstat-中参数选项" class="headerlink" title="netstat 中参数选项"></a>netstat 中参数选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-a或--all：显示所有连线中的Socket； </span><br><span class="line">-A&lt;网络类型&gt;或--&lt;网络类型&gt;：列出该网络类型连线中的相关地址； </span><br><span class="line">-c或--continuous：持续列出网络状态； </span><br><span class="line">-C或--cache：显示路由器配置的快取信息； </span><br><span class="line">-e或--extend：显示网络其他相关信息； </span><br><span class="line">-F或--fib：显示FIB； </span><br><span class="line">-g或--groups：显示多重广播功能群组组员名单； </span><br><span class="line">-h或--help：在线帮助； </span><br><span class="line">-i或--interfaces：显示网络界面信息表单； </span><br><span class="line">-l或--listening：显示监控中的服务器的Socket； </span><br><span class="line">-M或--masquerade：显示伪装的网络连线； </span><br><span class="line">-n或--numeric：直接使用ip地址，而不通过域名服务器； </span><br><span class="line">-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称； </span><br><span class="line">-o或--timers：显示计时器； </span><br><span class="line">-p或--programs：显示正在使用Socket的程序识别码和程序名称； </span><br><span class="line">-r或--route：显示Routing Table； </span><br><span class="line">-s或--statistice：显示网络工作信息统计表； </span><br><span class="line">-t或--tcp：显示TCP传输协议的连线状况； </span><br><span class="line">-u或--udp：显示UDP传输协议的连线状况； </span><br><span class="line">-v或--verbose：显示指令执行过程； </span><br><span class="line">-V或--version：显示版本信息； </span><br><span class="line">-w或--raw：显示RAW传输协议的连线状况； </span><br><span class="line">-x或--unix：此参数的效果和指定&quot;-A unix&quot;参数相同； </span><br><span class="line">--ip或--inet：此参数的效果和指定&quot;-A inet&quot;参数相同。</span><br></pre></td></tr></table></figure><p>使用命令 jstack $pid | grep “线程id” –A 30，把信息打印出来【这里的-A 30指的是30行】【线程id：根据第5步得到的1a68在pid线程信息里面去找对应线程内容】，也可以写到文件中，下载下来，通过16进制的线程id来搜索定位代码段。</p><p><img src="https://img-blog.csdnimg.cn/20200513094714742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3ODA0OTA5NDY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>9.通过jstack命令来查看下当前内存状态，解读线程信息，定位具体代码位置,接下来就是找开发人员确认问题，看这段代码是否可以优化。</p><p> 实际案例</p><p>案例一：</p><p>定位到cpu过高是IO读写太高 ,接下来就是找开发人员确认这段代码是否可以优化</p><p><img src="https://img-blog.csdnimg.cn/20200513094811409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3ODA0OTA5NDY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>案例二：</p><p>两个线程执行过程中，需要对两个对象进行加锁，且加锁的顺序不一致，导致了死锁的产生，简单的修复方法是：对两个对象的加锁顺序一致。</p><p>注意：必须有两个可以被加锁的对象才能产生死锁，只有一个不会产生死锁问题</p><p><img src="https://img-blog.csdnimg.cn/20200513094910130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3ODA0OTA5NDY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>案例三：</p><p><img src="https://img-blog.csdnimg.cn/20200513094941778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3ODA0OTA5NDY1,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200513094958714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3ODA0OTA5NDY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>案例四：</p><p><img src="https://img-blog.csdnimg.cn/20200513095024261.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200513095044222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3ODA0OTA5NDY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>案例五：</p><p>1.生产环境heap堆内存不断上升导致oom，pst环境复现heap堆内存不断上升。经过分析堆内存创建的windq主题或队列WindqQueue、WindqTopic方式会缓存到连接工厂，缓存的对象并不是根据唯一的key去缓存，而是直接使用对象的引用作缓存，导致jvm无法回收这部分内存（比如新建同一个sendOperationTopic的主题Object1，Object2，Object1和Object2都会缓存到连接工厂）。</p><p>2.pst环境百万数据重试发现栈内存溢出，由于递归调用导致，已将递归方法修改为循环的方式去调用。</p><p>结果：修改后pst环境内存回收稳定，无连接工厂大对象，堆内存，无栈内存溢出，cpu使用情况稳定。</p><p>发现程序异常前通过执行指令，直接生成当前JVM的dump文件，15434是指JVM的进程号</p><p>jmap -dump:format=b,file=serviceDump.dat   15434 </p><p><img src="https://img-blog.csdnimg.cn/20200513095126360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3ODA0OTA5NDY1,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200513095139780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3ODA0OTA5NDY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>查看Java进程</p><p>ps aux|grep java</p><p>netstat -ano| grep pid</p><h3 id="tcpdump是干啥的？什么场景用？"><a href="#tcpdump是干啥的？什么场景用？" class="headerlink" title="tcpdump是干啥的？什么场景用？"></a>tcpdump是干啥的？什么场景用？</h3>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>公网私网？</title>
      <link href="/2020/11/12/%E5%85%AC%E7%BD%91%E7%A7%81%E7%BD%91%EF%BC%9F/"/>
      <url>/2020/11/12/%E5%85%AC%E7%BD%91%E7%A7%81%E7%BD%91%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>怎么对json格式的数据进行修改？</title>
      <link href="/2020/11/12/%E6%80%8E%E4%B9%88%E5%AF%B9json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%EF%BC%9F/"/>
      <url>/2020/11/12/%E6%80%8E%E4%B9%88%E5%AF%B9json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>建表语句如下，为 area 字段 声明为 JSON 类型；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`order`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'订单编号'</span>,</span><br><span class="line">  <span class="string">`order_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单名称'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`year`</span> <span class="keyword">year</span>(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年份'</span>,</span><br><span class="line">  <span class="string">`area`</span> <span class="keyword">json</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'地区'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`order_name`</span> (<span class="string">`order_name`</span>,<span class="string">`create_time`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">9</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>MySQL 中支持 json 对象 和json 数组，他们之间可以相互嵌套；json类似map，在java中json就是map得实现类，初学者若不懂何为json，就当作map来用，即储存 key - value 形式得数据结构；<strong>注意点是 json 数据 得key 必须是字符串，可以有key无value</strong>；</p><h2 id="2-1-插入-josn数据"><a href="#2-1-插入-josn数据" class="headerlink" title="2.1 插入 josn数据"></a>2.1 插入 josn数据</h2><p>插入 json 对象，east 得值 为 50 ， sourth 值为65 得 json对象；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order`</span>(<span class="string">`order_name`</span>, <span class="string">`year`</span>, <span class="string">`area`</span>) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'荷小花的订单'</span>, <span class="number">2020</span>, <span class="string">'&#123;"east": "50", "south": "65"&#125;'</span>);</span><br></pre></td></tr></table></figure><p>等效于使用 <code>JSON_OBJECT</code> 函数， 示例如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order`</span>(<span class="string">`order_name`</span>, <span class="string">`year`</span>, <span class="string">`area`</span>) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'荷小花的订单'</span>, <span class="number">2020</span>, JSON_OBJECT(<span class="string">"east"</span>, <span class="string">"50"</span>, <span class="string">"south"</span>, <span class="string">"65"</span>));</span><br></pre></td></tr></table></figure><p>插入 json 数组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order`</span>(<span class="string">`order_name`</span>, <span class="string">`year`</span>, <span class="string">`area`</span>) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'荷小花的订单'</span>, <span class="number">2020</span>, <span class="string">'[&#123;"east": "50", "south": "65"&#125;]'</span>);</span><br></pre></td></tr></table></figure><p>等效于使用 <code>JSON_ARRAY</code> 函数，示例如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order`</span>(<span class="string">`order_name`</span>, <span class="string">`year`</span>, <span class="string">`area`</span>) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'荷小花的订单'</span>, <span class="number">2020</span>, JSON_ARRAY(<span class="string">"east"</span>, <span class="string">"50"</span>, <span class="string">"south"</span>, <span class="string">"65"</span>));</span><br></pre></td></tr></table></figure><h2 id="2-2-查询json数据"><a href="#2-2-查询json数据" class="headerlink" title="2.2 查询json数据"></a>2.2 查询json数据</h2><p>使用 column - path 路径符 <code>-&gt;</code> 查询 指定key 得值，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_name, area -&gt; <span class="string">'$.east'</span> <span class="keyword">from</span> <span class="string">`order`</span></span><br></pre></td></tr></table></figure><p>注意，如果json 数据中不存在 east 得键，则列出为null值</p><p>输出如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---------   ------</span></span><br><span class="line">荷小花的订单"50"</span><br><span class="line">荷小花的订单</span><br></pre></td></tr></table></figure><p>也可以使用 -&gt;&gt; 符号, 不同之处是使用 <code>-&gt;&gt;</code> 更加直观，输出得json数据最外层不会携带双引号，内层数据中存在双引号不会有反斜杠转义；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_name, area -&gt;&gt; <span class="string">'$.east'</span> <span class="keyword">from</span> <span class="string">`order`</span></span><br></pre></td></tr></table></figure><p>使用 单引号 代替 双引号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_name, area -&gt;&gt; <span class="string">"$.east"</span> <span class="keyword">from</span> <span class="string">`order`</span></span><br></pre></td></tr></table></figure><p>我们 也可以使用 <code>JSON_EXTRACT</code> 函数 达到同样得效果；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_name,JSON_EXTRACT(area, <span class="string">'$.east'</span>) <span class="keyword">from</span> <span class="string">`order`</span>;</span><br></pre></td></tr></table></figure><h2 id="2-3-修改json数据"><a href="#2-3-修改json数据" class="headerlink" title="2.3 修改json数据"></a>2.3 修改json数据</h2><p>使用 <code>JSON_SET</code> 设置 json key 得 值</p><p>id = 1 得 area 数据如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"north": "55", "south": "66"&#125;</span><br></pre></td></tr></table></figure><p>现在将south 值改为 60 的语句示例如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="string">`order`</span> <span class="keyword">set</span> area = json_set(area, <span class="string">'$[0].south'</span>, <span class="string">'60'</span>) <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><p>其中 $[0] 代表 json 中的第一个对象 ,以此类推 $[1] 为 josn 中的第二个对象；</p><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;6&quot;,&quot;2&quot;,&#123;&quot;east&quot;: &quot;50&quot;, &quot;south&quot;: &quot;65&quot;&#125;]</span><br></pre></td></tr></table></figure><p>$[0] 为”6”，$[1] 为 “2” , $[2] 为 {“east”: “50”, “south”: “65”}; $[2].east 为 “50” , 或者 <code>$[2][1]</code>;</p><p>如果上面$[*] 表达式式理解困难也可以使用如下方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="string">`order`</span> <span class="keyword">set</span> area = json_set(area, <span class="string">'$.south'</span>, <span class="string">'60'</span>) <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><blockquote><p>tip: 如果更改整个json值 与 平时的更新数据方式一致</p></blockquote><h2 id="2-4-删除json中的数据"><a href="#2-4-删除json中的数据" class="headerlink" title="2.4 删除json中的数据"></a>2.4 删除json中的数据</h2><p>使用 json_remove 可以达到效果；</p><p>示例: 删除json 中的 south 键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="string">`order`</span> <span class="keyword">set</span> area =json_remove(area, <span class="string">'$.south'</span>) <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><h1 id="三-json函数"><a href="#三-json函数" class="headerlink" title="三 json函数"></a>三 json函数</h1><h2 id="3-5-JSON-INSERT"><a href="#3-5-JSON-INSERT" class="headerlink" title="3.5 JSON_INSERT"></a>3.5 JSON_INSERT</h2><p>JSON_INSERT 函数 向 json 中添加新的值，不会改变已经存在的值；</p><p>id = 1 的数据如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"north": "55"&#125;</span><br></pre></td></tr></table></figure><p>更新语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="string">`order`</span> <span class="keyword">set</span> area =JSON_INSERT(area, <span class="string">'$.north'</span>, <span class="number">55</span> ,<span class="string">'$.south'</span>, <span class="string">"60"</span>) <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><p>更改结果如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"north": "55", "south": "60"&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-JSON-KEYS"><a href="#3-8-JSON-KEYS" class="headerlink" title="3.8 JSON_KEYS"></a>3.8 JSON_KEYS</h2><p>返回json顶级值底下所有key</p><p>id = 1 的数据如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;"north": "50", "south": "60"&#125;, &#123;"north": "50", "south": "70"&#125;]</span><br></pre></td></tr></table></figure><p>查询json数据中第一个json对象所有的key</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> JSON_KEYS(area, <span class="string">'$[0]'</span>)  <span class="keyword">from</span> <span class="string">`order`</span>  <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">["north", "south"]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对Content-type的理解?</title>
      <link href="/2020/11/12/%E5%AF%B9Content-type%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/11/12/%E5%AF%B9Content-type%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>Content-Type</strong>是指http/https发送信息至服务器时的内容编码类型，contentType用于表明发送数据流的类型，服务器根据编码类型使用特定的解析方式，获取数据流中的数据。</p><h3 id="一：application-x-www-form-urlencoded-主要用于如下"><a href="#一：application-x-www-form-urlencoded-主要用于如下" class="headerlink" title="一：application/x-www-form-urlencoded 主要用于如下:"></a><strong>一：application/x-www-form-urlencoded 主要用于如下:</strong></h3><h4 id="urlencoded是什么意思？"><a href="#urlencoded是什么意思？" class="headerlink" title="urlencoded是什么意思？"></a>urlencoded是什么意思？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、它是post的默认格式，使用js中URLencode转码方法。包括将name、value中的空格替换为加号；将非ascii字符做百分号编码；将input的name、value用‘&#x3D;’连接，不同的input之间用‘&amp;’连接。</span><br></pre></td></tr></table></figure><p>1.1: 最常见的POST提交数据方式。<br>1.2：原生form默认的提交方式(可以使用enctype指定提交数据类型)。<br>1.3：jquery，zepto等默认post请求提交的方式。</p><p>\1. 首先来看下form表单中post默认提交方式的数据；代码如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;0&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&quot; method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">      &lt;p&gt;username: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;age: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如下图所示：</p><p><img src="https://images2018.cnblogs.com/blog/561794/201804/561794-20180430225744260-1116552426.png" alt="img"></p><p>application/x-www-form-urlencoded 是最常用的一种请求编码方式，支持GET/POST等方法，所有数据变成键值对的形式 key1=value1&amp;key2=value2<br>的形式，并且特殊字符需要转义成utf-8编号，如空格会变成 %20;</p><p>默认的提交方式是 application/x-www-form-urlencoded 编码提交数据的，在chrome的network面板下，默认的请求体是被解析的。展示成formData的形式；</p><p>如下是使用ajax的方式提交的；</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;0&quot;&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;tugenhua0707.github.io&#x2F;html5UploadImage&#x2F;js&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;btn&quot;&gt;发送post请求&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var obj &#x3D; &#123;</span><br><span class="line">      &quot;name&quot;: &#39;CntChen&#39;,</span><br><span class="line">      &quot;info&quot;: &#39;Front-End&#39;,</span><br><span class="line">    &#125;;</span><br><span class="line">    $(&#39;.btn&#39;).click(function() &#123;</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: &#39;www.example.com&#39;,</span><br><span class="line">        type: &#39;POST&#39;,</span><br><span class="line">        dataType: &#39;json&#39;,</span><br><span class="line">        data: obj,</span><br><span class="line">        success: function(d) &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如下图所示：</p><p><img src="https://images2018.cnblogs.com/blog/561794/201804/561794-20180430225835153-863701865.png" alt="img"></p><p>如上默认提交的 contentType为 application/x-www-form-urlencoded，此时提交的数据将会格式化成：<br>username=111&amp;age=2;</p><p>如果请求类型type是GET的话，那么格式化的字符串将直接拼接在url后发送到服务端； 如果请求类型是POST, 那么格式化的字符串将放在http body的Form Data中发送。</p><h3 id="二：multipart-form-data"><a href="#二：multipart-form-data" class="headerlink" title="二：multipart/form-data"></a><strong>二：multipart/form-data</strong></h3><p>对于一段utf8编码的字节，用application/x-www-form-urlencoded传输其中的ascii字符没有问题，但对于非ascii字符传输效率就很低了（汉字‘丁’从三字节变成了九字节），因此在传很长的字节（如文件）时应用multipart/form-data格式。smtp等协议也使用或借鉴了此格式。</p><p>使用表单上传文件时，必须指定表单的 enctype属性值为 multipart/form-data. 请求体被分割成多部分，每部分使用 –boundary分割；</p><p>html代码如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;0&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;www.example.com&quot; method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">      &lt;p&gt;username: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;age: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如下图所示：</p><p><img src="https://images2018.cnblogs.com/blog/561794/201804/561794-20180430225931100-66284411.png" alt="img"></p><p><a href="https://www.cnblogs.com/tugenhua0707/p/7599691.html" target="_blank" rel="noopener">ajax formdata提交数据请看这篇文章</a></p><h3 id="三：application-json"><a href="#三：application-json" class="headerlink" title="三：application/json"></a><strong>三：application/json</strong></h3><p>在http请求中，ContentType都是默认的值 application/x-www-form-urlencoded, 这种编码格式的特点是：name/value值对，<br>每组之间使用&amp;连接，而name与value之间是使用 = 连接，比如 key=xxx&amp;name=111&amp;password=123456; 键值对一般的情况下是没有什么问题的，<br>是很简单的json形式，比如如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会解析成 a=1&amp;b=2这样的，但是在一些复杂的情况下，比如需要传一个复杂的json对象，也就是对象嵌套数组的情况下，比如如下代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  obj: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: 111,</span><br><span class="line">      &quot;password&quot;: 22</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>这样复杂的对象，application/x-www-form-urlencoded这种形式传递的话， 会被解析成 obj[0][‘name’]=111&amp;obj[0].[‘password’]=2这样的。<br>然后再转成json形式；</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;obj&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: 111,</span><br><span class="line">      &quot;password&quot;: 22</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>对于一些复制的数据对象，对象里面再嵌套数组的话，建议使用application/json传递比较好，开发那边也会要求使用application/json。因为他们那边不使用application/json的话，使用默认的application/x-www-form-urlencoded传递的话，开发那边先要解析成如上那样的，<br>然后再解析成json对象，如果对于比上面更复杂的json对象的话，那么他们那边是很解析的，所以直接json对象传递的话，对于他们来说更简单。</p><p>通过json的形式将数据发送给服务器。json的形式的优点是它可以传递结构复杂的数据形式，比如对象里面嵌套数组这样的形式等。</p><p>如下代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;0&quot;&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;tugenhua0707.github.io&#x2F;html5UploadImage&#x2F;js&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;btn&quot;&gt;发送post请求&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    $(&#39;.btn&#39;).click(function() &#123;</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: &#39;http:&#x2F;&#x2F;www.example.com&#39;,</span><br><span class="line">        type: &#39;POST&#39;,</span><br><span class="line">        dataType: &#39;json&#39;,</span><br><span class="line">        contentType: &#39;application&#x2F;json&#39;,</span><br><span class="line">        data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;),</span><br><span class="line">        success: function(d) &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>但是如上代码，在浏览器运行后，发现跨域了，我们看如下截图所示：</p><p><img src="https://images2018.cnblogs.com/blog/561794/201804/561794-20180430230249656-1515790837.png" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/561794/201804/561794-20180430230257449-234197367.png" alt="img"></p><h3 id="3-1-理解ajax跨域设置-ContentType-application-json"><a href="#3-1-理解ajax跨域设置-ContentType-application-json" class="headerlink" title="3.1 理解ajax跨域设置 ContentType: application/json"></a><strong>3.1 理解ajax跨域设置 ContentType: application/json</strong></h3><p>在使用ajax跨域请求时，如果设置Header的ContentType为 application/json，它会发两次请求，第一次先发Method为OPTIONS的请求到服务器，<br>这个请求会询问服务器支持那些请求方法(比如GET,POST)等。如果这个请求支持跨域的话，就会发送第二个请求，否则的话在控制台会报错，第二个请求不会请求。如下我们做个简单的demo，不跨域的如下：</p><p>如下的代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,user-scalable&#x3D;0&quot;&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;tugenhua0707.github.io&#x2F;html5UploadImage&#x2F;js&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;btn&quot;&gt;发送post请求&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    $(&#39;.btn&#39;).click(function() &#123;</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: &#39;http:&#x2F;&#x2F;localhost:8081&#x2F;api.json&#39;,</span><br><span class="line">        type: &#39;POST&#39;,</span><br><span class="line">        dataType: &#39;json&#39;,</span><br><span class="line">        contentType: &#39;application&#x2F;json&#39;,</span><br><span class="line">        data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;),</span><br><span class="line">        success: function(d) &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如下图所示：</p><p><img src="https://images2018.cnblogs.com/blog/561794/201804/561794-20180430230355691-288861275.png" alt="img"></p><p>如上我们可以看到json格式提交的数据会显示 Request Payload;</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程中如何使用CPU缓存?</title>
      <link href="/2020/11/12/%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CPU%E7%BC%93%E5%AD%98/"/>
      <url>/2020/11/12/%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CPU%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>CPU缓存会把一片连续的内存空间读入， 因为数组结构是连续的内存地址，所以数组全部或者部分元素被连续存在CPU缓存里面， 平均读取每个元素的时间只要3个CPU时钟周期。   而链表的节点是分散在堆空间里面的，这时候CPU缓存帮不上忙，只能是去读取内存，平均读取时间需要100个CPU时钟周期。 这样算下来，数组访问的速度比链表快33倍！ （这里只是介绍概念，具体的数字因CPU而异）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis分布式锁剖析</title>
      <link href="/2020/11/12/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/11/12/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>如何用Redis实现分布式锁？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;6844903616667451399</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String threadId &#x3D; Thread.currentThread().getId()</span><br><span class="line"></span><br><span class="line">set（key，threadId ，30，NX）</span><br></pre></td></tr></table></figure><p>解锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if（threadId .equals(redisClient.get(key))）&#123;</span><br><span class="line"></span><br><span class="line">del(key)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么要线程的ID？"><a href="#为什么要线程的ID？" class="headerlink" title="为什么要线程的ID？"></a>为什么要线程的ID？</h3><p>如果某些原因导致线程B执行的很慢很慢，过了30秒都没执行完，这时候锁过期自动释放，线程B得到了锁。随后，线程A执行完了任务，线程A接着执行del指令来释放锁。但这时候线程B还没执行完，线程A实际上删除的是线程B加的锁。</p><p>怎么避免这种情况呢？可以在del释放锁之前做一个判断，验证当前的锁是不是自己加的锁。至于具体的实现，可以在加锁的时候把当前的线程ID当做value，并在删除之前验证key对应的value是不是自己线程的ID。</p><p>用lua脚本来保证原子性</p><h3 id="并发可能性"><a href="#并发可能性" class="headerlink" title="并发可能性"></a>并发可能性</h3><p>还是刚才第二点所描述的场景，虽然我们避免了线程A误删掉key的情况，但是同一时间有A，B两个线程在访问代码块，仍然是不完美的。</p><p>怎么办呢？我们可以让获得锁的线程开启一个<strong>守护线程</strong>，用来给快要过期的锁“续航”。</p><p>当过去了29秒，线程A还没执行完，这时候守护线程会执行expire指令，为这把锁“续命”20秒。守护线程从第29秒开始执行，每20秒执行一次。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双亲委派剖析</title>
      <link href="/2020/11/08/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%89%96%E6%9E%90/"/>
      <url>/2020/11/08/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>双亲委派模型要求<strong>除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器</strong>。</p><p>双亲委派模型的工作过程是：</p><ul><li>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。</li><li>每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。</li><li>只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性</strong>，每一个类加载器，都拥有一个独立的类名称空间。因此，使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处：<strong>类随着它的类加载器一起具备了一种带有优先级的层次关系</strong>。</p><p>例如类<code>java.lang.Object</code>，它由启动类加载器加载。双亲委派模型保证任何类加载器收到的对<code>java.lang.Object</code>的加载请求，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此<strong>Object类在程序的各种类加载器环境中都是同一个类</strong>。</p><p>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并用自定义的类加载器加载，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>根据双亲委派机制，我们知道它一定是被应用程序类加载器AppClassLoader加载，而不是我们自定义的类加载器</p><h3 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h3><p><strong>失败的尝试</strong><br>由于需要使用不同的类加载器加载类，所以自定义了一个类加载器从指定的目录下加载类。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class TestStaticBlock &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;static block init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        &#x2F;&#x2F;new TestStaticBlock();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; class0 &#x3D; TestStaticBlock.class;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(class0.getClassLoader() instanceof MyClassLoader);</span><br><span class="line">            Class&lt;?&gt; class1 &#x3D; class0.getClassLoader().loadClass(&quot;classloader.TestStaticBlock&quot;);</span><br><span class="line">            ClassLoader classLoader &#x3D; new MyClassLoader();</span><br><span class="line">            Class&lt;?&gt; class2 &#x3D; classLoader.loadClass(&quot;TestStaticBlock&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(class1.hashCode());</span><br><span class="line">            System.out.println(class2.hashCode());</span><br><span class="line">            System.out.println(class1.equals(class2));</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;自定义一个类加载器从指定磁盘目录加载类</span><br><span class="line">    public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line">        &#x2F;&#x2F;不破坏双亲委派模型</span><br><span class="line">        @Override</span><br><span class="line">        protected Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">            String myPath &#x3D; &quot;D:&#x2F;myeclipseworkspace&#x2F;class&#x2F;&quot; + name.replace(&quot;.&quot;,&quot;&#x2F;&quot;) + &quot;.class&quot;;</span><br><span class="line">            System.out.println(myPath);</span><br><span class="line">            byte[] classBytes &#x3D; null;</span><br><span class="line">            FileInputStream in &#x3D; null;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                File file &#x3D; new File(myPath);</span><br><span class="line">                in &#x3D; new FileInputStream(file);</span><br><span class="line">                classBytes &#x3D; new byte[(int) file.length()];</span><br><span class="line">                in.read(classBytes);</span><br><span class="line">            &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; clazz &#x3D; defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">            return clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>System.out.println(class1.equals(class2));猜猜输出的结果是什么？答案居然是true！这不是违背了我们平时的认知吗？被不同的类加载器加载的类不应该是不同的类吗？机智的博主很快想到了可能是双亲委派模型在作祟，先让我们看一看ClassLoader中loadClass()的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">      throws ClassNotFoundException</span><br><span class="line">  &#123;</span><br><span class="line">      synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">          &#x2F;&#x2F; First, check if the class has already been loaded</span><br><span class="line">          Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">          if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">              long t0 &#x3D; System.nanoTime();</span><br><span class="line">              try &#123;</span><br><span class="line">                  &#x2F;&#x2F;双亲委派模型的体现</span><br><span class="line">                  if (parent !&#x3D; null) &#123;</span><br><span class="line">                      c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                  &#x2F;&#x2F; ClassNotFoundException thrown if class not found</span><br><span class="line">                  &#x2F;&#x2F; from the non-null parent class loader</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                  &#x2F;&#x2F; If still not found, then invoke findClass in order</span><br><span class="line">                  &#x2F;&#x2F; to find the class.</span><br><span class="line">                  long t1 &#x3D; System.nanoTime();</span><br><span class="line">                  c &#x3D; findClass(name);</span><br><span class="line"></span><br><span class="line">                  &#x2F;&#x2F; this is the defining class loader; record the stats</span><br><span class="line">                  sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                  sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                  sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (resolve) &#123;</span><br><span class="line">              resolveClass(c);</span><br><span class="line">          &#125;</span><br><span class="line">          return c;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看看打印的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(classLoader.getParent());</span><br><span class="line">System.out.println(class0.getClassLoader());12</span><br><span class="line">sun.misc.Launcher$AppClassLoader@6d06d69c</span><br><span class="line">sun.misc.Launcher$AppClassLoader@6d06d69c12</span><br></pre></td></tr></table></figure><p>当当当当，发现我们虽然重写了ClassLoader的findClass()方法，但是并没有打破双亲委派模型。使用自定义类加载器加载TestStaticBlock最后还是被转发到了父类加载器，而从输出结果可以看出这个父类加载器就是class0.getClassLoader()。当然加载出来的类也会是同一个类。</p><hr><p><strong>打破双亲委派模型</strong><br>那么就没有办法打破双亲委派模型吗？结果当然是false。只需要重写ClassLoader类的loadClass()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;破坏双亲委派模型</span><br><span class="line">  @Override</span><br><span class="line">public Class&lt;?&gt; loadClass(String name)</span><br><span class="line">    throws ClassNotFoundException &#123;</span><br><span class="line">      String myPath &#x3D; &quot;D:&#x2F;myeclipseworkspace&#x2F;class&#x2F;&quot; + name.replace(&quot;.&quot;,&quot;&#x2F;&quot;) + &quot;.class&quot;;</span><br><span class="line">      System.out.println(myPath);</span><br><span class="line">      byte[] classBytes &#x3D; null;</span><br><span class="line">      FileInputStream in &#x3D; null;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">    File file &#x3D; new File(myPath);</span><br><span class="line">    in &#x3D; new FileInputStream(file);</span><br><span class="line">    classBytes &#x3D; new byte[(int) file.length()];</span><br><span class="line">    in.read(classBytes);</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      System.out.println();</span><br><span class="line">      Class&lt;?&gt; clazz &#x3D; defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">      return clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以为这就结束了吗？naive。让我们看看运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.FileNotFoundException: D:\myeclipseworkspace\class\java\lang\Object.class (系统找不到指定的路径。)1</span><br></pre></td></tr></table></figure><p>由于我们打破了双亲委派模型，所以父类的加载（Object）也会交由我们自自定义的类加载器加载。而很明显在我们自定义的加载目录下是不会有Object.class这个文件的。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逃逸分析</title>
      <link href="/2020/11/08/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
      <url>/2020/11/08/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>在Java的编译体系中，一个Java的源代码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把.java文件转换成.class文件。第二段编译是把.class转换成机器指令的过程。</p><p>第一段编译就是<code>javac</code>命令。</p><p>在第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的解释器（Interpreter）的功能。为了解决这种效率问题，引入了 JIT（即时编译） 技术。</p><p>引入了 JIT 技术后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。</p><p>由于关于JIT编译和热点检测的内容，我在<a href="http://www.hollischuang.com/archives/2322" target="_blank" rel="noopener">深入分析Java的编译原理</a>中已经介绍过了，这里就不在赘述，本文主要来介绍下JIT中的优化。JIT优化中最重要的一个就是逃逸分析。</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>关于逃逸分析的概念，可以参考<a href="http://www.hollischuang.com/archives/2398" target="_blank" rel="noopener">对象和数组并不是都在堆上分配内存的。</a>一文，这里简单回顾一下：</p><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p><p>例如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static StringBuffer craeteStringBuffer(String s1, String s2) &#123;</span><br><span class="line">    StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    return sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String createStringBuffer(String s1, String s2) &#123;</span><br><span class="line">    StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>第一段代码中的<code>sb</code>就逃逸了，而第二段代码中的<code>sb</code>就没有逃逸。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><p>二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p><p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p><p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，</p><p><code>-XX:+DoEscapeAnalysis</code> ： 表示开启逃逸分析</p><p><code>-XX:-DoEscapeAnalysis</code> ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis</p><h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p><p>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫<a href="http://www.hollischuang.com/archives/2344" target="_blank" rel="noopener">锁消除</a>。</p><p>如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void f() &#123;</span><br><span class="line">    Object hollis &#x3D; new Object();</span><br><span class="line">    synchronized(hollis) &#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void f() &#123;</span><br><span class="line">    Object hollis &#x3D; new Object();</span><br><span class="line">    System.out.println(hollis);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>所以，在使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。</p><h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void alloc() &#123;</span><br><span class="line">   Point point &#x3D; new Point（1,2）;</span><br><span class="line">   System.out.println(&quot;point.x&#x3D;&quot;+point.x+&quot;; point.y&#x3D;&quot;+point.y);</span><br><span class="line">&#125;</span><br><span class="line">class Point&#123;</span><br><span class="line">    private int x;</span><br><span class="line">    private int y;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上代码中，point对象并没有逃逸出<code>alloc</code>方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。</p><p>以上代码，经过标量替换后，就会变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void alloc() &#123;</span><br><span class="line">   int x &#x3D; 1;</span><br><span class="line">   int y &#x3D; 2;</span><br><span class="line">   System.out.println(&quot;point.x&#x3D;&quot;+x+&quot;; point.y&#x3D;&quot;+y);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p><p>标量替换为栈上分配提供了很好的基础。</p><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。</p><p>关于栈上分配的详细介绍，可以参考<a href="http://www.hollischuang.com/archives/2398" target="_blank" rel="noopener">对象和数组并不是都在堆上分配内存的。</a>。</p><p>这里，还是要简单说一下，其实在现有的虚拟机中，并没有真正的实现栈上分配，在<a href="http://www.hollischuang.com/archives/2398" target="_blank" rel="noopener">对象和数组并不是都在堆上分配内存的。</a>中我们的例子中，对象没有在堆上分配，其实是标量替换实现的。</p><h3 id="逃逸分析并不成熟"><a href="#逃逸分析并不成熟" class="headerlink" title="逃逸分析并不成熟"></a>逃逸分析并不成熟</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>G1相关补充</title>
      <link href="/2020/11/07/G1%E7%9B%B8%E5%85%B3%E8%A1%A5%E5%85%85/"/>
      <url>/2020/11/07/G1%E7%9B%B8%E5%85%B3%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>G1收集概览：</strong></p><p>G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片问题的存在了。</p><p><strong>Humongous区域：</strong></p><p>在G1中，还有一种特殊的区域，叫Humongous区域。如果一个对象占用的空间达到或者超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。</p><p><strong>G1 Young GC:</strong></p><ul><li>Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC完成工作，应用线程继续执行。</li><li>如果仅仅GC新生代对象，我们如何找到所有的根对象呢？老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是,G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。下面看图：<br><img src="https://img2018.cnblogs.com/blog/324374/201907/324374-20190707204635341-1202702709.png" alt="img"></li><li>在CMS中，也有RSet的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。 </li><li>但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。</li><li>于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。</li><li>由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用既可。</li><li>需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（既数组下标）来标识每个分区的空间地址。</li><li>默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为“0”，既标记为被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。</li></ul><p>另外它分为下几个阶段：</p><ul><li>阶段1：根扫描<br>表态和本地对象被扫描</li><li>阶段2：更新RS<br>处理dirty card队列更新RS</li><li>阶段3：处理RS<br>检测从年轻代指向老年代的对象</li><li>阶段4：对象拷贝<br>拷贝存活的对象到survivor/old区域</li><li>阶段5：处理引用队列<br>软引用、弱引用、虚引用处理</li></ul><p><strong>再谈Mixed GC:</strong></p><ul><li>Mixed GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。</li><li>这的GC步骤分为两步：<br>1、全局并发标记（global concurrent marking）<br>2、拷贝存活对象（evacuation）</li><li>在G1 GC中，global concurrent marking主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。global concurrent marking的执行过程分为四个步骤，这个在之前已经学习过了，回忆一下：<br><img src="https://img2018.cnblogs.com/blog/324374/201907/324374-20190707211002790-2041758892.png" alt="img"></li></ul><p><strong>三色标记算法：</strong></p><ul><li><p><strong>什么是三色标记？</strong></p><blockquote><p>为啥需要三色标记呢？</p><p>相比之前的标记清除算法，其GC执行期间需要把整个程序完全暂停，不能异步执行GC操作。对实时性要求比较高的系统来说，这种需要长时间挂起的标记清除算法是不可接受的，而三色标记算法就很好的解决了这个问题。</p><p>三色标记最大的好处是可以异步执行，从而可以以中断时间极少的代价或者完全没有中断操作来进行整个GC。</p><p>三色标记具体指那三色？</p><p>白色、灰色和黑色。</p><p>黑色：根对象，或者该对象与它的子对象都被扫描过。</p><p>灰色：对象本身被扫描，但是还有没扫描该对象的子对象。</p><p>白色：未被扫描的对象，如果扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象。</p></blockquote><p><strong>并发出现“对象消失”问题</strong></p><p><img src="https://oscimg.oschina.net/oscnet/up-4a3648a820494fd3133927e2349b95cf3a3.png" alt="img"></p><p>什么时候，会产生对象消失“的问题”，即原本应该是黑色的对象被误标为白色？</p><blockquote><p>当且仅当以下两个条件同时满足：</p><p> 赋值器插入了一条或多条从黑色对象到白色对象的新引用；</p><p> 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p></blockquote><p>那如何解决并发扫描时对象消失问题？</p><blockquote><p>只需要破坏这两个条件任意一个即可，两种解决方案：增量更新（Increamental Update）和原始快照（Snap shot At The Begining, SATB）</p><p>CMS 基于 增量更新（Increamental Update）来做并发标记，G1 基于 原始快照（Snap shot At The Begining, SATB）来实现的。</p><p>增量更新（Increamental Update）：当一个白色对象被黑色对象引用，将黑色对象重新标记为灰色，让垃圾回收器重新扫描。</p><p>原始快照（Snap shot At The Begining, SATB）：原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过得引用关系中的灰色对象为根，重新扫描一次。总而言之就是：无论引用关系删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索。</p><p>对比增量更新和原始快照：</p><p>原始快照关注的是引用删除，增量更新关注的是引用增加。</p><p>为啥G1不使用增量更新算法呢？</p><p>因为使用增量更新算法，那变成灰色的对象还要重新扫描一遍，效率太低了，所以G1在处理并发标记的过程比CMS效率要高，这个主要是解决漏标的算法决定的。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型问题</title>
      <link href="/2020/11/07/%E6%B3%9B%E5%9E%8B%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/07/%E6%B3%9B%E5%9E%8B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>泛型指的是可以将类型作为参数进行传递，其本质上就是类型参数化。比如:我们平时定义一个方法的时候，常会指定要传入一个具体类对象作为参数。而如果使用泛型，那么这个具体传入类的对象，就可以指定为某个类型，而不必指定具体的类。也就是我们将某个类型作为参数进行传递了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;普通方法</span><br><span class="line">public void testValue(String s) &#123;&#125;</span><br><span class="line">&#x2F;&#x2F;泛型方法</span><br><span class="line">public &lt;T&gt; void testValue(T t) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用泛型有哪些好处？"><a href="#2-使用泛型有哪些好处？" class="headerlink" title="2. 使用泛型有哪些好处？"></a>2. 使用泛型有哪些好处？</h3><ul><li>它可以避免类型强制转换，而引起的程序异常。</li><li>可以是代码更加简洁易度。</li></ul><h3 id="3-类型擦除"><a href="#3-类型擦除" class="headerlink" title="3. 类型擦除"></a>3. 类型擦除</h3><p>泛型值存在于编译期，代码在进入虚拟机后泛型就会会被擦除掉，这个者特性就叫做类型擦除。当泛型被擦除后，他有两种转换方式，第一种是如果泛型没有设置类型上限，那么将泛型转化成Object类型，第二种是如果设置了类型上限，那么将泛型转化成他的类型上限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;未指定上限</span><br><span class="line">public class Test1&lt;T&gt; &#123;</span><br><span class="line">    T t;</span><br><span class="line">    public T getValue() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setVale(T t) &#123;</span><br><span class="line">        this.t &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;指定上限</span><br><span class="line">public class Test2&lt;T extends String&gt; &#123;</span><br><span class="line">    T t;</span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;通过反射调用获取他们的属性类型</span><br><span class="line">@Test</span><br><span class="line">public void testType1() &#123;</span><br><span class="line">    Test1&lt;String&gt; test1 &#x3D; new Test1&lt;&gt;();</span><br><span class="line">    test1.setVale(&quot;11111&quot;);</span><br><span class="line">    Class&lt;? extends Test1&gt; aClass &#x3D; test1.getClass();</span><br><span class="line">    for (Field field : aClass.getDeclaredFields()) &#123;</span><br><span class="line">        System.out.println(&quot;Test1属性:&quot; + field.getName() + &quot;的类型为：&quot; + field.getType().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Test2 test2 &#x3D; new Test2();</span><br><span class="line">    test2.setT(&quot;2222&quot;);</span><br><span class="line">    Class&lt;? extends Test2&gt; aClass2 &#x3D; test2.getClass();</span><br><span class="line">    for (Field field : aClass2.getDeclaredFields()) &#123;</span><br><span class="line">        System.out.println(&quot;test2属性：&quot; + field.getName() + &quot;的类型为：&quot; + field.getType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面方法打印的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test1属性:t的类型为：java.lang.Object</span><br><span class="line">Test2属性：t的类型为：java.lang.String</span><br></pre></td></tr></table></figure><h3 id="4-泛型的两个关键字？"><a href="#4-泛型的两个关键字？" class="headerlink" title="4.泛型的两个关键字？"></a>4.泛型的两个关键字？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        List&lt;? extends A&gt; list1 &#x3D; new ArrayList&lt;A&gt;();</span><br><span class="line">&#x2F;&#x2F;          list1.add(new A()); &#x2F;&#x2F;错误，编译器无法确定List所持有的类型，所以无法安全的向其中添加对象</span><br><span class="line">        A a &#x3D; list1.get(0);</span><br><span class="line">        List&lt;? extends A&gt; list2 &#x3D; new ArrayList&lt;B&gt;();</span><br><span class="line">        List&lt;? super B&gt; list3 &#x3D; new ArrayList&lt;B&gt;();</span><br><span class="line">        list3.add(new B());</span><br><span class="line">        &#x2F;&#x2F;想要正确，必须向下转型，但是向下转型是不安全的，非常容易出错</span><br><span class="line">       &#x2F;&#x2F;   B b &#x3D; list3.get(0); &#x2F;&#x2F;编译器无法确定get返回的对象类型是B,还是B的父类或 Object.</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static class A&#123;&#125;</span><br><span class="line">    static class B extends A &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList heroList&lt;? extends Hero&gt; 表示这是一个Hero泛型或者其子类泛型<br>heroList 的泛型可能是Hero<br>heroList 的泛型可能是APHero<br>heroList 的泛型可能是ADHero<br>所以 可以确凿的是，<strong>从heroList取出来的对象，一定是可以转型成Hero的</strong></p><p>但是，不能往里面放东西，因为<br>放APHero就不满足<ADHero><br>放ADHero又不满足<APHero></APHero></ADHero></p><p>ArrayList heroList&lt;? super Hero&gt; 表示这是一个Hero泛型或者其父类泛型<br>heroList的泛型可能是Hero<br>heroList的泛型可能是Object</p><p><strong>可以往里面插入Hero以及Hero的子类</strong><br>但是取出来有风险，因为不确定取出来是Hero还是Object</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TLAB是什么</title>
      <link href="/2020/11/07/TLAB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2020/11/07/TLAB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>TLAB （Thread Local Allocation Buffer，线程本地分配缓冲区）是 Java 中内存分配的一个概念，它是在 Java 堆中划分出来的针对每个线程的内存区域，专门在该区域为该线程创建的对象分配内存。它的主要目的是在多线程并发环境下需要进行内存分配的时候，减少线程之间对于内存分配区域的竞争，加速内存分配的速度。TLAB 本质上还是在 Java 堆中的，因此在 TLAB 区域的对象，也可以被其他线程访问。</p><p>如果没有启用 TLAB，多个并发执行的线程需要创建对象、申请分配内存的时候，有可能在 Java 堆的同一个位置申请，这时就需要对拟分配的内存区域进行加锁或者采用 CAS 等操作，保证这个区域只能分配给一个线程。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>final关键字</title>
      <link href="/2020/11/07/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/11/07/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final 类不能被继承，所有成员方法都会被隐式地指定为 final 方法，final 方法不能被重写。</p><p>final 变量表示常量，只能被赋值一次，赋值后值不再改变。</p><ul><li>修饰基本数据类型时，该值在初始化后不能改变。</li><li>修饰引用类型时，引用指向的对象在初始化后不能改变，但该对象的内容可以发生变化。</li></ul><p><strong>内存语义</strong></p><ul><li>Store Store 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>Load Load 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantReadWriteLock剖析</title>
      <link href="/2020/11/07/ReentrantReadWriteLock%E5%89%96%E6%9E%90/"/>
      <url>/2020/11/07/ReentrantReadWriteLock%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一、读写锁简介"><a href="#一、读写锁简介" class="headerlink" title="一、读写锁简介"></a>一、读写锁简介</h3><p>  现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写的操作了。</p><p>　针对这种场景，<strong>JAVA的并发包提供了读写锁ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁</strong>，</p><p><strong>读写锁允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞</strong>。</p><p>而读写锁有以下三个重要的特性：</p><p>（1）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</p><p>（2）重进入：读锁和写锁都支持线程重进入。</p><p>（3）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。</p><h3 id="二、源码解读"><a href="#二、源码解读" class="headerlink" title="二、源码解读"></a>二、源码解读</h3><p>我们先来看下 ReentrantReadWriteLock 类的整体结构：</p><h4 id="1-HoldCounter"><a href="#1-HoldCounter" class="headerlink" title="1.HoldCounter"></a>1.HoldCounter</h4><p>Sync类内部存在两个内部类，分别为HoldCounter和ThreadLocalHoldCounter，其中HoldCounter主要与读锁配套使用，其中，HoldCounter源码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计数器</span><br><span class="line">static final class HoldCounter &#123;</span><br><span class="line">    &#x2F;&#x2F; 计数</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; Use id, not reference, to avoid garbage retention</span><br><span class="line">    &#x2F;&#x2F; 获取当前线程的TID属性的值</span><br><span class="line">    final long tid &#x3D; getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：HoldCounter主要有两个属性，count和tid，其中count表示某个读线程重入的次数，tid表示该线程的tid字段的值，该字段可以用来唯一标识一个线程。ThreadLocalHoldCounter的源码如下</p><p>说明：ThreadLocalHoldCounter重写了ThreadLocal的initialValue方法，ThreadLocal类可以将线程与对象相关联。在没有进行set的情况下，get到的均是initialValue方法里面生成的那个HolderCounter对象。</p><h4 id="2-ThreadLocalHoldCounter"><a href="#2-ThreadLocalHoldCounter" class="headerlink" title="2.ThreadLocalHoldCounter"></a>2.ThreadLocalHoldCounter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 本地线程计数器</span><br><span class="line">static final class ThreadLocalHoldCounter</span><br><span class="line">    extends ThreadLocal&lt;HoldCounter&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 重写初始化方法，在没有进行set的情况下，获取的都是该HoldCounter值</span><br><span class="line">    public HoldCounter initialValue() &#123;</span><br><span class="line">        return new HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 构造函数</span><br><span class="line">Sync() &#123;</span><br><span class="line">    &#x2F;&#x2F; 本地线程计数器</span><br><span class="line">    readHolds &#x3D; new ThreadLocalHoldCounter();</span><br><span class="line">    &#x2F;&#x2F; 设置AQS的状态</span><br><span class="line">    setState(getState()); &#x2F;&#x2F; ensures visibility of readHolds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：在Sync的构造函数中设置了本地线程计数器和AQS的状态state。</p><h4 id="3、读写状态的设计"><a href="#3、读写状态的设计" class="headerlink" title="3、读写状态的设计"></a>3、读写状态的设计</h4><p>  同步状态在重入锁的实现中是表示被同一个线程重复获取的次数，即一个整形变量来维护，但是之前的那个表示仅仅表示是否锁定，而不用区分是读锁还是写锁。而读写锁需要在同步状态（一个整形变量）上维护多个读线程和一个写线程的状态。</p><p>读写锁对于同步状态的实现是在一个整形变量上通过“按位切割使用”：将变量切割成两部分，高16位表示读，低16位表示写。</p><p><img src="http://static.open-open.com/lib/uploadImg/20151031/20151031223319_397.png" alt="http://static.open-open.com/lib/uploadImg/20151031/20151031223319_397.png"></p><h4 id="4、写锁的获取与释放"><a href="#4、写锁的获取与释放" class="headerlink" title="4、写锁的获取与释放"></a>4、写锁的获取与释放</h4><p>看下WriteLock类中的lock和unlock方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是调用的独占式同步状态的获取与释放，因此真实的实现就是Sync的 tryAcquire和 tryRelease。</p><p><strong>写锁的获取，看下tryAcquire：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> 1 protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line"> 2     &#x2F;&#x2F;当前线程</span><br><span class="line"> 3     Thread current &#x3D; Thread.currentThread();</span><br><span class="line"> 4     &#x2F;&#x2F;获取状态</span><br><span class="line"> 5     int c &#x3D; getState();</span><br><span class="line"> 6     &#x2F;&#x2F;写线程数量（即获取独占锁的重入数）</span><br><span class="line"> 7     int w &#x3D; exclusiveCount(c);</span><br><span class="line"> 8     </span><br><span class="line"> 9     &#x2F;&#x2F;当前同步状态state !&#x3D; 0，说明已经有其他线程获取了读锁或写锁</span><br><span class="line">10     if (c !&#x3D; 0) &#123;</span><br><span class="line">11         &#x2F;&#x2F; 当前state不为0，此时：如果写锁状态为0说明读锁此时被占用返回false；</span><br><span class="line">12         &#x2F;&#x2F; 如果写锁状态不为0且写锁没有被当前线程持有返回false</span><br><span class="line">13         if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">14             return false;</span><br><span class="line">15         </span><br><span class="line">16         &#x2F;&#x2F;判断同一线程获取写锁是否超过最大次数（65535），支持可重入</span><br><span class="line">17         if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">18             throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">19         &#x2F;&#x2F;更新状态</span><br><span class="line">20         &#x2F;&#x2F;此时当前线程已持有写锁，现在是重入，所以只需要修改锁的数量即可。</span><br><span class="line">21         setState(c + acquires);</span><br><span class="line">22         return true;</span><br><span class="line">23     &#125;</span><br><span class="line">24     </span><br><span class="line">25     &#x2F;&#x2F;到这里说明此时c&#x3D;0,读锁和写锁都没有被获取</span><br><span class="line">26     &#x2F;&#x2F;writerShouldBlock表示是否阻塞</span><br><span class="line">27     if (writerShouldBlock() ||</span><br><span class="line">28         !compareAndSetState(c, c + acquires))</span><br><span class="line">29         return false;</span><br><span class="line">30     </span><br><span class="line">31     &#x2F;&#x2F;设置锁为当前线程所有</span><br><span class="line">32     setExclusiveOwnerThread(current);</span><br><span class="line">33     return true;</span><br><span class="line">34 &#125;</span><br></pre></td></tr></table></figure><p>其中exclusiveCount方法表示占有写锁的线程数量，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p>说明：直接将状态state和（2^16 - 1）做与运算，其等效于将state模上2^16。写锁数量由state的低十六位表示。</p><p>从源代码可以看出，获取写锁的步骤如下：</p><p>（1）首先获取c、w。c表示当前锁状态；w表示写线程数量。然后判断同步状态state是否为0。如果state!=0，说明已经有其他线程获取了读锁或写锁，执行(2)；否则执行(5)。</p><p>（2）如果锁状态不为零（c != 0），而写锁的状态为0（w = 0），说明读锁此时被其他线程占用，所以当前线程不能获取写锁，自然返回false。或者锁状态不为零，而写锁的状态也不为0，但是获取写锁的线程不是当前线程，则当前线程也不能获取写锁。</p><p>（3）判断当前线程获取写锁是否超过最大次数，若超过，抛异常，反之更新同步状态（此时当前线程已获取写锁，更新是线程安全的），返回true。</p><p>（4）如果state为0，此时读锁或写锁都没有被获取，判断是否需要阻塞（公平和非公平方式实现不同），在非公平策略下总是不会被阻塞，在公平策略下会进行判断（判断同步队列中是否有等待时间更长的线程，若存在，则需要被阻塞，否则，无需阻塞），如果不需要阻塞，则CAS更新同步状态，若CAS成功则返回true，失败则说明锁被别的线程抢去了，返回false。如果需要阻塞则也返回false。</p><p>（5）成功获取写锁后，将当前线程设置为占有写锁的线程，返回true。</p><p>方法流程图如下：</p><p><img src="https://images2018.cnblogs.com/blog/249993/201806/249993-20180607130802005-1386429088.png" alt="img"></p><p><strong>写锁的释放，tryRelease方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 1 protected final boolean tryRelease(int releases) &#123;</span><br><span class="line"> 2     &#x2F;&#x2F;若锁的持有者不是当前线程，抛出异常</span><br><span class="line"> 3     if (!isHeldExclusively())</span><br><span class="line"> 4         throw new IllegalMonitorStateException();</span><br><span class="line"> 5     &#x2F;&#x2F;写锁的新线程数</span><br><span class="line"> 6     int nextc &#x3D; getState() - releases;</span><br><span class="line"> 7     &#x2F;&#x2F;如果独占模式重入数为0了，说明独占模式被释放</span><br><span class="line"> 8     boolean free &#x3D; exclusiveCount(nextc) &#x3D;&#x3D; 0;</span><br><span class="line"> 9     if (free)</span><br><span class="line">10         &#x2F;&#x2F;若写锁的新线程数为0，则将锁的持有者设置为null</span><br><span class="line">11         setExclusiveOwnerThread(null);</span><br><span class="line">12     &#x2F;&#x2F;设置写锁的新线程数</span><br><span class="line">13     &#x2F;&#x2F;不管独占模式是否被释放，更新独占重入数</span><br><span class="line">14     setState(nextc);</span><br><span class="line">15     return free;</span><br><span class="line">16 &#125;</span><br></pre></td></tr></table></figure><p>  写锁的释放过程还是相对而言比较简单的：首先查看当前线程是否为写锁的持有者，如果不是抛出异常。然后检查释放后写锁的线程数是否为0，如果为0则表示写锁空闲了，释放锁资源将锁的持有线程设置为null，否则释放仅仅只是一次重入锁而已，并不能将写锁的线程清空。</p><p>  说明：此方法用于释放写锁资源，首先会判断该线程是否为独占线程，若不为独占线程，则抛出异常，否则，计算释放资源后的写锁的数量，若为0，表示成功释放，资源不将被占用，否则，表示资源还被占用。其方法流程图如下。</p><p><img src="https://images2018.cnblogs.com/blog/249993/201806/249993-20180607131006282-1633551158.png" alt="img"></p><h4 id="5、读锁的获取与释放"><a href="#5、读锁的获取与释放" class="headerlink" title="5、读锁的获取与释放"></a>5、读锁的获取与释放</h4><p>类似于写锁，读锁的lock和unlock的实际实现对应Sync的 tryAcquireShared 和 tryReleaseShared方法。</p><p><strong>读锁的获取，看下tryAcquireShared方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">           Thread current &#x3D; Thread.currentThread();</span><br><span class="line">           int c &#x3D; getState();</span><br><span class="line">           &#x2F;**</span><br><span class="line">            * 写锁状态不为0 并且 当前线程不是写锁的占有者，即写锁由其他</span><br><span class="line">            * 线程占有，则获取读锁失败</span><br><span class="line">            *&#x2F;</span><br><span class="line">           if (exclusiveCount(c) !&#x3D; 0 &amp;&amp; getExclusiveOwnerThread() !&#x3D; current)</span><br><span class="line">               return -1;</span><br><span class="line">           &#x2F;&#x2F;读锁的同步状态</span><br><span class="line">           int r &#x3D; sharedCount(c);</span><br><span class="line">           &#x2F;&#x2F; 读状态的增加与减少需要对参数进行移位操作</span><br><span class="line">           &#x2F;&#x2F; compareAndSetState(c, c + SHARED_UNIT) 即为c+ 1&lt;&lt;16 </span><br><span class="line">           if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">               &#x2F;&#x2F;如果读锁未被获取</span><br><span class="line">               if (r &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                   &#x2F;&#x2F;firstThread 是第一个获取读锁的线程</span><br><span class="line">                   &#x2F;&#x2F;firstReaderHoldCount 是firstThread持有读锁的数目</span><br><span class="line">                   firstReader &#x3D; current;</span><br><span class="line">                   firstReaderHoldCount &#x3D; 1;</span><br><span class="line">               &#x2F;&#x2F;如果当前线程是第一个获取读锁的线程，则计数器++</span><br><span class="line">               &#125; else if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">                   firstReaderHoldCount++;</span><br><span class="line">               &#x2F;&#x2F;如果读锁被获取了，且当前线程不是第一个获取读锁的线程</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   &#x2F;&#x2F;HoldCounter是每一个线程读锁持有数目的计数器，它包含两个成员变量：count和线程id</span><br><span class="line">                   &#x2F;&#x2F;cachedHoldCounter表示上一个成功获取读锁的线程的读锁计数器</span><br><span class="line">                   HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class="line">                   &#x2F;**</span><br><span class="line">                    * rh&#x3D;&#x3D;null 表示这是第一个获取读锁的线程</span><br><span class="line">                    * rh.tid !&#x3D; rh.tid !&#x3D; getThreadId(current)) 表示当前线程不是上一个成功获取读锁的线程</span><br><span class="line">                    * 其实下面的if和else if都是在更新cachedHoldCounter，读锁持有数目的增加在rh.count++</span><br><span class="line">                    *&#x2F;</span><br><span class="line">                   if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class="line">                       &#x2F;&#x2F;获得当前线程的计数器 并将其设为cachedHoldCounter</span><br><span class="line">                       cachedHoldCounter &#x3D; rh &#x3D; readHolds.get();</span><br><span class="line">                   else if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                       readHolds.set(rh);</span><br><span class="line">                   rh.count++;</span><br><span class="line">               &#125;</span><br><span class="line">               return 1;</span><br><span class="line">           &#125;</span><br><span class="line">           return fullTryAcquireShared(current);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>1、获取同步状态c，获取写锁状态w、读锁状态r。</p><p>2、如果w!=0且写锁被其他线程获取，则进入等待状态。</p><p>3.1、如果读锁未被获取(r==0)，则设置当前线程为第一个获取读锁的线程，并设置持有读锁数目为1</p><p>3.2、如果当前线程是第一个获取读锁的线程，则持有读锁的数目加1</p><p>3.3、如果读锁被获取了，且当前线程不是第一个获取读锁的线程。那么：</p><p>3.3.1 如果上一个获取读锁的线程不是当前线程，则拿到当前线程的ThreadLocal变量，并赋予cachedHoldCounter，持有读锁数目加1</p><p>3.3.2 如果上一个获取读锁的线程是当前线程，直接持有读锁数目加1</p><p> 从28行开始，乍看之下不知道在做些什么，其实我们举个获取读锁的例子，然后根据代码一步步操作就会发现很简单。 举个例子：假定此时readHold是的状态如下图，上一个成功获取读锁的线程为1003。</p><p><img src="https://img-blog.csdn.net/20180828181233147?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlbmRpYW5saTY4MzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>​    此时线程1004来获取读锁(当前线程是1004)。从上面代码28行开始：我们将1003的计数器赋予了rh，由于rh不为null且当前线程不是1003，所以我们获取当前线程的计数器(实际上就是线程id=1004，count=0)，并将该计数器赋予rh和cachedHoldCounter；然后进行rh.count++，即读锁计数加1.</p><p><img src="https://img-blog.csdn.net/20180828181252106?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlbmRpYW5saTY4MzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>​    a处黑线代码中没有该操作，我这里是说明1004的计数器由readHolds维护。</p><p>​    同样，如果现在是1002线程来获取读锁，那么获取1002线程的计数器，然后进行相应操作</p><p>  这里为什么要搞一个firstRead、firstReaderHoldCount呢？而不是直接使用else那段代码？这是为了一个效率问题，firstReader是不会放入到readHolds中的，如果读锁仅有一个的情况下就会避免查找readHolds。可能就看这个代码还不是很理解HoldCounter。我们先看firstReader、firstReaderHoldCount的定义：</p><p><img src="https://images2018.cnblogs.com/blog/249993/201806/249993-20180607131704903-887096141.png" alt="img"></p><p><strong>读锁的释放，tryReleaseShared方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> 1 protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class="line"> 2     &#x2F;&#x2F; 获取当前线程</span><br><span class="line"> 3     Thread current &#x3D; Thread.currentThread();</span><br><span class="line"> 4     if (firstReader &#x3D;&#x3D; current) &#123; &#x2F;&#x2F; 当前线程为第一个读线程</span><br><span class="line"> 5         &#x2F;&#x2F; assert firstReaderHoldCount &gt; 0;</span><br><span class="line"> 6         if (firstReaderHoldCount &#x3D;&#x3D; 1) &#x2F;&#x2F; 读线程占用的资源数为1</span><br><span class="line"> 7             firstReader &#x3D; null;</span><br><span class="line"> 8         else &#x2F;&#x2F; 减少占用的资源</span><br><span class="line"> 9             firstReaderHoldCount--;</span><br><span class="line">10     &#125; else &#123; &#x2F;&#x2F; 当前线程不为第一个读线程</span><br><span class="line">11         &#x2F;&#x2F; 获取缓存的计数器</span><br><span class="line">12         HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class="line">13         if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current)) &#x2F;&#x2F; 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span><br><span class="line">14             &#x2F;&#x2F; 获取当前线程对应的计数器</span><br><span class="line">15             rh &#x3D; readHolds.get();</span><br><span class="line">16         &#x2F;&#x2F; 获取计数</span><br><span class="line">17         int count &#x3D; rh.count;</span><br><span class="line">18         if (count &lt;&#x3D; 1) &#123; &#x2F;&#x2F; 计数小于等于1</span><br><span class="line">19             &#x2F;&#x2F; 移除</span><br><span class="line">20             readHolds.remove();</span><br><span class="line">21             if (count &lt;&#x3D; 0) &#x2F;&#x2F; 计数小于等于0，抛出异常</span><br><span class="line">22                 throw unmatchedUnlockException();</span><br><span class="line">23         &#125;</span><br><span class="line">24         &#x2F;&#x2F; 减少计数</span><br><span class="line">25         --rh.count;</span><br><span class="line">26     &#125;</span><br><span class="line">27     for (;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">28         &#x2F;&#x2F; 获取状态</span><br><span class="line">29         int c &#x3D; getState();</span><br><span class="line">30         &#x2F;&#x2F; 获取状态</span><br><span class="line">31         int nextc &#x3D; c - SHARED_UNIT;</span><br><span class="line">32         if (compareAndSetState(c, nextc)) &#x2F;&#x2F; 比较并进行设置</span><br><span class="line">33             &#x2F;&#x2F; Releasing the read lock has no effect on readers,</span><br><span class="line">34             &#x2F;&#x2F; but it may allow waiting writers to proceed if</span><br><span class="line">35             &#x2F;&#x2F; both read and write locks are now free.</span><br><span class="line">36             return nextc &#x3D;&#x3D; 0;</span><br><span class="line">37     &#125;</span><br><span class="line">38 &#125;</span><br></pre></td></tr></table></figure><p>  说明：此方法表示读锁线程释放锁。首先判断当前线程是否为第一个读线程firstReader，若是，则判断第一个读线程占有的资源数firstReaderHoldCount是否为1，若是，则设置第一个读线程firstReader为空，否则，将第一个读线程占有的资源数firstReaderHoldCount减1；若当前线程不是第一个读线程，那么首先会获取缓存计数器（上一个读锁线程对应的计数器 ），若计数器为空或者tid不等于当前线程的tid值，则获取当前线程的计数器，如果计数器的计数count小于等于1，则移除当前线程对应的计数器，如果计数器的计数count小于等于0，则抛出异常，之后再减少计数即可。无论何种情况，都会进入无限循环，该循环可以确保成功设置状态state。其流程图如下。</p><p><img src="https://images2018.cnblogs.com/blog/249993/201806/249993-20180607132608771-1291388784.png" alt="img"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class hhh &#123;</span><br><span class="line"></span><br><span class="line">    private ReentrantReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();</span><br><span class="line">    private ReentrantReadWriteLock.ReadLock readLock &#x3D; rwLock.readLock();</span><br><span class="line">    private ReentrantReadWriteLock.WriteLock writeLock &#x3D; rwLock.writeLock();</span><br><span class="line"></span><br><span class="line">    public void read()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            readLock.lock();</span><br><span class="line">            System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;进入...&quot;);</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;退出...&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void write()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;进入...&quot;);</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;退出...&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        final hhh urrw &#x3D; new hhh();</span><br><span class="line"></span><br><span class="line">        Thread t1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                urrw.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t1&quot;);</span><br><span class="line">        Thread t2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                urrw.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t2&quot;);</span><br><span class="line">        Thread t3 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                urrw.write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t3&quot;);</span><br><span class="line">        Thread t4 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                urrw.write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t4&quot;);</span><br><span class="line">&#x2F;&#x2F;t1.start();</span><br><span class="line">&#x2F;&#x2F;t2.start();</span><br><span class="line">&#x2F;&#x2F;t1.start(); &#x2F;&#x2F; R</span><br><span class="line">&#x2F;&#x2F;t3.start(); &#x2F;&#x2F; W</span><br><span class="line">&#x2F;&#x2F;        t3.start();</span><br><span class="line">&#x2F;&#x2F;        t4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  通过上面的源码分析，我们可以发现一个现象：</p><p>  在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p><p>  在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p><p>  仔细想想，这个设计是合理的：因为当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</p><p>综上：</p><p>一个线程要想同时持有写锁和读锁，必须先获取写锁再获取读锁；写锁可以“降级”为读锁；读锁不能“升级”为写锁。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库的乐观锁怎么实现的?</title>
      <link href="/2020/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
      <url>/2020/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>MySql最经常使用的乐观锁时进行版本控制，也就是在数据库表中增加一列，记为version，当我们将数据读出时，将版本号一并读出，当数据进行更新时，会对这个版本号进行加1，当我们提交数据时，会判断数据库表中当前的version列值和当时读出的version是否相同，若相同说明没有进行更新的操作，不然，则取消这次的操作。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些比较偏门的面试题</title>
      <link href="/2020/11/05/%E4%B8%80%E4%BA%9B%E6%AF%94%E8%BE%83%E5%81%8F%E9%97%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/11/05/%E4%B8%80%E4%BA%9B%E6%AF%94%E8%BE%83%E5%81%8F%E9%97%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p>枚举可以new吗 不行 私有构造</p><p>unicode与utf-8</p><ul><li>Unicode 是「字符集」</li><li>UTF-8 是「编码规则」</li></ul><p>UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示）UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号</p><p>UTF-8表示最小单位1字节</p><p>GBK编码：是指中国的中文字符，其它它包含了简体中文与繁体中文字符</p><p>ASCII 主要用于显示现代英语和其他西欧语言</p><hr><p>说说NIO是什么，为什么快</p><p>5.NIO的Buffer到底是啥</p><p>6.你提到NIO用到了直接内存，那直接内存在用户态还是内核态</p><p>NIO介绍一下（Selector、Channel、ByteBuffer，IO多路复用，底层的select、poll、epoll（这里我只是了解，不清楚具体实现））</p><p>面向对象和面向过程</p><p>String，StringBuffer，StringBuilder</p><p>Integer自动拆箱装箱（可能和字面量类型一块考，比如包装类的对象和字面量相加有几次拆箱装箱）什么类是final的（String，Integer等包装类）</p><p>\5. 类加载过程和机制（可能在原理的基础上，结合实际的例子考察，如各种地方加了各种修饰符后new一个子类或者父类输出什么）<br>\6. 对象死亡的条件<br>\7. OOM发生的位置和解决办法</p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>10.101.102.103是公网IP还是内网IP，如何区分公网内网？</p><p>//了解中间人攻击和跨域攻击吗?</p><p>//可以伪造证书吗？</p><p>// BBR 怎么快，怎么实现，和之前的有什么区别?</p><ol><li>TCP 是怎么判断一个包丢了？</li><li><a href="https://www.nowcoder.com/jump/super-jump/word?word=客户端" target="_blank" rel="noopener">客户端</a>向服务器发送一个包，它一直都没有收到服务器返回的 ACK，该怎么处理？</li></ol><p>滑动窗口大小如何确定</p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>线程与协程。（协程不会）</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>说一下快排的最好和最坏的时间复杂度？稳定吗？</p><p>邻接表和邻接矩阵？</p><p>识别2的n次方</p><p>用int值表示ip如何做（刚好32位bit一对一映射），写个伪代码做transfer</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>模糊查询like语句该怎么写?<br>第1种：在Java代码中添加sql通配符。</p><p>一个线程在10：00：00（十点0分0秒）访问数据库进行查询操作，10：00：10（10点0分十秒）返回，但是另一个线程在10：00：01对数据库同一个元素进行了修改，问返回的结果是修改前的还是修改后的</p><p><a href="#">复制代码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string wildcardname &#x3D; “%smi%”;&#96;&#96;list names &#x3D; mapper.selectlike(wildcardname);&#96; &#96; &#96;&#96;select * from foo where bar like #&#123;value&#125;</span><br></pre></td></tr></table></figure><p>第2种：在sql语句中拼接通配符，会引起sql注入</p><p><a href="#">复制代码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string wildcardname &#x3D; “smi”;&#96;&#96;list names &#x3D; mapper.selectlike(wildcardname);&#96; &#96;   &#96;&#96;select * from foo where bar like &#96;&#96;&quot;%&quot;&#96;&#96;#&#123;value&#125;&#96;&#96;&quot;%&quot;</span><br></pre></td></tr></table></figure><p>**</p><p>索引下推和索引覆盖</p><p><strong>数据库中为什么不推荐使用外键约束</strong><br>电商<a href>项目</a>中数据库表不推荐外键关联，但是在被关联表中删除数据时会导致关联表中经常出现数据缺失的问题，但如果在删除数据时在业务层删除数据做关联查询来判断是否被关联使用，会导致业务层逻辑复杂，特别是被多个业务表关联，会导致多次关联查询操作，后面每次增加一个业务关联都得增加一次判断。<br>解决方案：<br>可以在关联表中增加一个被关联次数的字段，每次关联时都加1，每次取消关联都减一。</p><p>讲一下char和varchar的区别？优缺点？索引用char还是varchar好？</p><p>假如现在读写有10%的概率冲突，用什么隔离级别?</p><p><strong>场景设计：url存储数据库就算设置了索引也会很慢，应该怎么设计存储？</strong> </p><p>  我有了几种思路，想过切分，想过压缩，想过存md5，但我一个没说。。。最后他说要超时了，直接跟我说正解，我抱着反正要结束了的想法随便说了个切分和压缩的思路，然后面试官说你要是有思路一定要跟我说的啊，不然我不知道你有没有想法不知道怎么引导（对不起我真的交流能力巨差。。。<br>  然后他讲了几种方法，而且是层层优化的： </p><p>1.存md5（恨自己没胆子说出口 </p><p>2.md5也很长，只存前几个字符的话可能会冲突，所以可以同时存md5的前几个字符和原url，然后where md5 = ‘xxxx’ and url = ‘xxxxx’，让md5走索引。 </p><p>3.自己构建哈希映射</p><p>drop delete truncate 区别</p><p>Mysql聚蔟索引和非聚簇索引的区别（讲了Innodb和Myisyam的区别，文件结构，和两种索引的区别）</p><p>要求建立学生、课程、选课、成绩四张表，要求设计字段及相应的数据类型并建立主键</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>redis的跳表要实现快速查找第k小的元素怎么做</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>CAS怎么实现禁止指令重排？</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>linux 文件系统架构</p><p>inode 有什么信息</p><p>看tw状态的进程load average 是什么，怎么看，怎么分析</p><p>linux底层的零拷贝技术（<strong>经历4次 -》3次 -》2次拷贝的优化历程）</strong></p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p> tomcat如果有两个<a href>项目</a>，两个<a href>项目</a>里面如果有相同的class，那么tomcat是如何对其进行区别?</p><p>分布式系统如何实现数据一致性</p><h3 id="虚拟机？"><a href="#虚拟机？" class="headerlink" title="虚拟机？"></a>虚拟机？</h3><p>栈区内存会有垃圾回收吗？</p><p>在什么情况下，Java对象不需要垃圾回收也能回收掉？</p><p>类加载机制卸载条件</p><p>JVM调优了解吗，OOM了怎么排查（拷贝Dump文件，使用工具查看）</p><p>了解哪些工具（JvisualVM、Jprofiler、Jstack）</p><p>Jmap了解吗（no）</p><p>如果想把JVM内存固定为32M如何操作？（XMS、XMX同时设置）</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>单例模式，懒汉，饿汉，双重校验的优缺点</p><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><ol><li>如何保持长连接（Netty）</li><li>如何实现心跳保持（IDLE编解码器监听事件）</li><li>Netty为什么快（基于NIO+零拷贝）</li></ol><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>怎么实现透明调用的（自定义一个注解，然后在BeanPostProcesser中拦截使用了这个注解的接口，然后使用Cglib动态代理进行远程调用） </p><p>如何实现异步调用的？（将Future储存起来，再新建一个线程去维护这个Future的状态）</p><p>定期删除怎么做的？（服务器事件循环）</p><p>你刚才说<a href="https://www.nowcoder.com/jump/super-jump/word?word=redis" target="_blank" rel="noopener">redis</a>的所有定时器是用<a href="https://www.nowcoder.com/jump/super-jump/word?word=链表" target="_blank" rel="noopener">链表</a>存储的，还知不知道别的处理方式（不确定对不对，答了quartz的定时任务是用两个队列保存的）</p><p>9.Kafka的消息模型是什么<br>10.Kafka的架构是怎样的<br>11.Kafka怎样保证消息消费不重复的<br>12.Kafka、RocketMQ、RabbitMQ的区别是什么</p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>同一个类中一个没有事务的 A 方法调用有事务的 B 方法，会发生什么事？如果 B 异常了，会发生什么事？从动态代理的角度给我解释</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>restful的设计理念、修改和删除资源的时候为什么要把id放在url里而不放在http的参数里</p><p>登录怎么做。判断用户是否登录。</p><p>高并发系统的限流如何实现</p><p>高并发秒杀系统的设计</p><p>负载均衡如何设计</p><p>怎么进行一个权限控制</p><p>linux字节码</p><p>linux代码对齐?</p><p>N个线程交替打印，怎么实现，写出来，跑一下<br>设计长短地址转换</p><p>汇编过程</p><p>tcp洪流知道吗</p><p>怎么设计一个日志系统</p><p>怎么提升系统的并发能力（从索引优化、读写分离、分库分表说到<a href="https://www.nowcoder.com/jump/super-jump/word?word=redis" target="_blank" rel="noopener">redis</a>主从集群、分布式锁、mq解耦异步削峰、ngnix、限流）面试官补充说还要考虑网路传输、<a href="https://www.nowcoder.com/jump/super-jump/word?word=前端" target="_blank" rel="noopener">前端</a>优化等等，</p><p>如果访问一个网页，发现超时了，是怎么去排查问题的</p><p>降级处理hystrix了解过么</p><p>CPU架构，控制器，寄存器，运算器，高速缓存？</p><p>NIO的原理，jdk中有哪些工具和类去实现，如何实现（selector和channel的用法）,真的好用吗？还可以用什么？（面试官应该是想问netty，因为没有实际用过，只能给他讲了netty的原理） </p><p> 那来说说AIO吧，和NIO什么区别（对异步的理解）,AIO在工程中如何实现的？（大概说了下ajax的回调函数），又问回调函数具体是怎么实现的（传递函数指针）。 </p><p> 然后借着异步IO想问消息队列，讲了一下几种模型和原理。（面试中没有用过没关系，只要你懂原理还是可以跟面试官讲，起码可以证明你是爱学习的）</p><p>讲讲Spring中怎么对初始化的bean做其他操作。（这里有三种方式，@PostConstruct注解方式，init-method的XML配置方式，InitializingBean接口方式） </p><p> 三种实现上有什么区别（还好看过点<a href>源码</a>，其实前两种是一个意思，都是通过反射的方式用aop思想实现，可以消除对spring的依赖；接口方式是直接调用afterPropertiesSet方法，效率更高点。spring加载bean时先判断接口方式，再执行配置注解方式）</p><p>问卷发给1w个人，都是20-30岁之间的，怎么最快的按年龄<a href>排序</a>？** </p><p>  觉得要用好题目给的关键信息，最后说不出来，还想过双轴快排，因为我面试前还在复习Arrays.sort()的<a href>源码</a>。。。，然后他说了实现，就是用一个大小为10的列表数组，遍历一次问卷就可以排好序了。其实我还是很迷惑，我以为他是要1w份全都严格<a href>排序</a>，就是先按年龄后按问卷内容。。。<br>4kw个不重复的数，max不超过8kw，找小于max之后的不存在在数组中的4个数，如果内存只有10m怎么找？举例：1，2，3，8，答案是：7，6，5，4** </p><p>  想了想分片，他说不对，最后答案是用位图。我直呼妙啊然后说你太有意思了 😂我真的全程就在卖傻你知道吗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[海量数据](https:&#x2F;&#x2F;www.nowcoder.com&#x2F;jump&#x2F;super-jump&#x2F;word?word&#x3D;海量数据)库解决方案 》（而我看的技术内幕），jvm的题是来自JVM设计[算法]</span><br></pre></td></tr></table></figure><p>RSA 具体说说?</p><p>DES 和 AES 区别?</p><p>rpc 微服务？ 怎么保证数据一致？</p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>看你一面也写了一个topk的算法，那我变一下，依然是这个场景，只不过我现在要统计字符出现的次数，拿两个or多个线程去统计，怎么做？<br>括号匹配<br>括号匹配变式：括号中有一个特殊符号<em>，这个</em>可以替代左括号或者右括号，也可以代表一个空，即什么也不代表，来做做？</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring剖析</title>
      <link href="/2020/11/05/spring%E5%89%96%E6%9E%90/"/>
      <url>/2020/11/05/spring%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringIOC%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="Spring IoC的初始化过程"></p><ul><li><p>如果要使用Spring实现控制反转，需要先在src/main/resources下创建一个名为spring.xml的XML配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 将Student交给spring容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.sjh.entity.Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"sjh"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"24"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>利用IoC获取对象（通过bean的id）：</p><p>ClassPathXmlApplicationContext获取了配置文件，通过配置文件对象的getBean方法获取一个Student的实例，由于在配置文件中已经注入了属性，此时student是有相关属性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIoC2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring.xml"</span>);</span><br><span class="line">    Student student = (Student) ac.getBean(<span class="string">"student"</span>);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2020/11/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/11/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。<br>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p><h3 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h3><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这<br>些参与者是否要真正执行事务。</p><ol><li><p>运行过程<br> 1.1 准备阶段<br> 协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p><p><img src="/2020/11/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201114200146983.png" alt="image-20201114200146983"></p></li></ol><p>1.2 提交阶段<br>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚<br>事务。<br>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进<br>行提交或者回滚。</p><p><img src="/2020/11/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201114200203810.png" alt="image-20201114200203810"></p><p>存在的问题<br>2.1 同步阻塞</p><p>可以看到在第一阶段执行了准备命令后，我们<strong>每个本地资源都处于锁定状态</strong>，因为除了事务的提交之外啥都做了。</p><p>所以这时候如果本地的其他请求要访问同一个资源，比如要修改商品表 id 等于 100 的那条数据，那么此时是被阻塞住的，必须等待前面事务的完结2.2 单点问题<br>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等<br>待，无法完成其它操作。</p><p>  2.3 数据不一致<br>  在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消<br>  息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(如果任一参与者(Cohort)节点在第一阶段返回的响应消息为&quot;No&quot;，或者协调者(Coordinator)节点在第一阶段的询问超时之前无法获取所有参与者(Cohort)节点的响应消息时：)</span><br></pre></td></tr></table></figure><h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>三阶段提交（Three-phase commit），是二阶段提交（2PC）的改进版本。3PC 的引入是为了解决 2PC 同步阻塞和减少数据不一致的情况。</p><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><blockquote><ol><li><code>引入超时机制</code>。同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个<code>准备阶段</code>。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，3PC把2PC的<code>准备阶段再次一分为二</code>，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</li></ol></blockquote><p><img src="https://user-gold-cdn.xitu.io/2020/6/9/17298d963cef2191?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p><strong>CanCommit</strong>：协调者向所有参与者发送CanCommit命令，询问是否可以执行事务提交操作。如果全部响应YES则进入下一个阶段。</p><p><strong>PreCommit</strong>：<code>协调者</code>向所有<code>参与者</code>发送<code>PreCommit</code>命令，询问是否可以进行事务的预提交操作，参与者接收到PreCommit请求后，如参与者成功的执行了事务操作，则返回<code>Yes</code>响应，进入最终commit阶段。一旦参与者中有向协调者发送了<code>No</code>响应，协调者向所有参与者发送<code>abort</code>请求，参与者接受abort命令执行事务的中断。</p><p><strong>DoCommit</strong>： 在前两个阶段中所有参与者的响应反馈均是<code>YES</code>后，协调者向参与者发送<code>DoCommit</code>命令正式提交事务，如协调者没有接收到参与者发送的ACK响应，会向所有参与者发送<code>abort</code>请求命令，执行事务的中断。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><blockquote><p>同时在协调者和参与者中都引入超时机制。 改善同步阻塞 改善单点故障</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2020/5/23/1723f9467bcffd7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h3><p><strong>TCC 就是一种业务层面或者是应用层的两阶段提交</strong>。</p><p>TCC 分为指代 Try、Confirm、Cancel </p><p>TCC 分为两个阶段，第一阶段是资源检查预留阶段即 Try，第二阶段是提交或回滚，如果是提交的话就是执行真正的业务操作，如果是回滚则是执行预留资源的取消，恢复初始状态。</p><p>Try</p><ul><li>做资源预留（比如冻结库存，而不是直接减库存）。</li></ul><p>Confirm</p><ul><li>确认提交，在Try阶段所有事务参与者执行成功之后开始执行Confirm，通常情况下，TCC默认Confirm是不会出错的，认为只要Try成功，则Confirm一定成功，若Confirm真的出错了，需要采用重试机制或者人工干预。</li></ul><p>Cancel</p><ul><li>执行回滚，在Try阶段有事务参与者执行失败则开始执行Cancel，通常情况下，TCC默认Cancel是不会出错的，认为只要Try成功，则Cancel一定成功，若Cancel真的出错了，需要采用重试机制或者人工干预。</li></ul><h3 id="基于消息中间件的最终一致性事务方案"><a href="#基于消息中间件的最终一致性事务方案" class="headerlink" title="基于消息中间件的最终一致性事务方案"></a>基于消息中间件的最终一致性事务方案</h3><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并<br>且使用了消息队列来保证最终一致性。</p><ol><li><p>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一<br> 定会被写入本地消息表中。</p></li><li><p>之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转<br> 发。</p></li><li><p>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</p><p><img src="/2020/11/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201114202427598.png" alt="image-20201114202427598"></p></li></ol><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><p>AT 模式就是两阶段提交，前面我们提到了两阶段提交有同步阻塞的问题，效率太低了，那 Seata 是怎么解决的呢？</p><p>AT 的一阶段直接就把事务提交了，直接释放了本地锁，这么草率直接提交的嘛？当然不是，这里和本地消息表有点类似，就是利用本地事务，执行真正的事务操作中还会插入回滚日志，然后在一个事务中提交。</p><p><strong>这回滚日志怎么来的</strong>？</p><p>通过框架代理 JDBC 的一些类，在执行 SQL 的时候解析 SQL 得到执行前的数据镜像，然后执行 SQL ，再得到执行后的数据镜像，然后把这些数据组装成回滚日志。</p><p>再伴随的这个本地事务的提交把回滚日志也插入到数据库的 UNDO_LOG 表中(所以数据库需要有一张UNDO_LOG 表)。</p><p>这波操作下来在一阶段就可以没有后顾之忧的提交事务了。</p><p>然后一阶段如果成功，那么二阶段可以异步的删除那些回滚日志，如果一阶段失败那么可以通过回滚日志来反向补偿恢复。</p><p>这时候有细心的同学想到了，万一中间有人改了这条数据怎么办？你这镜像就不对了啊？</p><p>所以说还有个全局锁的概念，<strong>在事务提交前需要拿到全局锁</strong>（可以理解为对这条数据的锁），然后才能顺利提交本地事务。</p><p>如果一直拿不到那就需要回滚本地事务了。</p><p><strong>官网的示例很好，我就不自己编了，以下部分内容摘抄自 Seata 官网的示例</strong>：</p><p>此时有两个事务，分别是 tx1、和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。</p><p>tx1 先开始，开启本地事务，拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的 全局锁 ，本地提交释放本地锁。</p><p>tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的 全局锁 ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待全局锁 。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QicvKPaUemcnLqMLVM9jGfV9xJoeFViaGmBEdbhdOa37A2GickFeKO8qS2ejHHfkbNlRt5TTd81fksPw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>可以看到 tx2 的修改被阻塞了，之后重试拿到全局锁之后就能提交然后释放本地锁。</p><p>如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。</p><p>此时，如果 tx2 仍在等待该数据的全局锁，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的全局锁等锁超时，放弃全局锁并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。</p><p><strong>因为整个过程全局锁在 tx1 结束前一直是被 tx1 持有的，所以不会发生脏写的问题</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QicvKPaUemcnLqMLVM9jGfV9fD01HMFCl3H7iasibYCqyQDzCickBZyfichllhcQDGLclpr7qLhR5EWpyQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>然后 <strong>AT 模式默认全局是读未提交的隔离级别</strong>，如果应用在特定场景下，必需要求全局的读已提交 ，可以通过 SELECT FOR UPDATE 语句的代理。</p><p>当然前提是你本地事务隔离级别是读已提交及以上。</p><h3 id="AT-模式小结"><a href="#AT-模式小结" class="headerlink" title="AT 模式小结"></a>AT 模式小结</h3><p>可以看到通过代理来无侵入的得到数据的前后镜像，组装成回滚日志伴随本地事务一起提交，解决了两阶段的同步阻塞问题。</p><p>并且利用全局锁来实现写隔离。</p><p>为了总体性能的考虑，默认是读未提交隔离级别，只代理了 SELECT FOR UPDATE 来进行读已提交的隔离。</p><p><strong>这其实就是两阶段提交的变体实现</strong>。</p><h2 id="TCC-模式"><a href="#TCC-模式" class="headerlink" title="TCC 模式"></a>TCC 模式</h2><p>没什么花头，就是咱们上面分析的需要搞三个方法， <strong>然后把自定义的分支事务纳入到全局事务的管理中</strong></p><p>我贴一张官网的图应该挺清晰了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QicvKPaUemcnLqMLVM9jGfV9Nh8mFXibjwwqQh0XF0verFddlSCDG5U37DK5DTwYjicaTia6W2ZIhegvg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="Saga-模式"><a href="#Saga-模式" class="headerlink" title="Saga 模式"></a>Saga 模式</h2><p>这个 Saga 是 Seata 提供的长事务解决方案，适用于业务流程多且长的情况下，这种情况如果要实现一般的 TCC 啥的可能得嵌套多个事务了。</p><p>并且有些系统无法提供 TCC 这三种接口，比如老项目或者别人公司的，所以就搞了个 Saga 模式，这个 Saga 是在 1987 年 Hector &amp; Kenneth 发表的论⽂中提出的。</p><p>那 Saga 如何做呢？来看下这个图。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QicvKPaUemcnLqMLVM9jGfV9F2cn2hUnvmOHp66ylmtQviapdNesXkWFkArY8pnhVfO7hcpibRaBw5Sw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>假设有 N 个操作，直接从 T1 开始就是直接执行提交事务，然后再执行 T2，可以看到就是无锁的直接提交，到 T3 发现执行失败了，然后就进入 Compenstaing 阶段，开始一个一个倒回补偿了。</p><p>思想就是一开始蒙着头干，别怂，出了问题咱们再一个一个改回去呗。</p><p>可以看到这种情况是不保证事务的隔离性的，并且 Saga 也有 TCC 的一样的注意点，需要空补偿，防悬挂和幂等。</p><p>而且极端情况下会因为数据被改变了导致无法回滚的情况。比如第一步给我打了 2 万块钱，我给取出来花了，这时候你回滚，我账上余额已经 0 了，你说怎么办嘛？难道给我还搞负的不成?</p><p>这种情况只能在业务流程上入手，我写代码其实一直是这样写的，就拿买皮肤的场景来说，<strong>我都是先扣钱再给皮肤。</strong></p><p>假设先给皮肤扣钱失败了不就白给了嘛？这钱你来补啊？你觉得用户会来反馈说皮肤给了钱没扣嘛？</p><p>可能有小机灵鬼说我到时候把皮肤给改回去，嘿嘿这种事情确实发生过，啧啧，被骂的真惨。</p><p>所以<strong>正确的流程应该是先扣钱再给皮肤</strong>，钱到自己袋里先，皮肤没给成功用户自然而然会找过来，这时候再给他呗，虽说可能你写出了个 BUG ，但是还好不是个白给的 BUG。</p><p>所以说这点在编码的时候还是得注意下的。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT认证</title>
      <link href="/2020/11/05/JWT%E8%AE%A4%E8%AF%81/"/>
      <url>/2020/11/05/JWT%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JWT-身份认证优缺点分析以及常见问题解决方案"><a href="#JWT-身份认证优缺点分析以及常见问题解决方案" class="headerlink" title="JWT 身份认证优缺点分析以及常见问题解决方案"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=jwt-身份认证优缺点分析以及常见问题解决方案" target="_blank" rel="noopener">JWT 身份认证优缺点分析以及常见问题解决方案</a></h1><p>之前分享了一个使用 Spring Security 实现 JWT 身份认证的 Demo，文章地址：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485622&idx=1&sn=e9750ed63c47457ba1896db8dfceac6a&chksm=cea2477df9d5ce6b7af20e582c6c60b7408a6459b05b849394c45f04664d1651510bdee029f7&token=684071313&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">适合初学者入门 Spring Security With JWT 的 Demo</a>。 Demo 非常简单，没有介绍到 JWT 存在的一些问题。所以，单独抽了一篇文章出来介绍。为了完成这篇文章，我查阅了很多资料和文献，我觉得应该对大家有帮助。</p><p>相关阅读：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485626&idx=1&sn=3247aa9000693dd692de8a04ccffeec1&chksm=cea24771f9d5ce675ea0203633a95b68bfe412dc6a9d05f22d221161147b76161d1b470d54b3&token=684071313&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">《一问带你区分清楚Authentication,Authorization以及Cookie、Session、Token》</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485622&idx=1&sn=e9750ed63c47457ba1896db8dfceac6a&chksm=cea2477df9d5ce6b7af20e582c6c60b7408a6459b05b849394c45f04664d1651510bdee029f7&token=684071313&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">适合初学者入门 Spring Security With JWT 的 Demo</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485640&idx=1&sn=0ff147808318d53b371f16bb730c96ef&chksm=cea24703f9d5ce156ba67662f6f3f482330e8e6ebd9d44c61bf623083e9b941d8a180db6b0ea&token=1533246333&lang=zh_CN#rd" target="_blank" rel="noopener">Spring Boot 使用 JWT 进行身份和权限验证</a></li></ul><h2 id="Token-认证的优势"><a href="#Token-认证的优势" class="headerlink" title="Token 认证的优势"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=token-认证的优势" target="_blank" rel="noopener">Token 认证的优势</a></h2><p>相比于 Session 认证的方式来说，使用 token 进行身份认证主要有下面三个优势：</p><h3 id="1-无状态"><a href="#1-无状态" class="headerlink" title="1.无状态"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=_1无状态" target="_blank" rel="noopener">1.无状态</a></h3><p>token 自身包含了身份验证所需要的所有信息，使得我们的服务器不需要存储 Session 信息，这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。但是，也正是由于 token 的无状态，也导致了它最大的缺点：当后端在token 有效期内废弃一个 token 或者更改它的权限的话，不会立即生效，一般需要等到有效期过后才可以。另外，当用户 Logout 的话，token 也还有效。除非，我们在后端增加额外的处理逻辑。</p><h3 id="2-有效避免了CSRF-攻击"><a href="#2-有效避免了CSRF-攻击" class="headerlink" title="2.有效避免了CSRF 攻击"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=_2有效避免了csrf-攻击" target="_blank" rel="noopener">2.有效避免了CSRF 攻击</a></h3><p><strong>CSRF（Cross Site Request Forgery）</strong>一般被翻译为 <strong>跨站请求伪造</strong>，属于网络攻击领域范围。相比于 SQL 脚本注入、XSS等等安全攻击方式，CSRF 的知名度并没有它们高。但是,它的确是每个系统都要考虑的安全隐患，就连技术帝国 Google 的 Gmail 在早些年也被曝出过存在 CSRF 漏洞，这给 Gmail 的用户造成了很大的损失。</p><p>那么究竟什么是 <strong>跨站请求伪造</strong> 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子：</p><p>小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">src</span>=<span class="string">http://www.mybank.com/Transfer?bankId</span>=<span class="string">11&amp;money</span>=<span class="string">10000</span>&gt;</span>科学理财，年盈利率过万<span class="tag">&lt;/&gt;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>导致这个问题很大的原因就是： Session 认证中 Cookie 中的 session_id 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。</p><p><strong>那为什么 token 不会存在这种问题呢？</strong></p><p>我是这样理解的：一般情况下我们使用 JWT 的话，在我们登录成功获得 token 之后，一般会选择存放在 local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 token 的，所以这个请求将是非法的。</p><p>但是这样会存在 XSS 攻击中被盗的风险，为了避免 XSS 攻击，你可以选择将 token 存储在标记为<code>httpOnly</code> 的cookie 中。但是，这样又导致了你必须自己提供CSRF保护。</p><p>具体采用上面哪两种方式存储 token 呢，大部分情况下存放在 local storage 下都是最好的选择，某些情况下可能需要存放在标记为<code>httpOnly</code> 的cookie 中会更好。</p><h3 id="3-适合移动端应用"><a href="#3-适合移动端应用" class="headerlink" title="3.适合移动端应用"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=_3适合移动端应用" target="_blank" rel="noopener">3.适合移动端应用</a></h3><p>使用 Session 进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到 Cookie（需要 Cookie 保存 SessionId），所以不适合移动端。</p><p>但是，使用 token 进行身份认证就不会存在这种问题，因为只要 token 可以被客户端存储就能够使用，而且 token 还可以跨语言使用。</p><h3 id="4-单点登录友好"><a href="#4-单点登录友好" class="headerlink" title="4.单点登录友好"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=_4单点登录友好" target="_blank" rel="noopener">4.单点登录友好</a></h3><p>使用 Session 进行身份认证的话，实现单点登录，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 token 进行认证的话， token 被保存在客户端，不会存在这些问题。</p><h2 id="Token-认证常见问题以及解决办法"><a href="#Token-认证常见问题以及解决办法" class="headerlink" title="Token 认证常见问题以及解决办法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=token-认证常见问题以及解决办法" target="_blank" rel="noopener">Token 认证常见问题以及解决办法</a></h2><h3 id="1-注销登录等场景下-token-还有效"><a href="#1-注销登录等场景下-token-还有效" class="headerlink" title="1.注销登录等场景下 token 还有效"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=_1注销登录等场景下-token-还有效" target="_blank" rel="noopener">1.注销登录等场景下 token 还有效</a></h3><p>与之类似的具体相关场景有：</p><ol><li>退出登录;</li><li>修改密码;</li><li>服务端修改了某个用户具有的权限或者角色；</li><li>用户的帐户被删除/暂停。</li><li>用户由管理员注销；</li></ol><p>这个问题不存在于 Session 认证方式中，因为在 Session 认证方式中，遇到这种情况的话服务端删除对应的 Session 记录即可。但是，使用 token 认证的方式就不好解决了。我们也说过了，token 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的。那么，我们如何解决这个问题呢？查阅了很多资料，总结了下面几种方案：</p><ul><li><strong>将 token 存入内存数据库</strong>：将 token 存入 DB 中，redis 内存数据库在这里是是不错的选择。如果需要让某个 token 失效就直接从 redis 中删除这个 token 即可。但是，这样会导致每次使用 token 发送请求都要先从 DB 中查询 token 是否存在的步骤，而且违背了 JWT 的无状态原则。</li><li><strong>黑名单机制</strong>：和上面的方式类似，使用内存数据库比如 redis 维护一个黑名单，如果想让某个 token 失效的话就直接将这个 token 加入到 <strong>黑名单</strong> 即可。然后，每次使用 token 进行请求的话都会先判断这个 token 是否存在于黑名单中。</li><li><strong>修改密钥 (Secret)</strong> : 我们为每个用户都创建一个专属密钥，如果我们想让某个 token 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大，比如：1⃣️如果服务是分布式的，则每次发出新的 token 时都必须在多台机器同步密钥。为此，你需要将必须将机密存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。2⃣️如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的。</li><li><strong>保持令牌的有效期限短并经常轮换</strong> ：很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。</li></ul><p>对于修改密码后 token 还有效问题的解决还是比较容易的，说一种我觉得比较好的方式：<strong>使用用户的密码的哈希值对 token 进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。</strong></p><h3 id="2-token-的续签问题"><a href="#2-token-的续签问题" class="headerlink" title="2.token 的续签问题"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=_2token-的续签问题" target="_blank" rel="noopener">2.token 的续签问题</a></h3><p>token 有效期一般都建议设置的不太长，那么 token 过期后如何认证，如何实现动态刷新 token，避免用户经常需要重新登录？</p><p>我们先来看看在 Session 认证中一般的做法：<strong>假如 session 的有效期30分钟，如果 30 分钟内用户有访问，就把 session 有效期被延长30分钟。</strong></p><ol><li><strong>类似于 Session 认证中的做法</strong>：这种方案满足于大部分场景。假设服务端给的 token 有效期设置为30分钟，服务端每次进行校验时，如果发现 token 的有效期马上快过期了，服务端就重新生成 token 给客户端。客户端每次请求都检查新旧token，如果不一致，则更新本地的token。这种做法的问题是仅仅在快过期的时候请求才会更新 token ,对客户端不是很友好。</li><li><strong>每次请求都返回新 token</strong> :这种方案的的思路很简单，但是，很明显，开销会比较大。</li><li><strong>token 有效期设置到半夜</strong> ：这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</li><li><strong>用户登录返回两个 token</strong> ：第一个是 acessToken ，它的过期时间 token 本身的过期时间比如半个小时，另外一个是 refreshToken 它的过期时间更长一点比如为1天。客户端登录后，将 accessToken和refreshToken 保存在本地，每次访问将 accessToken 传给服务端。服务端校验 accessToken 的有效性，如果过期的话，就将 refreshToken 传给服务端。如果有效，服务端就生成新的 accessToken 给客户端。否则，客户端就重新登录即可。该方案的不足是：1⃣️需要客户端来配合；2⃣️用户注销的时候需要同时保证两个 token 都无效；3⃣️重新请求获取 token 的过程中会有短暂 token 不可用的情况（可以通过在客户端设置定时器，当accessToken 快过期的时候，提前去通过 refreshToken 获取新的accessToken）。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/authority-certification/JWT优缺点分析以及常见问题解决方案?id=总结" target="_blank" rel="noopener">总结</a></h2><p>JWT 最适合的场景是不需要服务端保存用户状态的场景，比如如果考虑到 token 注销和 token 续签的场景话，没有特别好的解决方案，大部分解决方案都给 token 加上了状态，这就有点类似 Session 认证了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两阶段提交</title>
      <link href="/2020/11/04/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
      <url>/2020/11/04/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><h3 id="redo-log日志模块"><a href="#redo-log日志模块" class="headerlink" title="redo log日志模块"></a>redo log日志模块</h3><p>redo log是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败（media failure）时，redo log文件就能派上用场，如数据库掉电，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。</p><p>在一条更新语句进行执行的时候，InnoDB引擎会把更新记录写到redo log日志中，然后更新内存，此时算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将redo log中的内容更新到磁盘中，这里涉及到<code>WAL</code>即<code>Write Ahead logging</code>技术，他的关键点是先写日志，再写磁盘。</p><p>有了redo log日志，那么在数据库进行异常重启的时候，可以根据redo log日志进行恢复，也就达到了<code>crash-safe</code>。</p><p>redo log日志的大小是固定的，即记录满了以后就从头循环写。</p><p><img src="https://www.linuxidc.com/upload/2018_11/181121105137361.jpg" alt="img"></p><p>图片来自极客时间，该图展示了一组4个文件的redo log日志，checkpoint之前表示擦除完了的，即可以进行写的，擦除之前会更新到磁盘中，write pos是指写的位置，当write pos和checkpoint相遇的时候表明redo log已经满了，这个时候数据库停止进行数据库更新语句的执行，转而进行redo log日志同步到磁盘中。</p><p>（bin log日志用于数据恢复和主从复制）</p><p><strong>为了保证事务的持久性</strong>，mysql的InnoDB采用了WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。<br> 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p><p><img src="https://img2020.cnblogs.com/blog/1331592/202008/1331592-20200817182643325-434826336.png" alt="img"></p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p>binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠binlog是没有<code>crash-safe</code>能力的</p><p>MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。<br> <strong>为什么会有两份日志呢？</strong>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p><p>这两种日志有以下三点不同。<br> 1.redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。<br> 2.redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。<br> 3.redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><p><strong>为了保证两份日志的逻辑一致性</strong>mysql采用了两阶段提交。<br> 下面是一个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p><p><img src="https:////upload-images.jianshu.io/upload_images/8561045-47d41f9158ff9570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1142/format/webp" alt="img"></p><p>2e5bff4910ec189fe1ee6e2ecc7b4bbe.png</p><p> 最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。<br><strong>为什么必须有“两阶段提交”呢？</strong><br> 如果不使用两阶段提交，假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？<br> 1.<strong>先写 redo log 后写 binlog。</strong>假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。<br> 但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。<br> 然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。<br> 2.<strong>先写 binlog 后写 redo log。</strong>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。<br> 可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。<br><strong>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka副本同步</title>
      <link href="/2020/11/04/kafka%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5/"/>
      <url>/2020/11/04/kafka%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Kafka副本"><a href="#Kafka副本" class="headerlink" title="Kafka副本"></a>Kafka副本</h2><p>Kafka中主题的每个Partition有一个预写式日志文件，每个Partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到Partition中，Partition中的每个消息都有一个连续的序列号叫做offset,<br>确定它在分区日志中唯一的位置。<br><img src="https://img-blog.csdn.net/20160620014300167" alt="这里写图片描述"><br>Kafka每个topic的partition有N个副本，其中N是topic的复制因子。Kafka通过多副本机制实现故障自动转移，当Kafka集群中一个Broker失效情况下仍然保证服务可用。在Kafka中发生复制时确保partition的预写式日志有序地写到其他节点上。N个replicas中。其中一个replica为leader，其他都为follower，leader处理partition的所有读写请求，与此同时，follower会被动定期地去复制leader上的数据。<br><img src="https://img-blog.csdn.net/20160620014329074" alt="这里写图片描述"><br>Kafka必须提供数据复制算法保证,如果leader发生故障或挂掉，一个新leader被选举并接收客户端的消息成功写入。Kafka确保从同步副本列表中选举一个副本为leader,或者换句话说,follower追赶leader数据。leader负责维护和跟踪ISR中所有follower滞后状态。当生产者发送一条消息到Broker,leader写入消息并复制到所有follower。消息提交之后才被成功复制到所有的同步副本。消息复制延迟受最慢的follower限制,重要的是快速检测慢副本,如果follower”落后”太多或者失效,leader将会把它从replicas从ISR移除。</p><h2 id="partition的follower追上leader含义"><a href="#partition的follower追上leader含义" class="headerlink" title="partition的follower追上leader含义"></a>partition的follower追上leader含义</h2><p>Kafka中每个partition的follower没有“赶上”leader的日志可能会从同步副本列表中移除。下面用一个例子解释一下“追赶”到底是什么意思。请看一个例子：主题名称为foo 1 partition 3 replicas。假如partition的replication分布在Brokers 1、2和3上，并且Broker 3消息已经成功提交。同步副本列表中1为leader、2和3为follower。假设replica.lag.max.messages设置为4，表明只要follower落后leader不超过3，就不会从同步副本列表中移除。replica.lag.time.max设置为500 ms，表明只要follower向leader发送请求时间间隔不超过500 ms，就不会被标记为死亡,也不会从同步副本列中移除。<br><img src="https://img-blog.csdn.net/20160620014619456" alt="这里写图片描述"><br>下面看看，生产者发送下一条消息写入leader，与此同时follower Broker 3 GC暂停，如下图所示:<br><img src="https://img-blog.csdn.net/20160620014641722" alt="这里写图片描述"><br>直到follower Broker 3从同步副本列表中移除或追赶上leader log end offset，最新的消息才会认为提交。注意,因为follower Broker 3小于replica.lag.max.messages= 4落后于leader Broker 1，Kafka不会从同步副本列表中移除。在这种情况下,这意味着follower Broker 3需要迎头追赶上知道offset = 6,如果是,那么它完全“赶上” leader Broker 1 log end offset。让我们假设代理3出来的GC暂停在100 ms和追赶上领袖的日志结束偏移量。在这种状态下，下面partition日志会看起来像这样<br><img src="https://img-blog.csdn.net/20160620014718389" alt="这里写图片描述"></p><h2 id="是什么原因导致分区的副本与leader不同步"><a href="#是什么原因导致分区的副本与leader不同步" class="headerlink" title="是什么原因导致分区的副本与leader不同步"></a>是什么原因导致分区的副本与leader不同步</h2><h3 id="一个副本可以不同步Leader有如下几个原因"><a href="#一个副本可以不同步Leader有如下几个原因" class="headerlink" title="一个副本可以不同步Leader有如下几个原因"></a>一个副本可以不同步Leader有如下几个原因</h3><ul><li>慢副本：在一定周期时间内follower不能追赶上leader。最常见的原因之一是I / O瓶颈导致follower追加复制消息速度慢于从leader拉取速度。</li><li>卡住副本：在一定周期时间内follower停止从leader拉取请求。follower replica卡住了是由于GC暂停或follower失效或死亡。</li><li>新启动副本：当用户给主题增加副本因子时，新的follower不在同步副本列表中，直到他们完全赶上了leader日志。</li></ul><p>一个partition的follower落后于leader足够多时，被认为不在同步副本列表或处于滞后状态。在Kafka-0.8.2.x中,副本滞后判断依据是副本落后于leader最大消息数量(replica.lag.max.messages)或replicas响应partition leader的最长等待时间(replica.lag.time.max.ms)。前者是用来检测缓慢的副本,而后者是用来检测失效或死亡的副本</p><h2 id="如何确定副本是滞后的"><a href="#如何确定副本是滞后的" class="headerlink" title="如何确定副本是滞后的"></a>如何确定副本是滞后的</h2><p>这个模型检测不同步卡住副本列表工作下所有情况都适用。它追踪follower replica时间内没有向leader发送拉取请求,表明它已经死了。另一方面,如果均匀流量模式情况下，为一个主题或多个主题设置这些参数检测模型不同步慢副本列表消息的数量会工作很好,但我们发现生产环境中它不扩展到所有主题各种工作负载。</p><p>接着上面的例子,如果主题foo获取数据速率2 msg/sec，leader单次批量接收一般不会超过3条消息,然后你知道主题参数replica.lag.max.messages设置为4。为什么?因为follower replica从leader复制消息前，已经有大批量消息写leader，follower replica落后于leader不超过3条消息 。另一方面，如果主题foo的follower replica初始落后于leader持续超过3消息,leader会从同步副本列表中移除慢副本，避免消息写延迟增加。</p><p>这本质上是replica.lag.max.messages的目标。能够检测follower与leader不一致且从同步副本列表移除。然而,主题在流量高峰期发送了一批消息(4条消息),等于replica.lag.max.messages = 4配置值。在那一瞬间,2个follower replica将被认为是”out-of-sync”并且leader会从同步副本列表中移除。<br><img src="https://img-blog.csdn.net/20160620014916999" alt="这里写图片描述"><br>2个follower replica都是活着,下次拉取请求他们会赶上leader log end offset并重新加入同步副本列表。重复相同的过程，如果生产者继续发送相对一批较大消息到leader。这种情况演示了当follower replica频繁在从同步副本列表移除和重新加入同步副本列表之间来回切换时，不必要触发虚假警报。<br><img src="https://img-blog.csdn.net/20160620014944061" alt="这里写图片描述"><br>参数replica.lag.max.messages指向核心问题。它的配置值根据队列流量大小和集群一般负载情况做出判断并设置一个合适值!</p><h2 id="副本配置规则"><a href="#副本配置规则" class="headerlink" title="副本配置规则"></a>副本配置规则</h2><p>笔者认为真正重要的事情是检测卡或慢副本,这段时间follower replica是“out-of-sync”落后于leader。在服务端现在只有一个参数需要配置replica.lag.time.max.ms。这个参数解释replicas响应partition leader的最长等待时间。检测卡住或失败副本的探测——如果一个replica失败导致发送拉取请求时间间隔超过replica.lag.time.max.ms。Kafka会认为此replica已经死亡会从同步副本列表从移除。检测慢副本机制发生了变化——如果一个replica开始落后leader超过replica.lag.time.max.ms。Kafka会认为太缓慢并且会从同步副本列表中移除。除非replica请求leader时间间隔大于replica.lag.time.max.ms，因此即使leader使流量激增和大批量写消息。Kafka也不会从同步副本列表从移除该副本。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka的分区再平衡</title>
      <link href="/2020/11/04/kafka%E7%9A%84%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1/"/>
      <url>/2020/11/04/kafka%E7%9A%84%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>所谓的再平衡，指的是在kafka consumer所订阅的topic发生变化时发生的一种分区重分配机制。一般有三种情况会触发再平衡：</p><ul><li>consumer group中的新增或删除某个consumer</li><li>consumer订阅的topic发生变化</li><li>consumer所订阅的topic发生了新增分区的行为</li></ul><p>​    Kafka提供的再平衡策略主要有三种：<code>Round Robin</code>，<code>Range</code>和<code>Sticky</code>，默认使用的是<code>Range</code>。这三种分配策略的主要区别在于：</p><ul><li><code>Round Robin</code>：会采用轮询的方式将当前所有的分区依次分配给所有的consumer；</li><li><code>Range</code>： range 方式是按照主题来分的，不会产生轮询方式的消费混乱问题</li><li>Sticky<ol><li>分区分配尽量均衡，主题分区数量相差最大为1个</li><li>分区分配尽量保持和上次分区保持一致</li></ol></li></ul><ol start="3"><li>如果第一点和第二点冲突，则第一点优先考虑</li></ol><p> <strong>（1） RoundRobin</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/1/23/16fd2062d728c639?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="roundrobin 分区分配"></p><p> RoundRobin 轮询方式将分区所有作为一个整体进行 hash 排序，消费者组内分配分区个数最大差别为1，是按照组来分的，可以解决多个消费者消费数据不均衡的问题。<br> 但是，当消费者组内订阅不同主题时，可能造成消费混乱，如下图所示，consumer0 订阅主题A，consumer1 订阅主题B，将 A、B主题的分区排序后分配给消费者组，TopicB 分区中的数据可能分配到 consumer0 中。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/23/16fd2062e91bb14b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="roundrobin 分区分配-消费者组订阅多个主题"></p><p><strong>（2）Range</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/1/23/16fd2062e1763616?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="range 分区分配"></p><p> range 方式是按照主题来分的，不会产生轮询方式的消费混乱问题。<br> 但是，如下图所示，consumer0、consumer1 同时订阅了主题A和B，可能造成消息分配不对等问题，当消费者组内订阅的主题越多，分区分配可能越不均衡。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/23/16fd2062df3c41c8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="range 分区分配-消费者组订阅多个主题"></p><p>作者：臧小晶<br>链接：<a href="https://juejin.cn/post/6844904050064883725" target="_blank" rel="noopener">https://juejin.cn/post/6844904050064883725</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka的集群选举、数据同步</title>
      <link href="/2020/11/04/kafka%E7%9A%84%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE%E3%80%81%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
      <url>/2020/11/04/kafka%E7%9A%84%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE%E3%80%81%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1%E3%80%81%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Broker选举"><a href="#Broker选举" class="headerlink" title="Broker选举"></a>Broker选举</h3><p>所谓控制器就是一个Borker，在一个kafka集群中，有多个broker节点，但是它们之间需要选举出一个leader，其他的broker充当follower角色。集群中第一个启动的broker会通过在zookeeper中创建临时节点<code>/controller</code>来让自己成为控制器，其他broker启动时也会在zookeeper中创建临时节点，但是发现节点已经存在，所以它们会收到一个异常，意识到控制器已经存在，那么就会在zookeeper中创建watch对象，便于它们收到控制器变更的通知。</p><p>重新选出的controller会增加epoch的值，避免旧的controller复活导致出现两个控制器</p><h3 id="分区Leader选举"><a href="#分区Leader选举" class="headerlink" title="分区Leader选举"></a>分区Leader选举</h3><p>基本思路是按照AR集合中副本的顺序查找第一个存活的副本，并且这个副本在ISR集合中。一个分区的AR集合在分配的时候就被指定，并且只要不发生重分配的情况，集合内部副本的顺序是保持不变的，而分区的ISR集合中副本的顺序可能会改变。注意这里是根据AR的顺序而不是ISR的顺序进行选举的。这个说起来比较抽象，有兴趣的读者可以手动关闭/开启某个集群中的broker来观察一下具体的变化。</p><p>还有一些情况也会发生分区leader的选举，比如当分区进行重分配（reassign）的时候也需要执行leader的选举动作。这个思路比较简单：从重分配的AR列表中找到第一个存活的副本，且这个副本在目前的ISR列表中。</p><p>再比如当发生优先副本（preferred replica partition leader election）的选举时，直接将优先副本设置为leader即可，AR集合中的第一个副本即为优先副本。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka怎么保证顺序消费</title>
      <link href="/2020/11/04/kafka%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9/"/>
      <url>/2020/11/04/kafka%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>如果Kafka要保证多个partition有序，不仅broker保存的数据要保持顺序，消费时也要按序消费。假设partition1堵了，为了有序，那partition2以及后续的分区也不能被消费，这种情况下，Kafka 就退化成了单一队列，毫无并发性可言，极大降低系统性能。因此Kafka使用多partition的概念，并且只保证单partition有序。这样不同partiiton之间不会干扰对方</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka消息堆积</title>
      <link href="/2020/11/04/kafka%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF/"/>
      <url>/2020/11/04/kafka%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>你看这问法，其实本质针对的场景，都是说，可能你的消费端出了问题，不消费了；或者消费的速度极其慢。接着就坑爹了，可能你的消息队列集群的磁盘都快写满了，都没人消费，这个时候怎么办？或者是这整个就积压了几个小时，你这个时候怎么办？或者是你积压的时间太长了，导致比如 RabbitMQ 设置了消息过期时间后就没了怎么办？</p><p>所以就这事儿，其实线上挺常见的，一般不出，一出就是大 case。一般常见于，举个例子，消费端每次消费之后要写 mysql，结果 mysql 挂了，消费端 hang 那儿了，不动了；或者是消费端出了个什么岔子，导致消费速度极其慢。</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>关于这个事儿，我们一个一个来梳理吧，先假设一个场景，我们现在消费端出故障了，然后大量消息在 mq 里积压，现在出事故了，慌了。</p><h3 id="大量消息在-mq-里积压了几个小时了还没解决"><a href="#大量消息在-mq-里积压了几个小时了还没解决" class="headerlink" title="大量消息在 mq 里积压了几个小时了还没解决"></a>大量消息在 mq 里积压了几个小时了还没解决</h3><p>几千万条数据在 MQ 里积压了七八个小时，从下午 4 点多，积压到了晚上 11 点多。这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。</p><p>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。</p><p>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：</p><ul><li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。</li><li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</li><li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li><li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li><li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li></ul><h3 id="mq-中的消息过期失效了"><a href="#mq-中的消息过期失效了" class="headerlink" title="mq 中的消息过期失效了"></a>mq 中的消息过期失效了</h3><p>假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是<strong>大量的数据会直接搞丢</strong>。</p><p>这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是<strong>批量重导</strong>，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。</p><p>假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p><h3 id="mq-都快写满了"><a href="#mq-都快写满了" class="headerlink" title="mq 都快写满了"></a>mq 都快写满了</h3><p>如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，<strong>消费一个丢弃一个，都不要了</strong>，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何保证消费的幂等性(不重复消费)</title>
      <link href="/2020/11/04/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>/2020/11/04/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p><p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</p><p>举个栗子。<br>有这么个场景。数据 1/2/3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152/153/154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 offset=153的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1/2 的 offset 并没有提交，kafka 也就不知道你已经消费了 offset=153 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1/2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p><p><img src="https://segmentfault.com/img/bVbp58K?w=568&h=454" alt="clipboard.png"></p><p>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1/2 在数据库里插入了 2 次，那么数据就错啦。</p><p>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。</p><p>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</p><p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。<br>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</p><p>所以第二个问题来了，怎么保证消息队列消费的幂等性？<br>其实还是得结合业务来思考，我这里给几个思路：</p><p>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。<br>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。<br>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。<br>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</p><p><img src="https://segmentfault.com/img/bVbp58O?w=401&h=371" alt="clipboard.png"></p><h3 id="Exactly-Once"><a href="#Exactly-Once" class="headerlink" title="Exactly Once"></a>Exactly Once</h3><p>将服务器的 ACK 级别设置为-1，可以保证 producer 到 server 之间不会丢失数据，即 <strong>At Least Once</strong> 语义。相对的，将服务器 ACK 级别设置为0，可以保证生产者每条消息只会被发送一次，即<strong>At Most Once</strong> 语义。<br> At Least Once 可以保证数据不丢失，但是不能保证数据不重复；相对的，At Most Once 可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如交易数据，下游数据消费者要求数据既不重复也不丢失，即 <strong>Exactly Once</strong> 语义。<br> 0.11版本的 Kafka，引入了<strong>幂等性</strong>：producer 不论向 server 发送多少重复数据，server 端都只会持久化一条。即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">At Least Once + 幂等性 &#x3D; Exactly Once</span><br></pre></td></tr></table></figure><p>要启用幂等性，只需要将 producer 的参数中 <code>enable.idompotence</code> 设置为 <code>true</code> 即可。</p><p>为了实现Producer的幂等语义，Kafka引入了<code>Producer ID</code>（即<code>PID</code>）和<code>Sequence Number</code>。每个新的Producer在初始化的时候会被分配一个唯一的PID，该PID对用户完全透明而不会暴露给用户。</p><p>对于每个PID，该Producer发送数据的每个<code>&lt;Topic, Partition&gt;</code>都对应一个从0开始单调递增的<code>Sequence Number</code>。</p><p>类似地，Broker端也会为每个<code>&lt;PID, Topic, Partition&gt;</code>维护一个序号，并且每次Commit一条消息时将其对应序号递增。对于接收的每条消息，如果其序号比Broker维护的序号（即最后一次Commit的消息的序号）大一，则Broker会接受它，否则将其丢弃：</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper在kafka中的作用</title>
      <link href="/2020/11/04/zookeeper%E5%9C%A8kafka%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2020/11/04/zookeeper%E5%9C%A8kafka%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Zookeeper-在-Kafka-中的作用"><a href="#Zookeeper-在-Kafka-中的作用" class="headerlink" title="Zookeeper 在 Kafka 中的作用"></a>Zookeeper 在 Kafka 中的作用</h2><h3 id="1、Broker注册"><a href="#1、Broker注册" class="headerlink" title="1、Broker注册"></a>1、Broker注册</h3><p><strong>Broker是分布式部署并且相互之间相互独立，但是需要有一个注册系统能够将整个集群中的Broker管理起来</strong>，此时就使用到了Zookeeper。在Zookeeper上会有一个专门<strong>用来进行Broker服务器列表记录</strong>的节点：</p><p>/brokers/ids</p><p>每个Broker在启动时，都会到Zookeeper上进行注册，即到/brokers/ids下创建属于自己的节点，如/brokers/ids/[0…N]。</p><p>Kafka使用了全局唯一的数字来指代每个Broker服务器，不同的Broker必须使用不同的Broker ID进行注册，创建完节点后，<strong>每个Broker就会将自己的IP地址和端口信息记录</strong>到该节点中去。其中，Broker创建的节点类型是临时节点，一旦Broker宕机，则对应的临时节点也会被自动删除。</p><p>kafka的元数据都存放在zk上面,由zk来管理</p><h3 id="2、Topic注册"><a href="#2、Topic注册" class="headerlink" title="2、Topic注册"></a>2、Topic注册</h3><p>在Kafka中，同一个<strong>Topic的消息会被分成多个分区</strong>并将其分布在多个Broker上，<strong>这些分区信息及与Broker的对应关系</strong>也都是由Zookeeper在维护，由专门的节点来记录，如：</p><p>/borkers/topics</p><p>Kafka中每个Topic都会以/brokers/topics/[topic]的形式被记录，如/brokers/topics/login和/brokers/topics/search等。Broker服务器启动后，会到对应Topic节点（/brokers/topics）上注册自己的Broker ID并写入针对该Topic的分区总数，如/brokers/topics/login/3-&gt;2，这个节点表示Broker ID为3的一个Broker服务器，对于”login”这个Topic的消息，提供了2个分区进行消息存储，同样，这个分区节点也是临时节点。</p><h3 id="3、生产者负载均衡"><a href="#3、生产者负载均衡" class="headerlink" title="3、生产者负载均衡"></a>3、生产者负载均衡</h3><p>由于同一个Topic消息会被分区并将其分布在多个Broker上，因此，<strong>生产者需要将消息合理地发送到这些分布式的Broker上</strong>，那么如何实现生产者的负载均衡，Kafka支持传统的四层负载均衡，也支持Zookeeper方式实现负载均衡。</p><p>(1) 四层负载均衡，根据生产者的IP地址和端口来为其确定一个相关联的Broker。通常，一个生产者只会对应单个Broker，然后该生产者产生的消息都发往该Broker。这种方式逻辑简单，每个生产者不需要同其他系统建立额外的TCP连接，只需要和Broker维护单个TCP连接即可。但是，其无法做到真正的负载均衡，因为实际系统中的每个生产者产生的消息量及每个Broker的消息存储量都是不一样的，如果有些生产者产生的消息远多于其他生产者的话，那么会导致不同的Broker接收到的消息总数差异巨大，同时，生产者也无法实时感知到Broker的新增和删除。</p><p>(2) 使用Zookeeper进行负载均衡，由于每个Broker启动时，都会完成Broker注册过程，生产者会通过该节点的变化来动态地感知到Broker服务器列表的变更，这样就可以实现动态的负载均衡机制。</p><h3 id="4、消费者负载均衡"><a href="#4、消费者负载均衡" class="headerlink" title="4、消费者负载均衡"></a>4、消费者负载均衡</h3><p>与生产者类似，Kafka中的消费者同样需要进行负载均衡来实现多个消费者合理地从对应的Broker服务器上接收消息，每个消费者分组包含若干消费者，<strong>每条消息都只会发送给分组中的一个消费者</strong>，不同的消费者分组消费自己特定的Topic下面的消息，互不干扰。</p><h3 id="5、分区-与-消费者-的关系"><a href="#5、分区-与-消费者-的关系" class="headerlink" title="5、分区 与 消费者 的关系"></a>5、分区 与 消费者 的关系</h3><p><strong>消费组 (Consumer Group)：</strong><br> consumer group 下有多个 Consumer（消费者）。<br> 对于每个消费者组 (Consumer Group)，Kafka都会为其分配一个全局唯一的Group ID，Group 内部的所有消费者共享该 ID。订阅的topic下的每个分区只能分配给某个 group 下的一个consumer(当然该分区还可以被分配给其他group)。<br> 同时，Kafka为每个消费者分配一个Consumer ID，通常采用”Hostname:UUID”形式表示。</p><p>在Kafka中，规定了<strong>每个消息分区 只能被同组的一个消费者进行消费</strong>，因此，需要在 Zookeeper 上记录 消息分区 与 Consumer 之间的关系，每个消费者一旦确定了对一个消息分区的消费权力，需要将其Consumer ID 写入到 Zookeeper 对应消息分区的临时节点上，例如：</p><p>/consumers/[group_id]/owners/[topic]/[broker_id-partition_id]</p><p>其中，[broker_id-partition_id]就是一个 消息分区 的标识，节点内容就是该 消息分区 上 消费者的Consumer ID。</p><h3 id="6、消息-消费进度Offset-记录"><a href="#6、消息-消费进度Offset-记录" class="headerlink" title="6、消息 消费进度Offset 记录"></a>6、消息 消费进度Offset 记录</h3><p>在消费者对指定消息分区进行消息消费的过程中，<strong>需要定时地将分区消息的消费进度Offset记录到Zookeeper上</strong>，以便在该消费者进行重启或者其他消费者重新接管该消息分区的消息消费后，能够从之前的进度开始继续进行消息消费。Offset在Zookeeper中由一个专门节点进行记录，其节点路径为:</p><p>/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]</p><p>节点内容就是Offset的值。</p><h3 id="7、消费者注册"><a href="#7、消费者注册" class="headerlink" title="7、消费者注册"></a>7、消费者注册</h3><p>消费者服务器在初始化启动时加入消费者分组的步骤如下</p><p>注册到消费者分组。每个消费者服务器启动时，都会到Zookeeper的指定节点下创建一个属于自己的消费者节点，例如/consumers/[group_id]/ids/[consumer_id]，完成节点创建后，消费者就会将自己订阅的Topic信息写入该临时节点。</p><p><strong>对 消费者分组 中的 消费者 的变化注册监听</strong>。每个 消费者 都需要关注所属 消费者分组 中其他消费者服务器的变化情况，即对/consumers/[group_id]/ids节点注册子节点变化的Watcher监听，一旦发现消费者新增或减少，就触发消费者的负载均衡。</p><p><strong>对Broker服务器变化注册监听</strong>。消费者需要对/broker/ids/[0-N]中的节点进行监听，如果发现Broker服务器列表发生变化，那么就根据具体情况来决定是否需要进行消费者负载均衡。</p><p><strong>进行消费者负载均衡</strong>。为了让同一个Topic下不同分区的消息尽量均衡地被多个 消费者 消费而进行 消费者 与 消息 分区分配的过程，通常，对于一个消费者分组，如果组内的消费者服务器发生变更或Broker服务器发生变更，会发出消费者负载均衡。</p><p>以下是kafka在zookeep中的详细存储结构图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/3149801-0d2ed2bd8b7bec25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka如何保证不丢失消息</title>
      <link href="/2020/11/04/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF/"/>
      <url>/2020/11/04/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="生产者丢失消息的情况"><a href="#生产者丢失消息的情况" class="headerlink" title="生产者丢失消息的情况"></a>生产者丢失消息的情况</h3><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p><p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是  Kafka 生产者(Producer) 使用  <code>send</code> 方法发送消息实际上是异步的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p><blockquote><p><strong>详细代码见我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486269&idx=2&sn=ec00417ad641dd8c3d145d74cafa09ce&chksm=cea244f6f9d5cde0c8eb233fcc4cf82e11acd06446719a7af55230649863a3ddd95f78d111de&token=1633957262&lang=zh_CN#rd" target="_blank" rel="noopener">Kafka系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列?</a></strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SendResult&lt;String, Object&gt; sendResult &#x3D; kafkaTemplate.send(topic, o).get();</span><br><span class="line">if (sendResult.getRecordMetadata() !&#x3D; null) &#123;</span><br><span class="line">  logger.info(&quot;生产者成功发送消息到&quot; + sendResult.getProducerRecord().topic() + &quot;-&gt; &quot; + sendRe</span><br><span class="line">              sult.getProducerRecord().value().toString());</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future &#x3D; kafkaTemplate.send(topic, o);</span><br><span class="line">future.addCallback(result -&gt; logger.info(&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">        ex -&gt; logger.error(&quot;生产者发送消失败，原因：&#123;&#125;&quot;, ex.getMessage()));</span><br></pre></td></tr></table></figure><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p><p><strong>另外这里推荐为 Producer 的<code>retries</code>（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你3次一下子就重试完了</strong></p><h3 id="消费者丢失消息的情况"><a href="#消费者丢失消息的情况" class="headerlink" title="消费者丢失消息的情况"></a>消费者丢失消息的情况</h3><p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170e29d648e63e5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="kafka offset"></p><p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p><p><strong>解决办法也比较粗暴，我们手动关闭闭自动提交 offset，每次在真正消费完消息之后之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p><h3 id="Kafka-弄丢了消息"><a href="#Kafka-弄丢了消息" class="headerlink" title="Kafka 弄丢了消息"></a>Kafka 弄丢了消息</h3><p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p><p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p><h4 id="设置-acks-all"><a href="#设置-acks-all" class="headerlink" title="设置 acks = all"></a>设置 acks = all</h4><p>解决办法就是我们设置  <strong>acks = all</strong>。acks 是 Kafka 生产者(Producer)  很重要的一个参数。</p><p>acks 的默认值即为1，代表我们的消息被leader副本接收之后就算被成功发送。当我们配置 <strong>acks = all</strong> 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。</p><h4 id="设置-replication-factor-gt-3"><a href="#设置-replication-factor-gt-3" class="headerlink" title="设置 replication.factor &gt;= 3"></a>设置 replication.factor &gt;= 3</h4><p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;= 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p><h4 id="设置-min-insync-replicas-gt-1"><a href="#设置-min-insync-replicas-gt-1" class="headerlink" title="设置 min.insync.replicas &gt; 1"></a>设置 min.insync.replicas &gt; 1</h4><p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p><p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下加入两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor = min.insync.replicas + 1</strong>。</p><h4 id="设置-unclean-leader-election-enable-false"><a href="#设置-unclean-leader-election-enable-false" class="headerlink" title="设置 unclean.leader.election.enable = false"></a>设置 unclean.leader.election.enable = false</h4><blockquote><p><strong>Kafka 0.11.0.0版本开始 unclean.leader.election.enable 参数的默认值由原来的true 改为false</strong></p></blockquote><p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable = false</strong>  的话，当 leader 副本发生故障时就不会从  follower 副本中和 leader 同步程度达不到要求的副本中选择出  leader ，这样降低了消息丢失的可能性。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="Ack-有哪几种-生产中怎样选择"><a href="#Ack-有哪几种-生产中怎样选择" class="headerlink" title="Ack 有哪几种, 生产中怎样选择?"></a>Ack 有哪几种, 生产中怎样选择?</h4><p>ack=0/1/-1的不同情况：</p><ul><li><p>Ack = 0</p><p>producer不等待broker的ack，broker一接收到还没有写入磁盘就已经返回，当broker故障时有可能丢失数据；</p></li><li><p>Ack = 1</p><p>producer等待broker的ack，partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将会丢失数据；</p></li><li><p>Ack = -1</p><p>producer等待broker的ack，partition的leader和follower全部落盘成功后才返回ack，数据一般不会丢失，延迟时间长但是可靠性高。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka剖析</title>
      <link href="/2020/11/04/kafka%E5%89%96%E6%9E%90/"/>
      <url>/2020/11/04/kafka%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="kafka的架构"><a href="#kafka的架构" class="headerlink" title="kafka的架构"></a>kafka的架构</h3><p><img src="https://user-gold-cdn.xitu.io/2020/1/17/16fb2cd4f1223ab9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>Producer：</strong> 消息生产者，向 Kafka Broker 发消息的客户端。</p><p><strong>Consumer：</strong> 消息消费者，从 Kafka Broker 取消息的客户端。</p><p><strong>Consumer Group：</strong> 多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。</p><p><strong>重平衡</strong>：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。</p><p><strong>Broker：</strong> 一台 Kafka 机器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。</p><p><strong>Topic：</strong> 可以理解为一个队列，topic 将消息分类，生产者和消费者面向的是同一个 topic。</p><p><strong>Partition(分区)：</strong> 为了实现扩展性，提高并发能力，一个非常大的 topic 可以分布到多个 broker （即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个 有序的队列。</p><p><strong>Replica：</strong> 副本，为实现备份的功能，保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 Kafka 仍然能够继续工作，Kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。</p><p><strong>Leader：</strong> 每个分区多个副本的“主”副本，生产者发送数据的对象，以及消费者消费数据的对象，都是 leader。</p><p><strong>Follower：</strong> 每个分区多个副本的“从”副本，实时从 leader 中同步数据，保持和 leader 数据的同步。leader 发生故障时，某个 follower 还会成为新的 leader。</p><p><strong>offset：</strong> 消费者消费的位置信息，监控数据消费到什么位置，当消费者挂掉再重新恢复的时候，可以从消费位置继续消费。</p><p><strong>Zookeeper：</strong> Kafka 集群能够正常工作，需要依赖于 zookeeper，zookeeper 帮助 Kafka 存储和管理集群信息。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Kafka集群将 Record 流存储在称为 topic 的类别中，每个记录由一个键、一个值和一个时间戳组成。<strong>Kafka 是一个分布式流平台</strong>，这到底是什么意思？</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/17/16fb2cd4f14b369d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Kafka 工作流程"></p><p>Kafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，面向的都是同一个 topic。<br> topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文件，该 log 文件中存储的就是 Producer 生产的数据。Producer 生产的数据会不断追加到该 log 文件末端，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自己消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。</p><h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p><img src="https://user-gold-cdn.xitu.io/2020/1/17/16fb2cd4f11f1b55?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Kafka文件存储机制"></p><p>由于生产者生产的消息会不断追加到 log 文件末尾，为防止 log 文件过大导致数据定位效率低下，Kafka 采取了<strong>分片</strong>和<strong>索引</strong>机制，将每个 partition 分为多个 segment，每个 segment 对应两个文件：“.index” 索引文件和 “.log” 数据文件。</p><h3 id="分区原因"><a href="#分区原因" class="headerlink" title="分区原因"></a>分区原因</h3><p>方便在集群中扩展，每个 partition 可以通过调整以适应它所在的机器，而一个 topic 又可以有多个 partition 组成，因此可以以 partition 为单位读写了。</p><h3 id="数据可靠性保证"><a href="#数据可靠性保证" class="headerlink" title="数据可靠性保证"></a>数据可靠性保证</h3><p>为保证 producer 发送的数据，能可靠地发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack（acknowledge 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/20/16fc0ef625f8c1c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h4 id="副本数据同步策略"><a href="#副本数据同步策略" class="headerlink" title="副本数据同步策略"></a>副本数据同步策略</h4><p><strong>（1）何时发送 ack？</strong><br> 确保有 follower 与 leader 同步完成，leader 再发送 ack，这样才能保证 leader 挂掉之后，能在 follower 中选举出新的 leader 而不丢数据。<br> <strong>（2）多少个 follower 同步完成后发送 ack？</strong><br> 全部 follower 同步完成，再发送 ack。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/20/16fc0ef626139ae5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="同步策略方案比较"></p><h4 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h4><p>采用第二种方案，所有 follower 完成同步，producer 才能继续发送数据，设想有一个 follower 因为某种原因出现故障，那 leader 就要一直等到它完成同步。这个问题怎么解决？<br> leader维护了一个动态的 in-sync replica set（ISR）：和 leader 保持同步的 follower 集合。当 ISR 集合中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower 长时间未向 leader 同步数据，则该 follower 将被踢出 ISR 集合，该时间阈值由 replica.lag.time.max.ms 参数设定。leader 发生故障后，就会从 ISR 中选举出新的 leader。</p><h4 id="ack-应答机制"><a href="#ack-应答机制" class="headerlink" title="ack 应答机制"></a>ack 应答机制</h4><p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等 ISR 中的 follower 全部接受成功。<br> 所以 Kafka 为用户提供了三种可靠性级别，用户根据可靠性和延迟的要求进行权衡，选择以下的配置。<br> <strong>（1）ack 参数配置：</strong></p><ul><li>0：producer 不等待 broker 的 ack，这提供了最低延迟，broker 一收到数据还没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据。</li><li>1：producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据。</li><li>-1（all）：producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才返回 ack。但是在 broker 发送 ack 时，leader 发生故障，则会造成数据重复。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/1/20/16fc0ef62659d31e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="acks=-1 造成数据重复分析"></p><h4 id="故障处理细节"><a href="#故障处理细节" class="headerlink" title="故障处理细节"></a>故障处理细节</h4><p><img src="https://user-gold-cdn.xitu.io/2020/1/20/16fc0ef626ae3ed5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Log 文件中的 HW 和 LEO"></p><p>LEO：每个副本最大的 offset。<br> HW：消费者能见到的最大的 offset。</p><p>高水位和 LEO 是副本对象的两个重要属性。Kafka 所有副本都有对应的高水位和 LEO 值，而不仅仅是 Leader 副本。只不过 Leader 副本比较特殊，Kafka 使用 Leader 副本的高水位来定义所在分区的高水位。换句话说，分区的高水位就是其 Leader 副本的高水位。</p><p><strong>（1）Follower 故障</strong><br> follower 发生故障后会被临时踢出 ISR 集合，待该 follower 恢复后，follower 会 读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步数据操作。等该 follower 的 LEO 大于等于该 partition 的 HW，即 follower 追上 leader 后，就可以重新加入 ISR 了。<br><strong>（2）Leader 故障</strong><br> leader 发生故障后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。<br><strong>注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</strong></p><p>作者：臧小晶<br>链接：<a href="https://juejin.im/post/6844904050064883725" target="_blank" rel="noopener">https://juejin.im/post/6844904050064883725</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="kafka的特点"><a href="#kafka的特点" class="headerlink" title="kafka的特点"></a>kafka的特点</h3><p>　　高吞吐量：Kafka 每秒可以生产约 25 万消息（50 MB），每秒处理 55 万消息（110 MB）<br>　　持久化数据存储：可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如 ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication 防止数据丢失。<br>　　分布式系统易于扩展：所有的 producer、broker 和 consumer 都会有多个，均为分布式的。无需停机即可扩展机器。<br>　　客户端状态维护：消息被处理的状态是在 consumer 端维护，而不是由 server 端维护。当失败时能自动平衡。</p><h3 id="Zookeeper在kafka中的作用"><a href="#Zookeeper在kafka中的作用" class="headerlink" title="Zookeeper在kafka中的作用?"></a>Zookeeper在kafka中的作用?</h3><h3 id="kafka基于硬盘为什么这么快"><a href="#kafka基于硬盘为什么这么快" class="headerlink" title="kafka基于硬盘为什么这么快"></a>kafka基于硬盘为什么这么快</h3><h4 id="顺序读写"><a href="#顺序读写" class="headerlink" title="顺序读写"></a>顺序读写</h4><p>众所周知Kafka是将消息记录持久化到本地磁盘中的.Kafka的message是不断追加到本地磁盘文件末尾的，而不是随机的写入，这使得Kafka写入吞吐量得到了显著提升。</p><h4 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h4><p>为了优化读写性能，Kafka利用了操作系统本身的Page Cache</p><ul><li>首先，操作系统层面的缓存利用率会更高，因为存储的都是紧凑的字节结构而不是独立的对象。</li><li>其次，操作系统本身也对于Page Cache做了大量优化，提供了write-behind、read-ahead以及flush等多种机制。再者，即使服务进程重启，系统缓存依然不会消失，避免了in-process cache重建缓存的过程。</li></ul><p>通过操作系统的Page Cache，Kafka的读写操作基本上是基于内存的，读写速度得到了极大的提升。</p><p>就是利用操作系统自身的内存而不是JVM空间内存。这样做的好处有：</p><ul><li>避免Object消耗：如果是使用Java堆，Java对象的内存消耗比较大，通常是所存储数据的两倍甚至更多。</li><li>避免GC问题：随着JVM中数据不断增多，垃圾回收将会变得复杂与缓慢，使用系统缓存就不会存在GC问题。</li></ul><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>这里主要讲的是Kafka利用linux操作系统的 “零拷贝（zero-copy）” 机制在消费端做的优化。首先来了解下数据从文件发送到socket网络连接中的常规传输路径：</p><ul><li>操作系统从磁盘读取数据到内核空间（kernel space）的Page Cache</li><li>应用程序读取Page Cache的数据到用户空间（user space）的缓冲区</li><li>应用程序将用户空间缓冲区的数据写回内核空间到socket缓冲区（socket buffer）</li><li>操作系统将数据从socket缓冲区复制到网络发送的NIC缓冲区</li></ul><p>这个过程包含4次copy操作和2次系统上下文切换，性能其实非常低效。linux操作系统 “零拷贝” 机制使用了sendfile方法，允许操作系统将数据从Page Cache 直接发送到网络，只需要最后一步的copy操作将数据复制到 NIC 缓冲区，这样避免重新复制数据。示意图如下：<br><img src="https://img-blog.csdnimg.cn/20190523181559385.png#pic_center" alt="img"></p><h4 id="分区分段"><a href="#分区分段" class="headerlink" title="分区分段"></a>分区分段</h4><p>Kafka的message是按topic分类存储的，topic中的数据又是按照一个一个的partition即分区存储到不同broker节点。每个partition对应了操作系统上的一个文件夹，partition实际上又是按照segment分段存储的。这也非常符合分布式系统分区分桶的设计思想。</p><p>通过这种分区分段的设计，Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度。</p><h4 id="批量发送"><a href="#批量发送" class="headerlink" title="批量发送"></a>批量发送</h4><p>Kafka允许进行批量发送消息，先将消息缓存在内存中，然后一次请求批量发送出去<br>比如可以指定缓存的消息达到某个量的时候就发出去，或者缓存了固定的时间后就发送出去</p><h3 id="和其他消息中间件的对比"><a href="#和其他消息中间件的对比" class="headerlink" title="和其他消息中间件的对比"></a>和其他消息中间件的对比</h3><p>吞吐量：10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景  RabbitMQ比kafka低一个级别</p><p>可用性：  非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</p><p>RabbitMQ基于主从架构实现高可用</p><p>可靠性：  经过参数优化配置，可以做到 0 丢失</p><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis的主从复制</title>
      <link href="/2020/11/03/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2020/11/03/redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="同步操作（PSYNC命令）"><a href="#同步操作（PSYNC命令）" class="headerlink" title="同步操作（PSYNC命令）"></a>同步操作（PSYNC命令）</h2><p><strong>PSYNC命令具有完整重同步（full resy nchronization）和部分重同步（partial resynchronization）两种模式：</strong></p><ul><li><strong>完整重同步：</strong>用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步 骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓 冲区里面的写命令来进行同步</li><li><strong>部分重同步：</strong>则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器 时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务 器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li></ul><h2 id="完整重同步"><a href="#完整重同步" class="headerlink" title="完整重同步"></a>完整重同步</h2><ul><li><p><strong>概念：</strong>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，<strong>将从服务器的数据库状态更新至主服务器当前所处的数据库状态</strong></p></li><li><p><strong>SYNC命令：</strong></p><p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：</p><ul><li>①从服务器向主服务器<strong>发送SYNC命令</strong></li><li>②收到SYNC命令的主服务器<strong>执行BGSAVE命令，在后台生成一个RDB文件</strong>，并使用一 个缓冲区记录从现在开始执行的所有写命令</li><li>③当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的<strong>RDB文件发送给从服务器</strong>，从服务器<strong>接收并载入</strong>这个RDB文件，将自己的数据库状态更新至主服务器 执行BGSAVE命令时的数据库状态</li><li>④主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写 命令，将自己的数据库状态更新至主服务器数据库当前所处的状态</li></ul></li><li><p>下图展示了SYNC命令执行期间，主从服务器的通信过程：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20191201105150863.png" alt="img"></p><blockquote><h3 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h3><ul><li>下表展示了一个主从服务器进行同步的例子</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201105237782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><h2 id="部分重同步的实现细节"><a href="#部分重同步的实现细节" class="headerlink" title="部分重同步的实现细节"></a>部分重同步的实现细节</h2><ul><li><strong>同步功能由以下三个部分构成：</strong><ul><li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区（replication backlog）</li><li>服务器的运行ID（run ID）</li></ul></li></ul><blockquote><h3 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h3><ul><li><p>执行复制的双方——主服务器和从服务器会</p><p><strong>分别维护一个复制偏移量：</strong></p><ul><li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li><li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li></ul></li><li><p>通过对比主从服务器的复制偏移量，</p><p><strong>程序可以很容易地知道主从服务器是否处于一致状态：</strong></p><ul><li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li><li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态</li></ul></li><li><p>在下图所示的例子中，主从服务器的复制偏移量的值都为10086</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121350757.png" alt="img"></p><ul><li>如果这时主服务器向三个从服务器传播长度为33字节的数据，那么主服务器的复制偏移量将更新为10086+33=10119，而三个从服务器在接收到主服务器传播的数据之后，也会将复制偏移量更新为10119，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121359413.png" alt="img"></p><h3 id="网络断开重连后的复制偏移量"><a href="#网络断开重连后的复制偏移量" class="headerlink" title="网络断开重连后的复制偏移量"></a>网络断开重连后的复制偏移量</h3><ul><li>考虑以下这个例子：假设如上面的图片所示，主从服务器当前的复制偏移量都为10086，但是就在主服务器要向从服务器传播长度为33字节的数据之前，从<strong>服务器A断线</strong>了，那么主服务 器传播的数据将只有从服务器B和从服务器C能收到，在这之后，主服务器、从服务器B和从 服务器C三个服务器的复制偏移量都将更新为10119，而断线的从服务器A的复制偏移量仍然停留在10086，这说明从服务器A与主服务器并不一致，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121522212.png" alt="img"></p><ul><li>假设从服务器A在断线之后就立即重新连接主服务器，并且成功，那么接下来，从服务器将向主服务器发送PSYNC命令，报告从服务器A当前的复制偏移量为10086，那么这时， <strong>主服务器应该对从服务器执行完整重同步还是部分重同步呢？</strong>如果执行部分重同步的话，主 服务器又如何补偿从服务器A在断线期间丢失的那部分数据呢？<strong>以上问题的答案都和复制积压缓冲区有关</strong></li></ul></blockquote><blockquote><h3 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h3><ul><li>复制积压缓冲区是由主服务器维护的一个<strong>固定长度（fixed-size）先进先出（FIFO）队列</strong>，默认大小为1MB</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121735717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会<strong>将写命令入队到复制积压缓冲区里面</strong>，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121909779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会<strong>为队列中的每个字节记录相应的复制偏移量</strong>，就像下表展示的那样</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121943503.png" alt="img"></p><ul><li><p>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令</p><p><strong>将自己的复制偏移量offset发送给主服务器</strong></p><p>，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操 作：</p><ul><li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）<strong>仍然存在于复制积压缓冲区里面</strong>，那么主服务器将对从服务器执行部分重同步操作</li><li>相反，如果offset偏移量之后的数据<strong>已经不存在于复制积压缓冲区</strong>，那么主服务器将对从服务器执行完整重同步操作</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/2019120112234757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong><em>\</em>演示案例：**</strong></p><ul><li>回到之前上面图片所展示的断线后重连接例子：</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201121522212.png" alt="img"></p><ul><li>当从服务器A断线之后，它立即重新连接主服务器，并<strong>向主服务器发送PSYNC命令，报告自己的复制偏移量为10086</strong></li><li>主服务器收到从服务器发来的PSYNC命令以及偏移量10086之后，主服务器将<strong>检查偏移量10086之后的数据是否存在于复制积压缓冲区里面</strong>，结果发现<strong>这些数据仍然存在</strong>，于是主服务器向从服务器发送+CONTINUE回复，表示数据同步将以部分重同步模式来进行</li><li>接着主服务器会将复制积压缓冲区10086偏移量之后的<strong>所有数据（偏移量为10087至 10119）都发送给从服务器</strong></li><li>从服务器只要接收这33字节的缺失数据，就可以回到与主服务器一致的状态，如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/20191201122209306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><blockquote><h3 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h3><ul><li><p>除了复制偏移量和复制积压缓冲区之外，</p><p><strong>实现部分重同步还需要用到服务器运行ID（run ID）：</strong></p><ul><li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID</li><li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3</li></ul></li><li><p>当从服务器对主服务器<strong>进行初次复制时</strong>，主服务器会<strong>将自己的运行ID传送给从服务器</strong>， 而从服务器则会将<strong>这个运行ID保存起来</strong></p></li><li><p>当从服务器断线并重新连上一个主服务器时，</p><p><strong>从服务器将向当前连接的主服务器发送之前保存的运行ID：</strong></p><ul><li>如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID相同</strong>，那么说明从服务器 断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操 作</li><li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的<strong>运行ID并不相同</strong>，那么 说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服 务器执行完整重同步操作</li></ul></li><li><p>举个例子，假设从服务器原本正在复制一个运行ID为 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3的主服务器，那么在网络断开，从服务器重新连 接上主服务器之后，从服务器将向主服务器发送这个运行ID，主服务器根据自己的运行ID是 否53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3来判断是执行部分重同步还是执行完整重同步</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis集群</title>
      <link href="/2020/11/03/redis%E9%9B%86%E7%BE%A4/"/>
      <url>/2020/11/03/redis%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h3><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑<strong>读高并发</strong>的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的<strong>读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20200115180329317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="redis-master-slave"></p><p><strong>主节点和从节点数据同步，也就复制的问题</strong></p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>消息通知：实例故障了通知管理员和客户端新的地址</p><p>故障发现</p><p>故障转移</p><h4 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h4><h5 id="一、检测主观下线状态"><a href="#一、检测主观下线状态" class="headerlink" title="一、检测主观下线状态"></a>一、检测主观下线状态</h5><ul><li>在默认情况下，Sentinel会<strong>以每秒一次的频率</strong>向所有与它创建了命令连接的实例（<strong>包括主服务器、从服务器、其他Sentinel在内</strong>）发送<strong>PING命令</strong>，并通过实例返回的PING命令回复来判断实例是否在线</li></ul><h5 id="二、检测客观下线状态"><a href="#二、检测客观下线状态" class="headerlink" title="二、检测客观下线状态"></a>二、检测客观下线状态</h5><ul><li>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线 了，它会<strong>向同样监视这一主服务器的其他Sentinel进行询问</strong>，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。当Sentinel从其他Sentinel那里<strong>接收到足够数量的已下线判断之后</strong>，Sentinel就会将从服务器判定为客观下线，并对主服务器<strong>执行故障转移操作</strong></li></ul><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的<strong>各个Sentinel会进行协商</strong>，选举出一个领头Sentinel，当某个sentinel被半数以上的sentinel设置成为领头sentinel，那么这个sentinel称为领头sentinel并由领头Sentinel<strong>对下线主服务器执行故障转移操作</strong>(raft)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Raft算法</span><br></pre></td></tr></table></figure><h4 id="故障自动转移"><a href="#故障自动转移" class="headerlink" title="故障自动转移"></a>故障自动转移</h4><p>领头的sentinel负责故障转移<br>从从服务器列表中选择一个节点作为新节点</p><p>1 过滤掉：下线、5s内没有回应InFO、与主服务器失联超过down-after-milliseconds的从服务器<br>2 选择从服务器中优先级最高的。若具有多个同样优先级的，则继续<br>3 选择复制偏移量最大的从节点。若具有多个复制偏移量相同的，则继续<br>4 选择 run id最小的从服务器</p><p>sentinel会对1中选出的从服务器发送slaveof no one使其成为主服务器<br>sentinel向其余从服务器发送命令，让他们成为新主服务器的从服务器，并同步数据<br>sentinel会关注刚刚下线的主服务器，并让它成为从服务器，当它恢复的时候就去同步数据</p><h3 id="官方Redis-Cluster-方案-服务端路由查询"><a href="#官方Redis-Cluster-方案-服务端路由查询" class="headerlink" title="官方Redis Cluster 方案(服务端路由查询)"></a>官方Redis Cluster 方案(服务端路由查询)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.主从复制不能实现高可用</span><br><span class="line">2.随着公司发展，用户数量增多，并发越来越多，业务需要更高的QPS，而主从复制中单机的QPS可能无法满足业务需求</span><br><span class="line">3.数据量的考虑，现有服务器内存不能满足业务数据的需要时，单纯向服务器添加内存不能达到要求，此时需要考虑分布式需求，把数据分布到不同服务器上</span><br></pre></td></tr></table></figure><p>redis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</p><p>那么redis 是如何合理分配这些节点和数据的呢？</p><p>Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做<code>哈希槽 (hash slot)</code>的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用<code>CRC16</code>算法来取模得到所属的<code>slot</code>，然后将这个key 分到哈希槽区间的节点上，具体算法就是：<code>CRC16(key) % 16384</code>。</p><ul><li><strong>Redis集群采用P2P的Gossip（流言）协议，</strong> Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播，如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200806112902246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><strong>通信过程说明：</strong><ul><li>1）集群中的每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口上加10000</li><li>2）每个节点在固定周期内通过特定规则选择几个节点发送ping消息</li><li>3）接收到ping消息的节点用pong消息作为响应</li></ul></li><li>集群中每个节点通过一定规则挑选要通信的节点，每个节点可能知道全部节点，也可能仅知道部分节点，<strong>只要这些节点彼此可以正常通信，最终它们会达到一致的状态</strong>。当节点出故障、新节点加入、主从角色变化、槽信息 变更等事件发生时，通过不断的ping/pong消息通信，经过一段时间后<strong>所有的节点都会知道整个集群全部节点的最新状态，从而达到集群状态同步的目的</strong></li></ul><blockquote><h3 id="Gossip消息"><a href="#Gossip消息" class="headerlink" title="Gossip消息"></a>Gossip消息</h3><ul><li>Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息，了解这些消息<strong>有助于我们理解集群如何完成信息交换</strong></li><li><strong>常用的Gossip消息可分为：</strong><ul><li><strong>meet消息：</strong>用于通知新节点加入。消息发送者通知接收者加入到当前 集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong消息交换</li><li><strong>ping消息：</strong>集群内交换最频繁的消息，集群内每个节点每秒向多个其 他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消 息发送封装了自身节点和部分其他节点的状态数据。</li><li><strong>pong消息：</strong>当接收到ping、meet消息时，作为响应消息回复给发送方确 认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内 广播自身的pong消息来通知整个集群对自身状态进行更新</li><li><strong>fail消息：</strong>当节点判定集群内另一个节点下线时，会向集群内广播一个 fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。具体细节将在后面的“故障转移”文章中说明</li></ul></li><li><strong>它们的通信模式如下图所示：</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20200531152212286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><h3 id="MOVED重定向"><a href="#MOVED重定向" class="headerlink" title="MOVED重定向"></a>MOVED重定向</h3><ul><li><strong>概念：</strong>在集群模式下，bRedis接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；否则回复MOVED重定向错误，通知客户端请求正确的节点。如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/20200531231926655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><h3 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h3><ul><li>Redis集群支持<strong>在线迁移槽（slot）和数据来完成水平伸缩</strong>，当slot对应的数据从源节点到目标节点迁移过程中，客户端需要做到智能识别，保证键命令可正常执行。例如当一个slot数据从源节点迁移到目标节点时，期间可能出现一部分数据在源节点，而另一部分在目标节点，如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/20200806113128921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><strong>当出现上述情况时，客户端键命令执行流程将发生变化，如下所示：</strong><ul><li>1）客户端根据本地slots缓存发送命令到源节点，如果存在键对象则直接执行并返回结果给客户端</li><li>2）如果键对象不存在，则可能存在于目标节点，这时源节点会回复ASK重定向异常。格式如下：(error) ASK {slot} {targetIP}:{targetPort}</li><li>3）客户端从ASK重定向异常提取出目标节点信息，发送asking命令到目标节点打开客户端连接标识，再执行键命令。如果存在则执行，不存在则返回不存在信息</li></ul></li><li><strong>ASK重定向整体流程如下图所示：</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20200806113146529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><ul><li><strong>ASK与MOVED虽然都是对客户端的重定向控制，但是有着本质区别：</strong><ul><li>ASK重定向说明集群正在进行slot数据迁移，<strong>客户端无法知道什么时候迁移完成，因此只能是临时性的重定向</strong>，客户端不会更新slots缓存</li><li>但是MOVED重定向说明键<strong>对应的槽已经明确指定到新的节点</strong>，因此需要更新slots缓存</li></ul></li></ul><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><ul><li><strong>Redis集群自身实现了高可用。高可用首先需要解决集群部分失败的场景：</strong>当集群内少量节点出现故障时通过自动故障转移保证集群可以正常对外提供服务。本文介绍故障转移的细节，分析故障发现和替换故障节点的过程</li></ul><blockquote><h3 id="故障发现-1"><a href="#故障发现-1" class="headerlink" title="故障发现"></a>故障发现</h3><ul><li>当集群内某个节点出现问题时，需要通过一种健壮的方式保证<strong><em>\</em>识别出节点是否发生了故障**</strong></li><li><strong>因此故障发现也是通过消息传播机制实现的，主要环节包括：</strong><ul><li><strong>主观下线 （pfail）：</strong>指某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况</li><li><strong>客观下线（fail）：</strong>指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移</li></ul></li></ul></blockquote><blockquote><h3 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h3><ul><li>集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong消息作为响应。<strong>如果在cluster-node-timeout时间内通信一直失败，则发送节点会\</strong>认为接收节点存在故障*<strong>*，把接收节点标记为</strong>主观下线（pfail）状态**</li></ul><h3 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a><strong>客观下线</strong></h3><ul><li><p>当某个节点判断另一个节点主观下线后，相应的<strong><em>\</em>节点状态会跟随消息在集群内传播**</strong></p></li><li><p>通过Gossip消息传播，集群内节点不断收集到故障节点的下线报告。<strong>当半数以上持有槽的主节点都标记某个节点是主观下线时。触发客观下线流程</strong></p></li><li><p>假设节点a标记节点b为主观下线，</p><p><strong>一段时间后节点a通过消息把节点b的状态发送到其他节点，当节点c接受到消息并解析出消息体含有节点b的pfail状态时，会触发客观下线流程</strong></p><p>，如下图所示：</p><ul><li>1）当消息体内含有其他节点的pfail状态会判断发送节点的状态，<strong>如果发送节点是主节点则对报告的pfail状态处理，从节点则忽略</strong></li><li>2）找到pfail对应的节点结构，更新clusterNode内部下线报告链表</li><li>3）根据更新后的下线报告链表告尝试进行客观下线</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200601000227906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p></blockquote><blockquote><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><ul><li>故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要<strong>在它的从节点中选出一个替换它，从而保证集群的高可用</strong></li><li>下线主节点的所有从节点承担故障恢复的义务，当从节点通过内部定时任务发现自身复制的主节点进入客观下线时，将会<strong><em>\</em>触发故障恢复流程，**</strong>如下图所示：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200806113530768.png" alt="img"></p><h3 id="资格检查"><a href="#资格检查" class="headerlink" title="资格检查"></a>资格检查</h3><ul><li>每个从节点都要检查最后与主节点断线时间<strong>，判断是否有资格替换故障的主节点</strong></li><li>如果从节点与主节点断线时间<strong>超过cluster-node-time*cluster-slavevalidity-factor，**</strong>则当前从节点不具备故障转移资格**。参数cluster-slavevalidity-factor用于从节点的有效因子，默认为10</li></ul><h3 id="准备选举时间"><a href="#准备选举时间" class="headerlink" title="准备选举时间"></a>准备选举时间</h3><ul><li>当从节点符合故障转移资格后，<strong>更新触发故障选举的时间，只有到达该时间后才能执行后续流程</strong></li></ul><h3 id="发起选举"><a href="#发起选举" class="headerlink" title="发起选举"></a>发起选举</h3><ul><li><p>当从节点定时任务</p><p><strong>检测到达故障选举时间（failover_auth_time）到达后，发起选举流程如下：</strong></p><ul><li><strong>（1）更新配置纪元：</strong>配置纪元是一个只增不减的整数，每个主节点自身维护一个配置纪元标示当前主节点的版本，所有主节点的配置纪元都不相等，从节点会复制主节点的配置纪元，整个集群又维护一个全局的配置纪元，用于记录集群内所有主节点配置纪元的最大版本。<strong>从节点每次发起投票时都会自增集群的全局配置纪元</strong></li><li><strong>（2）广播选举消息：</strong>在集群内广播选举消息（FAILOVER_AUTH_REQUEST），并记录已发送过消息的状态，保证该从节点在一个配置纪元内只能发起一次选举</li></ul></li></ul><h3 id="选举投票"><a href="#选举投票" class="headerlink" title="选举投票"></a>选举投票</h3><ul><li><strong>只有持有槽的主节点才会处理故障选举消息</strong>，因为每个持有槽的节点在一个配置纪元内都有唯一的一张选票，当接到第一个请求投票的从节点消息时回复FAILOVER_AUTH_ACK消息作为投票，之后相同配置纪元内其他从节点的 选举消息将忽略</li><li><strong><em>\</em>投票过程其实是一个领导者选举的过程\</strong>，**如集群内有N个持有槽的主节点代表有N张选票。由于在每个配置纪元内持有槽的主节点只能投票给一个 从节点，因此只能有一个从节点获得N/2+1的选票，保证能够找出唯一的从节点</li><li><strong>Redis集群没有直接使用从节点进行领导者选举，</strong>主要因为从节点数必须大于等于3个才能保证凑够N/2+1个节点，将导致从节点资源浪费。使用 集群内所有持有槽的主节点进行领导者选举，即使只有一个从节点也可以完 成选举过程</li><li><strong>当从节点收集到N/2+1个持有槽的主节点投票时，从节点可以执行替换主节点操作</strong>，例如集群内有5个持有槽的主节点，主节点b故障后还有4个， 当其中一个从节点收集到3张投票时代表获得了足够的选票可以进行替换主 节点操作，如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/20200601194700684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="替换主节点"><a href="#替换主节点" class="headerlink" title="替换主节点"></a>替换主节点</h3><ul><li><strong>当从节点收集到足够的选票之后，触发替换主节点操作：</strong><ul><li>1）当前从节点<strong>取消复制变为主节点</strong></li><li>2）执行clusterDelSlot操作<strong>撤销故障主节点负责的槽</strong>，并执行clusterAddSlot把这些槽委派给自己</li><li><strong>3）向集群广播自己的pong消息，</strong>通知集群内所有的节点当前从节点变为主节点并接管了故障主节点的槽信息</li></ul></li></ul></blockquote><h3 id="基于客户端分配"><a href="#基于客户端分配" class="headerlink" title="基于客户端分配"></a>基于客户端分配</h3><p><img src="https://img-blog.csdnimg.cn/20200115173640248.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>简介</strong></p><p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool</p><p><strong>优点</strong></p><p>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</p><p><strong>缺点</strong></p><ul><li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li><li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</li></ul><h3 id="基于代理服务器分片"><a href="#基于代理服务器分片" class="headerlink" title="基于代理服务器分片"></a>基于代理服务器分片</h3><p><img src="https://img-blog.csdnimg.cn/20200115173630730.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>简介</strong></p><p>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端</p><p><strong>特征</strong></p><ul><li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li><li>Proxy 的逻辑和存储的逻辑是隔离的</li><li>代理层多了一次转发，性能有所损耗</li></ul><p><strong>业界开源方案</strong></p><ul><li>Twtter开源的Twemproxy</li><li>豌豆荚开源的Codis</li></ul><h3 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h3><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将<br>该数据分配的节点序号为：hash(key)%N。<br>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，<br>将导致大量的数据迁移。</p><h4 id="顺序分布"><a href="#顺序分布" class="headerlink" title="顺序分布"></a>顺序分布</h4><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用<br>顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。<br>顺序分布相比于哈希分布的主要优点如下：</p><ul><li>能保持数据原有的顺序；</li><li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li></ul><h4 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h4><p>将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值<br>之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p><p><img src="/2020/11/03/redis%E9%9B%86%E7%BE%A4/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201106202450535.png" alt="image-20201106202450535"></p><p>虚拟节点</p><p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。<br>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。<br>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节<br>点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双写问题和延时双删</title>
      <link href="/2020/11/02/%E5%8F%8C%E5%86%99%E9%97%AE%E9%A2%98%E5%92%8C%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0/"/>
      <url>/2020/11/02/%E5%8F%8C%E5%86%99%E9%97%AE%E9%A2%98%E5%92%8C%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>我们讨论<strong>两种</strong>更新策略：</p><ul><li>1.先删除缓存，再更新数据库</li><li>2.先更新数据库，再删除缓存</li></ul><h3 id="先更新DB再删除缓存"><a href="#先更新DB再删除缓存" class="headerlink" title="先更新DB再删除缓存"></a>先更新DB再删除缓存</h3><p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href="https://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">《Cache-Aside pattern》</a>。其中就指出</p><ol><li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li><li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li></ol><p><strong>这种情况不存在并发问题么？</strong></p><p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p><p>（1）缓存刚好失效</p><p>（2）请求A查询数据库，得一个旧值</p><p>（3）请求B将新值写入数据库</p><p>（4）请求B删除缓存</p><p>（5）请求A将查到的旧值写入缓存 ok，如果发生上述情况，确实是会发生脏数据。</p><p><strong>然而，发生这种情况的概率又有多少呢？</strong></p><p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。</p><p>可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。 假设，有人非要抬杠，有强迫症，一定要解决怎么办？</p><p>如何解决上述并发问题？</p><p>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。<br><strong>还有其他造成不一致的原因么？</strong><br>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。</p><ol><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事务的实现原理</title>
      <link href="/2020/11/02/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2020/11/02/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>相信大家都用过事务以及了解他的特点，如原子性(Atomicity),一致性(Consistency),隔离型(Isolation)以及持久性(Durability)等。今天想跟大家一起研究下事务内部到底是怎么实现的，在讲解前我想先抛出个问题：<br><strong>事务想要做到什么效果？</strong></p><p>按我理解，无非是要做到<strong>可靠性</strong>以及<strong>并发处理</strong></p><p>可靠性：数据库要保证当insert或update操作时抛异常或者数据库crash的时候需要保障数据的操作前后的一致，想要做到这个，我需要知道我修改之前和修改之后的状态，所以就有了undo log和redo log。</p><p>并发处理：也就是说当多个并发请求过来，并且其中有一个请求是对数据修改操作的时候会有影响，为了避免读到脏数据，所以需要对事务之间的读写进行隔离，至于隔离到啥程度得看业务系统的场景了，实现这个就得用MySQL 的隔离级别。</p><p>下面我首先讲实现事务功能的三个技术，分别是日志文件(redo log 和 undo log)，锁技术以及MVCC，然后再讲事务的实现原理，包括原子性是怎么实现的，隔离型是怎么实现的等等。最后在做一个总结，希望大家能够耐心看完</p><ul><li>redo log与undo log介绍</li><li>mysql锁技术以及MVCC基础</li><li>事务的实现原理</li><li>总结</li></ul><hr><h3 id="二、-redo-log-与-undo-log介绍"><a href="#二、-redo-log-与-undo-log介绍" class="headerlink" title="二、 redo log 与 undo log介绍"></a>二、 redo log 与 undo log介绍</h3><h4 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1. redo log"></a>1. redo log</h4><p><strong>什么是redo log ?</strong></p><p>redo log叫做<strong>重做</strong>日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当<strong>事务提交之后</strong>会把所有修改信息都会存到该日志中。当数据发生修改时，InnoDB不仅会修改Buffer Pool中的数据，也会在redo log buffer记录这次操作；当事务提交时，会对redo log buffer进行刷盘，记录到redo log file中(WAL)。如果MySQL宕机，重启时可以读取redo log file中的数据，对数据库进行恢复。这样就不需要每次提交事务都实时进行刷脏了</p><p>假设有个表叫做tb1(id,username) 现在要插入数据（3，ceshi）</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2ff3e4c3b8b46?w=2368&h=788&f=png&s=226339" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select balance from bank where name&#x3D;&quot;zhangsan&quot;;</span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 balance&#x3D;600</span><br><span class="line">update bank set balance &#x3D; balance - 400; </span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 amount&#x3D;400</span><br><span class="line">update finance set amount &#x3D; amount + 400;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h3 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h3><p><img src="https://img-blog.csdnimg.cn/20201030172624806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzMTQ2Nzk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>注意点：</p><ul><li>先修改Buffer Pool，后写 redo log buffer。</li><li>redo日志比数据页先写回磁盘：事务提交的时候，会把redo log buffer写入redo log file，写入成功才算提交成功（也有其他场景触发写入，这里就不展开了），而Buffer Pool的数据由后台线程在后续某个时刻写入磁盘。</li><li>刷脏的时候一定会保证对应的redo log已经落盘了，也即是所谓的WAL（预写式日志），否则会有数据丢失的可能性。</li></ul><h4 id="2-undo-log"><a href="#2-undo-log" class="headerlink" title="2.undo log"></a>2.undo log</h4><p><strong>什么是 undo log ？</strong></p><p>undo log 叫做回滚日志，用于记录数据<strong>被修改前</strong>的信息。他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p><p>还用上面那两张表</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe552145e2c1?w=4652&h=1848&f=png&s=867671" alt="img"></p><p>每次写入数据或者修改数据之前都会把修改前的信息记录到 undo log。</p><p><strong>undo log 有什么作用？</strong></p><p>undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。</p><p>总结：<br>undo log是用来回滚数据的用于保障 未提交事务的原子性</p><hr><h3 id="三、mysql锁技术以及MVCC基础"><a href="#三、mysql锁技术以及MVCC基础" class="headerlink" title="三、mysql锁技术以及MVCC基础"></a>三、mysql锁技术以及MVCC基础</h3><h4 id="1-mysql锁技术"><a href="#1-mysql锁技术" class="headerlink" title="1. mysql锁技术"></a>1. mysql锁技术</h4><p>当有多个请求来读取表中的数据时可以不采取任何操作，但是多个请求里有读请求，又有修改请求时必须有一种措施来进行并发控制。不然很有可能会造成不一致。<br><strong>读写锁</strong><br>解决上述问题很简单，只需用两种锁的组合来对读写请求进行控制即可，这两种锁被称为：</p><p>共享锁(shared lock),又叫做”读锁”<br>读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。</p><p>排他锁(exclusive lock),又叫做”写锁”<br>写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a27696def80b5f?w=416&h=183&f=png&s=16219" alt="img"></p><p>总结：<br>通过读写锁，可以做到读读可以并行，但是不能做到写读，写写并行<br>事务的隔离性就是根据读写锁来实现的！！！这个后面再说。</p><h4 id="2-MVCC基础"><a href="#2-MVCC基础" class="headerlink" title="2. MVCC基础"></a>2. MVCC基础</h4><p>MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。</p><blockquote><p>InnoDB的 MVCC ，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，<br>一个保存了行的创建时间，一个保存了行的过期时间，<br>当然存储的并不是实际的时间值，而是系统版本号。</p></blockquote><p>以上片段摘自《高性能Mysql》这本书对MVCC的定义。他的主要实现思想是通过<strong>数据多版本</strong>来做到<strong>读写分离</strong>。从而实现不加锁读进而做到读写并行。</p><p><strong>MVCC在mysql中的实现依赖的是undo log与read view</strong></p><ul><li>undo log :undo log 中记录某行数据的多个版本的数据。</li><li>read view :用来判断当前版本数据的可见性</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f5e3c3950ca1?w=3612&h=1512&f=png&s=816439" alt="img"></p><hr><h3 id="四、事务的实现"><a href="#四、事务的实现" class="headerlink" title="四、事务的实现"></a>四、事务的实现</h3><p>前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。</p><ul><li>事务的原子性是通过 undo log 来实现的</li><li>事务的持久性性是通过 redo log 来实现的</li><li>事务的隔离性是通过 (读写锁+MVCC)来实现的</li><li>而事务的终极大 boss <strong>一致性</strong>是通过原子性，持久性，隔离性来实现的！！！</li></ul><p><strong>原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！</strong></p><p>总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。</p><h4 id="1-原子性的实现"><a href="#1-原子性的实现" class="headerlink" title="1.原子性的实现"></a>1.原子性的实现</h4><p>什么是原子性：</p><p>一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。</p><p>上面这段话取自《高性能MySQL》这本书对原子性的定义，原子性可以概括为就是要实现要么全部失败，要么全部成功。</p><p>以上概念相信大家伙儿都了解，那么数据库是怎么实现的呢？ 就是通过<strong>回滚</strong>操作。<br>所谓回滚操作就是当发生错误异常或者显式的执行rollback语句时需要把数据还原到原先的模样，所以这时候就需要用到undo log来进行回滚，接下来看一下undo log在实现事务原子性时怎么发挥作用的</p><h5 id="1-1-undo-log-的生成"><a href="#1-1-undo-log-的生成" class="headerlink" title="1.1 undo log 的生成"></a>1.1 undo log 的生成</h5><p>假设有两个表 bank和finance，表中原始数据如图所示，当进行插入，删除以及更新操作时生成的undo log如下面图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe331bab111c?w=4652&h=1848&f=png&s=867671" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe2457ff3820?w=1904&h=744&f=png&s=319469" alt="img"></p><p>从上图可以了解到数据的变更都伴随着回滚日志的产生：<br>(1) 产生了被修改前数据(zhangsan,1000) 的回滚日志</p><p>(2) 产生了被修改前数据(zhangsan,0) 的回滚日志</p><p>根据上面流程可以得出如下结论：<br><strong>1.每条数据变更(insert/update/delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上</strong><br><strong>2.所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</strong></p><p>思考：为什么先写日志后写数据库？ —稍后做解释</p><h5 id="1-2-根据undo-log-进行回滚"><a href="#1-2-根据undo-log-进行回滚" class="headerlink" title="1.2 根据undo log 进行回滚"></a>1.2 根据undo log 进行回滚</h5><p>为了做到同时成功或者失败，当系统发生错误或者执行rollback操作时需要根据undo log 进行回滚</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fece4894a8a8?w=3748&h=1100&f=png&s=475112" alt="img"></p><p>回滚操作就是要还原到原来的状态，undo log记录了数据被修改前的信息以及新增和被删除的数据信息，根据undo log生成回滚语句，比如：</p><p>(1) 如果在回滚日志里有新增数据记录，则生成删除该条的语句</p><p>(2) 如果在回滚日志里有删除数据记录，则生成生成该条的语句</p><p>(3) 如果在回滚日志里有修改数据记录，则生成修改到原先数据的语句</p><h4 id="2-持久性的实现"><a href="#2-持久性的实现" class="headerlink" title="2.持久性的实现"></a>2.持久性的实现</h4><p>事务一旦提交，其所作做的修改会永久保存到数据库中，此时即使系统崩溃修改的数据也不会丢失。</p><p>先了解一下MySQL的数据存储机制，MySQL的表数据是存放在磁盘上的，因此想要存取的时候都要经历磁盘IO,然而即使是使用SSD磁盘IO也是非常消耗性能的。<br>为此，为了提升性能InnoDB提供了缓冲池(Buffer Pool)，Buffer Pool中包含了磁盘数据页的映射，可以当做缓存来使用：<br><strong>读数据</strong>：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取在放入缓冲池；<br><strong>写数据</strong>：会首先写入缓冲池，缓冲池中的数据会定期同步到磁盘中；</p><p>上面这种缓冲池的措施虽然在性能方面带来了质的飞跃，但是它也带来了新的问题，当MySQL系统宕机，断电的时候可能会丢数据！！！</p><p>因为我们的数据已经提交了，但此时是在缓冲池里头，还没来得及在磁盘持久化，所以我们急需一种机制需要存一下已提交事务的数据，为恢复数据使用。</p><p>于是 redo log就派上用场了。下面看下redo log是什么时候产生的</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a26f9acf011739?w=994&h=373&f=png&s=120202" alt="img"></p><p>既然redo log也需要存储，也涉及磁盘IO为啥还用它？</p><p>（1）redo log 的存储是顺序存储，而缓存同步是随机操作。</p><p>（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。</p><hr><h4 id="3-隔离性实现"><a href="#3-隔离性实现" class="headerlink" title="3.隔离性实现"></a>3.隔离性实现</h4><p>隔离性是事务ACID特性里最复杂的一个。在SQL标准里定义了四种隔离级别，每一种级别都规定一个事务中的修改，哪些是事务之间可见的，哪些是不可见的。</p><p>级别越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。</p><p>Mysql 隔离级别有以下四种（级别由低到高）：</p><ul><li><strong>READ UNCOMMITED</strong> (未提交读)</li><li><strong>READ COMMITED</strong> (提交读)</li><li><strong>REPEATABLE READ</strong> (可重复读)</li><li><strong>SERIALIZABLE</strong> (可重复读)</li></ul><p>只要彻底理解了隔离级别以及他的实现原理就相当于理解了ACID里的隔离型。前面说过原子性，隔离性，持久性的目的都是为了要做到一致性，但隔离型跟其他两个有所区别，原子性和持久性是为了要实现数据的可性保障靠，比如要做到宕机后的恢复，以及错误后的回滚。</p><p>那么隔离性是要做到什么呢？ <strong>隔离性是要管理多个并发读写请求的访问顺序。</strong> 这种顺序包括<strong>串行</strong>或者是<strong>并行</strong><br>说明一点，写请求不仅仅是指insert操作，又包括update操作。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2c1c8b5285ee3?w=688&h=233&f=png&s=40492" alt="img"></p><p>总之，从隔离性的实现可以看出这是一场数据的可靠性与性能之间的权衡。</p><ul><li>可靠性性高的，并发性能低(比如 Serializable)</li><li>可靠性低的，并发性能高(比如 Read Uncommited)</li></ul><p><strong>READ UNCOMMITTED</strong></p><p>在READ UNCOMMITTED隔离级别下，事务中的修改即使还没提交，对其他事务是可见的。事务可以读取未提交的数据，造成脏读。</p><p>因为读不会加任何锁，所以写操作在读的过程中修改数据，所以会造成脏读。好处是可以提升并发处理性能，能做到<strong>读写并行</strong>。</p><p>换句话说，读的操作不能排斥写请求。<br><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2ed4dbd348a68?w=4284&h=1288&f=png&s=731191" alt="img"></p><p>优点：读写并行，性能高<br>缺点：造成脏读</p><p><strong>READ COMMITTED</strong></p><p>一个事务的修改在他提交之前的所有修改，对其他事务都是不可见的。其他事务能读到已提交的修改变化。在很多场景下这种逻辑是可以接受的。</p><p>InnoDB在 READ COMMITTED，使用排它锁,读取数据不加锁而是使用了MVCC机制。或者换句话说他采用了<strong>读写分离机制</strong>。<br>但是该级别会产生<strong>不可重读</strong>以及<strong>幻读</strong>问题。</p><blockquote><p>什么是不可重读？</p></blockquote><p>在一个事务内多次读取的结果不一样。</p><blockquote><p>为什么会产生不可重复读？</p></blockquote><p>这跟 READ COMMITTED 级别下的MVCC机制有关系，在该隔离级别下每次 select的时候新<strong>生成一个版本号</strong>，所以每次select的时候读的不是一个副本而是不同的副本。</p><p>在每次select之间有其他事务<strong>更新</strong>了我们读取的数据并提交了，那就出现了不可重复读<br><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f05d63f388d0?w=3612&h=1512&f=png&s=816439" alt="img"></p><p><strong>REPEATABLE READ</strong>(Mysql默认隔离级别)</p><p>在一个事务内的多次读取的结果是一样的。这种级别下可以避免，脏读，不可重复读等查询问题。mysql 有两种机制可以达到这种隔离级别的效果，分别是采用读写锁以及MVCC。</p><p><strong>采用读写锁实现</strong>：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2c351eb03fc24?w=1082&h=290&f=png&s=120400" alt="img"><br>为什么能可重复度？只要没释放读锁，在次读的时候还是可以读到第一次读的数据。</p><p>优点：实现起来简单</p><p>缺点：无法做到读写并行</p><p><strong>采用MVCC实现</strong>：<br><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f054474b394b?w=3584&h=1512&f=png&s=756027" alt="img"></p><p>为什么能可重复度？因为多次读取只生成一个版本，读到的自然是相同数据。</p><p>优点：读写并行</p><p>缺点：实现的复杂度高</p><p>但是在该隔离级别下仍会存在幻读的问题，关于幻读的解决我打算另开一篇来介绍。</p><p><strong>SERIALIZABLE</strong></p><p>该隔离级别理解起来最简单，实现也最单。在隔离级别下除了不会造成数据不一致问题，没其他优点。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f56d34ff739e?w=3528&h=1060&f=png&s=414467" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f69776d551b3?w=2608&h=776&f=png&s=445068" alt="img"></p><p>–摘自《高性能Mysql》</p><h4 id="4-一致性的实现"><a href="#4-一致性的实现" class="headerlink" title="4.一致性的实现"></a>4.一致性的实现</h4><blockquote><p>数据库总是从一个一致性的状态转移到另一个一致性的状态.</p></blockquote><p>下面举个例子:zhangsan 从银行卡转400到理财账户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select balance from bank where name&#x3D;&quot;zhangsan&quot;;</span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 balance&#x3D;600</span><br><span class="line">update bank set balance &#x3D; balance - 400; </span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 amount&#x3D;400</span><br><span class="line">update finance set amount &#x3D; amount + 400;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>1.假如执行完 <code>update bank set balance = balance - 400;</code>之发生异常了，银行卡的钱也不能平白无辜的减少，而是回滚到最初状态。</p><p>2.又或者事务提交之后，缓冲池还没同步到磁盘的时候宕机了，这也是不能接受的，应该在重启的时候恢复并持久化。</p><p>3.假如有并发事务请求的时候也应该做好事务之间的可见性问题，避免造成脏读，不可重复读，幻读等。在涉及并发的情况下往往在性能和一致性之间做平衡，做一定的取舍，所以隔离性也是对一致性的一种破坏。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文出发点是想讲一下Mysql的事务的实现原理。</p><p>实现事务采取了哪些技术以及思想？</p><ul><li>原子性：使用 undo log ，从而达到回滚</li><li>持久性：使用 redo log，从而达到故障后恢复</li><li>隔离性：使用锁以及MVCC,运用的优化思想有读写分离，读读并行，读写并行</li><li>一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>论坛项目过程</title>
      <link href="/2020/11/01/%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/11/01/%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><h4 id="用户表-user"><a href="#用户表-user" class="headerlink" title="用户表 user"></a>用户表 user</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>username</td><td>varchar</td><td>用户名，创建索引</td></tr><tr><td>password</td><td>varchar</td><td>用户密码</td></tr><tr><td>salt</td><td>varchar</td><td>加密盐值</td></tr><tr><td>email</td><td>varchar</td><td>用户邮箱，创建索引</td></tr><tr><td>type</td><td>int</td><td>用户类型：0 普通、1 管理员、2 版主</td></tr><tr><td>status</td><td>int</td><td>用户状态：0 未激活、1 已激活</td></tr><tr><td>activation_code</td><td>varchar</td><td>激活码</td></tr><tr><td>header_url</td><td>varchar</td><td>用户头像地址</td></tr><tr><td>create_time</td><td>timestamp</td><td>注册时间</td></tr></tbody></table><h4 id="评论表-comment"><a href="#评论表-comment" class="headerlink" title="评论表 comment"></a>评论表 comment</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>user_id</td><td>int</td><td>评论的用户 id，创建索引</td></tr><tr><td>entity_id</td><td>int</td><td>评论实体 id，创建索引</td></tr><tr><td>entity_type</td><td>int</td><td>评论实体类型：1 帖子评论、2 评论回复</td></tr><tr><td>target_id</td><td>int</td><td>评论目标 id</td></tr><tr><td>content</td><td>text</td><td>评论内容</td></tr><tr><td>status</td><td>int</td><td>评论状态：0 有效、1 无效</td></tr><tr><td>create_time</td><td>timestamp</td><td>评论发表时间</td></tr></tbody></table><h4 id="帖子表-discuss-post"><a href="#帖子表-discuss-post" class="headerlink" title="帖子表 discuss_post"></a>帖子表 discuss_post</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>user_id</td><td>int</td><td>发帖的用户 id，创建索引</td></tr><tr><td>title</td><td>varchar</td><td>帖子表标题</td></tr><tr><td>content</td><td>text</td><td>帖子内容</td></tr><tr><td>type</td><td>int</td><td>帖子类型：0 普通、1 置顶</td></tr><tr><td>comment_count</td><td>int</td><td>评论数量</td></tr><tr><td>status</td><td>int</td><td>帖子状态：0 普通、1 精华、2 拉黑</td></tr><tr><td>create_time</td><td>timestamp</td><td>评论发表时间</td></tr></tbody></table><h4 id="用户登录凭证表-login-ticket"><a href="#用户登录凭证表-login-ticket" class="headerlink" title="用户登录凭证表 login_ticket"></a>用户登录凭证表 login_ticket</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>user_id</td><td>int</td><td>登录用户 id</td></tr><tr><td>ticket</td><td>varchar</td><td>登录凭证，随机字符串</td></tr><tr><td>status</td><td>int</td><td>登录状态：0 有效、1 无效</td></tr><tr><td>expired</td><td>timestamp</td><td>过期时间</td></tr></tbody></table><h4 id="消息表-message"><a href="#消息表-message" class="headerlink" title="消息表 message"></a>消息表 message</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>from_id</td><td>int</td><td>发消息的 id，创建索引</td></tr><tr><td>to_id</td><td>int</td><td>收消息的 id，创建索引</td></tr><tr><td>conversation_id</td><td>varchar</td><td>会话 id，由通信双方 id 拼接，创建索引</td></tr><tr><td>content</td><td>text</td><td>消息内容</td></tr><tr><td>status</td><td>int</td><td>消息状态：0 未读、1 已读、2 删除</td></tr><tr><td>create_time</td><td>timestamp</td><td>消息发送时间</td></tr></tbody></table><hr><h2 id="开发社区首页"><a href="#开发社区首页" class="headerlink" title="开发社区首页"></a>开发社区首页</h2><h3 id="搭建基本环境"><a href="#搭建基本环境" class="headerlink" title="搭建基本环境"></a>搭建基本环境</h3><p>构建 SpringBoot 的 maven 项目，引入 mysql 和 mybatis 依赖。</p><hr><p>在 <code>application.properties</code> 配置文件中：</p><ul><li>关闭 thymeleaf 缓存</li><li>配置数据库，设置基本连接信息、最大线程数，最小空闲线程数，最大空闲时间等</li><li>mybatis，设置 mapper 文件的位置、实体类包名、使用主键等</li></ul><hr><p>创建 community 数据库和数据库表。</p><hr><p>用户相关操作：</p><ul><li>创建对应 user 表的 User 实体类</li><li>创建 UserMapper 接口，使用 <code>@Mapper</code> 注解</li><li>创建 user-mapper.xml，重复 sql 语句可以写在 <code>&lt;sql id = &quot;xxx&quot;&gt;</code> 标签，通过 <code>&lt;include refid=&quot;xxx&quot;/&gt;</code> 引用。</li></ul><hr><h3 id="开发社区首页（discuss-post-表）"><a href="#开发社区首页（discuss-post-表）" class="headerlink" title="开发社区首页（discuss_post 表）"></a>开发社区首页（discuss_post 表）</h3><p>功能拆分：开发社区首页，显示前 10 个帖子。开发分页组件，分页显示所有帖子。</p><p>用到的表是 discuss_post 数据库表，包括帖子 id、发帖人 id、标题、内容、类型、状态、发帖时间、评论数量（为了提高效率，避免关联查询，因此冗余存储）、分数（用于进行热度排名）。</p><h4 id="开发数据层"><a href="#开发数据层" class="headerlink" title="开发数据层"></a>开发数据层</h4><p>帖子相关操作：</p><ul><li><p>创建对应 discuss_post 表的 DisscussPost 实体类。</p></li><li><p>创建 DisscussPostMapper 接口，使用 <code>@Mapper</code> 注解。</p><ul><li>分页查询中用户 id 是可选参数，通过动态 SQL 选择，如果为 0 就不使用，在开发用户个人主页查询用户发帖记录时需要使用。</li><li>如果只有一个参数，并且在动态 SQL 的 <code>&lt;if&gt;</code> 里使用，必须使用 <code>@Param</code> 加别名。</li></ul></li><li><p>创建 <code>disscusspost-mapper.xml</code>。</p><ul><li><p><code>where status != 2</code> 拉黑的帖子不展现。</p></li><li><p><code>&lt;if test=&quot;userId!=0&quot;&gt;</code>  userID 为 0 时不使用，按照类型，发帖时间排序。</p></li></ul></li></ul><hr><h4 id="开发业务层"><a href="#开发业务层" class="headerlink" title="开发业务层"></a>开发业务层</h4><p>创建 DiscussPostService 类，可以分页查询帖子和帖子数量。</p><p>创建 UserService 类，实现根据 id 查询用户功能，因为显示帖子时不显示用户 id，而是显示用户名。</p><hr><h4 id="开发视图层"><a href="#开发视图层" class="headerlink" title="开发视图层"></a>开发视图层</h4><p>把静态资源 css、html、img、js 放到 static 目录下。</p><p>把模板 mail、site、index.html 放到 template 目录下。</p><p>创建 HomeController，<code>getIndexPage</code> 方法，用 map 集合把帖子和用户封装到一起。</p><p>修改 <code>index.html</code>，使用 <code>&lt;th:text=&quot;${map.xxx.xxx}&quot;</code> 动态替换。</p><p>【问题】使用帖子关联查询用户时，给查询用户的 <code>findUserById</code> 方法传入了帖子的 <code>getId</code> 方法，应该是 <code>getUserId</code> 方法。</p><hr><h4 id="开发分页组件"><a href="#开发分页组件" class="headerlink" title="开发分页组件"></a>开发分页组件</h4><p>创建 Page 实体类，封装分页信息，包括当前页码、显示限制、帖子总数、查询路径等。显示的起始页不能小于 1，最大页不能超过 total。</p><p>在 <code>index.html</code> 中，当 <code>page.rows &gt; 0</code> 时显示分页信息。</p><p>如果 <code>page.current</code>  等于 1 或 <code>page.total</code>，代表是首页或末页，此时不能点击上一页和下一页，用 <code>disabled</code> 属性实现。</p><hr><h2 id="开发注册登录模块"><a href="#开发注册登录模块" class="headerlink" title="开发注册登录模块"></a>开发注册登录模块</h2><hr><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>在新浪邮箱打开 SMTP 服务。</p><p>引入 <code>spring-boot-starter-mail</code> 依赖。</p><p>在配置文件配置主机、端口、发送邮箱、授权码等。</p><p>创建 MailClient 类，调用 JavaMailSender 发送邮件。</p><p>使用 thymeleaf 发送 HTML 邮件，调用 TemplateEngine 把信息封装到 HTML 模板。</p><p>【问题】发送邮件成功但没接收到，在垃圾箱中可找到。</p><hr><h3 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h3><p>把 register.html 地址关联到首页的注册 href 属性。</p><p>设置域名、创建 CommunityUtil 工具类，在工具类创建生产随机字符串和 MD5 加密方法。</p><p>创建 LoginController，创建 <code>getRegisterPage</code> 方法，跳转注册页面。</p><p>在 UserService 中创建 <code>register</code> 方法，判断注册信息合规后插入数据库，发送激活邮件。</p><p>在 LoginController 创建 <code>register</code> 方法，调用 UserService 的 <code>register</code> 方法。</p><p>创建接口 CommunityConstant，定义激活码的三种状态，成功、重复、失败，让 UserService 和 LoginController 实现该接口。</p><p>点击激活邮件的 url 【本地服务器的url】后，服务器通过 LoginController 的 <code>activation</code> 方法查询数据库用户，如果 url 中的激活码和设置的一样，就把用户 status 改为 1。</p><hr><h3 id="生成验证码"><a href="#生成验证码" class="headerlink" title="生成验证码"></a>生成验证码</h3><p>在 <code>pom.xml</code> 导入 kaptcha 的 jar 包。</p><p>创建配置类 KaptchaConfig，设置验证码的大小、范围、长度等。</p><p>在 LoginController 类新增 <code>getKaptcha</code> 方法生成验证码图片。</p><p>在 <code>login.html</code> 中，将刷新验证码的链接绑定 <code>refresh_kaptcha</code> 方法，通过 id 选择器获取 img 组件，重新访问  <code>getKaptcha</code> 方法生成验证码图片。</p><p>【问题】由于访问同一个生成验证码路径，需要在 url 参数加上一个随机数字，保证会重新请求获取新图片。</p><hr><h3 id="登录退出功能（login-ticket-表）"><a href="#登录退出功能（login-ticket-表）" class="headerlink" title="登录退出功能（login_ticket 表）"></a>登录退出功能（login_ticket 表）</h3><p>登录成功时，需要生成一个登录凭证发送给客户端。凭证可以在多个业务中连续地验证用户的登陆状态，凭证信息存储在 login_ticket 数据库表中，status 的 0 和 1 表示有效和无序，expire 表示过期时间。</p><p>创建对应 login_ticket 表的 LoginTicket 实体类，对应 login_ticket 数据库表。</p><p>创建 LoginTicketMapper 接口，通过 <code>@Insert</code>、<code>@Select</code>、<code>@Update</code> 注解来插入、查询、更新凭证。</p><p>在 UserServce </p><ul><li><p>创建 <code>login</code> 方法，验证账户合规后将凭证信息插入数据库，添加登录凭证到 map 中。</p></li><li><p>创建 <code>logout</code> 方法，将对应凭证设为无效。</p></li></ul><p>在 LoginController </p><ul><li><p>创建 <code>login</code> 方法，判断验证码正确后调用  UserServce 的 <code>login</code> 方法，如果 map 包含 ticket 代表登录成功，重定向跳转首页，否则添加错误信息并跳回登录页。</p></li><li><p>创建 <code>logout</code> 方法，判断验证码正确后调用  UserServce 的<code>logout</code> 方法，跳转至登录页。</p></li></ul><p>在 <code>login.html</code> 绑定登录链接，<code>index.html</code> 绑定退出登录链接。</p><p>【问题】登录成功后，创建了凭证，但忘记将凭证信息插入数据库。</p><hr><h3 id="显示登录信息"><a href="#显示登录信息" class="headerlink" title="显示登录信息"></a>显示登录信息</h3><p>创建 CookieUtil 工具类，通过 name 查询对应 cookie 的 value。</p><p>在 UserService 中新增 <code>findLoginTicket</code> 方法，根据 ticket 查询 LoginTicket。</p><p>创建 HostHolder 类用来模拟 session 的功能，利用 ThreadLocal 实现，存储用户信息。</p><p>创建 LoginTicketInterceptor 拦截器，实现 HandlerInterceptor 接口。</p><ul><li>在 <code>preHandle</code> 方法中通过 CookieUtil 的 <code>getValue</code> 方法查询是否有凭证 cookie，如果有则通过 UserService 的  <code>findloginTicket</code> 方法查询用户 ID，再通过用户 ID 查询用户。最后将用户放入 hostHolder 中。</li><li>在 <code>postHandle</code> 方法中通过 hostHolder 的 <code>get</code> 方法获取用户，并将其存入视图中。</li><li>在 <code>afterCompletion</code> 方法中清除 hostHolder 中存放的用户信息。</li></ul><p>创建 WebMvcConfig 配置类，实现 WebMvcConfigurer接口，配置 LoginTicketInterceptor，拦截除了静态资源之外的所有路径。</p><hr><h3 id="上传头像"><a href="#上传头像" class="headerlink" title="上传头像"></a>上传头像</h3><p>在 UserService 新增 <code>updateHeader</code> 方法，更改指定用户的头像。</p><p>创建 UserController</p><ul><li><p>新增 <code>getSettingPage</code> 方法访问账户设置 <code>setting.html</code> ，并在 <code>index.html</code> 的账号设置按钮关联该链接。</p></li><li><p>新增 <code>uploadHeader</code> 方法更新用户头像，如果上传出现错误将错误信息存在 Model 对象中。</p><p>如果没有错误，生成一个文件对象 dest，利用 MultipartFile 接口的 <code>transferTo</code> 方法将用户上传文件导入 dest，并从 hostHolder 中取出用户，更新用户的头像路径。</p></li><li><p>新增 <code>getHeader</code> 方法获取用户头像，利用文件输入流读取图片数据，利用 HttpServletResponse 的字节输出流再进行输出。</p></li></ul><p>调整 <code>setting.html</code> 的 form 表单， method=”post”，enctype=”multipart/form-data”，并设置提交路径。</p><hr><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>在 UserService 中新增 <code>changePassword</code> 方法，判断原密码是否正确，正确则修改密码并返回 1，否则返回 0。</p><p>在 UserController 中新增 <code>changePassword</code> 方法，根据 UserService 的  <code>changePassword</code> 方法的返回值判断原密码是否成功修改，封装为 JSON 数据并返回。</p><p>在 <code>setting.html</code> 中</p><ul><li>首先在前端判断两次输入的新密码是否一致，如果不一致不允许点击提交并显示错误信息。</li><li>利用 ajax 向 UserController 的  <code>changePassword</code> 方法发送 POST 请求，得到 JSON 数据并解析，如果状态码为 0 提示错误，如果状态码为 1 弹出修改成功提示。</li></ul><p>【问题】js 的虚拟路径问题，需要加上 <code>../</code>。</p><p>【问题】使用 ajax 请求时，表单按钮类型必须是 button，不能是 submit，否则 405 报错。</p><p>【问题】使用 ajax 请求时，Controller 中方法的返回值必须是 JSON 数据，并且需要加上 <code>@ResponseBody</code>。</p><p>【问题】使用 ajax 请求时，回调函数需要先对返回的 JSON 数据进行解析再使用。</p><hr><h3 id="检查登录状态"><a href="#检查登录状态" class="headerlink" title="检查登录状态"></a>检查登录状态</h3><p>利用拦截器，实现只处理带有自定义注解的方法，防止用户在未登录情况下通过 url 访问没有权限的页面。</p><p>创建 <code>@LoginRequired</code> 自定义注解，作用范围在方法上，有效期为运行时。</p><p>在 UserController 中需要在登录状态下调用的方法，访问设置页面、修改密码、上传头像等加上自定义注解。</p><p>创建 LoginRequiredInterceptor 拦截器，在 <code>preHandle</code> 方法中判断方法是否加了 <code>@LoginRequired</code> 注解，如果加了注解并且此时从 hostHolder 中获取不到用户则拒绝访问。</p><p>在 WebMvcConfig 配置类配置 LoginRequiredInterceptor，拦截除了静态资源之外的所有路径。</p><hr><h2 id="开发核心功能"><a href="#开发核心功能" class="headerlink" title="开发核心功能"></a>开发核心功能</h2><h3 id="敏感词过滤"><a href="#敏感词过滤" class="headerlink" title="敏感词过滤"></a>敏感词过滤</h3><p>利用字典树数据结构解决。</p><p>创建 SensitiveFilter 类</p><ul><li>创建静态内部类 TrieNode ，通过 boolean 类型的结束符判断是否匹配到关键字尾部。</li><li>利用 <code>@PostConstruct</code> 注解，在构造方法执行后初始化字典树。</li><li>添加 <code>filter</code> 方法，利用双指针进行匹配，过滤敏感词。</li></ul><p>【问题】判断子节点空时，直接添加了一个 new 的子节点，没有将对象赋值给子节点变量。</p><hr><h3 id="发布帖子"><a href="#发布帖子" class="headerlink" title="发布帖子"></a>发布帖子</h3><p>引入 fastjson 依赖，在 CommunityUtil 中新增 <code>getJSONString</code> 方法封装 JSON 信息。</p><p>在 DisscussPostMapper 接口新增 <code>insertDiscussPost</code> 方法，并在 <code>disscusspost-mapper.xml</code> 配置 insert 语句。</p><p>在 DiscussPostService 新增 <code>addDiscussPost</code> 方法调用 DisscussPostMapper 的 <code>insertDiscussPost</code> 方法，其中需要进行对标题内容和发帖内容进行 HTML 转义以及过滤敏感词。</p><p>创建 DiscussPostController 类，新增 <code>addDiscussPost</code> 方法，调用 DiscussPostService 的 <code>addDiscussPost</code> 方法发帖。</p><p>在 <code>index.html</code> 中为发帖按钮绑定函数，利用 Ajax 向 DiscussPostController 的 <code>addDiscussPost</code> 方法发送 POST 请求。</p><hr><h3 id="显示帖子内容"><a href="#显示帖子内容" class="headerlink" title="显示帖子内容"></a>显示帖子内容</h3><p>在 DisscussPostMapper 接口新增 <code>selectDiscussPostById</code> 方法，在 <code>disscusspost-mapper.xml</code> 配置 select 语句。</p><p>在 DiscussPostService 新增 <code>findDiscussPostById</code> 方法调用 DisscussPostMapper 的 <code>selectDiscussPostById</code> 方法。</p><p>在 DiscussPostController 新增 <code>getDiscussPost</code> 方法，调用 DiscussPostService 的 <code>findDiscussPostById</code> 方法查询帖子内容，将 DiscussPost 对象和 User 对象（通过 userId 查询，不在 DAO 层关联查询）数据存放到 Model 对象，返回模板 <code>discuss-detail</code>。</p><p>在 <code>discuss-detail.html</code> 取出 Model 对象存放的数据绑定到对应组件显示。</p><hr><h3 id="显示评论（comment-表）"><a href="#显示评论（comment-表）" class="headerlink" title="显示评论（comment 表）"></a>显示评论（comment 表）</h3><p>创建 comment 表对应的实体类 Comment。</p><p>创建 CommentMapper 接口</p><ul><li>新增 <code>selectCommentsByEntity</code> 方法，根据实体查询一页的评论数据。</li><li>新增 <code>selectCountByEntity</code> 方法，根据实体查询评论的数量。</li><li>在 <code>comment-mapper.xml</code> 配置 select 语句。</li></ul><p>创建 CommentService 类</p><ul><li>新增 <code>findCommentByEntity</code> 方法，调用 CommentMapper 的 <code>selectCommentByEntity</code> 方法。</li><li>新增 <code>findCommentCount</code> 方法，调用 CommentMapper 的 <code>selectCountByEntity</code> 方法。</li></ul><p>在 DiscussPostController 的 <code>getDiscussPost</code> 方法中增加查询帖子评论和回复的逻辑，将结果存储在 Model 对象。</p><p>【问题】sql 的 xml 文件中绑定参数时，应传入实体类属性名，拼错成数据库字段名（entityId 写成 entity_id）。</p><hr><h3 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h3><p>在 CommentMapper 接口新增 <code>insertComment</code> 方法，添加评论数据，在 <code>comment-mapper</code> 配置对应 sql。</p><p>在 DiscussPostMapper 接口新增 <code>updateCommentCount</code> 方法，增加评论数量，在 <code>discusspost-mapper</code> 配置对应 sql。</p><p>在 DiscussPostService 类新增 <code>updateCommentCount</code> 方法，调用 DiscussPostMapper 的 <code>updateCommentCount</code> 方法。</p><p>在 CommentService 类新增 <code>addComment</code> 方法，调用 CommentMapper 的 <code>insertComment</code> 新增评论，并调用 DiscussPostService 的 <code>updateCommentCount</code> 更新评论数量，使用 <code>@Transactional</code> 注解保证事务。</p><p>创建 CommentController 类，新增 <code>addComment</code> 方法，从 hostHolder 获取用户信息，然后调用 CommentService 的 <code>addComment</code> 方法添加评论。</p><p>【问题】sql 的 xml 文件中绑定参数时，应传入实体类属性名，拼错成数据库字段名（entityId 写成 entity_id）。</p><hr><h3 id="显示私信列表-（message-表）"><a href="#显示私信列表-（message-表）" class="headerlink" title="显示私信列表 （message 表）"></a>显示私信列表 （message 表）</h3><p>创建对应 message 表的实体类 Message。</p><p>创建 MessageMapper 接口，增加查询会话列表、会话数量、私信列表、私信数量、未读私信数量等方法，在 <code>message-mapper.xml</code> 中配置对应的 sql。</p><p>创建 MessageService，调用 MessageMapper 中的方法。</p><p>创建 MessgaeController</p><ul><li>新增 <code>getLetterList</code> 方法，将会话列表信息存储到 Model 对象，返回 <code>letter</code> 视图。</li><li>新增 <code>getLetterDetail</code> 方法，将每个会话具体的私信信息存储到 Model 对象，返回 <code>letter-datail</code> 视图。</li></ul><hr><h3 id="发送私信"><a href="#发送私信" class="headerlink" title="发送私信"></a>发送私信</h3><p>在 MessageMapper </p><ul><li>新增 <code>insertMessage</code> 方法插入私信记录，在 <code>message-mapper.xml</code>  配置 insert 语句。</li><li>新增 <code>updateMessgae</code> 方法修改私信状态，在 <code>message-mapper.xml</code>  配置 update 语句，利用 foreach 动态 sql。</li></ul><p>在 MessageService</p><ul><li><p>新增 <code>addMessage</code> 发送私信方法，过滤敏感词后，调用 MessageMapper 的 <code>insertMessage</code> 。</p></li><li><p>新增 <code>readMessage</code> 方法读取信息，调用MessageMapper 的 <code>updateMessgae</code> 更新私信的状态为 1。</p></li></ul><p>在 MessageController </p><ul><li><p>新增 <code>getLetterIds</code> 方法，将私信集合中未读私信的 id 添加到 List 集合并返回，在 <code>getLetterDetail</code> 方法调用该方法设置已读。</p></li><li><p>新增 <code>sendLetter</code> 发送私信方法，设置私信信息后调用 MessageService 的 <code>addMessage</code> 发送。</p></li></ul><hr><h3 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h3><p>在 HomeController 中增加 <code>getErrorPage</code> 方法，返回错误页面。</p><p>创建 ExceptionAdvice 类</p><ul><li>加上 <code>@ControllerAdvice</code> 注解，表示该类是 Controller 的全局配置类。</li><li>创建 <code>handleException</code> 方法，加上 <code>@ExceptionHandler</code> 注解，该方法在 Controller 出现异常后调用，处理捕获异常。如果是异步请求返回一个 JSON 数据，否则重定向至 HomeController 的 <code>getErrorPage</code> 方法。</li></ul><hr><h3 id="统一日志处理"><a href="#统一日志处理" class="headerlink" title="统一日志处理"></a>统一日志处理</h3><p>在 <code>pom.xml</code> 引入 aspectj 的依赖。</p><p>创建 ServiceLogAspect 类，添加 <code>@Aspect</code> 切面注解，配置切入点表达式，拦截所有 service 包下的方法，利用 <code>@Before</code> 记录日志。</p><hr><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>创建 RedisKeyUtil 工具类</p><ul><li>定义分隔符 <code>:</code> 以及实体获得赞的 key 前缀常量 <code>like:entity</code>。</li><li>新增 <code>getEntityLikeKey(int entityType,int entityId)</code> 方法，通过实体类型和实体 id 生成对应实体获得赞的 key。</li></ul><p>创建业务层的 LikeService 类</p><ul><li><p>注入 RedisTemplate 实例。</p></li><li><p>新增 <code>like</code> 点赞方法，首先通过 RedisKeyUtil 工具类的  <code>getEntityLikeKey</code> 方法获得实体点赞的 key，然后通过 RedisTemplate 对象对 set 集合的 <code>isMember</code> 方法查询 userId 是否存在于对应 key 的 set 集合中，如果存在则移除出点赞的用户集合，如果不存在则添加到点赞的用户集合。</p></li><li><p>新增 <code>findEntityLikeCount</code> 方法查询实体的点赞数量，通过调用 set 集合的 <code>size</code> 方法查询元素个数。</p></li><li><p>新增 <code>findEntityLikeStatus</code> 方法查询某用户对某实体的点赞状态，逻辑如 <code>like</code> 方法，通过 set 集合的 <code>isMember</code> 方法实现。</p></li></ul><p>创建表现层的 LikeController 类</p><ul><li>注入 LikeService 和 HostHolder 实例。</li><li>新增 <code>like</code> 点赞方法，调用业务层的 <code>like</code> 方法进行点赞、调用  <code>findEntityLikeCount</code> 和 <code>findEntityLikeStatus</code>  查询点赞数量和点赞状态，封装到 map 集合，然后通过工具类封装成 JSON 数据返回。</li></ul><p>（更新首页帖子点赞数量）在表现层的 HomeController 类</p><ul><li>注入 LikeService 实例。</li><li>在 <code>getIndexPage</code> 方法在通过 LikeService 类的方法获得点赞数量，存储到 map 集合。</li></ul><hr><h3 id="收到的赞"><a href="#收到的赞" class="headerlink" title="收到的赞"></a>收到的赞</h3><p>对点赞功能进行重构</p><p>在 RedisUnitl 工具类</p><ul><li><p>新增用户获得赞 key 的前缀常量 <code>like:user</code></p></li><li><p>新增 <code>getUserLikeKey(int userId)</code> 方法，通过用户 id 生成对应用户获得赞的 key。</p></li></ul><p>在 LikeService 中</p><ul><li><p>重构 <code>like</code> 方法，在参数列表中加入 entityUserId 表示被点赞用户的 id，用来更新用户的被点赞数量。</p><ul><li><p>通过 RedisTemplate 对象的 <code>execute</code> 方法实现事务，保证被点赞用户点和点赞用户的数据更新一致。通过 <code>isMember</code> 方法查询用户的点赞状态，之后通过 <code>mutli</code> 方法开启事务。</p></li><li><p>当用户已点赞时，调用 <code>remove</code> 方法将当前用户从点赞用户的集合中移除，调用 <code>decrement</code> 方法将被点赞用户的被点赞数减 1；当用户未点赞时，调用 <code>add</code> 方法将当前用户添加到点赞用户的集合，调用 <code>increment</code> 方法将被点赞用户的被点赞数加 1。</p></li></ul></li><li><p>增加 <code>findUserLikeCount</code> 方法，以用户 id 作为 key，调用 <code>get</code> 方法查询用户所获得的点赞数。</p></li></ul><p>在 LikeController 中给 <code>like</code> 方法增加 entityUserId 参数即可。</p><hr><h3 id="关注"><a href="#关注" class="headerlink" title="关注"></a>关注</h3><p>在 RedisUnitl 工具类</p><ul><li><p>新增用户关注实体（帖子、评论、用户等）和粉丝（用户）的前缀常量 <code>followee</code> 和 <code>follower</code></p></li><li><p>新增 <code>getFolloweeKey(int userId, int entityType)</code> 方法，通过用户 id 和实体类型生成用户关注实体的 key。</p></li><li><p>新增 <code>getFollowerKey(int entityType, int entityId)</code> 方法，通过实体类型和实体 id 生成实体用户粉丝的 key。</p></li></ul><p>创建业务层的 FollowService 类</p><ul><li>新增 <code>follow</code> 方法，当用户关注某实体时，<ul><li>调用 <code>add</code> 方法将当前实体 id  和时间作为 value 和 score加入用户的关注集合。</li><li>调用 <code>add</code> 方法将当前用户 id 和时间作为 value 和 score 加入实体的粉丝集合。</li></ul></li><li>新增 <code>unfollow</code> 方法，当用户取消关注某实体时，<ul><li>调用 <code>remove</code> 方法将当前实体从用户的关注集合移除。</li><li>调用 <code>remove</code> 方法将用户从实体的粉丝集合移除。</li></ul></li></ul><hr><h3 id="个人主页"><a href="#个人主页" class="headerlink" title="个人主页"></a>个人主页</h3><p>在业务层的 FollowService 类</p><ul><li>新增 <code>findFolloweeCount</code> 方法，调用 zset 的 <code>zcard</code>  方法查询某用户关注的实体数量。</li><li>新增 <code>findFollowerCount</code> 方法，调用 zset 的 <code>zcard</code>  方法查询某实体的粉丝数量。</li><li>新增 <code>hasFollowed</code> 方法，根据 zset 的 <code>zscore</code>  方法返回值查询当前用户是否关注某实体。</li></ul><p>在 UserController 中新增 <code>getProfilePage</code> 方法获取个人主页。</p><ul><li>调用 LikeService 的  <code>findUserLikeCount</code> 查询用户获赞数，并添加到 Model 中。</li><li>调用 FollowService 的<code>findFolloweeCount</code>、<code>findFollowerCount</code> 、<code>hasFollowed</code> 方法分别查询关注数量、粉丝数量、用户是否关注三项信息并添加到 Model 对象中存储。</li></ul><hr><h3 id="关注列表和粉丝列表"><a href="#关注列表和粉丝列表" class="headerlink" title="关注列表和粉丝列表"></a>关注列表和粉丝列表</h3><p>在业务层的 FollowService 类</p><ul><li>新增 <code>findFollowees</code> 方法，查询用户关注列表，主要通过 zset 的  <code>reverseRange</code> 获取 value 即关注用户的 userId，再查询出其 user，之后通过 <code>score</code> 获取关注时间，存入 map 集合，将 map 添加到 list 列表返回。</li><li>新增 <code>findFollowers</code> 方法，查询用户粉丝列表，主要通过 zset 的  <code>reverseRange</code> 获取 value 即粉丝的 userId，再查询出其 user，之后通过 <code>score</code> 获取关注时间，存入 map 集合，将 map 添加到 list 列表返回。</li></ul><p>在表现层的 FollowController 类</p><ul><li>新增 <code>getFollowees</code> 方法，获取关注列表，存入 Model 对象。</li><li>新增 <code>getFollowers</code> 方法，获取粉丝列表，存入 Model 对象。</li></ul><hr><h3 id="优化登录模块"><a href="#优化登录模块" class="headerlink" title="优化登录模块"></a>优化登录模块</h3><p><strong>存储验证码</strong></p><p>在 RedisUntil 工具类</p><ul><li>新增验证码前缀常量 <code>kaptcha</code></li><li>新增 <code>getKaptchaKey</code> 方法，通过一个用户凭证（由于未登录，利用 cookie 实现）获得对应验证码的 key 值（利用 string 存储验证码）。</li></ul><p>在表现层的 LoginController 类</p><ul><li>重构 <code>getKaptcha</code> 方法，将验证码存入 redis，key 值是当前随机生成的一个字符串，同时将该字符串存入 cookie。</li><li>重构 <code>login</code> 方法，从 cookie 中获得随机字符串，生成验证码的 key 值，然后获取对应的 value 值即验证码。</li></ul><hr><p><strong>存储登录凭证</strong></p><p>在 RedisUntil 工具类</p><ul><li>新增登录凭证前缀常量 <code>ticket</code></li><li>新增 <code>getTicketKey</code> 方法，通过字符串获得登录凭证的对应 key 值（利用 string 存储）。</li></ul><p>在业务层的 UserService 类</p><ul><li>重构 <code>login</code> 方法，将登录凭证存入 redis 中。</li><li>重构 <code>logout</code> 方法，先从 redis 中获取登录凭证对象，将状态设为无效再重新存储进 redis。</li><li>重构 <code>findLoginTicket</code> 方法，根据 ticket 字符串获得对应登录凭证的 key，然后从 redis 查询登录凭证。</li></ul><hr><p><strong>缓存用户信息</strong></p><p>在 RedisUntil 工具类</p><ul><li>新增用户前缀常量 <code>user</code></li><li>新增 <code>getUserKey</code> 方法，通过用户 id 获得用户的对应 key 值（利用 string 存储）。</li></ul><p>在业务层的 UserService 类</p><ul><li><p>新增 <code>getCache</code>，从缓存获取用户信息。</p></li><li><p>新增 <code>initCache</code>，从 MySQL 查询用户信息并存入 redis。</p></li><li><p>新增 <code>clearCache</code>，用户信息变更（更新头像，激活）时清除缓存。</p></li><li><p>重构 <code>findUserById</code> 方法，首先调用 <code>getCache</code>从缓存获取用户信息，如果获取为 null 则调用 <code>initCache</code>。</p></li></ul><hr><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="发送系统通知"><a href="#发送系统通知" class="headerlink" title="发送系统通知"></a>发送系统通知</h3><p>在 CommunityConstant 接口中新增三个常量，代表三个主题：评论、点赞、关注。</p><p>创建 Event 类，封装事件对象，包括主题、用户 id、实体类型、实体 id、实体用户 id 以及一个 map 集合存放其它信息。</p><h4 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h4><p>创建 EventProducer 事件生产者，新增 <code>fireEvent(Event event)</code> 方法，通过 Event 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 KafkaTemplate 实例的 send 方法发送。</p><p>在 CommentController、LikeControler、FollowController 中注入 EventProducer 实例，分别重构 <code>addComment</code> 方法、<code>like</code> 方法、<code>follow</code> 方法，封装 Event 对象，然后调用 EventProducer 的<code>fireEvent</code> 方法发布通知。</p><h4 id="消费事件"><a href="#消费事件" class="headerlink" title="消费事件"></a>消费事件</h4><p>创建 EventConsumer 事件消费者，消费者是被动触发的。</p><ul><li>注入 MessageService 实例。</li><li>增加 <code>handleCommentMessage(ConsumerRecord record)</code> 方法，通过 <code>@KafkaListener</code> 注解，topic 包括了评论、点赞和关注。从 recored 中获取信息，封装成 Message 对象然后调用 <code>addMessage</code> 方法插入数据库。</li></ul><p>【问题】没有向数据库插入系统通知记录，原因是 ServiceLogAspect 类进行日志处理时要获取 ServletRequestAttributes 请求对象，Kafka 的消费事件是自动触发的，没有进行新的请求，产生了请求对象的空指针异常。</p><hr><h3 id="显示系统通知"><a href="#显示系统通知" class="headerlink" title="显示系统通知"></a>显示系统通知</h3><h4 id="通知列表"><a href="#通知列表" class="headerlink" title="通知列表"></a>通知列表</h4><p>在 MessageMapper 接口中</p><ul><li><p>新增 <code>selectLatestNotice(int userId, String topic)</code> 方法，查询某主题最新的通知。</p></li><li><p>新增 <code>selectNoticeCount(int userId, String topic)</code> 方法，查询某主题通知的数量。</p></li><li><p>新增 <code>selectNoticeUnreadCount(int userId, String topic)</code> 方法，查询未读通知的数量。</p></li><li><p>在 <code>message-mapper.xml</code> 配置三个方法的 sql 语句，其中查询未读通知时使用 if 动态语句，如果没有传入 topic 就查询未读总量。</p></li></ul><p>在业务层的 MessageService 中</p><ul><li>新增 <code>findLatestNotice</code> 方法，调用 <code>selectLatestNotice</code> 方法查询最新通知。</li><li>新增 <code>findNoticeCount</code> 方法，调用 <code>selectNoticeCount</code> 方法查询某主题通知的数量。</li><li>新增 <code>findNoticeUnreadCount</code> 方法，调用 <code>selectNoticeUnreadCount</code> 方法查询未读通知的数量。</li></ul><p>在表现层的 MessageController 中新增 <code>getNoticeList</code> 方法，获取通知列表</p><ul><li>调用业务层 MessageService 的方法查询评论、点赞、关注的通知，将其封装在一个 HashMap 集合中然后添加到 Model 对象里。</li><li>调用业务层 MessageService 的方法查询私信和通知的总未读数量，添加到 Model 对象里。</li><li>返回 <code>notice.html</code> 页面。</li></ul><hr><h4 id="显示通知详情"><a href="#显示通知详情" class="headerlink" title="显示通知详情"></a>显示通知详情</h4><p>在 MessageMapper 接口新增 <code>selectNotices</code> 方法，查询某个主题的通知列表，在 <code>message-mapper.xml</code> 配置 SQL。</p><p>在业务层的 MessageService 中新增 <code>findNotices</code> 方法，调用 <code>selectNotices</code> 方法。</p><p>在表现层的 MessageController 中新增 <code>getNoticeDetail</code> 方法</p><ul><li>调用 <code>findNotices</code> 方法获取通知列表详情，封装到 List 集合并存入 Model 对象。</li><li>从通知集合中获取 id 集合，调用 <code>readMessage</code> 方法将消息设为已读。</li><li>返回 <code>notice-detail.html</code> 页面。</li></ul><hr><h4 id="显示未读通知总数"><a href="#显示未读通知总数" class="headerlink" title="显示未读通知总数"></a>显示未读通知总数</h4><p>创建 MessageInterceptor 拦截器</p><ul><li>注入 MessageService 实例和 HostHolder 实例。</li><li>重写 <code>postHandle</code> 方法，查询私信和通知的未读数量和，然后添加到 ModelAndView 对象。</li></ul><p>在 WebConfig 中注入 MessageInterceptor 实例，并在 <code>addInterceptors</code> 方法中添加该拦截器。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>论坛的总结和改进</title>
      <link href="/2020/11/01/%E8%AE%BA%E5%9D%9B%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%94%B9%E8%BF%9B/"/>
      <url>/2020/11/01/%E8%AE%BA%E5%9D%9B%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%94%B9%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2020/11/01/%E8%AE%BA%E5%9D%9B%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E6%94%B9%E8%BF%9B/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201115163502330.png" alt="image-20201115163502330"></p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><strong>用户表</strong>，包括 id、用户名、密码、盐值、邮箱、类型（普通/管理员/版主）、状态（激活/未激活）、激活码（随机字符串）、头像 url、注册时间。</p><p><strong>登录凭证表</strong>，包括 id、用户 id、登陆凭证（随机字符串）、登录状态（有效/无效）、过期时间。</p><p><strong>评论表</strong>，包括 id、评论用户 id（索引）、评论实体 id（索引）、评论类型（帖子/回复）、被评论目标 id、评论内容、评论状态（有效/无效）、评论时间。</p><p><strong>帖子表</strong>，包括 id、发帖用户 id（索引）、标题、帖子内容、类型（普通/置顶）、评论数量、状态（普通/精华/拉黑）、发帖时间。</p><p><strong>消息表</strong>，包括 id、发消息 id（索引）、收消息 id（索引）、会话 id（由发消息双方 id 拼接，索引）、内容、状态（未读/已读/删除）、发消息时间。</p><hr><p><strong>社区论坛</strong></p><p><strong>项目描述</strong>：该项目是设计一个社区论坛，方便用户发言与讨论</p><p><strong>使用技术</strong>：本项目使用SpringBoot进行开发，使用的技术主要有 MySQL，Redis , Kafka , Quartz</p><p><strong>主要功能</strong>：登录注册，发帖评论，点赞关注，消息提醒，热帖排行</p><p><strong>项目亮点</strong>：</p><ul><li>通过Kaptcha来生成验证码图片，作登录和注册的验证。</li><li>通过自定义注解和拦截器，防止用户在未登录的情况下通过url访问没有权限的页面。</li><li>利用数据结构Trie实现前缀树，对发表帖子评论进行简单的敏感词过滤。</li><li>对点赞关注等高频功能利用Redis的Set来提升性能，并通过Redis的Hyperloglog统计UV, Bitmap统计DAU。</li><li>利用Kafka来实现消息提醒功能，起到异步和解耦的功能。</li><li>使用定时任务Quartz来更新帖子的评分，实现帖子排行</li></ul><hr><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p><strong>判断注册合法性</strong></p><ul><li><p>利用 StringUtils 判断用户名、密码、邮箱是否非空。</p></li><li><p>分别通过用户名和邮箱查询是否已经注册（为数据库的用户名和邮箱字段添加索引）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Service层</span><br><span class="line">public Map&lt;String, Object&gt; register(User user)</span><br><span class="line">&#123;</span><br><span class="line">   &#x2F;&#x2F;Mapper层</span><br><span class="line">   User u &#x3D; userMapper.selectByName(user.getUsername());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>通过 <code>set</code> 方法为用户设置各项信息</strong>，包括 salt，MD5 加密后的密码、用户类型type，用户status状态、创建时间等，然后插入数据库。（keyProperty=”id” 标明主键)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user.setSalt(CommunityUtil.generateUUID().substring(0, 5));</span><br><span class="line">user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt()));</span><br><span class="line">user.setType(0);</span><br><span class="line">user.setStatus(0);</span><br><span class="line">user.setActivationCode(CommunityUtil.generateUUID());</span><br><span class="line">user.setHeaderUrl(String.format(&quot;http:&#x2F;&#x2F;images.nowcoder.com&#x2F;head&#x2F;%dt.png&quot;, new Random().nextInt(1000)));</span><br><span class="line">user.setCreateTime(new Date());</span><br><span class="line">userMapper.insertUser(user);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**给用户发送激活邮件**</span><br><span class="line"></span><br><span class="line">- 在新浪邮箱打开 SMTP 服务，引入 &#96;spring-boot-starter-mail&#96; 依赖。</span><br><span class="line">- 在配置文件配置主机（smtp.sina.com）、端口（465）、邮箱、授权码、协议（smtps），设置 smtp.ssl.enable &#x3D; true。</span><br><span class="line">- 调用 JavaMailSender 的 API 发送邮件，激活 url 由用户 id 和用户的激活码拼接而成。点击激活 url 后由 controller 中的方法进行处理（成功&#x2F;重复&#x2F;失败），调用 Model 对象的 &#96;addAttribute&#96; 方法将结果返回前端。</span><br></pre></td></tr></table></figure><p><strong>用户表</strong>，包括 id、用户名、密码、盐值、类型（普通/管理员/版主）、状态（激活/未激活）、注册时间。</p><hr><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p><strong>生成验证码</strong></p><ul><li><p>引入 kaptcha 依赖，将验证码的大小、范围、长度等属性封装到 Properties 对象，作为参数构造 Config 对象，再用 Config 对象作为 DeafultKaptcha 对象  <code>setConfig</code> 方法的参数为验证码设置属性。随后在登录模块就通过kaptchaProducer.createText()生成并封装在BufferedImage里，最后通过ImageIO写到response的输出流里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String text &#x3D; kaptchaProducer.createText();</span><br><span class="line"> BufferedImage image &#x3D; kaptchaProducer.createImage(text);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Producer kaptchaProducer() &#123;</span><br><span class="line">    Properties properties &#x3D; new Properties();</span><br><span class="line">    properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;100&quot;);</span><br><span class="line">    properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;40&quot;);</span><br><span class="line">    properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;32&quot;);</span><br><span class="line">    properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;0,0,0&quot;);</span><br><span class="line">    properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;, &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYAZ&quot;);</span><br><span class="line">    properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;);</span><br><span class="line">    properties.setProperty(&quot;kaptcha.noise.impl&quot;, &quot;com.google.code.kaptcha.impl.NoNoise&quot;);</span><br><span class="line">  </span><br><span class="line">    DefaultKaptcha kaptcha &#x3D; new DefaultKaptcha();</span><br><span class="line">    Config config &#x3D; new Config(properties);</span><br><span class="line">    kaptcha.setConfig(config);</span><br><span class="line">    return kaptcha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在登录的 controller 处理验证码，设置页面的响应类型为 png，通过 ImageIO 的 <code>write</code> 方法将图片输出到浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成验证码</span><br><span class="line">    String text &#x3D; kaptchaProducer.createText();</span><br><span class="line">    BufferedImage image &#x3D; kaptchaProducer.createImage(text);</span><br><span class="line">    &#x2F;&#x2F; 验证码的归属</span><br><span class="line">    &#x2F;&#x2F; 将验证码存入Redis</span><br><span class="line">    &#x2F;&#x2F; 将突图片输出给浏览器</span><br><span class="line">    response.setContentType(&quot;image&#x2F;png&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">    OutputStream os &#x3D; response.getOutputStream();</span><br><span class="line">    ImageIO.write(image, &quot;png&quot;, os);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">    logger.error(&quot;响应验证码失败:&quot; + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>验证码我们会生成一个随机ID，写到cookie设置过期时间，并把真正的value值设置到redis里面。在后面的登录模块就根据cookie的值从redis里面取出验证码，与传入的验证码进行验证。</p><p><strong>判断验证码正确后，调用业务层处理</strong></p><ul><li><p>利用 StringUtils 判断用户名、密码是否非空，之后判断用户是否存在、用户是否激活、密码是否正确，将错误信息存到 map 集合。(LoginTicketMapper)</p></li><li><p>如果全部合法，为用户生成一个包含过期时间的登录凭证，将凭证存入 redis 和 map 集合。(redis的key以及cookie存储loginTicket.getTicket()，value是loginTicket)</p><p>用户ID，ticket，状态status，expired</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LoginTicket loginTicket &#x3D; new LoginTicket();</span><br><span class="line">loginTicket.setUserId(user.getId());</span><br><span class="line">loginTicket.setTicket(CommunityUtil.generateUUID());</span><br><span class="line">loginTicket.setStatus(0);</span><br><span class="line">loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));</span><br></pre></td></tr></table></figure></li><li><pre><code>@Insert({        &quot;insert into login_ticket(user_id,ticket,status,expired) &quot;,        &quot;values(#{userId},#{ticket},#{status},#{expired})&quot;})@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)int insertLoginTicket(LoginTicket loginTicket);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**根据返回的 map 是否包含登陆凭证判断登陆状态**</span><br><span class="line"></span><br><span class="line">- 如果登录成功，将凭证存入 cookie 并重定向至首页。</span><br><span class="line">- 如果登陆失败，将 map 中的错误信息添加到 Model 对象，返回登录页。</span><br><span class="line"></span><br><span class="line">### 会话管理</span><br><span class="line"></span><br><span class="line">### 显示登录信息</span><br><span class="line"></span><br><span class="line">(HttpServletResponse)</span><br><span class="line"></span><br><span class="line">创建 CookieUtil 工具类，通过 name 查询对应 cookie 的 value。</span><br><span class="line"></span><br><span class="line">在 UserService 中新增 &#96;findLoginTicket&#96; 方法，根据 ticket 查询 LoginTicket。(redis的key以及cookie存储loginTicket.getTicket()，value是loginTicket)</span><br></pre></td></tr></table></figure>          // 检查凭证是否有效          if (loginTicket != null &amp;&amp; loginTicket.getStatus() == 0 &amp;&amp; loginTicket.getExpired().after(new Date())) {              // 根据凭证查询用户<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">创建 HostHolder 类用来模拟 session 的功能，利用 ThreadLocal 实现，存储用户信息。</span><br></pre></td></tr></table></figure>hostHolder.setUser(user);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">创建 LoginTicketInterceptor 拦截器，实现 HandlerInterceptor 接口。</span><br><span class="line"></span><br><span class="line">- 在 &#96;preHandle&#96; 方法中通过 CookieUtil 的 &#96;getValue&#96; 方法查询是否有凭证 cookie，如果有则通过 UserService 的  &#96;findloginTicket&#96; 方法查询用户 ID，再通过用户 ID 查询用户。最后将用户放入 hostHolder 中。</span><br><span class="line">- 在 &#96;postHandle&#96; 方法中通过 hostHolder 的 &#96;get&#96; 方法获取用户，并将其存入视图中。</span><br><span class="line">- 在 &#96;afterCompletion&#96; 方法中清除 hostHolder 中存放的用户信息。</span><br><span class="line"></span><br><span class="line">创建 WebMvcConfig 配置类，实现 WebMvcConfigurer接口，配置 LoginTicketInterceptor，拦截除了静态资源之外的所有路径。</span><br><span class="line"></span><br><span class="line">### 检查登录状态</span><br><span class="line"></span><br><span class="line">**目标**：防止用户通过url直接访问相应的页面。</span><br><span class="line"></span><br><span class="line">只处理带有自定义注解的方法，防止用户在未登录情况下通过 url 访问没有权限的页面。</span><br></pre></td></tr></table></figure>@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)//有效的时长public @interface LoginRequired {}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">利用 ThreadLocal 创建 HostHolder 类，包括 &#96;set&#96;、&#96;get&#96;、&#96;remove&#96; 方法，模拟 session 存储用户信息。</span><br><span class="line"></span><br><span class="line">通过实现 HandlerInterceptor 接口创建一个拦截器，在 &#96;preHandle&#96; 方法中通过查询是否有登录凭证的 cookie，如果有则通过登录凭证查询用户 ID，再通过用户 ID 查询用户。最后将用户放入 hostHolder 中，在本次请求中持有用户信息。</span><br><span class="line"></span><br><span class="line">创建 &#96;@LoginRequired&#96; 自定义注解，作用范围在方法上，有效期为运行时。为需要在登录状态下调用的方法，例如修改密码、上传头像等方法上等加上自定义注解。</span><br><span class="line"></span><br><span class="line">创建拦截器，在 &#96;preHandle&#96; 中判断方法是否添加了 &#96;@LoginRequired&#96; 注解，如果加了并且从 hostHolder 获取不到用户则拒绝访问。</span><br></pre></td></tr></table></figure>@Componentpublic class LoginRequiredInterceptor implements HandlerInterceptor {  @Autowired  private HostHolder hostHolder;  @Override  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {      if (handler instanceof HandlerMethod) { // 是不是方法          HandlerMethod handlerMethod = (HandlerMethod) handler;          Method method = handlerMethod.getMethod();                    LoginRequired loginRequired = method.getAnnotation(LoginRequired.class); // 获取注解          if (loginRequired != null &amp;&amp; hostHolder.getUser() == null) {              response.sendRedirect(request.getContextPath() + &quot;/login&quot;);              return false;          }      }      return true;  }}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在webMVC中排除掉静态资源</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  2 2</span><br></pre></td></tr></table></figure>public void addInterceptors(InterceptorRegistry registry) {      registry.addInterceptor(alphaInterceptor)              .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;)              .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 发帖、评论、私信</span><br><span class="line"></span><br><span class="line">**敏感词过滤**</span><br><span class="line"></span><br><span class="line">- 创建静态内部类 TrieNode ，通过 boolean 结束符判断是否匹配到关键字尾部。</span><br><span class="line">- 利用 &#96;@PostConstruct&#96; 注解，在构造方法执行后初始化字典树。</span><br><span class="line">- 添加 &#96;filter&#96; 方法，利用双指针进行匹配，过滤敏感词。</span><br><span class="line"></span><br><span class="line">**发帖、评论、私信**</span><br><span class="line"></span><br><span class="line">- 对内容进行 HTML 转义以及过滤敏感词。</span><br><span class="line"></span><br><span class="line">- 将信息插入数据库的帖子&#x2F;评论&#x2F;消息表。</span><br><span class="line"></span><br><span class="line">  发帖</span><br><span class="line">  </span><br><span class="line">  涉及的数据库的字段：用户id，title，content，createTime</span><br></pre></td></tr></table></figure>@RequestMapping(path = &quot;/add&quot;, method = RequestMethod.POST)@ResponseBodypublic String addDiscussPost(String title, String content) {  User user = hostHolder.getUser();  if (user == null) {      return CommunityUtil.getJSONString(403, &quot;你还没有登录哦!&quot;);  }  DiscussPost post = new DiscussPost();  post.setUserId(user.getId());  post.setTitle(title);  post.setContent(content);  post.setCreateTime(new Date());  discussPostService.addDiscussPost(post);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>public int addDiscussPost(DiscussPost post) {  if (post == null) {      throw new IllegalArgumentException(&quot;参数不能为空!&quot;);  }  // 转义HTML标记  post.setTitle(HtmlUtils.htmlEscape(post.getTitle()));  post.setContent(HtmlUtils.htmlEscape(post.getContent()));  // 过滤敏感词  post.setTitle(sensitiveFilter.filter(post.getTitle()));  post.setContent(sensitiveFilter.filter(post.getContent()));  return discussPostMapper.insertDiscussPost(post);}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>&lt;insert id=&quot;insertDiscussPost&quot; parameterType=&quot;DiscussPost&quot; keyProperty=&quot;id&quot;&gt;  insert into discuss_post(&lt;include refid=&quot;insertFields&quot;&gt;&lt;/include&gt;)  values(#{userId},#{title},#{content},#{type},#{status},#{createTime},#{commentCount},#{score})&lt;/insert&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">帖子详情</span><br><span class="line"></span><br><span class="line">- 通过帖子id，查出帖子的相关信息</span><br></pre></td></tr></table></figure>DiscussPost post = discussPostService.findDiscussPostById(discussPostId);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 根据帖子实体传来的用户id查出作者</span><br></pre></td></tr></table></figure>User user = userService.findUserById(post.getUserId());<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 根据帖子类型和帖子id找出点赞数量</span><br></pre></td></tr></table></figure>long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>///点赞状态int likeStatus = hostHolder.getUser() == null ? 0 :              likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 获取评论列表</span><br></pre></td></tr></table></figure>List&lt;Comment&gt; commentList = commentService.findCommentsByEntity(          ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 对每一个评论，也会根据评论进行查询</span><br></pre></td></tr></table></figure>        List&lt;Comment&gt; replyList = commentService.findCommentsByEntity(                        ENTITY_TYPE_COMMENT, comment.getId(), 0, Integer.MAX_VALUE);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>public String getDiscussPost(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Model model, Page page) {  // 帖子  DiscussPost post = discussPostService.findDiscussPostById(discussPostId);  model.addAttribute(&quot;post&quot;, post);  // 作者  User user = userService.findUserById(post.getUserId());  model.addAttribute(&quot;user&quot;, user);  // 点赞数量  long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);  model.addAttribute(&quot;likeCount&quot;, likeCount);  // 点赞状态  int likeStatus = hostHolder.getUser() == null ? 0 :          likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);  model.addAttribute(&quot;likeStatus&quot;, likeStatus);  // 评论分页信息  page.setLimit(5);  page.setPath(&quot;/discuss/detail/&quot; + discussPostId);  page.setRows(post.getCommentCount());  // 评论: 给帖子的评论  // 回复: 给评论的评论  // 评论列表  List&lt;Comment&gt; commentList = commentService.findCommentsByEntity(          ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());  // 评论VO列表  List&lt;Map&lt;String, Object&gt;&gt; commentVoList = new ArrayList&lt;&gt;();  if (commentList != null) {      for (Comment comment : commentList) {          // 评论VO          // 评论          // 作者          // 点赞数量          // 点赞状态</code></pre></li></ul><pre><code>        // 回复列表        // 回复VO列表        List&lt;Map&lt;String, Object&gt;&gt; replyVoList = new ArrayList&lt;&gt;();        if (replyList != null) {            for (Comment reply : replyList) {                // 回复                // 作者                // 回复目标                // 点赞数量                // 点赞状态            }        }        // 回复数量    }}model.addAttribute(&quot;comments&quot;, commentVoList);return &quot;/site/discuss-detail&quot;;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">帖子列表</span><br><span class="line"></span><br><span class="line">添加评论</span><br></pre></td></tr></table></figure><insert id="insertComment" parametertype="Comment">    insert into comment(<include refid="insertFields"></include>)    values(#{userId},#{entityType},#{entityId},#{targetId},#{content},#{status},#{createTime})</insert><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">事务管理：</span><br></pre></td></tr></table></figure>// REQUIRED: 支持当前事务(外部事务),如果不存在则创建新事务.// REQUIRES_NEW: 创建一个新事务,并且暂停当前事务(外部事务).// NESTED: 如果当前存在事务(外部事务),则嵌套在该事务中执行(独立的提交和回滚),否则就会REQUIRED一样.@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 点赞</span><br><span class="line"></span><br><span class="line">创建 RedisKeyUtil 工具类，通过实体类型和实体 id 生成对应实体获得赞的 key。、</span><br><span class="line"></span><br><span class="line">需要四个字段</span><br></pre></td></tr></table></figure>int userId, int entityType, int entityId, int entityUserId<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">点赞&#x2F;取消点赞：</span><br><span class="line"></span><br><span class="line">- 通过 RedisKeyUtil 获得实体点赞的 key，然后通过 RedisTemplate 的 API 操作，调用集合的 &#96;isMember&#96; 方法查询 userId 是否存在于对应集合中，如果存在则移除出点赞的用户集合，如果不存在则添加到点赞的用户集合。</span><br><span class="line">- 通过 RedisTemplate 的 &#96;execute&#96; 方法实现事务，保证被点赞用户点和点赞用户的数据更新一致。通过 &#96;isMember&#96; 方法查询用户的点赞状态，之后通过 &#96;mutli&#96; 方法开启事务。</span><br><span class="line"></span><br><span class="line">点赞数量：通过调用 set 集合的 &#96;size&#96; 方法查询元素个数。</span><br></pre></td></tr></table></figure>redisTemplate.opsForSet().size(entityLikeKey);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">点赞状态：通过 set 集合的 &#96;isMember&#96; 方法实现。</span><br></pre></td></tr></table></figure> return redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? 1 : 0;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>public void like(int userId, int entityType, int entityId, int entityUserId) {    redisTemplate.execute(new SessionCallback() {        @Override        public Object execute(RedisOperations operations) throws DataAccessException {            String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);            String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);<pre><code>        boolean isMember = operations.opsForSet().isMember(entityLikeKey, userId);        operations.multi();        if (isMember) {            operations.opsForSet().remove(entityLikeKey, userId);            operations.opsForValue().decrement(userLikeKey);        } else {            operations.opsForSet().add(entityLikeKey, userId);            operations.opsForValue().increment(userLikeKey);        }        return operations.exec();    }});</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@Configuration<br>public class RedisConfig {</p><pre><code>@Beanpublic RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {    RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();    template.setConnectionFactory(factory);    // 设置key的序列化方式    template.setKeySerializer(RedisSerializer.string());    // 设置value的序列化方式    template.setValueSerializer(RedisSerializer.json());    // 设置hash的key的序列化方式    template.setHashKeySerializer(RedisSerializer.string());    // 设置hash的value的序列化方式    template.setHashValueSerializer(RedisSerializer.json());    template.afterPropertiesSet();    return template;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 某个实体的赞<br>// like:entity:entityType:entityId -&gt; set(userId)<br>public static String getEntityLikeKey(int entityType, int entityId) {<br>    return PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 关注和粉丝</span><br><span class="line"></span><br><span class="line">在 RedisUnitl 工具类增加两个方法</span><br><span class="line"></span><br><span class="line">- 通过用户 id 和实体类型获得用户关注的实体集合的 key。</span><br><span class="line"></span><br><span class="line">- 通过实体类型和实体 id 获得实体拥有的粉丝集合的 key。</span><br><span class="line"></span><br><span class="line">当用户关注某实体时，</span><br><span class="line"></span><br><span class="line">- 将实体 id 和时间作为 value 和 score 加入用户的关注集合。</span><br><span class="line">- 将用户 id 和时间作为 value 和 score 加入实体的粉丝集合。</span><br><span class="line"></span><br><span class="line">当用户取消关注某实体时，将实体从用户的关注集合移除，用户从实体的粉丝集合移除。</span><br><span class="line"></span><br><span class="line">**关注列表和粉丝列表**</span><br><span class="line"></span><br><span class="line">需要三个变量</span><br></pre></td></tr></table></figure><p>int userId, int entityType, int entityId</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">某人的关注，就以userId和关注的类型entityType作为key，以entityID作为value进行设置，传入当前时间作为zset的score</span><br><span class="line"></span><br><span class="line">某个实体的粉丝，就以entityType, entityId作为key，以userID作为value进行设置，传入当前时间作为zset的score</span><br><span class="line"></span><br><span class="line">- 用户的关注列表，通过 zset 的  &#96;reverseRange&#96; 获取 value 即关注用户的 userId，再查询出 user，通过 &#96;score&#96; 获取关注时间。</span><br><span class="line">- 用户的粉丝列表，通过 zset 的  &#96;reverseRange&#96; 获取 value 即粉丝的 userId，再查询出 user，通过 &#96;score&#96; 获取关注时间。</span><br><span class="line">- 列表信息封装在 list 集合中，再将 list 添加到 Model 对象里。</span><br></pre></td></tr></table></figure><p>public void follow(int userId, int entityType, int entityId) {<br>    redisTemplate.execute(new SessionCallback() {<br>        @Override<br>        public Object execute(RedisOperations operations) throws DataAccessException {<br>            String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);<br>            String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);</p><pre><code>        operations.multi();        operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());        operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());        return operations.exec();    }});</code></pre><p>}</p><p>public void unfollow(int userId, int entityType, int entityId) {<br>    redisTemplate.execute(new SessionCallback() {<br>        @Override<br>        public Object execute(RedisOperations operations) throws DataAccessException {<br>            String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);<br>            String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);</p><pre><code>        operations.multi();        operations.opsForZSet().remove(followeeKey, entityId);        operations.opsForZSet().remove(followerKey, userId);        return operations.exec();    }});</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 查询某用户关注的人<br>public List&lt;Map&lt;String, Object&gt;&gt; findFollowees(int userId, int offset, int limit) {<br>    String followeeKey = RedisKeyUtil.getFolloweeKey(userId, ENTITY_TYPE_USER);<br>    Set<Integer> targetIds = redisTemplate.opsForZSet().reverseRange(followeeKey, offset, offset + limit - 1);</Integer></p><pre><code>if (targetIds == null) {    return null;}List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();for (Integer targetId : targetIds) {    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    User user = userService.findUserById(targetId);    map.put(&quot;user&quot;, user);    Double score = redisTemplate.opsForZSet().score(followeeKey, targetId);    map.put(&quot;followTime&quot;, new Date(score.longValue()));    list.add(map);}return list;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 查询某用户的粉丝<br>public List&lt;Map&lt;String, Object&gt;&gt; findFollowers(int userId, int offset, int limit) {<br>    String followerKey = RedisKeyUtil.getFollowerKey(ENTITY_TYPE_USER, userId);<br>    Set<Integer> targetIds = redisTemplate.opsForZSet().reverseRange(followerKey, offset, offset + limit - 1);</Integer></p><pre><code>if (targetIds == null) {    return null;}List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();for (Integer targetId : targetIds) {    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    User user = userService.findUserById(targetId);    map.put(&quot;user&quot;, user);    Double score = redisTemplate.opsForZSet().score(followerKey, targetId);    map.put(&quot;followTime&quot;, new Date(score.longValue()));    list.add(map);}return list;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### Kafka</span><br><span class="line"></span><br><span class="line">### 发送系统通知</span><br><span class="line"></span><br><span class="line">在 CommunityConstant 接口中新增三个常量，代表三个主题：评论、点赞、关注。</span><br><span class="line"></span><br><span class="line">创建 Event 类，封装事件对象，包括主题、用户 id、实体类型、实体 id、实体用户 id 以及一个 map 集合存放其它信息。</span><br></pre></td></tr></table></figure><p>public class Event {</p><pre><code>private String topic;private int userId;private int entityType;private int entityId;private int entityUserId;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 触发事件</span><br><span class="line"></span><br><span class="line">创建 EventProducer 事件生产者，新增 &#96;fireEvent(Event event)&#96; 方法，通过 Event 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 KafkaTemplate 实例的 send 方法发送。</span><br><span class="line"></span><br><span class="line">在 CommentController、LikeControler、FollowController 中注入 EventProducer 实例，分别重构 &#96;addComment&#96; 方法、&#96;like&#96; 方法、&#96;follow&#96; 方法，封装 Event 对象，然后调用 EventProducer 的&#96;fireEvent&#96; 方法发布通知。</span><br><span class="line"></span><br><span class="line">#### 消费事件</span><br><span class="line"></span><br><span class="line">创建 EventConsumer 事件消费者，消费者是被动触发的。</span><br><span class="line"></span><br><span class="line">- 注入 MessageService 实例。</span><br><span class="line"></span><br><span class="line">- 增加 &#96;handleCommentMessage(ConsumerRecord record)&#96; 方法，通过 &#96;@KafkaListener&#96; 注解，topic 包括了评论、点赞和关注。从 recored 中获取信息，封装成 Message 对象然后调用 &#96;addMessage&#96; 方法插入数据库。</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 发送站内通知</span><br><span class="line">          Message message &#x3D; new Message();</span><br><span class="line">          message.setFromId(SYSTEM_USER_ID);</span><br><span class="line">          message.setToId(event.getEntityUserId());</span><br><span class="line">          message.setConversationId(event.getTopic());</span><br><span class="line">          message.setCreateTime(new Date());</span><br><span class="line"></span><br><span class="line">【问题】没有向数据库插入系统通知记录，原因是 ServiceLogAspect 类进行日志处理时要获取 ServletRequestAttributes 请求对象，Kafka 的消费事件是自动触发的，没有进行新的请求，产生了请求对象的空指针异常。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 显示系统通知</span><br></pre></td></tr></table></figure><p>public class Message {</p><pre><code>private int id;private int fromId;private int toId;private String conversationId;private String content;private int status;private Date createTime;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 通知列表</span><br></pre></td></tr></table></figure><p> // 修改消息的状态<br>    int updateStatus(List<Integer> ids, int status);</Integer></p><pre><code>// 查询某个主题下最新的通知Message selectLatestNotice(int userId, String topic);// 查询某个主题所包含的通知数量int selectNoticeCount(int userId, String topic);// 查询未读的通知的数量int selectNoticeUnreadCount(int userId, String topic);// 查询某个主题所包含的通知列表List&lt;Message&gt; selectNotices(int userId, String topic, int offset, int limit);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 MessageMapper 接口中</span><br></pre></td></tr></table></figure><p>map.put(“unreadCount”, messageService.findLetterUnreadCount(user.getId(), message.getConversationId()));</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 新增 &#96;selectLatestNotice(int userId, String topic)&#96; 方法，查询某主题最新的通知。</span><br><span class="line">- 新增 &#96;selectNoticeCount(int userId, String topic)&#96; 方法，查询某主题通知的数量。</span><br><span class="line"></span><br><span class="line">- 新增 &#96;selectNoticeUnreadCount(int userId, String topic)&#96; 方法，查询未读通知的数量。</span><br><span class="line"></span><br><span class="line">- 在 &#96;message-mapper.xml&#96; 配置三个方法的 sql 语句，其中查询未读通知时使用 if 动态语句，如果没有传入 topic 就查询未读总量。</span><br><span class="line"></span><br><span class="line">在业务层的 MessageService 中</span><br><span class="line"></span><br><span class="line">- 新增 &#96;findLatestNotice&#96; 方法，调用 &#96;selectLatestNotice&#96; 方法查询最新通知。</span><br><span class="line"></span><br><span class="line">- 新增 &#96;findNoticeCount&#96; 方法，调用 &#96;selectNoticeCount&#96; 方法查询某主题通知的数量。</span><br><span class="line">- 新增 &#96;findNoticeUnreadCount&#96; 方法，调用 &#96;selectNoticeUnreadCount&#96; 方法查询未读通知的数量。</span><br><span class="line"></span><br><span class="line">在表现层的 MessageController 中新增 &#96;getNoticeList&#96; 方法，获取通知列表</span><br><span class="line"></span><br><span class="line">- 调用业务层 MessageService 的方法查询评论、点赞、关注的通知，将其封装在一个 HashMap 集合中然后添加到 Model 对象里。</span><br><span class="line">- 调用业务层 MessageService 的方法查询私信和通知的总未读数量，添加到 Model 对象里。</span><br><span class="line">- 返回 &#96;notice.html&#96; 页面。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 显示通知详情</span><br><span class="line"></span><br><span class="line">在 MessageMapper 接口新增 &#96;selectNotices&#96; 方法，查询某个主题的通知列表，在 &#96;message-mapper.xml&#96; 配置 SQL。</span><br><span class="line"></span><br><span class="line">在业务层的 MessageService 中新增 &#96;findNotices&#96; 方法，调用 &#96;selectNotices&#96; 方法。</span><br><span class="line"></span><br><span class="line">在表现层的 MessageController 中新增 &#96;getNoticeDetail&#96; 方法</span><br><span class="line"></span><br><span class="line">- 调用 &#96;findNotices&#96; 方法获取通知列表详情，封装到 List 集合并存入 Model 对象。</span><br><span class="line">- 从通知集合中获取 id 集合，调用 &#96;readMessage&#96; 方法将消息设为已读。</span><br><span class="line">- 返回 &#96;notice-detail.html&#96; 页面。</span><br></pre></td></tr></table></figure><p>  2已读<br>  0未读<br>  <select id="selectNoticeCount" resulttype="int"><br>        select count(id) from message<br>        where status != 2<br>        and from_id = 1<br>        and to_id = #{userId}<br>        and conversation_id = #{topic}<br>    </select></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 显示未读通知总数</span><br><span class="line"></span><br><span class="line">创建 MessageInterceptor 拦截器</span><br><span class="line"></span><br><span class="line">- 注入 MessageService 实例和 HostHolder 实例。</span><br><span class="line">- 重写 &#96;postHandle&#96; 方法，查询私信和通知的未读数量和，然后添加到 ModelAndView 对象。</span><br><span class="line"></span><br><span class="line">在 WebConfig 中注入 MessageInterceptor 实例，并在 &#96;addInterceptors&#96; 方法中添加该拦截器。</span><br></pre></td></tr></table></figure><pre><code>public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    User user = hostHolder.getUser();    if (user != null &amp;&amp; modelAndView != null) {        int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);        int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);        modelAndView.addObject(&quot;allUnreadCount&quot;, letterUnreadCount + noticeUnreadCount);    }</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**发送系统通知**</span><br><span class="line"></span><br><span class="line">创建 Event 类，封装事件对象，包括主题（评论、点赞、关注）、用户 id、实体类型、实体 id，以及一个 map 集合存放其它信息.</span><br></pre></td></tr></table></figure><p>public class Event {</p><pre><code>private String topic;private int userId;private int entityType;private int entityId;private int entityUserId;private Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**触发事件**</span><br><span class="line"></span><br><span class="line">通过 Event 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 KafkaTemplate 实例的 send 方法发送。</span><br></pre></td></tr></table></figure><p>public class EventProducer {</p><pre><code>@Autowiredprivate KafkaTemplate kafkaTemplate;// 处理事件public void fireEvent(Event event) {    // 将事件发布到指定的主题    kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 触发发帖事件<br>Event event = new Event()<br>        .setTopic(TOPIC_PUBLISH)<br>        .setUserId(user.getId())<br>        .setEntityType(ENTITY_TYPE_POST)<br>        .setEntityId(post.getId());<br>eventProducer.fireEvent(event);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**消费事件**</span><br><span class="line"></span><br><span class="line">通过 &#96;@KafkaListener&#96; 注解，topic 包括了评论、点赞和关注。从 recored 中获取信息，封装成 Message 对象然后调用 &#96;addMessage&#96; 方法插入数据库。</span><br></pre></td></tr></table></figure><pre><code>// 消费发帖事件@KafkaListener(topics = {TOPIC_PUBLISH})public void handlePublishMessage(ConsumerRecord record) {    if (record == null || record.value() == null) {        logger.error(&quot;消息的内容为空!&quot;);        return;    }    Event event = JSONObject.parseObject(record.value().toString(), Event.class);    if (event == null) {        logger.error(&quot;消息格式错误!&quot;);        return;    }    DiscussPost post = discussPostService.findDiscussPostById(event.getEntityId());    elasticsearchService.saveDiscussPost(post);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### UV</span><br><span class="line"></span><br><span class="line">Unique Visitor 独立游客</span><br><span class="line"></span><br><span class="line">通过用户IP排重统计数据。</span><br><span class="line"></span><br><span class="line">### DAU</span><br><span class="line"></span><br><span class="line">Daily Active User  日活跃用户</span><br><span class="line"></span><br><span class="line">通过用户ID排重统计数据</span><br><span class="line"></span><br><span class="line">![image-20201115211418953](C:\Users\77406\AppData\Roaming\Typora\typora-user-images\image-20201115211418953.png)</span><br><span class="line"></span><br><span class="line">首先就在preHandle那里，通过HttpServletRequest的getRemoteHost（）来获取相应的IP，随后以日期为key，ip为value进行插入opsForHyperLogLog().add来加入。如果我们要统计一定时间的UV的话，我们会有一个Date类型的start和end，接下来 使用Calendar 来对时间进行遍历，存到一个List里面，然后通过opsForHyperLogLog().union(redisKey, keyList.toArray())来合并，随后通过opsForHyperLogLog().size（redisKey）来返回统计的结果</span><br></pre></td></tr></table></figure><pre><code>@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {    // 统计UV    String ip = request.getRemoteHost();    dataService.recordUV(ip);    // 统计DAU    User user = hostHolder.getUser();    if (user != null) {        dataService.recordDAU(user.getId());    }    return true;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// 将指定的IP计入UV<br>public void recordUV(String ip) {<br>    String redisKey = RedisKeyUtil.getUVKey(df.format(new Date()));<br>    redisTemplate.opsForHyperLogLog().add(redisKey, ip);<br>}</p><p>// 统计指定日期范围内的UV<br>public long calculateUV(Date start, Date end) {<br>    if (start == null || end == null) {<br>        throw new IllegalArgumentException(“参数不能为空!”);<br>    }</p><pre><code>// 整理该日期范围内的keyList&lt;String&gt; keyList = new ArrayList&lt;&gt;();Calendar calendar = Calendar.getInstance();calendar.setTime(start);while (!calendar.getTime().after(end)) {    String key = RedisKeyUtil.getUVKey(df.format(calendar.getTime()));    keyList.add(key);    calendar.add(Calendar.DATE, 1);}// 合并这些数据String redisKey = RedisKeyUtil.getUVKey(df.format(start), df.format(end));redisTemplate.opsForHyperLogLog().union(redisKey, keyList.toArray());// 返回统计的结果return redisTemplate.opsForHyperLogLog().size(redisKey);</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DAU的计算</span><br><span class="line"></span><br><span class="line">    public void recordDAU(int userId) &#123;</span><br><span class="line">        String redisKey &#x3D; RedisKeyUtil.getDAUKey(df.format(new Date()));</span><br><span class="line">        redisTemplate.opsForValue().setBit(redisKey, userId, true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 统计指定日期范围内的DAU</span><br><span class="line">    public long calculateDAU(Date start, Date end) &#123;</span><br><span class="line">        if (start &#x3D;&#x3D; null || end &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;参数不能为空!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#x2F;&#x2F; 整理该日期范围内的key</span><br><span class="line">    List&lt;byte[]&gt; keyList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">    calendar.setTime(start);</span><br><span class="line">    while (!calendar.getTime().after(end)) &#123;</span><br><span class="line">        String key &#x3D; RedisKeyUtil.getDAUKey(df.format(calendar.getTime()));</span><br><span class="line">        keyList.add(key.getBytes());</span><br><span class="line">        calendar.add(Calendar.DATE, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 进行OR运算</span><br><span class="line">    return (long) redisTemplate.execute(new RedisCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object doInRedis(RedisConnection connection) throws DataAccessException &#123;</span><br><span class="line">            String redisKey &#x3D; RedisKeyUtil.getDAUKey(df.format(start), df.format(end));</span><br><span class="line">            connection.bitOp(RedisStringCommands.BitOperation.OR,</span><br><span class="line">                    redisKey.getBytes(), keyList.toArray(new byte[0][0]));</span><br><span class="line">            return connection.bitCount(redisKey.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">### Guava</span><br></pre></td></tr></table></figure><p>@PostConstruct<br>public void init() {<br>    // 初始化帖子列表缓存<br>    postListCache = Caffeine.newBuilder()<br>            .maximumSize(maxSize)<br>            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)<br>            .build(new CacheLoader&lt;String, List<DiscussPost>&gt;() {<br>                @Nullable<br>                @Override<br>                public List<DiscussPost> load(@NonNull String key) throws Exception {<br>                    if (key == null || key.length() == 0) {<br>                        throw new IllegalArgumentException(“参数错误!”);<br>                    }</DiscussPost></DiscussPost></p><pre><code>                String[] params = key.split(&quot;:&quot;);                if (params == null || params.length != 2) {                    throw new IllegalArgumentException(&quot;参数错误!&quot;);                }                int offset = Integer.valueOf(params[0]);                int limit = Integer.valueOf(params[1]);                // 二级缓存: Redis -&gt; mysql                logger.debug(&quot;load post list from DB.&quot;);                return discussPostMapper.selectDiscussPosts(0, offset, limit, 1);            }        });// 初始化帖子总数缓存postRowsCache = Caffeine.newBuilder()        .maximumSize(maxSize)        .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)        .build(new CacheLoader&lt;Integer, Integer&gt;() {            @Nullable            @Override            public Integer load(@NonNull Integer key) throws Exception {                logger.debug(&quot;load post rows from DB.&quot;);                return discussPostMapper.selectDiscussPostRows(key);            }        });</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Quartz</span><br><span class="line"></span><br><span class="line">Quartz</span><br><span class="line"></span><br><span class="line">- 调度器：Scheduler</span><br><span class="line">- 任务：JobDetail</span><br><span class="line">- 触发器：Trigger，包括SimpleTrigger和CronTrigger</span><br><span class="line"></span><br><span class="line">![这里写图片描述](https:&#x2F;&#x2F;img-blog.csdn.net&#x2F;20180710135431806?watermark&#x2F;2&#x2F;text&#x2F;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M&#x3D;&#x2F;font&#x2F;5a6L5L2T&#x2F;fontsize&#x2F;400&#x2F;fill&#x2F;I0JBQkFCMA&#x3D;&#x3D;&#x2F;dissolve&#x2F;70)</span><br></pre></td></tr></table></figure><p>// FactoryBean可简化Bean的实例化过程:<br>// 1.通过FactoryBean封装Bean的实例化过程.<br>// 2.将FactoryBean装配到Spring容器里.<br>// 3.将FactoryBean注入给其他的Bean.<br>// 4.该Bean得到的是FactoryBean所管理的对象实例.</p><pre><code>// 刷新帖子分数任务@Beanpublic JobDetailFactoryBean postScoreRefreshJobDetail() {    JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();    factoryBean.setJobClass(PostScoreRefreshJob.class);    factoryBean.setName(&quot;postScoreRefreshJob&quot;);    factoryBean.setGroup(&quot;communityJobGroup&quot;);    factoryBean.setDurability(true);    factoryBean.setRequestsRecovery(true);    return factoryBean;}@Beanpublic SimpleTriggerFactoryBean postScoreRefreshTrigger(JobDetail postScoreRefreshJobDetail) {    SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();    factoryBean.setJobDetail(postScoreRefreshJobDetail);    factoryBean.setName(&quot;postScoreRefreshTrigger&quot;);    factoryBean.setGroup(&quot;communityTriggerGroup&quot;);    factoryBean.setRepeatInterval(1000 * 60 * 5);    factoryBean.setJobDataMap(new JobDataMap());    return factoryBean;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">log(评论数*10+点赞数*2)</span><br><span class="line"></span><br><span class="line">新加帖子，先把id作为value加入、</span><br></pre></td></tr></table></figure><p>Comment<br>String redisKey = RedisKeyUtil.getPostScoreKey();<br>redisTemplate.opsForSet().add(redisKey, discussPostId);<br>点赞<br>           // 计算帖子分数<br>            String redisKey = RedisKeyUtil.getPostScoreKey();<br>            redisTemplate.opsForSet().add(redisKey, postId);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不需要刷新</span><br></pre></td></tr></table></figure><pre><code>String redisKey = RedisKeyUtil.getPostScoreKey();BoundSetOperations operations = redisTemplate.boundSetOps(redisKey);if (operations.size() == 0) {    logger.info(&quot;[任务取消] 没有需要刷新的帖子!&quot;);    return;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> epoch = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”).parse(“2014-08-01 00:00:00”);</p><p> double score = Math.log10(Math.max(w, 1))<br>                + (post.getCreateTime().getTime() - epoch.getTime()) / (1000 * 3600 * 24);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">页面的排序</span><br></pre></td></tr></table></figure><p>@RequestParam(name = “orderMode”, defaultValue = “0”)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>&lt;select id=&quot;selectDiscussPosts&quot; resultType=&quot;DiscussPost&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from discuss_post    where status != 2    &lt;if test=&quot;userId!=0&quot;&gt;        and user_id = #{userId}    &lt;/if&gt;    &lt;if test=&quot;orderMode==0&quot;&gt;        order by type desc, create_time desc    &lt;/if&gt;    &lt;if test=&quot;orderMode==1&quot;&gt;        order by type desc, score desc, create_time desc    &lt;/if&gt;    limit #{offset}, #{limit}&lt;/select&gt;</code></pre><p>```</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>编译期和运行时注解的区别</p><p>怎么样去实现一个编译型的注解</p><p>注解是如何注入的（不是声明，是底层原理！）通用的逻辑注入的原理，是这样完成的</p><p>lamda为什么能推导出哪个类型（参数中为什么只写x，y就够了）</p><p>mybatis mapper为啥不需要实现类，jdk动态代理原理</p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拆分为dubbo</title>
      <link href="/2020/10/30/%E6%8B%86%E5%88%86%E4%B8%BAdubbo/"/>
      <url>/2020/10/30/%E6%8B%86%E5%88%86%E4%B8%BAdubbo/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="gateway"><a href="#gateway" class="headerlink" title="gateway"></a>gateway</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Reference(interfaceClass &#x3D; RedisServiceApi.class)</span><br></pre></td></tr></table></figure><h4 id="总的pom"><a href="#总的pom" class="headerlink" title="总的pom"></a>总的pom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"> </span><br><span class="line">&lt;groupId&gt;com.example&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dubbodemo&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"> </span><br><span class="line">&lt;name&gt;dubbodemo&lt;&#x2F;name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"> </span><br><span class="line">&lt;modules&gt;</span><br><span class="line">&lt;module&gt;provider&lt;&#x2F;module&gt;</span><br><span class="line">&lt;module&gt;consumer&lt;&#x2F;module&gt;</span><br><span class="line">&lt;module&gt;api&lt;&#x2F;module&gt;</span><br><span class="line">&lt;&#x2F;modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><h4 id="common模块（api模块"><a href="#common模块（api模块" class="headerlink" title="common模块（api模块)"></a>common模块（api模块)</h4><p>User.java，实体类根据需要自己编写，但要注意的是需要实现Serializable这个接口</p><p>api中存放entity实体类和service接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line"> </span><br><span class="line">    private static final long serialVersionUID &#x3D; 7739394865008699599L;</span><br><span class="line"> </span><br><span class="line">    private Long id;</span><br><span class="line"> </span><br><span class="line">    private String username;</span><br><span class="line"> </span><br><span class="line">    private String password;</span><br><span class="line"> </span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setId(Long id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, password&#x3D;&#39;&quot; + password + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通用模块的pom"><a href="#通用模块的pom" class="headerlink" title="通用模块的pom"></a>通用模块的pom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;name&gt;dis-seckill-common&lt;&#x2F;name&gt;</span><br><span class="line">&lt;description&gt;通用模块&lt;&#x2F;description&gt;</span><br></pre></td></tr></table></figure><h4 id="消费者的配置文件"><a href="#消费者的配置文件" class="headerlink" title="消费者的配置文件"></a>消费者的配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 避免和provider工程端口冲突</span><br><span class="line">server.port&#x3D;7001</span><br><span class="line">## Dubbo 服务消费者配置</span><br><span class="line">spring.dubbo.application.name&#x3D;consumer &#x2F;&#x2F;模块名字</span><br><span class="line">## Dubbo 服务对象的注册中心zookeeper的地址和端口</span><br><span class="line">spring.dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;localhost:2181</span><br><span class="line">##  服务对象的被注入的包扫描范围</span><br><span class="line">spring.dubbo.scan&#x3D;com.example.consumer.controller &#x2F;&#x2F;相应的service包的位置</span><br></pre></td></tr></table></figure><p><img src="/2020/10/30/%E6%8B%86%E5%88%86%E4%B8%BAdubbo/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201030093252682.png" alt="image-20201030093252682"></p><h4 id="消费者的pom"><a href="#消费者的pom" class="headerlink" title="消费者的pom"></a>消费者的pom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    &lt;name&gt;dis-seckill-goods&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;商品模块&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 添加对api模块的依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.example&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;api&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- Spring Boot Dubbo 依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.dubbo.springboot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-dubbo&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;dubbo-spring-boot&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;&#x2F;exclusion&gt;</span><br><span class="line">&lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="服务提供者的配置"><a href="#服务提供者的配置" class="headerlink" title="服务提供者的配置"></a>服务提供者的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;8001</span><br><span class="line">## Dubbo 服务提供者配置</span><br><span class="line">spring.dubbo.application.name&#x3D;provider</span><br><span class="line">## Dubbo 服务对象的注册中心zookeeper的地址和端口</span><br><span class="line">spring.dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;localhost:2181</span><br><span class="line">## 用Dubbo协议在20880端口暴露服务</span><br><span class="line">spring.dubbo.protocol.name&#x3D;dubbo</span><br><span class="line">spring.dubbo.protocol.port&#x3D;20880</span><br><span class="line">## 包扫描范围</span><br><span class="line">spring.dubbo.scan&#x3D;com.example.provider.serviceimpl</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机常见的监控工具</title>
      <link href="/2020/10/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/10/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JDK-监控和故障处理工具总结"><a href="#JDK-监控和故障处理工具总结" class="headerlink" title="JDK 监控和故障处理工具总结"></a>JDK 监控和故障处理工具总结</h1><h2 id="JDK-命令行工具"><a href="#JDK-命令行工具" class="headerlink" title="JDK 命令行工具"></a>JDK 命令行工具</h2><p>这些命令在 JDK 安装目录下的 bin 目录下：</p><ul><li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li><li><strong><code>jstat</code></strong>（ JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li><li><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;</li><li><strong><code>jmap</code></strong> (Memory Map for Java) :生成堆转储快照;</li><li><strong><code>jhat</code></strong> (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</li><li><strong><code>jstack</code></strong> (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li></ul><h3 id="jps-查看所有-Java-进程"><a href="#jps-查看所有-Java-进程" class="headerlink" title="jps:查看所有 Java 进程"></a>jps:查看所有 Java 进程</h3><p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code> 命令。</p><p><code>jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。<code>jps -q</code> ：只输出进程的本地虚拟机唯一 ID。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">16504</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServerCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps <span class="literal">-l</span></span><br><span class="line"><span class="number">7360</span> firstNettyDemo.NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">16492</span> sun.tools.jps.Jps</span><br><span class="line"><span class="number">17340</span> firstNettyDemo.NettyServerCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p><p><code>jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p><h3 id="jstat-监视虚拟机各种运行状态信息"><a href="#jstat-监视虚拟机各种运行状态信息" class="headerlink" title="jstat: 监视虚拟机各种运行状态信息"></a>jstat: 监视虚拟机各种运行状态信息</h3><p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p><p><strong>jstat 命令使用格式：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-<span class="type">t</span>] [-<span class="type">h</span>&lt;<span class="type">lines</span>&gt;] &lt;vmid&gt; [&lt;<span class="built_in">int</span><span class="type">erval</span>&gt; [&lt;<span class="type">count</span>&gt;]]Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>比如 <code>jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p><p><strong>常见的 option 如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- &#96;jstat -class vmid&#96; ：显示 ClassLoader 的</span><br><span class="line">&#96;jstat -compiler vmid&#96; ：显示 JIT 编译的相关信息；相关信息；</span><br><span class="line">&#96;jstat -gc vmid&#96; ：显示与 GC 相关的堆信息；</span><br></pre></td></tr></table></figure><ul><li><code>jstat -class vmid</code> ：显示 ClassLoader 的相关信息；</li><li><code>jstat -compiler vmid</code> ：显示 JIT 编译的相关信息；</li><li><code>jstat -gc vmid</code> ：显示与 GC 相关的堆信息；</li><li><code>jstat -gccapacity vmid</code> ：显示各个代的容量及使用情况；</li><li><code>jstat -gcnew vmid</code> ：显示新生代信息；</li><li><code>jstat -gcnewcapcacity vmid</code> ：显示新生代大小与使用情况；</li><li><code>jstat -gcold vmid</code> ：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了；</li><li><code>jstat -gcoldcapacity vmid</code> ：显示老年代的大小；</li><li><code>jstat -gcpermcapacity vmid</code> ：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了；</li><li><code>jstat -gcutil vmid</code> ：显示垃圾收集信息；</li></ul><p>另外，加上 <code>-t</code>参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。</p><h3 id="jinfo-实时地查看和调整虚拟机各项参数"><a href="#jinfo-实时地查看和调整虚拟机各项参数" class="headerlink" title="jinfo: 实时地查看和调整虚拟机各项参数"></a>jinfo: 实时地查看和调整虚拟机各项参数</h3><p><code>jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p><p><code>jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code>-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span> MaxHeapSize <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:MaxHeapSize=<span class="number">2124414976</span></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span> PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:<span class="literal">-PrintGCCopy</span> to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p><p><code>jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:<span class="literal">-PrintGC</span></span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  +PrintGC <span class="number">17340</span></span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:+PrintGCCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="jmap-生成堆转储快照"><a href="#jmap-生成堆转储快照" class="headerlink" title="jmap:生成堆转储快照"></a>jmap:生成堆转储快照</h3><p><code>jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code>jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code>“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 <code>kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p><p>-dump : 生成Java堆转储快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format&#x3D;b,file&#x3D;C:\Users\SnailClimb\Desktop\heap.dat 17340</span><br><span class="line">jmap -dump:format&#x3D;b,file&#x3D;C:\Users\SnailClimb\Desktop\heap.hprof 17340</span><br></pre></td></tr></table></figure><p>-heap：显示Java堆详细信息</p><p>-histo：显示堆中对象统计信息</p><ul><li>jmap -heap pid</li></ul><p><img src="/2020/10/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210122220123744.png" alt="image-20210122220123744"></p><p>`</p><p><code>jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在 Windows 平台下也是受限制的。</p><p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jmap <span class="literal">-dump</span>:format=b,file=C:\Users\SnailClimb\Desktop\heap.hprof <span class="number">17340</span></span><br><span class="line">Dumping heap to C:\Users\SnailClimb\Desktop\heap.hprof ...</span><br><span class="line">Heap dump file createdCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="jhat-分析-heapdump-文件"><a href="#jhat-分析-heapdump-文件" class="headerlink" title="jhat: 分析 heapdump 文件"></a>jhat: 分析 heapdump 文件</h3><p><strong><code>jhat</code></strong> 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jhat C:\Users\SnailClimb\Desktop\heap.hprof</span><br><span class="line">Reading from C:\Users\SnailClimb\Desktop\heap.hprof...</span><br><span class="line">Dump file created Sat May <span class="number">04</span> <span class="number">12</span>:<span class="number">30</span>:<span class="number">31</span> CST <span class="number">2019</span></span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving <span class="number">131419</span> objects...</span><br><span class="line">Chasing references, expect <span class="number">26</span> dots..........................</span><br><span class="line">Eliminating duplicate references..........................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port <span class="number">7000</span></span><br><span class="line">Server is ready.Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:7000/" target="_blank" rel="noopener">http://localhost:7000/</a></p><p><img src="/2020/10/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210122221040601.png" alt="image-20210122221040601"></p><h3 id="jstack-生成虚拟机当前时刻的线程快照"><a href="#jstack-生成虚拟机当前时刻的线程快照" class="headerlink" title="jstack :生成虚拟机当前时刻的线程快照"></a>jstack :生成虚拟机当前时刻的线程快照</h3><p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p><p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p><p><strong>下面是一个线程死锁的代码。我们下面会通过 <code>jstack</code> 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><p><strong>通过 <code>jstack</code> 命令分析：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">13792</span> KotlinCompileDaemon</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">8932</span> Launcher</span><br><span class="line"><span class="number">9256</span> DeadLockDemo</span><br><span class="line"><span class="number">10764</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServer</span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jstack <span class="number">9256</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>输出的部分内容如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Found one Java<span class="literal">-level</span> deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"线程 2"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000333e668 (object <span class="number">0</span>x00000000d5efe1c0, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"线程 1"</span></span><br><span class="line"><span class="string">"线程 1"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000333be88 (object <span class="number">0</span>x00000000d5efe1d0, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"线程 2"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"线程 2"</span>:</span><br><span class="line">        at DeadLockDemo.lambda<span class="variable">$main</span><span class="variable">$1</span>(DeadLockDemo.java:<span class="number">31</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo<span class="variable">$</span><span class="variable">$Lambda</span><span class="variable">$2</span>/<span class="number">1078694789</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">"线程 1"</span>:</span><br><span class="line">        at DeadLockDemo.lambda<span class="variable">$main</span><span class="variable">$0</span>(DeadLockDemo.java:<span class="number">16</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo<span class="variable">$</span><span class="variable">$Lambda</span><span class="variable">$1</span>/<span class="number">1324119927</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>可以看到 <code>jstack</code> 命令已经帮我们找到发生死锁的线程的具体信息。</p><h2 id="JDK-可视化分析工具"><a href="#JDK-可视化分析工具" class="headerlink" title="JDK 可视化分析工具"></a>JDK 可视化分析工具</h2><h3 id="JConsole-Java-监视与管理控制台"><a href="#JConsole-Java-监视与管理控制台" class="headerlink" title="JConsole:Java 监视与管理控制台"></a>JConsole:Java 监视与管理控制台</h3><p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出<code>console</code>命令启动或者在 JDK 目录下的 bin 目录找到<code>jconsole.exe</code>然后双击启动。</p><h4 id="连接-Jconsole"><a href="#连接-Jconsole" class="headerlink" title="连接 Jconsole"></a>连接 Jconsole</h4><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/1JConsole%E8%BF%9E%E6%8E%A5.png" alt="连接 Jconsole"></p><p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Djava.rmi.server.hostname</span>=<span class="string">外网访问 ip 地址 </span></span><br><span class="line"><span class="meta">-Dcom.sun.management.jmxremote.port</span>=<span class="string">60001   //监控的端口号</span></span><br><span class="line"><span class="meta">-Dcom.sun.management.jmxremote.authenticate</span>=<span class="string">false   //关闭认证</span></span><br><span class="line"><span class="meta">-Dcom.sun.management.jmxremote.ssl</span>=<span class="string">falseCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>在使用 JConsole 连接时，远程进程地址如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外网访问 ip 地址:60001 Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="查看-Java-程序概况"><a href="#查看-Java-程序概况" class="headerlink" title="查看 Java 程序概况"></a>查看 Java 程序概况</h4><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/2%E6%9F%A5%E7%9C%8BJava%E7%A8%8B%E5%BA%8F%E6%A6%82%E5%86%B5.png" alt="查看 Java 程序概况 "></p><h4 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h4><p>JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。</p><p>点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。</p><blockquote><ul><li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li></ul></blockquote><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/3%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7.png" alt="内存监控 "></p><h4 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h4><p>类似我们前面讲的 <code>jstack</code> 命令，不过这个是可视化的。</p><p>最下面有一个”检测死锁 (D)”按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/4%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7.png" alt="线程监控 "></p><h3 id="Visual-VM-多合一故障处理工具"><a href="#Visual-VM-多合一故障处理工具" class="headerlink" title="Visual VM:多合一故障处理工具"></a>Visual VM:多合一故障处理工具</h3><p>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<a href="https://visualvm.github.io/" target="_blank" rel="noopener">https://visualvm.github.io/</a> 。Visual VM 中文文档:<a href="https://visualvm.github.io/documentation.html。" target="_blank" rel="noopener">https://visualvm.github.io/documentation.html。</a></p><p>下面这段话摘自《深入理解 Java 虚拟机》。</p><blockquote><p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p></blockquote><p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p><ul><li><strong>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</strong></li><li><strong>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</strong></li><li><strong>dump 以及分析堆转储快照（jmap、jhat）。</strong></li><li><strong>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</strong></li><li><strong>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</strong></li><li><strong>其他 plugins 的无限的可能性……</strong></li></ul><h2 id="CPU占满"><a href="#CPU占满" class="headerlink" title="CPU占满"></a>CPU占满</h2><p>模拟CPU占满还是比较简单，直接写一个死循环计算消耗CPU即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 模拟CPU占满</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @GetMapping(&quot;&#x2F;cpu&#x2F;loop&quot;)</span><br><span class="line">  public void testCPULoop() throws InterruptedException &#123;</span><br><span class="line">      System.out.println(&quot;请求cpu死循环&quot;);</span><br><span class="line">      Thread.currentThread().setName(&quot;loop-thread-cpu&quot;);</span><br><span class="line">      int num &#x3D; 0;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">          num++;</span><br><span class="line">          if (num &#x3D;&#x3D; Integer.MAX_VALUE) &#123;</span><br><span class="line">              System.out.println(&quot;reset&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          num &#x3D; 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>请求接口地址测试<code>curl localhost:8080/cpu/loop</code>,发现CPU立马飙升到100%</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance1.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance1.png" alt="img"></a></p><p>通过执行<code>top -Hp 32805</code> 查看Java线程情况</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance2.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance2.png" alt="img"></a></p><p>执行 <code>printf &#39;%x&#39; 32826</code> 获取16进制的线程id，用于<code>dump</code>信息查询，结果为 <code>803a</code>。最后我们执行<code>jstack 32805 |grep -A 20 803a</code>来查看下详细的<code>dump</code>信息。</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance3.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance3.png" alt="img"></a></p><p>这里<code>dump</code>信息直接定位出了问题方法以及代码行，这就定位出了CPU占满的问题。</p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>模拟内存泄漏借助了ThreadLocal对象来完成，ThreadLocal是一个线程私有变量，可以绑定到线程上，在整个线程的生命周期都会存在，但是由于ThreadLocal的特殊性，ThreadLocal是基于ThreadLocalMap实现的，ThreadLocalMap的Entry继承WeakReference，而Entry的Key是WeakReference的封装，换句话说Key就是弱引用，弱引用在下次GC之后就会被回收，如果ThreadLocal在set之后不进行后续的操作，因为GC会把Key清除掉，但是Value由于线程还在存活，所以Value一直不会被回收，最后就会发生内存泄漏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 模拟内存泄漏</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;memory&#x2F;leak&quot;)</span><br><span class="line">    public String leak() &#123;</span><br><span class="line">        System.out.println(&quot;模拟内存泄漏&quot;);</span><br><span class="line">        ThreadLocal&lt;Byte[]&gt; localVariable &#x3D; new ThreadLocal&lt;Byte[]&gt;();</span><br><span class="line">        localVariable.set(new Byte[4096 * 1024]);&#x2F;&#x2F; 为线程添加变量</span><br><span class="line">        return &quot;ok&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们给启动加上堆内存大小限制，同时设置内存溢出的时候输出堆栈快照并输出日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Xms500m -Xmx500m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;tmp&#x2F;heapdump.hprof -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:&#x2F;tmp&#x2F;heaplog.log analysis-demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>启动成功后我们循环执行100次,<code>for i in {1..500}; do curl localhost:8080/memory/leak;done</code>,还没执行完毕，系统已经返回500错误了。查看系统日志出现了如下异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><p>我们用<code>jstat -gc pid</code> 命令来看看程序的GC情况。</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance4.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance4.png" alt="img"></a></p><p>很明显，内存溢出了，堆内存经过45次 Full Gc 之后都没释放出可用内存，这说明当前堆内存中的对象都是存活的，有GC Roots引用，无法回收。那是什么原因导致内存溢出呢？是不是我只要加大内存就行了呢？如果是普通的内存溢出也许扩大内存就行了，但是如果是内存泄漏的话，扩大的内存不一会就会被占满，所以我们还需要确定是不是内存泄漏。我们之前保存了堆 Dump 文件，这个时候借助我们的MAT工具来分析下。导入工具选择<code>Leak Suspects Report</code>，工具直接就会给你列出问题报告。</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance5.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance5.png" alt="img"></a></p><p>这里已经列出了可疑的4个内存泄漏问题，我们点击其中一个查看详情。</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance6.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance6.png" alt="img"></a></p><p>这里已经指出了内存被线程占用了接近50M的内存，占用的对象就是ThreadLocal。如果想详细的通过手动去分析的话，可以点击<code>Histogram</code>,查看最大的对象占用是谁，然后再分析它的引用关系，即可确定是谁导致的内存溢出。</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance7.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance7.png" alt="img"></a></p><p>上图发现占用内存最大的对象是一个Byte数组，我们看看它到底被那个GC Root引用导致没有被回收。按照上图红框操作指引，结果如下图：</p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/images/performance-tuning/java-performance8.png" target="_blank" rel="noopener"><img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/images/performance-tuning/java-performance8.png" alt="img"></a></p><p>我们发现Byte数组是被线程对象引用的，图中也标明，Byte数组对像的GC Root是线程，所以它是不会被回收的，展开详细信息查看，我们发现最终的内存占用对象是被ThreadLocal对象占据了。这也和MAT工具自动帮我们分析的结果一致。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁会导致耗尽线程资源，占用内存，表现就是内存占用升高，CPU不一定会飙升(看场景决定)，如果是直接new线程，会导致JVM内存被耗尽，报无法创建线程的错误，这也是体现了使用线程池的好处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> ExecutorService service &#x3D; new ThreadPoolExecutor(4, 10,</span><br><span class="line">            0, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">   &#x2F;**</span><br><span class="line">     * 模拟死锁</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;cpu&#x2F;test&quot;)</span><br><span class="line">    public String testCPU() throws InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;请求cpu&quot;);</span><br><span class="line">        Object lock1 &#x3D; new Object();</span><br><span class="line">        Object lock2 &#x3D; new Object();</span><br><span class="line">        service.submit(new DeadLockThread(lock1, lock2), &quot;deadLookThread-&quot; + new Random().nextInt());</span><br><span class="line">        service.submit(new DeadLockThread(lock2, lock1), &quot;deadLookThread-&quot; + new Random().nextInt());</span><br><span class="line">        return &quot;ok&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public class DeadLockThread implements Runnable &#123;</span><br><span class="line">    private Object lock1;</span><br><span class="line">    private Object lock2;</span><br><span class="line"></span><br><span class="line">    public DeadLockThread1(Object lock1, Object lock2) &#123;</span><br><span class="line">        this.lock1 &#x3D; lock1;</span><br><span class="line">        this.lock2 &#x3D; lock2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (lock2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;get lock2 and wait lock1&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lock1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;get lock1 and lock2 &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们循环请求接口2000次，发现不一会系统就出现了日志错误，线程池和队列都满了,由于我选择的当队列满了就拒绝的策略，所以系统直接抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@2760298 rejected from java.util.concurrent.ThreadPoolExecutor@7ea7cd51[Running, pool size &#x3D; 10, active threads &#x3D; 10, queued tasks &#x3D; 1024, completed tasks &#x3D; 846]</span><br></pre></td></tr></table></figure><p>通过<code>ps -ef|grep java</code>命令找出 Java 进程 pid，执行<code>jstack pid</code> 即可出现java线程堆栈信息，这里发现了5个死锁，我们只列出其中一个，很明显线程<code>pool-1-thread-2</code>锁住了<code>0x00000000f8387d88</code>等待<code>0x00000000f8387d98</code>锁，线程<code>pool-1-thread-1</code>锁住了<code>0x00000000f8387d98</code>等待锁<code>0x00000000f8387d88</code>,这就产生了死锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Java stack information for the threads listed above:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;pool-1-thread-2&quot;:</span><br><span class="line">        at top.luozhou.analysisdemo.controller.DeadLockThread2.run(DeadLockThread.java:30)</span><br><span class="line">        - waiting to lock &lt;0x00000000f8387d98&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000f8387d88&gt; (a java.lang.Object)</span><br><span class="line">        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;pool-1-thread-1&quot;:</span><br><span class="line">        at top.luozhou.analysisdemo.controller.DeadLockThread1.run(DeadLockThread.java:30)</span><br><span class="line">        - waiting to lock &lt;0x00000000f8387d88&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000f8387d98&gt; (a java.lang.Object)</span><br><span class="line">        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">          </span><br><span class="line"> Found 5 deadlocks.</span><br></pre></td></tr></table></figure><h2 id="线程频繁切换"><a href="#线程频繁切换" class="headerlink" title="线程频繁切换"></a>线程频繁切换</h2><p>上下文切换会导致将大量CPU时间浪费在寄存器、内核栈以及虚拟内存的保存和恢复上，导致系统整体性能下降。当你发现系统的性能出现明显的下降时候，需要考虑是否发生了大量的线程上下文切换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> @GetMapping(value &#x3D; &quot;&#x2F;thread&#x2F;swap&quot;)</span><br><span class="line">    public String theadSwap(int num) &#123;</span><br><span class="line">        System.out.println(&quot;模拟线程切换&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; num; i++) &#123;</span><br><span class="line">            new Thread(new ThreadSwap1(new AtomicInteger(0)),&quot;thread-swap&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;ok&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">public class ThreadSwap1 implements Runnable &#123;</span><br><span class="line">    private AtomicInteger integer;</span><br><span class="line"></span><br><span class="line">    public ThreadSwap1(AtomicInteger integer) &#123;</span><br><span class="line">        this.integer &#x3D; integer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            integer.addAndGet(1);</span><br><span class="line">            Thread.yield(); &#x2F;&#x2F;让出CPU资源</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我创建多个线程去执行基础的原子+1操作，然后让出 CPU 资源，理论上 CPU 就会去调度别的线程，我们请求接口创建100个线程看看效果如何，<code>curl localhost:8080/thread/swap?num=100</code>。接口请求成功后，我们执行`vmstat 1 10，表示每1秒打印一次，打印10次，线程切换采集结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line">101  0 128000 878384    908 468684    0    0     0     0 4071 8110498 14 86  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4065 8312463 15 85  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4107 8207718 14 87  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4083 8410174 14 86  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4083 8264377 14 86  0  0  0</span><br><span class="line">100  0 128000 878384    908 468688    0    0     0   108 4182 8346826 14 86  0  0  0</span><br></pre></td></tr></table></figure><p>这里我们关注4个指标，<code>r</code>,<code>cs</code>,<code>us</code>,<code>sy</code>。</p><p><strong>r=100</strong>,说明等待的进程数量是100，线程有阻塞。</p><p><strong>cs=800多万</strong>，说明每秒上下文切换了800多万次，这个数字相当大了。</p><p><strong>us=14</strong>，说明用户态占用了14%的CPU时间片去处理逻辑。</p><p><strong>sy=86</strong>，说明内核态占用了86%的CPU，这里明显就是做上下文切换工作了。</p><p>我们通过<code>top</code>命令以及<code>top -Hp pid</code>查看进程和线程CPU情况，发现Java线程CPU占满了，但是线程CPU使用情况很平均，没有某一个线程把CPU吃满的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                            </span><br><span class="line"> 87093 root      20   0 4194788 299056  13252 S 399.7 16.1  65:34.67 java </span><br><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                             </span><br><span class="line"> 87189 root      20   0 4194788 299056  13252 R  4.7 16.1   0:41.11 java                                                                                </span><br><span class="line"> 87129 root      20   0 4194788 299056  13252 R  4.3 16.1   0:41.14 java                                                                                </span><br><span class="line"> 87130 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.51 java                                                                                </span><br><span class="line"> 87133 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.59 java                                                                                </span><br><span class="line"> 87134 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.95 java</span><br></pre></td></tr></table></figure><p>结合上面用户态CPU只使用了14%，内核态CPU占用了86%，可以基本判断是Java程序线程上下文切换导致性能问题。</p><p>我们使用<code>pidstat</code>命令来看看Java进程内部的线程切换数据，执行<code>pidstat -p 87093 -w 1 10</code>,采集数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">11:04:30 PM   UID       TGID       TID   cswch&#x2F;s nvcswch&#x2F;s  Command</span><br><span class="line">11:04:30 PM     0         -     87128      0.00     16.07  |__java</span><br><span class="line">11:04:30 PM     0         -     87129      0.00     15.60  |__java</span><br><span class="line">11:04:30 PM     0         -     87130      0.00     15.54  |__java</span><br><span class="line">11:04:30 PM     0         -     87131      0.00     15.60  |__java</span><br><span class="line">11:04:30 PM     0         -     87132      0.00     15.43  |__java</span><br><span class="line">11:04:30 PM     0         -     87133      0.00     16.02  |__java</span><br><span class="line">11:04:30 PM     0         -     87134      0.00     15.66  |__java</span><br><span class="line">11:04:30 PM     0         -     87135      0.00     15.23  |__java</span><br><span class="line">11:04:30 PM     0         -     87136      0.00     15.33  |__java</span><br><span class="line">11:04:30 PM     0         -     87137      0.00     16.04  |__java</span><br></pre></td></tr></table></figure><p>根据上面采集的信息，我们知道Java的线程每秒切换15次左右，正常情况下，应该是个位数或者小数。结合这些信息我们可以断定Java线程开启过多，导致频繁上下文切换，从而影响了整体性能。</p><p><strong>为什么系统的上下文切换是每秒800多万，而 Java 进程中的某一个线程切换才15次左右？</strong></p><p>系统上下文切换分为三种情况:</p><p>1、多任务：在多任务环境中，一个进程被切换出CPU，运行另外一个进程，这里会发生上下文切换。</p><p>2、中断处理：发生中断时，硬件会切换上下文。在vmstat命令中是<code>in</code></p><p>3、用户和内核模式切换：当操作系统中需要在用户模式和内核模式之间进行转换时，需要进行上下文切换,比如进行系统函数调用。</p><p>Linux 为每个 CPU 维护了一个就绪队列，将活跃进程按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。也就是vmstat命令中的<code>r</code>。</p><p>那么，进程在什么时候才会被调度到 CPU 上运行呢？</p><ul><li>进程执行完终止了，它之前使用的 CPU 会释放出来，这时再从就绪队列中拿一个新的进程来运行</li><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片被轮流分配给各个进程。当某个进程时间片耗尽了就会被系统挂起，切换到其它等待 CPU 的进程运行。</li><li>进程在系统资源不足时，要等待资源满足后才可以运行，这时进程也会被挂起，并由系统调度其它进程运行。</li><li>当进程通过睡眠函数 sleep 主动挂起时，也会重新调度。</li><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li></ul><p>结合我们之前的内容分析，阻塞的就绪队列是100左右，而我们的CPU只有4核，这部分原因造成的上下文切换就可能会相当高，再加上中断次数是4000左右和系统的函数调用等，整个系统的上下文切换到800万也不足为奇了。Java内部的线程切换才15次，是因为线程使用<code>Thread.yield()</code>来让出CPU资源，但是CPU有可能继续调度该线程，这个时候线程之间并没有切换，这也是为什么内部的某个线程切换次数并不是非常大的原因。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文模拟了常见的性能问题场景，分析了如何定位CPU100%、内存泄漏、死锁、线程频繁切换问题。分析问题我们需要做好两件事，第一，掌握基本的原理，第二，借助好工具。本文也列举了分析问题的常用工具和命令，希望对你解决问题有所帮助。当然真正的线上环境可能十分复杂，并没有模拟的环境那么简单，但是原理是一样的，问题的表现也是类似的，我们重点抓住原理，活学活用，相信复杂的线上问题也可以顺利解决。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计一个高可用系统</title>
      <link href="/2020/10/28/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/10/28/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="什么是高可用？可用性的判断标准是啥？"><a href="#什么是高可用？可用性的判断标准是啥？" class="headerlink" title="什么是高可用？可用性的判断标准是啥？"></a>什么是高可用？可用性的判断标准是啥？</h2><p><strong>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</strong></p><p><strong>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。</strong></p><p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</p><h2 id="哪些情况会导致系统不可用？"><a href="#哪些情况会导致系统不可用？" class="headerlink" title="哪些情况会导致系统不可用？"></a>哪些情况会导致系统不可用？</h2><ol><li>黑客攻击；</li><li>硬件故障，比如服务器坏掉。</li><li>并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。</li><li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。</li><li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。</li><li>自然灾害或者人为破坏。</li><li>……</li></ol><h2 id="有哪些提高系统可用性的方法？"><a href="#有哪些提高系统可用性的方法？" class="headerlink" title="有哪些提高系统可用性的方法？"></a>有哪些提高系统可用性的方法？</h2><h3 id="1-注重代码质量，测试严格把关"><a href="#1-注重代码质量，测试严格把关" class="headerlink" title="1. 注重代码质量，测试严格把关"></a>1. 注重代码质量，测试严格把关</h3><p>我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！</p><p>另外，安利这个对提高代码质量有实际效果的宝贝：</p><ol><li>sonarqube ：保证你写出更安全更干净的代码！（ps: 目前所在的项目基本都会用到这个插件）。</li><li>Alibaba 开源的 Java 诊断工具 Arthas 也是很不错的选择。</li><li>IDEA 自带的代码分析等工具进行代码扫描也是非常非常棒的。</li></ol><h3 id="2-使用集群，减少单点故障"><a href="#2-使用集群，减少单点故障" class="headerlink" title="2.使用集群，减少单点故障"></a>2.使用集群，减少单点故障</h3><p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例，不到一秒就会有另外一台 Redis 实例顶上。</p><h3 id="3-限流"><a href="#3-限流" class="headerlink" title="3.限流"></a>3.限流</h3><p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。——来自 alibaba-<a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel</a> 的 wiki。</p><h3 id="4-超时和重试机制设置"><a href="#4-超时和重试机制设置" class="headerlink" title="4.超时和重试机制设置"></a>4.超时和重试机制设置</h3><p>一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p><h3 id="5-熔断机制"><a href="#5-熔断机制" class="headerlink" title="5.熔断机制"></a>5.熔断机制</h3><p>超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的是流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。</p><h3 id="6-异步调用"><a href="#6-异步调用" class="headerlink" title="6.异步调用"></a>6.异步调用</h3><p>异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 <strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。</p><h3 id="7-使用缓存"><a href="#7-使用缓存" class="headerlink" title="7.使用缓存"></a>7.使用缓存</h3><p>如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！</p><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h3><ol><li><strong>核心应用和服务优先使用更好的硬件</strong></li><li><strong>监控系统资源使用情况增加报警设置。</strong></li><li><strong>注意备份，必要时候回滚。</strong></li><li><strong>灰度发布：</strong> 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可</li><li><strong>定期检查/更换硬件：</strong> 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。</li><li>…..(想起来再补充！也欢迎各位欢迎补充！)</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/high-availability/如何设计一个高可用系统要考虑哪些地方?id=总结" target="_blank" rel="noopener">总结</a></h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%EF%BC%9F.png" alt="如何设计高可用系统？"></p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式ID生成方案</title>
      <link href="/2020/10/28/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"/>
      <url>/2020/10/28/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做<strong>分布式ID</strong>，或<strong>全局ID</strong>。下面来分析各个生成分布式ID的机制。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%88%86%E5%B8%83%E5%BC%8Fid%E6%96%B9%E6%A1%88.jpeg" alt="常用分布式id方案"></p><p>这篇文章并不会分析的特别详细，主要是做一些总结，以后再出一些详细某个方案的文章。</p><h2 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h2><p>第一种方案仍然还是基于数据库的自增ID，需要单独使用一个数据库实例，在这个实例中新建一个单独的表：</p><p>表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`SEQID`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SEQID.SEQUENCE_ID (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment, </span><br><span class="line">    stub <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> stub (stub)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>可以使用下面的语句生成并获取到一个自增ID</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">replace</span> <span class="keyword">into</span> SEQUENCE_ID (stub) <span class="keyword">VALUES</span> (<span class="string">'anyword'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">last_insert_id</span>();</span><br><span class="line"><span class="keyword">commit</span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>stub字段在这里并没有什么特殊的意义，只是为了方便的去插入数据，只有能插入数据才能产生自增id。而对于插入我们用的是replace，replace会先看是否存在stub指定值一样的数据，如果存在则先delete再insert，如果不存在则直接insert。</p><p>这种生成分布式ID的机制，需要一个单独的Mysql实例，虽然可行，但是基于性能与可靠性来考虑的话都不够，<strong>业务系统每次需要一个ID时，都需要请求数据库获取，性能低，并且如果此数据库实例下线了，那么将影响所有的业务系统。</strong></p><p>为了解决数据库可靠性问题，我们可以使用第二种分布式ID生成方案。</p><h2 id="数据库多主模式"><a href="#数据库多主模式" class="headerlink" title="数据库多主模式"></a>数据库多主模式</h2><p>如果我们两个数据库组成一个<strong>主从模式</strong>集群，正常情况下可以解决数据库可靠性问题，但是如果主库挂掉后，数据没有及时同步到从库，这个时候会出现ID重复的现象。我们可以使用<strong>双主模式</strong>集群，也就是两个Mysql实例都能单独的生产自增ID，这样能够提高效率，但是如果不经过其他改造的话，这两个Mysql实例很可能会生成同样的ID。需要单独给每个Mysql实例配置不同的起始值和自增步长。</p><p>第一台Mysql实例配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">1</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>第二台Mysql实例配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">2</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>经过上面的配置后，这两个Mysql实例生成的id序列如下： mysql1,起始值为1,步长为2,ID生成的序列为：1,3,5,7,9,… mysql2,起始值为2,步长为2,ID生成的序列为：2,4,6,8,10,…</p><p>对于这种生成分布式ID的方案，需要单独新增一个生成分布式ID应用，比如DistributIdService，该应用提供一个接口供业务应用获取ID，业务应用需要一个ID时，通过rpc的方式请求DistributIdService，DistributIdService随机去上面的两个Mysql实例中去获取ID。</p><p>实行这种方案后，就算其中某一台Mysql实例下线了，也不会影响DistributIdService，DistributIdService仍然可以利用另外一台Mysql来生成ID。</p><p>但是这种方案的扩展性不太好，如果两台Mysql实例不够用，需要新增Mysql实例来提高性能时，这时就会比较麻烦。</p><p>现在如果要新增一个实例mysql3，要怎么操作呢？ 第一，mysql1、mysql2的步长肯定都要修改为3，而且只能是人工去修改，这是需要时间的。 第二，因为mysql1和mysql2是不停在自增的，对于mysql3的起始值我们可能要定得大一点，以给充分的时间去修改mysql1，mysql2的步长。 第三，在修改步长的时候很可能会出现重复ID，要解决这个问题，可能需要停机才行。</p><p>为了解决上面的问题，以及能够进一步提高DistributIdService的性能，如果使用第三种生成分布式ID机制。</p><h2 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h2><p>我们可以使用号段的方式来获取自增ID，号段可以理解成批量获取，比如DistributIdService从数据库获取ID时，如果能批量获取多个ID并缓存在本地的话，那样将大大提供业务应用获取ID的效率。</p><p>比如DistributIdService每次从数据库获取ID时，就获取一个号段，比如(1,1000]，这个范围表示了1000个ID，业务应用在请求DistributIdService提供ID时，DistributIdService只需要在本地从1开始自增并返回即可，而不需要每次都请求数据库，一直到本地自增到1000时，也就是当前号段已经被用完时，才去数据库重新获取下一号段。</p><p>所以，我们需要对数据库表进行改动，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> id_generator (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  current_max_id <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'当前最大id'</span>,</span><br><span class="line">  increment_step <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'号段的长度'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这个数据库表用来记录自增步长以及当前自增ID的最大值（也就是当前已经被申请的号段的最后一个值），因为自增逻辑被移到DistributIdService中去了，所以数据库不需要这部分逻辑了。</p><p>这种方案不再强依赖数据库，就算数据库不可用，那么DistributIdService也能继续支撑一段时间。但是如果DistributIdService重启，会丢失一段ID，导致ID空洞。</p><p>为了提高DistributIdService的高可用，需要做一个集群，业务在请求DistributIdService集群获取ID时，会随机的选择某一个DistributIdService节点进行获取，对每一个DistributIdService节点来说，数据库连接的是同一个数据库，那么可能会产生多个DistributIdService节点同时请求数据库获取号段，那么这个时候需要利用乐观锁来进行控制，比如在数据库表中增加一个version字段，在获取号段时使用如下SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> id_generator <span class="keyword">set</span> current_max_id=<span class="comment">#&#123;newMaxId&#125;, version=version+1 where version = #&#123;version&#125;Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>因为newMaxId是DistributIdService中根据oldMaxId+步长算出来的，只要上面的update更新成功了就表示号段获取成功了。</p><p>为了提供数据库层的高可用，需要对数据库使用多主模式进行部署，对于每个数据库来说要保证生成的号段不重复，这就需要利用最开始的思路，再在刚刚的数据库表中增加起始值和步长，比如如果现在是两台Mysql，那么 mysql1将生成号段（1,1001]，自增的时候序列为1，3，4，5，7…. mysql1将生成号段（2,1002]，自增的时候序列为2，4，6，8，10…</p><p>更详细的可以参考滴滴开源的TinyId：<a href="https://github.com/didi/tinyid/wiki/tinyid原理介绍" target="_blank" rel="noopener">github.com/didi/tinyid…</a></p><p>在TinyId中还增加了一步来提高效率，在上面的实现中，ID自增的逻辑是在DistributIdService中实现的，而实际上可以把自增的逻辑转移到业务应用本地，这样对于业务应用来说只需要获取号段，每次自增时不再需要请求调用DistributIdService了。</p><h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>上面的三种方法总的来说是基于自增思想的，而接下来就介绍比较著名的雪花算法-snowflake。</p><p>我们可以换个角度来对分布式ID进行思考，只要能让负责生成分布式ID的每台机器在每毫秒内生成不一样的ID就行了。</p><p>snowflake是twitter开源的分布式ID生成算法，是一种算法，所以它和上面的三种生成分布式ID机制不太一样，它不依赖数据库。</p><p>核心思想是：分布式ID固定是一个long型的数字，一个long型占8个字节，也就是64个bit，原始snowflake算法中对于bit的分配如下图：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.png" alt="雪花算法"></p><ul><li>第一个bit位是标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以固定为0。</li><li>时间戳部分占41bit，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li><li>工作机器id占10bit，这里比较灵活，比如，可以使用前5位作为数据中心机房标识，后5位作为单机房机器标识，可以部署1024个节点。</li><li>序列号部分占12bit，支持同一毫秒内同一个节点可以生成4096个ID</li></ul><p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p><p>snowflake算法实现起来并不难，提供一个github上用java实现的：<a href="https://github.com/beyondfengyu/SnowFlake" target="_blank" rel="noopener">github.com/beyondfengy…</a></p><p>在大厂里，其实并没有直接使用snowflake，而是进行了改造，因为snowflake算法中最难实践的就是工作机器id，原始的snowflake算法需要人工去为每台机器去指定一个机器id，并配置在某个地方从而让snowflake从此处获取机器id。</p><p>但是在大厂里，机器是很多的，人力成本太大且容易出错，所以大厂对snowflake进行了改造。</p><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><p>github地址：<a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener">uid-generator</a></p><p>uid-generator使用的就是snowflake，只是在生产机器id，也叫做workId时有所不同。</p><p>uid-generator中的workId是由uid-generator自动生成的，并且考虑到了应用部署在docker上的情况，在uid-generator中用户可以自己去定义workId的生成策略，默认提供的策略是：应用启动时由数据库分配。说的简单一点就是：应用在启动时会往数据库表(uid-generator需要新增一个WORKER_NODE表)中去插入一条数据，数据插入成功后返回的该数据对应的自增唯一id就是该机器的workId，而数据由host，port组成。</p><p>对于uid-generator中的workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，同一个应用每重启一次就会消费一个workId。</p><p>具体可参考<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">github.com/baidu/uid-g…</a></p><h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><p>github地址：<a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener">Leaf</a></p><p>美团的Leaf也是一个分布式ID生成框架。它非常全面，即支持号段模式，也支持snowflake模式。号段模式这里就不介绍了，和上面的分析类似。</p><p>Leaf中的snowflake模式和原始snowflake算法的不同点，也主要在workId的生成，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，在启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总得来说，上面两种都是自动生成workId，以让系统更加稳定以及减少人工成功。</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>这里额外再介绍一下使用Redis来生成分布式ID，其实和利用Mysql自增ID类似，可以利用Redis中的incr命令来实现原子性的自增与返回，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set seq_id 1     // 初始化自增ID为1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 3Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>使用redis的效率是非常高的，但是要考虑持久化的问题。Redis支持RDB和AOF两种持久化的方式。</p><p>RDB持久化相当于定时打一个快照进行持久化，如果打完快照后，连续自增了几次，还没来得及做下一次快照持久化，这个时候Redis挂掉了，重启Redis后会出现ID重复。</p><p>AOF持久化相当于对每条写命令进行持久化，如果Redis挂掉了，不会出现ID重复的现象，但是会由于incr命令过得，导致重启恢复数据时间过长。</p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单点登录</title>
      <link href="/2020/10/28/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2020/10/28/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>只有光头才能变强。</p></blockquote><blockquote><p>文本已收录至我的GitHub仓库，欢迎Star：<a href="https://github.com/ZhongFuCheng3y/3y" target="_blank" rel="noopener">github.com/ZhongFuChen…</a></p></blockquote><p>在我实习之前我就已经在看单点登录的是什么了，但是实习的时候一直在忙其他的事，所以有几个网站就一直躺在我的收藏夹里边：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/12/16aac3544ce88c36?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="收藏的一些网站"></p><p>在前阵子有个读者来我这投稿，是使用JWT实现单点登录的（但是文章中并没有介绍什么是单点登录），所以我觉得是时候来整理一下了。</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247485189&idx=1&sn=44e9558f3a03f9c5e1ec539e1a10dbe2&chksm=ebd74604dca0cf126c64586b448ee8c7bccd51545d7a27d06b21bc75a2e390f961d7cafac375&token=1875959808&lang=zh_CN#rd" target="_blank" rel="noopener">简单代码实现JWT(json web token)完成SSO单点登录</a></li></ul><h2 id="一、什么是单点登录？"><a href="#一、什么是单点登录？" class="headerlink" title="一、什么是单点登录？"></a>一、什么是单点登录？</h2><p>单点登录的英文名叫做：Single Sign On（简称<strong>SSO</strong>）。</p><p>在<strong>初学/以前</strong>的时候，一般我们就<strong>单系统</strong>，所有的功能都在同一个系统上。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/12/16aac3544cd4a892?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="所有的功能都在同一个系统上"></p><p>后来，我们为了<strong>合理利用资源和降低耦合性</strong>，于是把单系统<strong>拆分</strong>成多个子系统。</p><ul><li>回顾：<a href="https://mp.weixin.qq.com/s/mwn2X0G9UgUDz1sgGgL1mA" target="_blank" rel="noopener">分布式基础知识</a></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/5/12/16aac3544d675a4b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="拆分成多个子系统"></p><p>比如阿里系的<strong>淘宝和天猫</strong>，很明显地我们可以知道这是两个系统，但是你在使用的时候，登录了天猫，淘宝也会自动登录。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb63967305d5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="登录了天猫，淘宝也登录了"></p><p>简单来说，单点登录就是<strong>在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录。</strong></p><h2 id="二、回顾单系统登录"><a href="#二、回顾单系统登录" class="headerlink" title="二、回顾单系统登录"></a>二、回顾单系统登录</h2><p>在我初学JavaWeb的时候，登录和注册是我做得最多的一个功能了（初学Servlet的时候做过、学SpringMVC的时候做过、跟着做项目的时候做过…），反正我也数不清我做了多少次登录和注册的功能了…这里简单讲述一下我们初学时是怎么做登录功能的。</p><p>众所周知，HTTP是<strong>无状态</strong>的协议，这意味着<strong>服务器无法确认用户的信息</strong>。于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是<strong>Cookie</strong>。</p><p>如果说Cookie是检查用户身上的”通行证“来确认用户的身份，那么Session就是通过检查服务器上的”客户明细表“来确认用户的身份的。<strong>Session相当于在服务器中建立了一份“客户明细表”</strong>。</p><p>HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一个用户。于是乎：服务器向用户浏览器发送了一个名为JESSIONID的Cookie，它的值是Session的id值。<strong>其实Session是依据Cookie来识别是否是同一个用户</strong>。</p><p>所以，一般我们单系统实现登录会这样做：</p><ul><li><p>登录</p><p>：将用户信息保存在Session对象中</p><ul><li>如果在Session对象中能查到，说明已经登录</li><li>如果在Session对象中查不到，说明没登录（或者已经退出了登录）</li></ul></li><li><p><strong>注销（退出登录）</strong>：从Session中删除用户的信息</p></li><li><p><strong>记住我（关闭掉浏览器后，重新打开浏览器还能保持登录状态）</strong>：配合Cookie来用</p></li></ul><p>我之前Demo的代码，可以参考一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> * 用户登陆</span><br><span class="line"> *&#x2F;</span><br><span class="line">@PostMapping(value &#x3D; &quot;&#x2F;user&#x2F;session&quot;, produces &#x3D; &#123;&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;&#125;)</span><br><span class="line">public Result login(String mobileNo, String password, String inputCaptcha, HttpSession session, HttpServletResponse response) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断验证码是否正确</span><br><span class="line">    if (WebUtils.validateCaptcha(inputCaptcha, &quot;captcha&quot;, session)) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断有没有该用户</span><br><span class="line">        User user &#x3D; userService.userLogin(mobileNo, password);</span><br><span class="line">        if (user !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;*设置自动登陆，一个星期.  将token保存在数据库中*&#x2F;</span><br><span class="line">            String loginToken &#x3D; WebUtils.md5(new Date().toString() + session.getId());</span><br><span class="line">            user.setLoginToken(loginToken);</span><br><span class="line">            User user1 &#x3D; userService.userUpload(user);</span><br><span class="line"></span><br><span class="line">            session.setAttribute(&quot;user&quot;, user1);</span><br><span class="line"></span><br><span class="line">            CookieUtil.addCookie(response,&quot;loginToken&quot;,loginToken,604800);</span><br><span class="line"></span><br><span class="line">            return ResultUtil.success(user1);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ResultUtil.error(ResultEnum.LOGIN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return ResultUtil.error(ResultEnum.CAPTCHA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用户退出</span><br><span class="line"> *&#x2F;</span><br><span class="line">@DeleteMapping(value &#x3D; &quot;&#x2F;session&quot;, produces &#x3D; &#123;&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;&#125;)</span><br><span class="line">public Result logout(HttpSession session,HttpServletRequest request,HttpServletResponse response ) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;删除session和cookie</span><br><span class="line">    session.removeAttribute(&quot;user&quot;);</span><br><span class="line"></span><br><span class="line">    CookieUtil.clearCookie(request, response, &quot;loginToken&quot;);</span><br><span class="line"></span><br><span class="line">    return ResultUtil.success();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @author ozc</span><br><span class="line">* @version 1.0</span><br><span class="line">* &lt;p&gt;</span><br><span class="line">* 拦截器；实现自动登陆功能</span><br><span class="line">*&#x2F;</span><br><span class="line">public class UserInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private UserService userService;</span><br><span class="line"></span><br><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception &#123;</span><br><span class="line">    User sessionUser &#x3D; (User) request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 已经登陆了，放行</span><br><span class="line">    if (sessionUser !&#x3D; null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;得到带过来cookie是否存在</span><br><span class="line">        String loginToken &#x3D; CookieUtil.findCookieByName(request, &quot;loginToken&quot;);</span><br><span class="line">        if (StringUtils.isNotBlank(loginToken)) &#123;</span><br><span class="line">            &#x2F;&#x2F;到数据库查询有没有该Cookie</span><br><span class="line">            User user &#x3D; userService.findUserByLoginToken(loginToken);</span><br><span class="line">            if (user !&#x3D; null) &#123;</span><br><span class="line">                request.getSession().setAttribute(&quot;user&quot;, user);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;没有该Cookie与之对应的用户(Cookie不匹配)</span><br><span class="line">                CookieUtil.clearCookie(request, response, &quot;loginToken&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;没有cookie、也没有登陆。是index请求获取用户信息，可以放行</span><br><span class="line">            if (request.getRequestURI().contains(&quot;session&quot;)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;没有cookie凭证</span><br><span class="line">            response.sendRedirect(&quot;&#x2F;login.html&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>总结一下上面代码的思路：</p><ul><li>用户登录时，验证用户的账户和密码</li><li>生成一个Token保存在数据库中，将Token写到Cookie中</li><li>将用户数据保存在Session中</li><li>请求时都会带上Cookie，检查有没有登录，如果已经登录则放行</li></ul><p>如果没看懂的同学，建议回顾Session和Cookie和HTTP：</p><ul><li><a href="https://mp.weixin.qq.com/s/JW7mxXEqrV1rZ_pQOteXGQ" target="_blank" rel="noopener">介绍会话技术、Cookie的API、详解、应用</a></li><li><a href="https://mp.weixin.qq.com/s/kjiAznd2MKD0Y-shXtzVQg" target="_blank" rel="noopener">Session介绍、API、生命周期、应用、与Cookie区别</a></li><li><a href="https://mp.weixin.qq.com/s/8cNJy7fbI0CVbTCyrYoDeQ" target="_blank" rel="noopener">什么是HTTP</a></li></ul><h2 id="三、多系统登录的问题与解决"><a href="#三、多系统登录的问题与解决" class="headerlink" title="三、多系统登录的问题与解决"></a>三、多系统登录的问题与解决</h2><h3 id="3-1-Session不共享问题"><a href="#3-1-Session不共享问题" class="headerlink" title="3.1 Session不共享问题"></a>3.1 Session不共享问题</h3><p>单系统登录功能主要是用Session保存用户信息来实现的，但我们清楚的是：多系统即可能有多个Tomcat，而Session是依赖当前系统的Tomcat，所以系统A的Session和系统B的Session是<strong>不共享</strong>的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb63966d02418?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="系统A的Session和系统B的Session是不共享的"></p><p>解决系统之间Session不共享问题有一下几种方案：</p><ul><li><p>Tomcat集群Session全局复制（集群内每个tomcat的session完全同步）【会影响集群的性能呢，不建议】</p></li><li><p>根据请求的IP进行<strong>Hash映射</strong>到对应的机器上（这就相当于请求的IP一直会访问同一个服务器）【如果服务器宕机了，会丢失了一大部分Session的数据，不建议】</p></li><li><p>把Session数据放在Redis中（使用Redis模拟Session）【</p><p>建议</p><p>】</p><ul><li>如果还不了解Redis的同学，建议移步（<a href="https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A" target="_blank" rel="noopener">Redis合集</a>）</li></ul></li></ul><p>我们可以将登录功能<strong>单独抽取</strong>出来，做成一个子系统。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb639676f4f1d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="抽取出来成为子系统"></p><p>SSO（登录系统）的逻辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 登录功能(SSO单独的服务)</span><br><span class="line">@Override</span><br><span class="line">public TaotaoResult login(String username, String password) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据用户名查询用户信息</span><br><span class="line">TbUserExample example &#x3D; new TbUserExample();</span><br><span class="line">Criteria criteria &#x3D; example.createCriteria();</span><br><span class="line">criteria.andUsernameEqualTo(username);</span><br><span class="line">List&lt;TbUser&gt; list &#x3D; userMapper.selectByExample(example);</span><br><span class="line">if (null &#x3D;&#x3D; list || list.isEmpty()) &#123;</span><br><span class="line">return TaotaoResult.build(400, &quot;用户不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;核对密码</span><br><span class="line">TbUser user &#x3D; list.get(0);</span><br><span class="line">if (!DigestUtils.md5DigestAsHex(password.getBytes()).equals(user.getPassword())) &#123;</span><br><span class="line">return TaotaoResult.build(400, &quot;密码错误&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;登录成功，把用户信息写入redis</span><br><span class="line">&#x2F;&#x2F;生成一个用户token</span><br><span class="line">String token &#x3D; UUID.randomUUID().toString();</span><br><span class="line">jedisCluster.set(USER_TOKEN_KEY + &quot;:&quot; + token, JsonUtils.objectToJson(user));</span><br><span class="line">&#x2F;&#x2F;设置session过期时间</span><br><span class="line">jedisCluster.expire(USER_TOKEN_KEY + &quot;:&quot; + token, SESSION_EXPIRE_TIME);</span><br><span class="line">return TaotaoResult.ok(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其他子系统登录时，<strong>请求SSO（登录系统）进行登录，将返回的token写到Cookie中</strong>，下次访问时则把Cookie带上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public TaotaoResult login(String username, String password, </span><br><span class="line">HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">&#x2F;&#x2F;请求参数</span><br><span class="line">Map&lt;String, String&gt; param &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">param.put(&quot;username&quot;, username);</span><br><span class="line">param.put(&quot;password&quot;, password);</span><br><span class="line">&#x2F;&#x2F;登录处理</span><br><span class="line">String stringResult &#x3D; HttpClientUtil.doPost(REGISTER_USER_URL + USER_LOGIN_URL, param);</span><br><span class="line">TaotaoResult result &#x3D; TaotaoResult.format(stringResult);</span><br><span class="line">&#x2F;&#x2F;登录出错</span><br><span class="line">if (result.getStatus() !&#x3D; 200) &#123;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;登录成功后把取token信息，并写入cookie</span><br><span class="line">String token &#x3D; (String) result.getData();</span><br><span class="line">&#x2F;&#x2F;写入cookie</span><br><span class="line">CookieUtils.setCookie(request, response, &quot;TT_TOKEN&quot;, token);</span><br><span class="line">&#x2F;&#x2F;返回成功</span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>SSO系统生成一个token，并将用户信息存到Redis中，并设置过期时间</li><li>其他系统请求SSO系统进行登录，得到SSO返回的token，写到Cookie中</li><li>每次请求时，Cookie都会带上，拦截器得到token，判断是否已经登录</li></ul><p>到这里，其实我们会发现其实就两个变化：</p><ul><li>将登陆功能抽取为一个系统（SSO），其他系统请求SSO进行登录</li><li>本来将用户信息存到Session，现在将用户信息存到Redis</li></ul><h3 id="3-2-Cookie跨域的问题"><a href="#3-2-Cookie跨域的问题" class="headerlink" title="3.2 Cookie跨域的问题"></a>3.2 Cookie跨域的问题</h3><p>上面我们解决了Session不能共享的问题，但其实还有另一个问题。<strong>Cookie是不能跨域的</strong></p><p>比如说，我们请求<code>&lt;https://www.google.com/&gt;</code>时，浏览器会自动把<code>google.com</code>的Cookie带过去给<code>google</code>的服务器，而不会把<code>&lt;https://www.baidu.com/&gt;</code>的Cookie带过去给<code>google</code>的服务器。</p><p>这就意味着，<strong>由于域名不同</strong>，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。</p><p>针对Cookie存在跨域问题，有几种解决方案：</p><ol><li>服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了</li><li>多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。</li><li>将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了）</li></ol><p>到这里，我们已经可以实现单点登录了。</p><h3 id="3-3-CAS原理"><a href="#3-3-CAS原理" class="headerlink" title="3.3 CAS原理"></a>3.3 CAS原理</h3><p>说到单点登录，就肯定会见到这个名词：CAS （Central Authentication Service），下面说说CAS是怎么搞的。</p><p><strong>如果已经将登录单独抽取成系统出来</strong>，我们还能这样玩。现在我们有两个系统，分别是<code>www.java3y.com</code>和<code>www.java4y.com</code>，一个SSO<code>www.sso.com</code></p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb639678ec21c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="现在我们有三个系统"></p><p>首先，用户想要访问系统A<code>www.java3y.com</code>受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统A<code>www.java3y.com</code>发现用户并没有登录，于是<strong>重定向到sso认证中心，并将自己的地址作为参数</strong>。请求的地址如下：</p><ul><li><code>www.sso.com?service=www.java3y.com</code></li></ul><p>sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立<strong>全局会话（生成一份Token，写到Cookie中，保存在浏览器上）</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb6396dba1c48?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="4步过程"></p><p>随后，认证中心<strong>重定向回系统A</strong>，并把Token携带过去给系统A，重定向的地址如下：</p><ul><li><code>www.java3y.com?token=xxxxxxx</code></li></ul><p>接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（<strong>创建Session</strong>）。到此，系统A和用户已经是登录状态了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb6396e70f83b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="第五步和第六步"></p><p>此时，用户想要访问系统B<code>www.java4y.com</code>受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统B<code>www.java4y.com</code>发现用户并没有登录，于是<strong>重定向到sso认证中心，并将自己的地址作为参数</strong>。请求的地址如下：</p><ul><li><code>www.sso.com?service=www.java4y.com</code></li></ul><p>注意，因为之前用户与认证中心<code>www.sso.com</code>已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B<strong>重定向</strong>到认证中心<code>www.sso.com</code>是可以带上Cookie的。</p><p>认证中心<strong>根据带过来的Cookie</strong>发现已经与用户建立了全局会话了，认证中心<strong>重定向回系统B</strong>，并把Token携带过去给系统B，重定向的地址如下：</p><ul><li><code>www.java4y.com?token=xxxxxxx</code></li></ul><p>接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（<strong>创建Session</strong>）。到此，系统B和用户已经是登录状态了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb63a1ccb78a1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="系统B的流程图"></p><p>看到这里，其实SSO认证中心就类似一个<strong>中转站</strong></p><p>作者：Java3y<br>链接：<a href="https://juejin.im/post/6844903845424971783" target="_blank" rel="noopener">https://juejin.im/post/6844903845424971783</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 设计题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/2020/10/28/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2020/10/28/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//集合中是否还有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得集合中的下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>Iterator</code> 对象称为迭代器（设计模式的一种），迭代器可以对集合进行遍历，但每一个集合内部的数据结构可能是不尽相同的，所以每一个集合存和取都很可能是不一样的，虽然我们可以人为地在每一个类中定义 <code>hasNext()</code> 和 <code>next()</code> 方法，但这样做会让整个集合体系过于臃肿。于是就有了迭代器。</p><p>迭代器是将这样的方法抽取出接口，然后在每个类的内部，定义自己迭代方式，这样做就规定了整个集合体系的遍历方式都是 <code>hasNext()</code>和<code>next()</code>方法，使用者不用管怎么实现的，会用即可。迭代器的定义为：提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。</p><h4 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h4><p><code>Iterator</code> 主要是用来遍历集合用的，它的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 <code>ConcurrentModificationException</code> 异常。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>我们通过使用迭代器来遍历 <code>HashMap</code>，演示一下 迭代器 Iterator 的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"Java"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"C++"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"PHP"</span>);</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">  System.out.println(entry.getKey() + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识大杂烩</title>
      <link href="/2020/10/25/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
      <url>/2020/10/25/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<p>作者：0XCAFEBABY<br>链接：<a href="https://www.nowcoder.com/discuss/438311" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/438311</a><br>来源：牛客网</p><p>1.JDK JRE<br>\2. Java异常了解吗？说说平时遇到的异常？说出6种常见的java异常。写程序遇到过哪些异常 运行时异常有哪些<br>\3. 面向对象 面对对象的几大特性 多态怎么理解<br>\4. 修饰符：public；protect；default；private优先级<br>\5. 对string类的理解。stringbuffer 和 stringbuilder<br>\6. 反射机制介绍一下<br>\7. bio，nio，aio分别介绍一下，nio的实现方式<br>\8. 问了public等变量定义修饰词的时间域<br>\9. 问了反射机制，还有问了动态代理的好处和坏处，好处答不上来<br>\10. 接口和抽象类的区别。<br>\11. 有一个public static final的HashMap，里边对象的属性能不能修改？<br>\12. 为什么java 平台无关性 机器码和字节码区别 JVM加载代码的一个流程<br>\13. java数据类型以及自己的应用 自动拆箱和自动装箱以及自己的应用即什么时候用到的，列举几种情况<br>\14. 什么是值传递和引用传递，区别及应用<br>\15. 重载和重写<br>\16. static方法是否能重写，接口和抽象类的区别<br>\17. 你觉得java是一种什么样的语言以及java特性<br>\18. lamda表达式了解吗？1.8新特性有什么？（面试宝典对接口抽象这个问题是错的，过时了）<br>\19. 内存泄露怎么造成的，怎么排查<br>\20. 讲讲final修饰符。<br>\21. 一个对象占多少内存。<br>\22. 最短路径问题<br>\23. java浅拷贝和深拷贝<br>\24. 内存泄露的原因和处理<br>\25. java反射机制，优点缺点<br>\26. 说说静态变量和非静态变量的区别，用类名调用静态变量和用实例对象调用静态变量有区别吗？非静态方法里可以有静态变量吗？<br>\27. static能不能被重写？<br> - 重写方法的目的是为了多态，或者说：重写是实现多态的前提，即重写是发生在继承中且是针对非static方法的。<br>语法上子类允许出现和父类只有方法体不一样其他都一模一样的static方法，但是在父类引用指向子类对象时，通过父类引用调用的依然是父类的static方法，而不是子类的static方法。<br>即：语法上static支持重写，但是运行效果上达不到多态目的<br>\28. 序列化，反序列化，什么时候用？ 如何对一个对象序列化</p><h2 id="Java集合类"><a href="#Java集合类" class="headerlink" title="Java集合类"></a>Java集合类</h2><ol><li>Hashmap底层（数组+<a href>链表</a>+<a href>红黑树</a>）hashmap为什么线程不安全，如何保证线程安全，就扯到concurrenthashmap hashmap底层实现 多线程会出现什么情况 扩容机制是什么为什么会死锁 如何解决碰撞 Jdk 1.8的优化。为什么使用<a href>红黑树</a>，它是如何做到效率优化的？ hashmap了解不，原理是什么，位图了解不，跳跃表了解不，<a href>红黑树</a>了解不，<a href>红黑树</a>插入过程，B+树了解不，B+树特点和插入过程，邻接表和邻接矩阵区别，分别在什么地方用到，<br> 插入和查询的流程。</li><li>concurrenthashmap1.7和1.8的区别；concurrenthashmap说说，它是如何保证线程安全的？jdk1.7的hashentry和segment锁。具体说说segment锁？能讲下ConcurrentHashMap的实现原理么 JDK7或者8都行</li><li>常用集合类 实现类 </li><li>list和set区别（重复/不重复）</li><li>set，list，map（线程安全的map，map怎么实现之类的）</li><li><a href>红黑树</a>介绍一下，跟<a href>平衡二叉树</a>比较一下，<a href>红黑树</a>有哪些应用场景</li><li>你常用的数据结构有哪些？</li><li><a href>红黑树</a>的特点，AVL树</li><li>一致性哈希函数以及hashmap的put方法</li><li>数组、二叉搜索树、B树、B+树</li><li>堆和栈。堆、栈</li><li><a href>二叉树</a>的最大节点个数；2^n-1;</li></ol><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><ol><li>java创建线程的方式，runnable和callable区别（参数不同）1. java线程的状态有哪些；线程的几种状态</li><li>wait和sleep的区别；wait和notify的使用场景；</li><li>介绍一下volatile以及原理；volatile介绍一下Volatile底层是如何实现的？ 说了内存可见性和内存屏障，Volatile是绝对线2程安全的吗？不是，没有保证原子性。volatile关键字在线程通信的问题</li><li>介绍一下synchornized以及原理； lock和synchornized的区别；synchronized锁的升级过程？Synchronized，底层是如何实现的？说了monitor对象头，以及两个monitorenter和monitorexit运用于代码块。<br>对象头是存储了哪些信息？说说synchronized的锁优化过程？说了偏向，自旋，轻量和重量。</li><li>介绍一下AQS;</li><li>说一下公平锁和非公平锁的原理；</li><li>cas操作是什么，以及可能出现的问题；</li><li>线程池，然后你再平时怎么用的，工作原理，有哪些重要参数，饱和策略有哪些；线程池了解吧，说说如何实现线程池？核心参数哪些？有哪些阻塞队列呢？如何优雅的关闭线程池 线程池（线程大小，阻塞队列）线程创建，线程池参数，说说你常用的线程池？说了new ***d 和newFixed。以及介绍各个参数</li><li>说说你理解的悲观锁和乐观锁？乐观锁有哪些？乐观锁有什么缺点？</li><li>阻塞队列 线程间通信方式 创建线程方式 创建线程池方式 线程池常用参数</li><li>锁有哪些</li><li>说说你常用的并发包JUI？</li><li>问了如何保证多线程通信</li><li>你用过Java的J.U.C并发包吧，给我讲一下AQS的原理</li><li>CAS的原理给我讲一下，他是怎么保证内存的可见性的。CAS会产生什么问题</li><li>知道Java中的内存模型吧，它有8个指令你给我说一下</li><li>多线程如何保持同步？</li><li>java可见性的关键字及其原理。</li><li>cpu密集型多线程和io密集型多线程的比较。cpu密集型里如何管理多线程？ 用什么样的线程池和阻塞队列？</li><li>cpu线程特别多会产生什么问题？io密集型里怎么减少需要的线程数？</li><li>io多路复用的原理和实现。怎么减少处理io（和磁盘io交互）所需要的线程？</li><li>线程实现方式。有什么区别。线程之间的通讯，进程之间的通讯。</li></ol><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol><li>JVM运行时内存区域划分？哪些线程私有？运行时数据区，私有共享都是哪些？堆区内存如何分配？</li><li>对象的生命周期？</li><li>JVM垃圾回收器，cms和g1的特点，两者的区别是什么，比g1更加先进的垃圾回收器有了解么，ZGC原理，能够管理多大的内存，CMS能管理多大的内存，G1呢</li><li>JVM内存模型 类的生命周期 类加载过程 双亲委派机制了解吗 进入老年代过程 什么情况下直接进入老年代</li><li>JVM内存分布（堆栈等，程序计数器+jvm栈+本地方法栈线程不共享，堆和方法区线程共享）</li><li>类加载机制，过程，类加载机制？如何自定义实现类加载器？双亲委派模型、类加载器类别，双亲委派模型本质是解决了什么问题？安全性，有哪几种类加载器？类加载的流程。知道哪些类加载器。类加载器之间的关系？双亲委派模型。为什么使用双亲委派模型？</li><li>垃圾回收<a href>算法</a>，常见的垃圾回收器及他们之间区别，垃圾回收发生在哪里，怎么判断对象存活、GC Roots具体有哪些、讲讲对象分配与回收，什么可以作为垃圾回收的对象，垃圾回收<a href>算法</a>和流程。</li><li>栈什么情况下会溢出？</li><li>静态变量存放在内存哪个区域？</li><li>怎么查看java虚拟机内存占用？</li><li>如何减少full gc的次数？方法区是否需要gc</li><li>4个引用类型 </li></ol><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol><li>输入一个url后的过程；浏览器从发送请求的全部过程</li><li>OSI七层和TCP四层协议，OSI七层模型/五层模型，每一层有哪些协议，http，tcp，ip位于哪一层</li><li>TCP三次握手四次分手，tcp四次挥手为什么要四次，为什么TCP是安全的，TCP，UDP的区别</li><li>TCP报文结构，HTTP结构， TCP，UDP，HTTP的报文格式（我懵了）</li><li>设计一个应用层协议（没有答出来</li><li>HTTP协议连接过程，HTTPS连接过程，HTTP的长连接是怎么做的HTTP2和HTTP1区别，HTTP请求过程<br>http的几种方法，HTTP跟HTTPS的区别，https加密过程</li></ol><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol><li>程序，进程和线程的区别</li><li>什么时候情况下要用多线程？</li><li>进程之间怎么通信的？</li><li>一个手机应用程序里面的进程和线程分别是怎么进行的？</li><li>死锁，怎么解死锁，死锁条件，怎么预防</li><li>进程的状态：阻塞+就绪+执行</li><li>手机内存8g，是32位的，一个进程能申请多少内存？</li><li>线程的应用，举例，线程的阻塞</li><li>主线程和子线程的区别</li></ol><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux :"></a>Linux :</h2><ol><li>linux中如何查看CPU负载 top</li><li>linux用过嘛（扯到了我训练过深度模型，小哥哥直接来了个场景题）<br>场景题：推荐<a href>算法</a>中如何控制广告推送频率（结合强化学习说了一些</li><li>Linux了解不，df dh区别，如何格式化磁盘，磁盘挂载过程，tcp丢包如何排查，docker是用什么实现的</li><li>怎么查找特定后缀名或前缀名的文件</li></ol><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ol><li>数据库引擎事务隔离级别，串行化如何实现，数据库的隔离级别？四个。你平常使用的是哪个隔离级别。数据库隔离级别以及分别解决了什么问题</li><li>MySQL的存储引擎有哪些？它们之间的区别？你用的mysql存储引擎？为什么选择它？实现原理？</li><li>怎么判断一个SQL语句有没有走索引？紧接着问explain知道哪些字段吗</li><li>mysql存储模型 区别 怎么看用没用索引 怎么判断sql语句好坏</li><li>数据库中索引B+树</li><li>一个手机应用要更改数据库，它的底层是怎么实现的？</li><li>sql查询过程</li><li>MySQL InnoDB存储引擎中的MVCC解决了什么问题，能说下MVCC的实现原理么</li><li>SQL语句经常写吧，那我给你出一道SQL题（分组求和<a href>排序</a>）</li><li>你认为什么情况下不应该建立索引</li><li>mysql有几种锁？怎么实现？</li><li>innodb事物的级别</li><li>b 树的结构？与<a href>二叉树</a>的区别？与b树的区别？</li><li>写过最复杂的sql， 手写代码： 统计各个科目考试最高分:最复杂的包括了sum、case、left join、group by，追问左连接和内联区别，没答上来</li><li>聚簇索引跟<a href>红黑树</a></li><li>sql :给一个日期范围，统计每天入库的数据总量</li><li>sql语句里like和in关键字</li><li>sql语句，求平均分超过60分的学生学号</li><li>数据库sql怎么优化 </li><li>什么情况不能用索引？</li><li>SELECT column_name(s)<br>FROM table_name<br>WHERE column_name<br>BETWEEN value1 AND value2 什么时候会发生死锁；怎么解决死锁；N个资源怎么办？</li></ol><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a><a href>redis</a></h2><ol><li>你知道<a href>redis</a>的什么东西</li><li><a href>redis</a>中zset，说了一下跳跃表的插入，删除过程；</li><li>位图知道原理嘛（操作系统中的位示图还是bitmap?不太了解）</li><li><a href>redis</a>数据类型，<a href>redis</a>的应用场景，为什么<a href>redis</a>快</li><li>Redis的key的写入和删除的原理</li><li>怎么保证Redis的高可用</li><li><a href>redis</a>数据结构？单线程还是多线程？</li><li>用什么样的队列？你是怎么实现？我回答的<a href>redis</a>的list实现的）这种队列有什么缺点？</li><li>分布式锁；</li></ol><h2 id="mq"><a href="#mq" class="headerlink" title="mq"></a>mq</h2><ol><li>你还用过rabbitMQ呀，它能够做什么？</li><li>rabbitMQ是怎么保证消息不丢的，从<a href>客户端</a>—消息队列， 消息队列—服务器端的角度考虑</li></ol><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><ol><li>开源框架有哪些了解的 为什么用spring 为什么不用new就可以自动生产 能不能自己实现一个</li><li>spring security是干嘛的，原理是啥，jwt干啥的</li><li>后台用什么框架？ioc，aop,其他还有什么框架也可以做到ioc,aop（2333～不就spring?）</li><li>Spring IOC,AOP,注解</li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol><li>双重检索单例</li><li>设计模式分为哪三类，各有什么？设计模式，用过哪些设计模式，讲几个，设计模式和原则</li><li>代理模式属于哪一类</li><li>生产者消费者模式,生产消费者的，以及多生产者同步</li><li>描述适配器，写单例</li><li>单例模式，装饰模式，</li></ol><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ol><li>负载均衡的<a href>算法</a>有哪些；</li><li>rpc dubbo的组件有哪些</li><li>分布式事务，CAP定理，有没有使用过相关的产品</li><li>zoo<a href>keep</a>er了解吗</li><li>hbase索引的结构，kafka存储的结构，二进制文件的组织方式，kafka如何避免消息丢失，zoo<a href>keep</a>er在kafka中是干啥的，kafka在zoo<a href>keep</a>er中存储的数据，zoo<a href>keep</a>er了解不，zoo<a href>keep</a>er的共识<a href>算法</a>，分区后如何解决。</li><li>protobuf了解不，grpc了解不，用的什么协议，HTTP2和HTTP1区别，websocket建立连接过程</li><li>RPC你了解过吗？</li><li>如何分布式存储？</li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><a href>算法</a></h2><ol><li><a href>排序</a><a href>算法</a>有哪些，简述冒泡和归并<a href>排序</a>，冒泡<a href>算法</a>的优化,讲讲归并<a href>排序</a>,冒泡的优化知道吗；回答相等不交换，还有flag做已<a href>排序</a>标志的优化；直接插入<a href>排序</a>，写一下伪代码或者说一下思路,插入<a href>排序</a>，时间复杂度</li><li>堆<a href>排序</a>原理</li><li>快排,快排是什么思想，快排的优化是啥，为啥这么做；</li><li>字母<a href>排序</a></li><li>100个数中找出想要的数</li><li>一个数组分成2个相等或接近的子数组</li><li>派单的最短路径问题</li><li>很大的数据，内存放不下，如何快速找到中间值</li><li>手撕栈</li><li><a href>链表</a>找环 <a href>链表</a>找环入口，不用双指针怎么做</li><li>双向<a href>链表</a>实现 ，写了个add()和add(index)的</li><li>求数组的全排列</li><li>中序遍历，递归非递归</li><li>求四个数绝对值的最小值</li><li>黑猫白猫，混在一起，如何把他们区分开？ 黑白灰三种猫混在一起，如何按照黑白灰排好序？ 还有两个小问题忘记了。</li><li>如何用一个int值，表示三种状态？</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>给你10个tomcat你如何判断自己用哪个（容器？emmmm，求指点）<br>位图知道原理嘛（操作系统中的位示图还是bitmap?不太了解）<br>所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此可以大大节省存储空间。<br>其实就是位示图为原型，01存储的，建议面试的时候知道多少说多少，知道什么说什么~</li><li>序列化相关</li><li>最后还是问<a href>项目</a>，<a href>项目</a>中的难点，是如何解决的？</li><li>c++编程搞过没，GPU编程了解不，用的什么GPU，GPU运算性能是什么决定的</li><li>如果某个用户同时请求创建活动接口100次，如果防止它被重复创建？创建前查看该记录是否存在、使用锁、如果是分布式的使用分布式锁—这样解决了99.99%的问题。除了使用这些方案，还能使用什么方法解决吗？</li><li>讲讲分布式锁的实现</li><li>io量很大，队列很长怎么办？</li><li>Q:觉得用过的模板解析引擎有什么不同的特征。<br>A:用过JSP和Thymeleaf，JSP我就说适合Java程序员做<a href>前端</a>，本质还是Servlet，生产环境下调试方便；Thymeleaf是SpringBoot<a href>项目</a>碰到的，本质是EL，语法特殊，但是前后端传值、传对象方便。</li><li>讲一下对jQUERY的使用感受<br>A：研一的<a href>项目</a>做过iOS开发，用OC做的webview APP，用到了jQuery Mobile做界面和事件控制，感觉很方便。 后面的Web<a href>项目</a>主要用来进行Ajax操作，选择器很方便。</li><li>硕士一个<a href>项目</a>涉及到跨系统集成，要我在纸上画出集成逻辑架构，介绍一下开发用到的技术和业务环境。<br> 集成用的WebService，引入Apache旗下的Axis， 涉及到文件传输和多数据源配置。。。。</li><li>用过eclipse、IDEA、Myeclipse，评价一下区别 代码提示、插件库、收费与免费、代码模板、资源消耗</li><li>用过EJB和SSH，评价一下区别</li><li>问了实习经历 了解分布式吗？</li><li>你怎么用的websocket?</li><li>想做安卓还是java后台？手机端安卓怎么开发的？</li><li>activity四大组件</li><li>介绍一下service</li><li>APP的启动流程</li><li>Android事件分发机制</li><li>view的测量方法；</li><li>Android之间线程通信</li><li>介绍一个你用心做的模块，<a href>项目</a>流程，怎么理解异步同步，什么场景用；<br>static能不能被重写？</li><li>MD5为啥要加盐(彩虹表·)；UUID有多少位(32位)</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis源码剖析</title>
      <link href="/2020/10/24/redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/10/24/redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><a href="https://juejin.im/post/6855129008091332615" target="_blank" rel="noopener">https://juejin.im/post/6855129008091332615</a></p><p>本文 知识 脑图 如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758550e143b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h2 id="一、Redis的数据模型"><a href="#一、Redis的数据模型" class="headerlink" title="一、Redis的数据模型"></a>一、Redis的数据模型</h2><p>用 键值对 <code>name：&quot;小明&quot;</code>来展示Redis的数据模型如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758534a337a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><ul><li><strong>dictEntry:</strong>   在一些编程语言中，键值对的数据结构被称为字典，而在Redis中，会给每一个key-value键值对分配一个字典实体，就是“dicEntry”。dicEntry包含三部分： <strong>key的指针、val的指针、next指针</strong>，next指针指向下一个dicteEntry形成链表，这个next指针可以将多个哈希值相同的键值对链接在一起，<strong>通过链地址法来解决哈希冲突的问题</strong></li><li><strong>sds</strong> ：<strong>Simple Dynamic String</strong>，简单动态字符串，存储字符串数据。</li><li><strong>redisObject</strong>：Redis的5种常用类型都是以RedisObject来存储的，redisObject中的<strong>type</strong>字段指明了值的数据类型（也就是5种基本类型)。<strong>ptr</strong>字段指向对象所在的地址。</li></ul><p>RedisObject对象很重要，Redis<strong>对象的类型</strong>、<strong>内部编码</strong>、<strong>内存回收</strong>、<strong>共享对象</strong>等功能，都是基于RedisObject对象来实现的。</p><p><strong>这样设计的好处是：可以针对不同的使用场景，对5种常用类型设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</strong></p><p>Redis将jemalloc作为默认内存分配器，减小内存碎片。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Redis 对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 类型</span><br><span class="line">    unsigned type:4;        </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 不使用(对齐位)</span><br><span class="line">    unsigned notused:2;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 编码方式</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; LRU 时间（相对于 server.lruclock）</span><br><span class="line">    unsigned lru:22;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 引用计数</span><br><span class="line">    int refcount;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 指向对象的值</span><br><span class="line">    void *ptr;</span><br><span class="line"> </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h2 id="二、Redis支持的数据结构"><a href="#二、Redis支持的数据结构" class="headerlink" title="二、Redis支持的数据结构"></a>二、Redis支持的数据结构</h2><p>Redis支持的数据结构有哪些？</p><p>如果回答是String、List、Hash、Set、Zset就不对了，这5种是redis的常用基本数据类型，每一种数据类型内部还包含着多种数据结构。</p><p>用encoding指令来看一个值的数据结构。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name tom</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此处设置了name值是tom，它的数据结构是embstr，下文介绍字符串时会详解说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding age</span><br><span class="line">&quot;int&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如下表格总结Redis中所有的数据结构类型：</p><table><thead><tr><th>底层数据结构</th><th>编码常量</th><th>object encoding指令输出</th></tr></thead><tbody><tr><td>整数类型</td><td>REDIS_ENCODING_INT</td><td>“int”</td></tr><tr><td>embstr字符串类型</td><td>REDIS_ENCODING_EMBSTR</td><td>“embstr”</td></tr><tr><td>简单动态字符串</td><td>REDIS_ENCODING_RAW</td><td>“raw”</td></tr><tr><td>字典类型</td><td>REDIS_ENCODING_HT</td><td>“hashtable”</td></tr><tr><td>双端链表</td><td>REDIS_ENCODING_LINKEDLIST</td><td>“linkedlist”</td></tr><tr><td>压缩列表</td><td>REDIS_ENCODING_ZIPLIST</td><td>“ziplist”</td></tr><tr><td>整数集合</td><td>REDIS_ENCODING_INTSET</td><td>“intset”</td></tr><tr><td>跳表和字典</td><td>REDIS_ENCODING_SKIPLIST</td><td>“skiplist”</td></tr></tbody></table><p><strong>补充说明</strong></p><blockquote><p>假如面试官问：redis的数据类型有哪些？</p><p>回答：String、list、hash、set、zet</p></blockquote><p>一般情况下这样回答是正确的，前文也提到redis的数据类型确实是包含这5种，但细心的同学肯定发现了之前说的是<strong>“常用”</strong>的5种数据类型。其实，随着Redis的不断更新和完善，Redis的数据类型早已不止5种了。</p><p>登录redis的官方网站打开官方的数据类型介绍：</p><p><a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">redis.io/topics/data…</a></p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b4475857ff2a94?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>发现Redis支持的数据结构不止5种，而是8种，后三种类型分别是：</p><ul><li>位数组（或简称位图）：使用特殊命令可以处理字符串值，如位数组：您可以设置和清除各个位，将所有位设置为1，查找第一个位或未设置位，等等。</li><li>HyperLogLogs：这是一个概率数据结构，用于估计集合的基数。不要害怕，它比看起来更简单。</li><li>Streams：仅附加的类似于地图的条目集合，提供抽象日志数据类型。</li></ul><p>本文主要介绍5种常用的数据类型，上述三种以后再共同探索。</p><h3 id="2-1-string字符串"><a href="#2-1-string字符串" class="headerlink" title="2.1 string字符串"></a>2.1 string字符串</h3><p>字符串类型是redis最常用的数据类型，在Redis中，字符串是可以修改的，在底层它是以字节数组的形式存在的。</p><p>Redis中的字符串被称为简单动态字符串「SDS」，这种结构很像Java中的ArrayList，其长度是动态可变的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SDS&lt;T&gt; &#123;</span><br><span class="line">  T capacity; &#x2F;&#x2F; 数组容量</span><br><span class="line">  T len; &#x2F;&#x2F; 数组长度</span><br><span class="line">  byte[] content; &#x2F;&#x2F; 数组内容</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b447584f4b52d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p><strong>content[]</strong> 存储的是字符串的内容，<strong>capacity</strong>表示数组分配的长度，<strong>len</strong>表示字符串的实际长度。</p><p>字符串的编码类型有int、embstr和raw三种，如上表所示，那么这三种编码类型有什么不同呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;    &#x2F;&#x2F;简单动态字符串(simple dynamic string, SDS)的抽象类型</span><br><span class="line">  &#x2F;&#x2F; 用于记录buf数组中使用的字节的数目</span><br><span class="line">  &#x2F;&#x2F; 和SDS存储的字符串的长度相等  </span><br><span class="line">int len;    </span><br><span class="line">  &#x2F;&#x2F; 用于记录buf数组中没有使用的字节的数目   </span><br><span class="line">int free;    </span><br><span class="line">  &#x2F;&#x2F; 字节数组，用于储存字符串</span><br><span class="line">char buf[];   &#x2F;&#x2F;buf的大小等于len+free+1，其中多余的1个字节是用来存储’\0’的。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>int 编码</strong>：保存的是可以用 long 类型表示的整数值。</li><li><strong>raw 编码</strong>：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li><li><strong>embstr 编码</strong>：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li></ul><p><img src="https://img2018.cnblogs.com/blog/1432634/201907/1432634-20190724185636136-1199490260.png" alt="img"></p><p>设置一个值测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set num 300</span><br><span class="line">127.0.0.1:6379&gt; object encoding num</span><br><span class="line">&quot;int&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key1 wealwaysbyhappyhahaha</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key2 hahahahahahahaahahahahahahahahahahahaha</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; strlen key2</span><br><span class="line">(integer) 39</span><br><span class="line">127.0.0.1:6379&gt; object encoding key2</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key2 hahahahahahahaahahahahahahahahahahahahahahaha</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key2</span><br><span class="line">&quot;raw&quot;</span><br><span class="line">127.0.0.1:6379&gt; strlen key2</span><br><span class="line">(integer) 45</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="raw类型和embstr类型对比"><a href="#raw类型和embstr类型对比" class="headerlink" title="raw类型和embstr类型对比"></a>raw类型和embstr类型对比</h4><p>embstr编码的结构:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b447584f3e35a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>raw编码的结构：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758547bc9c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="raw编码"></p><blockquote><p>embstr和raw都是由redisObject和sds组成的。不同的是：embstr的redisObject和sds是连续的，只需要使用<strong>malloc</strong>分配一次内存；而raw需要为redisObject和sds分别分配内存，即需要分配两次内存。</p><p>所有相比较而言，embstr少分配一次内存，更方便。但embstr也有明显的缺点：如要增加长度，redisObject和sds都需要重新分配内存。</p></blockquote><p>上文介绍了embstr和raw结构上的不同。重点来了~ <strong>为什么会选择44作为两种编码的分界点？在3.2版本之前为什么是39？这两个值是怎么得出来的呢？</strong></p><p><strong>1） 计算RedisObject占用的字节大小</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct RedisObject &#123;</span><br><span class="line">    int4 type; &#x2F;&#x2F; 4bits</span><br><span class="line">    int4 encoding; &#x2F;&#x2F; 4bits</span><br><span class="line">    int24 lru; &#x2F;&#x2F; 24bits</span><br><span class="line">    int32 refcount; &#x2F;&#x2F; 4bytes &#x3D; 32bits</span><br><span class="line">    void *ptr; &#x2F;&#x2F; 8bytes，64-bit system</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>type: 不同的redis对象会有不同的数据类型(string、list、hash等)，type记录类型，会用到<strong>4bits</strong>。</li><li>encoding：存储编码形式，用<strong>4bits</strong>。</li><li>lru：用<strong>24bits</strong>记录对象的LRU信息。</li><li>refcount：引用计数器，用到<strong>32bits</strong>。</li><li><em>ptr：指针指向对象的具体内容，需要*</em>64bits**。</li></ul><p>计算： 4 + 4 + 24 + 32 + 64 = 128bits = <strong>16bytes</strong></p><p>第一步就完成了，RedisObject对象头信息会占用<strong>16字节</strong>的大小，这个大小通常是固定不变的.</p><p><strong>2) sds占用字节大小计算</strong></p><p><strong>旧版本：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SDS &#123;</span><br><span class="line">    unsigned int capacity; &#x2F;&#x2F; 4byte</span><br><span class="line">    unsigned int len; &#x2F;&#x2F; 4byte</span><br><span class="line">    byte[] content; &#x2F;&#x2F; 内联数组，长度为 capacity</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里的<strong>unsigned int</strong> 一个4字节，加起来是8字节.</p><p>内存分配器jemalloc分配的内存如果超出了64个字节就认为是一个大字符串，就会用到raw编码。</p><p>前面提到 SDS 结构体中的 content 的字符串是以字节\0结尾的字符串，之所以多出这样一个字节，是为了便于直接使用 glibc 的字符串处理函数，以及为了便于字符串的调试打印输出。所以我们还要减去1字节 <strong>64byte  -  16byte   -  8byte  -  1byte  =  39byte</strong></p><p><strong>新版本：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct SDS &#123;</span><br><span class="line">    int8 capacity; &#x2F;&#x2F; 1byte</span><br><span class="line">    int8 len; &#x2F;&#x2F; 1byte</span><br><span class="line">    int8 flags; &#x2F;&#x2F; 1byte</span><br><span class="line">    byte[] content; &#x2F;&#x2F; 内联数组，长度为 capacity</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里unsigned int 变成了uint8_t、uint16_t.的形式，还加了一个char flags标识，总共只用了3个字节的大小。相当于优化了sds的内存使用，相应的用于存储字符串的内存就会变大。</p><p>然后进行计算：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b447586c898442?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p><strong>64byte - 16byte -3byte -1byte = 44byte</strong>。</p><p><strong>总结：</strong></p><p>所以，redis 3.2版本之后embstr最大能容纳的字符串长度是44，之前是39。长度变化的原因是SDS中内存的优化。</p><h3 id="2-2-List"><a href="#2-2-List" class="headerlink" title="2.2 List"></a>2.2 List</h3><p>Redis中List对象的底层是由quicklist(快速列表)实现的，快速列表支持从链表头和尾添加元素，并且可以获取指定位置的元素内容。</p><p>那么，快速列表的底层是如何实现的呢？为什么能够达到如此快的性能？</p><p>罗马不是一日建成的，quicklist也不是一日实现的，起初redis的list的底层是ziplist（压缩列表）或者是  linkedlist（双端列表）。先分别介绍这两种数据结构。</p><h4 id="ziplist-压缩列表"><a href="#ziplist-压缩列表" class="headerlink" title="ziplist 压缩列表"></a>ziplist 压缩列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ziplist是由一系列特殊编码的连续内存块组成的顺序存储结构，类似于数组，ziplist在内存中是连续存储的，但是不同于数组，为了节省内存 ziplist的每个元素所占的内存大小可以不同。ziplist的每个节点的长度是可以不一样的。ziplist将一些必要的偏移量信息记录在了每一个节点里，使之能跳到上一个节点或下一个节点。</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush dotahero sf qop doom</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; object encoding dotahero</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure><p>此处使用老版本redis进行测试，向dota英雄列表中加入了qop痛苦女王、sf影魔、doom末日使者三个英雄，数据结构编码使用的是ziplist。</p><p><strong>所以 ziplist是Redis为了节约内存而开发的</strong>，是由一系列特殊编码的连续内存块组成的顺序型数据结构。具体结构相对比较复杂，大家有兴趣地话可以深入了解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct ziplist&lt;T&gt; &#123;</span><br><span class="line">    int32 zlbytes; &#x2F;&#x2F; 整个压缩列表占用字节数</span><br><span class="line">    int32 zltail_offset; &#x2F;&#x2F; 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点</span><br><span class="line">    int16 zllength; &#x2F;&#x2F; 元素个数</span><br><span class="line">    T[] entries; &#x2F;&#x2F; 元素内容列表，挨个挨个紧凑存储</span><br><span class="line">    int8 zlend; &#x2F;&#x2F; 标志压缩列表的结束，值恒为 0xFF</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b447587271beeb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h4 id="双端列表（linkedlist）"><a href="#双端列表（linkedlist）" class="headerlink" title="双端列表（linkedlist）"></a>双端列表（linkedlist）</h4><p>双端列表大家都很熟悉，这里的双端列表和java中的linkedlist很类似。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b4475875e8182a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>从图中可以看出Redis的linkedlist双端链表有以下特性：节点带有prev、next指针、head指针和tail指针，获取前置节点、后置节点、表头节点和表尾节点、获取长度的复杂度都是O(1)。</p><p><strong>压缩列表占用内存少，但是是顺序型的数据结构，插入删除元素的操作比较复杂，所以压缩列表适合数据比较小的情况，当数据比较多的时候，双端列表的高效插入删除还是更好的选择</strong></p><p>在Redis开发者的眼中，数据结构的选择，时间上、空间上都要达到极致，所以，他们将压缩列表和双端列表合二为一，创建了<strong>快速列表（quicklist）</strong>。和java中的hashmap一样，结合了数组和链表的优点。</p><h4 id="快速列表（quicklist）"><a href="#快速列表（quicklist）" class="headerlink" title="快速列表（quicklist）"></a>快速列表（quicklist）</h4><ul><li>rpush: listAddNodeHead —O(1)</li><li>lpush: listAddNodeTail —O(1)</li><li>push:listInsertNode —O(1)</li><li>index : listIndex —O(N)</li><li>pop:ListFirst/listLast —O(1)</li><li>llen:listLength —O(N)</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b4475876af391e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct ziplist &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">struct ziplist_compressed &#123;</span><br><span class="line">    int32 size;</span><br><span class="line">    byte[] compressed_data;</span><br><span class="line">&#125;</span><br><span class="line">struct quicklistNode &#123;</span><br><span class="line">    quicklistNode* prev;</span><br><span class="line">    quicklistNode* next;</span><br><span class="line">    ziplist* zl; &#x2F;&#x2F; 指向压缩列表</span><br><span class="line">    int32 size; &#x2F;&#x2F; ziplist 的字节总数</span><br><span class="line">    int16 count; &#x2F;&#x2F; ziplist 中的元素数量</span><br><span class="line">    int2 encoding; &#x2F;&#x2F; 存储形式 2bit，原生字节数组还是 LZF 压缩存储</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">struct quicklist &#123;</span><br><span class="line">    quicklistNode* head;</span><br><span class="line">    quicklistNode* tail;</span><br><span class="line">    long count; &#x2F;&#x2F; 元素总数</span><br><span class="line">    int nodes; &#x2F;&#x2F; ziplist 节点的个数</span><br><span class="line">    int compressDepth; &#x2F;&#x2F; LZF 算法压缩深度</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数list-compress-depth决定。为了支持快速的 push/pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p><h3 id="2-3-Hash"><a href="#2-3-Hash" class="headerlink" title="2.3 Hash"></a>2.3 Hash</h3><p>Hash数据类型的底层实现是ziplist（压缩列表）或字典（也称为hashtable或散列表）。这里压缩列表或者字典的选择，也是根据元素的数量大小决定的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758773ee9fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>如图hset了三个键值对，每个值的字节数不超过64的时候，默认使用的数据结构是<strong>ziplist</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b4475886a94f94?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>当我们加入了字节数超过64的值的数据时，默认的数据结构已经成为了hashtable。</p><p><strong>Hash对象只有同时满足下面两个条件时，才会使用ziplist（压缩列表）：</strong></p><ul><li>哈希中元素数量小于512个；</li><li>哈希中所有键值对的键和值字符串长度都小于64字节。</li></ul><p>压缩列表刚才已经了解了，hashtables类似于jdk1.7以前的hashmap。hashmap采用了链地址法的方法解决了哈希冲突的问题。想要深入了解的话可以参考之前写的一篇博客： <a href="https://blog.csdn.net/qq_32519415/article/details/87006982" target="_blank" rel="noopener">hashmap你真的了解吗</a></p><h4 id="Redis中的字典"><a href="#Redis中的字典" class="headerlink" title="Redis中的字典"></a>Redis中的字典</h4><p><strong>典</strong>， 又称符号表（symbol table）、关联数组（associative array）或者映射（map）， 是一种用于保存键值对（key-value pair）的抽象数据结构。在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。</p><p>字典中的每个键都是独一无二的， 程序可以在字典中根据键查找与之关联的值， 或者通过键来更新值， 又或者根据键来删除整个键值对， 等等。</p><h4 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h4><blockquote><p>Redis 的字典采用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。所以咱们依次来分析一下哈希表、哈希表节点、以及字典的结构。</p></blockquote><h4 id="1-哈希表结构"><a href="#1-哈希表结构" class="headerlink" title="1.哈希表结构"></a>1.哈希表结构</h4><p><strong>哈希表结构定义</strong> （dict.h/dictht）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表数组</span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表大小</span><br><span class="line">    unsigned long size;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表大小掩码，用于计算索引值</span><br><span class="line">    &#x2F;&#x2F; 总是等于 size - 1</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 该哈希表已有节点的数量</span><br><span class="line">    unsigned long used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>描述</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h&#x2F;dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</span><br><span class="line"></span><br><span class="line">size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</span><br><span class="line"></span><br><span class="line">sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>结构图解：一个空的哈希表</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6adabf00ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><h4 id="2-哈希表节点"><a href="#2-哈希表节点" class="headerlink" title="2.哈希表节点"></a>2.哈希表节点</h4><p>一个哈希表里面可以有多个哈希表节点，那么每个哈希表节点的结构以及多个哈希表节点之间的存储关系是怎么样的呢？</p><p><strong>哈希表节点结构定义</strong> （dictEntry）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 键</span><br><span class="line">    void *key;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 值</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指向下个哈希表节点，形成链表</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>描述</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， </span><br><span class="line">或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</span><br><span class="line"></span><br><span class="line">next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以此来解决键冲突（collision）的问题。</p><p>结构图解：多个哈希值相同的键值对存储结构，解决键冲突</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6adb3ebce3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><h4 id="3-字典结构实现"><a href="#3-字典结构实现" class="headerlink" title="3.字典结构实现"></a>3.字典结构实现</h4><p><strong>字典结构定义</strong> （dict.h/dict）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 类型特定函数</span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; rehash 索引</span><br><span class="line">    &#x2F;&#x2F; 当 rehash 不在进行时，值为 -1</span><br><span class="line">    int rehashidx; &#x2F;* rehashing not in progress if rehashidx &#x3D;&#x3D; -1 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p><strong>描述</strong>：type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数，</span><br><span class="line">Redis 会为用途不同的字典设置不同的类型特定函数。</span><br><span class="line"></span><br><span class="line">privdata 属性则保存了需要传给那些类型特定函数的可选参数。</span><br><span class="line">复制代码</span><br><span class="line">typedef struct dictType &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 计算哈希值的函数</span><br><span class="line">    unsigned int (*hashFunction)(const void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 复制键的函数</span><br><span class="line">    void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 复制值的函数</span><br><span class="line">    void *(*valDup)(void *privdata, const void *obj);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对比键的函数</span><br><span class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁键的函数</span><br><span class="line">    void (*keyDestructor)(void *privdata, void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁值的函数</span><br><span class="line">    void (*valDestructor)(void *privdata, void *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p><p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p><p>结构图解：普通状态下（没有进行 rehash）的字典</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6adba856b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><h4 id="哈希表分析"><a href="#哈希表分析" class="headerlink" title="哈希表分析"></a>哈希表分析</h4><h4 id="1-哈希算法"><a href="#1-哈希算法" class="headerlink" title="1.哈希算法"></a>1.哈希算法</h4><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><p>Redis 计算哈希值和索引值的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash &#x3D; dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class="line">index &#x3D; hash &amp; dict-&gt;ht[x].sizemask;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如图 4-4：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6adc63be56?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><p>举个例子， 对于图 4-4 所示的字典来说， 如果我们要将一个键值对 k0 和 v0 添加到字典里面， 那么程序会先使用语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash &#x3D; dict-&gt;type-&gt;hashFunction(k0);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>计算键 k0 的哈希值。</p><p>假设计算得出的哈希值为 8 ， 那么程序会继续使用语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index &#x3D; hash &amp; dict-&gt;ht[0].sizemask &#x3D; 8 &amp; 3 &#x3D; 0;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>计算出键 k0 的索引值 0 ， 这表示包含键值对 k0 和 v0 的节点应该被放置到哈希表数组的索引 0 位置上， 结构图解：图 4-5</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6ae014913d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><h4 id="2-键冲突解决"><a href="#2-键冲突解决" class="headerlink" title="2.键冲突解决"></a>2.键冲突解决</h4><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p><p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p><p>举个例子， 假设程序要将键值对 k2 和 v2 添加到图 4-6 所示的哈希表里面， 并且计算得出 k2 的索引值为 2 ， 那么键 k1 和 k2 将产生冲突， 而解决冲突的办法就是使用 next 指针将键 k2 和 k1 所在的节点连接起来。 结构图解：图 4-7</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6ae08fb489?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/30/1739da6b451b7570?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Redis五种数据类型"></p><p>因为 dictEntry 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面。</p><h4 id="3-rehash"><a href="#3-rehash" class="headerlink" title="3.rehash"></a>3.rehash</h4><p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大<br>的负担。<br>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次<br>rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1]<br>上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。<br>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。<br>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执<br>行。</p><h4 id="4-扩容或者缩容"><a href="#4-扩容或者缩容" class="headerlink" title="4. 扩容或者缩容"></a>4. 扩容或者缩容</h4><ul><li>随着操作的不断执行，哈希表保存的键值对会<strong>逐渐地增多或者减少</strong>，为了让哈希表的<strong>负载因子（load factor）</strong>维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩</li><li>扩展和收缩哈希表的工作可以</li></ul><blockquote><h3 id="哈希表的自动扩展与收缩"><a href="#哈希表的自动扩展与收缩" class="headerlink" title="哈希表的自动扩展与收缩"></a>哈希表的自动扩展与收缩</h3><ul><li><p>当以下条件中的任意一个被满足时，程序</p><p><strong>会自动开始对哈希表执行扩展操作：</strong></p><ul><li>①服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1</li><li>②服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5</li></ul></li><li><p>其中哈希表的<strong><em>\</em>负载因子可以通过下列公式得出：**</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#负载因子= 哈希表已保存节点数量/哈希表大小</span><br><span class="line">load_factor = ht[<span class="number">0</span>].used/ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure><ul><li>例如，对于一个大小为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor = <span class="number">4</span>/<span class="number">4</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>又例如，对于一个大小为512，包含256个键值对的哈希表来说，这个哈希表的负载因子为：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor = <span class="number">256</span>/<span class="number">512</span>=<span class="number">0.5</span></span><br></pre></td></tr></table></figure><ul><li>根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技 术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负 载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内 存写入操作，最大限度地节约内存</li><li>另一方面，当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作</li></ul></blockquote><p>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的<img src="https://private.codecogs.com/gif.latex?2%5E%7Bn%7D" alt="2^{n}">（2的n次方幂）； ·如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的<img src="https://private.codecogs.com/gif.latex?2%5E%7Bn%7D" alt="2^{n}"></p><h4 id="5-渐进式rehash执行期间的哈希表操作"><a href="#5-渐进式rehash执行期间的哈希表操作" class="headerlink" title="5.渐进式rehash执行期间的哈希表操作"></a>5.渐进式rehash执行期间的哈希表操作</h4><ul><li>因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐 进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两 个哈希表上进行。例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如 果没找到的话，就会继续到ht[1]里面进行查找，诸如此类</li><li>另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而 ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着 rehash操作的执行而最终变成空表</li></ul><h2 id="四、要点总结"><a href="#四、要点总结" class="headerlink" title="四、要点总结"></a>四、要点总结</h2><blockquote><p>1.字典 ht 属性是包含两个哈希表项的数组，一般情况下， 字典只使用 ht[0]， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash (下节分析) 时使用</p></blockquote><p>redis中的dict 结构内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的。但是在 dict 扩容缩容时，需要分配新的 hashtable，然后进行渐进式搬迁，这时两个 hashtable 存储的分别是旧的 hashtable 和新的 hashtable。待搬迁结束后，旧的 hashtable 被删除，新的 hashtable 取而代之。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b44758921c661d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h3 id="2-4-Set"><a href="#2-4-Set" class="headerlink" title="2.4 Set"></a>2.4 Set</h3><p>Set数据类型的底层可以是<strong>intset</strong>(整数集)或者是<strong>hashtable</strong>(散列表也叫哈希表)。</p><p>当数据都是整数并且数量不多时，使用intset作为底层数据结构；当有除整数以外的数据或者数据量增多时，使用hashtable作为底层数据结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset 111 222 333</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; object encoding myset</span><br><span class="line">&quot;intset&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd myset hahaha</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding myset</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>inset的数据结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    &#x2F;&#x2F; 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    &#x2F;&#x2F; 集合包含的元素数量</span><br><span class="line">    uint32_t length;</span><br><span class="line">    &#x2F;&#x2F; 保存元素的数组</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>intset底层实现为有序、无重复数的数组。 intset的整数类型可以是16位的、32位的、64位的。如果数组里所有的整数都是16位长度的，新加入一个32位的整数，那么整个16的数组将升级成一个32位的数组。升级可以提升intset的灵活性，又可以节约内存，但不可逆。</p></blockquote><h3 id="2-5-Zset"><a href="#2-5-Zset" class="headerlink" title="2.5 Zset"></a>2.5 Zset</h3><p>Redis中的Zset，也叫做<strong>有序集合</strong>。它的底层是ziplist（压缩列表）或 <strong>skiplist</strong>（跳跃表）。</p><p>压缩列表前文已经介绍过了，同理是在元素数量比较少的时候使用。此处主要介绍跳跃列表。</p><hr><p>  跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>  跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p>  在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p><p>  Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>  和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。</p><hr><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>跳跃表（skiplist）是一种<strong>有序数据链表结构</strong>， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。查询平均性能为O(logN)，最坏的情况会出现O(N)情况，而redis中的zset在数据较多的时候底层就是采用跳跃表去实现的，元素较少的时候会进行小对象压缩采用压缩列表实现。</p><p><img src="https://img-blog.csdnimg.cn/20200413141708514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9mZW5nMTAzMzAxMTE=,size_16,color_FFFFFF,t_70" alt="img"></p><p>从上述图我们可以看出跳跃表有以下几个特点：</p><ul><li><p>跳跃表的每个节点都有多层构成。</p></li><li><p>跳跃表存在一个头结点，该头结点有64层结构，每层都包含指向下个节点的指针，指向本层下个节点中间所跨越的节点个数为跨度（span）。</p></li><li><p>除头结点以外，层高最高的节点为该跳跃表的level，图中的跳跃表level为3。</p></li><li><p>每层都是一个有序链表。</p></li><li><p>最底层的有序链表包含所有的节点数，也即是整个跳跃表的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    robj *obj;  &#x2F;*成员对象*&#x2F;</span><br><span class="line">    double score;   &#x2F;*分值*&#x2F;</span><br><span class="line">    struct zskiplistNode *backward; &#x2F;*后退指针*&#x2F;</span><br><span class="line">    struct zskiplistLevel &#123; &#x2F;*层*&#x2F;</span><br><span class="line">        struct zskiplistNode *forward;  &#x2F;*前进指针*&#x2F;</span><br><span class="line">        unsigned int span;  &#x2F;*跨度*&#x2F;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    struct zskiplistNode *header, *tail;    &#x2F;&#x2F;header指向跳跃表的表头节点，tail指向跳跃表的表尾节点</span><br><span class="line">    unsigned long length;   &#x2F;&#x2F;记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</span><br><span class="line">    int level;  &#x2F;&#x2F;记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>跳跃表<strong><em>\</em>每个节点都维护了多个指向其他节点的指针\</strong>，*<em>所以在进行查询、更新、删除等操作的时候不需要进行整条链表的遍历*</em>，*<em>可以通过维护的指针过滤掉中间的很多节点，从而达到很快速的访问效果***</em>，一般情况来说跳跃表的性能能与平衡树相媲美的，而且跳跃表实现较为简单，所以这也是<strong><em>\</em>redis为什么采用跳跃表来作为zset底层的数据结构实现**</strong>。</p><p><strong>查找过程</strong></p><p>跳跃表的查询，跳跃表有多层的情况下查询复杂度为O(logN)，如果跳跃表就一层那么查询复杂度会上升为O(N)，接下来我们就用图1的实例来模拟下查询score为70的节点的具体查询过程。</p><p><img src="https://img-blog.csdnimg.cn/20200413191759762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9mZW5nMTAzMzAxMTE=,size_16,color_FFFFFF,t_70" alt="img"></p><p>如图所示我们需要找到score为70的节点，查找首先从header开始，因为level为3我们先从L2开始往后开始遍历，查找到第一个节点，发现score比70小，继续往后遍历查找到第五个节点，发现score比70大，于是从当前节点往下一层进行查找，查找到节点3，以此类推，最终查询到score为70的节点。</p><p><strong>插入以及更新过程</strong><br>插入过程：跳跃表插入节点的时候，首先需要通过score找到自己的位置，也就是需要先走一步查找过程，找到新节点所处的位置的时候就创建一个新节点，并对新节点分配一个层数（这里层数的分配redis采用的是random随机机制，分配层数从1开始，每次晋升为上一层的概率为0.25），层数分配完了之后将前后指针进行赋值将新节点与旧节点串起来，<strong><em>\</em>如果层数大于当前的level还需要进行level的更新操作。**</strong></p><p>更新过程：更新过程会稍微复杂一些，更新其实就是插入，只不过插入的时候发现value已经存在了，只是<strong>需要调整一下score值</strong>，如果更新的score值不会带来位置上的改变，那么直接更新score就行不需要进行调整位置，但是如果新score会导致排序改变，那么就需要调整位置了，redis采用的方式比较直接就是先删除这个元素然后再插入这个元素即可，前后需要两次路径搜索</p><p>  Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。</p><p><img src="https://img-blog.csdn.net/20160412161658898" alt="一个跳跃表"></p><p>  上图展示了一个跳跃表示例，位于图片最左边的是zskiplist结构，该结构包含以下属性：</p><ul><li>header：指向跳跃表的表头节点</li><li>tail：指向跳跃表的表尾节点</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li><li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</li></ul><p>  位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：</p><ul><li>层(level)：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，依次类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li><li>后退(backward)指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>分值(score)：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>成员对象(obj)：各个节点中的o1、o2和o3是节点所保存的成员对象。</li></ul><p>  注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#### **跳跃表节点**</span><br><span class="line"></span><br><span class="line">  跳跃表节点的实现由redis.h&#x2F;zskiplistNode结构定义：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;c</span><br><span class="line">&#x2F;* ZSETs use a specialized version of Skiplists *&#x2F;</span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    robj *obj;  &#x2F;*成员对象*&#x2F;</span><br><span class="line">    double score;   &#x2F;*分值*&#x2F;</span><br><span class="line">    struct zskiplistNode *backward; &#x2F;*后退指针*&#x2F;</span><br><span class="line">    struct zskiplistLevel &#123; &#x2F;*层*&#x2F;</span><br><span class="line">        struct zskiplistNode *forward;  &#x2F;*前进指针*&#x2F;</span><br><span class="line">        unsigned int span;  &#x2F;*跨度*&#x2F;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>  1、分值和成员</p><p>  节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。</p><p>  节点的成员对象(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。</p><p>  在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分至相同的节点将按照成员对象在字典中的大小来进行排序，成员对象较小的节点会排在前面(靠近表头的方向)，而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p><p>  举个例子，在下图中所示的跳跃表中，三个跳跃表节点都保存了相同的分值10086.0，但保存成员对象o1的节点却排在保存成员对象o2和o3的节点的前面，而保存成员对象o2的节点又排在保存成员对象o3的节点之前，由此可见，o1、o2、o3三个成员对象在字典中的排序为o1&lt;=o2&lt;=o3。</p><p><img src="https://img-blog.csdn.net/20160412174412181" alt="三个带有相同分值的跳跃表节点"></p><p>  2、后退指针</p><p>  节点的后退指针(backward属性)用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p><p>  下图用虚线展示了如何从表尾向表头遍历跳跃表中的所有节点：程序首先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点，之后再沿着后退指针访问倒数第三个节点，再之后遇到指向NULL的后退指针，于是访问结束。</p><p><img src="https://img-blog.csdn.net/20160412194049758" alt="从表尾向表头方向遍历跳跃表"></p><p>  3、层</p><p>  跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。</p><p>  每次创建一个新跳跃表节点的时候，程序根据幂次定律(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。</p><p>  下图分别展示了三个高度为1层、3层和5层的节点，因为C语言的数组索引总是从0开始的，所以节点的第一层是level[0]，而第二层是level[1]，依次类推。</p><p><img src="https://img-blog.csdn.net/20160412195202083" alt="带有不同层高的节点"></p><p>  4、前进指针</p><p>  每个层都有一个指向表尾方向的前进指针(level[i].forward属性)，用于从表头向表尾方向访问节点。下图用虚线表示出了程序从表头向表尾方向，遍历跳跃表中所有节点的路径：</p><p><img src="https://img-blog.csdn.net/20160412195458493" alt="遍历整个跳跃表"></p><p>  1) 迭代程序首先访问跳跃表的第一个节点(表头)，然后从第四层的前进指针移动到表中的第二个节点。<br>  2) 在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。<br>  3) 在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。<br>  4) 当程序再次沿着第四个节点的前进指针移动时，它碰到一个NULL，程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历。</p><p>  5、跨度</p><p>  层的跨度(level[i].span属性)用于记录两个节点之间的距离：</p><ul><li>两个节点之间的跨度越大，它们相距得就越远。</li><li>指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。</li></ul><p>  初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样的，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p>  举个例子，下图用虚线标记了在跳跃表中查找分值为3.0、成员对象为o3的节点时，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为3，所以目标节点在跳跃表中的排位为3。</p><p><img src="https://img-blog.csdn.net/20160412201553302" alt="计算节点的排位"></p><p>  再举个例子，下图用虚线标记了在跳跃表中查找分值为2.0、成员对象为o2的节点时，沿途经历的层：在查找节点的过程中，程序经过了两个跨度为1的节点，因此可以计算出，目标节点在跳跃表中的排位为2。</p><p><img src="https://img-blog.csdn.net/20160412201857509" alt="另一个计算节点排位的例子"></p><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a><strong>跳跃表</strong></h4><p>  仅靠多个跳跃表节点就可以组成一个跳跃表，如下图所示：</p><p><img src="https://img-blog.csdn.net/20160412202104618" alt="多个跳跃节点组成的跳跃表"></p><p>  但通过使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量(也即是跳跃表的长度)等信息，如下图所示：</p><p><img src="https://img-blog.csdn.net/20160412202419032" alt="带有zskiplist结构的跳跃表"></p><p>  zskiplist结构的定义如下：</p><p>​<code>ctypedef struct zskiplist {    struct zskiplistNode *header, *tail;    //header指向跳跃表的表头节点，tail指向跳跃表的表尾节点    unsigned long length;   //记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)    int level;  //记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)} zskiplist;12345​</code></p><p>  这样获取表头、表尾节点，表长，以及表中最高层数的复杂度均为O(1)。</p><p>```</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文大概介绍了Redis的5种常用数据类型的底层实现，希望大家结合源码和资料更深入地了解。</p><p>数据结构之美在Redis中体现得淋漓尽致，从String到压缩列表、快速列表、散列表、跳表，这些数据结构都适用在了不同的地方，各司其职。</p><p>不仅如此，Redis将这些数据结构加以升级、结合，将内存存储的效率性能达到了极致，正因为如此，Redis才能成为众多互联网公司不可缺少的高性能、秒级的key-value内存数据库。</p><p>作者：宜信技术学院<br>链接：<a href="https://juejin.im/post/6844903863145742350" target="_blank" rel="noopener">https://juejin.im/post/6844903863145742350</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2020/10/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1. 01背包问题"></a>1. 01背包问题</h2><p>有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。</p><p>第 ii 件物品的体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 读入数据的代码</span><br><span class="line">        Scanner reader &#x3D; new Scanner(System.in);</span><br><span class="line">        &#x2F;&#x2F; 物品的数量为N</span><br><span class="line">        int N &#x3D; reader.nextInt();</span><br><span class="line">        &#x2F;&#x2F; 背包的容量为V</span><br><span class="line">        int V &#x3D; reader.nextInt();</span><br><span class="line">        &#x2F;&#x2F; 一个长度为N的数组，第i个元素表示第i个物品的体积；</span><br><span class="line">        int[] v &#x3D; new int[N + 1] ;</span><br><span class="line">        &#x2F;&#x2F; 一个长度为N的数组，第i个元素表示第i个物品的价值；</span><br><span class="line">        int[] w &#x3D; new int[N + 1] ;</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;1 ; i &lt;&#x3D; N ; i++)&#123;</span><br><span class="line">            &#x2F;&#x2F; 接下来有 N 行，每行有两个整数:v[i],w[i]，用空格隔开，分别表示第i件物品的体积和价值</span><br><span class="line">            v[i] &#x3D; reader.nextInt();</span><br><span class="line">            w[i] &#x3D; reader.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close() ;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 正式工作的代码</span><br><span class="line">        &#x2F;*</span><br><span class="line">        定义一个二阶矩阵dp[N+1][V+1],</span><br><span class="line">        这里之所以要N+1和V+1，是因为第0行表示只能选择第0个物品的时候，即没有物品的时候</span><br><span class="line">        第0列表示背包的体积为0的时候，即不能装任何东西的时候</span><br><span class="line"></span><br><span class="line">        dp[i][j]表示在 只能选择前i个物品，背包容量为j的情况下，背包中物品的最大价值</span><br><span class="line">        对于dp[i][j]有两种情况：</span><br><span class="line">        1. 不选择当前的第i件物品&#x2F;第i件物品比背包容量要大，则dp[i][j] &#x3D; dp[i-1][j]</span><br><span class="line">        2. 选择当前的第i件物品（潜在要求第i件物品体积小于等于背包总容量），则能装入的物品最大价值为：</span><br><span class="line">            当前物品的价值 加上 背包剩余容量在只能选前i-1件物品的情况下的最大价值</span><br><span class="line">            dp[i][j] &#x3D; dp[i-1][j-v[i]] + w[i]</span><br><span class="line">        dp[i][j]在两种情况中选择比较大的情况作为当前的最优解；</span><br><span class="line">        即：</span><br><span class="line">        if(j &gt;&#x3D; v[i]):</span><br><span class="line">            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])</span><br><span class="line">        else:</span><br><span class="line">            dp[i][j] &#x3D; dp[i-1][j]</span><br><span class="line">        *&#x2F;</span><br><span class="line">        int[][] dp &#x3D; new int[N+1][V+1];</span><br><span class="line">        dp[0][0] &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt;&#x3D; V; j++)&#123;</span><br><span class="line">                if(j &gt;&#x3D; v[i])&#123;</span><br><span class="line">                    dp[i][j] &#x3D; Math.max(dp[i-1][j], dp[i-1][j-v[i]] + w[i]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[N][V]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后代码</p><pre><code>import java.util.Scanner;public class Main{    public static void main(String[] args) throws Exception {        // 读入数据的代码        Scanner reader = new Scanner(System.in);        // 物品的数量为N        int N = reader.nextInt();        // 背包的容量为V        int V = reader.nextInt();        // 一个长度为N的数组，第i个元素表示第i个物品的体积；        int[] v = new int[N + 1] ;        // 一个长度为N的数组，第i个元素表示第i个物品的价值；        int[] w = new int[N + 1] ;        for (int i=1 ; i &lt;= N ; i++){            // 接下来有 N 行，每行有两个整数:v[i],w[i]，用空格隔开，分别表示第i件物品的体积和价值            v[i] = reader.nextInt();            w[i] = reader.nextInt();        }    reader.close() ;    // 正式算法的代码    // 将dp优化为一维数组    /*    注意，这里第二层循环的时候，还是小到大循环的话，那么    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])    实际上变成了    dp[i][j] = Math.max(dp[i][j], dp[i][j-v[i]] + w[i]);    因为i-1的值已经在前面被更新过了，覆盖了    为了避免这个问题，所以要逆序更新，即先更新第i个，然后更新第i-1个，从而保证第i-1个不被覆盖    如果不逆序的话，输出结果为10，dp数组实际为：    0 0 0 0 0 0     0 2 4 6 8 10    0 2 4 6 8 10    0 2 4 6 8 10    0 2 4 6 8 10    */    int[] dp = new int[V+1];    dp[0] = 0;    for(int i = 1; i &lt;= N; i++){        for(int j = V; j &gt;= v[i]; j--){            dp[j] = Math.max(dp[j], dp[j-v[i]] + w[i]);        }        // for(int j = 0; j &lt;= V; j++){        //     System.out.print(dp[j]);        //     System.out.print(&quot; &quot;);        // }        // System.out.print(&quot;\n&quot;);    }    System.out.println(dp[V]); }}</code></pre><h2 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2.完全背包问题"></a>2.完全背包问题</h2><p>有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。</p><p>第 ii 种物品的体积是 vivi，价值是 wiwi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤10000&lt;N,V≤1000<br>0&lt;vi,wi≤10000&lt;vi,wi≤1000</p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 1010;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int dp[N][N], v[N], w[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</span><br><span class="line">        for(int j &#x3D; 0; j &lt;&#x3D; m; j ++ )</span><br><span class="line">            for(int k &#x3D; 0; k * v[i] &lt;&#x3D; j; k ++ )</span><br><span class="line">                dp[i][j] &#x3D; max(dp[i][j], dp[i - 1][j - k * v[i]] + k * w[i]);</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇总版</title>
      <link href="/2020/10/15/%E6%B1%87%E6%80%BB%E7%89%88/"/>
      <url>/2020/10/15/%E6%B1%87%E6%80%BB%E7%89%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>笔试题整理</title>
      <link href="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-王大锤"><a href="#1-王大锤" class="headerlink" title="1.王大锤"></a>1.王大锤</h2><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002172244791.png" alt="image-20201002172244791"></p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002172300325.png" alt="image-20201002172300325"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这题就暴力扫一遍就可以了，碰到3个连续的或者AABB删掉那个字符即可。。。</span><br><span class="line">&#x2F;&#x2F;当时没做出来。。。菜是原罪！</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        while(sc.hasNext())&#123;</span><br><span class="line">            int n &#x3D; Integer.parseInt(sc.nextLine());</span><br><span class="line">            for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">                StringBuilder sb &#x3D; new StringBuilder(sc.nextLine());</span><br><span class="line">                for(int j &#x3D; 2; j &lt; sb.length(); j++)&#123;</span><br><span class="line">                    if(sb.charAt(j) &#x3D;&#x3D; sb.charAt(j - 1) </span><br><span class="line">                       &amp;&amp; sb.charAt(j - 1) &#x3D;&#x3D; sb.charAt(j - 2))&#123;</span><br><span class="line">                        sb.deleteCharAt(j);</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if(isPattern(sb, j - 3, j))&#123;</span><br><span class="line">                        sb.deleteCharAt(j);</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean isPattern(StringBuilder sb, int i, int j)&#123;</span><br><span class="line">        if(i &lt; 0) return false;</span><br><span class="line">        return sb.charAt(i) &#x3D;&#x3D; sb.charAt(i + 1) &amp;&amp;</span><br><span class="line">                sb.charAt(j - 1) &#x3D;&#x3D; sb.charAt(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-雀魂"><a href="#2-雀魂" class="headerlink" title="2.雀魂"></a>2.雀魂<img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002220653472.png" alt="image-20201002220653472"></h2><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002220728137.png" alt="image-20201002220728137"></p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002220743070.png" alt="image-20201002220743070"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 回溯法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static int[] arr &#x3D; new int[13];</span><br><span class="line">    private static int[] count;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        count &#x3D; new int[9];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; scanner.nextInt();</span><br><span class="line">            ++count[arr[i]-1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int winCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 选择1到9中的一个作为第14张牌，然后判断是否胡牌</span><br><span class="line">        for (int i &#x3D; 1 ; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            if(count[i-1]&lt;4)&#123;</span><br><span class="line">                ++count[i-1];</span><br><span class="line">                if(win())&#123;</span><br><span class="line">                    ++winCount;</span><br><span class="line">                    System.out.print(i);</span><br><span class="line">                    System.out.print(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                --count[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(winCount&#x3D;&#x3D;0)&#123;</span><br><span class="line">            System.out.println(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean win()&#123;</span><br><span class="line">        &#x2F;&#x2F; 从1到9 中选择一个作为雀头, 然后判断剩余的牌是否构成4对</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            if(count[i-1]&lt;2)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            count[i-1]-&#x3D;2;</span><br><span class="line">            if(hasTriples(4))&#123;</span><br><span class="line">                count[i-1]+&#x3D;2;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            count[i-1]+&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean hasTriples(int n)&#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 1到9，每一张牌尝试三张或顺子</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">            if(count[i-1]&gt;&#x3D;3)&#123;</span><br><span class="line">                count[i-1]-&#x3D;3;</span><br><span class="line">                boolean subHashTriples &#x3D; hasTriples(n-1);</span><br><span class="line">                count[i-1]+&#x3D;3;</span><br><span class="line">                if(subHashTriples)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i&lt;&#x3D;7  &amp;&amp; count[i-1]&gt;0 &amp;&amp; count[i] &gt; 0 &amp;&amp; count[i+1]&gt;0)&#123;</span><br><span class="line">                --count[i-1];</span><br><span class="line">                --count[i];</span><br><span class="line">                --count[i+1];</span><br><span class="line">                boolean subHasTriples &#x3D; hasTriples(n-1);</span><br><span class="line"></span><br><span class="line">                ++count[i-1];</span><br><span class="line">                ++count[i];</span><br><span class="line">                ++count[i+1];</span><br><span class="line">                if(subHasTriples)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.特工</p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002221037230.png" alt="image-20201002221037230"></p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002221054430.png" alt="image-20201002221054430"></p><p><img src="/2020/10/02/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201002221105589.png" alt="image-20201002221105589"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    private int mod &#x3D; 99997867;</span><br><span class="line"></span><br><span class="line">    private void sln() &#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        int N &#x3D; sc.nextInt(), D &#x3D; sc.nextInt();</span><br><span class="line">        long cnt &#x3D; 0;</span><br><span class="line">        if (N &lt;&#x3D; 2) &#123;</span><br><span class="line">            System.out.println(-1);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] locs &#x3D; new int[N];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">            locs[i] &#x3D; sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">        int left &#x3D; 0, right &#x3D; 2;</span><br><span class="line">        while (right &lt; N) &#123;</span><br><span class="line">            if (locs[right] - locs[left] &gt; D) left++;</span><br><span class="line">            else if (right - left &lt; 2) right++;</span><br><span class="line">            else &#123;</span><br><span class="line">                cnt +&#x3D; calC(right - left);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt %&#x3D; mod;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long calC(long num) &#123;</span><br><span class="line">        return num * (num - 1) &#x2F; 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Main().sln();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3。迷宫"><a href="#3。迷宫" class="headerlink" title="3。迷宫"></a>3。迷宫</h2><p>由于新冠肺炎疫情的爆发，小明养在宿舍的小昆虫已经很久很久都没有人管了。小昆虫已经饿的不行了，必须出来找东西吃，可是出来之后需要走出一个迷宫。小昆虫每次可以朝上、下、左、右四个方向之一走一步，且只要走出任意一条边界线即可逃出迷宫。这只小昆虫曾感染过X星的一种奇异病毒，目前还没有发现任何副作用，但是却拥有了一项特异功能——破坏障碍物。<br>假设小昆虫在一个N<em>M的迷宫中，”@”代表小昆虫的初始位置，”.”代表可以通过的空地，”</em>“代表可以破坏的障碍物，”#”代表不可破坏的障碍物。请问小昆虫最少需要使用多少次特异功能才可以逃出迷宫？</p><p>输入描述<br>多组数据，第1行有1个正整数T，表示有T组数据。（T&lt;=100）<br>对于每组数据，第1行有两个整数N和M。(1&lt;=N, M&lt;=1000)<br>接着N行，每行有一个长度为M的字符串，表示N*M的迷宫。<br>输出描述<br>输出一个整数，表示使用特异功能的最少次数。如果小昆虫不能走出迷宫，则输出-1。</p><p>样例输入<br>3<br>3 3<br>###<br>#@*</p><p>3 4<br>####<br>#@.*<br><em>*.</em><br>3 3<br>.#.<br>#@#<br>.#.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.util.PriorityQueue;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class D2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        String st &#x3D; sc.nextLine();</span><br><span class="line">       int t &#x3D; Integer.parseInt(st);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; t; i++) &#123;</span><br><span class="line">            String str &#x3D; sc.nextLine();</span><br><span class="line">            String[] strs &#x3D; str.split(&quot; &quot;);</span><br><span class="line">            int n &#x3D;Integer.parseInt(strs[0]);    &#x2F;&#x2F;行数</span><br><span class="line">            int m &#x3D;Integer.parseInt(strs[1]);    &#x2F;&#x2F;列数</span><br><span class="line"></span><br><span class="line">            char[][] board &#x3D; new char[n][m];</span><br><span class="line">            int x &#x3D; -1;</span><br><span class="line">            int y &#x3D; -1;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">                String s &#x3D; sc.nextLine();</span><br><span class="line">                for (int k &#x3D; 0; k &lt; m; k++) &#123;</span><br><span class="line">                    board[j][k]&#x3D;s.charAt(k);</span><br><span class="line">                    if (board[j][k] &#x3D;&#x3D; &#39;@&#39;) &#123;</span><br><span class="line">                        x &#x3D; k;    &#x2F;&#x2F;列号</span><br><span class="line">                        y &#x3D; j;    &#x2F;&#x2F;行号</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            boolean[][] used &#x3D; new boolean[n][m];</span><br><span class="line">            int[][] move &#x3D; new int[4][2];</span><br><span class="line">            move[0][0]&#x3D;0;</span><br><span class="line">            move[0][1]&#x3D;1;</span><br><span class="line">            move[1][0]&#x3D;0;</span><br><span class="line">            move[1][1]&#x3D;-1;</span><br><span class="line">            move[2][0]&#x3D;1;</span><br><span class="line">            move[2][1]&#x3D;0;</span><br><span class="line">            move[3][0]&#x3D;-1;</span><br><span class="line">            move[3][1]&#x3D;0;</span><br><span class="line"></span><br><span class="line">            PriorityQueue&lt;Integer&gt; list &#x3D; new PriorityQueue&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F;System.out.println(t +&quot; &quot;+n+ &quot; &quot;+m+&quot; &quot;+x+&quot; &quot;+y );</span><br><span class="line">            dis(x,y,board,used,list,0,move);</span><br><span class="line">            if(list.size()&gt;0)&#123;</span><br><span class="line">                System.out.println(list.poll());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(&quot;-1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void dis(int x,int y,char[][] board,boolean[][] used, PriorityQueue&lt;Integer&gt; list,int count,int[][] move)&#123;</span><br><span class="line">        if(x&lt;&#x3D;0||x&gt;&#x3D;board[0].length-1||y&lt;&#x3D;0||y&gt;&#x3D;board.length-1)&#123;     &#x2F;&#x2F;第3个或写成了与</span><br><span class="line">            &#x2F;&#x2F;System.out.println(count);</span><br><span class="line">            list.add(count);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">            x&#x3D;x+move[i][0];</span><br><span class="line">            y&#x3D;y+move[i][1];</span><br><span class="line">            if(x&gt;&#x3D;0&amp;&amp;x&lt;board[0].length&amp;&amp;y&gt;&#x3D;0&amp;&amp;y&lt;board.length&amp;&amp;!used[y][x])&#123;</span><br><span class="line">                used[y][x] &#x3D; true;</span><br><span class="line">                if (board[y][x]&#x3D;&#x3D;&#39;*&#39;)&#123;</span><br><span class="line">                    dis(x,y,board,used,list,count+1,move);</span><br><span class="line">                    &#x2F;&#x2F; System.out.println(count);</span><br><span class="line">                &#125;else if (board[y][x]&#x3D;&#x3D;&#39;.&#39;)&#123;</span><br><span class="line">                    dis(x,y,board,used,list,count,move);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                used[y][x] &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            x-&#x3D;move[i][0];</span><br><span class="line">            y-&#x3D;move[i][1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int bfs(vector&lt;string&gt; grid)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; direct&#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line">    queue&lt;vector&lt;int&gt;&gt; que_;</span><br><span class="line">    int hei &#x3D; grid.size();</span><br><span class="line">    int wid &#x3D; grid[0].length();</span><br><span class="line">    int result &#x3D; -1;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; visited(hei, vector&lt;int&gt;(wid, -1));</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; hei; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; wid; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (grid[i][j] &#x3D;&#x3D; &#39;@&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                que_.push(&#123;i, j, 0&#125;);</span><br><span class="line">                visited[i][j] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (!que_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        auto cur &#x3D; que_.front();</span><br><span class="line">        que_.pop();</span><br><span class="line">        if (cur[0] &#x3D;&#x3D; 0 || cur[0] &#x3D;&#x3D; hei - 1 || cur[1] &#x3D;&#x3D; 0 || cur[1] &#x3D;&#x3D; wid - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            if (cur[2] &lt; result || result &#x3D;&#x3D; -1)</span><br><span class="line">            &#123;</span><br><span class="line">                result &#x3D; cur[2];</span><br><span class="line">            &#125;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 4; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int next_y &#x3D; cur[0] + direct[i][0];</span><br><span class="line">            int next_x &#x3D; cur[1] + direct[i][1];</span><br><span class="line">            int last_time &#x3D; cur[2];</span><br><span class="line">            if (visited[next_y][next_x] !&#x3D; -1 &amp;&amp; visited[next_y][next_x] &lt;&#x3D; last_time + 1)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[next_y][next_x] &#x3D; last_time + 1;</span><br><span class="line">            if (grid[next_y][next_x] &#x3D;&#x3D; &#39;.&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                que_.push(&#123;next_y, next_x, last_time&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (grid[next_y][next_x] &#x3D;&#x3D; &#39;*&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                que_.push(&#123;next_y, next_x, last_time + 1&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t, n, m;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; grids(t);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        grids[i].resize(n);</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; grids[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (auto grid : grids)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bfs(grid) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">public class hello &#123;&#x2F;&#x2F;100 999</span><br><span class="line">    static int[][] dir&#x3D;&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">    static int startX,startY;</span><br><span class="line">  &#x2F;&#x2F;  static int endX,endY;</span><br><span class="line">    static int min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">    static int[][] vis;</span><br><span class="line">    static Scanner sc&#x3D;new Scanner(System.in);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    int x&#x3D;sc.nextInt();</span><br><span class="line"></span><br><span class="line">    while(x--&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        int n&#x3D;sc.nextInt();</span><br><span class="line">        int m&#x3D;sc.nextInt();</span><br><span class="line">        char[][] matrix&#x3D;new char[n][m];</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[i]&#x3D;sc.next().toCharArray();</span><br><span class="line">          &#x2F;&#x2F;  sc.nextLine();</span><br><span class="line">            for(int j&#x3D;0;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">             if(matrix[i][j]&#x3D;&#x3D;&#39;@&#39;)</span><br><span class="line">             &#123;</span><br><span class="line">                 startX&#x3D;i;</span><br><span class="line">                 startY&#x3D;j;</span><br><span class="line">             &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis&#x3D;new int[n][m];</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i][j]&#x3D;-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        Queue&lt;Node&gt; q&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">        q.add(new Node(startX,startY));</span><br><span class="line">        BFS(matrix,q);</span><br><span class="line">        System.out.println(min);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void BFS(char[][] matrix,Queue&lt;Node&gt; q) &#123;</span><br><span class="line">    while(!q.isEmpty()) &#123;</span><br><span class="line">        int size &#x3D; q.size();</span><br><span class="line">        while (size-- &gt; 0) &#123;</span><br><span class="line">            Node nowNode &#x3D; q.poll();</span><br><span class="line">            int i &#x3D; nowNode.x, j &#x3D; nowNode.y;</span><br><span class="line">            vis[i][j]&#x3D;nowNode.step;</span><br><span class="line">            if (i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; matrix.length - 1</span><br><span class="line">                    || j &#x3D;&#x3D; 0</span><br><span class="line">                    || j &#x3D;&#x3D; matrix[0].length - 1</span><br><span class="line">            ) &#123;</span><br><span class="line">                min&#x3D;Math.min(vis[i][j],min);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int[] d : dir) &#123;</span><br><span class="line">                int newX &#x3D; d[0] + i;</span><br><span class="line">                int newY &#x3D; d[1] + j;</span><br><span class="line">                if (matrix[newX][newY] &#x3D;&#x3D; &#39;#&#39;) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(vis[newX][newY]!&#x3D;-1 &amp;&amp; vis[newX][newY]&lt;&#x3D;nowNode.step+1)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                Node newNode &#x3D; new Node(newX, newY);</span><br><span class="line">                if (matrix[newX][newY] &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line"></span><br><span class="line">                    newNode.step &#x3D;nowNode.step+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(matrix[newX][newY] &#x3D;&#x3D; &#39;.&#39;)</span><br><span class="line">                &#123;</span><br><span class="line">                    newNode.step &#x3D;nowNode.step;</span><br><span class="line">                &#125;</span><br><span class="line">                q.add(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;  ####</span><br><span class="line">        &#x2F;&#x2F; ####</span><br><span class="line">        &#x2F;&#x2F; #@.*</span><br><span class="line">        &#x2F;&#x2F; **.*</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static class Node</span><br><span class="line">    &#123;</span><br><span class="line">        int x;</span><br><span class="line">        int y;</span><br><span class="line">        int step;</span><br><span class="line">        Node(int a,int b)</span><br><span class="line">        &#123;</span><br><span class="line">            x&#x3D;a;</span><br><span class="line">            y&#x3D;b;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据</title>
      <link href="/2020/09/30/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
      <url>/2020/09/30/%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>1MB=2^20B</p><p>1KB=2^10B=10^3B</p><h2 id="1-共同URL"><a href="#1-共同URL" class="headerlink" title="1.共同URL"></a>1.共同URL</h2><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。</p><blockquote><p>5,000,000,000 * 64B ≈ 5GB * 64 = 320GB</p></blockquote><p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p><strong>思路如下</strong>：</p><p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code>，根据计算结果把遍历到的  URL 存储到文件  a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p><p>接着遍历 ai( <code>i∈[0,999]</code>)，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p><h3 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h3><p>1.分而治之，进行哈希取余；2.对每个子文件进行 HashSet 统计。</p><h2 id="2-频率Top100"><a href="#2-频率Top100" class="headerlink" title="2.频率Top100"></a>2.频率Top100</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p><h3 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h3><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p><p><strong>思路如下</strong>：</p><p>首先遍历大文件，对遍历到的每个词x，执行 <code>hash(x) % 5000</code>，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p><p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 <code>map.put(x, 1)</code>；若存在，则执行 <code>map.put(x, map.get(x)+1)</code>，将该词频数加 1。</p><p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p><h3 id="方法总结-1"><a href="#方法总结-1" class="headerlink" title="方法总结"></a>方法总结</h3><p>1.分而治之，进行哈希取余；2.使用 HashMap 统计频数；3.求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</p><h2 id="3-找不重复"><a href="#3-找不重复" class="headerlink" title="3.找不重复"></a>3.找不重复</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p><h3 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h3><h4 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p><h4 id="方法二：位图法"><a href="#方法二：位图法" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h4><p><strong>位图</strong>，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p><p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p><p>假设我们要对 <code>[0,7]</code> 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000</span><br></pre></td></tr></table></figure><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00001010</span><br></pre></td></tr></table></figure><p>依次遍历，结束后，位数组是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01101110</span><br></pre></td></tr></table></figure><p>每个为 1 的位，它的下标都表示了一个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in range(8):if bits[i] &#x3D;&#x3D; 1:print(i)</span><br></pre></td></tr></table></figure><p>这样我们其实就已经实现了排序。</p><p>对于整数相关的算法的求解，<strong>位图法</strong>是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 2^32。</p><p><strong>那么对于这道题</strong>，我们用 2 个 bit 来表示各个数字的状态：</p><p>•00 表示这个数字没出现过；•01 表示这个数字出现过一次（即为题目所找的不重复整数）；•10 表示这个数字出现了多次。</p><p>那么这 232 个整数，总共所需内存为 2^32*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p><p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p><h3 id="方法总结-2"><a href="#方法总结-2" class="headerlink" title="方法总结"></a>方法总结</h3><p><strong>判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p><h2 id="4-1亿个正整数-范围是0-42亿。求出现次数是2的数字，空间复杂度"><a href="#4-1亿个正整数-范围是0-42亿。求出现次数是2的数字，空间复杂度" class="headerlink" title="4.1亿个正整数,范围是0-42亿。求出现次数是2的数字，空间复杂度"></a>4.1亿个正整数,范围是0-42亿。求出现次数是2的数字，空间复杂度</h2><p>使用位图bitMap     。位图是以 bit     位为单位进行数据存储，这样每个字节8个位就可以存储8个数字，普通的一个int占4个字节，32位，用了位图之后可以将空间节省32倍。     </p><p>​      开一个42亿大小的位图，将这一亿个数字存进数字大小对应的位置，一个bit每存进去一个数字，就将value+1,比如第一次存8，就将索引为8的位置的value置为1，第二次就置为2，存完之后搜索value为2的key是多少。     </p><p>​      32位机器最大能表示的数字是42亿9千多万。     </p><p>​      42亿bit /(8 * 1024 * 1024) = 500MB</p><h2 id="5-有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？"><a href="#5-有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？" class="headerlink" title="5.有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？"></a>5.有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？</h2><p>思路一：分治法，将ip地址根据前三位分成256份，然后看这个ip地址对应的网段，只比对这个网段里面是否有这个ip，当然还可以继续分下去，根据数据量来决定分成多少份。     </p><p>​      思路二：位图，将每一条ip对应位图中的一个位，2^32次方(42亿多)个数据只需要512M空间。可以实现O(1)的时间搜索，O(n)的时间存储。     </p><h2 id="6-2g内存，要求一个10g文件的中位数"><a href="#6-2g内存，要求一个10g文件的中位数" class="headerlink" title="6. 2g内存，要求一个10g文件的中位数**"></a>6. 2g内存，要求一个10g文件的中位数**</h2><p>如题 “在一个文件中有 10G 个整数,乱序排列,要求找出中位数(内存限制为 2G)”</p><p>原创，网上这个题目有好多答案，但是有好多都不准确。</p><p> 假设整数用32bit来表示。</p><p>第一步：要表示10G个整数，最少需要一个64位的数据空间。（10G = 5 * 2^31 &gt; 2^32 )</p><p>第二步：分区间</p><p>2G的内存，能够表示多少个64bit，就能分多少个区间。（一个区间 就表示 一个64bit的数据空间）</p><p>区间数位：2G / 64bit = 256M 个区间。</p><p>第三步：求区间表示范围</p><p>32bit的整数最大值为2^32-1,所以区间的范围是2^32 / 256M = 16.</p><p>即0 ~ 15 ，16 ~ 31，32 ~ 47，……（总共256M个)</p><p>此时我们有 256M个区间，大小总共为256M * 64bit = 2G内存。</p><p>第四步：遍历10G个整数。每读取一个整数就将此整数对应的区间+1。</p><p>第五步：找出中位数所在的区间</p><p>统计每个区间中整数的值。然后从第一个区间的整数值开始累加。当累加到5G时，停止。此时的区间便包含中位数。记下此区间所表示的范围，设为[a,a+15].并且记下此区间之前所有区间的累加和，设为m。释放掉除包含中位数区间的其他所有区间的内存。</p><p>第六步：再次遍历10G个整数，统计出现在区间[a,a+15]中每个值的计数，有16个数值，按照a到a+15排序。设为n0,n1,n2,…n15</p><p>第七步：当m+n0+n1+…+nx首次大于5G时，此时的 a+x 就是所求的中位数。</p><p>7.</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智力题</title>
      <link href="/2020/09/30/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
      <url>/2020/09/30/%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-三门问题（Monty-Hall-problem）"><a href="#1-三门问题（Monty-Hall-problem）" class="headerlink" title="1.三门问题（Monty Hall problem）"></a>1.三门问题（Monty Hall problem）</h2><p>亦称为蒙提霍尔问题或蒙提霍尔悖论，大致出自美国的电视游戏节目Let’s Make a Deal。问题名字来自该节目的主持人蒙提·霍尔（Monty Hall）。参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机率？</p><p>作为工科生，还是拿贝叶斯公式来分析一波：</p><p>首先看贝叶斯公式： </p><p><img src="https://img-blog.csdnimg.cn/20190707193021763.png" alt="img"></p><p>p(A|B)的意思是在B事件发生的情况下，A事件发生的概率。p(A,B)是两个事件同时发生的概率。</p><p>那么上面的公式可以延伸出下面的公式：</p><p><img src="https://img-blog.csdnimg.cn/20190707193821826.png" alt="img"></p><p>好，然后我们针对这个题目，我们假设有A、B、C三个门，参赛者选择了A门，主持人打开了B门，然后要参赛者在A门和C门之间抉择换还是不换。那么如果汽车在B门后面，换与不换得到汽车的概率均为0，如果换了能赢，那么汽车必须在C门后面， 现在我们求以下概率：</p><p><img src="https://img-blog.csdnimg.cn/20190707200643101.png" alt="img"></p><p>我们先看分母，我们三种可能情况列一下：</p><p><img src="https://img-blog.csdnimg.cn/20190707201600435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3Vuc2hp,size_16,color_FFFFFF,t_70" alt="img"></p><p>所以分母为：</p><p><img src="https://img-blog.csdnimg.cn/20190707201824129.png" alt="img"></p><p>再看分子，当车在C后面时，参赛者选择了A门，支持人只有B门可以打开，所以：</p><p><img src="https://img-blog.csdnimg.cn/20190707202332301.png" alt="img"></p><p>而车在C门后的概率显而易见：</p><p><img src="https://img-blog.csdnimg.cn/20190707202715221.png" alt="img"></p><p>然后我们就求得了换门获胜的概率：</p><p><img src="https://img-blog.csdnimg.cn/20190707203200890.png" alt="img"></p><p>-———————————————————————————————————————— </p><p>这个问题就结束了。然而对于贝叶斯公式还没有结束。</p><p>贝叶斯公式还会有如下写法：</p><p><img src="https://img-blog.csdnimg.cn/20190707211603830.png" alt="img"></p><p>这个公式可以用在分类上，具体的可以去翻看我的另一篇博客</p><h2 id="2-桶装水"><a href="#2-桶装水" class="headerlink" title="2.桶装水"></a>2.桶装水</h2><p>有无限的水，5L和6L 的桶精确装4L 水</p><blockquote><p>通用解法： 用小的桶不断往大桶填水</p><p>这里： 5L桶 6L桶</p><p>0 0</p><p>5 0</p><p>0 5</p><p>5 5</p><p>4 6</p></blockquote><p><strong>一个装了10L水的桶，一个7L的空桶，一个3L的空桶，怎样变成2个5L</strong></p><p>初始时为10，0，0。<br>第二步7，0，3。<br>然后7，3，0。<br>然后4，3，3。<br>然后4，6，0。<br>然后1，6，3。<br>然后1，7，2。<br>然后8，0，2。<br>然后8，2，0。<br>然后5，2，3。<br>然后5，5，0。</p><p><strong>如果你有无穷多的水，一个3夸脱的和一个5夸脱的提桶，你如何准确称出 4夸脱的水？</strong></p><p>初始时0，5<br>然后3，2<br>然后0，2<br>然后2，0<br>然后2，5<br>然后1，4</p><p>两个舀酒的勺子，分别能舀7两和11两酒，二两酒？</p><p>初始0，11<br>然后7，4<br>然后0，4<br>然后4，0<br>然后4，11<br>然后7，8<br>然后0，8<br>然后7，1<br>然后0，1<br>-—–<br>然后1，11<br>然后7，5<br>然后0，5<br>然后5，0<br>然后5，11，<br>然后7，9<br>然后0，9<br>然后7，2</p><h2 id="3-瞎子分牌"><a href="#3-瞎子分牌" class="headerlink" title="3.瞎子分牌"></a>3.瞎子分牌</h2><p>一副牌52张,告诉瞎子里面有10张牌是正面朝上的, 要求瞎子把这52张牌分成两堆, 并且每堆牌正面朝上的张数相同，可任意翻动牌，但是一直不可以看。</p><blockquote><p>分成10和42， 10 中的所有牌。</p><p>proof： 第一堆（10张牌里有x张向上），全翻 = 10-x 张向上，等于第二堆向上的牌数</p></blockquote><h2 id="4-赛马问题"><a href="#4-赛马问题" class="headerlink" title="4.赛马问题"></a>4.赛马问题</h2><p>64匹马，8个跑道，选跑最快的4匹马需要比赛多少次。</p><p>(     锦标赛<a href>排序</a><a href>算法</a>     )      sum = 11     </p><p>​      第一步：首先每8匹马跑一次，总共需要8次，假设结果中A1&gt;A2&gt;A3&gt;……,B1&gt;B2&gt;B3&gt;….等。 sum=8；     </p><p>​      第二步：这8组中的第一名拉出来跑一次，那么这次最快的是总的第一名，假设是A1，同时假设B1&gt;C1&gt;D1。这时还要角逐2,3,4名，     那这一轮中的第五到第八组都可以直接舍弃     ，因为他们所有的马一定进不了前4名。sum=9。     </p><p>​      第三步：从A组中选A2，A3，A4，B组中B1，B2，B3，C组中C1，C2，D组中D1，这些才有资格角逐2,3,4名。这时需要再比赛两次。 sum=11。（但是如果第10轮选择A4不上场，如果A3获得了第4名，那么A4就不需要比赛了，这样     sum=10     ）。</p><p>25匹马，5个跑道，每个跑道最多能有1匹马进行比赛，最少比多少次能比出前3名？前5名？</p><h2 id="5-老鼠死亡问题"><a href="#5-老鼠死亡问题" class="headerlink" title="5.老鼠死亡问题"></a>5.老鼠死亡问题</h2><p>1000瓶药，有一些可能有毒，用老鼠来喝药，喝到有毒的一周就死。一周内至少需要多少只老鼠才能检测到哪些有毒</p><p>同时给老鼠编号，从1,2,…10，从低位开始，让第n个编号老鼠喝下第n个bit位为1的瓶子中的药水。<br>一周后，若所有的老鼠都没有发病，那么是第0个瓶子有毒，<br>如果有一些编号的老鼠发病，死亡的老鼠记为1，正常老鼠记为0，那么按照老鼠编号1-10对应bit位从低到高，对应的10进制即为有毒药水的编号。</p><p><strong>附上百度解释</strong><br>给1000个瓶分别标上如下标签（10位长度）：<br>0000000001 （第1瓶）<br>0000000010 （第2瓶）<br>0000000011 （第3瓶）<br>……<br>1111101000 （第1000瓶）<br>从编号最后1位是1的所有的瓶子里面取出1滴混在一起（比如从第一瓶，第三瓶，。。。里分别取出一滴混在一起）并标上记号为1。以此类推，从编号第一位是1的所有的瓶子里面取出1滴混在一起并标上记号为10。现在得到有10个编号的混合液，小白鼠排排站，分别标上10，9，。。。1号，并分别给它们灌上对应号码的混合液。24小时过去了，过来验尸吧：<br><strong>从左到右，死了的小白鼠贴上标签1，没死的贴上0，最后得到一个序号，把这个序号换成10进制的数字，就是有毒的那瓶水的编号。</strong><br>检验一下：假如第一瓶有毒，按照0000000001 （第1瓶），说明第1号混合液有毒，因此小白鼠的生死符为0000000001（编号为1的小白鼠挂了），0000000001二进制标签转换成十进制=1号瓶有毒；假如第三瓶有毒，0000000011 （第3瓶），第1号和第2号混合液有毒，因此小白鼠的生死符为00000011（编号为1，2的鼠兄弟挂了），0000000011二进制标签转换成十进制=3号瓶有毒。</p><p>————————————————————————————————————————————<br><strong>举例，10瓶药水，4个bit表示，对应药水编号0-9，又4个bit对应4个老鼠，则老鼠编号1-4，</strong><br>0000， 0<br>0001， 1<br>0010， 2<br>0011， 3<br>0100， 4<br>0101，5<br>0110，6<br>0111，7<br>1000，8<br>1001，9</p><p>老鼠编号 对应药水瓶子编号<br>1， ，，， 1，3，5，7，9<br>2， ，，， 2，3，6，7<br>3， ，，，4，5，6，7<br>4， ，，，8，9</p><p>如果一周之后，全都安然无恙，则0号药水瓶子有毒，<br>如果1，2，3编号老鼠死亡，则很容易看出7号有毒，<br>或者1，2，3编号老鼠置为1，4号置为0，从低到高即为0111=7</p><h2 id="6-石头称重"><a href="#6-石头称重" class="headerlink" title="6.石头称重"></a>6.石头称重</h2><p>13个石头，有一个比较重其他都一样，用天平测量最多需要几次才能测出重的那个</p><p>4 4 5</p><p> 1) 如果 4 == 4 在 5 里面 分为 2 2 1<br> 1.1) 如果 2 == 2 在 1 那 ok <strong>两次</strong><br> 1.2) 如果 2 != 2 称 1 1 ，那个沉就是答案，<strong>三次</strong><br> 2) 4 != 4 在 沉的那堆里面<br> 2.1) 称2 2 排除 2个 再称1 1 ，那个沉就是答案，<strong>三次</strong></p><h2 id="7-抛硬币"><a href="#7-抛硬币" class="headerlink" title="7.抛硬币"></a>7.抛硬币</h2><p>一硬币，一面向上概率0.7，一面0.3，如何公平？</p><p>两个人轮流抛硬币，先抛到正面的赢，问先抛的人赢的概率？</p><p>每一轮 抛硬币，A先抛赢得概率是1/2，B后抛赢得概率是（1/2）*（1/2）= 1/4。那么 每一轮A赢得概率都是B赢得概率的2倍 ，总概率为1,所以A赢的概率是2/3。</p><h2 id="8-蚊香"><a href="#8-蚊香" class="headerlink" title="8.蚊香"></a>8.蚊香</h2><p>两根香，一根烧完1小时，如何测量15分钟</p><p>开始时一根香两头点着，一根香只点一头，两头点着的香烧完说明过去了半小时，这时将只点了一头的香另一头也点着，从这时开始到烧完就是15分钟。</p><h2 id="9-海盗分金币"><a href="#9-海盗分金币" class="headerlink" title="9.海盗分金币"></a>9.海盗分金币</h2><p>1.</p><p>在加勒比海上，有五个海盗，共同抢到了100枚金币， 每一个人按顺序依次提出自己的分配方案，如果提出的方案没有获得<strong>半数或半数以上</strong>的人的同意，则这个提出方案的人就被扔到海里喂鲨鱼，那么第一个提出方案的人要怎么做，才能使自己的利益最大化？（前提是海盗都是十分聪明和贪婪的）</p><p>假使前三个人都因为分配金币的方式不合理而被扔下大海，此时还剩下两个人，也就是4号和5号，那么问题就简单了：</p><p><strong>4号和5号</strong>分金币的情况：<br>   4号提出方案，自己一定会同意的，并且只要自己同意，这个方案就已经获得了半数的支持，就可以被实施<br>   因此，无论5号是否同意4号提出的方案，都不会对最终的结果造成影响，因此，<strong>4号一定会要100枚金币</strong>，以使自己的利益最大化，结果就变成了这样：<br>     <strong>4号</strong>     5号<br>     <strong>100</strong>     0</p><p>现在我们多添加一个人，<br><strong>3号，4号和5号</strong>分金币的情况：<br>   3号要使自己的提议获得半数的支持就必须再拉拢一个人，拉拢4号显然是不合适的，4号一定不会同意，4号知道，只要搞死了3号，剩下的100枚金币都是自己的。（就像上面4号和5号分金币的情况）拉拢5号是合适的，因为5号之前得不到金币，现在只要3号给5号一个金币就能够获得5号的支持，因为5号也知道，如果3号死亡，自己一定一枚金币都得不到。</p><p>情况就变成了这样：</p><p>​    <strong>3号</strong>     4号    <strong>5号</strong><br>​     <strong>99</strong>      0      <strong>1</strong></p><p>现在我们再多添加一个人：<br><strong>2号，3号，4号和5号</strong>分金币的情况：<br>   2号要使自己的提议获得半数的支持也必须再拉拢一个人，拉拢3号显示是不合适的，3号一定不会同意，3号知道，只要搞死了2号，有99枚金币都是自己的（就像上面3号，4号和5号分金币的情况）， 拉拢5号貌似是可以的，他已经有一个金币了，要让他支持自己只要再多给他一个金币就可以了，拉拢4号也是可以的，4号现在没有金币，只要给他一个就可以让他自持自己的提案，综上所述，要让自己利益最大化，就需要拉拢4号，因为只要给4号一个金币即可：<br>   情况就变成了这样：<br>     <strong>2号</strong>     3号     <strong>4号</strong>     5号<br>     <strong>99</strong>      0       <strong>1</strong>     0</p><p>最后我们再多添加一个人这道题目的答案就出来了：<br>1号，2号，3号，4号和5号分金币的情况：</p><p>1号要使自己的提议获得半数的支持必须拉拢两个人，拉拢2号显示是不合适的，2号一定不会同意，2号知道，只要搞死了1号，有99枚金币都是自己的，（就像上面2号，3号，4号和5号分金币的情况）， 拉拢4号貌似是可以的，他已经有一个金币了，要让他支持自己需要再给他一个金币才可以，这样做并不能让自己的利益最大化， 拉拢3号是可以的，3号现在没有金币，只要给他一个就可以让他自持自己的提案， 5号跟3号情况一至，同样没有金币，只要给他一个就可以了，综上所述，要让自己利益最大化，就需要拉拢3号跟5号，因为拉拢他们两个只需要各自给一个金币即可：<br>情况就变成了这样：<br>     <strong>1号</strong>     2号     <strong>3号</strong>     4号     <strong>5号</strong><br>     <strong>98</strong>      0       <strong>1</strong>       0      <strong>1</strong></p><ol start="2"><li><p>或必须半数以上的人同意呢？</p><p>这道题是典型的逆向思维的问题，用回推法可以得到答案。过程如下：从后往前推，人数依次增加如果1-3号强盗都喂了鲨鱼，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。3号知道这一点，就会提（100,0,0）的分配方案，对4号、5号一毛不拔而将全部金币归为已有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票，他的方案即可通过。2号推到3号的方案，就会提出（98，0，1，1）的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。2号的方案会被1号所洞悉，1号并将提出（97，0，1，2，0）或（97，0，1，0，2）的方案，即放弃2号，而给3号一枚金币，同时给4号（或5号）2枚金币。由于1号的这一方案对于3号和4号（或5号）来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。这无疑是1号能够获取最大收益的方案了！</p></li></ol><h2 id="10-54张扑克牌，平均分成3份，大小王在一份的概率"><a href="#10-54张扑克牌，平均分成3份，大小王在一份的概率" class="headerlink" title="10. 54张扑克牌，平均分成3份，大小王在一份的概率"></a>10. 54张扑克牌，平均分成3份，大小王在一份的概率</h2><p>首先大王一定会在某一份中，然后要计算这一份中还要包含小王的概率。去掉大王还剩53张牌，这一份还可以分17张牌，那么每次分到小王的概率是1/53,所以总概率是17/53。</p><p><img src="https://uploadfiles.nowcoder.com/images/20200518/66153173_1589803055420_16F6C01C102793BA75D2E74EDCF64397" alt="img"></p><h2 id="11-让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。"><a href="#11-让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。" class="headerlink" title="11.让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。"></a>11.让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。</h2><p>传入参数有总钱数，分的份数，随机分还是等分。先判断钱数能不能分那么多份，这个直接用总钱数&gt;=0.01<em>份数判断就可以了。然后根据分发策略，选择随机还是等分，随机的话就给 1到总钱数-（总份数-1）</em>0.01 的随机数（总钱数以分为单位），等分的话直接除判断能不能除开，有余数就将余数加到最后一份里面。</p><h2 id="12-分布式多个机器生成id，如何保证不重复"><a href="#12-分布式多个机器生成id，如何保证不重复" class="headerlink" title="12.分布式多个机器生成id，如何保证不重复?"></a>12.分布式多个机器生成id，如何保证不重复?</h2><p>\1.     <strong>snowflake方案</strong>     ：     </p><p>​      snowflake是Twitter开源的分布式ID生成<a href>算法</a>，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着     每个节点在每毫秒可以产生 4096 个 ID     ），最后还有一个符号位，永远是0。     </p><p>​      优点     ：     </p><p>​      1.毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。     </p><p>​      2.不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。     </p><p>​      3.可以根据自身业务特性分配bit位，非常灵活。     </p><p>​      缺点     ：     </p><p>​      强依赖机器时钟，如果     机器上时钟回拨     ，会导致发号重复或者服务会处于不可用状态。     </p><p>​      \2.     <strong>用Redis生成ID：</strong>     </p><p>​      因为Redis是单线程的，也可以用来生成全局唯一ID。可以用Redis的原子操作INCR和INCRBY来实现。     </p><p>​      此外，可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis，可以初始化每台Redis的值分别是1,2,3,4,5，步长都是5，各Redis生成的ID如下：     </p><p>​      A：1,6,11,16     </p><p>​      B：2,7,12,17     </p><p>​      C：3,8,13,18     </p><p>​      D：4,9,14,19     </p><p>​      E：5,10,15,20     </p><p>​      这种方式是负载到哪台机器提前定好，未来很难做修改。3~5台服务器基本能够满足需求，都可以获得不同的ID，但步长和初始值一定需要事先确定，使用Redis集群也可以解决单点故障问题。     </p><p>​      另外，比较适合使用Redis来生成每天从0开始的流水号，如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。     </p><p>​      <strong>优点：</strong>     </p><p>​      1）不依赖于数据库，灵活方便，且性能优于数据库。     </p><p>​      2）数字ID天然<a href>排序</a>，对分页或需要<a href>排序</a>的结果很有帮助。     </p><p>​      <strong>缺点：</strong>     </p><p>​      1）如果系统中没有Redis，需要引入新的组件，增加系统复杂度。     </p><p>​      2）需要编码和配置的工作量较大。</p><h2 id="13-数据库连接池怎么设计"><a href="#13-数据库连接池怎么设计" class="headerlink" title="13.数据库连接池怎么设计?"></a>13.数据库连接池怎么设计?</h2><p>需要考虑的问题：     </p><ol><li>限制连接池中最多、可以容纳的连接数目，避免过度消耗系统资源。 </li><li>当客户请求连接，而连接池中所有连接都已被占用时，该如何处理呢？一种方式是让客户一直等待，直到有空闲连接，另一种方式是为客户分配一个新的临时连接。 </li><li>当客户不再使用连接，需要把连接重新放回连接池。 </li><li>连接池中允许处于空闲状态的连接的最大<a href>项目</a>。假定允许的最长空闲时间为十分钟，并且允许空闲状态的连接最大数目为5， </li></ol><p>​      那么当连接池中有n个(n&gt;5)连接处于空闲状态的时间超过十分钟时，     <strong>就应该把n-5个连接关闭，并且从连接池中删除，</strong>     这样才能更有效的利用系统资源。</p><h2 id="14-扫码登录"><a href="#14-扫码登录" class="headerlink" title="14.扫码登录"></a>14.扫码登录</h2><h2 id="15-砝码秤盐"><a href="#15-砝码秤盐" class="headerlink" title="15.砝码秤盐"></a>15.砝码秤盐</h2><p>140g盐,一天平,7g 、2g砝码各一个,如何只利用这些东西3次把盐分成50g和90g?</p><ul><li><p>第一次： 7g、2g砝码称出9g盐，结果盐分成9g与131g</p></li><li><p>第二次：将9g盐与7g、2g都作为砝码，结果将盐分为18g与113g （注意：这时盐已经分为三份：9g、18g、113g，还有两个砝码）</p></li><li><p>第三次：将18g盐与7g砝码发在左托盘，将2g砝码放在右托盘，然后在113g盐中取盐添置右托盘中，可获取23g盐。</p></li></ul><p>  这时盐分为9g，18g，23g与90g。  </p><p>  即三次，可以得到90g与（9+18+23）50g。</p><h2 id="16-九球称重"><a href="#16-九球称重" class="headerlink" title="16.九球称重"></a>16.九球称重</h2><blockquote><h3 id="有-9-个球，其中-8-个球质量相同，有-1-个球比较重。要求用-2-次天平，找出比较重的那个球。"><a href="#有-9-个球，其中-8-个球质量相同，有-1-个球比较重。要求用-2-次天平，找出比较重的那个球。" class="headerlink" title="有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。"></a>有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。</h3></blockquote><p> 将这些球均分成 3 个一组共 3 组，选出 2 组称重，如果 1 组比较重，那么重球在比较重的那 1 组；如果 1 组重量相等，那么重球在另外 1 组。 </p><p> 对比较重的那 1 组的 3 个球再分成 3 组，重复上面的步骤。 </p><h2 id="17-药丸称重"><a href="#17-药丸称重" class="headerlink" title="17.药丸称重"></a>17.药丸称重</h2><blockquote><h3 id="有-20-瓶药丸，其中-19-瓶药丸质量相同为-1-克，剩下一瓶药丸质量为-1-1-克。瓶子中有无数个药丸。要求用一次天平找出药丸质量-1-1-克的药瓶。"><a href="#有-20-瓶药丸，其中-19-瓶药丸质量相同为-1-克，剩下一瓶药丸质量为-1-1-克。瓶子中有无数个药丸。要求用一次天平找出药丸质量-1-1-克的药瓶。" class="headerlink" title="有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。"></a>有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。</h3></blockquote><p> 可以从药丸的数量上来制造差异：从第 i 瓶药丸中取出 i 个药丸，然后一起称重。可以知道，如果第 i 瓶药丸重 1.1 克/粒，那么称重结果就会比正常情况下重 0.1 * i 克。 </p><h2 id="18-得到-4-升的水"><a href="#18-得到-4-升的水" class="headerlink" title="18.得到 4 升的水"></a>18.得到 4 升的水</h2><blockquote><h3 id="有两个杯子，容量分别为-5-升和-3-升，水的供应不断。问怎么用这两个杯子得到-4-升的水。"><a href="#有两个杯子，容量分别为-5-升和-3-升，水的供应不断。问怎么用这两个杯子得到-4-升的水。" class="headerlink" title="有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。"></a>有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。</h3></blockquote><ul><li>1、将3升的装满倒入5升的；<br>2、再一次将3升的转满，倒入5升的，把5升装满；<br>3、3升杯里剩下的就是1升水；<br>4、倒掉5升的，把1升水倒入5升杯；<br>5、第三次加满3升杯，倒入5升杯，得到4升水。 </li></ul><h2 id="19-扔鸡蛋"><a href="#19-扔鸡蛋" class="headerlink" title="19.扔鸡蛋"></a>19.扔鸡蛋</h2><blockquote><h3 id="一栋楼有-100-层，在第-N-层或者更高扔鸡蛋会破，而第-N-层往下则不会。给-2-个鸡蛋，求-N，要求最差的情况下扔鸡蛋的次数最少"><a href="#一栋楼有-100-层，在第-N-层或者更高扔鸡蛋会破，而第-N-层往下则不会。给-2-个鸡蛋，求-N，要求最差的情况下扔鸡蛋的次数最少" class="headerlink" title="一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少"></a>一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少</h3></blockquote><p>最优解法是反向思考的经典：如果最优解法在最坏情况下需要扔X次，那第一次在第几层扔最好呢？ </p><p> 答案是：从X层扔 </p><p> 假设最优的尝试次数的x次，为什么第一次扔就要选择第x层呢？ </p><p> 这里的解释会有些烧脑，请小伙伴们坐稳扶好： </p><p> <strong>假设第一次扔在第x+1层：</strong> </p><p> 如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x层。 </p><p> 这样一来，我们总共尝试了x+1次，和假设尝试x次相悖。由此可见，第一次扔的楼层必须小于x+1层。 </p><p> <strong>假设第一次扔在第x-1层：</strong> </p><p> 如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-2层。 </p><p> 这样一来，我们总共尝试了x-2+1 = x-1次，虽然没有超出假设次数，但似乎有些过于保守。 </p><p> <strong>假设第一次扔在第x层：</strong> </p><p> 如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x-1层。 </p><p> 这样一来，我们总共尝试了x-1+1 = x次，刚刚好没有超出假设次数。 </p><p> 因此，要想尽量楼层跨度大一些，又要保证不超过假设的尝试次数x，那么第一次扔鸡蛋的最优选择就是第x层。 </p><p> 那么算最坏情况，第二次你只剩下x-1次机会，从100-x层 扔</p><p>按照上面的说法，你第二次尝试的位置必然是X+（X-1）； </p><p> 以此类推我们可得： </p><p> x + (x-1) + (x-2) + … + 1 = 100 </p><p> 这个方程式不难理解： </p><p> 左边的多项式是各次扔鸡蛋的楼层跨度之和。由于假设尝试x次，所以这个多项式共有x项。 </p><p> 右边是总的楼层数100。 </p><p> 下面我们来解这个方程： </p><p> x + (x-1) + (x-2) + … + 1 = 100 转化为 </p><p> (x+1)*x/2 = 100 </p><p> 最终x向上取整，得到 x = 14 </p><p> 因此，最优解在最坏情况的尝试次数是14次，第一次扔鸡蛋的楼层也是14层。 </p><p> 最后，让我们把第一个鸡蛋没碎的情况下，所尝试的楼层数完整列举出来： </p><p> 14，27， 39， 50， 60， 69， 77， 84， 90， 95， 99， 100 </p><p> 举个栗子验证下： </p><p> 假如鸡蛋不会碎的临界点是65层，那么第一个鸡蛋扔出的楼层是14，27，50，60，69。这时候啪的一声碎了。 </p><p> 第二个鸡蛋继续，从61层开始，61，62，63，64，65，66，啪的一声碎了。 </p><p> 因此得到不会碎的临界点65层，总尝试次数是 6 + 6 = 12 &lt; 14 。 </p><p> 下面是我个人的理解：这个更像是优化版的均匀法，均匀法让你第二次尝试不超过10，但是第一次的位置无法保证（最多要9次，最好一次），这个由于每多一次尝试，楼层间隔就-1，最终使得第一次与第二次的和完全均匀（最差情况）。 </p><p> 但是核心思路是逆向思考，因为即使理解了需要两次的和均匀也很难得到第一次要在哪层楼扔。 </p><p> 一旦理解了这种方法，多少层楼你都不会怕啦~</p><p>来源：<a href="https://blog.csdn.net/qq_38316721/article/details/81351297" target="_blank" rel="noopener">https://blog.csdn.net/qq_38316721/article/details/81351297</a></p><h2 id="20-一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样"><a href="#20-一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样" class="headerlink" title="20.一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样"></a>20.一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样</h2><p>1/3<br>样本空间为（男男）（女女）（男女）（女男）<br>A＝（已知其中一个是女孩）＝）（女女）（男女）（女男）<br>B＝（另一个也是女孩）＝（女女）<br>于是P（B／A）＝P（AB）／P（A）＝（1／4）／（3／4）＝1／3</p><h2 id="21-分金条"><a href="#21-分金条" class="headerlink" title="21.分金条"></a>21.分金条</h2><p>有个商人雇用了一位手艺高超的工匠了为他做一个精致产品，工作一星期七天的代价是一条金条。商人手头上有一条金条，刚好有可以付工匠一星期的工钱。但工匠要求工钱要按每天来付。虽然他并不急着用钱，每天有钱进账，老人心里总是踏实一些。但商人家中有个规矩，金条每星期只能切二刀。后来商人想出以了个切割金条的办法，满足了工匠的要求。你知道商人是怎么切割金条才能满足工匠的吗？</p><p>切成1、2、4。这三个二进制数的组合能表示0-7中的任何一个。</p><h2 id="22-假钱问题"><a href="#22-假钱问题" class="headerlink" title="22.假钱问题"></a>22.假钱问题</h2><p><strong>老王30买了双鞋，35卖，客人花100买，老王没零钱于是向老李换了100.补给客人后，客人走远后老李突然说是假钱，于是老王补偿给了老李，问老王一共亏了多少？</strong></p><p>卖鞋赚了35-30=5<br>假钱赔了100<br>一共亏95</p><h2 id="23-取硬币问题"><a href="#23-取硬币问题" class="headerlink" title="23.取硬币问题"></a>23.取硬币问题</h2><p><strong>30枚面值不全相同的硬币摆成一排，甲、乙两个人轮流选择这排硬币的其中一端，并取走最外边的那枚硬币。如果你先取硬币，能保证得到的钱不会比对手少吗？</strong></p><p>先取者可以让自己总是取奇数位置上的硬币或者总是取偶数位置上的硬币。数一数是奇数位置上的面值总和多还是偶数位置上的面值总和多，然后总是取这些位置上的硬币就可以了。</p><h2 id="24-旅馆问题"><a href="#24-旅馆问题" class="headerlink" title="24.旅馆问题"></a>24.旅馆问题</h2><p>有三个人去住旅馆，住三间房，每一间房10元，于是他们一共付给老板30，第二天，老板觉得三间房只需要25元就够了  叫小弟退回5给三位客人，谁知小弟贪心,只退回每人1，自己偷偷拿了2，这样一来便等于那三位客人每人各花了九元，于是三个人一共花了27，再加上小弟独吞了2，总共是29。可是当初他们三个人一共付出30，那么还有剩下的1呢？</p><p>他们所消费的27元里已经包括小弟贪污的2元了，再加退还的3元=30元。：这30元现在的分布是：老板拿25元，伙计拿2元，三人各拿1元，正好！</p><h2 id="25-蓝眼睛问题"><a href="#25-蓝眼睛问题" class="headerlink" title="25.蓝眼睛问题"></a>25.蓝眼睛问题</h2><p>有个岛上住着一群人，有一天来了个游客，定了一条奇怪的规矩：所有蓝眼睛的人都必须尽快离开这个岛。每晚8点会有一个航班离岛。每个人都看得见别人眼睛的颜色，但不知道自己的（别人也不可以告知）。此外，他们不知道岛上到底有多少人是蓝眼睛的，只知道至少有一个人的眼睛是蓝色的。所有蓝眼睛的人要花几天才能离开这个岛？</p><p>c=1<br>假设岛上所有人都是聪明的，蓝眼睛的人四处观察之后，发现没有人是蓝眼睛的。但他知道至少有一人是蓝眼睛的，于是就能推导出自己一定是蓝眼睛的。因此，他会搭乘当晚的飞机离开。 </p><p>c=2<br>两个蓝眼睛的人看到对方，并不确定c是1还是2，但是由上一种情况，他们知道，如果c = 1，那个蓝眼睛的人第一晚就会离岛。因此，发现另一个蓝眼睛的人仍在岛上，他一定能推断出c = 2，也就意味着他自己也是蓝眼睛的。于是，两个蓝眼睛的人都会在第二晚离岛。</p><p>c&gt;2<br>逐步提高c时，我们可以看出上述逻辑仍旧适用。如果c = 3，那么，这三个人会立即意识到有2到3人是蓝眼睛的。如果有两人是蓝眼睛的，那么这两人会在第二晚离岛。因此，如果过了第二晚另外两人还在岛上，每个蓝眼睛的人都能推断出c = 3，因此这三人都有蓝眼睛。他们会在第三晚离岛。 </p><p>不论c为什么值，都可以套用这个模式。所以，如果有c人是蓝眼睛的，则所有蓝眼睛的人要用c晚才能离岛，且都在同一晚离开。</p><h2 id="26-疯狗问题"><a href="#26-疯狗问题" class="headerlink" title="26.疯狗问题"></a>26.疯狗问题</h2><p>有50家人家，每家一条狗。有一天警察通知，50条狗当中有病狗，行为和正常狗不一样。每人只能通过观察别人家的狗来判断自己家的狗是否生病，而不能看自己家的狗，如果判断出自己家的狗病了，就必须当天一枪打死自己家的狗。结果，第一天没有，第二天没有，第三天开始一阵枪响，问：一共死了几条狗？</p><p>死了3条（第几天枪响就有几条）。<br>从有一条不正常的狗开始，显然第一天将会听到一声枪响。这里的要点是你只需站在那条不正常狗的主人的角度考虑。<br>有两条的话思路继续，只考虑有两条不正常狗的人，其余人无需考虑。通过第一天他们了解了对方的信息。第二天杀死自己的狗。换句话说每个人需要一天的时间证明自己的狗是正常的。有三条的话，同样只考虑那三个人，其中每一个人需要两天的时间证明自己的狗是正常的狗。</p><h2 id="27-耳光问题（跟蓝眼睛一样）"><a href="#27-耳光问题（跟蓝眼睛一样）" class="headerlink" title="27.耳光问题（跟蓝眼睛一样）"></a>27.耳光问题（跟蓝眼睛一样）</h2><p>一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其他人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？</p><p>答案：有三个人戴黑帽。假设有N个人戴黑帽，当N＝1时，戴黑帽的人看见别人都为白则能肯定自己为黑。于是第一次关灯就应该有声。可以断定N＞1。对于每个戴黑帽的人来说，他能看见N-1顶黑帽，并由此假定自己为白。但等待N-1次还没有人打自己以后，每个戴黑人都能知道自己也是黑的了。所以第N次关灯就有N个人打自己。</p><h2 id="28-红球篮球"><a href="#28-红球篮球" class="headerlink" title="28.红球篮球"></a>28.红球篮球</h2><p><strong>你有两个罐子，每个罐子各有若干红色弹球和蓝色弹球，两个罐子共有50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机从中选取出一个弹球，要使取出的是红球的概率最大，一开始两个罐子应放几个红球，几个蓝球？在你的计划中，得到红球的准确几率是多少？</strong></p><p>一个罐子放1红，一个罐子放49红和50蓝，这样得到红球的概率接近3/4。</p><h2 id="29-猜数字"><a href="#29-猜数字" class="headerlink" title="29.猜数字"></a>29.猜数字</h2><p>教授选出两个从2到9的数，把它们的和告诉学生甲，把它们的积告诉学生乙，让他们轮流猜这两个数， 甲说：“我猜不出”， 乙说：“我猜不出”， 甲说：“我猜到了”， 乙说：“我也猜到了”， 问这两个数是多少？</p><p>3和4。设两个数为n1，n2，n1&gt; =n2，甲听到的数为n=n1 n2，乙听到的数为m=n1*n2，证明n1=3，n2=4是唯一解。</p><p>证明：要证以上命题为真，不妨先证n=7</p><p>1)必要性：<br> 　　i) n&gt; 5 是显然的，因为n &lt;4不可能，n=4或者n=5甲都不可能回答不知道<br> 　　ii) n&gt; 6 因为如果n=6的话，那么甲虽然不知道(不确定2 4还是3 3)但是无论是2，4还是3，3乙都不可能说不知道(m=8或者m=9的话乙说不知道是没有道理的)<br> 　　iii) n &lt;8 因为如果n&gt; =8的话，就可以将n分解成 n=4 x 和 n=6 (x-2)，那么m可以是4x也可以是6(x-2)而4x=6(x-2)的必要条件是x=6即n=10，那样n又可以分解成8 2，所以总之当n&gt; =8时，n至少可以分解成两种不同的合数之和，这样乙说不知道的时候，甲就没有理由马上说知道。以上证明了必要性。<br>2)充分性<br>当n=7时，n可以分解成2 5或3 4<br>显然2 5不符合题意，舍去，容易判断出3 4符合题意，m=12，证毕<br>于是得到n=7 m=12 n1=3 n2=4是唯一解。</p><h2 id="30-水果标签问题"><a href="#30-水果标签问题" class="headerlink" title="30.水果标签问题"></a>30.水果标签问题</h2><p><strong>3个箱子里面放了 苹果，梨子，苹果加梨子，标签全错误，只能选择查看一箱的水果来改正所有标签</strong></p><p>查看贴苹果和梨标签那一个，如果拿出来的是苹果，代表这一箱只有苹果，因为如果是苹果和梨就代表标签没错了。<br>那么剩下的两箱就是梨，苹果和梨，剩下的标签是梨，苹果，由于标签全错，所以贴着苹果的是梨，贴着梨的是苹果和梨。<br>如果拿出来的是梨，同理代表这一箱只有梨。那么剩下的两箱就是苹果，苹果和梨，剩下的标签就是苹果，梨。由于标签全错，贴着苹果的就是苹果和梨，贴着梨的就是苹果。</p><h2 id="31-便士标签问题（和水果标签一样）"><a href="#31-便士标签问题（和水果标签一样）" class="headerlink" title="31.便士标签问题（和水果标签一样）"></a>31.便士标签问题（和水果标签一样）</h2><p>假设在桌上有三个密封的盒，一个盒中有2枚银币(1银币=10便士)，一个盒中有2枚镍币(1镍币=5便士)，还有一个盒中有1枚银币和1枚镍币。这些盒子被标上10便士、 15便士和20便士，但每个标签都是错误的。允许你从一个盒中拿出1枚硬币放在盒前，看到这枚硬币，你能否说出每个盒内装的东西呢？</p><h2 id="32-吃药问题"><a href="#32-吃药问题" class="headerlink" title="32.吃药问题"></a>32.吃药问题</h2><p>某种药方要求非常严格，你每天需要同时服用A、B两种药片各一颗，不能多也不能少。这种药非常贵，你不希望有任何一点的浪费。一天，你打开装药片A的药瓶，倒出一粒药片放在手心；然后打开另一个药瓶，但不小心倒出了两粒药片。现在，你手心上有一颗药片A，两颗药片B，并且你无法区别哪个是A，哪个是B。你如何才能严格遵循药方服用药片，并且不能有任何的浪费？</p><p>把手上的三片药各自切成两半，分成两堆摆放。再取出一粒药片A，也把它切成两半，然后在每一堆里加上半片的A。现在，每一堆药片恰好包含两个半片的A和两个半片的B。一天服用其中一堆即可。</p><h2 id="33-硬币问题"><a href="#33-硬币问题" class="headerlink" title="33.硬币问题"></a>33.硬币问题</h2><p>如何用一枚硬币等概率生成一个1到3之间的随机整数？如果这枚硬币是不公正的呢？</p><p>答案：如果是公正的硬币，则投掷两次，“正反”为1，“反正”为2，“正正”为3，“反反”重来。</p><p>如果是不公正的硬币，注意到出现“正反”和“反正”的概率一样，因此令“正反反正”、“反正正反”、“正反正反”分别为1、2、3，其余情况重来。另一种更妙的办法是，投掷三次硬币，“正反反”为1，“反正反”为2，“反反正”为3，其余情况重来。</p><h2 id="34-灯管问题"><a href="#34-灯管问题" class="headerlink" title="34.灯管问题"></a>34.灯管问题</h2><p><strong>在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？</strong></p><p>打开一个开关。过10分钟后关掉开关，并打开另一个开关。进屋确认可知：<br>亮的灯是由第二次打开的开关控制；<br>摸上去发热的不发亮的灯是由第一次打开的开关控制<br>剩下的第三盏灯是由未操作过的开关控制。</p><h2 id="35-盲人问题"><a href="#35-盲人问题" class="headerlink" title="35.盲人问题"></a>35.盲人问题</h2><p>他们都各自买了两对黑袜和两对白袜，八对袜了的布质、大小完全相同，而每对袜了都有一张商标纸连着。两位盲人不小心将八对袜了混在一起。 他们每人怎样才能取回黑袜和白袜各两对呢？</p><p>每一对分开，一人拿一只，因为袜子不分左右脚</p><h2 id="36-最大钻石问题"><a href="#36-最大钻石问题" class="headerlink" title="36.最大钻石问题"></a>36.最大钻石问题</h2><p><strong>一楼到十楼的每层电梯门口都放着一颗钻石，钻石大小不一。你乘坐电梯从一楼到十楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到最大的一颗？</strong></p><p>选择前五层楼都不拿，观察各层钻石的大小，做到心中有数。后面五个楼层再选择，选择大小接近前五层楼出现过最大钻石大小的钻石。</p><h2 id="37-飞机飞行的问题"><a href="#37-飞机飞行的问题" class="headerlink" title="37.飞机飞行的问题"></a>37.飞机飞行的问题</h2><p>有N架一样的飞机停靠在同一个机场，每架飞机都只有一个油箱，每箱油可使飞机绕地球飞半圈。注意：天空没有加油站，飞机之间只是可以相互 加油。 如果使某一架飞机平安地绕地球飞一圈，并安全地回到起飞时的机场，问：至少需要出动几架飞机？ 注：路途中间没有飞机场，每架飞机都必须安全返回起飞时的机场，不许中途降落。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一共需要6架飞机。假设绕地球一圈为1，3 架飞机同时顺时针飞，在1&#x2F;8 处 油量为 3&#x2F;4 3&#x2F;4 3&#x2F;4 其中一辆給另外两加满往回飞，此时油量为1，1，到1&#x2F;4 处 油量为3&#x2F;4，3&#x2F;4， 加满一辆，另一辆往回 2&#x2F;4 ，1，可以飞到3&#x2F;4 的位置 此时油量为0</span><br><span class="line"></span><br><span class="line">3架飞机往逆时针方向飞，在7&#x2F;8 位置3&#x2F;4， 3&#x2F;4， 3&#x2F;4 ，一架给另两加满然后往回飞 1，1，0，继续飞，在3&#x2F;4 位置 油量为 3&#x2F;4， 3&#x2F;4， 0 ， 平衡一下 2&#x2F;4 ，2&#x2F;4 ，2&#x2F;4 可以把之前的飞机接回去</span><br></pre></td></tr></table></figure><h2 id="38-犯人猜颜色"><a href="#38-犯人猜颜色" class="headerlink" title="38.犯人猜颜色"></a>38.犯人猜颜色</h2><p>一百个犯人站成一纵列，每人头上随机带上黑色或白色的帽子，各人不知道自己帽子的颜色，但是能看见自己前面所有人帽子的颜色．<br> 然后从最后一个犯人开始，每人只能用同一种声调和音量说一个字：”黑”或”白”，<br> 如果说中了自己帽子的颜色，就存活，说错了就拉出去斩了，<br> 说的答案所有犯人都能听见，<br> 是否说对，其他犯人不知道，<br> 在这之前，所有犯人可以聚在一起商量策略，<br> 问如果犯人都足够聪明而且反应足够快，100个人最大存活率是多少？ </p><p> 答案：这是一道经典推理题 </p><p> 1、最后一个人如果看到奇数顶黑帽子报“黑”否则报“白”，他可能死 </p><p> 2、其他人记住这个值（实际是黑帽奇偶数），在此之后当再听到黑时，黑帽数量减一 </p><p> 3、从倒数第二人开始，就有两个信息：记住的值与看到的值，相同报“白”，不同报“黑” </p><p> 99人能100%存活，1人50%能活 </p><p> 除此以外，此题还有变种：每个犯人只能看见前面一个人帽子颜色又能最多存活多少人？ </p><p> 答案：在上题基础上，限制了条件，这时上次的方法就不管用了，此时只能约定偶数位犯人说他前一个人的帽子颜色，奇数犯人获取信息100%存活，偶数犯人50几率存活。</p><h2 id="39-猴子搬香蕉"><a href="#39-猴子搬香蕉" class="headerlink" title="39.猴子搬香蕉"></a>39.猴子搬香蕉</h2><p>一个小猴子边上有100根香蕉，它要走过50米才能到家，每次它最多搬50根香蕉，（多了就被压死了），它每走 </p><p> 1米就要吃掉一根，请问它最多能把多少根香蕉搬到家里。（提示：他可以把香蕉放下往返的走，但是必须保证它每走一米都能有香蕉吃。也可以走到n米时，放下一些香蕉，拿着n根香蕉走回去重新搬50根。） </p><p> 答案：这种试题通常有一个迷惑点，让人看不懂题目的意图。此题迷惑点在于：走一米吃一根香蕉，一共走50米，那不是把50根香蕉吃完了吗？如果要回去搬另外50根香蕉，则往回走的时候也要吃香蕉，这样每走一米需要吃掉三根香蕉，走50米岂不是需要150根香蕉？ </p><p> 其实不然，本题关键点在于：猴子搬箱子的过程其实分为两个阶段，第一阶段：来回搬，当香蕉数目大于50根时，猴子每搬一米需要吃掉三根香蕉。第二阶段：香蕉数《=50，直接搬回去。每走一米吃掉1根。 </p><p> 我们分析第一阶段：假如把100根香蕉分为两箱。一箱50根。 </p><p> 第一步，把A箱搬一米，吃一根。 </p><p> 第二步，往回走一米，吃一根。 </p><p> 第三步，把B箱搬一米，吃一根。 </p><p> 这样，把所有香蕉搬走一米需要吃掉三根香蕉。 </p><p> 这样走到第几米的时候，香蕉数刚好小于50呢？ </p><p> 100-(n<em>3)&lt;50 &amp;&amp; 100-(n-1</em>3)&gt;50 </p><p> 走到16米的时候，吃掉48根香蕉，剩52根香蕉。这步很有意思，它可以直接搬50往前走，也可以再来回搬一次，但结果都是一样的。到17米的时候，猴子还有49根香蕉。这时猴子就轻松啦。直接背着走就行。 </p><p> 第二阶段： </p><p> 走一米吃一根。 </p><p> 把剩下的50-17=33米走完。还剩49-33=16根香蕉。</p><h2 id="40-轮流拿石头"><a href="#40-轮流拿石头" class="headerlink" title="40.轮流拿石头"></a>40.轮流拿石头</h2><p>问题：一共有N颗石子（或者其他乱七八糟的东西），每次最多取M颗最少取1颗，A，B轮流取，谁最后会获胜？（假设他们每次都取最优解）。</p><p>例子：有10个石头，每人每次可以拿1-2个，轮流拿，最后一个拿的人算输，有什么必赢的方案。</p><p>先说结论：</p><p>假如A先取，N&lt;M，A获胜；</p><p>　　　　　  N&gt;M，若N能被（M + 1）整除时，A失败；</p><p>　　　　　　　　  若N不能被（M + 1）整除时，A获胜；</p><p>假如B先取，（同上）；</p><p>N&gt;M时，A要想赢，必须要在自己倒数第二次取完的时候还剩下（M + 1）颗石子（此时A和B还可以再取一次就可以分出胜负游戏就结束了），这样不论B取几颗，A都获胜！但是要怎样才能控制最后一轮的石子数量？</p><p>分两种情况分析，</p><ol><li>N不能被（M + 1）整除，A先拿走n颗石子（使得剩下的石子数量是（M + 1）的整数倍），那么下一次B拿走k颗石子时，A就拿走（M + 1）- k颗石子。这样不论B怎么拿A总能控制剩下的石子数量是（M + 1）的整数倍，那么最后一轮一定剩下（M + 1）颗石子；</li><li>N能被（M + 1）整除，A就认输吧。。。（B除非傻才会让A赢）无论A怎么拿，B可以控制石子数量（即当B拿完后总能使剩下的石子数量是（M + 1）的整数倍)，在最后一轮之前B拿完后还剩（M + 1）颗，A拿多少颗都是输。</li></ol><p><a href="https://www.cnblogs.com/StrayWolf/p/5396427.html" target="_blank" rel="noopener">https://www.cnblogs.com/StrayWolf/p/5396427.html</a></p><p> 答案：较复杂的尼姆博弈：<a href="https://blog.csdn.net/BBHHTT/article/details/80199541" target="_blank" rel="noopener">https://blog.csdn.net/BBHHTT/article/details/80199541</a></p><p>母题：有若干堆石子，每堆石子的数量是有限的，二个人依次从这些石子堆中拿取任意的石子，至少一个（不能不取），最后一个拿光石子的人胜利。</p><p>1、我们首先以一堆为例： 假设现在只有一堆石子，你的最佳选择是将所有石子全部拿走，那么你就赢了。</p><p>2、如果是两堆：假设现在有两堆石子且数量不相同，那么你的最佳选择是取走多的那堆石子中多出来的那几个，使得两堆石子数量相同，这样，不管另一个怎么取，你都可以在另一堆中和他取相同的个数，这样的局面你就是必胜。比如有两堆石子，第一堆有3个，第二堆有5个，这时候你要拿走第二堆的三个，然后两堆就都变成了3个，这时你的对手无论怎么操作，你都可以“学”他，比如他在第一堆拿走两个，你就在第二堆拿走两个，这样你就是稳赢的</p><h2 id="41-蚂蚁走树枝"><a href="#41-蚂蚁走树枝" class="headerlink" title="41. 蚂蚁走树枝"></a>41. 蚂蚁走树枝</h2><p> 问题：放N只蚂蚁在一条长度为M树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。 </p><p> 答案：这个其实就一个诀窍：蚂蚁相碰就往反方向走，可以直接看做没有发生任何事：大家都相当于独立的 </p><p>  A蚂蚁与B蚂蚁相碰后你可以看做没有发生这次碰撞，这样无论是求时间还是距离都很简单了。</p><h2 id="42-三个火枪手"><a href="#42-三个火枪手" class="headerlink" title="42.三个火枪手"></a>42.三个火枪手</h2><p>问题：彼此痛恨的甲、乙、丙三个枪手准备决斗。甲枪法最好，十发八中；乙枪法次之，十发六中；丙枪法最差，十发四中。如果三人同时***，并且每人每轮只发一枪；那么枪战后，谁活下来的机会大一些？ </p><p> 答案： </p><p> 一般人认为甲的枪法好，活下来的可能性大一些。但合乎推理的结论是，枪法最糟糕的丙活下来的几率最大。 </p><p> 那么我们先来分析一下各个枪手的策略。 </p><p> 如同田忌赛马一般，枪手甲一定要对枪手乙先***。因为乙对甲的威胁要比丙对甲的威胁更大，甲应该首先干掉乙，这是甲的最佳策略。 </p><p> 同样的道理，枪手乙的最佳策略是第一枪瞄准甲。乙一旦将甲干掉，乙和丙进行对决，乙胜算的概率自然大很多。 </p><p> 枪手丙的最佳策略也是先对甲***。乙的枪法毕竟比甲差一些，丙先把甲干掉再与乙进行对决，丙的存活概率还是要高一些。 </p><p> 我们根据分析来计算一下三个枪手在上述情况下的存活几率：<br> 第一轮：甲射乙，乙射甲，丙射甲。<br> 甲的活率为24%（40% X 60%） </p><p> 乙的活率为20%(100% - 80%) </p><p> 丙的活率为100%（无人射丙）。 </p><p> 由于丙100％存活率，因此根据上轮甲乙存活的情况来计算三人第二轮的存活几率： </p><p> 情况1：甲活乙死（24% X 80% = 19.2%）<br> 甲射丙，丙射甲：甲的活率为60%，丙的活率为20%。<br> 情况2：乙活甲死（20% X 76% = 15.2%）<br> 乙射丙，丙射乙：乙的活率为60%，丙的活率为40%。<br> 情况3：甲乙同活（24% X 20% = 4.8%）<br> 重复第一轮。<br> 情况4：甲乙同死（76% X 80% = 60.8%）<br> 枪战结束。 </p><p> 据此来计算三人活率：<br> 甲的活率为(19.2% X 60%) + (4.8% X 24%) = 12.672%<br> 乙的活率为(15.2% X 60%) + (4.8% X 20%) = 10.08%<br> 丙的活率为(19.2% X 20%) + (15.2% X 40%) + (4.8% X 100%) + (60.8% X 100%) = 75.52% </p><p> 通过对两轮枪战的详细概率计算，我们发现枪法最差的丙存活的几率最大，枪法较好的甲和乙的存活几率却远低于丙的存活几率。</p><h2 id="43-囚犯拿豆子"><a href="#43-囚犯拿豆子" class="headerlink" title="43.囚犯拿豆子"></a>43.囚犯拿豆子</h2><p>问题：有5个囚犯被判了死刑，他们请求上诉，于是法官愿意给他们一个机会。 </p><p> 犯人抽签分好顺序，按序每人从100粒豆子中随意抓取，最多可以全抓，最少可以不抓，可以和别人抓的一样多。 </p><p> 最终，抓的最多的和最少的要被处死。 </p><p> 1、他们都是非常聪明且自私的人。 </p><p> 2、他们的原则是先求保命。如果不能保命，就拉人陪葬。 </p><p> 3、100颗不必都分完。 </p><p> 4、若有重复的情况，则也算最大或最小，一并处死（中间重复不算）。 </p><p> 假设每个犯人都足够聪明，但每个犯人并不知道其他犯人足够聪明。那么，谁活下来的可能性最大？</p><p>根据题意，一号知道有五个人抓豆子，为保性命，他只要让豆子在20颗以内就可以了。但是他足够聪明的话他一定拿20颗，因为无论多拿一颗：2,3,4号的人一定会拿20颗最后死的人就会是最多的1号和最少的5号  还是少拿一颗：2,3,4号拿20个后，5号选择也拿20个拉上1234号垫背。（下面会说为什么多拿少拿也只会相差一颗） </p><p> 2号是知道1号抓了几颗豆子(20)的。那么，对于2号来说，只有2种选择：与1号一样多，或者不一样多。我们就从这里入手。 </p><p> 情况一，假如2号选择与1号的豆子数不一样多，也就是说2号选择比1号多或者比1号少。 </p><p> 我们先要证明，如果2号选择比1号多或者比1号少，那么他一定会选择比1号只多1颗或者只少1颗。 </p><p> 要证明这个并不算太难。因为每个囚犯的第一选择是先求保命，要保命就要尽量使自己的豆子数既不是最多也不是最少。当2号决定选择比1号多的时候，他已经可以保证自己不是最少，为了尽量使自己不是最多，当然比1号多出来的数量越小越好。因为这个数量如果与一号相差大于1的话，那么3号就有机会抓到的居中数，相差越大，二号成为最多的可能性也就越大。反之，当2号决定选择比1号少的时候，也是同样的道理，他会选择只比1号少1颗。既然2号只会会选择比1号多1颗或者比1号少1颗，那么1、2号的豆子数一定是2个连续的自然数，和一定是2n+1（其中1个人是n,另1人是n+1）。 </p><p> 轮到3号的时候，他可以从剩下的豆子数知道1、2号的数量和，也就不难计算出n的值。而3号也只有2个选择：n颗或者n+1颗。为什么呢？这与上面的证明是一样的道理，保命原则，取最接近的数量，这里不再赘述。 </p><p> 不过，3号选择的时候会有一个特殊情况，在这一情况下，他一定会选择较小的n，而不是较大的n+1。这一特殊情况就是，当3号知道自己选择了n后(已保证自己不是最多)，剩下的豆子数由于数量有限，4、5号中一定有人比n要少，这样自己一定可以活下来。计算的话就是 [100-(3n+1)]/2&lt;=n ，不难算出，在这个特殊情况下，n&gt;=20。也就是说，当1、2号选择了20或21颗的时候，3号只要选择20颗，就可以保证自己活下来。 </p><p> 这样一来剩下的豆子只剩39颗，4、5号至少有一人少于20颗的（这个人当然是后选的5号），这样死的将是5号和1、2号中选21颗的那个人。当然，1号、2号肯定不会有人选择21这一“倒霉”的数字（因为他们都是聪明人），这样的话，上述“特殊情况（即3号选择n）”就不会发生了。 </p><p> 综上所述，2345这四个人不难从剩下的豆子数知道前面几个人的数量总和，也就不难进而计算出n的值，而这样一来他们也只有n或者n+1这两种选择。最后的5号也是不难算出n的。在前4个人只选择了2个数字(n和n+1)的情况下，5号已是必死无疑，这时,根据“死也要拉几个垫背”的条件，5号会选择n或n+1，选择5个人一起完蛋。 </p><p> 情况二，如果2号选择了与1号不一样多的话，最终结果是5个人一起死，那么2号只有选择与1号一样多了。 </p><p> 那么1、2号的和就是2n，而3号如果选择n+1或者n -1的话，就又回到第一点的情况去了(前3个人的和是3m+1或3m+2)，于是3号也只能选择n ，当然，4号还是只能选n，最后的结果仍旧是5个人一起完蛋。 </p><p> “最后处死抓的最多和最少的囚犯”严格执行这句话的话，除非有人舍己为人，死二留三。但这是足够聪明且自私的囚犯，所以这五个聪明人的下场是全死，这道题只不过是找了一个处死所有人的借口罢了. . . . . . </p><p> 变种问题：如果每个囚犯都知道其他囚犯足够聪明，事情会怎么发展？ </p><p> 答案： </p><p> 这样的情况下囚犯一也会像我们一样推导出前面的结论，那么根据自私的规定，他会直接拿完100个，大家一起完蛋(反正结局已定) </p><h2 id="44-学生猜生日-lt-笔试高频-gt"><a href="#44-学生猜生日-lt-笔试高频-gt" class="headerlink" title="44.学生猜生日&lt;笔试高频&gt;"></a>44.学生猜生日&lt;笔试高频&gt;</h2><p>这种题目笔试中出现的次数比较多，用排除法比较好解决</p><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p> 小明和小强都是张老师的学生，张老师的生日是M月N日, </p><p> 2人都知道张老师的生日是下列10组中的一天，张老师把M值告诉了小明, </p><p> 把N值告诉了小强，张老师问他们知道他的生日是那一天吗? </p><p> 3月4日 3月5日 3月8日 </p><p> 6月4日 6月7日 </p><p> 9月1日 9月5日 </p><p> 12月1日 12月2日 12月8日 </p><p> 小明说:如果我不知道的话，小强肯定也不知道. </p><p> 小强说:本来我也不知道，但是现在我知道了. </p><p> 小明说:哦，那我也知道了. </p><p> 请根据以上对话推断出张老师的生日是哪一天? </p><p> 答案：9月1日 </p><p> 排除法： </p><p> 1.小明肯定小强不知道是哪天，排除所有月份里有单独日的月份：6月和12月&lt;因为如果小强的M是2或者7的话，小强就知道了，所以把6月7日与12月2日排除&gt;，所以小明拿到的是3或者9 </p><p> 2.小强本来不知道，所以小强拿到的不是2或者7，但是小强现在知道了，说明把6月与12月排除后，小强拿到的是1,4,8中的一个&lt;这里小强肯定没拿到5，否则他不会知道是哪天的&gt; </p><p> 3.小明现在也知道了，说明小明拿到的不是3，否则他不会知道是3月4日还是3月8日的，所以小明拿到的是9才能唯一确定生日 </p><p> 综上，答案是9月1日 </p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p> 小明和小强是赵老师的学生，张老师的生日是M月N日，张老师 </p><p> 把M值告诉小明，N值告诉小强 </p><p> 给他们六个选项 </p><p> 3月1日 3月3日 7月3日 7月5日  </p><p> 9月1日 11月7日 </p><p> 小明说:我猜不出来 </p><p> 小强说:本来我也猜不出来，但是现在我知道了 </p><p> 问:张老师生日多少 </p><p> 答案：3月1日 </p><p> 排除法： </p><p> 1.小明说猜不出来，说明小明拿到的不是单独出现的9或者11，说明老师生日只能是3月或者7月 </p><p> 2.小强原本不知道，说明小强拿到的不是单独出现的5或者7，说明老是生日是1日或3日 </p><p> 3.小强现在知道了，说明小强拿到的是1，因为如果拿到的是3，那么小强就不知道是3月3日还是7月3日了 </p><p>   综上，老师生日是3月1日  </p><h2 id="45-火车开车问题"><a href="#45-火车开车问题" class="headerlink" title="45.火车开车问题"></a>45.火车开车问题</h2><p>有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以每小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和两辆火车现时启动，从洛杉矶出发，碰到另一辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，假设洛杉矶到纽约的距离为s, 请问，这只小鸟飞行了多长距离？</p><p>那小鸟飞行的距离就是(s/(15+20))*30。 时间 * 速度</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="网络协议分层"><a href="#网络协议分层" class="headerlink" title="网络协议分层"></a>网络协议分层</h2><p>国际标准化组织 ISO 提出了 OSI 开放互连的七层计算机网络模型，从上到下分别是应用层、表示层、会话层、运输层、网络层、链路层和物理层。OSI 模型的概念清楚，理论也比较完善，但是既复杂又不实用。还有一种是 TCP/IP 体系结构，它分为四层，从上到下分别是应用层、运输层、网际层和网络接口层，不过从实质上将只有三层，因为最下面的网络接口层并没有什么具体内容。因特网的协议栈使用一种五层的模型结构，从上到下依次是<strong>应用层、运输层、网络层、链路层和物理层</strong>，其中下层是为上层提供服务的，每层执行某些动作或使用下层的服务来提高服务。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层是网络体系结构中的最高层，应用层的任务就是<strong>通过应用进程之间的交互来完成特定网络应用</strong>，这一层的数据单元叫做<strong>报文</strong>。</p><p>应用层的协议定义了<strong>应用进程之间通信和交互的规则</strong>，主要包括了域名系统 DNS、支持万维网的 HTTP 协议、支持电子邮件的 SMTP 协议、文件传输协议 FTP 等。</p><p><strong>域名解析系统 DNS</strong></p><p>DNS 被设计为一个联机分布式数据库系统，并采用客户服务器方式。DNS 使大多数名字都在本地进行解析，仅少量解析需要在互联网上通信，因此 DNS 的效率很高。由于 DNS 是分布式系统，即使单个计算机出现了故障也不会妨碍到整个 DNS 系统的正常运行。</p><p><strong>主机向本地域名服务器的查询一般都采用递归查询</strong>，递归查询指如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份向其他根域名服务器继续发出查询请求报文。递归查询的结果是要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</p><p><strong>本地域名服务器向根域名服务器查询通常采用迭代查询</strong>，迭代查询指当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉它该向哪一个域名服务器进行查询。本地域名服务器也可以采用递归查询，这取决于最初的查询请求报文设置的查询方式。</p><p><strong>文件传送协议 FTP</strong></p><p>FTP 使用 TCP 可靠的运输服务，FTP 使用客户服务器方式，一个 FTP 服务器进程可以同时为多个客户进程提供服务，在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：控制连接和数据连接，实际用于传输文件的是数据连接。</p><p><strong>电子邮件系统协议 SMTP/POP3/IMAP</strong></p><p>一个电子邮件系统有三个主要组成构件，即用户代理、邮件服务器、以及邮件协议。</p><p>从用户代理把邮件传送到邮件服务器，以及在邮件服务器之间的传送都要使用 SMTP，但用户代理从邮件服务器读取邮件时则要使用 POP3 或 IMAP 协议。</p><p>基于万维网的电子邮件使用户可以利用浏览器收发电子邮件，用户浏览器和邮件服务器之间使用 HTTP 协议，而邮件服务器之间的传送仍然使用 SMTP 协议。</p><p><strong>DHCP (Dynamic Host Configuration Protocol) 动态主机配置协议</strong></p><p>提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><ol><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li></ol><p><strong>子网掩码的作用</strong></p><p>子网掩码的作用: </p><p>1、用于将一个大的IP网络划分为若干小的子网络：</p><p>因为随着互联网的发展，越来越多的网络产生，有的网络多则几百台，有的只有区区几台，这样就浪费了很多IP地址，所以要划分子网。使用子网可以提高网络应用的效率。</p><p>2、用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上：</p><hr><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>运输层的任务就是<strong>负责向两台主机中进程之间的通信提供通用的数据传输服务</strong>，应用进程利用该服务来传送应用层报文。由于一台主机同时可以运行多个进程，因此运输层具有复用和分用的功能，复用就是多个应用层进程可以同时使用下面运输层的服务，分用就是把运输层收到的信息分别交付给上面应用层中的对应进程。</p><p>运输层主要使用两种协议：① 用户数据报协议 UDP，这是一种提供无连接的、尽最大努力交付的数据传输服务，不保证数据传输的可靠性，数据传输单位是用户数据报。② 传输控制协议 TCP，这是一种面向连接的、可靠的数据传输服务，数据传输单元是报文。</p><hr><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层负责<strong>为分组交换网上的不同主机提供通信服务</strong>，在发生数据时，网络层把数据层产生的报文或用户数据报封装成<strong>分组</strong>进行传送，由于网络层使用 IP 协议，因此分组也叫 <strong>IP 数据报</strong>。网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。</p><p>网络层的协议包括了网际协议 IP、地址解析协议 ARP、网际控制报文协议 ICMP 以及路由选择协议 RIP/OSPF/BGP-4 等。</p><p><strong>网际协议 IP</strong></p><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，一般指的是 IPv4。与 IP 协议配套使用的协议还有 ARP、ICMP 和 IGMP，IP 使用 ARP，ICMP 和 IGMP 要使用 IP。由于网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP/IP 体系中的网络层也称网际层或 IP 层。要解决 IP 地址耗尽的问题，根本方法是采用具有更大地址空间的新版本 IP 协议即 IPv6，向 IPv6 过渡可以使用双协议栈或使用隧道技术。</p><p><strong>地址解析协议 ARP</strong></p><p>由于 IP 协议使用了 ARP 协议，因此把 ARP 协议归到网络层，但 ARP 的作用是通过一个 ARP 高速缓存存储本地局域网的各主机和路由器的 IP 地址到硬件地址的映射表，以从网络层的 IP 地址解析出在数据链路层使用的硬件地址，因此也可以把 ARP 划归在数据链路层。与 ARP 对应的协议是 RARP，逆地址解析协议，作用是使只知道自己硬件地址的主机能够找出 IP 地址，但被 DHCP 协议取代。</p><p><strong>路由选择协议 RIP/OSPF/BGP-4</strong></p><p>路由选择协议有两大类：内部网关协议，如 RIP 和 OSPF；外部网关协议，如 BGP-4。</p><p>RIP 是分布式的基于距离向量的路由选择协议，只适用于小型互联网。RIP 按照固定的时间间隔与相邻路由器交换信息，交换的信息是当前路由表。OSPF 是分布式的链路状态协议，适用于大型互联网，只在链路状态发生变化时才向本自治系统中的所有路由器用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。</p><p>BGP-4 是不同自治系统的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。其目标是寻找一条能够到达目的网络且比较好的路由而不是最佳路由。</p><p><strong>网际控制报文协议 ICMP</strong></p><p>ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去，<strong>使用 ICMP 并非为了实现可靠传输</strong>，ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p><p>ICMP 的一个重要应用就是分组间探测 PING，用来测试两台主机之间的连通性，PING 使用了 ICMP 回送请求与回送回答报文。</p><p><strong>Ping</strong></p><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。应答数据包的类型字段为 0，构建新的ICMP数据包，发回给主机A，此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p><strong>Traceroute</strong><br>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文</p><ul><li><p>Traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。将TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了。如果中间的路由器不止一个，当然碰到第一个就“牺牲”。于是，返回一个 ICMP 包，也就是网络差错包，类型是时间超时。接下来，将 TTL 设置为2.。。这样，Traceroute 就拿到了所有的路由器 IP。怎么知道 UDP 有没有到达目的主机呢？Traceroute 程序会发送一份 UDP 数据报给目的主机，但它会选择一个不可能的值作为 UDP 端口号（大于 30000）。当该数据报到达时，将使目的主机的 UDP 模块产生一份“端口不可达”错误 ICMP 报文。如果数据报没有到达，则可能是超时</p></li><li><p>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。要做的工作首先是发送分组，并设置“不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包.</p></li></ul><p><strong>网际组管理协议 IGMP</strong></p><p>IP 多播使用 IGMP 协议，IGMP 并非在互联网范围内对所有多播组成员进行管理，它不知道 IP 多播组包含的成员个数也不知道这些成员都分布在哪些网络上。</p><p>IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机上的某个进程参加或推出了某个多播组。</p><hr><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>数据链路层的任务是<strong>将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻结点之间的链路上传输帧，每一帧包括数据和必要的控制信息（同步信息、地址信息、差错控制等）。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始到哪个比特结束，这样链路层就可以从帧中提取出数据部分上交给网络层。控制信息还使接收端能够检测到所收到的帧有无差错，如果有差错就简单地丢弃这个帧以免继续传送而浪费网络资源。</p><p>数据链路层的协议包括了点对点协议 PPP 和 CSMA/CD 协议等。</p><p><strong>点对点协议 PPP</strong></p><p>在通信线路质量较差的年代，使用高级数据链路控制 HDLC 作为实现可靠传输的数据链路层协议，但现在 HDLC 已经很少使用了，对于点对点的链路，简单得多的点对点协议 PPP 是目前使用得最广泛的数据链路层协议。PPP 协议的特点是简单、只检测差错而不纠正差错、不使用序号也不进行流量控制、可同时支持多种网络层协议。</p><p><strong>CSMA/CD 协议</strong></p><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><p>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</p></li><li><p>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</p></li><li><p>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</p></li></ul><p>记端到端的传播时延为 t，最先发送的站点最多经过 2t就可以知道是否发生了碰撞，称 2t 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2^k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><hr><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层的任务是尽可能地<strong>屏蔽掉传输媒体和通信手段的差异</strong>，使物理层上面的数据链路层感觉不到这些差异，使其只需考虑本层的协议和服务。</p><p>物理层所传输的数据单位是比特，发送方发送 1 或 0，接收方也接收 1 或 0，因此物理层需要考虑用多大的电压代表 1 或 0，以及接收方如何识别出发送方所发送的比特。除此之外，物理层还要确定连接电缆的插头应当有多少根引以及各引脚如何连接等问题。</p><hr><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题</p><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>建立及管理会话。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP-特点"><a href="#TCP-特点" class="headerlink" title="TCP 特点"></a>TCP 特点</h3><p><strong>TCP 是面向连接的运输层协议</strong>，一个应用进程在向另一个进程发送数据之前，两个进程必须先建立 TCP 连接，发送某些预备报文段，建立确保数据传输的参数。作为 TCP 连接建立的一部分，连接双方都将初始化与 TCP 连接相关的许多状态变量。这种连接不是电路交换网络中的端到端电路这种物理连接，而是一种逻辑连接，TCP 报文要先传送到 IP 层加上 IP 首部后，再传到数据链路层，加上链路层的首部和尾部后才离开主机发送到物理层。</p><p><strong>TCP 连接提供全双工服务</strong>，允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都有各自的发送缓存和接收缓存，用来临时存放通信数据。在发送时，应用程序把数据传送给 TCP 缓存后就可以做自己的事，而 TCP 在合适的时候会把数据发送出去。在接收时，TCP 把收到的数据放入缓存，上层应用程序会在合适的时候读取缓存数据。</p><p><strong>TCP 连接是点对点的</strong>，每一条 TCP 连接只能有两个端点，即只能是单个发送方和单个接收方之间的连接。</p><p><strong>TCP 提供可靠的交付服务</strong>，通过 TCP 连接传送的数据无差错、不丢失、不重复，按序到达。</p><p><strong>TCP 是面向字节流的</strong>，流是指流入到进程或从进程中流出的字节序列。面向字节流的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但是 TCP 把应用程序交下来的数据仅仅看成一连串无结构的字节流。TCP 不保证接收方应用程序收到的数据块和发送方应用程序发出的数据块具有对应大小的关系，但是接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。接收方应用程序必须有能力识别收到的字节流，并把它还原成有意义的应用层数据。</p><hr><h3 id="TCP-报文结构"><a href="#TCP-报文结构" class="headerlink" title="TCP 报文结构"></a>TCP 报文结构</h3><p><img src="https://uploadfiles.nowcoder.com/files/20200810/176673786_1597021487780_27194088468_4cb0141fc8_b.jpg" alt="img"></p><p>TCP 传送的数据单元是报文段，一个 TCP 报文段分为首部和数据两部分。首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项，因此 TCP 首部的最小长度是 20 字节.TCP 首部的重要字段如下：</p><p><strong>源端口和目的端口：</strong>各占 2 字节，分别写入源端口号和目的端口号，TCP 的分用功能是通过端口实现的，分用就是指运输层从 IP 层收到发送给各应用进程的数据后，把数据交付给正确的套接字的工作。</p><p><strong>序号：</strong>占 4 字节。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号，首部中的序号字段值指的是本报文段所发送的数据的第一个字节的序号。序号使用 mod2^32^ 计算，每增加到 2^31^-1 后下一个序号就又回到 0。</p><p><strong>确认号：</strong>占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。如果确认号为 N，代表到序号 N-1 为止的所有数据已经正确收到。序号有 32 位长，一般情况下可以保证当序号重复使用时，旧序号的数据早已通过网络到达终点了。</p><p><strong>数据偏移：</strong>占 4 字节，实际是TCP 报文段的首部长度，指出了 TCP 报文段的数据起始处到 TCP 报文段的起始处的距离。由于首部中有长度不确定的选项字段，因此数据偏移字段是必要的。</p><p><strong>标志字段：</strong>占 6 位。URG 是紧急标志，URG=1 时告诉系统此报文段中有紧急数据，应尽快传送，而不按照原来的排队顺序传送，和紧急指针配合使用，紧急指针指出了本报文段中紧急数据的字节数和位置。ACK 是确认标志，ACK=1 时表示成功接收了报文段。SYN 是同步标志，在建立连接时用来同步序号，当 SYN=1 而 ACK=0 时，表示一个连接请求报文段，响应时 SYN 和 ACK 都为 1，因此 SYN=1 表示一个连接请求或连接响应报文。FIN 是终止标志，用来释放一个连接，当 FIN=1 时表示报文段发送方的数据已发送完毕，并要求释放连接。PSH 是推送标志，PSH=1 时接收方就不等待整个缓存填满了再向上交付而是尽快交付数据。RST 是复位标志，当 RST=1 时表示 TCP 连接出现了严重错误，必须释放连接再重新建立连接。</p><p><strong>接收窗口：</strong>占 2 字节，指的是发送本报文段一方的接收窗口，告诉对方从本报文首部的确认号算起允许对方发送的数据量。窗口值是用来限制发送方的发送窗口的，因为接收方的数据缓存空间是有限的。</p><p><strong>检验和：</strong>占 2 字节，检验范围包括首部和数据两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p><hr><h3 id="可靠传输协议-ARQ"><a href="#可靠传输协议-ARQ" class="headerlink" title="可靠传输协议 ARQ"></a>可靠传输协议 ARQ</h3><p>自动重传请求 ARQ 包括了停止等待协议、回退 N 步协议和选择重传协议，后两种结合了窗口机制，属于连续 ARQ 协议。</p><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>停止等待就是每发送完一个分组就停止发送，等待对方的确认，在收到确认之后再发送下一个分组。停止等待协议包括了三种情况：</p><p><strong>1. 无差错情况</strong></p><p>A 发送分组 M<del>1</del>，发送完后就暂停并等待 B 的确认。B 收到了 M<del>1</del> 之后就向 A 发送确认，当 A 收到确认之后就再发送下一个分组 M<del>2</del>。</p><p><strong>2. 出现差错的情况</strong></p><p>当 B 收到 M<del>1</del> 时检测出了差错就丢弃了 M<del>1</del>，其他什么也不做，也可能是 M<del>1</del> 在传输过程中丢失了，B 什么都不知道。在这两种情况下 B 都不会发送任何确认信息，解决方法是：A 只要超过一段时间没有收到确认就认为刚才发送的分组丢失了，因而重传前面发过的分组，这就叫<strong>超时重传</strong>。要实现超时重传，就要在每发送完一个分组时设置一个<strong>超时计时器</strong>，如果在超时计时器到期之间收到了对方的确认就进行撤销。</p><p>有三点需要注意：① A 在发送完一个分组后必须暂时保留已发送分组的副本在超时重传时使用，只有在收到确认后才清除副本。② 分组和确认分组都必须进行编号，这样才能明确是哪一个发送出去的分组进行了确认。③ 超时计时器设置的时间应当比数据在分组传输的平均往返时间稍长一些，如果设置过短会产生不必要的重传，如果设置过长会降低通信效率。</p><p><strong>3. 确认丢失和确认迟到</strong></p><p>B 发送的对 M<del>1</del> 的确认丢失了，A 在设定的超时重传时间内没有收到确认，并不知道是自己发送的问题还是 B 的问题，因此 A 就会超时重传。假设 B 又收到了重传分组 M<del>1</del>，此时 B 会采取两个行动：① 丢弃这个分组，不向上层交付。② 重新向 A 发送确认。</p><p>还有另一种情况就是 B 发送的确认并没有丢失但是迟到了，A 会受到重复的确认，此时 A 会收下并丢弃。通常 A 最终总是可以收到对所有发出的分组的确认，如果 A 不断重传分组但总是收不到确认，就说明通信线路质量太差，不能进行通信。</p><p>停止等待协议的优点是简单，但缺点是信道利用率太低。为了提高传输效率，发送方可以不使用停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发送完一个分组就停下来等待对方的确认。这样可以使信道上一直有数据不间断地传送，流水线传输中可能会遇到差错，解决差错的两种基本方法是回退 N 步和选择重传。</p><hr><h4 id="回退-N-步协议"><a href="#回退-N-步协议" class="headerlink" title="回退 N 步协议"></a>回退 N 步协议</h4><p>在回退 N 步即 GBN 协议中，允许发送方发送多个分组而不需要等待确认。在 GBN 中发送方看到的序号可以分为四个范围，已经发送且被确认的的序号、已经发送还未确认的序号、允许发送但还未发送的序号和不允许发送的序号。其中已经发送但还未确认的序号和允许发送但还未发送的序号可以被看作一个长度为 N 的窗口，随着协议的运行该窗口在序号空间向前滑动，因此 GBN 协议也被称为滑动窗口协议。</p><p>GBN 发送方必须响应三种类型的事件：</p><ul><li><p><strong>上层的调用</strong></p><p>当上层调用发送方法时，发送方首先检查发送窗口是否已满，即是否有 N 个已发送但未确认的分组。如果窗口未满，则产生一个分组并将其发送并更新相应变量，如果窗口已满，发送方指需将数据返回给上层，隐式说明该窗口已满。实际实现中，发送方更可能缓存而不是立即发送这些数据，或者使用同步机制允许上层在仅当窗口不满时才调用发送方法。</p></li><li><p><strong>收到一个 ACK</strong></p><p>在 GBN 协议中，对序号为 n 的分组确认采用累积确认的方式，对按序到达的最后一个分组发送确认，表明接收方已经正确接收到序号为 n 的以前且包括 n 在内的所有分组。例如发送了序号为 1~5 的五个分组，除了第三个全部收到了，那么确认序号就是 2。</p></li><li><p><strong>超时事件</strong></p><p>回退 N 步的名字来源于出现丢失和时延过长时发送方的行为，就像在停止等待协议中那样，如果超时，发送方会重传所有已经发送但还未确认过的分组。如果收到一个 ACK，但仍有已发送但未确认的分组，则计时器也会重新启动。</p></li></ul><p>在 GBN 协议中，接收方丢弃所有失序分组，即使是正确接收的也要丢弃，这样做的理由是接收方必须按序将数据交付给上层。这种做法的优点是接收缓存简单，即接收方不需要缓存任何失序分组。不过丢弃一个正确失序分组的缺点是随后对该分组的重传也许也会错误，而导致更多的重传。</p><hr><h4 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h4><p>GBN 协议潜在地允许用多个分组填充流水线，因此避免了停止等待协议中的信道利用问题，但是 GBN 本身也存在性能问题，单个分组的差错就能引起 GBN 重传大量分组，许多分组根本没有重传必要。随着信道差错率的增加，流水线会被不必要重传的分组所充斥。</p><p>选择重传即 SR 协议，通过让发送方仅重传那些它怀疑在接收方出错的分组而避免不必要的重传。这种个别的、按需重传，要求接收方逐个确认正确接收的分组，再次用窗口长度 N 来限制流水线中未完成和未被确认的分组数。与 GBN 不同的是，发送方已经收到了窗口中对某些分组的 ACK。</p><p>接收方将确认一个正确接收的分组，不管是否按序。失序分组将被缓存直到所有丢失分组都收到，这时才可以将一批分组按序交付上层。</p><hr><h3 id="TCP-可靠原理"><a href="#TCP-可靠原理" class="headerlink" title="TCP 可靠原理"></a>TCP 可靠原理</h3><p>TCP 的可靠传输包含很多机制，例如使用<strong>检验和</strong>来检测一个传输分组中的比特错误、使用<strong>定时器</strong>来用于超时重传一个分组、使用<strong>序号</strong>来检测丢失的分组和冗余副本、使用<strong>确认</strong>来告诉发送方确认的分组信息、使用<strong>否定确认</strong>来告诉发送方某个分组未被正确接收。</p><p>TCP 的发送方仅需维持已发送过但未被确认的字节的最小序号和下一个要发送的字节的序号，从这种角度看 TCP 更像一个 GBN 协议。但是 TCP 和 GBN 有一些显著的区别，许多 TCP 实现会将正确接收但失序的报文段缓存起来。当分组 n 丢失时，GBN 会重传 n 之后的所有分组，但是 TCP 至多只会重传分组 n。对 TCP 提出的一种修改意见是选择确认，它允许 TCP 接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段，从这个角度看 TCP 又像 SR 协议。<strong>因此 TCP 的差错恢复机制是一种 GBN 和 SR  的结合体</strong>。</p><p>除此之外，TCP 还使用<strong>流量控制</strong>和<strong>拥塞控制</strong>来保证可靠性。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>滑动窗口以字节为单位。发送端有一个发送窗口，窗口中的序号是允许发送的序号，窗口的后沿是已经发送并且确认的序号，窗口的前沿是不允许发送的序号。窗口的后沿可能不动（代表没有收到新的确认），也有可能前移（代表收到了新的确认），但是不会后移（不可能撤销已经确认的数据）。窗口的前沿一般是向前的，也有可能不动（表示没有收到新的请求或对方的接收窗口变小），也有可能收缩，但 TCP 强烈不建议这么做，因为发送端在收到通知前可能已经发送了很多数据，此时如果收缩窗口可能会产生错误。</p><p>滑动窗口的状态需要3个指针p1，p2 和 p3。p1 之前的序号表示已经发送并且确认的序号，p1<del>p2 的序号表示已经发送但还没有确认的序号，p2</del>p3 表示允许发送的序号，也叫可用窗口，p1~p3 表示发送窗口，p3 之后的序号表示不可发送的序号。</p><p>发送缓存用来暂时存放发送应用程序传给发送方 TCP 准备发送的数据和已经发送但还没确认的数据。接收缓存用来暂时存放按序到达的但尚未被应用程序读取的数据以及未按序到达的数据。</p><p>注意三点：① 发送窗口根据接收窗口设置，但并不总是一样大，还要根据网络的拥塞情况调整。② 对于不按序到达的数据，TCP 通常存放在接收窗口，等到字节流缺少的字节收到后再按序交付上层应用程序。③ 接收方必须有累积确认功能，可以减小传输开销，可以在合适的时候发送确认，也可以在自己有数据需要发送时捎带确认。但是接收方不能过分推迟发送确认，不能超过0.5秒。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>如果某个应用程序读取数据的速度较慢，而发送方发送得太多、太快，发送的数据就会很容易使连接的接收缓存溢出，TCP 为它的应用程序提供了流量控制以消除发送方使接收方缓存溢出的可能性。流量控制是一个速度匹配服务，即发送方的发送速率与接收方的应用程序读取速率相匹配。</p><p>TCP 通过让<strong>发送方维护一个接收窗口的变量</strong>来提供流量控制。通俗地说，接收窗口用于给发送方一个指示，该接收方还有多少可用的缓存空间，因此方法方的发送窗口不能超过接收方给出的接收窗口的数值。因为 TCP 是全双工通信，在连接两端的发送方都各自维护一个接收窗口。</p><p>当接收窗口 rwnd 减小到 0 时，就不再允许发送方发送数据了。但是可能存在一种情况，当发生了零窗口报文段不久后，发送方的接收缓存又有了一些存储空间，因此又发生了新的报文说明自己的接收窗口大小，但是这个报文可能会在传输过程中丢失。接收方就会一直等待发送方的非零窗口通知，而发送方也一直在等待接收方发送数组，形成一种死锁的状态。为了解决这个问题，TCP 为每一个连接设有一个持续计时器，只要 TCP 连接的一方收到对方的零窗口通知就启动该计时器，到期后发送一个零窗口探测报文，如果仍为 0 就重新设置计时器的时间，如果对方给出了新的窗口值就可以解决可能出现的死锁问题。</p><p>还有一种问题叫做<strong>糊涂窗口综合症</strong>，当接收方处理接收缓冲区数据很慢时，就会使应用进程间传送的有效数据很小， 极端情况下有效数据可能只有 1 字节但传输开销却有 40 字节（20字节的 IP 头以及 20 字节的 TCP 头) ，导致网络效率极低。为了解决这个问题，可以让接收方等待一段时间，使得接收缓存有足够的空间容纳一个最长报文段或者等到接收缓存已有一半的空闲空间。发送方也不要发送太小的报文，而是把数据积累成足够大的报文或达到接收方缓存空间的一半时才发送。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>网络中对资源需求超过了资源可用量的情况就叫做拥塞。当吞吐量明显小于理想的吞吐量时就出现了轻度拥塞，当吞吐量随着负载的增加反而下降时，网络就进入了拥塞状态。当吞吐量降为 0 时，网络已无法正常工作并陷入死锁状态。拥塞控制就是尽量减少注入网络的数据，减轻网络中的路由器和链路的负担。<strong>拥塞控制是一个全局性的问题，它涉及网络中的所有路由器和主机，而流量控制只是一个端到端的问题，是两个端点之间通信量的控制。</strong></p><p>根据网络层是否为运输层拥塞控制提供显式帮助可以将拥塞控制的方法区分为两种：端到端拥塞控制和网络辅助的拥塞控制。TCP 使用端到端的拥塞控制，因为 IP 层不会向端系统提供显式的网络拥塞反馈。TCP 所采取的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其向连接发送数据的速率。如果一个 TCP 发送方感知到它到目的地之间的路径上没什么拥塞则会增加发送速率，如果发送方感知到拥塞就会降低其发送速率。限制发送速率是通过拥塞窗口来实现的，它对发送方能向网络中发送流量的速率进行了限制。判断拥塞是通过超时或者连续接收到 3 个冗余 ACK 实现的。</p><p>TCP 的拥塞控制算法主要包括了慢启动、拥塞避免和快恢复。慢启动和拥塞避免是 TCP 的强制部分，差异在于对收到的 ACK 做出反应时 cwnd 增加的方式，慢启动比拥塞避免要更快地增加 cwnd 的长度。快恢复是推荐部分，对 TCP 发送方不是必需的。</p><p><strong>1. 慢启动</strong></p><p>在慢启动状态，拥塞窗口 cwnd 的值以一个 MSS 最大报文段开始并且每当传输的报文段首次被确认就增加一个 MSS。因此每经过一个 RTT 往返时间，拥塞窗口就会翻倍，发送速率也会翻倍。因此 TCP 的发送速率起始很慢，但是在慢启动阶段以指数增长。</p><p>结束慢启动有三种情况：① 如果存在一个超时指示的丢包事件，即发生了拥塞，TCP 发送方就会将 cwnd 设置为 1 并重新开始慢启动过程。它还将慢启动阈值设置为 cwnd/2，即检测到拥塞时将慢启动阈值设置为拥塞窗口的一半。② 当拥塞窗口达到慢启动阈值时就会结束慢启动而进入拥塞避免模式。③ 最后一种结束慢启动的方式是，如果检测到三个冗余的 ACK，TCP 就会执行快重传并进入快恢复状态。</p><p><strong>2. 拥塞避免</strong></p><p>一旦进入拥塞避免状态，cwnd 的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远。因此 TCP 无法再每经过一个 RTT 就将 cwnd 的值翻倍，而是采用一种较为保守的方法，每个 RTT 后只将 cwnd 的值增加一个 MSS。这能够以几种方式完成，一种通用的方法是发送方无论何时收到一个新的确认，都将 cwnd 增加一个 MSS。</p><p>当出现超时时，TCP 的拥塞避免和慢启动一样，cwnd 的值将被设置为 1，并且将慢启动阈值设置为 cwnd 的一半。</p><p><strong>3. 快恢复</strong></p><p>有时候个报文段丢失，而网络中并没有出现拥塞，如果使用慢启动算法就会降低传输效率。这时应该使用快重传来让发送方尽早知道出现了个别分组的丢失，快重传要求接收端不要等待自己发送数据时再捎带确认，而是要立即发送确认。即使收到了乱序的报文段后也要立即发出对已收到报文段的重复确认。当发送方连续收到三个冗余 ACK 后就知道出现了报文段丢失的情况，会立即重传并进入快恢复状态。</p><p>在快恢复中，会调整慢启动阈值为 cwnd 的一半，并进入拥塞避免状态。</p><hr><h3 id="TCP-连接和释放机制"><a href="#TCP-连接和释放机制" class="headerlink" title="TCP 连接和释放机制"></a>TCP 连接和释放机制</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>TCP 是全双工通信，任何一方都可以发起建立连接的请求，假设 A 是客户端，B 是服务器。</p><p>初始 A 和 B 均处于 CLOSED 状态，B 会创建传输进程控制块 TCB 并进入 LISTEND 状态，监听端口是否收到了 TCP 请求以便及时响应。</p><p>当 A 要发生数据时就向 B 发送一个连接请求报文，TCP 规定连接请求报文的 SYN=1，ACK=0，SYN 不可以携带数据，但要消耗一个序号，假设此时 A 发送的序号 seq 为 x。发送完之后 A 就进入了 SYN-SENT 同步已发送状态。</p><p>当 B 收到 A 的连接请求报文后，如果同意建立连接就会发送给 A 一个确认连接请求报文，其中 SYN=1，ACK=1，ack=x+1，seq=y，ack 的值为 A 发送的序号加 1，ACK 可以携带数据，如果不携带的话则不消耗序号。发送完之后，B进入 SYN-RCVD 同步已接收状态。</p><p>当 A 收到 B 的确认连接请求报文后，还要对该确认再进行一次确认，报文的 ACK=1，ack=y+1，seq=x+1，发送后 A 进入 ESTABLISHED 状态，当 B 接收到该报文后也进入 ESTABLISHED 状态，客户端会稍早于服务器端建立连接。</p><p><strong>三次握手的原因主要有两个目的，信息对等和防止超时。</strong></p><p>从信息对等的角度看，双方只有确定 4 类信息才能建立连接，即 A 和 B 分别确认自己和对方的发送和接收能力正常。在第二次握手后，从 B 的角度看还不能确定自己的发送能力和对方的接收能力，只有在第三次握手后才能确认。</p><p>三次握手也是防止失效连接突然到达导致脏连接，网络报文的生存时间往往会超过 TCP 请求超时时间，A 的某个超时连接请求可能会在双方释放连接之后到达 B，B 会误以为是 A 创建了新的连接请求，然后发送确认报文创建连接。因为 A 机器的状态不是 SYN_SENT，所以直接丢弃了 B 的确认数据。如果是两次握手，连接已经建立了，服务器资源被白白浪费。如果是三次握手，B 由于长时间没有收到确认信息，最终超时导致创建连接失败，因此不会出现脏连接。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当 A 已经没有要发送的数据时就会释放连接，会向 B 发送一个终止连接报文，其中 FIN=1，seq=u，u 的值为之前 A 发送的最后一个序号+1。发送完之后进入 FIN-WAIT-1 状态。</p><p>B 收到该报文后，发送给 A 一个确认报文，ACK=1，ack=u+1，seq=v，v 的值为 B 之前发送的最后一个序号+1。此时 A 进入了FIN-WAIT-2 状态，B 进入了 CLOSE-WAIT 状态，但连接并未完全释放，B 会通知高层的应用层结束 A 到 B 方向的连接，此时 TCP 处于半关闭状态。</p><p>当 B 发送完数据后准备释放连接时，就向 A 发送连接终止报文，FIN=1，同时还要重发ACK=1，ack=u+1，seq=w，seq 不是 v 的原因是在半关闭状态 B 可能又发送了一些数据，之后 B 进入 LAST-ACK 状态。</p><p>A 收到连接终止报文后还要再进行一次确认，确认报文中 ACK=1，ack=w+1，seq=u+1。发送完之后进入 TIME-WAIT 状态，等待 2MSL之后进入 CLOSED 状态，B 收到该确认后进入 CLOSED 状态，服务器端会稍早于客户端释放连接。</p><p><strong>四次挥手的原因</strong></p><p>tcp是全双工通信，服务端和客服端都能发送和接收数据。</p><p>tcp在断开连接时，需要服务端和客服端都确定对方将不再发送数据。</p><p><strong>第1次挥手</strong></p><p>由客户端向服务端发起，服务端收到信息后就能确定客户端已经停止发送数据。</p><p><strong>第2次挥手</strong></p><p>由服务端向客户端发起，客户端收到消息后就能确定服务端已经知道客户端不会再发送数据。</p><p><strong>第3次握手</strong></p><p>由服务端向客户端发起，客户端收到消息后就能确定服务端已经停止发送数据。</p><p><strong>第4次挥手</strong></p><p>由客户端向服务端发起，服务端收到信息后就能确定客户端已经知道服务端不会再发送数据。</p><p><strong>为什么不是3次挥手</strong></p><p>在客服端第1次挥手时，服务端可能还在发送数据。</p><p>所以第2次挥手和第3次挥手不能合并。</p><p><strong>大量 TIME-WAIT 的原因、导致的问题、处理</strong></p><p>在高并发短连接的 TCP 服务器上，服务器处理完请求后立刻主动正常关闭连接，这个场景下会出现大量 socket 处于 TIME-WAIT 状态。</p><p>TIME-WAIT 状态无法真正释放句柄资源，socket 使用的本地端口在默认情况下不能再被使用，会限制有效连接数量，成为性能瓶颈。</p><p>可以调小 tcp_fin_timeout 的值，将 tcp_tw_reuse 设为 1 开启重用，将 tcp_tw_recycle 设为 1 表示开启快速回收。</p><hr><h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><p>TCP 是面向连接的，而 UDP 是无连接的，发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。</p><p>TCP 保证数据的可靠传输，UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态。</p><p>TCP 是面向字节流的，UDP 是面向报文的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文既不拆分也不合并，而是保留这些报文的边界。如果报文太长，IP 层在传送时可能需要分片，如果报文太短，会使 IP 数据报首部的相对长度太大，都会降低 IP 层的效率。</p><p>TCP 有拥塞控制，UDP 没有拥塞控制，因此网络中出现的拥塞不会降低源主机的发送速率。这对某些实时应用很重要，很多实时应用如 IP 电话、实时视频会议等要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许网络有太大的时延，UDP 正好适合这种要求。</p><p>TCP 是点到点之间的一对一通信，UDP 支持一对一、一对多和多对多的交互通信。</p><p>UDP 的首部开销很小，只有 8 字节，相比 TCP 的 20 字节要短。</p><h3 id="TCP和UDP的传送信息单位的区别？"><a href="#TCP和UDP的传送信息单位的区别？" class="headerlink" title="TCP和UDP的传送信息单位的区别？"></a>TCP和UDP的传送信息单位的区别？</h3><p>16位源端口号+16位目的端口号+32位序号+32位确认号+4位头部长度（单位4字节）+6位保留+6个关键字（SYN,ACK，FIN）+16位窗口大小（指接收窗口）+16位校验和+16位紧急指针+最多40字节的选项；</p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。</p><h3 id="TCP三次握手后，客户端网线断掉了，服务端会不会检测得到？还有，如果客户端此时再插上网线，还需要进行三次握手吗？"><a href="#TCP三次握手后，客户端网线断掉了，服务端会不会检测得到？还有，如果客户端此时再插上网线，还需要进行三次握手吗？" class="headerlink" title="TCP三次握手后，客户端网线断掉了，服务端会不会检测得到？还有，如果客户端此时再插上网线，还需要进行三次握手吗？"></a>TCP三次握手后，客户端网线断掉了，服务端会不会检测得到？还有，如果客户端此时再插上网线，还需要进行三次握手吗？</h3><p>短时间不会的，具体可以参考tcp的保活机制，隔一段时间发一个保活探测报文，超过保活探测次数连接就会关闭，</p><h3 id="如果四次挥手中的第二次挥手后，服务端又收到了客户端发来的数据，那么服务端会做什么？"><a href="#如果四次挥手中的第二次挥手后，服务端又收到了客户端发来的数据，那么服务端会做什么？" class="headerlink" title="如果四次挥手中的第二次挥手后，服务端又收到了客户端发来的数据，那么服务端会做什么？"></a>如果四次挥手中的第二次挥手后，服务端又收到了客户端发来的数据，那么服务端会做什么？</h3><h3 id="为什么三次握手，返回时，ack-值是-seq-加-1"><a href="#为什么三次握手，返回时，ack-值是-seq-加-1" class="headerlink" title="为什么三次握手，返回时，ack 值是 seq 加 1?"></a>为什么三次握手，返回时，ack 值是 seq 加 1?</h3><p>假设对方接收到数据，比如sequence number = 1000，TCP Payload = 1000，数据第一个字节编号为1000，最后一个为1999，<strong>回应一个确认报文，确认号为2000，意味着编号2000前的字节接收完成，准备接收编号为2000及更多的数据</strong> </p><p>确认收到的序列，并且告诉发送端下一次发送的序列号从哪里开始（便于接收方对数据<a href>排序</a>，便于选择重传）</p><h3 id="大量TIME-WAIT"><a href="#大量TIME-WAIT" class="headerlink" title="大量TIME_WAIT?"></a>大量TIME_WAIT?</h3><ol><li>作为服务器，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，<strong>占据大量的tuple /tApl/ ，严重消耗着服务器的资源</strong>，此时部分客户端就会显示连接不上 </li><li>作为客户端，短时间内大量的短连接，会大量消耗的Client机器的端口，毕竟端口只有65535个，端口被耗尽了，后续就无法在发起新的连接了 </li></ol><p>解决方法：  </p><ul><li><p>用负载均衡来抗这些高并发的短请求； </p></li><li><p>服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，TIME_WAIT 状态可以通过优化服务器参数得到解决，因为发生TIME_WAIT的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的 </p></li><li><p>强制关闭，发送 RST 包越过TIMEWAIT状态，直接进入CLOSED状态</p></li><li><p>调整参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1</span><br><span class="line">表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 1</span><br><span class="line">表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class="line"></span><br><span class="line">系统tcp_timestamps缺省就是开启的，所以当tcp_tw_recycle被开启后，实际上这种行为就被激活了.如果服务器身处NAT环境，安全起见，通常要禁止tcp_tw_recycle，至于TIME_WAIT连接过多的问题，可以通过激活tcp_tw_reuse来缓解。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_syn_backlog &#x3D; 8192</span><br><span class="line">表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</span><br></pre></td></tr></table></figure></li></ul><h3 id="大量CLose-Wait"><a href="#大量CLose-Wait" class="headerlink" title="大量CLose-Wait?"></a>大量CLose-Wait?</h3><p>通常，CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的 CLOSE_WAIT 状态，那么就意味着被动关闭的一方没有及时发出 FIN 包，一般有如下几种可能：</p><ul><li>程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。</li><li>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。</li></ul><h3 id="TCP粘包？"><a href="#TCP粘包？" class="headerlink" title="TCP粘包？"></a>TCP粘包？</h3><p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>原因可能是发送方也可能是接收方造成的。</p><p>发送方原因：TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</p><p>接收方原因：TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。</p><h4 id="处理方法："><a href="#处理方法：" class="headerlink" title="处理方法："></a>处理方法：</h4><p> 最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：</p><ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。 </li><li>包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。 </li><li>包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。</li></ul><hr><h3 id="三次握手最后一次丢失"><a href="#三次握手最后一次丢失" class="headerlink" title="三次握手最后一次丢失"></a>三次握手最后一次丢失</h3><p>如果最后一次ACK在网络中丢失，那么<strong>Server端（服务端）该TCP连接的状态仍为SYN_RECV</strong>，并且<strong>根据 TCP的超时重传机制依次等待3秒、6秒、12秒后重新发送 SYN+ACK 包</strong>，以便 <strong>Client重新发送ACK包</strong> </p><p><strong>如果重发指定次数后，仍然未收到ACK应答</strong>，那么一段时间后，<strong>Server（服务端）自动关闭这个连接</strong> </p><p><strong>但是Client（<a href>客户端</a>）认为这个连接已经建立</strong>，如果Client向Server（服务端）发送数据，<strong>Server端（服务端）将以RST包（Reset，标示复位，用于异常的关闭连接）响应</strong>，此时，<strong><a href>客户端</a>知道第三次握手失败</strong></p><h3 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><ul><li>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把<strong>ACK和SYN放在一个报文里</strong>发送给<a href>客户端</a>。 </li><li>关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了,所以服务器可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接。因此，服务器<strong>ACK和FIN一般都会分开发送</strong>，从而导致多了一次</li></ul><h3 id="为什么TCP挥手每两次中间有一个-FIN-WAIT2等待时间？"><a href="#为什么TCP挥手每两次中间有一个-FIN-WAIT2等待时间？" class="headerlink" title="为什么TCP挥手每两次中间有一个 FIN-WAIT2等待时间？"></a>为什么TCP挥手每两次中间有一个 FIN-WAIT2等待时间？</h3><ul><li>主动关闭的一端调用完close以后（即发FIN给被动关闭的一端， 并且收到其对FIN的确认ACK）则进入FIN_WAIT_2状态。<strong>如果这个时候因为网络突然断掉、被动关闭的一段宕机等原因，导致主动关闭的一端不能收到被动关闭的一端发来的FIN（防止对端不发送关闭连接的FIN包给本端）</strong>，这个时候就需要FIN_WAIT_2定时器， 如果在该定时器超时的时候，还是没收到被动关闭一端发来的FIN，那么直接释放这个链接，进入CLOSE状态</li></ul><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p><img src="https://uploadfiles.nowcoder.com/files/20200810/176673786_1597021488550_u16143127921954581760fm26gp0.jpg" alt="img"></p><p><strong>4位版本</strong>：</p><p> 目前协议版本号是4，因此IP有时也称作IPV4.</p><p> <strong>4位首部长度</strong>：</p><p> 首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。</p><p> <strong>服务类型（TOS）</strong>：</p><p> 服务类型字段包括一个3bit的优先权字段（现在已经被忽略），4bit的TOS子字段和1bit未用位必须置0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。</p><p> <strong>总长度</strong>：</p><p> 总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16bit，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。</p><p> <strong>标识字段</strong>：</p><p> 标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</p><p> <strong>生存时间</strong>：</p><p> TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为 3 2或6 4），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0时，数据报就被丢弃，并发送 ICMP 报文通知源主机。</p><p> <strong>首部检验和</strong>：</p><p> 首部检验和字段是根据 I P首部计算的检验和码。它不对首部后面的数据进行计算。 ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP-概况"><a href="#HTTP-概况" class="headerlink" title="HTTP 概况"></a>HTTP 概况</h3><p>HTTP 即超文本传输协议，是 Web 的应用层协议。HTTP 由两个程序实现，一个客户程序和一个服务器程序，客户程序和服务器程序运行在不同的端系统中，通过交换 HTTP 报文进行会话。HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式，当用户请求一个 Web 页面时，浏览器向服务器发出对该页面中所包含对象的 HTTP 请求报文，服务器接收到请求并用包含这些对象的 HTTP 响应报文进行响应。</p><p><strong>HTTP 使用 TCP 作为它的支撑运输协议</strong>，HTTP 客户首先发起一个与服务器的 TCP 连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字访问 TCP。客户端的套接字接口是客户进程与 TCP 连接之间的门，服务器端的套接字接口则是服务器进程与 TCP 连接之间的门。客户向它的套接字接口发送 HTTP 请求报文并从它的套接字接口接收 HTTP 响应报文，类似的，服务器从它的套接字接口接收 HTTP 请求报文并向它的套接字接口发送 HTTP 响应报文。一旦客户向它的套接字接口发送一个 HTTP 请求报文，该报文就脱离了客户控制并进入 TCP 的控制，TCP 为 HTTP 提供可靠的数据传输服务，因此一个客户进程发出的每个 HTTP 请求报文最终都能完整地到达服务器，服务器进程发出地每个 HTTP 响应报文最终也可以完整地到达客户。这里体现了分层体系结构的优点，HTTP 协议不需要担心数据丢失，也不需要关注 TCP 从网络的数据丢失和乱序中如何恢复。</p><p><strong>HTTP 是一种无状态的协议</strong>，服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。假如某个客户在短时间内连续两次请求同一个对象，服务器并不会因为刚刚为该客户做出了响应就不再响应，而是重新进行响应。</p><hr><h3 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h3><p>HTTP 报文有两种，分为请求报文和响应报文。</p><p><strong>请求报文</strong></p><p>HTTP 请求报文的第一行叫做请求行，其后继的行叫做首部行。请求行有三个字段，包括方法、URL 和 HTTP 版本。方法包括了 GET、POST、HEAD、PUT 和 DELETE 等。绝大部分的 HTTP 请求报文使用 GET 方法，当使用 GET 方法时，在 URL 字段中会带有请求对象的标识。</p><p>首部行指明了对象所在的主机，其实已经存在 TCP 连接了，但是还需要首部行提供主机信息，这时 Web 代理高速缓存所要求的。通过包含 <code>Connection:close</code> 的首部行，可以告诉服务器不要麻烦地使用持续连接，它要求在发送完响应后就关闭连接。<code>User-agent</code> 可以用来指明用户代理，即向服务器发送请求的浏览器类型，服务器可以有效地为不同类型的用户代理发送实际相同对象的不同版本。</p><p>在首部行之后有一个空行，后面跟着的是实体。使用 GET 方法时实体为空，而使用 POST 方法时才会使用实体。当用户提交表单时，HTTP 客户通常使用 POST 方法，使用 POST 方法时用户仍可以向服务器请求一个 Web 页面，但 Web 页面的特定内容依赖于用户在表单字段中输入的内容。如果使用 POST 方法，则实体中包含的就是用户在表单字段的输入值。表单不是必须使用 POST 方法，也可以使用 GET。</p><p>HEAD 方法类似于 GET，当服务器收到一个使用 HEAD 方法的请求时，将会用一个 HTTP 报文进行响应，但是并不返回请求对象。通常开发者使用 HEAD 方法进行调试跟踪。PUT 方法常用于上传对象到指定的 Web 服务器上指定的目录，DELETE 方法允许用户或应用程序删除 Web 服务器上的对象。</p><p><strong>响应报文</strong></p><p>响应报文包括状态行、首部行和实体。状态行有三个字段，协议版本、状态码和对应的状态信息。实体是报文的主要部分，即所请求的对象本身。</p><p>服务器通过首部行来告诉浏览器一些信息。 <code>Connection:close</code> 可以告诉客户发送完报文后将关闭该 TCP 连接。<code>Date</code> 是首部行指示服务器发送响应报文的日期和时间，这个时间不是对象创建或修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文并发送的时间。<code>Server</code> 指明了服务器的类型，类似于请求报文中的 <code>User-agent</code> 。</p><p>状态码及其相应的短语指示了请求的结果，一些常见的状态码和相关短语如下：</p><table><thead><tr><th>状态码</th><th>短语</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>成功响应</td></tr><tr><td>301</td><td>Moved Permanently</td><td>请求的对象已经被永久转移了，新的 URL 定义在响应报文的 Location 首部行，客户将自动获取新的 URL。</td></tr><tr><td>302</td><td>Found</td><td>与301类似，但资源只是临时被移动，客户端应继续使用原有 URL。</td></tr><tr><td>400</td><td>Bad Request</td><td>一个通用的差错代码，标识该请求不能被服务器理解。</td></tr><tr><td>401</td><td>Unauthorized</td><td>未认证，缺乏相关权限。</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解客户端的请求，但是拒绝执行。</td></tr><tr><td>404</td><td>Not Found</td><td>被请求的文档不在服务器上，有可能因为请求 URL 出错。</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端中请求的方法被禁止，例如限制 POST 方式但使用了 GET 访问。</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求。</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求。</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求。</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>服务器不支持请求报文使用的 HTTP 协议版本。</td></tr></tbody></table><hr><h3 id="输入一个-url-发生的事"><a href="#输入一个-url-发生的事" class="headerlink" title="输入一个 url 发生的事"></a>输入一个 url 发生的事</h3><p><strong>① 分析 url</strong></p><p>判断输入的 url 是否合法，如果不合法浏览器会使用默认的搜索引擎进行搜索。如果输入的是一个域名，默认会加上一个 http 前缀。</p><p><strong>② DNS 查询</strong></p><p>检查浏览器的 DNS 缓存，检查本地 hosts 文件的缓存，如果没有会向本地 DNS 服务器发送请求。</p><p>主机向本地 DNS 服务器发起请求是递归查询，如果找到则返回，否则会向根 DNS 查询。</p><p>根 DNS 查询是迭代查询，没有域名和 ip 的对应关系，而是告知可以查询的域名服务器地址。</p><p>本地 DNS 向得到的域名服务器发出请求，收到一个域名和 ip 关系，把结果返回给用户，并把结果保存到缓存中。</p><p><strong>③ TCP 建立连接</strong></p><p>拿到 ip 地址后，通过 TCP 的三次握手建立连接，按照协议规定的格式发送 HTTP 请求报文。</p><p><strong>④ 处理请求</strong></p><p>服务器收到 HTTP 请求报文后进行响应，主进程进行监听，创建子进程处理，先判断是否是重定向，如果是重定向则返回重定向地址。如果是静态资源则直接返回，否则通过 REST URL 在代码层面处理返回结果，最后返回 HTTP 响应报文。</p><p><strong>⑤ 接收响应</strong></p><p>浏览器收到 HTTP 响应报文后进行解析，首先查看响应报文在状态行的状态码，根据不同的状态码做不同的事，解析 HTML、CSS、JS 等文件。构建 DOM 树，渲染树，重绘，将像素发送 GPU 进行渲染，最后将渲染结果返回给用户并进行缓存。</p><p><strong>⑥ TCP 断开连接</strong></p><p>通过 TCP 的四次挥手断开连接，如果是 HTTP1.1 则会将连接保持一小段时间。</p><hr><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><strong>HTTP 存在的问题</strong></p><p>HTTP 没有密码加密，无法保证通信内容不被窃听，攻击者可以截取客户发送的数据并得到他的信息。</p><p>HTTP 没有报文完整性验证，无法确保通信内容在传输过程中不被改变，攻击者可以篡改客户通信内容。</p><p>HTTP 没有身份鉴别，无法让通信双方确认对方的身份，攻击者可以伪装成客户或者服务器。</p><p><strong>加密原理</strong></p><p>HTTPS 即 HTTP over SSL，在 HTTP 传输上增加了 SSL 安全性服务。SSL 是安全套接字层，通过采用机密性、数据完整性、服务器鉴别以及客户鉴别来强化 TCP，主要用于为发生在 HTTP 之上的事务提供安全性。SSL 会对数据进行加密并把加密数据送往 TCP 套接字，在接收方，SSL 读取 TCP 套接字中的数据并解密，然后把数据交给应用层。HTTPS 采用混合加密机制，使用非对称加密传输对称密钥来保证传输过程的安全性，之后使用对称加密进行通信来保证通信过程的效率。</p><p>HTTPS 的传输过程主要分为两部分：通过 SSL 握手建立安全的 HTTPS 通道和在安全的通道上进行数据传输，SSL 握手的步骤如下：</p><p>① 客户发送它支持的密码算法列表，以及一个客户的不重数，不重数就是在一个协议的生存期只使用一次的数。</p><p>② 服务器从该列表中选择一种对称加密算法（例如 AES），一种公钥加密算法（例如 RSA）和一种报文鉴别码算法。服务器把它的选择以及证书和一个服务器不重数返回给客户。</p><p>③ 客户通过 CA 提供的公钥验证该证书，验证成功后提取服务器的公钥，生产一个前主密钥 PMS，用服务器的公钥加密该 PMS，并将加密的 PMS 发送给服务器。</p><p>④ 客户和服务器独立地从 PMS 和不重数中计算出仅用于当前 SSL 会话的主密钥 MS，然后该 MS 被切片以生成两个密码和两个报文鉴别码密钥。自从以后，客户和服务器之间发送的所有报文均被加密和鉴别（使用报文鉴别码）。</p><p>⑤ 客户和服务器分别发送所有握手报文的一个报文鉴别码。这一步是为了使握手免受篡改危害，在第一步中客户提供的算法列表是以明文形式发送的，因此可能被攻击者截获并删除较强的算法。当客户发送一个级联它以及发送和接收的所有握手报文的报文鉴别码，服务器能够比较这个报文鉴别码和它已经接受和发送的握手报文的报文鉴别码，如果不一致就终止连接。类似的，客户也可以通过服务器发送的报文鉴别码来检查一致性。</p><p>第一步和第二步中的不重复数用于防止重放攻击，每个 TCP 会话使用不同的不重复数就可以使加密密钥不同，当收到重放的 SSL 记录时，该记录无法通过完整性检查，假冒的电子事务不会成功。</p><p>当结束 SSL 会话时，需要在类型字段中指出该记录是否是用于终止 SSL 会话的。通过包含这样一个字段，如果客户或服务器在收到一个关闭 SSL 记录之前突然收到了一个 TCP FIN，就知道遭受了截断攻击。</p><h3 id="HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？"><a href="#HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？" class="headerlink" title="HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？"></a><strong>HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密<a href>算法</a>和非对称加密<a href>算法</a>不？</strong></h3><p> <strong>HTTP与HTTPS之间的区别：</strong></p><table><thead><tr><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>默认端口80</td><td>HTTPS默认使用端口443</td></tr><tr><td>明文传输、数据未加密、安全性差</td><td>传输过程ssl加密、安全性较好</td></tr><tr><td>响应速度快、消耗资源少</td><td>响应速度较慢、消耗资源多、需要用到CA证书</td></tr></tbody></table><h3 id="HTTPS链接建立的过程："><a href="#HTTPS链接建立的过程：" class="headerlink" title="HTTPS链接建立的过程："></a><strong>HTTPS链接建立的过程：</strong></h3><p> 1.首先<a href>客户端</a>先给服务器发送一个请求</p><p> 2.服务器发送一个SSL证书给<a href>客户端</a>，内容包括：证书的发布机构、有效期、所有者、签名以及公钥</p><p> 3.<a href>客户端</a>对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密<a href>算法</a>以及对称密钥进行加密</p><p> 4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给<a href>客户端</a></p><p> 5.随后<a href>客户端</a>和服务端就使用对称密钥进行信息传输</p><h3 id="对称加密算法："><a href="#对称加密算法：" class="headerlink" title="对称加密算法："></a><strong>对称加密<a href>算法</a>：</strong></h3><p> 双方持有相同的密钥，且加密速度快，典型对称加密<a href>算法</a>：DES、AES</p><h3 id="非对称加密算法："><a href="#非对称加密算法：" class="headerlink" title="非对称加密算法："></a><strong>非对称加密<a href>算法</a>：</strong></h3><p> 密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密<a href>算法</a>有：RSA、DSA</p><h3 id="HTTP请求有哪些。get和Post区别。"><a href="#HTTP请求有哪些。get和Post区别。" class="headerlink" title="HTTP请求有哪些。get和Post区别。"></a><strong>HTTP请求有哪些。get和Post区别。</strong></h3><p><strong>HTTP请求：</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>向特定资源发送请求，查询数据，并返回实体</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改</td></tr><tr><td>PUT</td><td>向服务器上传新的内容</td></tr><tr><td>HEAD</td><td>类似GET请求，返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>DELETE</td><td>请求服务器删除指定标识的资源</td></tr><tr><td>OPTIONS</td><td>可以用来向服务器发送请求来测试服务器的功能性</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，用于测试或诊断</td></tr><tr><td>CONNECT</td><td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table><p><strong>get和Post区别：</strong></p><table><thead><tr><th>GET</th><th>POST</th><th></th></tr></thead><tbody><tr><td>可见性</td><td>数据在URL中对所有人可见</td><td>数据不会显示在URL中</td></tr><tr><td>安全性</td><td>与post相比，get的安全性较差，因为所 发送的数据是URL的一部分</td><td>安全，因为参数不会被保存在浏览器 历史或web服务器日志中</td></tr><tr><td>数据长度</td><td>受限制，最长2kb</td><td>无限制</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>multipart/form-data</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能被缓存</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="HTTP常见响应状态码，从1xx到5xx"><a href="#HTTP常见响应状态码，从1xx到5xx" class="headerlink" title="HTTP常见响应状态码，从1xx到5xx"></a><strong>HTTP常见响应状态码，从1xx到5xx</strong></h3><p> 100：Continue — 继续。<a href>客户端</a>应继续其请求。</p><p> 200：OK — 请求成功。一般用于GET与POST请求。</p><p> 301：Moved Permanently — 永久重定向。</p><p> 302：Found — 暂时重定向。</p><p> 400：Bad Request — <a href>客户端</a>请求的语法错误，服务器无法理解。</p><p> 403：Forbideen — 服务器理解请求<a href>客户端</a>的请求，但是拒绝执行此请求。</p><p> 404：Not Found — 服务器无法根据<a href>客户端</a>的请求找到资源（网页）。</p><p> 500：Internal Server Error — 服务器内部错误，无法完成请求。</p><p> 502：Bad Gateway — 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。</p><h3 id="重定向和转发区别"><a href="#重定向和转发区别" class="headerlink" title="重定向和转发区别"></a><strong>重定向和转发区别</strong></h3><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><p><strong>转发（Forword）</strong> 通过 RequestDispatcher 对象的<code>forward（HttpServletRequest request,HttpServletResponse response）</code>方法实现的。<code>RequestDispatcher</code> 可以通过<code>HttpServletRequest</code> 的 <code>getRequestDispatcher()</code>方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;login_success.jsp&quot;).forward(request, response);</span><br></pre></td></tr></table></figure><p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletRequestResponse 的 setStatus(int status)方法设置状态码。如果服务器返回 301 或者 302，则浏览器会到新的网址重新请求该资源。</p><ol><li><strong>从地址栏显示来说</strong>：forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。redirect 是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的 URL。</li><li>转发是服务器行为，重定向是客户端行为；</li><li>转发是浏览器只做了一次访问请求。重定向是浏览器做了至少两次的访问请求；</li></ol><h3 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a>条件请求</h3><p>ETag是URL的tag，用来标示URL对象是否改变。这样可以应用于客户端的缓存：服务器产生ETag，并在HTTP响应头中将其传送到客户端，服务器用它来判断页面是否被修改过</p><p><strong>一、If-Match</strong></p><p>服务端有个ETag（实体标记）的字段，与特定资源关联的确定值，当资源更新后Etag也会随之更新。</p><p>所以当客户端If-Match的值若与服务端的ETag一致，才会执行请求，否则会拒绝412</p><p><img src="https://www.pianshen.com/images/658/8ae15fcacfbba3b753514e601d0afa6a.png" alt="img"></p><p><strong>二、If-Modified-Since</strong></p><p>If-Modified-Since会告知服务器若If-Modifed-Since字段值早于资源的更新时间，则希望服务端能处理该请求；</p><p>若If-Modifed-Since字段值晚于资源的更新时间，则返回状态码304 Not Modified的响应</p><p>作用：用于确定代理或客户端拥有的本地资源的有效性。</p><p><img src="https://www.pianshen.com/images/900/4299779b411d9b82bf600758063c9f74.png" alt="img"></p><p> <strong>三、If-None-Match</strong></p><p>与If-Match相反</p><p><strong>四、If-Range</strong></p><p>它告知服务器若指定的If-Range字段值和请求资源的ETag值一致时，则作为范围请求处理，否则返回全部资源</p><p>（这样做也是合理的，因为ETag不变，说明资源未变，则直接返回客户端请求的资源即可；若资源改变，请求的部分资源没有了，应该返回所有的新资源）</p><p><img src="https://www.pianshen.com/images/669/a497c152e52f14dc671ce1fec07c32ed.png" alt="img"></p><p>若不用If-Range，则需要发两次请求。因为若资源改变，会返回客户端412；客户端再发起请求，获得新资源</p><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p>网络安全主要探讨的问题是攻击者如何攻击计算机网络，以及如何防御这些攻击，或者如何事先预防这样的攻击。</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>多道程序环境下允许多个程序并发执行，进程就是为了更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p><p>进程就是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。系统资源指的是处理机、存储器和其他设备服务于某个进程的时间，例如把处理机资源理解为处理机的时间片才是准确的。因为进程是这些资源分配和调度的独立单位，这就决定了进程一定是一个动态的、过程性的概念。</p><p><strong>结构</strong></p><p>①进程控制块PCB：进程实体的一部分，进程存在的唯一标识，包括进程描述信息、控制和管理信息、资源分配清单和处理机相关信息。</p><p>②程序段：就被进程调度程序调度到CPU执行的程序代码段。</p><p>③数据段：进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p><p><strong>特征</strong></p><p>①动态性 进程是一次程序的执行，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。</p><p>②并发性 指多个进程同时存在于内存中，能在一段时间内同时运行。并发性是进程的重要特征，也是操作系统的重要特征。进入进程的目的就是为了使程序能与其他进程的程序并发执行，提高资源利用率。</p><p>③独立性 指进程实体是一个能独立运行、独立获得自由和独立接受调度的基本单位。</p><p>④异步性 由于进程的相互制约，会使进程具有执行的间断性，即进程按各自独立的，不可预知的速度向前推进。</p><p>⑤结构性 每个进程都配置有一个进程控制块PCB对其进行描述，从结构上看进程实体是由程序段、数据段和PCB组成的。</p><p><strong>进程的状态和转换</strong></p><p>①运行态 进程正在处理机上运行</p><p>②就绪态 进程已处于准备运行的状态，获得了除处理机外的一切资源</p><p>③阻塞态 进程正在等待某一事件而暂停运行，如等待某资源可用或等待输入/输出流</p><p>④创建态 进程正在被创建，尚未转到就绪态</p><p>⑤结束态 进程正从系统中消失，可能是正常结束或其他原因中断退出</p><p>就绪-&gt;运行：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片）</p><p>运行-&gt;就绪：处于运行态的进程在时间片用完后，不得不让出处理机。在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转为就绪态，让更高优先级的进程执行。</p><p>运行-&gt;阻塞：进程请求某一资源的使用和分配或等待某事件的发生（如IO完成），进程以系统调用的形式请求操作系统提供服务。</p><p>阻塞-&gt;就绪：进程等待的事件到来时，如IO结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞转为就绪态。</p><p><strong>进程控制</strong></p><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p><strong>进程创建</strong></p><p>允许一个进程创建另一个进程，创建者为父进程，被创建者为子进程。子进程可以继承父进程所拥有的资源，当子进程被撤销时，应将父进程的资源归还。撤销父进程时，必须同时撤销所有子进程。</p><p>①为新进程分配一个唯一的进程标识号，并申请一个空白PCB。②为进程分配资源，为新进程的程序和数据分配必要内存空间。若资源不足不会创建失败而是进入阻塞态。③初始化PCB，包括标志信息，处理机状态信息，进程优先级等。④若进程就绪队列未满，就将新进程插入就绪队列等待被调度。</p><p><strong>进程终止</strong></p><p>正常结束，表示进程任务已经完成并准备退出运行。异常结束，表示进程在运行时发生了某种异常，使程序无法继续运行，例如非法指令，IO故障等。外界干预，指进程因为外界请求而终止，例如操作系统干预或父进程请求终止等。</p><p>①根据被终止进程的标识符，检索PCB，读出该进程的状态。②若处于执行状态，终止执行，将处理机资源分配给其他进程。③若进程还有子进程，应将所有子进程终止。④将该进程的全部资源归还给父进程或操作系统。⑤将PCB从所在队列删除。</p><p><strong>进程阻塞</strong></p><p>①找到将要被阻塞进程的PCB。②如果为运行态，保护现场转为阻塞态，停止运行。③把PCB插入相应事件的等待队列。</p><p><strong>进程唤醒</strong></p><p>①在该事件的等待队列中找到进程对应的PCB。②将其从等待队列中移除，设置状态为就绪态。③将PCB插入就绪队列，等待调度程序调度。</p><p><strong>进程切换</strong></p><p>①保存处理机上下文，包括程序计数器和其他寄存器。②更新PCB信息。③把进程的PCB移入相应的队列。④选择另一个进程执行并更新其PCB。⑤更新内存管理的数据结构。⑥恢复处理机上下文。</p><p><strong>进程通信</strong></p><p>①共享存储：在通信的进程之间存在一块可以直接访问的共享空间，共享存储分为两种：低级的共享基于数据结构，高级的共享基于存储区。操作系统只负责为通信进程提供可共享的存储空间和同步互斥工具，数据交换由用户自己安排读写指令完成。</p><p>②消息传递：进程间的数据交换以格式化的消息为单位，进程提供系统提供的发送消息和接收消息两个原语进行数据交换。消息传递分为：直接通信方式，把消息挂在接收进程的消息缓存队列上。间接通信方式，发送进程把消息发送到某个中间实体，中间实体一般称作信箱，相应的通信系统为电子邮件系统。</p><p>③管道通信：消息传递的一种特殊方式，管道就是连接一个读进程和一个写进程来实现它们通信的一个共享文件。管道可以理解为共享存储的优化和发展，管道通信中存储空间优化为缓冲区，缓冲区只允许一边写入另一边读出，只要缓冲区有数据进程就能从缓冲区读出，只要有数据写进程就不会往缓冲区写数据，因此管道通信是半双工通信。</p><hr><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>引入进程的目的是为了多道程序更好的并发执行，提高资源利用率和吞吐量；引入线程的目的是为了减少程序在并发执行时的时空开销，提高操作系统的并发性能。</p><p>线程就是一种轻量级的进程，是一个基本的CPU执行单位，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是操作系统独立调度和分配的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它与同一进程下的其他线程共享进程的全部资源。</p><p><strong>线程和进程的区别</strong></p><p>①调度：进程是拥有资源的基本单位，而线程是独立调度的基本单位。在同一进程中，线程的切换不会引起进程的切换。在不同进程中线程的切换会引起进程切换。</p><p>②拥有资源：不管是传统操作系统还是有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源，只有一点运行中必不可少的资源。如果线程也是拥有资源的单位，那么切换线程就需要较大的时空开销，它的引入就没有意义。</p><p>③系统开销：创建和撤销进程涉及资源的分配和回收，操作系统的开销远大于创建或撤销线程的开销。进程切换也需要涉及CPU环境的保存和新调度到进程CPU环境的设置，但线程切换只需要保存和设置少量的寄存器容量，开销很小。</p><p>④地址空间：进程的地址空间之间互相独立，同一进程的各个线程共享进程的资源，进程内的线程对其他进程不可见。</p><p>⑤通信：进程间通信需要同步和互斥手段的辅助，保证数据一致性。线程可以直接读写进程数据段（全局变量）来进行通信。</p><p><strong>线程的实现方式</strong></p><p>①用户级线程：有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。</p><p>②内核级线程：线程管理的所有工作都由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。</p><hr><h3 id="TCP异常处理？"><a href="#TCP异常处理？" class="headerlink" title="TCP异常处理？"></a>TCP异常处理？</h3><p>tcp 异常处理，什么时候有RST？</p><p>什么时候有PSH URG 的包</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁就是指多个进程因为互相竞争资源而陷入的一种僵局，如果没有外力的作用，这些进程都无法继续向前推进。</p><p>死锁的原因包含了：</p><p>①不可剥夺资源数量的不足，如果是可剥夺资源是不会造成死锁的。</p><p>②进程的推进顺序非法，进程请求和释放资源的顺序不当，例如进程P1和P2分别占用资源R1和R2，而此时P1和P2又分别申请资源R2和R1。</p><p>③信号量的使用不当，彼此等待对方的消息。</p><p>死锁有四个必要条件：</p><p>①互斥条件，进程对资源的占用具有排他性控制，如果进程请求的资源已被占用，请求就会被阻塞。</p><p>②不可剥夺条件，当一个资源没有被使用完成前是不能被其他进程强行获取的，只有占用它的进程主动释放才可以。</p><p>③请求和保持条件，一个进程已经占有了某个资源，又要请求其他资源，而该资源被其他进程占用，请求被阻塞，但进程也不会释放自己已经占有的资源。</p><p>④循环等待条件，存在一个进程资源的循环等待链，链中每个进程已经占有的资源同时是其他进程请求的资源。</p><p><strong>预防</strong></p><p>事先预防，实现起来比较简单，但是条件严格，效率很低。</p><p>①破坏互斥条件，系统中的所有资源都允许共享，但是有的资源不能同时访问，不太现实。</p><p>②破坏不可剥夺条件，允许剥夺其他进程已经占有的资源，可能会造成前段工作的失效，如果频繁发送就会增加系统开销，严重降低系统的吞吐量。</p><p>③破坏请求和保持条件，采用预先资源分配法，一次性分配进程需要的所有资源，缺点是会严重浪费系统资源。</p><p>④破坏循环等待条件，采用顺序资源分配法， 缺点是会造成编程不便。</p><p><strong>避免</strong></p><p>同样也是事先预防，不同的是动态地根据情况来避免死锁，性能比较好。</p><p>①系统安全状态，不安全的系统可能会导致死锁，安全的系统状态不会导致死锁，如果资源分配不会进入不安全的系统状态就给进程分配资源。</p><p>②银行家算法，把操作系统视为银行家，操作系统管理的资源视为资金，进程向操作系统申请资源相当于贷款。采用预先资源分配策略，主要的数据结构是可利用的资源向量，分配矩阵，需求矩阵，最大需求矩阵。</p><p><strong>检测</strong></p><p>画出资源分配图，圆圈表示进程，框表示一类资源。进程到资源是请求边，资源到进程是分配边。然后利用死锁定理来简化资源分配图，如果S不可被完全简化那么代表是一个死锁。</p><p><strong>解除</strong></p><p>如果没有采取死锁的预防和避免，就要采用死锁的检测和解除。</p><p>①资源剥夺法：挂起某些死锁进程并剥夺其资源。</p><p>②撤销进程法：撤销一个甚至全部死锁进程并剥夺其资源。</p><p>③进程回退法：让一个或多个进程回到不至于造成死锁的状态。</p><h2 id="分页分段"><a href="#分页分段" class="headerlink" title="分页分段"></a>分页分段</h2><p>传统存储管理方式：操作系统引入了虚拟内存的概念，利用计算机的空间局部性和时间局部性原理，将程序分的一部分装入内存运行，其余部分留在外存，等需要的时候再讲外存的程序装入内存继续运行。</p><h3 id="虚拟内存实现方式："><a href="#虚拟内存实现方式：" class="headerlink" title="虚拟内存实现方式："></a>虚拟内存实现方式：</h3><p>请求分页，请求分段，请求段页式存储管理。请求分页存储管理中，将虚拟地址内存空间划分为大小相等的页块，同时内存地址空间，也划分为等大小的页块。系统维持一个页表，存储这虚拟页号到物理快块号的映射。程序中的逻辑地址由两部分组成：页号P和页内位移量W。块号*块大小加上页内偏移得到物理地址。</p><p>如果程序执行时，调用到不再内存中的虚拟页面时，发生缺页中断，将页由外存调入内存。如果内存已满，采用页面置换算法将老的淘汰，载入新的。页面置换算法常见的有FIFO,LRU。</p><p><img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201024091740786.png" alt="image-20201024091740786"></p><p>优点：没有外碎片，每个内碎片不超过页的大小。</p><p>缺点：程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。</p><h3 id="请求分段存储管理："><a href="#请求分段存储管理：" class="headerlink" title="请求分段存储管理："></a>请求分段存储管理：</h3><p>将用户程序地址空间分成若干个大小不等的段，每段能够定义一组相对完整的逻辑信息。存储分配时，以段为单位，段内地址连续，段间不连续。虚拟地址由段号和段内地址组成，虚拟地址到实存地址的变换通过段表来实现。 分页对程序猿而言是不可见的。而分段通常对程序猿而言是可见的，因而分段为组织程序和数据提供了方便。段页式存储组织是分段式和分页式结合的存储组织方法。这样可充分利用分段管理和分页管理的长处。</p><p><img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201024091751743.png" alt="image-20201024091751743"></p><p>优点：可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。</p><p>缺点：会产生碎片。</p><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统</p><p>的共享和保护，又拥有分页系统的虚拟内存功能。</p><p><img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201024091706330.png" alt="image-20201024091706330"></p><h3 id="大内核和微内核有什么区别？"><a href="#大内核和微内核有什么区别？" class="headerlink" title="大内核和微内核有什么区别？"></a>大内核和微内核有什么区别？</h3><ul><li>大内核，就是将操作系统的全部功能都放进内核里面，组成一个紧密连接整体。大内核的优点就是效率高，但是很难定位<code>bug</code>，拓展性比较差，每次需要增加新的功能，都要将新的代码和原来的内核代码重新编译。 </li><li>微内核与单体内核不同，微内核只是将操作中最核心的功能加入内核，包括<code>IPC</code>、地址空间分配和基本的调度，这些东西都在内核态运行，其他功能作为模块被内核调用，并且是在用户空间运行。微内核比较好维护和拓展，但是效率可能不高，因为需要频繁地在内核态和用户态之间切换。</li></ul><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>作者：风雨下钟山<br>链接：<a href="https://www.nowcoder.com/discuss/468422" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/468422</a><br>来源：牛客网</p><h4 id="Socket通信流程是怎样的？"><a href="#Socket通信流程是怎样的？" class="headerlink" title="Socket通信流程是怎样的？"></a>Socket通信流程是怎样的？</h4><p><img src="https://uploadfiles.nowcoder.com/images/20200806/6638786_1596672311055_5EE57B5D9BB579AAED205B35F053429B" alt="图片说明"> </p><ul><li>概括地说，就是通信的两端都建立了一个 <code>Socket</code> ，然后通过 <code>Socket</code> 对数据进行传输。通常服务器处于一个无限循环，等待<a href>客户端</a>的连接。 </li><li>对于<a href>客户端</a>，它的的过程比较简单，首先创建 <code>Socket</code>，通过<code>TCP</code>连接服务器，将 <code>Socket</code> 与远程主机的某个进程连接，然后就发送数据，或者读取响应数据，直到数据交换完毕，关闭连接，结束 <code>TCP</code> 对话。 </li><li>对于服务端，先初始化 <code>Socket</code>，建立流式套接字，与本机地址及端口进行绑定，然后通知 <code>TCP</code>，准备好接收连接，调用 <code>accept()</code> 阻塞，等待来自<a href>客户端</a>的连接。如果这时<a href>客户端</a>与服务器建立了连接，<a href>客户端</a>发送数据请求，服务器接收请求并处理请求，然后把响应数据发送给<a href>客户端</a>，<a href>客户端</a>读取数据，直到数据交换完毕。最后关闭连接，交互结束。 </li></ul><h4 id="延伸问题：从TCP连接的角度说说Socket通信流程。"><a href="#延伸问题：从TCP连接的角度说说Socket通信流程。" class="headerlink" title="延伸问题：从TCP连接的角度说说Socket通信流程。"></a>延伸问题：从<code>TCP</code>连接的角度说说Socket通信流程。</h4><p><img src="https://uploadfiles.nowcoder.com/images/20200806/6638786_1596672375547_34FD922BEF6AB289D1B71C7D84037E42" alt="图片说明"> </p><p>首先是三次握手的<code>Socket</code>交互流程。</p><ol><li>服务器调用 <code>socket()</code>、<code>bind()</code>、<code>listen()</code> 完成初始化后，调用 <code>accept()</code> 阻塞等待； </li><li><a href>客户端</a> <code>Socket</code> 对象调用 <code>connect()</code> 向服务器发送了一个 <code>SYN</code> 并阻塞； </li><li>服务器完成了第一次握手，即发送 <code>SYN</code> 和 <code>ACK</code> 应答； </li><li><a href>客户端</a>收到服务端发送的应答之后，从 <code>connect()</code> 返回，再发送一个 <code>ACK</code> 给服务器； </li><li>服务器 <code>Socket</code> 对象接收<a href>客户端</a>第三次握手 <code>ACK</code> 确认，此时服务端从 <code>accept()</code> 返回，建立连接。 </li></ol><p>接下来就是两个端的连接对象互相收发数据。</p><p><img src="https://uploadfiles.nowcoder.com/images/20200806/6638786_1596672413212_A3DEEBF7F3F9D50D1D3613B9F2A48D7B" alt="图片说明"> </p><p>然后是四次挥手的<code>Socket</code>交互流程。</p><ol><li>某个应用进程调用 <code>close()</code> 主动关闭，发送一个 <code>FIN</code>； </li><li>另一端接收到 <code>FIN</code> 后被动执行关闭，并发送 <code>ACK</code> 确认； </li><li>之后被动执行关闭的应用进程调用 <code>close()</code> 关闭 <code>Socket</code>，并也发送一个 <code>FIN</code>； </li><li>接收到这个 <code>FIN</code> 的一端向另一端 <code>ACK</code> 确认。</li></ol><h3 id="close-wait产生原因"><a href="#close-wait产生原因" class="headerlink" title="close_wait产生原因"></a>close_wait产生原因</h3><p>通常，CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的 CLOSE_WAIT 状态，那么就意味着被动关闭的一方没有及时发出 FIN 包，一般有如下几种可能：</p><ul><li>程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。</li><li>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。</li><li>BACKLOG 太大：此处的 backlog 不是 syn backlog，而是 accept 的 backlog，如果 backlog 太大的话，设想突然遭遇大访问量的话，即便响应速度不慢，也可能出现来不及消费的情况，导致多余的请求还在<a href="http://jaseywang.me/2014/07/20/tcp-queue-的一些问题/" target="_blank" rel="noopener">队列</a>里就被对方关闭了。</li></ul><p>如果你通过「netstat -ant」或者「ss -ant」命令发现了很多 CLOSE_WAIT 连接，请注意结果中的「Recv-Q」和「Local Address」字段，通常「Recv-Q」会不为空，它表示应用还没来得及接收数据，而「Local Address」表示哪个地址和端口有问题，我们可以通过「lsof -i:<PORT>」来确认端口对应运行的是什么程序以及它的进程号是多少。</PORT></p><p>如果是我们自己写的一些程序，比如用 HttpClient 自定义的蜘蛛，那么八九不离十是程序问题，如果是一些使用广泛的程序，比如 Tomcat 之类的，那么更可能是响应速度太慢或者 timeout 设置太小或者 BACKLOG 设置过大导致的故障。</p><h3 id="第二次挥手和第三次挥手能不能合并"><a href="#第二次挥手和第三次挥手能不能合并" class="headerlink" title="第二次挥手和第三次挥手能不能合并"></a>第二次挥手和第三次挥手能不能合并</h3><p>第二次挥手的目的是确认你刚才给我发的包已经收到了，第三次挥手的目标是一个新的请求，因为第一次挥手数据包过来时服务器要有两件事要做，diyijianercihuishoudehuifu第一件二次挥手的回复，第二件通过应用程序解阻塞之后才能调用close，这个应用程序有可能调用了close，也有可能没调用，只要不调用close，就没有第三次挥手，如果第一次挥手发了数据包之后，服务器是要尽快去认，应用程序里面迟迟不调用close，所以第三次挥手迟迟发不了，如果把二和三合并一起，第三次迟迟发不了，两次挥手都发不了，客户端还等着呢，所以不能合并，拆开发。</p><h3 id="那为什么会有close-wait状态呢"><a href="#那为什么会有close-wait状态呢" class="headerlink" title="那为什么会有close_wait状态呢"></a>那为什么会有close_wait状态呢</h3><p>·在服务器与客户端通信的过程中，因为服务器未关闭socket导致closed_wait的发生，当客户端不断地发送连接请求的时候，这样打开的文件描述符就会不断增加。在linux系统中，一个进程可以最大同时打开的文件描述符是有限的。通过ulimit可以查看。</p><h3 id="IO复用？"><a href="#IO复用？" class="headerlink" title="IO复用？"></a>IO复用？</h3><p>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p>1、select、poll和epoll<br>·select、poll、epoll都可以监听多个文件描述符，等待指定的超时时间，直到一个或者多个文件描述符上有事件发生时返回。返回的值就是文件描述符的数量。返回0表示没有事件发生。</p><p>·差别：<br> (1)事件集<br>  ·select有三种类型的描述符类型：readfds、writefds、exceptfds，分别对应读、写、异常条件的描述符集合。因此，select不能处理这三种事件以外的事件类型。并且，每一次select会使得内核直接对fd_set进行修改，再下一次使用select的时候需要重置fd_set。每次select返回的都是注册了的事件集合，包括了就绪和没有就绪的，程序检索就绪事件的时间复杂度为O(n)</p><p>  ·poll对select进行了改进，poll的参数是一个结构体pollfd。poll不会修改描述符，因此每次使用不需要重置pollfd。但是，poll仍然是返回注册了的事件集合，包括了就绪和没有就绪的，程序检索就绪事件的时间复杂度为O(n)。</p><p>  ·epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<br>红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事<br>件完成的描述符。使得检索的时间复杂度达到O(1)</p><p> (2)支持最大的文件描述符<br>  ·select：受到系统的限制，由&lt;sys/select.h&gt;头文件中的FD_SETSIZE宏决定，通常是1024<br>  ·poll和epoll一般为65535</p><p> (3)工作模式<br>  ·select和poll只能工作在相对来说低效的水平触发模式(LT)<br>  ·epoll可以工作在高效的边缘触发模式(ET),也可以工作在水平触发模式</p><p> (4)实现原理<br>  ·select和poll都是基于轮询的方式，每一次的调用都要扫描整个注册的文件描述符集合，并将其中就绪的文件描述符返回给用户，因此检测就绪事件的时间复杂度是O(n)<br>  ·epoll_wait是采用回调的方式，内核检测到了就绪文件描述符，就会触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪队列中，内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此epoll_wait无需轮询检测哪些事件已经就绪，其时间复杂度是O(1)<br>  ·epoll需要触发回调函数，因此更适用于连接数目多，但活动连接较少的情况。</p><h3 id="同步与异步，阻塞和非阻塞"><a href="#同步与异步，阻塞和非阻塞" class="headerlink" title="同步与异步，阻塞和非阻塞"></a>同步与异步，阻塞和非阻塞</h3><p>同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p><p>而异步则是相反，<strong><em>调用\</em>在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p><p>·阻塞是指结果返回前，当前进程直接被挂起，一直等待结果的到来； 非阻塞则立刻返回，执行后续操作</p><p>·同步阻塞：当前进程在等待时，没有执行其他操作而是被挂起<br>·同步非阻塞：线程等待的时候，执行其它操作(效率低，很有可能设计线程切换的操作)</p><p>·异步阻塞：线程在等待消息通知时被挂起<br>·异步非阻塞：线程不等待，可以去做其他事情</p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p><ol><li>LT 模式<br>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait()<br>会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</li><li>ET 模式<br>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。<br>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个<br>文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</li></ol><h3 id="工作场景"><a href="#工作场景" class="headerlink" title="工作场景"></a>工作场景</h3><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><ol><li>select 应用场景<br>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比<br>如核反应堆的控制。<br>select 可移植性更好，几乎被所有主流平台所支持。</li><li>poll 应用场景<br>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</li><li>epoll 应用场景<br>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。<br>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。<br>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在<br>内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且<br>epoll 的描述符存储在内核，不容易调试。</li></ol><h3 id="arp欺骗"><a href="#arp欺骗" class="headerlink" title="arp欺骗"></a>arp欺骗</h3><p>在使用以太网交换机的网络中，攻击者向某个以太网交换机发送大量的伪造源 MAC 地址，以太网交换机收到这样的帧就把虚假的 MAC 源地址填入到交换表中，由于伪造的数量很大很快就填满了表，导致以太网交换机无法正常工作。</p><p> 1.解决方法：利用交换机防止ARP攻击</p><p>在交换机上绑定MAC地址与IP地址，为每台主机添加一条IP地址和MAC地址对应的关系静态地址表。用户发送数据包时，若交换机获得的IP和MAC地址与之前建立的映射表匹配，则发送的包能通过，否则将丢弃该数据包，从而有效地防止ARP欺骗。</p><p>2.[DHCP snooping](<a href="https://baike.baidu.com/item/DHCP" target="_blank" rel="noopener">https://baike.baidu.com/item/DHCP</a> snooping)，网上设备可借由<a href="https://baike.baidu.com/item/DHCP" target="_blank" rel="noopener">DHCP</a>保留网络上各计算机的MAC地址，在伪造的ARP数据包发出时即可侦测到。此方式已在一些厂牌的网上设备产品所支持。</p><p>3.每台计算机的ARP一律改用静态的方式，不过这在大型的网上是不可行的，因为需要经常更新每台计算机的ARP表。</p><h3 id="SYN-flood"><a href="#SYN-flood" class="headerlink" title="SYN flood"></a>SYN flood</h3><p>Syn-Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问。</p><p>解决方法</p><p>1.无效连接监视释放</p><p>这种方法不停监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。</p><p>2.延缓TCB分配方法</p><p>从前面SYN Flood原理可以看到，消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用SYN Cache和SYN Cookie技术。</p><p>SYN Cache技术：</p><p>这种技术是在收到SYN数据报文时不急于去分配TCB，而是先回应一个SYN ACK报文，并在一个专用HASH表（Cache）中保存这种半开连接信息，直到收到正确的回应ACK报文再分配TCB。</p><p>SYN Cookie技术：</p><p>对于SYN攻击，SYN Cache虽然不分配TCB，但是为了判断后续对方发来的ACK报文中的Sequence Number的正确性，还是需要使用一些空间去保存己方生成的Sequence Number等信息，也造成了一些资源的浪费。Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（SequenceNumber-1）相同，从而决定是否分配TCB资源。</p><p>3．使用SYN Proxy防火墙</p><p>SYN Cache技术和SYN Cookie技术总的来说是一种主机保护技术，需要系统的TCP/IP协议栈的支持，而目前并非所有的操作系统支持这些技术。因此很多防火墙中都提供一种 SYN代理的功能，其主要原理是对试图穿越的SYN请求进行验证后才放行，下图描述了这种过程：</p><h3 id="DNS欺骗？"><a href="#DNS欺骗？" class="headerlink" title="DNS欺骗？"></a>DNS欺骗？</h3><p> DNS欺骗就是攻击者冒充<a href="https://baike.baidu.com/item/域名服务器/9705133" target="_blank" rel="noopener">域名服务器</a>的一种欺骗行为。 原理：如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。</p><ol><li><p>进行IP地址和MAC地址的绑定</p><p>(1)预防ARP欺骗攻击。因为DNS攻击的欺骗行为要以ARP欺骗作为开端，所以如果能有效防范或避免ARP欺骗，也就使得DNS ID欺骗攻击无从下手。例如可以通过将Gateway Router 的Ip Address和MAC Address静态绑定在一起，就可以防范ARP攻击欺骗。</p></li></ol><p>2.直接使用IP地址访问</p><p>   对个别信息安全等级要求十分严格的WEB站点尽量不要使用DNS进行解析。由于DNS欺骗攻击中不少是针对窃取客户的私密数据而来的，而多数用户访问的站点并不涉及这些隐私信息，因此当访问具有严格保密信息的站点时，可以直接使用IP地址而无需通过DNS解析，这样所有的DNS欺骗攻击可能造成的危害就可以避免了。除此，应该做好DNS Server的安全配置项目和升级DNS软件，合理限定DNS Server进行响应的IP地址区间，关闭DNS Server的递归查询项目等。</p><p>3.对DNS数据包进行监测</p><p>   在DNS欺骗攻击中，Client会接收到至少两个DNS的数据响应包，一个是真实的数据包，另一个是攻击数据包。欺骗攻击数据包为了抢在真实应答包之前回复给Client，它的信息数据结构与真实的数据包相比十分简单，只有应答域，而不包括授权域和附加域。因此，可以通过监测DNS响应包，遵循相应的原则和模型算法对这两种响应包进行分辨，从而避免虚假数据包的攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字节算法题汇总</title>
      <link href="/2020/09/28/%E5%AD%97%E8%8A%82%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2020/09/28/%E5%AD%97%E8%8A%82%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>作者：星__尘<br>链接：<a href="https://www.nowcoder.com/discuss/428158?page=2" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/428158?page=2</a><br>来源：牛客网</p><h2 id="动态规划和贪心"><a href="#动态规划和贪心" class="headerlink" title="动态规划和贪心"></a><strong><a href>动态规划</a>和贪心</strong></h2><ul><li><p><a href>算法题</a>：买卖股票的最佳时机（只能有一次买卖，可以最多两次买卖，不限次数） </p><p>股票问题通用解法详解参考： <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/</a> </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缓存优化</title>
      <link href="/2020/09/09/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"/>
      <url>/2020/09/09/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2020/09/09/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200909163600765.png" alt="image-20200909163600765"></p><p>caffeine</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 帖子列表缓存</span><br><span class="line">private LoadingCache&lt;String, List&lt;DiscussPost&gt;&gt; postListCache;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 帖子总数缓存</span><br><span class="line">private LoadingCache&lt;Integer, Integer&gt; postRowsCache;</span><br><span class="line"></span><br><span class="line">@PostConstruct</span><br><span class="line">public void init() &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化帖子列表缓存</span><br><span class="line">    postListCache &#x3D; Caffeine.newBuilder()</span><br><span class="line">            .maximumSize(maxSize)</span><br><span class="line">            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)</span><br><span class="line">            .build(new CacheLoader&lt;String, List&lt;DiscussPost&gt;&gt;() &#123;</span><br><span class="line">                @Nullable</span><br><span class="line">                @Override</span><br><span class="line">                public List&lt;DiscussPost&gt; load(@NonNull String key) throws Exception &#123;</span><br><span class="line">                    if (key &#x3D;&#x3D; null || key.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        throw new IllegalArgumentException(&quot;参数错误!&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String[] params &#x3D; key.split(&quot;:&quot;);</span><br><span class="line">                    if (params &#x3D;&#x3D; null || params.length !&#x3D; 2) &#123;</span><br><span class="line">                        throw new IllegalArgumentException(&quot;参数错误!&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    int offset &#x3D; Integer.valueOf(params[0]);</span><br><span class="line">                    int limit &#x3D; Integer.valueOf(params[1]);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 二级缓存: Redis -&gt; mysql</span><br><span class="line"></span><br><span class="line">                    logger.debug(&quot;load post list from DB.&quot;);</span><br><span class="line">                    return discussPostMapper.selectDiscussPosts(0, offset, limit, 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#x2F;&#x2F; 初始化帖子总数缓存</span><br><span class="line">    postRowsCache &#x3D; Caffeine.newBuilder()</span><br><span class="line">            .maximumSize(maxSize)</span><br><span class="line">            .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)</span><br><span class="line">            .build(new CacheLoader&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                @Nullable</span><br><span class="line">                @Override</span><br><span class="line">                public Integer load(@NonNull Integer key) throws Exception &#123;</span><br><span class="line">                    logger.debug(&quot;load post rows from DB.&quot;);</span><br><span class="line">                    return discussPostMapper.selectDiscussPostRows(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>热帖排行</title>
      <link href="/2020/09/09/%E7%83%AD%E5%B8%96%E6%8E%92%E8%A1%8C/"/>
      <url>/2020/09/09/%E7%83%AD%E5%B8%96%E6%8E%92%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>Quartz</p><ul><li>调度器：Scheduler</li><li>任务：JobDetail</li><li>触发器：Trigger，包括SimpleTrigger和CronTrigger</li></ul><p><img src="https://img-blog.csdn.net/20180710135431806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>配置-&gt;数据库-&gt;调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 刷新帖子分数任务</span><br><span class="line">@Bean</span><br><span class="line">public JobDetailFactoryBean postScoreRefreshJobDetail() &#123;</span><br><span class="line">    JobDetailFactoryBean factoryBean &#x3D; new JobDetailFactoryBean();</span><br><span class="line">    factoryBean.setJobClass(PostScoreRefreshJob.class);</span><br><span class="line">    factoryBean.setName(&quot;postScoreRefreshJob&quot;);</span><br><span class="line">    factoryBean.setGroup(&quot;communityJobGroup&quot;);</span><br><span class="line">    factoryBean.setDurability(true);</span><br><span class="line">    factoryBean.setRequestsRecovery(true);</span><br><span class="line">    return factoryBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SimpleTriggerFactoryBean postScoreRefreshTrigger(JobDetail postScoreRefreshJobDetail) &#123;</span><br><span class="line">    SimpleTriggerFactoryBean factoryBean &#x3D; new SimpleTriggerFactoryBean();</span><br><span class="line">    factoryBean.setJobDetail(postScoreRefreshJobDetail);</span><br><span class="line">    factoryBean.setName(&quot;postScoreRefreshTrigger&quot;);</span><br><span class="line">    factoryBean.setGroup(&quot;communityTriggerGroup&quot;);</span><br><span class="line">    factoryBean.setRepeatInterval(1000 * 60 * 5);</span><br><span class="line">    factoryBean.setJobDataMap(new JobDataMap());</span><br><span class="line">    return factoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>帖子分数刷新的任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class PostScoreRefreshJob implements Job, CommunityConstant &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(PostScoreRefreshJob.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private LikeService likeService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ElasticsearchService elasticsearchService;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 牛客纪元</span><br><span class="line">    private static final Date epoch;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            epoch &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).parse(&quot;2014-08-01 00:00:00&quot;);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;初始化牛客纪元失败!&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        String redisKey &#x3D; RedisKeyUtil.getPostScoreKey();</span><br><span class="line">        BoundSetOperations operations &#x3D; redisTemplate.boundSetOps(redisKey);</span><br><span class="line"></span><br><span class="line">        if (operations.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            logger.info(&quot;[任务取消] 没有需要刷新的帖子!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;[任务开始] 正在刷新帖子分数: &quot; + operations.size());</span><br><span class="line">        while (operations.size() &gt; 0) &#123;</span><br><span class="line">            this.refresh((Integer) operations.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(&quot;[任务结束] 帖子分数刷新完毕!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void refresh(int postId) &#123;</span><br><span class="line">        DiscussPost post &#x3D; discussPostService.findDiscussPostById(postId);</span><br><span class="line"></span><br><span class="line">        if (post &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;该帖子不存在: id &#x3D; &quot; + postId);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 是否精华</span><br><span class="line">        boolean wonderful &#x3D; post.getStatus() &#x3D;&#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; 评论数量</span><br><span class="line">        int commentCount &#x3D; post.getCommentCount();</span><br><span class="line">        &#x2F;&#x2F; 点赞数量</span><br><span class="line">        long likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_POST, postId);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 计算权重</span><br><span class="line">        double w &#x3D; (wonderful ? 75 : 0) + commentCount * 10 + likeCount * 2;</span><br><span class="line">        &#x2F;&#x2F; 分数 &#x3D; 帖子权重 + 距离天数</span><br><span class="line">        double score &#x3D; Math.log10(Math.max(w, 1))</span><br><span class="line">                + (post.getCreateTime().getTime() - epoch.getTime()) &#x2F; (1000 * 3600 * 24);</span><br><span class="line">        &#x2F;&#x2F; 更新帖子分数</span><br><span class="line">        discussPostService.updateScore(postId, score);</span><br><span class="line">        &#x2F;&#x2F; 同步搜索数据</span><br><span class="line">        post.setScore(score);</span><br><span class="line">        elasticsearchService.saveDiscussPost(post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算帖子分数</p><p>log(评论数<em>10+点赞数</em>2)+现在时间-牛客纪元</p><p>点赞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    public String like(int entityType, int entityId, int entityUserId, int postId) &#123;</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if(entityType &#x3D;&#x3D; ENTITY_TYPE_POST) &#123;</span><br><span class="line">    &#x2F;&#x2F; 计算帖子分数</span><br><span class="line">    String redisKey &#x3D; RedisKeyUtil.getPostScoreKey();</span><br><span class="line">    redisTemplate.opsForSet().add(redisKey, postId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>评论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算帖子分数</span><br><span class="line">String redisKey &#x3D; RedisKeyUtil.getPostScoreKey();</span><br><span class="line">redisTemplate.opsForSet().add(redisKey, discussPostId);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kafka系统通知</title>
      <link href="/2020/09/08/Kafka%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/"/>
      <url>/2020/09/08/Kafka%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2020/09/08/Kafka%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908222307315.png" alt="image-20200908222307315"></p><p>Event</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Event &#123;</span><br><span class="line"></span><br><span class="line">    private String topic;</span><br><span class="line">    private int userId;</span><br><span class="line">    private int entityType;</span><br><span class="line">    private int entityId;</span><br><span class="line">    private int entityUserId;</span><br><span class="line">    private Map&lt;String, Object&gt; data &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EventProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理事件</span><br><span class="line">    public void fireEvent(Event event) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将事件发布到指定的主题</span><br><span class="line">        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public class EventConsumer implements CommunityConstant &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(EventConsumer.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MessageService messageService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ElasticsearchService elasticsearchService;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;wk.image.command&#125;&quot;)</span><br><span class="line">    private String wkImageCommand;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;wk.image.storage&#125;&quot;)</span><br><span class="line">    private String wkImageStorage;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;qiniu.key.access&#125;&quot;)</span><br><span class="line">    private String accessKey;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;qiniu.key.secret&#125;&quot;)</span><br><span class="line">    private String secretKey;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;qiniu.bucket.share.name&#125;&quot;)</span><br><span class="line">    private String shareBucketName;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ThreadPoolTaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    @KafkaListener(topics &#x3D; &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;)</span><br><span class="line">    public void handleCommentMessage(ConsumerRecord record) &#123;</span><br><span class="line">        if (record &#x3D;&#x3D; null || record.value() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息的内容为空!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Event event &#x3D; JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">        if (event &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息格式错误!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 发送站内通知</span><br><span class="line">        Message message &#x3D; new Message();</span><br><span class="line">        message.setFromId(SYSTEM_USER_ID);</span><br><span class="line">        message.setToId(event.getEntityUserId());</span><br><span class="line">        message.setConversationId(event.getTopic());</span><br><span class="line">        message.setCreateTime(new Date());</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; content &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        content.put(&quot;userId&quot;, event.getUserId());</span><br><span class="line">        content.put(&quot;entityType&quot;, event.getEntityType());</span><br><span class="line">        content.put(&quot;entityId&quot;, event.getEntityId());</span><br><span class="line"></span><br><span class="line">        if (!event.getData().isEmpty()) &#123;</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; entry : event.getData().entrySet()) &#123;</span><br><span class="line">                content.put(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        message.setContent(JSONObject.toJSONString(content));</span><br><span class="line">        messageService.addMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 消费发帖事件</span><br><span class="line">    @KafkaListener(topics &#x3D; &#123;TOPIC_PUBLISH&#125;)</span><br><span class="line">    public void handlePublishMessage(ConsumerRecord record) &#123;</span><br><span class="line">        if (record &#x3D;&#x3D; null || record.value() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息的内容为空!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Event event &#x3D; JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">        if (event &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息格式错误!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DiscussPost post &#x3D; discussPostService.findDiscussPostById(event.getEntityId());</span><br><span class="line">        elasticsearchService.saveDiscussPost(post);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 消费删帖事件</span><br><span class="line">    @KafkaListener(topics &#x3D; &#123;TOPIC_DELETE&#125;)</span><br><span class="line">    public void handleDeleteMessage(ConsumerRecord record) &#123;</span><br><span class="line">        if (record &#x3D;&#x3D; null || record.value() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息的内容为空!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Event event &#x3D; JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">        if (event &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logger.error(&quot;消息格式错误!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elasticsearchService.deleteDiscussPost(event.getEntityId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 触发评论事件</span><br><span class="line">Event event &#x3D; new Event()</span><br><span class="line">        .setTopic(TOPIC_COMMENT)</span><br><span class="line">        .setUserId(hostHolder.getUser().getId())</span><br><span class="line">        .setEntityType(comment.getEntityType())</span><br><span class="line">        .setEntityId(comment.getEntityId())</span><br><span class="line">        .setData(&quot;postId&quot;, discussPostId);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 触发点赞事件</span><br><span class="line">if (likeStatus &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    Event event &#x3D; new Event()</span><br><span class="line">            .setTopic(TOPIC_LIKE)</span><br><span class="line">            .setUserId(hostHolder.getUser().getId())</span><br><span class="line">            .setEntityType(entityType)</span><br><span class="line">            .setEntityId(entityId)</span><br><span class="line">            .setEntityUserId(entityUserId)</span><br><span class="line">            .setData(&quot;postId&quot;, postId);</span><br><span class="line">    eventProducer.fireEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 触发关注事件</span><br><span class="line">Event event &#x3D; new Event()</span><br><span class="line">        .setTopic(TOPIC_FOLLOW)</span><br><span class="line">        .setUserId(hostHolder.getUser().getId())</span><br><span class="line">        .setEntityType(entityType)</span><br><span class="line">        .setEntityId(entityId)</span><br><span class="line">        .setEntityUserId(entityId);</span><br><span class="line">eventProducer.fireEvent(event);</span><br></pre></td></tr></table></figure><p>显示系统通知（我们只要评论，赞和关注)</p><p><img src="/2020/09/08/Kafka%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200909105702853.png" alt="image-20200909105702853"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;notice&#x2F;list&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">public String getNoticeList(Model model) &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询评论类通知</span><br><span class="line">    Message message &#x3D; messageService.findLatestNotice(user.getId(), TOPIC_COMMENT);</span><br><span class="line">    if (message !&#x3D; null) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; messageVO &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        messageVO.put(&quot;message&quot;, message);</span><br><span class="line"></span><br><span class="line">        String content &#x3D; HtmlUtils.htmlUnescape(message.getContent());</span><br><span class="line">        Map&lt;String, Object&gt; data &#x3D; JSONObject.parseObject(content, HashMap.class);</span><br><span class="line"></span><br><span class="line">        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));</span><br><span class="line">        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));</span><br><span class="line">        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));</span><br><span class="line">        messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));</span><br><span class="line"></span><br><span class="line">        int count &#x3D; messageService.findNoticeCount(user.getId(), TOPIC_COMMENT);</span><br><span class="line">        messageVO.put(&quot;count&quot;, count);</span><br><span class="line"></span><br><span class="line">        int unread &#x3D; messageService.findNoticeUnreadCount(user.getId(), TOPIC_COMMENT);</span><br><span class="line">        messageVO.put(&quot;unread&quot;, unread);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;commentNotice&quot;, messageVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询点赞类通知</span><br><span class="line">    message &#x3D; messageService.findLatestNotice(user.getId(), TOPIC_LIKE);</span><br><span class="line">    if (message !&#x3D; null) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; messageVO &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        messageVO.put(&quot;message&quot;, message);</span><br><span class="line"></span><br><span class="line">        String content &#x3D; HtmlUtils.htmlUnescape(message.getContent());</span><br><span class="line">        Map&lt;String, Object&gt; data &#x3D; JSONObject.parseObject(content, HashMap.class);</span><br><span class="line"></span><br><span class="line">        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));</span><br><span class="line">        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));</span><br><span class="line">        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));</span><br><span class="line">        messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));</span><br><span class="line"></span><br><span class="line">        int count &#x3D; messageService.findNoticeCount(user.getId(), TOPIC_LIKE);</span><br><span class="line">        messageVO.put(&quot;count&quot;, count);</span><br><span class="line"></span><br><span class="line">        int unread &#x3D; messageService.findNoticeUnreadCount(user.getId(), TOPIC_LIKE);</span><br><span class="line">        messageVO.put(&quot;unread&quot;, unread);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;likeNotice&quot;, messageVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询关注类通知</span><br><span class="line">    message &#x3D; messageService.findLatestNotice(user.getId(), TOPIC_FOLLOW);</span><br><span class="line">    if (message !&#x3D; null) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; messageVO &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        messageVO.put(&quot;message&quot;, message);</span><br><span class="line"></span><br><span class="line">        String content &#x3D; HtmlUtils.htmlUnescape(message.getContent());</span><br><span class="line">        Map&lt;String, Object&gt; data &#x3D; JSONObject.parseObject(content, HashMap.class);</span><br><span class="line"></span><br><span class="line">        messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));</span><br><span class="line">        messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));</span><br><span class="line">        messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));</span><br><span class="line"></span><br><span class="line">        int count &#x3D; messageService.findNoticeCount(user.getId(), TOPIC_FOLLOW);</span><br><span class="line">        messageVO.put(&quot;count&quot;, count);</span><br><span class="line"></span><br><span class="line">        int unread &#x3D; messageService.findNoticeUnreadCount(user.getId(), TOPIC_FOLLOW);</span><br><span class="line">        messageVO.put(&quot;unread&quot;, unread);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;followNotice&quot;, messageVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 查询未读消息数量</span><br><span class="line">    int letterUnreadCount &#x3D; messageService.findLetterUnreadCount(user.getId(), null);</span><br><span class="line">    model.addAttribute(&quot;letterUnreadCount&quot;, letterUnreadCount);</span><br><span class="line">    int noticeUnreadCount &#x3D; messageService.findNoticeUnreadCount(user.getId(), null);</span><br><span class="line">    model.addAttribute(&quot;noticeUnreadCount&quot;, noticeUnreadCount);</span><br><span class="line"></span><br><span class="line">    return &quot;&#x2F;site&#x2F;notice&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>点赞关注</title>
      <link href="/2020/09/07/%E7%82%B9%E8%B5%9E%E5%85%B3%E6%B3%A8/"/>
      <url>/2020/09/07/%E7%82%B9%E8%B5%9E%E5%85%B3%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>点赞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public String like(int entityType, int entityId, int entityUserId, int postId) &#123;</span><br><span class="line">       User user &#x3D; hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 点赞</span><br><span class="line">       likeService.like(user.getId(), entityType, entityId, entityUserId);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 数量</span><br><span class="line">       long likeCount &#x3D; likeService.findEntityLikeCount(entityType, entityId);</span><br><span class="line">       &#x2F;&#x2F; 状态</span><br><span class="line">       int likeStatus &#x3D; likeService.findEntityLikeStatus(user.getId(), entityType, entityId);</span><br><span class="line">       &#x2F;&#x2F; 返回的结果</span><br><span class="line">       ....</span><br><span class="line">       ....</span><br></pre></td></tr></table></figure><p>关注</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;follow&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String follow(int entityType, int entityId) &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">    followService.follow(user.getId(), entityType, entityId);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;unfollow&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String unfollow(int entityType, int entityId) &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line"></span><br><span class="line">    followService.unfollow(user.getId(), entityType, entityId);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;followees&#x2F;&#123;userId&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">public String getFollowees(@PathVariable(&quot;userId&quot;) int userId, Page page, Model model) &#123;</span><br><span class="line">    User user &#x3D; userService.findUserById(userId);</span><br><span class="line">    if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;该用户不存在!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(&quot;user&quot;, user);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;followers&#x2F;&#123;userId&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">public String getFollowers(@PathVariable(&quot;userId&quot;) int userId, Page page, Model model) &#123;</span><br><span class="line">    User user &#x3D; userService.findUserById(userId);</span><br></pre></td></tr></table></figure><p>关注列表</p><p>粉丝列表</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>点赞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void like(int userId, int entityType, int entityId, int entityUserId) &#123;</span><br><span class="line">    redisTemplate.execute(new SessionCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            String entityLikeKey &#x3D; RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">            String userLikeKey &#x3D; RedisKeyUtil.getUserLikeKey(entityUserId);</span><br><span class="line"></span><br><span class="line">            boolean isMember &#x3D; operations.opsForSet().isMember(entityLikeKey, userId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            if (isMember) &#123;</span><br><span class="line">                operations.opsForSet().remove(entityLikeKey, userId);</span><br><span class="line">                operations.opsForValue().decrement(userLikeKey);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                operations.opsForSet().add(entityLikeKey, userId);</span><br><span class="line">                operations.opsForValue().increment(userLikeKey);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询某实体点赞的数量</span><br><span class="line">public long findEntityLikeCount(int entityType, int entityId) &#123;</span><br><span class="line">    String entityLikeKey &#x3D; RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">    return redisTemplate.opsForSet().size(entityLikeKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询某人对某实体的点赞状态</span><br><span class="line">public int findEntityLikeStatus(int userId, int entityType, int entityId) &#123;</span><br><span class="line">    String entityLikeKey &#x3D; RedisKeyUtil.getEntityLikeKey(entityType, entityId);</span><br><span class="line">    return redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? 1 : 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关注</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void follow(int userId, int entityType, int entityId) &#123;</span><br><span class="line">    redisTemplate.execute(new SessionCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            String followeeKey &#x3D; RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">            String followerKey &#x3D; RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());</span><br><span class="line">            operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">            return operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void unfollow(int userId, int entityType, int entityId) &#123;</span><br><span class="line">    redisTemplate.execute(new SessionCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</span><br><span class="line">            String followeeKey &#x3D; RedisKeyUtil.getFolloweeKey(userId, entityType);</span><br><span class="line">            String followerKey &#x3D; RedisKeyUtil.getFollowerKey(entityType, entityId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            operations.opsForZSet().remove(followeeKey, entityId);</span><br><span class="line">            operations.opsForZSet().remove(followerKey, userId);</span><br><span class="line"></span><br><span class="line">            return operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>发布帖子</title>
      <link href="/2020/09/07/%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90/"/>
      <url>/2020/09/07/%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><p><img src="/2020/09/07/%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200907224007422.png" alt="image-20200907224007422"></p><p><img src="/2020/09/07/%E5%8F%91%E5%B8%83%E5%B8%96%E5%AD%90/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200907225126398.png" alt="image-20200907225126398"></p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>发布帖子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String addDiscussPost(String title, String content) &#123;</span><br><span class="line">        User user &#x3D; hostHolder.getUser();</span><br><span class="line">        if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return CommunityUtil.getJSONString(403, &quot;你还没有登录哦!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DiscussPost post &#x3D; new DiscussPost();</span><br><span class="line">        post.setUserId(user.getId());</span><br><span class="line">        post.setTitle(title);</span><br><span class="line">        post.setContent(content);</span><br><span class="line">        post.setCreateTime(new Date());</span><br><span class="line">        discussPostService.addDiscussPost(post);</span><br></pre></td></tr></table></figure><p>帖子详情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;detail&#x2F;&#123;discussPostId&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">public String getDiscussPost(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Model model, Page page) &#123;</span><br><span class="line">    &#x2F;&#x2F; 帖子</span><br><span class="line">    DiscussPost post &#x3D; discussPostService.findDiscussPostById(discussPostId);</span><br><span class="line">    model.addAttribute(&quot;post&quot;, post);</span><br><span class="line">    &#x2F;&#x2F; 作者</span><br><span class="line">    User user &#x3D; userService.findUserById(post.getUserId());</span><br><span class="line">    model.addAttribute(&quot;user&quot;, user);</span><br><span class="line">    &#x2F;&#x2F; 点赞数量</span><br><span class="line">    long likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);</span><br><span class="line">    model.addAttribute(&quot;likeCount&quot;, likeCount);</span><br><span class="line">    &#x2F;&#x2F; 点赞状态</span><br><span class="line">    int likeStatus &#x3D; hostHolder.getUser() &#x3D;&#x3D; null ? 0 :</span><br><span class="line">            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);</span><br><span class="line">    model.addAttribute(&quot;likeStatus&quot;, likeStatus);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 评论分页信息</span><br><span class="line">    page.setLimit(5);</span><br><span class="line">    page.setPath(&quot;&#x2F;discuss&#x2F;detail&#x2F;&quot; + discussPostId);</span><br><span class="line">    page.setRows(post.getCommentCount());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 评论: 给帖子的评论</span><br><span class="line">    &#x2F;&#x2F; 回复: 给评论的评论</span><br><span class="line">    &#x2F;&#x2F; 评论列表</span><br><span class="line">    List&lt;Comment&gt; commentList &#x3D; commentService.findCommentsByEntity(</span><br><span class="line">            ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());</span><br><span class="line">    &#x2F;&#x2F; 评论VO列表</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; commentVoList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (commentList !&#x3D; null) &#123;</span><br><span class="line">        for (Comment comment : commentList) &#123;</span><br><span class="line">            &#x2F;&#x2F; 评论VO</span><br><span class="line">            Map&lt;String, Object&gt; commentVo &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F; 评论</span><br><span class="line">            commentVo.put(&quot;comment&quot;, comment);</span><br><span class="line">            &#x2F;&#x2F; 作者</span><br><span class="line">            commentVo.put(&quot;user&quot;, userService.findUserById(comment.getUserId()));</span><br><span class="line">            &#x2F;&#x2F; 点赞数量</span><br><span class="line">            likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">            commentVo.put(&quot;likeCount&quot;, likeCount);</span><br><span class="line">            &#x2F;&#x2F; 点赞状态</span><br><span class="line">            likeStatus &#x3D; hostHolder.getUser() &#x3D;&#x3D; null ? 0 :</span><br><span class="line">                    likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">            commentVo.put(&quot;likeStatus&quot;, likeStatus);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 回复列表</span><br><span class="line">            List&lt;Comment&gt; replyList &#x3D; commentService.findCommentsByEntity(</span><br><span class="line">                    ENTITY_TYPE_COMMENT, comment.getId(), 0, Integer.MAX_VALUE);</span><br><span class="line">            &#x2F;&#x2F; 回复VO列表</span><br><span class="line">            List&lt;Map&lt;String, Object&gt;&gt; replyVoList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            if (replyList !&#x3D; null) &#123;</span><br><span class="line">                for (Comment reply : replyList) &#123;</span><br><span class="line">                    Map&lt;String, Object&gt; replyVo &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">                    &#x2F;&#x2F; 回复</span><br><span class="line">                    replyVo.put(&quot;reply&quot;, reply);</span><br><span class="line">                    &#x2F;&#x2F; 作者</span><br><span class="line">                    replyVo.put(&quot;user&quot;, userService.findUserById(reply.getUserId()));</span><br><span class="line">                    &#x2F;&#x2F; 回复目标</span><br><span class="line">                    User target &#x3D; reply.getTargetId() &#x3D;&#x3D; 0 ? null : userService.findUserById(reply.getTargetId());</span><br><span class="line">                    replyVo.put(&quot;target&quot;, target);</span><br><span class="line">                    &#x2F;&#x2F; 点赞数量</span><br><span class="line">                    likeCount &#x3D; likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, reply.getId());</span><br><span class="line">                    replyVo.put(&quot;likeCount&quot;, likeCount);</span><br><span class="line">                    &#x2F;&#x2F; 点赞状态</span><br><span class="line">                    likeStatus &#x3D; hostHolder.getUser() &#x3D;&#x3D; null ? 0 :</span><br><span class="line">                            likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, reply.getId());</span><br><span class="line">                    replyVo.put(&quot;likeStatus&quot;, likeStatus);</span><br><span class="line"></span><br><span class="line">                    replyVoList.add(replyVo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            commentVo.put(&quot;replys&quot;, replyVoList);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 回复数量</span><br><span class="line">            int replyCount &#x3D; commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());</span><br><span class="line">            commentVo.put(&quot;replyCount&quot;, replyCount);</span><br><span class="line"></span><br><span class="line">            commentVoList.add(commentVo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(&quot;comments&quot;, commentVoList);</span><br><span class="line"></span><br><span class="line">    return &quot;&#x2F;site&#x2F;discuss-detail&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加评论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">comment.setUserId(hostHolder.getUser().getId());</span><br><span class="line">comment.setStatus(0);</span><br><span class="line">comment.setCreateTime(new Date());</span><br><span class="line">commentService.addComment(comment);</span><br></pre></td></tr></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过滤敏感词</title>
      <link href="/2020/09/07/%E8%BF%87%E6%BB%A4%E6%95%8F%E6%84%9F%E8%AF%8D/"/>
      <url>/2020/09/07/%E8%BF%87%E6%BB%A4%E6%95%8F%E6%84%9F%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>树结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private class TrieNode &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 关键词结束标识</span><br><span class="line">    private boolean isKeywordEnd &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 子节点(key是下级字符,value是下级节点)</span><br><span class="line">    private Map&lt;Character, TrieNode&gt; subNodes &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public boolean isKeywordEnd() &#123;</span><br><span class="line">        return isKeywordEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKeywordEnd(boolean keywordEnd) &#123;</span><br><span class="line">        isKeywordEnd &#x3D; keywordEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 添加子节点</span><br><span class="line">    public void addSubNode(Character c, TrieNode node) &#123;</span><br><span class="line">        subNodes.put(c, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取子节点</span><br><span class="line">    public TrieNode getSubNode(Character c) &#123;</span><br><span class="line">        return subNodes.get(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个敏感词添加到前缀树中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将一个敏感词添加到前缀树中</span><br><span class="line">private void addKeyword(String keyword) &#123;</span><br><span class="line">    TrieNode tempNode &#x3D; rootNode;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; keyword.length(); i++) &#123;</span><br><span class="line">        char c &#x3D; keyword.charAt(i);</span><br><span class="line">        TrieNode subNode &#x3D; tempNode.getSubNode(c);</span><br><span class="line"></span><br><span class="line">        if (subNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 初始化子节点</span><br><span class="line">            subNode &#x3D; new TrieNode();</span><br><span class="line">            tempNode.addSubNode(c, subNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 指向子节点,进入下一轮循环</span><br><span class="line">        tempNode &#x3D; subNode;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置结束标识</span><br><span class="line">        if (i &#x3D;&#x3D; keyword.length() - 1) &#123;</span><br><span class="line">            tempNode.setKeywordEnd(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public String filter(String text) &#123;</span><br><span class="line">    if (StringUtils.isBlank(text)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指针1</span><br><span class="line">    TrieNode tempNode &#x3D; rootNode;</span><br><span class="line">    &#x2F;&#x2F; 指针2</span><br><span class="line">    int begin &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 指针3</span><br><span class="line">    int position &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 结果</span><br><span class="line">    StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    while (position &lt; text.length()) &#123;</span><br><span class="line">        char c &#x3D; text.charAt(position);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 跳过符号</span><br><span class="line">        if (isSymbol(c)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 若指针1处于根节点,将此符号计入结果,让指针2向下走一步</span><br><span class="line">            if (tempNode &#x3D;&#x3D; rootNode) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 无论符号在开头或中间,指针3都向下走一步</span><br><span class="line">            position++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 检查下级节点</span><br><span class="line">        tempNode &#x3D; tempNode.getSubNode(c);</span><br><span class="line">        if (tempNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 以begin开头的字符串不是敏感词</span><br><span class="line">            sb.append(text.charAt(begin));</span><br><span class="line">            &#x2F;&#x2F; 进入下一个位置</span><br><span class="line">            position &#x3D; ++begin;</span><br><span class="line">            &#x2F;&#x2F; 重新指向根节点</span><br><span class="line">            tempNode &#x3D; rootNode;</span><br><span class="line">        &#125; else if (tempNode.isKeywordEnd()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 发现敏感词,将begin~position字符串替换掉</span><br><span class="line">            sb.append(REPLACEMENT);</span><br><span class="line">            &#x2F;&#x2F; 进入下一个位置</span><br><span class="line">            begin &#x3D; ++position;</span><br><span class="line">            &#x2F;&#x2F; 重新指向根节点</span><br><span class="line">            tempNode &#x3D; rootNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 检查下一个字符</span><br><span class="line">            position++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将最后一批字符计入结果</span><br><span class="line">    sb.append(text.substring(begin));</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>登录注册</title>
      <link href="/2020/09/06/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/"/>
      <url>/2020/09/06/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="涉及数据库"><a href="#涉及数据库" class="headerlink" title="涉及数据库"></a>涉及数据库</h2><p>user</p><p><img src="/2020/09/06/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200906203352925.png" alt="image-20200906203352925"></p><p>LoginTicket</p><p><img src="/2020/09/06/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200906215039799.png" alt="image-20200906215039799"></p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map &#x3D; userService.register(user);</span><br></pre></td></tr></table></figure><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String login(String username, String password, String code, boolean rememberme,</span><br><span class="line">                       Model model, HttpServletResponse response,</span><br><span class="line">                       @CookieValue(&quot;kaptchaOwner&quot;) String kaptchaOwner)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map &#x3D; userService.login(username, password, expiredSeconds);</span><br></pre></td></tr></table></figure><h3 id="kaptcha"><a href="#kaptcha" class="headerlink" title="kaptcha"></a>kaptcha</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void getKaptcha(HttpServletResponse response&#x2F;*, HttpSession session*&#x2F;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 生成验证码</span><br><span class="line">        String text &#x3D; kaptchaProducer.createText();</span><br><span class="line">        BufferedImage image &#x3D; kaptchaProducer.createImage(text);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将验证码存入session</span><br><span class="line">        &#x2F;&#x2F; session.setAttribute(&quot;kaptcha&quot;, text);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 验证码的归属</span><br><span class="line">        String kaptchaOwner &#x3D; CommunityUtil.generateUUID();</span><br><span class="line">        Cookie cookie &#x3D; new Cookie(&quot;kaptchaOwner&quot;, kaptchaOwner);</span><br><span class="line">        cookie.setMaxAge(60);</span><br><span class="line">        cookie.setPath(contextPath);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        &#x2F;&#x2F; 将验证码存入Redis</span><br><span class="line">        String redisKey &#x3D; RedisKeyUtil.getKaptchaKey(kaptchaOwner);</span><br><span class="line">        redisTemplate.opsForValue().set(redisKey, text, 60, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将突图片输出给浏览器</span><br><span class="line">        response.setContentType(&quot;image&#x2F;png&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            OutputStream os &#x3D; response.getOutputStream();</span><br><span class="line">            ImageIO.write(image, &quot;png&quot;, os);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            logger.error(&quot;响应验证码失败:&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>验证码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (StringUtils.isNotBlank(kaptchaOwner)) &#123;</span><br><span class="line">    String redisKey &#x3D; RedisKeyUtil.getKaptchaKey(kaptchaOwner);</span><br><span class="line">    kaptcha &#x3D; (String) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) &#123;</span><br><span class="line">    model.addAttribute(&quot;codeMsg&quot;, &quot;验证码不正确!&quot;);</span><br><span class="line">    return &quot;&#x2F;site&#x2F;login&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="UserService"><a href="#UserService" class="headerlink" title="UserService"></a>UserService</h3><p>注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; register(User user)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User u &#x3D; userMapper.selectByName(user.getUsername());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册用户</span><br><span class="line">user.setSalt(CommunityUtil.generateUUID().substring(0, 5));</span><br><span class="line">user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt()));</span><br><span class="line">user.setType(0);</span><br><span class="line">user.setCreateTime(new Date());</span><br><span class="line">userMapper.insertUser(user);</span><br></pre></td></tr></table></figure><p>登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; login(String username, String password, long expiredSeconds)</span><br><span class="line">&#123;</span><br><span class="line">        ....</span><br><span class="line">        Cookie cookie &#x3D; new Cookie(&quot;ticket&quot;, map.get(&quot;ticket&quot;).toString());</span><br><span class="line">        cookie.setPath(contextPath);</span><br><span class="line">        cookie.setMaxAge(expiredSeconds);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        return &quot;redirect:&#x2F;index&quot;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 验证账号</span><br><span class="line">&#x2F;&#x2F; 验证密码</span><br><span class="line">&#x2F;&#x2F; 生成登录凭证</span><br><span class="line">&#x2F;&#x2F; 生成登录凭证</span><br><span class="line">LoginTicket loginTicket &#x3D; new LoginTicket();</span><br><span class="line">loginTicket.setUserId(user.getId());</span><br><span class="line">loginTicket.setTicket(CommunityUtil.generateUUID());</span><br><span class="line">loginTicket.setStatus(0);</span><br><span class="line">loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));</span><br><span class="line">String redisKey &#x3D; RedisKeyUtil.getTicketKey(loginTicket.getTicket());</span><br><span class="line">redisTemplate.opsForValue().set(redisKey, loginTicket);</span><br><span class="line"></span><br><span class="line">map.put(&quot;ticket&quot;, loginTicket.getTicket());</span><br><span class="line">return map;</span><br></pre></td></tr></table></figure><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AlphaInterceptor implements HandlerInterceptor</span><br><span class="line">WebMvcConfig implements WebMvcConfigurer</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 从cookie中获取凭证</span><br><span class="line">    String ticket &#x3D; CookieUtil.getValue(request, &quot;ticket&quot;);</span><br><span class="line"></span><br><span class="line">    if (ticket !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 查询凭证</span><br><span class="line">        LoginTicket loginTicket &#x3D; userService.findLoginTicket(ticket);</span><br><span class="line">        &#x2F;&#x2F; 检查凭证是否有效</span><br><span class="line">        if (loginTicket !&#x3D; null &amp;&amp; loginTicket.getStatus() &#x3D;&#x3D; 0 &amp;&amp; loginTicket.getExpired().after(new Date())) &#123;</span><br><span class="line">            &#x2F;&#x2F; 根据凭证查询用户</span><br><span class="line">            User user &#x3D; userService.findUserById(loginTicket.getUserId());</span><br><span class="line">            &#x2F;&#x2F; 在本次请求中持有用户</span><br><span class="line">            hostHolder.setUser(user);</span><br><span class="line">            &#x2F;&#x2F; 构建用户认证的结果,并存入SecurityContext,以便于Security进行授权.</span><br><span class="line">            Authentication authentication &#x3D; new UsernamePasswordAuthenticationToken(</span><br><span class="line">                    user, user.getPassword(), userService.getAuthorities(user.getId()));</span><br><span class="line">            SecurityContextHolder.setContext(new SecurityContextImpl(authentication));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">    User user &#x3D; hostHolder.getUser();</span><br><span class="line">    if (user !&#x3D; null &amp;&amp; modelAndView !&#x3D; null) &#123;</span><br><span class="line">        modelAndView.addObject(&quot;loginUser&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry.addInterceptor(loginTicketInterceptor)</span><br><span class="line">        .excludePathPatterns(&quot;&#x2F;**&#x2F;*.css&quot;, &quot;&#x2F;**&#x2F;*.js&quot;, &quot;&#x2F;**&#x2F;*.png&quot;, &quot;&#x2F;**&#x2F;*.jpg&quot;, &quot;&#x2F;**&#x2F;*.jpeg&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 论坛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些不常见的面试算法题</title>
      <link href="/2020/08/06/%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2020/08/06/%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li><p>平衡二叉搜索树插入算法</p></li><li><p>对于给定的数据，找出比这个数大的最小回文数（正反读都一样的数），如 12310 -&gt; 12321</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">leetcode 564</span><br><span class="line">public class hello &#123;&#x2F;&#x2F;100 999</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str&#x3D;&quot;271&quot;;</span><br><span class="line"></span><br><span class="line">        int len&#x3D;str.length();</span><br><span class="line">        char[] s&#x3D;str.toCharArray();</span><br><span class="line">        int flag&#x3D;0,i;</span><br><span class="line">        for(i&#x3D;len&#x2F;2-1;i&gt;&#x3D;0;--i)&#123;</span><br><span class="line">            if(s[i]&gt;s[len-1-i])&#123;flag&#x3D;1;break;&#125;</span><br><span class="line">            else if(s[i]&lt;s[len-1-i])&#123; flag&#x3D;-1;break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag!&#x3D;1)&#123;&#x2F;&#x2F;前半串要加1</span><br><span class="line">            &#x2F;&#x2F;s[(len-1)&#x2F;2]++;</span><br><span class="line">            for(i&#x3D;(len-1)&#x2F;2;i&gt;&#x3D;0;--i)&#123;&#x2F;&#x2F;199 191 999</span><br><span class="line">                s[i]++;</span><br><span class="line">                if(s[i]&gt;&#39;9&#39;)&#123;</span><br><span class="line">                    s[i]&#x3D;&#39;0&#39;;</span><br><span class="line">                &#125;else break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(s[0]&#x3D;&#x3D;&#39;0&#39;)&#123;&#x2F;&#x2F;999 9999</span><br><span class="line">                s[0]&#x3D;&#39;1&#39;;</span><br><span class="line">                len++;</span><br><span class="line">                s[len&#x2F;2]&#x3D;&#39;0&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i&#x3D;0;i&lt;len&#x2F;2;++i)</span><br><span class="line">            System.out.print((s[i])+&quot; &quot;);</span><br><span class="line">        for(i&#x3D;(len+1)&#x2F;2-1;i&gt;&#x3D;0;--i)</span><br><span class="line">            System.out.println(s[i]+&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对一个奇数位升序，偶数位降序的链表，进行排序，例如 1-&gt;100-&gt;20-&gt;80-&gt;40-&gt;30</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇偶拆分 反转 合并链表</span><br></pre></td></tr></table></figure></li><li><p>从一个数 l 一直 与 操作到 r ，怎么做最快，复杂度最小</p></li><li><p>输出交错后的链表(比如链表a-b-c-d-e,交错后输出为a-e-b-d-c)</p></li><li><p>请对3个有序数组进行归并排序</p></li></ol><ol start="7"><li><p>掷骰子走路，1～6，给定的输入n，走到第n个格子有多少种走法</p></li><li><p>青蛙跳格子，数组里元素表示该位置石头个数，每次跳3-5格，问跳出数组最少踩多少石头</p></li><li><p>.给一个正整数，表示成一个或多个不同的正整数的和，输出所有的解决方案</p></li><li><p>找出数组里出现次数大于n/k的数</p></li><li><p>给一个矩阵，从右上角往左下角一层一层斜着遍历</p></li><li><p>一个int数组，找出两个异或最大的数字，时间要求O(n)</p></li><li><p>四个int数组，从每个数组里边挑一个数，加起来等于指定数，要求打印出所有非重复的组合，要求最大n2</p></li><li><p>查找有序数组中一个目标值出现的第一次位置，没有找到返回 -1</p></li><li><p>二分查找在升序数组中找出绝对值最小的那个数</p></li><li><p>给定一个包含大写英文字母和数字的句子，找出这个句子所包含的最大的十六进制整数，返回这个整数的值。数据保证该整数在int表示范围内</p></li><li><p>字符串数组两个字符串的最小距离</p></li><li><p>实现洗牌算法</p></li><li><p>单链表高位在前、低位在后，大数计算</p></li><li><p>阶乘</p></li><li><p>合并数组</p></li><li><p>一道矩阵相乘</p></li><li><p>求连续子序列乘积为完全平方数的最大长度</p></li><li><p>定一个升序数组，可能会有重复的数字，将数组里的数平方后，有多少不同的数</p></li><li><p>:两个大数字符串求和输出字符串</p></li><li><p>任意数组中的第一个缺失的正整数</p></li><li><p>字符串反转</p></li><li><p>.给你一个数组和一个target，找出和是target整数倍的连续子串</p></li><li><p>I am student 返回 student am I 不用split</p></li><li><p>给一个分数n/m，如果这个分数是无线循环小数，找出循环位。</p></li><li><p>排序数组，平方后，数组当中有多少不同的数字（相同算一个）</p></li><li><p>一个数据先递增再递减，找出数组不重复的个数，比如 [1, 3, 9, 1]，结果为3，不能使用额外空间，复杂度o(n)</p></li><li><p>某一个大文件被拆成了N个小文件，每个小文件编号从0至N-1，相应大小分别记为S(i)。给定磁盘空间为C，试实现一个函数从N个文件中连续选出若干个文件拷贝到磁盘中，使得磁盘剩余空间最小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ol><ol start="34"><li><p>给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3</p></li><li><p>算法题，一个有序数组，从随机一位截断，把前段放在后边，如 4 5 6 7 1 2 3求中位数</p></li><li><p>链表实现一个栈</p></li><li><p>求完全二叉树的节点个数，小于O(n)，并分析复杂度</p></li><li><p>写一个函数，求平方根，函数参数为目标数字和精度，测试案例 fn(4.1,0.001) fn(501.1,0.001) fn(0.045,0.001)</p></li><li><p>给定一个 0-4随机数生成器 如何生成0-6随机数</p></li><li><p>中文数字转阿拉伯数字，字符串处理问题</p><p>中文数字格式：一万三千五百四十一      </p><p>阿拉伯数字格式：13541      </p><p>中文数字中要分单位和数字分别处理，可以用两个数组分别保存中文数字和中文单位，每次循环扫描给的中文数字，去匹配对应的数字。中文数字数字可以用数组下标对应数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class Solution&#123;</span><br><span class="line">   static char[] cnArr &#x3D; &#123;&#39;零&#39;,&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;&#125;;</span><br><span class="line">   static char[] chArr &#x3D; &#123;&#39;十&#39;, &#39;百&#39;, &#39;千&#39;, &#39;万&#39;, &#39;亿&#39;&#125;;</span><br><span class="line">public static int chineseNumToArabicNum(String chineseNum) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    int temp &#x3D; 1;&#x2F;&#x2F;存放一个单位的数字如：十万</span><br><span class="line">    int count &#x3D; 0;&#x2F;&#x2F;判断是否有表示单位的文字</span><br><span class="line">    for (int i &#x3D; 0; i &lt; chineseNum.length(); i++) &#123;</span><br><span class="line">        boolean b &#x3D; true;&#x2F;&#x2F;判断是否是单位</span><br><span class="line">        char c &#x3D; chineseNum.charAt(i);</span><br><span class="line">        for (int j &#x3D; 0; j &lt; cnArr.length; j++) &#123;&#x2F;&#x2F;非单位，即数字</span><br><span class="line">            if (c &#x3D;&#x3D; cnArr[j]) &#123;</span><br><span class="line">                if (count !&#x3D; 0) &#123;&#x2F;&#x2F;添加下一个单位之前，先把上一个单位值添加到结果中</span><br><span class="line">                    result +&#x3D; temp;</span><br><span class="line">                    temp &#x3D; 1;</span><br><span class="line">                    count &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 下标+1，就是对应的值</span><br><span class="line">                temp &#x3D; j;</span><br><span class="line">                b &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (b) &#123;&#x2F;&#x2F;单位&#123;&#39;十&#39;,&#39;百&#39;,&#39;千&#39;,&#39;万&#39;,&#39;亿&#39;&#125;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; chArr.length; j++) &#123;</span><br><span class="line">                if (c &#x3D;&#x3D; chArr[j]) &#123;</span><br><span class="line">                    switch (j) &#123;</span><br><span class="line">                        case 0:</span><br><span class="line">                            temp *&#x3D; 10;</span><br><span class="line">                            break;</span><br><span class="line">                        case 1:</span><br><span class="line">                            temp *&#x3D; 100;</span><br><span class="line">                            break;</span><br><span class="line">                        case 2:</span><br><span class="line">                            temp *&#x3D; 1000;</span><br><span class="line">                            break;</span><br><span class="line">                        case 3:</span><br><span class="line">                            temp *&#x3D; 10000;</span><br><span class="line">                            break;</span><br><span class="line">                        case 4:</span><br><span class="line">                            temp *&#x3D; 100000000;</span><br><span class="line">                            break;</span><br><span class="line">                        default:</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &#x3D;&#x3D; chineseNum.length() - 1) &#123;&#x2F;&#x2F;遍历到最后一个字符</span><br><span class="line">            result +&#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三个线程循环打印ABC**</p></li><li><pre><code>public class hello {    //1-&gt;100-&gt;20-&gt;80-&gt;40-&gt;30    1-&gt;20-30-&gt;40-&gt;80-&gt;100    static class ListNode    {        int val;        ListNode(int x)        {            val=x;        }        ListNode next;    }    public static void main(String[] args) {        ListNode l1=new ListNode(1);        ListNode l2=new ListNode(100);        ListNode l3=new ListNode(20);        ListNode l4=new ListNode(80);        l1.next=l2;        l2.next=l3;        l3.next=l4;        l4.next=null;//        while(l1!=null)//        {//            System.out.println(l1.val);//            l1=l1.next;//        }        help(l1);        while(l1!=null)        {            System.out.println(l1.val);            l1=l1.next;        }    }    public static ListNode help(ListNode head)    {        if(head==null || head.next==null)        {            return head;        }        ListNode h1=head,t1=head;        ListNode h2=head.next,t2=h2;        while(t1.next!=null &amp;&amp; t2.next!=null)        {            t1.next=t2.next;            t1=t1.next;            t2.next=t1.next;            t2=t2.next;        }        t1.next=null;        ListNode temp=reverse(h2);        ListNode res=mergeTwoLists(temp,h1);        return res;    }    public static ListNode reverse(ListNode head)    {       if(head==null || head.next==null) return head;       ListNode temp=reverse(head.next);       head.next.next=head;       head.next=null;       return temp;    }    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {        if(l1==null) return l2;        if(l2==null) return l1;        ListNode dummy=new ListNode(0);        ListNode curr=dummy;        ListNode p=l1,q=l2;        while(p!=null&amp;&amp;q!=null)        {            int x=p.val;            int y=q.val;            if(x&lt;y)            {                curr.next=p;                p=p.next;            }            else            {                curr.next=q;                q=q.next;            }            curr=curr.next;        }        if(p!=null) curr.next=p;        if(q!=null) curr.next=q;        return dummy.next;    }}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">43. **平方后，数组当中有多少不同的数字**</span><br></pre></td></tr></table></figure>public class Solution {public int diffSquareNum(int nums[]) {    int n = nums.length;    if(n == 0 || nums == null){        return 0;    }    int sum = 0;    int left = 0;    int right = n - 1;    while(left &lt;= right){        if(nums[left] + nums[right] == 0){            sum++;            int temp = nums[left];            //这里开始去掉后面重复的数字            while(left &lt;= right &amp;&amp; nums[left] == temp)                left++;            while(left &lt;= right &amp;&amp; nums[right] == -temp)                right--;        }        else if(nums[left] + nums[right] &lt; 0){            sum++;            int temp = nums[left];            while(left &lt;= right &amp;&amp; nums[left] == temp)                left++;        }        else {            sum++;            int temp = nums[right];            while(left &lt;= right &amp;&amp; nums[right] == temp)                right--;        }    }    return sum;}}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">43</span><br><span class="line"></span><br><span class="line">给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，</span><br></pre></td></tr></table></figure>public class hello {public static void main(String[] args) {char[] c={&apos;a&apos;,&apos;c&apos;,&apos;b&apos;,&apos;d&apos;};String s=&quot;tbcacbdata&quot;;int res=help(c,s);System.out.println(res);}public static int help(char[] ch,String s){    if(ch.length &gt; s.length()){        return -1;    }    for(int i = 0; i &lt;= s.length() - ch.length+1; i++){        //每次匹配长度为m的子串        if(matchs(ch,s.substring(i,i+ch.length)))            return i;    }    return -1;}private static boolean matchs(char[] ch,String s){    for(int i = 0; i &lt; s.length();i++){        //返回-1说明字符串中不包含这个字符        if(s.indexOf(ch[i]) == -1)            return false;    }    return true;}</code></pre></li></ol><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">44.一个有序数组，从随机一位截断，把前段放在后边，如 4 5 6 7 1 2 3求中位数</span><br></pre></td></tr></table></figure><p>public class findNumInRotateArr {</p><pre><code>public static double minNumberInRotateArray(int[] nums) {    if (nums == null || nums.length == 0) {        return 0;    }    int left = 0;    int right = nums.length - 1;    while (left &lt; right) {        int mid = left + ((right - left) &gt;&gt; 1);        if (nums[mid] &lt; nums[right]) {            right = mid;        } else if (nums[mid] &gt; nums[right]) {            left = mid + 1;        } else {            right--;        }    }    int size = nums.length;    if (size % 2 == 1) {        return nums[(left + size / 2) % size];    } else {        return (double) (nums[(left + size / 2) % size] + nums[(left + (size - 1) / 2) % size]) / 2;    }}public static void main(String[] args) {    int[] arr = {6, 7, 8, 1, 2, 3, 4, 5};    System.out.println(minNumberInRotateArray(arr));}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">45.给定一个未排序的整数数组，找出最长连续序列的长度。</span><br><span class="line"></span><br><span class="line">要求算法的时间复杂度为 *O(n)*。</span><br></pre></td></tr></table></figure><p>输入: [100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">46.高考成绩2000万数据，分数0-750，如何快速知道你的排名，如何知道任一分数排名 ---&gt;桶排序</span><br><span class="line"></span><br><span class="line">桶[排序]()    (Bucket sort)的工作的原理：假设输入数据   服从均匀分布   ，将数据分到有限数量的桶里，每个桶再分别[排序]()（有可能再使用别的[排序]()[算法]()或是以递归方式继续使用桶[排序]()进行排）。   </span><br><span class="line"></span><br><span class="line">​    [算法]()描述：   </span><br><span class="line"></span><br><span class="line">​    设置一个定量的数组当作空桶；   </span><br><span class="line"></span><br><span class="line">​    遍历输入数据，并且把数据一个一个放到对应的桶里去；   </span><br><span class="line"></span><br><span class="line">​    对每个不是空的桶进行[排序]()；   </span><br><span class="line"></span><br><span class="line">​    从不是空的桶里把排好序的数据拼接起来。</span><br></pre></td></tr></table></figure><p>public class Solution {<br>    public ArrayList<Integer> bucketSort(int[] scores){<br>      //先确定最大最小值，来确定范围<br>      int max = Integer.MIN_VALUE;<br>      int min = Integer.MAX_VALUE;<br>      for(int i = 0; i &lt; scores.length;i++){<br>          max = Math.max(max,scores[i]);<br>          min = Math.min(min,scores[i]);<br>      }<br>      //计算出桶数<br>      //int bucketNum = (max - min)/scores.length + 1;<br>      //这里直接给出751个桶<br>      int bucketNum = 751;<br>      ArrayList&lt;ArrayList<Integer>&gt; list = new ArrayList&lt;&gt;(bucketNum);<br>      for(int i = 0; i &lt; bucketNum; i++){<br>          list.add(new ArrayList<Integer>());<br>      }</Integer></Integer></Integer></p><pre><code>  //将每个元素放入桶  for(int i = 0; i &lt; scores.length;i++){      //本题中这里放元素也可以简化      //list.get((scores[i] - min)/bucketNum).add(scores[i]);      list.get(scores[i]).add(scores[i]);  }  //桶内排序,本题中可以省略这一步  for(int i = 0; i&lt; list.size();i++){      Collections.sort(list.get(i));  }   return list;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">47.</span><br><span class="line"></span><br><span class="line">**最大栈（最小栈）**</span><br></pre></td></tr></table></figure><p>使用辅助栈：<br>public class MaxStack{<br>    private Stack<Integer> stack;<br>    private Stack<Integer> helper;<br>    public MaxStack(){<br>        stack = new Stack&lt;&gt;();<br>        helper = new Stack&lt;&gt;();<br>    }<br>    public void push(int x) {<br>        if(helper.isEmpty() || helper.peek() &lt;= x){<br>            helper.push(x);<br>        }<br>        stack.push(x);<br>    }<br>    public void pop(){<br>        if(stack.peek() == helper.peek()){<br>            helper.pop();<br>        }<br>        stack.pop();<br>    }<br>    public int peek(){<br>        if(!helper.isEmpty()){<br>            return stack.peek();<br>        }<br>        throw new RuntimeException(“栈中元素为空”);</Integer></Integer></p><pre><code>}public int getMax(){    if(!helper.isEmpty()){        return helper.peek();    }    throw new RuntimeException(&quot;最大值栈中元素为空&quot;);}</code></pre><p>}<br>用最大值标记，存入数据栈中，空间复杂度降到O(1)<br>public class MaxStack {<br>    private Stack<Integer> stack;<br>    public MaxStack(){<br>        stack = new Stack&lt;&gt;();<br>    }<br>    int max = Integer.MIN_VALUE;<br>    public void push(int x){<br>        if(max &lt;= x){<br>            if(!stack.isEmpty()){<br>                stack.push(max);<br>            }<br>            max = x;<br>        }<br>        stack.push(x);<br>    }<br>    public void pop(){<br>        if(stack.peek() == max){<br>            stack.pop();<br>            max = stack.pop();<br>        }else{<br>            stack.pop();<br>        }<br>    }<br>    public int getMax(){<br>        return max;<br>    }<br>}</Integer></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">48. 链表实现一个栈</span><br></pre></td></tr></table></figure><p>public class ListNode{<br>    int val;<br>    ListNode next;<br>    ListNode(int val){<br>        this.val =val;<br>    }<br>}<br>public class ListToStack{<br>    public ListToStack(){<br>        ListNode head;<br>    }<br>    public void push(int x){<br>        ListNode node = new ListNode(x);<br>        node.next = head.next;<br>        head.next = node;<br>    }<br>    public int pop(){<br>        ListNode node = head.next;<br>        head.next = node.next;<br>        node.next = null;<br>        return node.val;<br>    }<br>    public int peek(){<br>        return head.next.val;<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 48.一个形如 123456789101112……的字符串，输入一个n（很大很大），输出字符串第n个字符</span><br><span class="line"></span><br><span class="line">## 49.版本数字比较，比如&quot;1.10.0&quot;版本比&quot;1.8.1&quot;版本新，不允许使用split等函数</span><br><span class="line"></span><br><span class="line">## 50.中缀表达式转后缀</span><br><span class="line"></span><br><span class="line">1、任何中缀表达式都由运算数，运算符，括号（大，中，小），这三部分组成。</span><br><span class="line"></span><br><span class="line">2、从中缀表达式的左边开始扫描（脑中自己想像的），若遇到运算数时，则直接将其输出（不压入堆栈）。</span><br><span class="line"></span><br><span class="line">3、若遇到左括号，则将其压栈。</span><br><span class="line"></span><br><span class="line">4、若遇到右括号，表达括号内的中缀表达式已经扫描完毕。这时需将栈顶的运算符依次弹出并输出，直至遇到左括号[左括号弹出但不输出]。</span><br><span class="line"></span><br><span class="line">5、若遇到的是运算符：a、如果该运算符的优先级大于栈顶运算符的优先级时，将其压栈</span><br><span class="line"></span><br><span class="line">​                  b、如果该运算符的优先级小于栈顶运算符的优先级时，将栈顶运算符弹出并输出，接着和新的栈顶运算 符比较，若大于，则将其压栈，若小于，继续将栈顶运算符弹出并输出......(一直递归下去，直至运算符大于栈顶云算符为止)。</span><br><span class="line"></span><br><span class="line">6、最后一步，若扫描到中缀表达式的末尾[即扫描结束]，若堆栈中还有存留的运算符依次弹出并输出即可。</span><br></pre></td></tr></table></figure><p>public class hello {//100 999</p><pre><code>public static void calculate(String string) {    Stack&lt;String&gt; operator = new Stack&lt;&gt;();//操作符栈    List&lt;String&gt; list = new ArrayList&lt;&gt;();//结果集    char[] s = string.toCharArray();    //遍历表达式    // 1+(2-4*3)    // 1 2 4 3 * - +    // 1+(2-4*3)*5    // 1 2 4 3 * - +5-    for (int i = 0; i &lt; s.length; i++) {        if (s[i] == &apos; &apos;)            continue;        if (s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;){            StringBuilder stringBuilder = new StringBuilder();            while (i &lt; s.length &amp;&amp; s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;){                stringBuilder.append(s[i]);                i++;            }            i--;            list.add(stringBuilder.toString());        }//正则表达式匹配数字，对应思路1        else if (s[i] == &apos;(&apos;){//对应思路2            operator.push(String.valueOf(s[i]));        }else if (s[i] == &apos;)&apos;){//对应思路3            while (!operator.peek().equals(&quot;(&quot;)){                list.add(operator.pop());            }            operator.pop();        }else{//对应思路4            while (!operator.isEmpty() &amp;&amp; priority(operator.peek()) &gt;= priority(String.valueOf(s[i]))){                list.add(operator.pop());            }            operator.push(String.valueOf(s[i]));        }    }    // 1+(2-4*3)  1 2 4 3 * - +    // 1+(2*4-3)  1 2 4 * 3 - +    while (!operator.isEmpty())        list.add(operator.pop());    System.out.println(list.size());</code></pre><p>//        Stack<Integer> nums = new Stack&lt;&gt;();<br>//        for (int i = 0; i &lt; list.size(); i++) {<br>//            if (list.get(i).equals(“+”)){<br>//                nums.push(nums.pop() + nums.pop());<br>//            }else if (list.get(i).equals(“-“)){<br>//                nums.push(-(nums.pop() - nums.pop()));<br>//            }else if (list.get(i).equals(“*”)){<br>//                nums.push(nums.pop() * nums.pop());<br>//            }else if (list.get(i).equals(“/“)){<br>//                int num1 = nums.pop();<br>//                int num2 = nums.pop();<br>//                nums.push(num2 / num1);<br>//            } else<br>//                nums.push(Integer.parseInt(list.get(i)));<br>//        }<br>//<br>//        return nums.pop();//弹出栈中元素返回结果<br>    }<br>    //计算符优先级<br>    private static int priority(String oper){<br>        if (oper.equals(“+”) || oper.equals(“-“))<br>            return 0;<br>        else if (oper.equals(“*”) || oper.equals(“/“))<br>            return 1;<br>        else return -1;<br>    }<br>    public static void main(String[] args) {<br>    String s=”1+(2*4-3)”;<br>    calculate(s);<br>    }<br>}</Integer></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 51.滑动窗口</span><br><span class="line"></span><br><span class="line">某一个大文件被拆成了N个小文件，每个小文件编号从0至N-1，相应大小分别记为S(i)。给定磁盘空间为C，试实现一个函数从N个文件中连续选出若干个文件拷贝到磁盘中，使得磁盘剩余空间最小。 </span><br><span class="line"></span><br><span class="line">滑动窗口   ：每次记录窗口内的总和，和小于C，记录剩余空间，再窗口右端右移，和大于C，就窗口左端右移，小于C情况下比较剩余空间取最小值。</span><br></pre></td></tr></table></figure><p>public class Solution {<br>    public int[] findMin(int[] s,int c){<br>        int i = 0;<br>        int j = 0;<br>        int minValue = Integer.MAX_VALUE;<br>        int sum = 0;<br>        int left = 0;<br>        int right = 0;<br>        while(j &lt;= s.length){<br>            if(sum &lt;= c){<br>               j++;<br>               sum += s[j];<br>               minValue = Math.min(minValue,c - sum);<br>               if(minValue == c - sum){<br>                   left = i;<br>                   right = j;<br>               }<br>            }else{<br>                i++;<br>                sum -= s[i];<br>            }<br>        }<br>        int nums = new int[right - left];<br>        for(int k = left;k &lt; right;k++){<br>            nums[k - left] = s[k];<br>        }<br>        return nums;<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">52.求有序链表的中位数</span><br></pre></td></tr></table></figure><p>public class Test {<br>    //【快慢指针————求一个有序链表的中位数】<br>    public static double sortedListMedian(ListNode head) {<br>        if(head == null)<br>            System.out.println(“链表不能为空！”);<br>        ListNode slow = head, fast = head;<br>        while(fast.next != null &amp;&amp; fast.next.next != null) {<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        }<br>        if(fast.next == null)       //说明链表有奇数个节点，此时slow正好是中位数<br>            return slow.val * 1.0;<br>        else                        //说明链表有偶数个节点，此时(slow+slow.next)/2是中位数<br>            return (slow.val + slow.next.val) / 2.0;<br>    }</p><pre><code>//返回由一个数组生成的链表的头结点private static ListNode makeListByArray(int[] array) {    ListNode dummyHead = new ListNode(-1);    ListNode cur = dummyHead;    for (int i = 0; i &lt; array.length; i++) {        cur.next = new ListNode(array[i]);        cur = cur.next;    }    return dummyHead.next;}//主函数public static void main(String[] args) {    int[] array = {0,1,2,3,4,5};    ListNode head = makeListByArray(array);    double ans = sortedListMedian(head);    System.out.println(ans);}</code></pre><p>}</p><p>// 链表节点定义<br>class ListNode {<br>    int val;<br>    ListNode next;</p><pre><code>public ListNode(int val, ListNode next) {    this.val = val;    this.next = next;}public ListNode(int val) {    this(val,null);}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">53.**题目：合并K个有序数组</span><br></pre></td></tr></table></figure><p>输入: [[1,2,3], [1,2]]<br>输出: [1,1,2,2,3]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 O(N log k) 的时间复杂度内完成：*N* 是所有数组包含的整数总数量。***k\* 是数组的个数**。</span><br><span class="line"></span><br><span class="line">解法：N个数组进行两两合并，合并后的数组再继续执行合并过程，最后合成N*M的有序数组。可以认为合并这个递归过程发生了logN次，每一次合并的过程都是N*M个数合并，所以每一次合并的时间复杂度为N*M,总的时间复杂度就是N*M*logN</span><br></pre></td></tr></table></figure><p>public class hello {//100 999</p><pre><code>public static void main(String[] args) {    int[][] arr={{1,2,3},{5,6},{3,4},{1,3}};    int[] res=mergekSortedArrays(arr);    System.out.println(res);}public static int[] mergekSortedArrays(int[][] arrays) {    // write your code here    if(arrays == null || arrays.length == 0)        return null;    return helper(arrays, 0, arrays.length-1);}private static int[] helper(int[][] arrays, int l, int r){    int mid = l + (r-l)/2;    if(l&lt;r)    {        int[] left = helper(arrays, l, mid);        int[] right = helper(arrays, mid+1, r);        return merge2Arrays(left, right);    }    return arrays[l];}private static int[] merge2Arrays(int[] a, int[] b){    int[] res = new int[a.length + b.length];    int i=0, j=0;    for(int k=0; k&lt;res.length; k++){        if(i &gt;= a.length)            res[k] = b[j++];        else if(j &gt;= b.length)            res[k] = a[i++];        else if(a[i] &lt; b[j])            res[k] = a[i++];        else            res[k] = b[j++];    }    return res;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public class Solution {<br>    /**<br>     * @param arrays: k sorted integer arrays<br>     * @return: a sorted array<br>     */<br>    public int[] mergekSortedArrays(int[][] arrays) {<br>        // write your code here<br>            if(arrays == null || arrays.length == 0)<br>                return null;</p><pre><code>        return helper(arrays, 0, arrays.length-1);}private int[] helper(int[][] arrays, int l, int r){    if(l == r)        return arrays[l];    if(l + 1 == r)        return merge2Arrays(arrays[l], arrays[r]);    int mid = l + (r-l)/2;    int[] left = helper(arrays, l, mid);    int[] right = helper(arrays, mid+1, r);    return merge2Arrays(left, right);}private int[] merge2Arrays(int[] a, int[] b){    int[] res = new int[a.length + b.length];    int i=0, j=0;    for(int k=0; k&lt;res.length; k++){        if(i &gt;= a.length)            res[k] = b[j++];        else if(j &gt;= b.length)            res[k] = a[i++];        else if(a[i] &lt; b[j])            res[k] = a[i++];        else            res[k] = b[j++];    }    return res;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">54.无序数组有多少个和为K的子数组</span><br></pre></td></tr></table></figure><p>双指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">55.因子分解</span><br><span class="line"></span><br><span class="line">给一个正数N，求这个N的所有的因子分解；</span><br><span class="line"></span><br><span class="line">N &#x3D; 12；</span><br><span class="line"></span><br><span class="line">Ans &#x3D; &#123;12&#125;,&#123;6,2&#125;,&#123;3,4&#125;,&#123;3,2,2&#125;</span><br><span class="line"></span><br><span class="line">解法：递归</span><br></pre></td></tr></table></figure><p>package backtracking;</p><p>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.List;</p><p>// <a href="https://leetcode.com/problems/factor-combinations/" target="_blank" rel="noopener">https://leetcode.com/problems/factor-combinations/</a><br>public class FactorCombinations {</p><p>  public static void main(String[] args) {<br>    FactorCombinations obj = new FactorCombinations();<br>    int n = 12;<br>    List&lt;List<Integer>&gt; resultList = obj.getFactors(12);<br>    System.out.println(Arrays.toString(resultList.toArray()));<br>  }</Integer></p><p>  public List&lt;List<Integer>&gt; getFactors(int n) {<br>    List&lt;List<Integer>&gt; resultList = new ArrayList&lt;List<Integer>&gt;();<br>    // DFS<br>    dfs(resultList, new ArrayList<Integer>(), n, 2);<br>    //dfs1(resultList, new ArrayList<Integer>(), n, 2);</Integer></Integer></Integer></Integer></Integer></p><pre><code>return resultList;</code></pre><p>  }</p><p>  private void dfs(List&lt;List<Integer>&gt; resultList, List<Integer> list, int n, int start) {<br>    // exit<br>    if (n == 1) {<br>      if (list.size() &gt; 1) {<br>        resultList.add(new ArrayList<Integer>(list));<br>      }</Integer></Integer></Integer></p><pre><code>  return;}for (int i = start; i &lt;= n; i++) {  if (n % i == 0) {    list.add(i);    dfs(resultList, list, n / i, i);    list.remove(list.size() - 1);  }}</code></pre><p>  }</p><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">56.有一个日志文件，记录用户登录抖音、登出抖音的时间，求每一时刻在线人数 </span><br><span class="line"></span><br><span class="line">   格式为uid login_time logout_time  </span><br><span class="line"></span><br><span class="line">   输入: logs &#x3D; [[1, 0, 5], [2, 0, 6], [3, 0, 3], [4, 1, 2], [5, 1, 3], [6, 2, 3], [7, 3, 4], [8, 4, 6]]  </span><br><span class="line"></span><br><span class="line">   输出: [3, 5, 5, 3, 3, 2, 0]（我只写了O(N*M),要求时间复杂夫O(N),还没想到解法，面试官最后说可以用[动态规划]()）</span><br><span class="line"></span><br><span class="line">57. String的ip地址转int？</span><br><span class="line"></span><br><span class="line">[算法题](https:&#x2F;&#x2F;www.nowcoder.com&#x2F;jump&#x2F;super-jump&#x2F;word?word&#x3D;算法题)，实现 一个IP地址（10.101.102.103）转成int类型数据。 （IP地址是32个比特，int也是32个比特）</span><br><span class="line"></span><br><span class="line">58.前序中序求后续，没有建立二叉树</span><br></pre></td></tr></table></figure><p>/**</p><ul><li>Definition for a binary tree node.</li><li>public class TreeNode {</li><li>int val;</li><li>TreeNode left;</li><li>TreeNode right;</li><li>TreeNode(int x) { val = x; }</li><li>}</li><li>/<br>class Solution {<br>  int[] post;<br>  int idx;<br>  public TreeNode buildTree(int[] preorder, int[] inorder) {<pre><code>if(preorder==null||preorder.length==0||inorder==null||inorder.length==0||preorder.length!=inorder.length) return null;post=new int[preorder.length];idx=post.length-1;help(preorder,0,preorder.length-1,inorder,0,inorder.length-1,0,post.length-1);for(int i:post){    System.out.print(&quot; &quot;+i)</code></pre>;        }<pre><code>return null;}// 前序 3 9 20 15 7 //// 中序 9 3 15 20 7// 后续 9 15 7 20 3 //  private void help(int[] preorder,int ps,int pd,int[] inorder,int is,int id,int pLeft,int pRight){    if(ps&gt;pd || is&gt;id) return;    int index=0;    while(preorder[ps]!=inorder[is+index]) index++;    post[pRight]=preorder[ps];    //idx-             help(preorder,ps+1,ps+index,inorder,is,is+index-1,pLeft,pLeft+index-1);    //index-1;    help(preorder,ps+index+1,pd,inorder,is+index+1,id,pLeft+index,pRight-1);   // return root;}</code></pre>}</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">59.交换两个对象</span><br><span class="line"></span><br><span class="line">交换俩个对象swap（Object obj1， Object obj2）&#123;&#125;</span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>投票法</title>
      <link href="/2020/08/05/%E6%8A%95%E7%A5%A8%E6%B3%95/"/>
      <url>/2020/08/05/%E6%8A%95%E7%A5%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一半"><a href="#一半" class="headerlink" title="一半"></a>一半</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int majorityElement(int[] nums) &#123;</span><br><span class="line">    int major&#x3D;nums[0];</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line">    for(int num:nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if(major&#x3D;&#x3D;num)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(count&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            major&#x3D;num;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return major;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3"><a href="#1-3" class="headerlink" title="1/3"></a>1/3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; majorityElement(int[] nums) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">        首先可以明确的一点是，这样的元素可能有0个、1个、或者2个，再没有别的情况了. </span><br><span class="line">        然后，求众数I 里的 Boyer-Moore 算法思路在这里依然可用，但需要些改动：</span><br><span class="line">        1) 满足条件的元素最多有两个，那么需要两组变量. count, major变成了</span><br><span class="line">           count1, major1; count2, major2;</span><br><span class="line">        2) 选出的两个元素，需要验证它们的出现次数是否真的满足条件.</span><br><span class="line">        **&#x2F;</span><br><span class="line">        List&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if(nums.length &lt; 1) return ret;</span><br><span class="line">        int count1 &#x3D; 0, count2 &#x3D; 0;</span><br><span class="line">        int major1 &#x3D; nums[0], major2 &#x3D; nums[0];</span><br><span class="line">        for(int num : nums) &#123;</span><br><span class="line">            if(num &#x3D;&#x3D; major1)</span><br><span class="line">                count1++;</span><br><span class="line">            else if(num &#x3D;&#x3D; major2)</span><br><span class="line">                count2++;</span><br><span class="line">            else if(count1 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                count1 &#x3D; 1;</span><br><span class="line">                major1 &#x3D; num;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(count2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                count2 &#x3D; 1;</span><br><span class="line">                major2 &#x3D; num;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count1 &#x3D; 0;</span><br><span class="line">        count2 &#x3D; 0;</span><br><span class="line">        for(int num : nums) &#123;</span><br><span class="line">            if(num &#x3D;&#x3D; major1)</span><br><span class="line">                count1++;</span><br><span class="line">            else if(num &#x3D;&#x3D; major2)</span><br><span class="line">                count2++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count1 &gt; nums.length&#x2F;3)</span><br><span class="line">            ret.add(major1);</span><br><span class="line">        if(major1 !&#x3D; major2 &amp;&amp; count2 &gt; nums.length&#x2F;3)</span><br><span class="line">            ret.add(major2);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="n-k"><a href="#n-k" class="headerlink" title="n/k"></a>n/k</h2><p>左神的代码写的很好，时间复杂度是O(N*K)，额外空间复杂度O(K)，用map集合保存K个不同的值。一、如果map的大小不超过K，遍历到相同的，value加1，不同的，添加进去。用map.containskey判断是否在容器中，比用数组方便。<br>二、如果map大小达到K，遍历到相同的，所有键的值减1，如果值变成0，要删除。这时候引出一全体键值都减1的函数，左神用了遍历map，如果要删除的键放进一个链表里。<br>三、判断map中剩下的值出现次数是否大于N/K</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class hello &#123;&#x2F;&#x2F;100 999</span><br><span class="line">    public static void printKMajor(int[] arr, int K) &#123;</span><br><span class="line">        if (K &lt; 2) &#123;</span><br><span class="line">            System.out.println(&quot;the value of K is invalid.&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; cands &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i !&#x3D; arr.length; i++) &#123;</span><br><span class="line">            if (cands.containsKey(arr[i])) &#123;</span><br><span class="line">                cands.put(arr[i], cands.get(arr[i]) + 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (cands.size() &#x3D;&#x3D; K - 1) &#123;</span><br><span class="line">                    allCandsMinusOne(cands);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cands.put(arr[i], 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; reals &#x3D; getReals(arr, cands);</span><br><span class="line">        boolean hasPrint &#x3D; false;</span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; set : cands.entrySet()) &#123;</span><br><span class="line">            Integer key &#x3D; set.getKey();</span><br><span class="line">            if (reals.get(key) &gt; arr.length &#x2F; K) &#123;</span><br><span class="line">                hasPrint &#x3D; true;</span><br><span class="line">                System.out.print(key + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(hasPrint ? &quot;&quot; : &quot;no such number.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void allCandsMinusOne(HashMap&lt;Integer, Integer&gt; map) &#123;</span><br><span class="line">        List&lt;Integer&gt; removeList &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; set : map.entrySet()) &#123;</span><br><span class="line">            Integer key &#x3D; set.getKey();</span><br><span class="line">            Integer value &#x3D; set.getValue();</span><br><span class="line">            if (value &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                removeList.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (Integer removeKey : removeList) &#123;</span><br><span class="line">            map.remove(removeKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HashMap&lt;Integer, Integer&gt; getReals(int[] arr,</span><br><span class="line">                                                     HashMap&lt;Integer, Integer&gt; cands) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; reals &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i !&#x3D; arr.length; i++) &#123;</span><br><span class="line">            int curNum &#x3D; arr[i];</span><br><span class="line">            if (cands.containsKey(curNum)) &#123;</span><br><span class="line">                reals.put(curNum,reals.getOrDefault(curNum,0)+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return reals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123; 1, 2, 3, 1, 1, 2, 1 &#125;;</span><br><span class="line">        int K &#x3D; 4;</span><br><span class="line">        printKMajor(arr, K);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树相关操作</title>
      <link href="/2020/07/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/07/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static TreeNode stringToTreeNode(String input) &#123;</span><br><span class="line">    input &#x3D; input.trim();</span><br><span class="line">    if (input.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] parts &#x3D; input.split(&quot;,&quot;);</span><br><span class="line">    String item &#x3D; parts[0];</span><br><span class="line">    TreeNode root &#x3D; new TreeNode(Integer.parseInt(item));</span><br><span class="line">    Queue&lt;TreeNode&gt; nodeQueue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    nodeQueue.add(root);</span><br><span class="line">    int index &#x3D; 1;</span><br><span class="line">    while(!nodeQueue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node &#x3D; nodeQueue.remove();</span><br><span class="line"></span><br><span class="line">        if (index &#x3D;&#x3D; parts.length) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        item &#x3D; parts[index++];</span><br><span class="line">        item &#x3D; item.trim();</span><br><span class="line">        if (!item.equals(&quot;null&quot;)) &#123;</span><br><span class="line">            int leftNumber &#x3D; Integer.parseInt(item);</span><br><span class="line">            node.left &#x3D; new TreeNode(leftNumber);</span><br><span class="line">            nodeQueue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (index &#x3D;&#x3D; parts.length) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        item &#x3D; parts[index++];</span><br><span class="line">        item &#x3D; item.trim();</span><br><span class="line">        if (!item.equals(&quot;null&quot;)) &#123;</span><br><span class="line">            int rightNumber &#x3D; Integer.parseInt(item);</span><br><span class="line">            node.right &#x3D; new TreeNode(rightNumber);</span><br><span class="line">            nodeQueue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内部类</title>
      <link href="/2020/07/24/Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2020/07/24/Java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>内部类可对同一包中其他类隐藏，内部类方法可以访问定义这个内部类的作用域中的数据，包括 private 数据。</p><p>内部类是一个编译器现象，与虚拟机无关。编译器会把内部类转换成常规的类文件，用 $ 分隔外部类名与内部类名，其中匿名内部类使用数字编号，虚拟机对此一无所知。</p><p><strong>静态内部类：</strong> 属于外部类，只加载一次。作用域仅在包内，可通过 <code>外部类名.内部类名</code> 直接访问，类内只能访问外部类所有静态属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class ClassOuter &#123;</span><br><span class="line">    private int noStaticInt &#x3D; 1;</span><br><span class="line">    private static int STATIC_INT &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    public void fun() &#123;</span><br><span class="line">        System.out.println(&quot;外部类方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class InnerClass &#123;</span><br><span class="line">        &#x2F;&#x2F;static int num &#x3D; 1; 此时编辑器会报错 非静态内部类则不能有静态成员</span><br><span class="line">        public void fun()&#123;</span><br><span class="line">            &#x2F;&#x2F;非静态内部类的非静态成员可以访问外部类的非静态变量。</span><br><span class="line">            System.out.println(STATIC_INT);</span><br><span class="line">            System.out.println(noStaticInt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class StaticInnerClass &#123;</span><br><span class="line">        static int NUM &#x3D; 1;&#x2F;&#x2F;静态内部类可以有静态成员</span><br><span class="line">        public void fun()&#123;</span><br><span class="line">            System.out.println(STATIC_INT);</span><br><span class="line">            &#x2F;&#x2F;System.out.println(noStaticInt); 此时编辑器会报 不可访问外部类的非静态变量错</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestInnerClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;非静态内部类 创建方式1</span><br><span class="line">        ClassOuter.InnerClass innerClass &#x3D; new ClassOuter().new InnerClass();</span><br><span class="line">        &#x2F;&#x2F;非静态内部类 创建方式2</span><br><span class="line">        ClassOuter outer &#x3D; new ClassOuter();</span><br><span class="line">        ClassOuter.InnerClass inner &#x3D; outer.new InnerClass();</span><br><span class="line">        &#x2F;&#x2F;静态内部类的创建方式</span><br><span class="line">        ClassOuter.StaticInnerClass staticInnerClass &#x3D; new ClassOuter.StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员内部类：</strong> 属于外部类的每个对象，随对象一起加载。不可以定义静态成员和方法，可访问外部类的所有内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    private double radius &#x3D; 0;</span><br><span class="line">    public static int count &#x3D;1;</span><br><span class="line">    public Circle(double radius) &#123;</span><br><span class="line">        this.radius &#x3D; radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    class Draw &#123;     &#x2F;&#x2F;内部类</span><br><span class="line">        public void drawSahpe() &#123;</span><br><span class="line">            System.out.println(radius);  &#x2F;&#x2F;外部类的private成员</span><br><span class="line">            System.out.println(count);   &#x2F;&#x2F;外部类的静态成员</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>局部内部类：</strong> 定义在方法内，不能声明访问修饰符，只能定义实例成员变量和实例方法，作用范围仅在声明类的代码块中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        class Inner&#123;</span><br><span class="line">            public void fun()&#123;</span><br><span class="line">                System.out.println(&quot;HelloWorld&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        new Inner().fun();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        new test().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名内部类：</strong> 只用一次的没有名字的类，可以简化代码，创建的对象类型相当于 new 的类的子类类型。用于实现事件监听和其他回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public interface Product &#123;</span><br><span class="line">    public double getPrice();</span><br><span class="line">    public String  getName();</span><br><span class="line">&#125;</span><br><span class="line">public class test1 &#123;</span><br><span class="line">    public void test (Product p)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(p.getName()+&quot;--------&quot;+p.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String [ ] args )</span><br><span class="line">    &#123;</span><br><span class="line">        test1 as&#x3D; new test1 ();</span><br><span class="line">        as.test(new Product( )&#x2F;&#x2F;此处实现接口并实现抽象方法</span><br><span class="line">        &#123;</span><br><span class="line">            public double getPrice( )&#x2F;&#x2F;实现方法</span><br><span class="line">            &#123;</span><br><span class="line">                return 8888;</span><br><span class="line">            &#125;</span><br><span class="line">            public String getName( )&#x2F;&#x2F;实现方法</span><br><span class="line">            &#123;</span><br><span class="line">                return &quot;I can do it &quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类在方法中声明，可以访问方法中的临时变量吗-为什么"><a href="#匿名内部类在方法中声明，可以访问方法中的临时变量吗-为什么" class="headerlink" title="匿名内部类在方法中声明，可以访问方法中的临时变量吗 为什么"></a>匿名内部类在方法中声明，可以访问方法中的临时变量吗 为什么</h4><ol><li><p>原因是：因为局部变量和匿名内部类的生命周期不同。</p><p>匿名内部类是创建后是存储在堆中的，而方法中的局部变量是存储在Java栈中，当方法执行完毕后，就进行退栈，同时局部变量也会消失。那么此时匿名内部类还有可能在堆中存储着，那么匿名内部类要到哪里去找这个局部变量呢？</p><p>为了解决这个问题编译器为自动地帮我们在匿名内部类中创建了一个局部变量的备份，也就是说即使方法执结束，匿名内部类中还有一个备份，自然就不怕找不到了。</p><p>但是问题又来了。如果局部变量中的a不停的在变化。那么岂不是也要让备份的a变量无时无刻的变化。为了保持局部变量与匿名内部类中备份域保持一致。编译器不得不规定死这些局部域必须是常量，一旦赋值不能再发生变化了。所以为什么匿名内部类应用外部方法的域必须是常量域的原因所在了。</p><p>特别注意：<strong>在Java8中已经去掉要对final的修饰限制，但其实只要在匿名内部类使用了，该变量还是会自动变为final类型（只能使用，不能赋值）。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MVCC剖析</title>
      <link href="/2020/07/22/MVCC%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/22/MVCC%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（<code>row_id</code>并不是必要的，我们创建的表中有主键或者非NULL唯一键时都不会包含<code>row_id</code>列）：</p><ul><li><code>trx_id</code>：每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值给<code>trx_id</code>隐藏列。</li><li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><p>可以将这些<code>undo日志</code>都连起来，串成一个链表</p><p>为了判断一下版本链中的哪个版本是当前事务可见的，还有一个<code>ReadView</code>的概念，这个<code>ReadView</code>中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，我们把这个列表命名为为<code>m_ids</code>。这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见:</p><ul><li>如果被访问版本的<code>trx_id</code>属性值小于<code>m_ids</code>列表中最小的事务id，表明生成该版本的事务在生成<code>ReadView</code>前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值大于<code>m_ids</code>列表中最大的事务id，表明生成该版本的事务在生成<code>ReadView</code>后才生成，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值在<code>m_ids</code>列表中最大的事务id和最小事务id之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p><code>READ COMMITTED</code> — 每次读取数据前都生成一个ReadView</p><p><code>REPEATABLE READ</code> —在第一次读取数据时生成一个ReadView</p><p>比方说我们的表<code>t</code>现在只包含一条记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | c      |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 刘备   |</span><br><span class="line">+----+--------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>假设插入该记录的事务id为<code>80</code>，那么此刻该条记录的示意图如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf19851d3dce6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vemvvn1db6h431ekvsp158m19.png-15kB"></p><p>假设之后两个<code>id</code>分别为<code>100</code>、<code>200</code>的事务对这条记录进行<code>UPDATE</code>操作，操作流程如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198519aee7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vfo4g814h019mj1jqb1ggu72o3j.png-106.5kB"></p><blockquote><p>小贴士： 能不能在两个事务中交叉更新同一条记录呢？哈哈，这是不可以滴，第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。本篇文章不是讨论锁的，有关锁的更多细节我们之后再说。</p></blockquote><p>每次对记录进行改动，都会记录一条<code>undo日志</code>，每条<code>undo日志</code>也都有一个<code>roll_pointer</code>属性（<code>INSERT</code>操作对应的<code>undo日志</code>没有该属性，因为该记录并没有更早的版本），可以将这些<code>undo日志</code>都连起来，串成一个链表，所以现在的情况就像下图一样：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198524e1b34?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vfrv111j4guetptcts1qgp40.png-57.1kB"></p><p>对该记录每次更新后，都会将旧值放到一条<code>undo日志</code>中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被<code>roll_pointer</code>属性连接成一个链表，我们把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id，这个信息很重要，我们稍后就会用到。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>对于使用<code>READ UNCOMMITTED</code>隔离级别的事务来说，直接读取记录的最新版本就好了，对于使用<code>SERIALIZABLE</code>隔离级别的事务来说，使用加锁的方式来访问记录。对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，就需要用到我们上边所说的<code>版本链</code>了，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。所以设计<code>InnoDB</code>的大叔提出了一个<code>ReadView</code>的概念，这个<code>ReadView</code>中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，我们把这个列表命名为为<code>m_ids</code>。这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>如果被访问版本的<code>trx_id</code>属性值小于<code>m_ids</code>列表中最小的事务id，表明生成该版本的事务在生成<code>ReadView</code>前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值大于<code>m_ids</code>列表中最大的事务id，表明生成该版本的事务在生成<code>ReadView</code>后才生成，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值在<code>m_ids</code>列表中最大的事务id和最小事务id之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本，如果最后一个版本也不可见的话，那么就意味着该条记录对该事务不可见，查询结果就不包含该记录。</p><p>在<code>MySQL</code>中，<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的的一个非常大的区别就是它们生成<code>ReadView</code>的时机不同，我们来看一下。</p><p>READ COMMITTED — 每次读取数据前都生成一个ReadView</p><p><code>REPEATABLE READ</code> —在第一次读取数据时生成一个ReadView</p><h4 id="READ-COMMITTED-—-每次读取数据前都生成一个ReadView"><a href="#READ-COMMITTED-—-每次读取数据前都生成一个ReadView" class="headerlink" title="READ COMMITTED — 每次读取数据前都生成一个ReadView"></a>READ COMMITTED — 每次读取数据前都生成一个ReadView</h4><p>比方说现在系统里有两个<code>id</code>分别为<code>100</code>、<code>200</code>的事务在执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;关羽&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;张飞&#39; WHERE id &#x3D; 1;</span><br><span class="line">复制代码</span><br><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>小贴士： 事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。</p></blockquote><p>此刻，表<code>t</code>中<code>id</code>为<code>1</code>的记录得到的版本链表如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf19852d16845?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vgdl0j1c9d16rbelo1deh17324d.png-42.2kB"></p><p>假设现在有一个使用<code>READ COMMITTED</code>隔离级别的事务开始执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;刘备&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个<code>SELECT1</code>的执行过程如下：</p><ul><li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[100, 200]</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>c</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;关羽&#39;</code>，该版本的<code>trx_id</code>值也为<code>100</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>m_ids</code>列表中最小的事务id<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;刘备&#39;</code>的记录。</li></ul><p>之后，我们把事务id为<code>100</code>的事务提交一下，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;关羽&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;张飞&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后再到事务id为<code>200</code>的事务中更新一下表<code>t</code>中<code>id</code>为1的记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;赵云&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;诸葛亮&#39; WHERE id &#x3D; 1;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此刻，表<code>t</code>中<code>id</code>为<code>1</code>的记录的版本链就长这样：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198532476f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vgrt5jeh2itl5e41ocl944q.png-57.6kB"></p><p>然后再到刚才使用<code>READ COMMITTED</code>隔离级别的事务中继续查找这个id为<code>1</code>的记录，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200均未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;刘备&#39;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 100提交，Transaction 200未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;张飞&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个<code>SELECT2</code>的执行过程如下：</p><ul><li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[200]</code>（事务id为<code>100</code>的那个事务已经提交了，所以生成快照时就没有它了）。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>c</code>的内容是<code>&#39;诸葛亮&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;赵云&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，比<code>m_ids</code>列表中最小的事务id<code>200</code>还要小，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;张飞&#39;</code>的记录。</li></ul><p>以此类推，如果之后事务id为<code>200</code>的记录也提交了，再此在使用<code>READ COMMITTED</code>隔离级别的事务中查询表<code>t</code>中<code>id</code>值为<code>1</code>的记录时，得到的结果就是<code>&#39;诸葛亮&#39;</code>了，具体流程我们就不分析了。总结一下就是：使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p><h4 id="REPEATABLE-READ-—在第一次读取数据时生成一个ReadView"><a href="#REPEATABLE-READ-—在第一次读取数据时生成一个ReadView" class="headerlink" title="REPEATABLE READ —在第一次读取数据时生成一个ReadView"></a>REPEATABLE READ —在第一次读取数据时生成一个ReadView</h4><p>对于使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个<code>ReadView</code>，之后的查询就不会重复生成了。我们还是用例子看一下是什么效果。</p><p>比方说现在系统里有两个<code>id</code>分别为<code>100</code>、<code>200</code>的事务在执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;关羽&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;张飞&#39; WHERE id &#x3D; 1;</span><br><span class="line">复制代码</span><br><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此刻，表<code>t</code>中<code>id</code>为<code>1</code>的记录得到的版本链表如下所示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf19852d16845?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vgdl0j1c9d16rbelo1deh17324d.png-42.2kB"></p><p>假设现在有一个使用<code>REPEATABLE READ</code>隔离级别的事务开始执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;刘备&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个<code>SELECT1</code>的执行过程如下：</p><ul><li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[100, 200]</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>c</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;关羽&#39;</code>，该版本的<code>trx_id</code>值也为<code>100</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>m_ids</code>列表中最小的事务id<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;刘备&#39;</code>的记录。</li></ul><p>之后，我们把事务id为<code>100</code>的事务提交一下，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;关羽&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;张飞&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后再到事务id为<code>200</code>的事务中更新一下表<code>t</code>中<code>id</code>为1的记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;赵云&#39; WHERE id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE t SET c &#x3D; &#39;诸葛亮&#39; WHERE id &#x3D; 1;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此刻，表<code>t</code>中<code>id</code>为<code>1</code>的记录的版本链就长这样：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198532476f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1d6vgrt5jeh2itl5e41ocl944q.png-57.6kB"></p><p>然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个id为<code>1</code>的记录，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200均未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值为&#39;刘备&#39;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 100提交，Transaction 200未提交</span><br><span class="line">SELECT * FROM t WHERE id &#x3D; 1; # 得到的列c的值仍为&#39;刘备&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个<code>SELECT2</code>的执行过程如下：</p><ul><li>因为之前已经生成过<code>ReadView</code>了，所以此时直接复用之前的<code>ReadView</code>，之前的<code>ReadView</code>中的<code>m_ids</code>列表就是<code>[100, 200]</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>c</code>的内容是<code>&#39;诸葛亮&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;赵云&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，而<code>m_ids</code>列表中是包含值为<code>100</code>的事务id的，所以该版本也不符合要求，同理下一个列<code>c</code>的内容是<code>&#39;关羽&#39;</code>的版本也不符合要求。继续跳到下一个版本。</li><li>下一个版本的列<code>c</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，<code>80</code>小于<code>m_ids</code>列表中最小的事务id<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;刘备&#39;</code>的记录。</li></ul><p>也就是说两次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是<code>&#39;刘备&#39;</code>，这就是<code>可重复读</code>的含义。如果我们之后再把事务id为<code>200</code>的记录提交了，之后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个id为<code>1</code>的记录，得到的结果还是<code>&#39;刘备&#39;</code>，具体执行过程大家可以自己分析一下。</p><h3 id="MVCC总结"><a href="#MVCC总结" class="headerlink" title="MVCC总结"></a>MVCC总结</h3><p>从上边的描述中我们可以看出来，所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行普通的<code>SEELCT</code>操作时访问记录的版本链的过程，这样子可以使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是生成<code>ReadView</code>的时机不同，<code>READ COMMITTD</code>在每一次进行普通<code>SELECT</code>操作前都会生成一个<code>ReadView</code>，而<code>REPEATABLE READ</code>只在第一次进行普通<code>SELECT</code>操作前生成一个<code>ReadView</code>，之后的查询操作都重复这个<code>ReadView</code>就好了</p><p>作者：小孩子4919<br>链接：<a href="https://juejin.im/post/5c9b1b7df265da60e21c0b57" target="_blank" rel="noopener">https://juejin.im/post/5c9b1b7df265da60e21c0b57</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="为什么MVCC不能解决幻读？"><a href="#为什么MVCC不能解决幻读？" class="headerlink" title="为什么MVCC不能解决幻读？"></a>为什么MVCC不能解决幻读？</h3><p><a href="https://blog.csdn.net/weixin_42907817/article/details/107121470" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42907817/article/details/107121470</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Semaphore剖析</title>
      <link href="/2020/07/18/Semaphore%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/18/Semaphore%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>可以看到公平共享锁和非公平共享锁的区别就在是否需要判断队列中是否有已经等待的线程。公平共享锁需要先判断，非公平共享锁直接插队，尽管前面已经有线程在等待。</p><p>非公平锁acquire，内部重写，如果state&lt;0 会被阻塞，如果成功，会扣取state值</p><p>acquire state减一 release加一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化10个信号量在信号包中，让ABCD4个线程分别去获取</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Semaphore semaphore &#x3D; new Semaphore(10,false);</span><br><span class="line">        SemaphoreTest(semaphore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void SemaphoreTest(final Semaphore semaphore) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;线程A初始获取了4个信号量，然后分3次释放了这4个信号量</span><br><span class="line">        Thread threadA &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire(8);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get 1 semaphore&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; release 1 semaphore&quot;);</span><br><span class="line">                    semaphore.release(3);</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; release 1 semaphore&quot;);</span><br><span class="line">                    semaphore.release(5);</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadA.setName(&quot;threadA&quot;);</span><br><span class="line">        &#x2F;&#x2F;线程B初始获取了5个信号量，然后分2次释放了这5个信号量</span><br><span class="line">        Thread threadB &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;B start&quot;);</span><br><span class="line">                    semaphore.acquire(6);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get 6 semaphore&quot;);</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; release 6 semaphore&quot;);</span><br><span class="line">                    semaphore.release(6);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadB.setName(&quot;threadB&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;线程C初始获取了4个信号量，然后分1次释放了这4个信号量</span><br><span class="line">        Thread threadC &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;C start&quot;);</span><br><span class="line">                    semaphore.acquire(2);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; get 2 semaphore&quot;);</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; release 2 semaphore&quot;);</span><br><span class="line">                    semaphore.release(2);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        threadC.setName(&quot;threadC&quot;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        Thread.sleep(1);</span><br><span class="line">        threadB.start();</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        threadC.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring相关问题</title>
      <link href="/2020/07/17/Spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/17/Spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h3><h4 id="Q1：IoC-是什么？"><a href="#Q1：IoC-是什么？" class="headerlink" title="Q1：IoC 是什么？"></a>Q1：IoC 是什么？</h4><p>ioc，控制反转。平时传统方式中，当我们需要使用对象的时候，我们就必须自己手动地去创建，比如直接new一个对象。这样当我们在项目中需要使用大量对象时，就显得特别繁琐。 创建对象的控制权进行转移到IOC容器</p><p>  通过ioc就可以解决这些问题，我们不用再自己去手动new对象了，我们只需要设置好配置信息，ioc容器就可以帮我们自动创建对象，并且进行依赖注入，对这些对象进行管理。当我们在需要相应对象时，直接去ioc容器里面获取即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是将依赖对象的创建和绑定转移到被依赖对象类的外部来实现</span><br></pre></td></tr></table></figure><hr><h4 id="Q2：IoC-容器初始化过程？"><a href="#Q2：IoC-容器初始化过程？" class="headerlink" title="Q2：IoC 容器初始化过程？"></a>Q2：IoC 容器初始化过程？</h4><p><strong>基于 XML 的容器初始化</strong></p><p>为了方便理解和追踪代码，使用常用实现类ClassPathXmlApplicationContext写了一个小例子，步骤如下：</p><p>1）.在类路径下新建xml，定义一个bean,其中daoImpl就是bean的名字，spring.aop.xml.dao.impl.DaoImpl对应具体的一个pojo.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;daoImpl&quot; class&#x3D;&quot;spring.aop.xml.dao.impl.DaoImpl&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>2）.main方法中直接载入xml,然后获取bean,最后执行bean实例的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1     public static void main(String[] args) &#123;</span><br><span class="line">2         &#x2F;&#x2F;源码入口，从类路径下读取xml</span><br><span class="line">3         ApplicationContext ac1 &#x3D; new ClassPathXmlApplicationContext(&quot;aop.xml&quot;);</span><br><span class="line">4         Dao dao &#x3D; (Dao)ac1.getBean(&quot;daoImpl&quot;);&#x2F;&#x2F;根据名称获取Bean</span><br><span class="line">5         dao.select();&#x2F;&#x2F;执行Bean实例方法          &#125;</span><br></pre></td></tr></table></figure><p>下面我们就分析ClassPathXmlApplicationContext源码，来看看都做了什么。</p><p>ClassPathXmlApplicationContext类图</p><p><img src="https://images2017.cnblogs.com/blog/584866/201710/584866-20171019103913927-1865904529.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DefaultResourceLoader，该类设置classLoader，并且将配置文件 封装为Resource文件。</span><br><span class="line"></span><br><span class="line">AbstractApplicationContext，该类完成了大部分的IOC容器初始化工作，同时也提供了扩展接口留给子类去重载。该类的refresh()函数是核心初始化操作。</span><br><span class="line"></span><br><span class="line">AbstractRefreshableApplicationContext，该类支持刷新BeanFactory。</span><br><span class="line"></span><br><span class="line">AbstractRefreshableConfigApplicationContext，该类保存了配置文件路径</span><br><span class="line"></span><br><span class="line">AbstractXmlApplicationContext：该类支持解析bean定义文件</span><br><span class="line"></span><br><span class="line">最后ClassPathXmlApplicationContext:只提供了一个简单的构造函数</span><br><span class="line"></span><br><span class="line">Spring 将类职责分开，形成职责链，每一层次的扩展 都只是添加了某个功能</span><br><span class="line"></span><br><span class="line">然后父类定义大量的模板，让子类实现，父类层层传递到子类 直到某个子类重载了抽象方法。这里应用到了职责链设计模式和模板设计模式，IOC是个容器工厂设计模式。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当创建一个 ClassPathXmlApplicationContext 时，构造方法做了两件事：① 调用父容器的构造方法为容器设置好 Bean 资源加载器。② 调用父类的 &#96;setConfigLocations&#96; 方法设置 Bean 配置信息的定位路径。</span><br><span class="line"></span><br><span class="line">ClassPathXmlApplicationContext 通过调用父类 AbstractApplicationContext 的</span><br></pre></td></tr></table></figure><p>refresh()方法,其实标志容器初始化过程的正式启动.</p><p><code>refresh</code> 是一个模板方法，规定了 IoC 容器的启动流程, 在创建 IoC 容器前如果已有容器存在，需要把已有的容器销毁，保证在 <code>refresh</code> 方法后使用的是新创建的 IoC 容器。</p><p>容器创建后通过 <code>loadBeanDefinitions</code> 方法加载 Bean 配置资源。加载资源时首先解析配置文件路径，读取内容，然后通过 XML 解析器将 Bean 配置信息转换成文档对象，并对文档对象进行解析。</p><p>Spring IoC 容器中解析注册的 Bean 信息存放在一个 HashMap 集合中，在refresh过程中需要使用 synchronized 保证线程安全。当配置信息中配置的 Bean 被解析且被注册到 IoC 容器中后，初始化就算真正完成了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bean 定义信息已经可以使用且可被检索。Spring IoC 容器的作用就是对这些注册的 Bean 定义信息进行处理和维护，注册的 Bean 定义信息是控制反转和依赖注入的基础。（key 是字符串，值是 BeanDefinition)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">          synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">              &#x2F;&#x2F;准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证。</span><br><span class="line">              prepareRefresh();</span><br><span class="line">             &#x2F;&#x2F;启动子类的refreshBeanFactory方法.解析xml</span><br><span class="line">              ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</span><br><span class="line">               ... </span><br><span class="line">&#125;</span><br><span class="line">     &#125;</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">            ... </span><br><span class="line">            loadBeanDefinitions(beanFactory);&#x2F;&#x2F;核心方法</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>基于注解的容器初始化</strong></p><p>分为两种：① 直接将注解 Bean 注册到容器中。② 通过扫描指定的包及其子包的所有类处理，在初始化注解容器时指定要自动扫描的路径。</p><hr><h4 id="Q3：依赖注入的实现方法有哪些？-和IOC的区别"><a href="#Q3：依赖注入的实现方法有哪些？-和IOC的区别" class="headerlink" title="Q3：依赖注入的实现方法有哪些？(和IOC的区别)"></a>Q3：依赖注入的实现方法有哪些？(和IOC的区别)</h4><p>(控制反转：创建对象实例的控制从代码控制剥离到IOC容器控制，实际就是你在xml文件shu控制，侧重于原理。<br>依赖注入：创建对象实例时，为这个对象注入属性值或其它对象实例，侧重于实现。)</p><p><strong>它提供一种机制，将需要依赖（低层模块）对象的引用传递给被依赖（高层模块）对象</strong></p><p><strong>构造方法注入：</strong> 构造函数注入可以通过配置文件的方法注入和不通过配置文件 </p><p>配置文件，XML。</p><p><strong>setter 方法注入：</strong> 当前对象只需要为其依赖对象对应的属性添加 setter 方法，就可以通过 setter 方法将依赖对象注入到被依赖对象中。setter 方法注入在描述性上要比构造方法注入强，并且可以被继承，允许设置默认值。缺点是无法在对象构造完成后马上进入就绪状态。</p><p><strong>接口注入：</strong> 必须实现某个接口，接口提供方法来为其注入依赖对象。使用少，因为它强制要求被注入对象实现不必要接口，侵入性强。</p><p>具体思路是先定义一个接口，包含一个设置依赖的方法。</p><hr><h4 id="Q4：依赖注入的相关注解？"><a href="#Q4：依赖注入的相关注解？" class="headerlink" title="Q4：依赖注入的相关注解？"></a>Q4：依赖注入的相关注解？</h4><p><code>@Autowired</code>：自动按类型注入，如果有多个匹配，查找不到会报错。</p><p><code>@Qualifier</code>：在自动按照类型注入的基础上再按照 Bean 的 id 注入，给变量注入时必须搭配 <code>@Autowired</code>，给方法注入时可单独使用。</p><p><code>@Resource</code> ：直接按照 Bean 的 id 注入，只能注入 Bean 类型。</p><p><code>@Value</code> ：用于注入基本数据类型和 String 类型。</p><p>@Autowired 是通过 byType 的方式去注入的， 使用该注解，要求接口只能有一个实现类。</p><p>@Resource 可以通过 byName 和 byType的方式注入， 默认先按 byName的方式进行匹配，如果匹配不到，再按 byType的方式进行匹配。 @Resource(name=”dogImpl”)  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;dogImpl&quot;)</span><br><span class="line">public class DaoImpl impliments IAnimal&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping:用于处理请求url映射的注解，可用于类或方法上。用于类上，则表示类中的所有</span><br><span class="line">响应请求的方法都是以该地址作为父路径。</span><br><span class="line">@RequestBody：注解实现接受http请求的json数据，将json转换为java对象。</span><br><span class="line">@ResponseBody:注解实现将Controller方法返回的对象转化为json对象响应给客户。</span><br><span class="line">@RestController:注解相当于@Controller+@ResponseBody</span><br><span class="line">@RequestParam:在controller的方法中参数名与表单中的参数名不一致，使用@RequestParm实现参</span><br><span class="line">数绑定</span><br><span class="line">@RequestParam(name&#x3D;&quot;username&quot;) String t_username</span><br><span class="line">@PathVariable：Controller除了可以接受表单提交的数据之外，还可以获取url中携带的变量，即路径</span><br><span class="line">变量</span><br></pre></td></tr></table></figure><h4 id="Q5：依赖注入的过程？"><a href="#Q5：依赖注入的过程？" class="headerlink" title="Q5：依赖注入的过程？"></a>Q5：依赖注入的过程？</h4><p>依赖注入（Dependency Injection，简称 DI）是实现控制反转的主要方式</p><p>作者：沉默王二<br>链接：<a href="https://zhuanlan.zhihu.com/p/77036617" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77036617</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>1）基于构造函数。实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。</p><p>老王类的代码修改如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Laowang &#123;</span><br><span class="line">    private Heshang saodiseng;</span><br><span class="line"></span><br><span class="line">    public Laowang(Heshang saodiseng) &#123;</span><br><span class="line">        this.saodiseng &#x3D; saodiseng;</span><br><span class="line">    &#125;</span><br><span class="line">    public void mingling() &#123;</span><br><span class="line">       this.saodiseng.saodi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类的代码修改如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Laowang laowang &#x3D; new Laowang(new Xiaosan());</span><br><span class="line">        laowang.mingling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，控制权掌握在测试类的手里，它决定派小二和尚还是小三和尚去执行老王的扫地命令。</p><p>2）基于 set 方法。实现特定属性的 public set 方法，让外部容器调用传入所依赖类型的对象。</p><p>老王类的代码修改如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Laowang &#123;</span><br><span class="line">    private Heshang saodiseng;</span><br><span class="line"></span><br><span class="line">    public Heshang getSaodiseng() &#123;</span><br><span class="line">        return saodiseng;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSaodiseng(Heshang saodiseng) &#123;</span><br><span class="line">        this.saodiseng &#x3D; saodiseng;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void mingling() &#123;</span><br><span class="line">       this.getSaodiseng().saodi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类的代码修改如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Laowang laowang &#x3D; new Laowang();</span><br><span class="line">        Xiaosan xiaosan &#x3D; new Xiaosan();</span><br><span class="line">        laowang.setSaodiseng(xiaosan);</span><br><span class="line">        laowang.mingling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，控制权仍然掌握在测试类的手里，它决定派小二和尚还是小三和尚去执行老王的扫地命令。</p><p>3）基于接口。</p><p>作者：沉默王二<br>链接：<a href="https://zhuanlan.zhihu.com/p/77036617" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77036617</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="Spring-框架"><a href="#Spring-框架" class="headerlink" title="Spring 框架"></a><strong>Spring 框架</strong></h3><p>当我们搞清楚控制反转和依赖注入的概念后，就可以顺带了解一下大名鼎鼎的 Spring 框架。控制反转是 Spring 框架的核心，贯穿始终。Spring 中依赖注入有两种实现方式：set 方式（传值方式）和构造器方式（引用方式）。 </p><p>首先，我们需要在 pom.xml 文件中加入 Spring 的依赖项，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context-support&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.3.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>其次，我们将 Laowang 类修改为如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Laowang &#123;</span><br><span class="line">    private Heshang saodiseng;</span><br><span class="line"></span><br><span class="line">    public Laowang(Heshang saodiseng) &#123;</span><br><span class="line">        this.saodiseng &#x3D; saodiseng;</span><br><span class="line">    &#125;</span><br><span class="line">    public void mingling() &#123;</span><br><span class="line">       this.saodiseng.saodi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们创建一个 Spring 的配置文件 application.xml，内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">  xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;bean id&#x3D;&quot;laowang&quot; class&#x3D;&quot;com.cmower.java_demo.ioc.Laowang&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref&#x3D;&quot;saodiseng&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">  &lt;bean id&#x3D;&quot;saodiseng&quot; class&#x3D;&quot;com.cmower.java_demo.ioc.Xiaosan&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>通过  元素配置了两个对象，一个老王主持，一个小三和尚，使用  元素将小三和尚作为老王主持的构造参数。</p><p>准备工作完成以后，我们来测试一下，代码示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br><span class="line">        Laowang laowang &#x3D; (Laowang) context.getBean(&quot;laowang&quot;);</span><br><span class="line">        laowang.mingling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，我们将控制权交给了 IoC 框架 Spring，这样也可以完美的解决代码耦合度较紧的问题。</p><hr><h4 id="Q6：Bean-的生命周期？"><a href="#Q6：Bean-的生命周期？" class="headerlink" title="Q6：Bean 的生命周期？"></a>Q6：Bean 的生命周期？</h4><ul><li>实例化bean对象(通过构造方法或者工厂方法)</li><li>设置对象属性(setter等)（依赖注入）</li><li>检查Aware接口</li><li>将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法</li><li>调用Bean的初始化方法</li><li>将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法</li><li>使用Bean</li><li>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean接口，会调用其实现的destroy方法</li></ul><p><img src="/2020/07/17/Spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201205160024907.png" alt="image-20201205160024907"></p><p>经过这一系列初始化操作后 Bean 达到可用状态，接下来就可以使用 Bean 了，当使用完成后会调用 destroy 方法进行销毁，此时也可以指定自定义的销毁方法，最终 Bean 被销毁且从容器中移除。</p><p>XML 方式通过配置 bean 标签中的 init-Method 和 destory-Method 指定自定义初始化和销毁方法。 </p><p>注解方式通过 <code>@PreConstruct</code> 和 <code>@PostConstruct</code> 注解指定自定义初始化和销毁方法。</p><hr><h4 id="Q7：Bean-的作用范围？-不用管了"><a href="#Q7：Bean-的作用范围？-不用管了" class="headerlink" title="Q7：Bean 的作用范围？(不用管了)"></a>Q7：Bean 的作用范围？(不用管了)</h4><p>通过 scope 属性指定 bean 的作用范围，包括：</p><p>① singleton：单例模式，是默认作用域，不管收到多少 Bean 请求每个容器中只有一个唯一的 Bean 实例。</p><p>② prototype：原型模式，和 singleton 相反，每次 Bean 请求都会创建一个新的实例。</p><hr><h4 id="Q8：如何通过-XML-方式创建-Bean？"><a href="#Q8：如何通过-XML-方式创建-Bean？" class="headerlink" title="Q8：如何通过 XML 方式创建 Bean？"></a>Q8：如何通过 XML 方式创建 Bean？</h4><p>默认无参构造方法，只需要指明 bean 标签中的 id 和 class 属性，如果没有无参构造方报错。</p><hr><h4 id="Q9：如何通过注解创建-Bean？"><a href="#Q9：如何通过注解创建-Bean？" class="headerlink" title="Q9：如何通过注解创建 Bean？"></a>Q9：如何通过注解创建 Bean？</h4><p><code>@Component</code> 把当前类对象存入 Spring 容器中，相当于在 xml 中配置一个 bean 标签。value 属性指定 bean 的 id，默认使用当前类的首字母小写的类名。</p><p><code>@Controller</code>，<code>@Service</code>，<code>@Repository</code> 三个注解都是 <code>@Component</code>  的衍生注解，作用及属性都是一模一样的。只是提供了更加明确语义，<code>@Controller</code> 用于表现层，<code>@Service</code>用于业务层，<code>@Repository</code>用于持久层。如果注解中有且只有一个 value 属性要赋值时可以省略 value。</p><p>如果想将第三方的类变成组件又没有源代码，也就没办法使用 <code>@Component</code> 进行自动配置，这种时候就要使用 <code>@Bean</code> 注解。被 <code>@Bean</code> 注解的方法返回值是一个对象，将会实例化，配置和初始化一个新对象并返回，这个对象由 Spring 的 IoC 容器管理。name 属性用于给当前 <code>@Bean</code>  注解方法创建的对象指定一个名称，即 bean 的 id。当使用注解配置方法时，如果方法有参数，Spring 会去容器查找是否有可用 bean对象，查找方式和 <code>@Autowired</code> 一样。</p><hr><h4 id="Q10：如何通过注解配置文件？"><a href="#Q10：如何通过注解配置文件？" class="headerlink" title="Q10：如何通过注解配置文件？"></a>Q10：如何通过注解配置文件？</h4><p><code>@Configuration</code> 用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解，value 属性用于指定配置类的字节码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> package config;</span><br><span class="line"> </span><br><span class="line"> import model.User;</span><br><span class="line"> import org.springframework.context.annotation.Bean;</span><br><span class="line"> import org.springframework.context.annotation.Configuration;</span><br><span class="line"> import org.springframework.context.annotation.Scope;</span><br><span class="line"> </span><br><span class="line"> @Configuration</span><br><span class="line"> public class TestConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    public TestConfiguration()&#123;</span><br><span class="line">        System.out.println(&quot;TestConfiguration 容器启动初始化...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(&quot;prototype&quot;)</span><br><span class="line">    public TestBean testBean() &#123;</span><br><span class="line">        return new TestBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class TestMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; @Configuration注解的spring容器加载方式，用AnnotationConfigApplicationContext替换ClassPathXmlApplicationContext</span><br><span class="line">        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(TestConfiguration.class);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果加载spring-context.xml文件：</span><br><span class="line">        &#x2F;&#x2F; ApplicationContext context &#x3D; new</span><br><span class="line">        &#x2F;&#x2F; ClassPathXmlApplicationContext(&quot;spring-context.xml&quot;);</span><br><span class="line">        </span><br><span class="line">         &#x2F;&#x2F;获取bean</span><br><span class="line">        TestBean tb &#x3D; (TestBean) context.getBean(&quot;testBean&quot;);</span><br><span class="line">        tb.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@ComponentScan</code> 用于指定 Spring 在初始化容器时要扫描的包。basePackages 属性用于指定要扫描的包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;@PropertySource&#96; 用于加载 &#96;.properties&#96; 文件中的配置。value 属性用于指定文件位置，如果是在类路径下需要加上 classpath。</span><br><span class="line"></span><br><span class="line">&#96;@Import&#96; 用于导入其他配置类，在引入其他配置类时可以不用再写 &#96;@Configuration&#96; 注解。有 &#96;@Import&#96; 的是父配置类，引入的是子配置类。value 属性用于指定其他配置类的字节码。</span><br></pre></td></tr></table></figure><hr><h4 id="Q11：BeanFactory、FactoryBean-和-ApplicationContext-的区别？"><a href="#Q11：BeanFactory、FactoryBean-和-ApplicationContext-的区别？" class="headerlink" title="Q11：BeanFactory、FactoryBean 和 ApplicationContext 的区别？"></a>Q11：BeanFactory、FactoryBean 和 ApplicationContext 的区别？</h4><p>BeanFactory 是一个 Bean 工厂，是一个接口，作用是管理 Bean，包括实例化、配置对象及建立这些对象间的依赖。BeanFactory 实例化后并不会自动实例化 Bean，只有当 Bean 被使用时才实例化与装配依赖关系，属于延迟加载，适合多例模式。</p><p>ApplicationConext 是 BeanFactory 的子接口，扩展了 BeanFactory 的功能。BeanFactory在启动的时候不会去实例化Bean，</p><ul><li>ApplicationContext在启动的时候就把所有的Bean全部实例化了。</li><li>资源访问，如URL和文件 </li><li>AOP（拦截器）</li></ul><p>FactoryBean 是一个工厂 Bean，是一个能生产或者修饰对象生成的工厂Bean</p><h4 id="Q13-Spring启动过程"><a href="#Q13-Spring启动过程" class="headerlink" title="Q13: Spring启动过程"></a>Q13: Spring启动过程</h4><p><img src="https://upload-images.jianshu.io/upload_images/11798292-651b056425ce045f.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/637/format/webp" alt="img"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/application_context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.ContextLoaderListener</span><br><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring的启动其实就是IOC容器的启动过程，通过上述的第一段配置&#96;&lt;context-param&gt;&#96;是初始化上下文，然后通过后一段的的&lt;listener&gt;来加载配置文件，其中调用的spring包中的&#96;ContextLoaderListener&#96;这个上下文监听器，&#96;ContextLoaderListener&#96;是一个实现了&#96;ServletContextListener&#96;接口的监听器，他的父类是  &#96;ContextLoader&#96;，在启动项目时会触发&#96;contextInitialized&#96;上下文初始化方法。下面我们来看看这个方法：</span><br></pre></td></tr></table></figure><p>调用refresh</p><h4 id="Q15-Spring如何解决循环依赖（三级缓存）（必考）"><a href="#Q15-Spring如何解决循环依赖（三级缓存）（必考）" class="headerlink" title="Q15: Spring如何解决循环依赖（三级缓存）（必考）"></a>Q15: Spring如何解决循环依赖（三级缓存）（必考）</h4><h4 id="Q17-Spring的-Transactional如何实现的（必考）"><a href="#Q17-Spring的-Transactional如何实现的（必考）" class="headerlink" title="Q17: Spring的@Transactional如何实现的（必考）"></a>Q17: Spring的@Transactional如何实现的（必考）</h4><h4 id="Q18-Spring的事务传播级别"><a href="#Q18-Spring的事务传播级别" class="headerlink" title="Q18: Spring的事务传播级别"></a>Q18: Spring的事务传播级别</h4><h4 id="Q19-拦截器，监听器和过滤器区别"><a href="#Q19-拦截器，监听器和过滤器区别" class="headerlink" title="Q19: 拦截器，监听器和过滤器区别"></a>Q19: 拦截器，监听器和过滤器区别</h4><p>拦截器依赖于SpringMVC框架。在实现上基于Java的反射机制，属于面向切面编程（AOP）面向切面编程的一种运用。</p><p>过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理<br>通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理</p><p>多个Filter按照字母进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package filter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import javax.servlet.annotation.WebInitParam;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@WebFilter(filterName &#x3D; &quot;CharsetFilter&quot;,</span><br><span class="line">        urlPatterns &#x3D; &quot;&#x2F;*&quot;,&#x2F;*通配符（*）表示对所有的web资源进行拦截*&#x2F;</span><br><span class="line">        initParams &#x3D; &#123;</span><br><span class="line">                @WebInitParam(name &#x3D; &quot;charset&quot;, value &#x3D; &quot;utf-8&quot;)&#x2F;*这里可以放一些初始化的参数*&#x2F;</span><br><span class="line">        &#125;)</span><br><span class="line">public class CharsetFilter implements Filter &#123;</span><br><span class="line">    private String filterName;</span><br><span class="line">    private String charset;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        &#x2F;*销毁时调用*&#x2F;</span><br><span class="line"></span><br><span class="line">        System.out.println(filterName + &quot;销毁&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;*过滤方法 主要是对request和response进行一些处理，然后交给下一个过滤器或Servlet处理*&#x2F;</span><br><span class="line">System.out.println(filterName + &quot;doFilter()&quot;);</span><br><span class="line">        req.setCharacterEncoding(charset);</span><br><span class="line">        resp.setCharacterEncoding(charset);</span><br><span class="line">        chain.doFilter(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init(FilterConfig config) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;*初始化方法  接收一个FilterConfig类型的参数 该参数是对Filter的一些配置*&#x2F;</span><br><span class="line"></span><br><span class="line">        filterName &#x3D; config.getFilterName();</span><br><span class="line">        charset &#x3D; config.getInitParameter(&quot;charset&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;过滤器名称：&quot; + filterName);</span><br><span class="line">        System.out.println(&quot;字符集编码：&quot; + charset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180604094219689?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nfcm95aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>监听器</p><p>ServletContext,HttpSession,ServletRequest</p><p>1)ServletContext对应监控application内置对象的创建跟销毁.<br>2)用于监听用户会话对象(HttpSession)的事件监听器<br>3)用于监听请求消息对象(ServletRequest)的事件监听器</p><p><img src="https://img-blog.csdnimg.cn/20190817182633273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNzIyMTcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Q20-Springboot起步依赖有什么好处？"><a href="#Q20-Springboot起步依赖有什么好处？" class="headerlink" title="Q20: Springboot起步依赖有什么好处？"></a>Q20: Springboot起步依赖有什么好处？</h4><h4 id="Q21-Spring-框架中都用到了哪些设计模式？"><a href="#Q21-Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Q21:Spring 框架中都用到了哪些设计模式？"></a>Q21:Spring 框架中都用到了哪些设计模式？</h4><p>Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的：</p><p>（1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p><p>BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象</p><p>（2）单例模式：Bean默认为单例模式。</p><p>（3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p><p>（4）模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p><p>（5）观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p><h3 id="Spring和SpringBoot的区别？"><a href="#Spring和SpringBoot的区别？" class="headerlink" title="Spring和SpringBoot的区别？"></a>Spring和SpringBoot的区别？</h3><hr><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h4 id="Q1：AOP-是什么？"><a href="#Q1：AOP-是什么？" class="headerlink" title="Q1：AOP 是什么？"></a>Q1：AOP 是什么？</h4><p>AOP 即面向切面编程，简单地说就是将代码中重复的部分抽取出来，在需要执行的时候使用动态代理技术，在不修改源码的基础上对方法进行增强。用于<strong>处理系统中分布于各个模块的横切关注点</strong>，比如事务管理、日志、缓存等等</p><p>Spring 根据类是否实现接口来判断动态代理方式，如果实现接口会使用 JDK 的动态代理，核心是 InvocationHandler 接口和 Proxy 类，如果没有实现接口会使用 CGLib 动态代理，CGLib 是在运行时动态生成某个类的子类，如果某个类被标记为 final，不能使用 CGLib 。</p><p>JDK 动态代理主要通过重组字节码实现，首先获得被代理对象的引用和所有接口，生成新的类必须实现被代理类的所有接口，动态生成Java 代码后编译新生成的 <code>.class</code> 文件并重新加载到 JVM 运行。JDK 代理直接写 Class 字节码，CGLib 是采用 ASM 框架写字节码，生成代理类的效率低。但是 CGLib 调用方法的效率高，因为 JDK 使用反射调用方法，CGLib 使用 FastClass 机制为代理类和被代理类各生成一个类，这个类会为代理类或被代理类的方法生成一个 index，这个 index 可以作为参数直接定位要调用的方法。</p><p>常用场景包括权限认证、自动缓存、错误处理、日志、调试和事务等。</p><hr><h4 id="Q2：AOP-的相关注解有哪些？"><a href="#Q2：AOP-的相关注解有哪些？" class="headerlink" title="Q2：AOP 的相关注解有哪些？"></a>Q2：AOP 的相关注解有哪些？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class AopAdvice &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution (* com.shangguan.aop.controller.*.*(..))&quot;)</span><br><span class="line">    public void test() &#123;</span><br><span class="line"> &#x2F;&#x2F; 方法执行的时候触发 包路径 任意类 任意方法 任意参数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;test()&quot;)</span><br><span class="line">    public void beforeAdvice() &#123;</span><br><span class="line">        System.out.println(&quot;beforeAdvice...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @After(&quot;test()&quot;)</span><br><span class="line">    public void afterAdvice() &#123;</span><br><span class="line">        System.out.println(&quot;afterAdvice...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;test()&quot;)</span><br><span class="line">    public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) &#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            proceedingJoinPoint.proceed();</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Aspect</code>：声明被注解的类是一个切面 Bean。</p><p><code>@Before</code>：前置通知，指在某个连接点之前执行的通知。</p><p><code>@After</code>：后置通知，指某个连接点退出时执行的通知（不论正常返回还是异常退出）。</p><p><code>@AfterReturning</code>：返回后通知，指某连接点正常完成之后执行的通知，返回值使用returning属性接收。</p><p><code>@AfterThrowing</code>：异常通知，指方法抛出异常导致退出时执行的通知，和<code>@AfterReturning</code>只会有一个执行，异常使用throwing属性接收。</p><hr><h4 id="Q3：AOP-的相关术语有什么？"><a href="#Q3：AOP-的相关术语有什么？" class="headerlink" title="Q3：AOP 的相关术语有什么？"></a>Q3：AOP 的相关术语有什么？</h4><p><code>Aspect</code>：切面，一个关注点的模块化，这个关注点可能会横切多个对象。</p><p><code>Joinpoint</code>：连接点，程序执行过程中的某一行为，即业务层中的所有方法。。</p><p><code>Advice</code>：通知，指切面对于某个连接点所产生的动作，包括前置通知、后置通知、返回后通知、异常通知和环绕通知。</p><p><code>Pointcut</code>：切入点，指被拦截的连接点，切入点一定是连接点，但连接点不一定是切入点。</p><p><code>Proxy</code>：代理，Spring AOP 中有 JDK 动态代理和 CGLib 代理，目标对象实现了接口时采用 JDK 动态代理，反之采用 CGLib 代理。</p><p><code>Target</code>：代理的目标对象，指一个或多个切面所通知的对象。</p><p><code>Weaving</code> ：织入，指把增强应用到目标对象来创建代理对象的过程。</p><hr><h4 id="Q4：AOP-的过程？"><a href="#Q4：AOP-的过程？" class="headerlink" title="Q4：AOP 的过程？"></a>Q4：AOP 的过程？</h4><p>Spring AOP 由 BeanPostProcessor 后置处理器开始，这个后置处理器是一个***，可以监听容器触发的 Bean 生命周期事件，向容器注册后置处理器以后，容器中管理的 Bean 就具备了接收 IoC 容器回调事件的能力。BeanPostProcessor 的调用发生在 Spring IoC 容器完成 Bean 实例对象的创建和属性的依赖注入后，为 Bean 对象添加后置处理器的入口是 <code>initializeBean</code> 方法。</p><p>Spring 中 JDK 动态代理通过 JdkDynamicAopProxy 调用 Proxy 的 <code>newInstance</code> 方法来生成代理类，JdkDynamicAopProxy 也实现了 InvocationHandler 接口，<code>invoke</code> 方法的具体逻辑是先获取应用到此方法上的拦截器链，如果有拦截器则创建 MethodInvocation 并调用其 <code>proceed</code> 方法，否则直接反射调用目标方法。因此 Spring AOP 对目标对象的增强是通过拦截器实现的。</p><hr><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h4 id="Q1：Spring-MVC-的处理流程？"><a href="#Q1：Spring-MVC-的处理流程？" class="headerlink" title="Q1：Spring MVC 的处理流程？"></a>Q1：Spring MVC 的处理流程？</h4><p><img src="https://camo.githubusercontent.com/f5433f5b67095bda3ba5a96079a21411e3d58292/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f31302f313636666434353738373339343139323f773d3130313526683d34363626663d7765627026733d3335333532" alt="SpringMVC 原理"></p><p>Web 容器启动时会通知 Spring 初始化容器，加载 Bean 的定义信息并初始化所有单例 Bean，然后遍历容器中的 Bean，获取每一个 Controller 中的所有方法访问的 URL，将 URL 和对应的 Controller 保存到一个 Map 集合中。</p><p>所有的请求会转发给 DispatcherServlet 前端处理器处理，DispatcherServlet 会请求 HandlerMapping 找出容器中被 <code>@Controler</code> 注解修饰的 Bean 以及被 <code>@RequestMapping</code> 修饰的方法和类，生成 Handler 和 HandlerInterceptor 并以一个 HandlerExcutionChain 处理器执行链的形式返回。</p><p>之后 DispatcherServlet 使用 Handler 找到对应的 HandlerApapter，通过 HandlerApapter 调用 Handler 的方法，将请求参数绑定到方法的形参上，执行方法处理请求并得到 ModelAndView。</p><p>最后 DispatcherServlet 根据使用 ViewResolver 试图解析器对得到的 ModelAndView 逻辑视图进行解析得到 View 物理视图，然后对视图渲染，将数据填充到视图中并返回给客户端。</p><hr><h4 id="Q2：Spring-MVC-有哪些组件？"><a href="#Q2：Spring-MVC-有哪些组件？" class="headerlink" title="Q2：Spring MVC 有哪些组件？"></a>Q2：Spring MVC 有哪些组件？</h4><p><code>DispatcherServlet</code>：SpringMVC 中的前端控制器，是整个流程控制的核心，负责接收请求并转发给对应的处理组件。</p><p><code>Handler</code>：处理器，完成具体业务逻辑，相当于 Servlet 或 Action。</p><p><code>HandlerMapping</code>：完成 URL 到 Controller 映射，DispatcherServlet 通过 HandlerMapping 将不同请求映射到不同 Handler。</p><p><code>HandlerInterceptor</code>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</p><p><code>HandlerExecutionChain</code>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor。</p><p><code>HandlerAdapter</code>：处理器适配器，Handler执行业务方法前需要进行一系列操作，包括表单数据验证、数据类型转换、将表单数据封装到JavaBean等，这些操作都由 HandlerAdapter 完成。DispatcherServlet 通过 HandlerAdapter 来执行不同的 Handler。</p><p><code>ModelAndView</code>：装载模型数据和视图信息，作为 Handler 处理结果返回给 DispatcherServlet。</p><p><code>ViewResolver</code>：视图解析器，DispatcherServlet 通过它将逻辑视图解析为物理视图，最终将渲染的结果响应给客户端。</p><hr><h4 id="Q3：Spring-MVC-的相关注解？"><a href="#Q3：Spring-MVC-的相关注解？" class="headerlink" title="Q3：Spring MVC 的相关注解？"></a>Q3：Spring MVC 的相关注解？</h4><p><code>@Controller</code>：在类定义处添加，将类交给IoC容器管理。</p><p><code>@RequtestMapping</code>：将URL请求和业务方法映射起来，在类和方法定义上都可以添加该注解。<code>value</code> 属性指定URL请求的实际地址，是默认值。<code>method</code> 属性限制请求的方法类型，包括GET、POST、PUT、DELETE等。如果没有使用指定的请求方法请求URL，会报405 Method Not Allowed 错误。<code>params</code> 属性限制必须提供的参数，如果没有会报错。</p><p><code>@RequestParam</code>：如果 Controller 方法的形参和 URL 参数名一致可以不添加注解，如果不一致可以使用该注解绑定。<code>value</code> 属性表示HTTP请求中的参数名。<code>required</code> 属性设置参数是否必要，默认false。<code>defaultValue</code> 属性指定没有给参数赋值时的默认值。</p><p><code>@PathVariable</code>：Spring MVC 支持 RESTful 风格 URL，通过 <code>@PathVariable</code> 完成请求参数与形参的绑定。</p><h4 id="Q5：mybatis的xml有什么标签？"><a href="#Q5：mybatis的xml有什么标签？" class="headerlink" title="Q5：mybatis的xml有什么标签？"></a>Q5：mybatis的xml有什么标签？</h4><hr><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h4 id="Q1：Mybatis-的优缺点？"><a href="#Q1：Mybatis-的优缺点？" class="headerlink" title="Q1：Mybatis 的优缺点？"></a>Q1：Mybatis 的优缺点？</h4><p><strong>优点</strong></p><p>相比 JDBC 减少了大量代码量，减少冗余代码。</p><p>使用灵活，SQL 语句写在 XML 里，从程序代码中彻底分离，降低了耦合度，便于管理。</p><p>提供 XML 标签，支持编写动态 SQL 语句。</p><p>提供映射标签，支持对象与数据库的 ORM 字段映射关系。</p><p><strong>缺点</strong></p><p>SQL 语句编写工作量较大，尤其是字段和关联表多时。</p><p>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><hr><h4 id="Q2：Mybatis-的-XML-文件有哪些标签属性？"><a href="#Q2：Mybatis-的-XML-文件有哪些标签属性？" class="headerlink" title="Q2：Mybatis 的 XML 文件有哪些标签属性？"></a>Q2：Mybatis 的 XML 文件有哪些标签属性？</h4><p><code>select</code>、<code>insert</code>、<code>update</code>、<code>delete</code> 标签分别对应查询、添加、更新、删除操作。</p><p><code>parameterType</code>  属性表示参数的数据类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型，当有多个参数时可以使用 <code>#{argn}</code> 的形式表示第 n 个参数。除了基本数据类型都要以全限定类名的形式指定参数类型。</p><p><code>resultType</code>  表示返回的结果类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型。还可以使用把返回结果封装为复杂类型的 <code>resultMap</code> 。</p><hr><h4 id="Q3：Mybatis-的一级缓存是什么？"><a href="#Q3：Mybatis-的一级缓存是什么？" class="headerlink" title="Q3：Mybatis 的一级缓存是什么？"></a>Q3：Mybatis 的一级缓存是什么？</h4><p>一级缓存是 SqlSession 级别，默认开启且不能关闭。</p><p>操作数据库时需要创建 SqlSession 对象，对象中有一个 HashMap 存储缓存数据，不同 SqlSession 之间缓存数据区域互不影响。</p><p>一级缓存的作用域是 SqlSession 范围的，在同一个 SqlSession 中执行两次相同的 SQL 语句时，第一次执行完毕会将结果保存在缓存中，第二次查询直接从缓存中获取。</p><p>如果 SqlSession 执行了 DML 操作（insert、update、delete），Mybatis 必须将缓存清空保证数据有效性。 </p><hr><h4 id="Q4：Mybatis-的二级缓存是什么？"><a href="#Q4：Mybatis-的二级缓存是什么？" class="headerlink" title="Q4：Mybatis 的二级缓存是什么？"></a>Q4：Mybatis 的二级缓存是什么？</h4><p>二级缓存是Mapper 级别，默认关闭。</p><p>使用二级缓存时多个 SqlSession 使用同一个 Mapper 的 SQL 语句操作数据库，得到的数据会存在二级缓存区。作用域是 Mapper 的同一个 namespace，不同 SqlSession 两次执行相同的 namespace 下的 SQL 语句，参数也相等，则第一次执行成功后会将数据保存在二级缓存中，第二次可直接从二级缓存中取出数据。同样使用 HashMap 进行数据存储，相比于一级缓存，二级缓存范围更大，多个 SqlSession 可以共用二级缓存。</p><p>要使用二级缓存，需要在全局配置文件中配置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code> ，再在对应的映射文件中配置一个 <code>&lt;cache/&gt;</code> 标签。</p><hr><h4 id="Q5：Mybatis-和-的区别？"><a href="#Q5：Mybatis-和-的区别？" class="headerlink" title="Q5：Mybatis  #{} 和 ${} 的区别？"></a>Q5：Mybatis  <code>#{}</code> 和 <code>${}</code> 的区别？</h4><p>使用 <code>${}</code>  相当于使用字符串拼接，存在 SQL 注入的风险。</p><p>使用 <code>#{}</code> 相当于使用占位符，可以防止 SQL 注入，不支持使用占位符的地方就只能使用 <code>${}</code> ，典型情况就是动态参数。</p><p>首先，我们说一下这两种引用参数时的区别，<strong>使用#</strong>{parameterName}引用参数的时候，Mybatis会<strong>把这个参数认为是一个字符串，并自动加上’’</strong>，例如传入参数是“Smith”，那么在下面SQL中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from emp where name = #&#123;employeeName&#125;</span><br></pre></td></tr></table></figure><p>使用的时候就会转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * <span class="keyword">from</span> emp where name = <span class="string">'Smith'</span>;</span><br></pre></td></tr></table></figure><p>同时<strong>使用${parameterName}的</strong>时候在下面SQL中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * <span class="keyword">from</span> emp where name = $&#123;employeeName&#125;</span><br></pre></td></tr></table></figure><p>就会直接转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * <span class="keyword">from</span> emp where name = Smith</span><br></pre></td></tr></table></figure><p>简单说<strong>#{}是经过预编译的,是安全的</strong>。</p><p>而<strong>${}</strong>是未经过预编译的,<strong>仅仅是取变量的值,是非安全的,存在SQL注入</strong>。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>@resource与 @autowired</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没错，注解的本质就是一个继承了 Annotation 接口的接口。</span><br></pre></td></tr></table></figure><h3 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h3><p>Spring Boot启动流程以及生命周期</p><p><img src="/2020/07/17/Spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201213160224897.png" alt="image-20201213160224897"></p><p><a href="https://blog.csdn.net/u011277123/article/details/104476683" target="_blank" rel="noopener">https://blog.csdn.net/u011277123/article/details/104476683</a></p><p>.Spring和Springboot的区别</p><p><code>Spring Boot</code>基本上是<code>Spring</code>框架的扩展，它消除了设置<code>Spring</code>应用程序所需的<code>XML配置</code>，为更快，更高效的开发生态系统铺平了道路。提供的<code>starters</code> 简化构建配置</p><p><strong>Spring Boot为不同的Spring模块提供了许多依赖项。一些最常用的是：</strong><br><code>spring-boot-starter-data-jpa</code><br><code>spring-boot-starter-security</code><br><code>spring-boot-starter-test</code><br><code>spring-boot-starter-web</code><br><code>spring-boot-starter-thymeleaf</code></p><p>Springboot starter</p><p>不使用springboot时，需要引入spring-web、spring-webmvc、spring-aop等等来支持项目开发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Spring等方式</span><br><span class="line">Spring的Web应用，我们需要做以下一些工作：</span><br><span class="line">  1.pom文件中引入相关jar包，包括spring、springmvc、redis、mybaits、log4j、mysql-connector-java 等等相关jar ...</span><br><span class="line">  2.配置web.xml，Listener配置、Filter配置、Servlet配置、log4j配置、error配置 ...</span><br><span class="line">  3.配置数据库连接、配置spring事务</span><br><span class="line">  4.配置视图解析器</span><br><span class="line">  5.开启注解、自动扫描功能</span><br><span class="line">  6.配置完成后部署tomcat、启动调试</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>RESTful 和SOAP</p><p>SOA和微服务的区别</p><p>springboot的优点</p><h3 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h3><h4 id="Q1：ORM-是什么？"><a href="#Q1：ORM-是什么？" class="headerlink" title="Q1：ORM 是什么？"></a>Q1：ORM 是什么？</h4><p>ORM 即 Object-Relational Mapping ，表示对象关系映射，映射的不只是对象的值还有对象之间的关系，通过 ORM 就可以把对象映射到关系型数据库中。操作实体类就相当于操作数据库表，可以不再重点关注 SQL 语句。</p><hr><h4 id="Q2：JPA-如何使用？"><a href="#Q2：JPA-如何使用？" class="headerlink" title="Q2：JPA 如何使用？"></a>Q2：JPA 如何使用？</h4><p>只需要持久层接口继承 JpaRepository 即可，泛型参数列表中第一个参数是实体类类型，第二个参数是主键类型。</p><p>运行时通过 <code>JdkDynamicAopProxy</code> 的 <code>invoke</code> 方法创建了一个动态代理对象 <code>SimpleJpaRepository</code>，<code>SimpleJpaRepository</code> 中封装了 JPA 的操作，通过 <code>hibernate</code>（封装了JDBC）完成数据库操作。</p><hr><h4 id="Q3：JPA-实体类相关注解有哪些？"><a href="#Q3：JPA-实体类相关注解有哪些？" class="headerlink" title="Q3：JPA 实体类相关注解有哪些？"></a>Q3：JPA 实体类相关注解有哪些？</h4><p><code>@Entity</code>：表明当前类是一个实体类。</p><p><code>@Table</code> ：关联实体类和数据库表。</p><p><code>@Column</code> ：关联实体类属性和数据库表中字段。</p><p><code>@Id</code> ：声明当前属性为数据库表主键对应的属性。</p><p><code>@GeneratedValue</code>： 配置主键生成策略。</p><p><code>@OneToMany</code> ：配置一对多关系，mappedBy 属性值为主表实体类在从表实体类中对应的属性名。</p><p><code>@ManyToOne</code> ：配置多对一关系，targetEntity 属性值为主表对应实体类的字节码。</p><p><code>@JoinColumn</code>：配置外键关系，name 属性值为外键名称，referencedColumnName 属性值为主表主键名称。</p><hr><h4 id="Q4：对象导航查询是什么？"><a href="#Q4：对象导航查询是什么？" class="headerlink" title="Q4：对象导航查询是什么？"></a>Q4：对象导航查询是什么？</h4><p>通过 get 方法查询一个对象的同时，通过此对象可以查询它的关联对象。</p><p>对象导航查询一到多默认使用延迟加载的形式， 关联对象是集合，因此使用立即加载可能浪费资源。</p><p>对象导航查询多到一默认使用立即加载的形式， 关联对象是一个对象，因此使用立即加载。</p><p>如果要改变加载方式，在实体类注解配置加上 fetch 属性即可，LAZY 表示延迟加载，EAGER 表示立即加载。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何在主线程捕获子线程的异常</title>
      <link href="/2020/07/17/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%8D%95%E8%8E%B7%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/07/17/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%8D%95%E8%8E%B7%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>  通过对线程调用setUncaughtExceptionHandler，对处理器实现Thread.UncaughtExceptionHandler的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class test extends Thread&#123;</span><br><span class="line">    public static class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">        public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;MyUncaughtExceptionHandler do something...&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;errorMsg:&quot; + e.getMessage());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static class ChildTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;  Thread.currentThread().setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;do something&quot;);</span><br><span class="line"></span><br><span class="line">            throw new RuntimeException(&quot;ChildTask异常&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Thread t&#x3D; new Thread(new ChildTask());</span><br><span class="line">            t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</span><br><span class="line">            t.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>守护线程与非守护线程</title>
      <link href="/2020/07/17/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/07/17/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程中会同时存在二种线程：也就是守护线程和非守护线程，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。</p><p>将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。但是必须在thread.start()之前设置</p><h2 id="Main线程结束，其他线程一样可以正常运行。"><a href="#Main线程结束，其他线程一样可以正常运行。" class="headerlink" title="Main线程结束，其他线程一样可以正常运行。"></a>Main线程结束，其他线程一样可以正常运行。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class ParentTest</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;parent thread begin &quot;);</span><br><span class="line">        </span><br><span class="line">        ChildThread t1 &#x3D; new ChildThread(&quot;thread1&quot;);</span><br><span class="line">        ChildThread t2 &#x3D; new ChildThread(&quot;thread2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;parent thread over &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class ChildThread extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    private String name &#x3D; null;</span><br><span class="line"> </span><br><span class="line">    public ChildThread(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(this.name + &quot;--child thead begin&quot;);</span><br><span class="line"> </span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(this.name + &quot;--child thead over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">--程序运行结果如下:</span><br><span class="line">parent thread begin </span><br><span class="line">parent thread over </span><br><span class="line">thread2--child thead begin</span><br><span class="line">thread1--child thead begin</span><br><span class="line">thread2--child thead over</span><br><span class="line">thread1--child thead over</span><br></pre></td></tr></table></figure><h2 id="Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程"><a href="#Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程" class="headerlink" title="Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程"></a>Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class ParentTest</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;parent thread begin &quot;);</span><br><span class="line">        </span><br><span class="line">        ChildThread t1 &#x3D; new ChildThread(&quot;thread1&quot;);</span><br><span class="line">        ChildThread t2 &#x3D; new ChildThread(&quot;thread2&quot;);</span><br><span class="line">        t1.setDaemon(true);</span><br><span class="line">        t2.setDaemon(true);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;parent thread over &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ChildThread extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    private String name &#x3D; null;</span><br><span class="line">    public ChildThread(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(this.name + &quot;--child thead begin&quot;);</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this.name + &quot;--child thead over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> 执行结果如下：</span><br><span class="line">parent thread begin</span><br><span class="line">parent thread over</span><br><span class="line">thread1--child thead begin</span><br><span class="line">thread2--child thead begin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java中如何正常终止线程</title>
      <link href="/2020/07/17/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E6%AD%A3%E5%B8%B8%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/07/17/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E6%AD%A3%E5%B8%B8%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="使用退出标志"><a href="#使用退出标志" class="headerlink" title="使用退出标志"></a>使用退出标志</h2><p>使线程正常退出，也就是当 run() 方法完成后线程中止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class test extends Thread&#123;</span><br><span class="line">    public volatile boolean state &#x3D; false;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(!state)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;state的值：&quot;+state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test t&#x3D;new test();</span><br><span class="line">        t.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.state&#x3D;true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;state的值：false</span><br><span class="line">&#x2F;&#x2F;state的值：true</span><br></pre></td></tr></table></figure><h2 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt()"></a>Interrupt()</h2><p>interrupt() 方法并不像在 for 循环语句中使用 break 语句那样干脆，马上就停止循环。调用 interrupt() 方法仅仅是在当前线程中打一个停止的标记，并不是真的停止线程。</p><p>也就是说，线程中断并不会立即终止线程，而是通知目标线程，有人希望你终止。至于目标线程收到通知后会如何处理，则完全由目标线程自行决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class test extends Thread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            test t &#x3D; new test();</span><br><span class="line">            t.start();</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;super.run();</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; 2000; i++) &#123;</span><br><span class="line">            System.out.println(&quot;i&#x3D;&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确使用</p><p>Thread.currentThread().isInterrupted()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class test extends Thread&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            test t &#x3D; new test();</span><br><span class="line">            t.start();</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;super.run();</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; 2000; i++) &#123;</span><br><span class="line">            if(Thread.currentThread().isInterrupted())</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;i&#x3D;&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-stop-终止线程"><a href="#使用-stop-终止线程" class="headerlink" title="使用 stop() 终止线程"></a>使用 stop() 终止线程</h2><p>为什么弃用stop：</p><ol><li>调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。</li><li>调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>序列化和反序列化</title>
      <link href="/2020/07/16/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/07/16/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>[TOC]<br>当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。</p><p>好处:</p><p>一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SerialDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        &#x2F;&#x2F;序列化</span><br><span class="line">        FileOutputStream fos &#x3D; new FileOutputStream(&quot;object.out&quot;);</span><br><span class="line">        ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);</span><br><span class="line">        User user1 &#x3D; new User(&quot;xuliugen&quot;, &quot;123456&quot;, &quot;male&quot;);</span><br><span class="line">        oos.writeObject(user1);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">        &#x2F;&#x2F;反序列化</span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(&quot;object.out&quot;);</span><br><span class="line">        ObjectInputStream ois &#x3D; new ObjectInputStream(fis);</span><br><span class="line">        User user2 &#x3D; (User) ois.readObject();</span><br><span class="line">        System.out.println(user2.getUserName()+ &quot; &quot; + </span><br><span class="line">            user2.getPassword() + &quot; &quot; + user2.getSex());</span><br><span class="line">        &#x2F;&#x2F;反序列化的输出结果为：xuliugen 123456 male</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private String userName;</span><br><span class="line">    private String password;</span><br><span class="line">    private String sex;</span><br><span class="line">    &#x2F;&#x2F;全参构造方法、get和set方法省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/5/4/16a82df8ad1e3584?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/5/4/16a82df8ad0910e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CyclicBarrier剖析</title>
      <link href="/2020/07/16/CyclicBarrier%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/16/CyclicBarrier%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。<br>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，<br>直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>dowait();-&gt;reentrantlock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierExample &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">        final int totalThread &#x3D; 10;</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; totalThread; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">        System.out.print(&quot;before..&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;after..&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before..before..before..before..before..before..before..before..before..before..after..after</span><br><span class="line">..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>JDK 的思路就是：首先，每个 CyclicBarrier 都有一个 Lock，想执行 await 方法，就必须获得这把锁.设置一个计数器，线程每调用一次计数器，就减一，并使用  Condition 阻塞线程。当计数器是0的时候，就唤醒所有线程，并尝试执行构造函数中的任务。由于 CyclicBarrier 是可重复执行的，所以，就需要重置计数器。</p><p>CyclicBarrier 还有一个重要的点，就是 generation 的概念，由于每一个线程可以使用多个 CyclicBarrier，每个 CyclicBarrier 又都可以唤醒线程，那么就需要用代来控制，如果代不匹配，就需要重新休眠。有一个 “代” 的概念，因为 CyclicBarrier 是可以复用的，那么每次所有的线程通过了栅栏，就表示一代过去了.</p><p>而他和 CountDownLatch 的区别在于，CountDownLatch 只能使用一次就 over 了，CyclicBarrier 能使用多次，可以说功能类似，CyclicBarrier 更强大一点。并且 CyclicBarrier 携带了一个在栅栏处可以执行的任务。更加灵活。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch剖析</title>
      <link href="/2020/07/16/CountDownLatch%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/16/CountDownLatch%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>用来控制一个线程等待多个线程。<br>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方<br>法而在等待的线程就会被唤醒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">       final int totalThread &#x3D; 10;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(&quot;run..&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看看这个类的结构：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/16317a37eda063fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p><p>该类是一个独立的类，没有继承别的类，有一个内部类 Sync，这个类继承了 AQS 抽象类，其实，在之前的文章中，我们说过，AQS 是 JUC 所有锁的实现，定义了锁的基本操作。这个内部类重写了 tryAcquireShared 方法和 tryReleaseShared 方法。</p><p>然后呢？我们看看构造方法。</p><h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;</span><br><span class="line">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">    this.sync &#x3D; new Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部实现还是继承了 AQS 的 Sync 类。</p><p>Sync 构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sync(int count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br><span class="line">protected final void setState(int newState) &#123;</span><br><span class="line">    state &#x3D; newState;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * The synchronization state.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure><p>设置了这个 State 变量，我们之前分析过 AQS 的源码，这个变量可以说是 AQS 实现的核心，通过控制这个变量，能够实现共享共享锁或者独占锁。</p><p>那么，如果让我们来设计这个CountDownLatch ，我们该如何设计呢？</p><p>事实上，很简单，我们只需要对 state 变量进行减 1 操作，直到这个变量变成 0，我们就唤醒主线程。</p><p>不知道 Doug Lea 是不是这么设计的？我们去看看。</p><h3 id="await-方法"><a href="#await-方法" class="headerlink" title="await 方法"></a>await 方法</h3><p>主线程会调用这个方法，让自己阻塞，直到被唤醒。</p><p>看看这个方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">       sync.acquireSharedInterruptibly(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">           throws InterruptedException &#123;</span><br><span class="line">       if (Thread.interrupted())</span><br><span class="line">           throw new InterruptedException();</span><br><span class="line">       if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">           doAcquireSharedInterruptibly(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>await 方法调用的是 Syn的  acquireSharedInterruptibly 方法，如果返回值不是大于等于 0 ，说明当前线程不能获取锁，那么就调用 doAcquireSharedInterruptibly 方法。这个方法内部会将当前线程挂起，直到 state 变成 0，才会被唤醒。</p><p>而 <strong>tryAcquireShared</strong> 方法是需要子类自己实现的。我们看看 CountDown 是如何实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return (getState() &#x3D;&#x3D; 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>很简单，就是获取 state 变量，也就是构造方法中设置的参数。</p><p> doAcquireSharedInterruptibly方法的是如何将当前线程挂起的呢？</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个 node 对象，对象中有个属性就是当前线程对象。并将这个 node 添加进队列尾部。</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    &#x2F;&#x2F; 中断失败标记</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找到这个 node 的上一个节点</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F; 如果上一个节点是 head，说明他前面已经没有线程阻挡他获取锁了。</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                &#x2F;&#x2F; 获取锁的状态</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                &#x2F;&#x2F; 如果大于等于0，说明可以获取锁</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 将包装当前线程的 node 设置为 head.</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    &#x2F;&#x2F; 设置他的 next 是 null，让 GC 回收</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    &#x2F;&#x2F; 没有发生错误，不必执行下面的取消操作</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果他的前面的节点的状态时 -1，那么当前线程就需要等待。</span><br><span class="line">            &#x2F;&#x2F; 调用 parkAndCheckInterrupt 等待，如果等待过程中被中断了，抛出异常</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)  </span><br><span class="line">            &#x2F;&#x2F; 如果发生了中断异常，则取消获取锁。</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的代码写了很多注释，总的来说，逻辑如下：</p><ol><li>将当前线程包装成一个 Node 对象，加入到 AQS 的队列尾部。</li><li>如果他前面的 node 是 head ，便可以尝试获取锁了。</li><li>如果不是，则阻塞等待，调用的是 LockSupport.park(this);</li></ol><p><strong>CountDown 的 await 方法就是通过 AQS 的锁机制让主线程阻塞等待。而锁的实现就是通过构造器中设置的 state 变量来控制的。当 state 是 0 的时候，就可以获取锁。然后执行后面的逻辑。</strong></p><p>知道了 await 方法，CountDown 方法应该能猜个大概了。</p><h3 id="countDown-方法"><a href="#countDown-方法" class="headerlink" title="countDown 方法"></a>countDown 方法</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>调用了  AQS 需要子类实现 tryReleaseShared 方法。看看 CountDownLatch 是怎么实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F; Decrement count; signal when transition to zero</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line">        if (c &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc &#x3D; c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>该方法很简单，就是将 state 变量减 1，只要减过之后， state 不是 0，就返回 fasle。</strong></p><p>回到 releaseShared 方法中，当 tryReleaseShared 返回值是 true 时，也就是 state 是 0，就需要执行 doReleaseShared 方法 ，唤醒阻塞在 CountDown 上的线程了。</p><p>唤醒代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">            int ws &#x3D; h.waitStatus;</span><br><span class="line">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>只要队列中 head 节点不是 null，且和 tail 不相等，并且状态是 -1，使用 CAS 将状态修改成 0，如果成功，唤醒当前线程。当前线程就会在 doAcquireSharedInterruptibly 方法中苏醒，再次尝试获取锁，只要他的上一个节点是 head，也就是没有人和他争抢锁，并且 state 是 0，就能够成功获取到锁，继续执行下面的逻辑，不再继续阻塞。</p><p>而我们 CountDownLatch 的主线程也就可以被唤醒从而继续执行了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，CountDownLatch 还是比较简单的。说白了就是通过共享锁实现的。在我们的代码中，只有一个线程会阻塞，那就是我们的主线程， 其余的线程就是在不停的释放 state 变量，直到为 0。从 AQS 的角度来讲，整个工作流程如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/16317a37edbaecf8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p><p>简单的一个流程图，CountDownLatch 就是通过使用 AQS 的机制来实现<code>倒计时门栓</code>的。</p><p>作者：莫那·鲁道<br>链接：<a href="https://juejin.im/post/5ae754dd6fb9a07abc29b2ce" target="_blank" rel="noopener">https://juejin.im/post/5ae754dd6fb9a07abc29b2ce</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>String、StringBuffer、StringBuilder</title>
      <link href="/2020/07/14/String%E3%80%81StringBuffer%E3%80%81StringBuilder/"/>
      <url>/2020/07/14/String%E3%80%81StringBuffer%E3%80%81StringBuilder/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>String 被声明为 final，因此它不可被继承。<br>在 Java 8 中，String 内部使用 char 数组存储数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">&#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">private final char value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">&#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">private final byte[] value;</span><br><span class="line">&#x2F;** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. *&#x2F;</span><br><span class="line">private final byte coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value<br>数组的方法，因此可以保证 String 不可变。</p><h2 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h2><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法<br>进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回<br>这个新字符串的引用。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PriorityQueue源码剖析</title>
      <link href="/2020/07/13/PriorityQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/PriorityQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>Java的集合框架，PriorityQueue源码解析等…</strong></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面以Java <em>ArrayDeque</em>为例讲解了<em>Stack</em>和<em>Queue</em>，其实还有一种特殊的队列叫做<em>PriorityQueue</em>，即优先队列。<strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（*natural ordering*），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于C++的仿函数）。</p><p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p><a href="https://camo.githubusercontent.com/ac0678ef35b8a6cbfca531e2ca645ff2a50e9baf/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f626173652e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ac0678ef35b8a6cbfca531e2ca645ff2a50e9baf/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f626173652e706e67" alt="PriorityQueue"></a></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leftNo &#x3D; parentNo*2+1</span><br><span class="line">rightNo &#x3D; parentNo*2+2</span><br><span class="line">parentNo &#x3D; (nodeNo-1)&#x2F;2</span><br></pre></td></tr></table></figure><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em>。</p><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h3><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><p><a href="https://camo.githubusercontent.com/e7333c5724af6ee4e4fdff70862f9a31a906e361/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f6f666665722e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/e7333c5724af6ee4e4fdff70862f9a31a906e361/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f6f666665722e706e67" alt="add"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;offer(E e)</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e &#x3D;&#x3D; null)&#x2F;&#x2F;不允许放入null元素</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    int i &#x3D; size;</span><br><span class="line">    if (i &gt;&#x3D; queue.length)</span><br><span class="line">        grow(i + 1);&#x2F;&#x2F;自动扩容</span><br><span class="line">    size &#x3D; i + 1;</span><br><span class="line">    if (i &#x3D;&#x3D; 0)&#x2F;&#x2F;队列原来为空，这是插入的第一个元素</span><br><span class="line">        queue[0] &#x3D; e;</span><br><span class="line">    else</span><br><span class="line">        siftUp(i, e);&#x2F;&#x2F;调整</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;siftUp()</span><br><span class="line">private void siftUp(int k, E x) &#123;</span><br><span class="line">    while (k &gt; 0) &#123;</span><br><span class="line">        int parent &#x3D; (k - 1) &gt;&gt;&gt; 1;&#x2F;&#x2F;parentNo &#x3D; (nodeNo-1)&#x2F;2</span><br><span class="line">        Object e &#x3D; queue[parent];</span><br><span class="line">        if (comparator.compare(x, (E) e) &gt;&#x3D; 0)&#x2F;&#x2F;调用比较器的比较方法</span><br><span class="line">            break;</span><br><span class="line">        queue[k] &#x3D; e;</span><br><span class="line">        k &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] &#x3D; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h3 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h3><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong>。</p><p><a href="https://camo.githubusercontent.com/bd7715e17d75c967a49a0df6cc399e544a8cc80c/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f7065656b2e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/bd7715e17d75c967a49a0df6cc399e544a8cc80c/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f7065656b2e706e67" alt="peek"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;peek()</span><br><span class="line">public E peek() &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0)</span><br><span class="line">        return null;</span><br><span class="line">    return (E) queue[0];&#x2F;&#x2F;0下标处的那个元素就是最小的那个</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h3><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><a href="https://camo.githubusercontent.com/dbe221333180c2a9693d46afd4b79cc485569f30/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f706f6c6c2e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/dbe221333180c2a9693d46afd4b79cc485569f30/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f706f6c6c2e706e67" alt="poll"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0)</span><br><span class="line">        return null;</span><br><span class="line">    int s &#x3D; --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result &#x3D; (E) queue[0];&#x2F;&#x2F;0下标处的那个元素就是最小的那个</span><br><span class="line">    E x &#x3D; (E) queue[s];</span><br><span class="line">    queue[s] &#x3D; null;</span><br><span class="line">    if (s !&#x3D; 0)</span><br><span class="line">        siftDown(0, x);&#x2F;&#x2F;调整</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素（也就是最小的那个元素）。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;siftDown()</span><br><span class="line">private void siftDown(int k, E x) &#123;</span><br><span class="line">    int half &#x3D; size &gt;&gt;&gt; 1;</span><br><span class="line">    while (k &lt; half) &#123;</span><br><span class="line">    &#x2F;&#x2F;首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span><br><span class="line">        int child &#x3D; (k &lt;&lt; 1) + 1;&#x2F;&#x2F;leftNo &#x3D; parentNo*2+1</span><br><span class="line">        Object c &#x3D; queue[child];</span><br><span class="line">        int right &#x3D; child + 1;</span><br><span class="line">        if (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">            c &#x3D; queue[child &#x3D; right];</span><br><span class="line">        if (comparator.compare(x, (E) c) &lt;&#x3D; 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] &#x3D; c;&#x2F;&#x2F;然后用c取代原来的值</span><br><span class="line">        k &#x3D; child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] &#x3D; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</p><p><a href="https://camo.githubusercontent.com/6511a83152577db51c77d1448facc75da6fd2a17/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f72656d6f7665322e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6511a83152577db51c77d1448facc75da6fd2a17/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f5072696f7269747951756575655f72656d6f7665322e706e67" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;remove(Object o)</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">&#x2F;&#x2F;通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span><br><span class="line">    int i &#x3D; indexOf(o);</span><br><span class="line">    if (i &#x3D;&#x3D; -1)</span><br><span class="line">        return false;</span><br><span class="line">    int s &#x3D; --size;</span><br><span class="line">    if (s &#x3D;&#x3D; i) &#x2F;&#x2F;情况1</span><br><span class="line">        queue[i] &#x3D; null;</span><br><span class="line">    else &#123;</span><br><span class="line">        E moved &#x3D; (E) queue[s];</span><br><span class="line">        queue[s] &#x3D; null;</span><br><span class="line">        siftDown(i, moved);&#x2F;&#x2F;情况2</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stack&amp;Queue源码剖析</title>
      <link href="/2020/07/13/Stack-Queue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/Stack-Queue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Stack-amp-Queue概述"><a href="#Stack-amp-Queue概述" class="headerlink" title="Stack &amp; Queue概述"></a>Stack &amp; Queue概述</h2><p>Java里有一个叫做<em>Stack</em>的类，却没有叫做<em>Queue</em>的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>；既然<em>Queue</em>只是一个接口，当需要使用队列时也就首选<em>ArrayDeque</em>了（次选是<em>LinkedList</em>）。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><em>Queue<em>接口继承自Collection接口，除了最基本的Collection的方法之外，它还支持额外的</em>insertion</em>, <em>extraction</em>和<em>inspection</em>操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现（没有则返回null）。</p><table><thead><tr><th></th><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td><td>offer(e)</td></tr><tr><td>Remove</td><td>remove()</td><td>poll()</td></tr><tr><td>Examine</td><td>element()</td><td>peek()</td></tr></tbody></table><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><code>Deque</code>是”double ended queue”, 表示双向的队列，英文读作”deck”. Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现（没有则返回null）。</p><p><em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<em>Deque</em>与<em>Queue</em>相对应的接口：</p><p>当把<code>Deque</code>当做FIFO的<code>queue</code>来使用时，元素是从<code>deque</code>的尾部添加，从头部进行删除的； 所以<code>deque</code>的部分方法是和<code>queue</code>是等同的。具体如下：</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>add(e)</code></td><td><code>addLast(e)</code></td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td><code>offer(e)</code></td><td><code>offerLast(e)</code></td><td>向队尾插入元素，失败则返回<code>false</code></td></tr><tr><td><code>remove()</code></td><td><code>removeFirst()</code></td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td><code>poll()</code></td><td><code>pollFirst()</code></td><td>获取并删除队首元素，失败则返回<code>null</code></td></tr><tr><td><code>element()</code></td><td><code>getFirst()</code></td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除队首元素，失败则返回<code>null</code></td></tr></tbody></table><p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>push(e)</code></td><td><code>addFirst(e)</code></td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>offerFirst(e)</code></td><td>向栈顶插入元素，失败则返回<code>false</code></td></tr><tr><td><code>pop()</code></td><td><code>removeFirst()</code></td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>pollFirst()</code></td><td>获取并删除栈顶元素，失败则返回<code>null</code></td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则返回<code>null</code></td></tr></tbody></table><p><em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现。</p><p>由于官方更推荐使用<em>AarryDeque</em>用作栈和队列。从名字可以看出<em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p><p><a href="https://camo.githubusercontent.com/fd346bba6c6485031d222ba6c3b16c592846e0c4/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f626173652e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/fd346bba6c6485031d222ba6c3b16c592846e0c4/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f626173652e706e67" alt="ArrayDeque"></a></p><p>上图中我们看到，<strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以<code>head</code>不一定总等于0，<code>tail</code>也不一定总是比<code>head</code>大。</p><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h3><p><code>addFirst(E e)</code>的作用是在<em>Deque</em>的首端插入元素，也就是在<code>head</code>的前面插入元素，在空间足够且下标没有越界的情况下，只需要将<code>elements[--head] = e</code>即可。</p><p><a href="https://camo.githubusercontent.com/04f331e67b3d429fe7d1570885e6ac32b8a0ba70/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f61646446697273742e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/04f331e67b3d429fe7d1570885e6ac32b8a0ba70/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f61646446697273742e706e67" alt="addFirst"></a></p><p>实际需要考虑：1.空间是否够用，以及2.下标是否越界的问题。上图中，如果<code>head</code>为<code>0</code>之后接着调用<code>addFirst()</code>，虽然空余空间还够用，但<code>head</code>为<code>-1</code>，下标越界了。下列代码很好的解决了这两个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;addFirst(E e)</span><br><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    if (e &#x3D;&#x3D; null)&#x2F;&#x2F;不允许放入null</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[head &#x3D; (head - 1) &amp; (elements.length - 1)] &#x3D; e;&#x2F;&#x2F;2.下标是否越界</span><br><span class="line">    if (head &#x3D;&#x3D; tail)&#x2F;&#x2F;1.空间是否够用</span><br><span class="line">        doubleCapacity();&#x2F;&#x2F;扩容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，<code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。因为<code>elements.length</code>必需是<code>2</code>的指数倍，<code>elements - 1</code>就是二进制低位全<code>1</code>，跟<code>head - 1</code>相与之后就起到了取模的作用，如果<code>head - 1</code>为负数（其实只可能是-1），则相当于对其取相对于<code>elements.length</code>的补码。</p><p>下面再说说扩容函数<code>doubleCapacity()</code>，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：</p><p><a href="https://camo.githubusercontent.com/1d720a181a6ca38a00d311025d96a3daf776b176/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f646f75626c6543617061636974792e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1d720a181a6ca38a00d311025d96a3daf776b176/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f646f75626c6543617061636974792e706e67" alt="doubleCapacity"></a></p><p>图中我们看到，复制分两次进行，第一次复制<code>head</code>右边的元素，第二次复制<code>head</code>左边的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;doubleCapacity()</span><br><span class="line">private void doubleCapacity() &#123;</span><br><span class="line">    assert head &#x3D;&#x3D; tail;</span><br><span class="line">    int p &#x3D; head;</span><br><span class="line">    int n &#x3D; elements.length;</span><br><span class="line">    int r &#x3D; n - p; &#x2F;&#x2F; head右边元素的个数</span><br><span class="line">    int newCapacity &#x3D; n &lt;&lt; 1;&#x2F;&#x2F;原空间的2倍</span><br><span class="line">    if (newCapacity &lt; 0)</span><br><span class="line">        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span><br><span class="line">    Object[] a &#x3D; new Object[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, 0, r);&#x2F;&#x2F;复制右半部分，对应上图中绿色部分</span><br><span class="line">    System.arraycopy(elements, 0, a, r, p);&#x2F;&#x2F;复制左半部分，对应上图中灰色部分</span><br><span class="line">    elements &#x3D; (E[])a;</span><br><span class="line">    head &#x3D; 0;</span><br><span class="line">    tail &#x3D; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h3><p><code>addLast(E e)</code>的作用是在<em>Deque</em>的尾端插入元素，也就是在<code>tail</code>的位置插入元素，由于<code>tail</code>总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用<code>doubleCapacity()</code>进行扩容。</p><p><a href="https://camo.githubusercontent.com/d70399fc026fabaebd445cf59a6e4d5bd1024e76/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f6164644c6173742e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d70399fc026fabaebd445cf59a6e4d5bd1024e76/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f417272617944657175655f6164644c6173742e706e67" alt="addLast"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    if (e &#x3D;&#x3D; null)&#x2F;&#x2F;不允许放入null</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[tail] &#x3D; e;&#x2F;&#x2F;赋值</span><br><span class="line">    if ( (tail &#x3D; (tail + 1) &amp; (elements.length - 1)) &#x3D;&#x3D; head)&#x2F;&#x2F;下标越界处理</span><br><span class="line">        doubleCapacity();&#x2F;&#x2F;扩容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a>pollFirst()</h3><p><code>pollFirst()</code>的作用是删除并返回<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于<code>ArrayDeque</code>中不允许放入<code>null</code>，当<code>elements[head] == null</code>时，意味着容器为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public E pollFirst() &#123;</span><br><span class="line">    E result &#x3D; elements[head];</span><br><span class="line">    if (result &#x3D;&#x3D; null)&#x2F;&#x2F;null值意味着deque为空</span><br><span class="line">        return null;</span><br><span class="line">    elements[h] &#x3D; null;&#x2F;&#x2F;let GC work</span><br><span class="line">    head &#x3D; (head + 1) &amp; (elements.length - 1);&#x2F;&#x2F;下标越界处理</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast()"></a>pollLast()</h3><p><code>pollLast()</code>的作用是删除并返回<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public E pollLast() &#123;</span><br><span class="line">    int t &#x3D; (tail - 1) &amp; (elements.length - 1);&#x2F;&#x2F;tail的上一个位置是最后一个元素</span><br><span class="line">    E result &#x3D; elements[t];</span><br><span class="line">    if (result &#x3D;&#x3D; null)&#x2F;&#x2F;null值意味着deque为空</span><br><span class="line">        return null;</span><br><span class="line">    elements[t] &#x3D; null;&#x2F;&#x2F;let GC work</span><br><span class="line">    tail &#x3D; t;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="peekFirst"><a href="#peekFirst" class="headerlink" title="peekFirst()"></a>peekFirst()</h3><p><code>peekFirst()</code>的作用是返回但不删除<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素，直接返回<code>elements[head]</code>即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E peekFirst() &#123;</span><br><span class="line">    return elements[head]; &#x2F;&#x2F; elements[head] is null if deque empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="peekLast"><a href="#peekLast" class="headerlink" title="peekLast()"></a>peekLast()</h3><p><code>peekLast()</code>的作用是返回但不删除<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E peekLast() &#123;</span><br><span class="line">    return elements[(tail - 1) &amp; (elements.length - 1)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap-ConcurrentHashMap面试必问</title>
      <link href="/2020/07/13/HashMap-ConcurrentHashMap%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE/"/>
      <url>/2020/07/13/HashMap-ConcurrentHashMap%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>众所周知，HashMap的底层结构是<strong>数组和链表</strong>组成的，不过在jdk1.7和jdk1.8中具体实现略有不同。</p><h3 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><p>先看图<a href="https://camo.githubusercontent.com/51e51a0e34f51ceda409cac151e34156169e3d53/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432626537373935382e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/51e51a0e34f51ceda409cac151e34156169e3d53/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432626537373935382e6a7067" alt="img"></a></p><p>再看看1.7的实现<a href="https://camo.githubusercontent.com/d113e661f95ade8a9c24b0f347c8cb4fdc2417f6/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432626664366162612e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d113e661f95ade8a9c24b0f347c8cb4fdc2417f6/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432626664366162612e6a7067" alt="img"></a></p><p>介绍成员变量：</p><ul><li>初始化桶大小，因为底层是数组，所以这是数组默认的大小。</li><li>桶最大值。</li><li>默认的负载因子（0.75）</li><li>table真正存放数据的数组。</li><li>map存放数量的大小</li><li>桶大小，可在构造函数时显式指定。</li><li>负载因子，可在构造函数时显式指定。</li></ul><h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public HashMap() &#123;</span><br><span class="line">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); &#x2F;&#x2F; 桶和负载因子</span><br><span class="line">&#125;</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    threshold &#x3D; initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给定的默认容量为16，负载因子为0.75.</li><li>Map在使用过程中不断的往里面存放数据，当数量达到了<code>16 * 0.75 = 12</code>就需要将当前16的容量进行扩容，而扩容这个过程涉及到rehash（重新哈希）、复制数据等操作，所有非常消耗性能。</li><li>因此通常建议能提前预估HashMap的大小最好，尽量的减少扩容带来的额外性能损耗。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Ideally, under random hashCodes, the frequency of</span><br><span class="line"></span><br><span class="line">nodes in bins follows a Poisson distribution</span><br><span class="line">(http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Poisson_distribution) with a</span><br><span class="line">parameter of about 0.5 on average for the default resizing</span><br><span class="line">threshold of 0.75, although with a large variance because of</span><br><span class="line">resizing granularity. Ignoring variance, the expected</span><br><span class="line">occurrences of list size k are (exp(-0.5) * pow(0.5, k) &#x2F;</span><br><span class="line">factorial(k)). The first values are:</span><br><span class="line">0: 0.60653066</span><br><span class="line">1: 0.30326533</span><br><span class="line">2: 0.07581633</span><br><span class="line">3: 0.01263606</span><br><span class="line">4: 0.00157952</span><br><span class="line">5: 0.00015795</span><br><span class="line">6: 0.00001316</span><br><span class="line">7: 0.00000094</span><br><span class="line">8: 0.00000006</span><br><span class="line">more: less than 1 in ten million</span><br><span class="line">注意wiki链接中的关键字：Poisson_distribution</span><br><span class="line">泊淞分布啊</span><br></pre></td></tr></table></figure><p>简单翻译一下就是在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布，同时给出了桶中元素个数和概率的对照表。</p><p>从上面的表中可以看到当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</p><p>好了，再深挖就要挖到统计学那边去了，就此打住，重申一下使用hash容器请尽量指定初始容量，且是2的幂次方。</p><p>关于泊淞分布的知识请看</p><p><a href="http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html#comment-356111" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html#comment-356111</a></p><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Entry&lt;K,V&gt;[] table &#x3D; (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p>如何定义呢？<a href="https://camo.githubusercontent.com/d4896d60a3183274a1e559b0a66a29ffedfb7a44/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633038653639332e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d4896d60a3183274a1e559b0a66a29ffedfb7a44/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633038653639332e6a7067" alt="img"></a></p><p>Entry是Hashmap中的一个内部类，从他的成员变量很容易看出：</p><ul><li>key就是写入时的键</li><li>value自然就是值</li><li>开始的时候就提到HashMap是由数组和链表组成，所以这个next就是用于实现链表结构</li><li>hash存放的是当前key的hashcode</li></ul><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold); &#x2F;&#x2F; 判断数组是否需要初始化</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return putForNullKey(value); &#x2F;&#x2F; 判断key是否为空</span><br><span class="line">    int hash &#x3D; hash(key); &#x2F;&#x2F; 计算hashcode</span><br><span class="line">    int i &#x3D; indexFor(hash, table.length); &#x2F;&#x2F; 计算桶</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123; &#x2F;&#x2F; 遍历判断链表中的key和hashcode是否相等，等就替换</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i); &#x2F;&#x2F; 没有就添加新的呗</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前数组是否需要初始化</li><li>如果key为空，则put一个空值进去</li><li>根据key计算hashcode</li><li>根据计算的hashcode定位index的桶</li><li>如果桶是一个链表，则需要遍历判断里面的hashcode、key是否和传入的key相等，如果相等则进行覆盖，并返回原来的值</li><li>如果桶是空的，说明当前位置没有数据存入，此时新增一个Entry对象写入当前位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;&#x2F;&#x2F; 是否扩容</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;</span><br><span class="line">        bucketIndex &#x3D; indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];</span><br><span class="line">    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当调用addEntry写入Entry时需要判断是否需要扩容</li><li>如果需要就进行两倍扩充，并将当前的key重新hash并定位。</li><li>而在createEntry中会将当前位置的桶传入到新建的桶中，如果当前桶油值就会在位置形成链表。</li></ul><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null) &#x2F;&#x2F; 判断key是否为空</span><br><span class="line">        return getForNullKey(); &#x2F;&#x2F; 为空，就返回空值</span><br><span class="line">    Entry&lt;K,V&gt; entry &#x3D; getEntry(key); &#x2F;&#x2F; get entry</span><br><span class="line">    return null &#x3D;&#x3D; entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key); &#x2F;&#x2F;根据key和hashcode</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];</span><br><span class="line">         e !&#x3D; null;</span><br><span class="line">         e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先根据key计算hashcode，然后定位具体的桶</li><li>判断该位置是否为链表</li><li>不是链接就根据key和hashcode是否相等来返回值</li><li>为链表则需要遍历直到key和hashcode相等就返回值</li><li>啥都没得，就返回null</li></ul><h3 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p>不知道 1.7 的实现大家看出需要优化的点没有？</p><p>其实一个很明显的地方就是链表</p><p><strong>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 <code>O(N)</code>。</strong></p><p><a href="https://camo.githubusercontent.com/1bd19ba02d0aa93cf7d6c947c0672cafe7e478fd/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633163316364372e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1bd19ba02d0aa93cf7d6c947c0672cafe7e478fd/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633163316364372e6a7067" alt="img"></a></p><p>看看成员变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line">&#x2F;**</span><br><span class="line"> * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line"> * by either of the constructors with arguments.</span><br><span class="line"> * MUST be a power of two &lt;&#x3D; 1&lt;&lt;30.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * The load factor used when none specified in constructor.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Holds cached entrySet(). Note that AbstractMap fields are used</span><br><span class="line"> * for keySet() and values().</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * The number of key-value mappings contained in this map.</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient int size;</span><br></pre></td></tr></table></figure><ul><li><code>TREEIFY_THRESHOLD</code> 用于判断是否需要将链表转换为红黑树的阈值。</li><li>HashEntry 修改为 Node。</li><li>Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 <code>key value hashcode next</code> 等数据。</li></ul><h4 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h4><p><a href="https://camo.githubusercontent.com/068bac3f602c768691b1def1d91a114c457dac95/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633337383039302e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/068bac3f602c768691b1def1d91a114c457dac95/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633337383039302e6a7067" alt="img"></a></p><ul><li>判断当前桶是否为空，空的就需要初始化（resize中会判断是否进行初始化）</li><li>根据当前key的hashcode定位到具体的桶中并判断是否为空，为空则表明没有Hash冲突，就直接在当前位置创建一个新桶</li><li>如果当前桶油值（Hash冲突），那么就要比较当前桶中的key、key的hashcode与写入的key是否相等，相等就赋值给e，在第8步的时候会统一进行赋值及返回</li><li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据</li><li>如果是个链表，就需要将当前的key、value封装称一个新节点写入到当前桶的后面形成链表。</li><li>接着判断当前链表的大小是否大于预设的阈值，大于就要转换成为红黑树</li><li>如果在遍历过程中找到key相同时直接退出遍历。</li><li>如果<code>e != null</code>就相当于存在相同的key，那就需要将值覆盖。</li><li>最后判断是否需要进行扩容。</li></ul><h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先将key hash之后取得所定位的桶</li><li>如果桶为空，则直接返回null</li><li>否则判断桶的第一个位置（有可能是链表、红黑树）的key是否为查询的key，是就直接返回value</li><li>如果第一个不匹配，则判断它的下一个是红黑树还是链表</li><li>红黑树就按照树的查找方式返回值</li><li>不然就按照链表的方式遍历匹配返回值</li></ul><p><strong>从这两个核心方法（get/put）可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 <code>O(logn)</code>。</strong></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            map.put(UUID.randomUUID().toString(), &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>HashMap扩容的时候会调用resize()方法，就是这里的并发操作容易在一个桶上形成环形链表</li><li>这样当获取一个不存在的key时，计算出的index正好是环形链表的下标就会出现死循环。</li><li>但是1.7的头插法造成的问题，1.8改变了插入顺序，就解决了这个问题，但是为了内存可见性等安全性，还是需要ConCurrentHashMap</li></ul><p><a href="https://camo.githubusercontent.com/b7a084415c8a08d4fa15227227a863eb649f994e/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633465646535342e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/b7a084415c8a08d4fa15227227a863eb649f994e/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633465646535342e6a7067" alt="img"></a></p><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><p>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator &#x3D; map.entrySet().iterator();</span><br><span class="line">        while (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next &#x3D; entryIterator.next();</span><br><span class="line">            System.out.println(&quot;key&#x3D;&quot; + next.getKey() + &quot; value&#x3D;&quot; + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator &#x3D; map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String key &#x3D; iterator.next();</span><br><span class="line">            System.out.println(&quot;key&#x3D;&quot; + key + &quot; value&#x3D;&quot; + map.get(key));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>建议使用第一种，同时可以把key value取出。</li><li>第二种还需要通过key取一次key，效率较低。</li></ul><h2 id="ConCurrentHashMap"><a href="#ConCurrentHashMap" class="headerlink" title="ConCurrentHashMap"></a>ConCurrentHashMap</h2><h3 id="jdk1-7-1"><a href="#jdk1-7-1" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><p><a href="https://camo.githubusercontent.com/ecc8e454cddfede7ac97cfd212b0a13682f1b53a/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633563653935632e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ecc8e454cddfede7ac97cfd212b0a13682f1b53a/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633563653935632e6a7067" alt="img"></a></p><ul><li>Segment数组</li><li>HashEntry组成</li><li>和HashMap一样，仍然是数组加链表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span><br><span class="line"> *&#x2F;</span><br><span class="line">final Segment&lt;K,V&gt;[] segments;</span><br><span class="line">transient Set&lt;K&gt; keySet;</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line">       private static final long serialVersionUID &#x3D; 2249069246763182397L;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span><br><span class="line">       transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">       transient int count;</span><br><span class="line">       transient int modCount;</span><br><span class="line">       transient int threshold;</span><br><span class="line">       final float loadFactor;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/a55002a94ff6ed86b32ed1475168147d72e3aacc/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633633356336392e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/a55002a94ff6ed86b32ed1475168147d72e3aacc/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432633633356336392e6a7067" alt="img"></a></p><ul><li>唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</li><li>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。</li><li>不会像HashTable那样不管是put还是get操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。</li><li>每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</li></ul><h4 id="put-2"><a href="#put-2" class="headerlink" title="put"></a>put</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    if (value &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck</span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment</span><br><span class="line">        s &#x3D; ensureSegment(j);</span><br><span class="line">    return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过key定位到Segment，之后在对应的Segment中进行具体的put</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">        int index &#x3D; (tab.length - 1) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class="line">            if (e !&#x3D; null) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue &#x3D; e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value &#x3D; value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                e &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (node !&#x3D; null)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                int c &#x3D; count + 1;</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                else</span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count &#x3D; c;</span><br><span class="line">                oldValue &#x3D; null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虽然HashEntry中的value是用volatile关键字修饰的，但是并不能保证并发的原子性，所以put操作仍然需要加锁处理。</li><li>首先第一步的时候会尝试获取锁，如果获取失败肯定就是其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</li></ul><p><a href="https://camo.githubusercontent.com/71f965d21a47f284830a21fac13f956ca08fe757/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636333633938322e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/71f965d21a47f284830a21fac13f956ca08fe757/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636333633938322e6a7067" alt="img"></a></p><ul><li>尝试获取自旋锁</li><li>如果重试的次数达到了<code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li></ul><p><a href="https://camo.githubusercontent.com/95b3b80b9d412127883290166fcd4b612d4b36f1/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636432356333372e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/95b3b80b9d412127883290166fcd4b612d4b36f1/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636432356333372e6a7067" alt="img"></a></p><ul><li>将当前的Segment中的table通过key的hashcode定位到HashEntry</li><li>遍历该HashEntry，如果不为空则判断传入的key和当前遍历的key是否相等，相等则覆盖旧的value</li><li>不为空则需要新建一个HashEntry并加入到Segment中，同时会先判断是否需要扩容</li><li>最后会解除在1中所获取当前Segment的所。</li></ul><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; &#x2F;&#x2F; manually integrate access methods to reduce overhead</span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    int h &#x3D; hash(key);</span><br><span class="line">    long u &#x3D; (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) !&#x3D; null &amp;&amp;</span><br><span class="line">        (tab &#x3D; s.table) !&#x3D; null) &#123;</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; h &amp;&amp; key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</li><li>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</li><li>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</li></ul><h3 id="jdk1-8-1"><a href="#jdk1-8-1" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p><strong>那就是查询遍历链表效率太低。</strong></p><p><a href="https://camo.githubusercontent.com/28bb34f51a46357d1636147c6290b5098592250b/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636533333739352e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/28bb34f51a46357d1636147c6290b5098592250b/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636533333739352e6a7067" alt="img"></a></p><p><strong>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性</strong></p><p><a href="https://camo.githubusercontent.com/683f45273cb02892783747659b250bc58ba66a8d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636565626530322e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/683f45273cb02892783747659b250bc58ba66a8d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636565626530322e6a7067" alt="img"></a></p><ul><li>也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。</li><li>其中的 <code>val next</code> 都用了 volatile 修饰，保证了可见性。</li></ul><h4 id="put-3"><a href="#put-3" class="headerlink" title="put"></a>put</h4><p><a href="https://camo.githubusercontent.com/865ef617cb35cbbb2da99fc73313df2c909b498d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636663333239332e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/865ef617cb35cbbb2da99fc73313df2c909b498d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432636663333239332e6a7067" alt="img"></a></p><ul><li>根据key计算出hashcode</li><li>判断是否需要进行初始化</li><li>f即为当前key定位出的Node，如果为空表示当前位置可以写入数据，利用CAS尝试写入，失败则自旋保证成功。</li><li>如果当前位置的<code>hashcode == MOVED == -1</code>，则需要进行扩容</li><li>如果都不满足，则利用synchronized锁写入数据</li><li>如果数量大于<code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ul><h4 id="get-2"><a href="#get-2" class="headerlink" title="get"></a>get</h4><p><a href="https://camo.githubusercontent.com/c7a73630d6aa169d98cae7209f604c12414c9541/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432643232633663622e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/c7a73630d6aa169d98cae7209f604c12414c9541/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30352f30382f356364316432643232633663622e6a7067" alt="img"></a></p><ul><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值。</li></ul><p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code>），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>套路：</p><ul><li>谈谈你理解的 HashMap，讲讲其中的 get put 过程。</li><li>1.8 做了什么优化？</li><li>是线程安全的嘛？</li><li>不安全会导致哪些问题？</li><li>如何解决？有没有线程安全的并发容器？</li><li>ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？<h2 id="源码图"><a href="#源码图" class="headerlink" title="源码图"></a>源码图</h2><img src="https://img-blog.csdnimg.cn/20200713192652430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="img"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TreeMap(Set)源码剖析</title>
      <link href="/2020/07/13/TreeMap-Set-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/TreeMap-Set-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>基于红黑树实现的 TreeMap 提供了平均和最差时间复杂度均为 O(log<del>n</del>) 的增删改查操作，该集合最大的特点就是 Key 的有序性。TreeMap 继承了 SortedMap 和 NavigableMap，SortedMap 表示 Key 是有序不可重复的，支持获取头尾 Key-Value 元素，或者根据 Key 指定范围获取子集合等。插入的 Key 必须实现 Comparable 接口或提供额外的 Comparator 比较器，所以 Key 不允许为 null。NavigableMap 继承了 SortedMap，根据指定的搜索条件返回最匹配的 Key-Value 元素。</p><p>不同于 HashMap 的是 TreeMap 并非一定要重写 hashCode 和 equals 方法来达到 Key 去重的目的。HashMap 是依靠 hashCode 和 equals 来去重的，而 TreeMap 依靠 Comparable 或 Comparator 来实现去重。 TreeMap 对 Key 进行排序时，如果比较器不为空就会优先使用比较器的 compare 方法，如果比较器为空就会使用 Key 实现的自然排序 Comparable 接口的 compareTo 方法，如果两者都不满足就会抛出异常。</p><p>TreeMap 通过 put 和 deleteEntry 实现红黑树增加和删除节点的操作。插入新节点的规则有三个：① 需要调整的新节点总是红色的。② 如果插入新节点的父节点是黑色的，不需要调整。③ 如果插入新节点的父节点是红色的，由于红黑树中不能出现相邻的红色，则进入循环判断，通过重新着色或左右旋转来调整。TreeMap 的插入操作就是按照 Key 的对比往下遍历，大于比较节点值的向右查找，小于的向左查找，先按照二叉查找树的特性操作，无需关心节点颜色与树的平衡，后续会重新着色和旋转，保持红黑树的特性。</p><p>TreeMap 是线程不安全的集合，在多线程操作时需要添加互斥机制，或者把对象放在 Collections.synchronizedMap() 中实现同步。在 JDK 7 之后的 HashMap、TreeSet、ConcurrentHashMap 也都是使用红黑树的方式管理节点。如果只是对单个元素进行排序，使用 TreeSet 即可。TreeSet 的底层就是 TreeMap，Value 共享一个静态的 Object 对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LinkedHashMap(Set)源码剖析</title>
      <link href="/2020/07/13/LinkedHashMap-Set-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/LinkedHashMap-Set-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>Java的集合框架，TreeSet &amp; TreeMap源码解析等…</strong></p><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>概括的说，<code>LinkedHashMap</code> 继承自<code>HashMap</code>，实现了<code>Map&lt;K,V&gt;</code>接口。其内部还维护了一个<strong>双向链表</strong>，在每次<strong>插入数据，或者访问、修改数据</strong>时，<strong>会增加节点、或调整链表的节点顺序</strong>。以决定迭代时输出的顺序。</p><p>默认情况，遍历时的顺序是<strong>按照插入节点的顺序</strong>。这也是其与<code>HashMap</code>最大的区别。<br>也可以在构造时传入<code>accessOrder</code>参数，使得其遍历顺序<strong>按照访问的顺序</strong>输出。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><code>LinkedHashMap</code>的节点<code>Entry&lt;K,V&gt;</code>继承自<code>HashMap.Node&lt;K,V&gt;</code>，在其基础上扩展了一下。改成了一个<strong>双向链表</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时类里有两个成员变量<code>head tail</code>,分别指向内部双向链表的表头、表尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;双向链表的头结点</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;双向链表的尾节点</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h3><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在<br>每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未<br>使用的节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">       LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">       if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">           LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">               (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">           p.after &#x3D; null;</span><br><span class="line">           if (b &#x3D;&#x3D; null)</span><br><span class="line">               head &#x3D; a;</span><br><span class="line">           else</span><br><span class="line">               b.after &#x3D; a;</span><br><span class="line">           if (a !&#x3D; null)</span><br><span class="line">               a.before &#x3D; b;</span><br><span class="line">           else</span><br><span class="line">               last &#x3D; b;</span><br><span class="line">           if (last &#x3D;&#x3D; null)</span><br><span class="line">               head &#x3D; p;</span><br><span class="line">           else &#123;</span><br><span class="line">               p.before &#x3D; last;</span><br><span class="line">               last.after &#x3D; p;</span><br><span class="line">           &#125;</span><br><span class="line">           tail &#x3D; p;</span><br><span class="line">           ++modCount;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h3><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。<br>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    static class LRUCache&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt;</span><br><span class="line">    &#123;</span><br><span class="line">     private static final int MAX_ENTRIES&#x3D;3;</span><br><span class="line">     protected  boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</span><br><span class="line">     &#123;</span><br><span class="line">         return size()&gt;MAX_ENTRIES;</span><br><span class="line">     &#125;</span><br><span class="line">     LRUCache()</span><br><span class="line">     &#123;</span><br><span class="line">         super(MAX_ENTRIES,0.75f,true);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LRUCache&lt;Integer, String&gt; cache &#x3D; new LRUCache&lt;&gt;();</span><br><span class="line">        cache.put(1, &quot;a&quot;);</span><br><span class="line">        cache.put(2, &quot;b&quot;);</span><br><span class="line">        cache.put(3, &quot;c&quot;);</span><br><span class="line">        cache.get(1);</span><br><span class="line">        cache.put(4, &quot;d&quot;);</span><br><span class="line">        System.out.println(cache.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>前面已经说过<em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashSet&lt;E&gt;</span><br><span class="line">    extends HashSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#x2F;&#x2F; LinkedHashSet里面有一个LinkedHashMap</span><br><span class="line">    public LinkedHashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        map &#x3D; new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    public boolean add(E e) &#123;&#x2F;&#x2F;简单的方法转换</span><br><span class="line">        return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashSet源码剖析</title>
      <link href="/2020/07/13/HashSet%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/HashSet%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>HashSet 的是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，HashMap 的 Key 值即 HashSet 存储的元素，所有 Key 都使用相同的 Value ，一个 static final 修饰的变量名为 PRESENT 的 Object 类型的对象。使用 Key 保证集合元素的唯一性，但它不保证集合元素的有序性。由于 HashSet 的底层是 HashMap 实现的，HashMap 是线程不安全的，因此 HashSet 也是线程不安全的。</p><p>HashSet 判断元素是否相同时，对于基本类型的包装类，直接按值进行比较。对于引用数据类型，会先比较 hashCode 返回值是否相同，如果不同则代表不是同一个对象，如果相同则继续比较 equals 方法返回值是否相同，都相同说明是同一个对象。</p><p>TreeSet 的是使用 TreeMap 实现的，底层为树结构，在添加新元素到集合中时，按照某种比较规则将其插入合适的位置，保证插入后的集合仍然是有序的。LinkedHashSet 继承自 HashSet，内部使用链表维护了元素插入的顺序。</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList源码剖析</title>
      <link href="/2020/07/13/LinkedList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/13/LinkedList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（<em>Queue</em>），同时又可以看作一个栈（<em>Stack</em>）。这样看来，<em>LinkedList</em>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，一方面是因为Java官方已经声明不建议使用<em>Stack</em>类，更遗憾的是，Java里根本没有一个叫做<em>Queue</em>的类（它是个接口名字）。关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>（当作栈或队列使用时）有着更好的性能。</p><p><a href="https://camo.githubusercontent.com/af8b89b4d140940680305ab75b62b457c384fee3/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f626173652e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/af8b89b4d140940680305ab75b62b457c384fee3/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f626173652e706e67" alt="LinkedList"></a></p><p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p><h2 id="LinkedLists实现"><a href="#LinkedLists实现" class="headerlink" title="LinkedLists实现"></a>LinkedLists实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟<em>List</em>接口相关的函数，而将<em>Queue</em>和<em>Stack</em>以及<em>Deque</em>相关的知识放在下一节讲。双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候<code>first</code>和<code>last</code>都指向<code>null</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  transient int size &#x3D; 0;</span><br><span class="line">  transient Node&lt;E&gt; first;</span><br><span class="line">  transient Node&lt;E&gt; last;</span><br><span class="line">&#x2F;&#x2F; Node是私有的内部类</span><br><span class="line">  private static class Node&lt;E&gt; &#123;</span><br><span class="line">      E item;</span><br><span class="line">      Node&lt;E&gt; next;</span><br><span class="line">      Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">          this.item &#x3D; element;</span><br><span class="line">          this.next &#x3D; next;</span><br><span class="line">          this.prev &#x3D; prev;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getFirst-，getLast"><a href="#getFirst-，getLast" class="headerlink" title="getFirst()，getLast()"></a>getFirst()，getLast()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public E getFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E getLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeFirst-，removeLast-，remove-e-，remove-index"><a href="#removeFirst-，removeLast-，remove-e-，remove-index" class="headerlink" title="removeFirst()，removeLast()，remove(e)，remove(index)"></a>removeFirst()，removeLast()，remove(e)，remove(index)</h3><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p><p><a href="https://camo.githubusercontent.com/20a94f0e8e77cbbf0c70264439b940cf1e64ff23/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f72656d6f76652e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/20a94f0e8e77cbbf0c70264439b940cf1e64ff23/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f72656d6f76652e706e67" alt="remove"></a></p><p>删除元素 - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判读的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">    E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line"></span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 第一个元素</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next &#x3D; next;</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 最后一个元素</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev &#x3D; prev;</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item &#x3D; null; &#x2F;&#x2F; GC</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remove(int index)</code>使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除head元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    first &#x3D; next;</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除last元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public E removeLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;</span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    last &#x3D; prev;</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p><em>add()\</em>方法有两个版本，一个是<code>add(E e)</code>，该方法在*LinkedList*的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last &#x3D; newNode;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/4831538ace9fd84081b890f29bd06e0500fa9703/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f6164642e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/4831538ace9fd84081b890f29bd06e0500fa9703/68747470733a2f2f7777772e706461692e746563682f5f696d616765732f636f6c6c656374696f6e2f4c696e6b65644c6973745f6164642e706e67" alt="img"></a></p><p><code>add(int index, E element)</code>, 当index==size时，等同于add(E e); 如果不是，则分两步：1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    if (index &#x3D;&#x3D; size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    else</span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>node(int index)</code>函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3><p>addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a &#x3D; c.toArray();</span><br><span class="line">    int numNew &#x3D; a.length;</span><br><span class="line">    if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    if (index &#x3D;&#x3D; size) &#123;</span><br><span class="line">        succ &#x3D; null;</span><br><span class="line">        pred &#x3D; last;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        succ &#x3D; node(index);</span><br><span class="line">        pred &#x3D; succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Object o : a) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">        if (pred &#x3D;&#x3D; null)</span><br><span class="line">            first &#x3D; newNode;</span><br><span class="line">        else</span><br><span class="line">            pred.next &#x3D; newNode;</span><br><span class="line">        pred &#x3D; newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (succ &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; pred;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pred.next &#x3D; succ;</span><br><span class="line">        succ.prev &#x3D; pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size +&#x3D; numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2020/07/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="https://images2018.cnblogs.com/blog/1032108/201807/1032108-20180724193606939-1891336874.jpg" alt></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class bubbleSort &#123;</span><br><span class="line">    public static int[] BubbleSort(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    swap(arr, j, j + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;21, 34, 56, 11, 2&#125;;</span><br><span class="line">        BubbleSort(arr);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void quickSort(int arr[], int left, int right) &#123;</span><br><span class="line">        if (left &gt;&#x3D; right) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int index &#x3D; partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, index - 1);</span><br><span class="line">        quickSort(arr, index + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int partition(int[] arr, int left, int right) &#123;</span><br><span class="line">        int key &#x3D; arr[left];</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            while (right &gt; left &amp;&amp; arr[right] &gt;&#x3D; key) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[left] &#x3D; arr[right];</span><br><span class="line">            while (right &gt; left &amp;&amp; arr[left] &lt; key) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[right] &#x3D; arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] &#x3D; key;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 测试案例</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;49, 38, 65, 97, 76, 13, 27, 49&#125;;</span><br><span class="line"></span><br><span class="line">        quickSort(arr, 0, arr.length - 1);</span><br><span class="line"></span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">            System.out.print(i + &quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度推导</p><p>我们用T(n)来表示时间复杂度，有：</p><p><img src="https://private.codecogs.com/gif.latex?T%28n%29%3D%20%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%202T%28n/2%29&plus;n%2Cn%3E1%3B%5C%5C%200%2Cn%3D1%3B%20%5Cend%7Bmatrix%7D%5Cright." alt="T(n)= \left\{\begin{matrix} 2T(n/2)+n,n&gt;1;\\ 0,n=1; \end{matrix}\right."></p><p>解这个递推公式：</p><p><img src="https://private.codecogs.com/gif.latex?T%28n%29%3D%202T%28%5Cfrac%7Bn%7D%7B2%7D%29&plus;n%3B" alt="T(n)= 2T(\frac{n}{2})+n;"></p><p>有<img src="https://private.codecogs.com/gif.latex?T%28%5Cfrac%7Bn%7D%7B2%7D%29%3D%202T%28%5Cfrac%7Bn%7D%7B4%7D%29&plus;%5Cfrac%7Bn%7D%7B2%7D%3B" alt="T(\frac{n}{2})= 2T(\frac{n}{4})+\frac{n}{2};">)代入上一个公式有<img src="https://private.codecogs.com/gif.latex?T%28n%29%3D%204T%28%5Cfrac%7Bn%7D%7B4%7D%29&plus;2n%3B" alt="T(n)= 4T(\frac{n}{4})+2n;"></p><p>有<img src="https://private.codecogs.com/gif.latex?T%28%5Cfrac%7Bn%7D%7B4%7D%29%3D%202T%28%5Cfrac%7Bn%7D%7B8%7D%29&plus;%5Cfrac%7Bn%7D%7B4%7D%3B" alt="T(\frac{n}{4})= 2T(\frac{n}{8})+\frac{n}{4};">)代入上一个公式有<img src="https://private.codecogs.com/gif.latex?T%28n%29%3D%208T%28%5Cfrac%7Bn%7D%7B8%7D%29&plus;3n%3B" alt="T(n)= 8T(\frac{n}{8})+3n;"></p><p>…</p><p>最后一层递归有<img src="https://private.codecogs.com/gif.latex?T%28%5Cfrac%7Bn%7D%7B2%5E%7Bk%7D%7D%29%3D%202T%28%5Cfrac%7Bn%7D%7B2%5E%7Bk&plus;1%7D%7D%29&plus;%5Cfrac%7Bn%7D%7B2%5E%7Bk%7D%7D%3B" alt="T(\frac{n}{2^{k}})= 2T(\frac{n}{2^{k+1}})+\frac{n}{2^{k}};">)代入上一个公式有<img src="https://private.codecogs.com/gif.latex?T%28n%29%3D%202%5E%7Bk%7DT%28%5Cfrac%7Bn%7D%7B2%5E%7Bk%7D%7D%29&plus;kn%3B" alt="T(n)= 2^{k}T(\frac{n}{2^{k}})+kn;"></p><p>已知最后一层递归时操作次数为1，<img src="https://private.codecogs.com/gif.latex?%5Cfrac%7Bn%7D%7B2%5E%7Bk%7D%7D%3D1" alt="\frac{n}{2^{k}}=1">)，有<img src="https://private.codecogs.com/gif.latex?k%3Dlog_%7B2%7Dn" alt="k=log_{2}n"></p><p>带入公式<img src="https://private.codecogs.com/gif.latex?T%28n%29%3D%202%5E%7Bk%7DT%28%5Cfrac%7Bn%7D%7B2%5E%7Bk%7D%7D%29&plus;kn" alt="T(n)= 2^{k}T(\frac{n}{2^{k}})+kn">)得<img src="https://private.codecogs.com/gif.latex?T%28n%29%3D%20nT%281%29&plus;%7Blog_%7B2%7D%7Dn*n%3B" alt="T(n)= nT(1)+{log_{2}}n*n;"></p><p>有T(1)=0;</p><p>所以<img src="https://private.codecogs.com/gif.latex?T%28n%29%3D%20n%7Blog_%7B2%7D%7Dn" alt="T(n)= n{log_{2}}n"> 即：O(nlgn);</p><p>看着好复杂，我的简单理解是，每一轮复杂度都是n，每一轮劈两半，能劈2^x=n x=logn轮，总复杂度就是nlogn</p><p>最好情况，每层左右子树都可以平均分摊，层高是n对2取log，否则倒叙输入，每层左子树只能分担一个，退化为层高n的树</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class InsertSort &#123;</span><br><span class="line">    public static int[] insertSort(int[] arr) &#123;</span><br><span class="line">        int temp, j;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            temp &#x3D; arr[i];</span><br><span class="line">            for (j &#x3D; i - 1; j &gt;&#x3D; 0 &amp;&amp; temp &lt; arr[j]; j--) &#123;</span><br><span class="line">                arr[j + 1] &#x3D; arr[j];</span><br><span class="line">            &#125;&#x2F;&#x2F; 1 2 2 5 2</span><br><span class="line">            arr[j + 1] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F;  Set&lt;Integer&gt; set&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">        int[] arr &#x3D; &#123;3, 1, 2, 5&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static int[] sort(int[] a,int low,int high)&#123;</span><br><span class="line">        int mid &#x3D; (low+high)&#x2F;2;</span><br><span class="line">        if(low&lt;high)&#123;</span><br><span class="line">            sort(a,low,mid);</span><br><span class="line">            sort(a,mid+1,high);</span><br><span class="line">            &#x2F;&#x2F;左右归并</span><br><span class="line">            merge(a,low,mid,high);</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void merge(int[] a, int low, int mid, int high) &#123;</span><br><span class="line">        int[] temp &#x3D; new int[high-low+1];</span><br><span class="line">        int i&#x3D; low;</span><br><span class="line">        int j &#x3D; mid+1;</span><br><span class="line">        int k&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F; 把较小的数先移到新数组中</span><br><span class="line">        while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;high)&#123;</span><br><span class="line">            if(a[i]&lt;a[j])&#123;</span><br><span class="line">                temp[k++] &#x3D; a[i++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp[k++] &#x3D; a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把左边剩余的数移入数组</span><br><span class="line">        while(i&lt;&#x3D;mid)&#123;</span><br><span class="line">            temp[k++] &#x3D; a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把右边边剩余的数移入数组</span><br><span class="line">        while(j&lt;&#x3D;high)&#123;</span><br><span class="line">            temp[k++] &#x3D; a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把新数组中的数覆盖nums数组</span><br><span class="line">        for(int x&#x3D;0;x&lt;temp.length;x++)&#123;</span><br><span class="line">            a[x+low] &#x3D; temp[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr&#x3D;&#123;2,1,5,4&#125;;</span><br><span class="line">        sort(arr,0,arr.length-1);</span><br><span class="line">        for(int a:arr)</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line">    public static void heapSort(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; arr.length &#x2F; 2 - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">            downjust(arr, i, arr.length);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot; :&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; arr.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            swap(arr, i, 0);</span><br><span class="line">            downjust(arr, 0, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void downjust(int[] arr, int low, int high) &#123;</span><br><span class="line">        int i &#x3D; low, j &#x3D; i * 2 + 1, temp &#x3D; arr[i];</span><br><span class="line">        while (j &lt; high) &#123;</span><br><span class="line">            if (j + 1 &lt; high &amp;&amp; arr[j] &lt; arr[j + 1])</span><br><span class="line">                j++;</span><br><span class="line">            if (arr[j] &gt; temp) &#123;</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">                i &#x3D; j;</span><br><span class="line">                j &#x3D; i * 2 + 1;</span><br><span class="line">            &#125; else break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums &#x3D; &#123;110, 16, 7, 3, 20, 17, 8&#125;;</span><br><span class="line">        heapSort(nums);</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            System.out.print(num + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class SelectSort &#123;</span><br><span class="line">    &#x2F;&#x2F;选择排序：每次从待排序的元素中选出最小值</span><br><span class="line">    &#x2F;&#x2F;选择排序：每次从待排序的元素中选出最小值  </span><br><span class="line">    public static void selectionSort(int[] arr)&#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; arr.length - 1; i++)&#123;</span><br><span class="line">            int min &#x3D; i;</span><br><span class="line">            for(int j &#x3D; i + 1; j &lt; arr.length; j++)&#123;</span><br><span class="line">                &#x2F;&#x2F;将a[i]和a[i+1...N-1]中的最小元素交换</span><br><span class="line">                if(arr[j] &lt; arr[min])&#123;&#x2F;&#x2F;升序排列</span><br><span class="line">                    min &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(min !&#x3D; i)&#123;</span><br><span class="line">                int temp &#x3D; arr[i];</span><br><span class="line">                arr[i] &#x3D; arr[min];</span><br><span class="line">                arr[min] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array &#x3D; &#123;3,2,4,1,5,0&#125;;</span><br><span class="line">        selectionSort(array);</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class shellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;1,8,3,4,2,0,5,6,3,2,8,9&#125;;</span><br><span class="line">        shell(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 希尔排序</span><br><span class="line">     * @param arr 要排序的数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void shell(int[] arr)&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;希尔排序实际上是直接插入排序的升级版本，在直接插入排序的算法中，如果越到后面突然出现某个比较小的值</span><br><span class="line">        &#x2F;&#x2F;这个时候排序的步骤就越长，希尔排序就是为了解决这个问题，先大致的排一下，然后拍的过程中用的是直接插入排序算法</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;首先计算步长</span><br><span class="line">        for(int d &#x3D; arr.length&#x2F;2;d&gt;0;d &#x3D; d&#x2F;2)&#123;</span><br><span class="line">            &#x2F;&#x2F;开始直接排序算法</span><br><span class="line">            &#x2F;&#x2F;先来一轮直接排序</span><br><span class="line">            for(int i &#x3D; d;i &lt; arr.length;i++)&#123;</span><br><span class="line">                &#x2F;&#x2F;然后开始交换</span><br><span class="line">                for(int j &#x3D; i - d;j &gt;&#x3D;0; j &#x3D; j-d)&#123;</span><br><span class="line">                    if(arr[j] &gt; arr[j+d])&#123;</span><br><span class="line">                        int temp &#x3D; arr[j];</span><br><span class="line">                        arr[j] &#x3D; arr[j+d];</span><br><span class="line">                        arr[j+d] &#x3D; temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images2018.cnblogs.com/blog/1032108/201807/1032108-20180724193606939-1891336874.jpg" alt></p><h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h2><p> 笔试时，遇到一个算法题：差不多是 在n个不同的数中随机取出不重复的m个数。洗牌算法是将原来的数组进行打散，使原数组的某个数在打散后的数组中的每个位置上等概率的出现，刚好可以解决该问题。</p><p>该算法是经典洗牌算法。它的proof如下：</p><p>对于arr[i],洗牌后在第n-1个位置的概率是1/n（第一次交换的随机数为i）<br>在n-2个位置概率是[(n-1)/n] * [1/(n-1)] = 1/n，（第一次交换的随机数不为i，第二次为arr[i]所在的位置（注意，若i=n-1，第一交换arr[n-1]会被换到一个随机的位置））<br>在第n-k个位置的概率是[(n-1)/n] * [(n-2)/(n-1)] <em>…</em> [(n-k+1)/(n-k+2)] *[1/(n-k+1)] = 1/n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">该算法的基本思想和 Fisher 类似，每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。</span><br><span class="line">算法步骤为：</span><br><span class="line">    1. 建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；</span><br><span class="line">    2. 生成一个从 0 到 n - 1 的随机数 x；</span><br><span class="line">    3. 输出 arr 下标为 x 的数值，即为第一个随机数；</span><br><span class="line">    4. 将 arr 的尾元素和下标为 x 的元素互换；</span><br><span class="line">    5. 同2，生成一个从 0 到 n - 2 的随机数 x；</span><br><span class="line">    6. 输出 arr 下标为 x 的数值，为第二个随机数；</span><br><span class="line">    7. 将 arr 的倒数第二个元素和下标为 x 的元素互换；</span><br><span class="line">……</span><br><span class="line">如上，直到输出 m 个数为止</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class hello &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] arr &#x3D; &#123;5,1,2,6,7,8,93,67,8,3,86,4,6,8,45,86&#125;;</span><br><span class="line">        flushArr(arr);</span><br><span class="line">        for(int num : arr)&#123;</span><br><span class="line">            System.out.print(num + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void flushArr(int[] arr)&#123;</span><br><span class="line">        for (i &#x3D; arr.length - 1; i &gt; 0; i--)</span><br><span class="line">        &#123;  </span><br><span class="line">            &#x2F;&#x2F;随机数生成器，范围[0, i]  </span><br><span class="line">            int rand &#x3D; (new Random()).nextInt(i+1);  </span><br><span class="line"></span><br><span class="line">            int temp &#x3D; arr[i];  </span><br><span class="line">            arr[i] &#x3D; arr[rand];  </span><br><span class="line">            arr[rand] &#x3D; temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int createRandom(int end)&#123;</span><br><span class="line">        return (new Random().nextInt(end));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最短路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[1,1,0,1],</span><br><span class="line"> [1,0,1,0],</span><br><span class="line"> [1,1,1,1],</span><br><span class="line"> [1,0,1,1]]</span><br><span class="line"> 1 表示可以经过某个位置，求解从 (0, 0) 位置到 (tr, tc) 位置的最短路径长度。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">static int min&#x3D;Integer.MAX_VALUE;</span><br><span class="line">   static class Pair&#123;</span><br><span class="line">       int key;</span><br><span class="line">       int value;</span><br><span class="line">       public Pair(int key,int value) &#123;</span><br><span class="line">           this.key&#x3D;key;</span><br><span class="line">           this.value&#x3D;value;</span><br><span class="line">       &#125;</span><br><span class="line">       public int getKey() &#123;</span><br><span class="line">           return (int) this.key;</span><br><span class="line">       &#125;</span><br><span class="line">       public int getValue() &#123;</span><br><span class="line">           return (int) this.value;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       int [][]grids&#x3D; &#123;&#123;1,2&#125;,</span><br><span class="line">                       &#123;1,1&#125;&#125;;</span><br><span class="line">       minPathLength(grids, 1, 1);</span><br><span class="line">       System.out.println(min);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   public static void minPathLength(int[][] grids, int tr, int tc) &#123;</span><br><span class="line">       final int[][] direction &#x3D; &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">       int[][] s&#x3D;new int[2][2];</span><br><span class="line">       for(int i&#x3D;0;i&lt;2;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           for(int j&#x3D;0;j&lt;2;j++)</span><br><span class="line">           &#123;</span><br><span class="line">               s[i][j]&#x3D;300;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       s[0][0]&#x3D;1;</span><br><span class="line"></span><br><span class="line">       final int m &#x3D; grids.length, n &#x3D; grids[0].length;</span><br><span class="line">       Queue&lt;Pair&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">       queue.add(new Pair(0, 0));</span><br><span class="line">       int pathLength &#x3D; 0;</span><br><span class="line">       while (!queue.isEmpty()) &#123;</span><br><span class="line">           int size &#x3D; queue.size();</span><br><span class="line">           while (size-- &gt; 0) &#123;</span><br><span class="line">               Pair cur &#x3D; queue.poll();</span><br><span class="line">               int cr &#x3D; cur.getKey(), cc &#x3D; cur.getValue();</span><br><span class="line">               grids[cr][cc] &#x3D; 0; &#x2F;&#x2F; 标记</span><br><span class="line">               for (int[] d : direction) &#123;</span><br><span class="line">                   int nr &#x3D; cr + d[0], nc &#x3D; cc + d[1];</span><br><span class="line">                   if (nr &lt; 0 || nr &gt;&#x3D; m || nc &lt; 0 || nc &gt;&#x3D; n || s[nr][nc]&lt;&#x3D;s[cr][cc]+grids[nr][nc]) &#123;</span><br><span class="line">                       continue;</span><br><span class="line">                   &#125;</span><br><span class="line">                   s[nr][nc]&#x3D;s[cr][cc]+grids[nr][nc];</span><br><span class="line">                   queue.add(new Pair(nr, nc));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       min&#x3D;Math.min(min,s[1][1]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="不同的数字"><a href="#不同的数字" class="headerlink" title="不同的数字"></a>不同的数字</h2><p>一个有序数组，有重复的数，平方后，数组当中有多少不同的数字,例子，[-1，3，3]，返回结果 2.</p><p>例子，[-1，-1，1，1]，返回结果 1. nums = {-2,-1,0,1,2,3} 返回4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int findDiff(int[] nums) &#123;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    int left &#x3D; 0;</span><br><span class="line">    int right &#x3D; nums.length - 1;</span><br><span class="line">    int pre &#x3D; - 1;</span><br><span class="line">   </span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        if (Math.abs(nums[left]) &gt; Math.abs(nums[right])) &#123;</span><br><span class="line">            if (pre !&#x3D; Math.abs(nums[left]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                pre &#x3D; Math.abs(nums[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (pre !&#x3D; abs(nums[right]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                pre &#x3D; abs(nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-hard"><a href="#leetcode-hard" class="headerlink" title="leetcode hard"></a>leetcode hard</h2><p>股票问题</p><p>4 中位数</p><p>10 正则匹配</p><p>23 合并K个</p><p>41 缺失第一个正数</p><p>44 通配符匹配</p><p>124 二叉树最大路径和</p><p>146 LRU</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>敲击url后发生了什么</title>
      <link href="/2020/07/10/%E6%95%B2%E5%87%BBurl%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/10/%E6%95%B2%E5%87%BBurl%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="https://camo.githubusercontent.com/c6bda910351aff0fc39247088fde335ab5bbf3c8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f2545352539302538342545372541372538442545372542442539312545372542422539432545382541462542372545362542312538322545372539342541382545352538382542302545372539412538342545352538442538462545382541452541452e6a7067" alt="各种网络请求用到的协议"></p><h3 id="DHCP-配置主机信息"><a href="#DHCP-配置主机信息" class="headerlink" title="DHCP 配置主机信息"></a>DHCP 配置主机信息</h3><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。<br>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。<br>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。<br>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。<br>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报<br>文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP<br>地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。<br>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了<br>MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。<br>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并<br>在其 IP 转发表中安装默认网关。</p><h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><p>浏览器会把输入的域名解析成对应的IP，其过程如下：</p><p>1.查找浏览器缓存：因为浏览器一般会缓存DNS记录一段时间，不同浏览器的时间可能不一样，一般2-30分钟不等，浏览器去查找这些缓存，如果有缓存，直接返回IP，否则下一步。</p><p>2.查找系统缓存：浏览器缓存中找不到IP之后，浏览器会进行系统调用（windows中是gethostbyname），查找本机的hosts文件，如果找到，直接返回IP，否则下一步。</p><p>3.查找路由器缓存：如果1,2步都查询无果，则需要借助网络，路由器一般都有自己的DNS缓存，将前面的请求发给路由器，查找ISP 服务商缓存 DNS的服务器，如果查找到IP则直接返回，没有的话继续查找。</p><p>4.递归查询：如果以上步骤还找不到，则ISP的DNS服务器就会进行递归查询，所谓递归查询就是如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步查询。（本地域名服务器地址是通过DHPC协议获取地址，DHPC是负责分配IP地址的）</p><p>5.迭代查询：本地域名服务器采用迭代查询，它先向一个根域名服务器查询。本地域名服务器向根域名服务器的查询一般都是采用迭代查询。所谓迭代查询就是当根域名服务器收到本地域名服务器发出的查询请求报文后，要么告诉本地域名服务器下一步应该查询哪一个域名服务器，然后本地域名服务器自己进行后续的查询。（而不是替代本地域名服务器进行后续查询）。</p><p>本例子中：根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.net的IP地址。本地域名服务器向顶级域名服务器dns.net进行查询。顶级域名服务器dns.net告诉本地域名服务器，下一次应查询的权限域名服务器dns.csdn.net的IP地址。本地域名服务器向权限域名服务器dns.csdn.net进行查询。权限域名服务器dns.csdn.net告诉本地域名服务器，所查询的主机<a href="http://www.csdn.net的IP地址。本地域名服务器最后把结果告诉主机。" target="_blank" rel="noopener">www.csdn.net的IP地址。本地域名服务器最后把结果告诉主机。</a></p><ol><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h3 id="浏览器与目标服务器建立TCP连接"><a href="#浏览器与目标服务器建立TCP连接" class="headerlink" title="浏览器与目标服务器建立TCP连接"></a>浏览器与目标服务器建立TCP连接</h3><ol><li><p>主机浏览器通过DNS解析得到了目标服务器的IP地址后，与服务器建立TCP连接。</p></li><li><p>TCP3次握手连接：浏览器所在的客户机向服务器发出连接请求报文（SYN标志为1）；服务器接收报文后，同意建立连接，向客户机发出确认报文（SYN，ACK标志位均为1）；客户机接收到确认报文后，再次向服务器发出报文，确认已接收到确认报文；此处客户机与服务器之间的TCP连接建立完成，开始通信。</p><p><img src="/2020/07/10/%E6%95%B2%E5%87%BBurl%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201116150659656.png" alt="image-20201116150659656"></p></li></ol><h3 id="服务器处理请求，发回响应"><a href="#服务器处理请求，发回响应" class="headerlink" title="服务器处理请求，发回响应"></a>服务器处理请求，发回响应</h3><h3 id="浏览器渲染解析"><a href="#浏览器渲染解析" class="headerlink" title="浏览器渲染解析"></a>浏览器渲染解析</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP和UDP相关问题</title>
      <link href="/2020/07/10/TCP%E5%92%8CUDP%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/10/TCP%E5%92%8CUDP%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>TCP提供可靠的、面向连接的运输服务。在传输数据之前必须三次握手建立连接，数据传输结束之后，4次挥手释放连接，而且在数据传递时，又有确认应答、超时重传、流量控制、拥塞控制等机制保证传送数据的可靠性。TCP经常用于对网络通信质量有很高要求的地方，如文件传输，邮件发送，远程登录等场景。SMTP、TELNET、HTTP、FTP</p><p>   UDP在传送数据之前不需要建立连接，目的主机收到UDP报文后，不需要给出确认。UDP不提供可靠交付，一般用于即时通信，如语音、视频、直播等。RIP(路由选择协议)，DNS</p><h2 id="什么是TCP的三次握手？"><a href="#什么是TCP的三次握手？" class="headerlink" title="什么是TCP的三次握手？"></a>什么是TCP的三次握手？</h2><p><img src="https://img-blog.csdnimg.cn/20200710095751436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="img"></p><p>假设 A 为客户端，B 为服务器端。</p><p>最初客户端和服务端都处于 CLOSED(关闭) 状态。ACK为确认值，ack为确认编号</p><p>一开始，服务器首先创建传输控制块TCB，然后处于 LISTEN(监听) 状态，等待客户端的连接请求。</p><p>· 第一次握手：A 的 TCP 客户端进程创建传输控制块 TCB、向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。</p><p>· 第二次握手：B 收到连接请求报文后，向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，己选择一个初始序号 seq = y，确认号 ack = x + 1。（请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。）这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。</p><p>· 第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。(这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。)这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</p><h2 id="为什么是三次握手？"><a href="#为什么是三次握手？" class="headerlink" title="为什么是三次握手？"></a>为什么是三次握手？</h2><p><strong>三次握手的原因主要有两个目的，信息对等和防止超时。</strong></p><p>从信息对等的角度看，双方只有确定 4 类信息才能建立连接，即 A 和 B 分别确认自己和对方的发送和接收能力正常。在第二次握手后，从 B 的角度看还不能确定自己的发送能力和对方的接收能力，只有在第三次握手后才能确认。</p><p>防止超时。三次握手也是防止失效连接突然到达导致脏连接，网络报文的生存时间往往会超过 TCP 请求超时时间，A 的某个超时连接请求可能会在双方释放连接之后到达 B，B 会误以为是 A 创建了新的连接请求，然后发送确认报文创建连接。如果是两次握手，连接已经建立了，服务器资源被白白浪费。如果是三次握手，B 由于长时间没有收到确认信息，最终超时导致创建连接失败，因此不会出现脏连接。</p><h2 id="四次挥手？"><a href="#四次挥手？" class="headerlink" title="四次挥手？"></a>四次挥手？</h2><p><img src="https://img-blog.csdnimg.cn/20200710100009759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="img"></p><p>由于TCP连接是全双工的，因此每个方向都必须单独关闭。当一方数据发送任务完成之后，可以发送FIN来终止这个方向的连接。而另一方可以继续发送数据。</p><p>· 客户端发送请求释放连接报文，FIN=1,seq=u;客户端进入FIN-WAIT-1状态；</p><p>· 服务器收到请求，发送确认报文。ACK=1,seq=v,ack=u+1;服务器进入CLOSE-WAIT状态。客户端收到后进入终止等待2FIN-WAIT-2;</p><p>· 服务器发送完数据之后，向客户端发送请求释放连接报文，FIN=1,ACK=1,seq=w,ack=u+1;进入LAST-ACK状态</p><p>·客户端收到请求后，发送确认报文，ACK=1,seq=u+1,ack=w+1。客户端进入TIME-WAIT状态，等待2MSL后进如CLOSED状态，服务器收到确认后进如CLOSED状态。</p><h2 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h2><p>第一点原因是为了保证被动关闭方可以进入 CLOSED 状态。MSL 是最大报文段寿命，等待 2MSL 可以保证 A 发送的最后一个确认报文能被 B 接收，如果该报文丢失，B 没有收到就会超时重传之前的 FIN+ACK 报文，而如果 A 在发送确认报文后就立即释放连接就无法收到 B 超时重传的报文，因而也不会再一次发送确认报文段，B 就无法正常进入 CLOSED 状态。</p><p>第二点原因是 2MSL 时间之后，本连接中的所有报文就都会从网络中消失，可以防止已失效连接的请求数据包与正常连接的请求数据包混淆而发生异常。</p><p>除此之外，TCP 还设有一个保活计时器，用于解决客户端主机故障的问题，服务器每收到一次客户的数据就重新设置保活计时器，时间为 2 小时。如果 2 小时内没有收到就间隔 75 秒发送一次探测报文，连续 10 次都没有响应后就关闭连接。</p><h2 id="TCP是怎么保证可靠的？"><a href="#TCP是怎么保证可靠的？" class="headerlink" title="TCP是怎么保证可靠的？"></a>TCP是怎么保证可靠的？</h2><p>TCP 的可靠传输包含很多机制，例如使用<strong>检验和</strong>来检测一个传输分组中的比特错误、使用<strong>定时器</strong>来用于超时重传一个分组、使用<strong>序号</strong>来检测丢失的分组和冗余副本、使用<strong>确认</strong>来告诉发送方确认的分组信息、使用<strong>否定确认</strong>来告诉发送方某个分组未被正确接收。除此之外，TCP 还使用<strong>流量控制</strong>和<strong>拥塞控制</strong>来保证可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ICMP及其应用</title>
      <link href="/2020/07/09/ICMP%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2020/07/09/ICMP%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ICMP 报文是封装在 IP 包里面的。ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><h2 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h2><p>TTL 允许转发的最大次数</p><p>字节 数据包的大小</p><p>时间 耗时</p><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。<br>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时<br>间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p>ping 命令执行的时候，源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。最重要的是两个，第一个是类型字段，对于请求数据包而言该字段为 8；另外一个是顺序号，主要用于区分连续 ping 的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加 1。</p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。应答数据包的类型字段为 0，构建新的ICMP数据包，发回给主机A，此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><h2 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h2><p>（<em>ip</em>可以传输的最大的数据报）</p><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。<br>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第<br>一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP<br>时间超过差错报告报文；<br>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2<br>收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。<br>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是<br>因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。<br>之后源主机知道了到达<strong>目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</strong></li><li>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。要做的工作首先是发送分组，并设置“不分片”标志。发送的第一个分组的长度正好与出口 MTU 相等。如果中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包，</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis高可用</title>
      <link href="/2020/07/05/redis%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>/2020/07/05/redis%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>Redis多副本（主从）</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6EJvicazJ6KzImNoKH1nofWM9rqIR6VUWeDxJHhJHIQgDFF9Hb5kRnGkNicM7KGfpad5VnUo0pOQjm2Fw7TGUs0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>Redis 多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。</p><p>优点：</p><p>1、高可靠性，一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行。另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题。</p><p>2、读写分离策略，从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</p><p>缺点：</p><p>1、故障恢复复杂，如果没有RedisHA系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其他从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐。</p><p>2、主库的写能力受到单机的限制，可以考虑分片</p><p>3、主库的存储能力受到单机的限制，可以考虑Pika</p><p>4、原生复制的弊端在早期的版本也会比较突出，如：Redis复制中断后，Slave会发起psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于COW机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘IO和CPU（压缩）资源消耗；发送数GB大小的备份文件导致服务器出口带宽暴增，阻塞请求。建议升级到最新版本。</p><p><strong>Redis Sentinel（哨兵）</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6EJvicazJ6KzImNoKH1nofWM9rqIR6VUW1ibIW7Go066hNFQF5jUpkv5NN8RIA4McUSyRPVb82OTnpnWnmKyrDbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>Redis Sentinel是社区版本推出的原生高可用解决方案，Redis Sentinel部署架构主要包括两部分：Redis Sentinel集群和Redis数据集群，其中Redis Sentinel集群是由若干Sentinel节点组成的分布式集群。可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel的节点数量要满足2n+1（n&gt;=1）的奇数个。</p><p>优点：</p><p>1、Redis Sentinel集群部署简单</p><p>2、能够解决Redis主从模式下的高可用切换问题</p><p>3、很方便实现Redis数据节点的线形扩展，轻松突破Redis自身单线程瓶颈，可极大满足对Redis大容量或高性能的业务需求。</p><p>4、可以实现一套Sentinel监控一组Redis数据节点或多组数据节点</p><p>缺点：</p><p>1、部署相对Redis 主从模式要复杂一些，原理理解更繁琐</p><p>2、资源浪费，Redis数据节点中slave节点作为备份节点不提供服务</p><p>3、Redis Sentinel主要是针对Redis数据节点中的主节点的高可用切换，对Redis的数据节点做失败判定分为主观下线和客观下线两种，对于Redis的从节点有对节点做主观下线操作，并不执行故障转移。</p><p>4、不能解决读写分离问题，实现起来相对复杂</p><p>建议：</p><p>1、如果监控同一业务，可以选择一套Sentinel集群监控多组Redis数据节点的方案，反之选择一套Sentinel监控一组Redis数据节点的方案</p><p>2、sentinel monitor <master-name> <ip> <port> <quorum> 配置中的<quorum>建议设置成Sentinel节点的一半加1，当Sentinel部署在多个IDC的时候，单个IDC部署的Sentinel数量不建议超过（Sentinel数量 – quorum）。</quorum></quorum></port></ip></master-name></p><p>3、合理设置参数，防止误切，控制切换灵敏度控制</p><ol><li>quorum</li><li>down-after-milliseconds 30000</li><li>failover-timeout 180000</li><li>maxclient</li><li>timeout</li></ol><p>4、部署的各个节点服务器时间尽量要同步，否则日志的时序性会混乱</p><p>5、Redis建议使用pipeline和multi-keys操作，减少RTT次数，提高请求效率</p><p>6、自行搞定配置中心（zookeeper），方便客户端对实例的链接访问</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/6EJvicazJ6KzImNoKH1nofWM9rqIR6VUWNSEC8dvIoHtWlm4OyK3KxaXc4sSzibK0nFC4hNKhhsPXibrQibFwLOglA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>Redis Cluster是社区版推出的Redis分布式集群解决方案，主要解决Redis分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster能起到很好的负载均衡的目的。Redis Cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p><p>优点：</p><p>1、无中心架构</p><p>2、数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p><p>3、可扩展性，可线性扩展到1000多个节点，节点可动态添加或删除。</p><p>4、高可用性，部分节点不可用时，集群仍可用。通过增加Slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升。</p><p>5、降低运维成本，提高系统的扩展性和可用性。</p><p>缺点：</p><p>1、Client实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅JedisCluster相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</p><p>2、节点会因为某些原因发生阻塞（阻塞时间大于clutser-node-timeout），被判断下线，这种failover是没有必要的。</p><p>3、数据通过异步复制,不保证数据的强一致性。</p><p>4、多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</p><p>5、Slave在集群中充当“冷备”，不能缓解读压力，当然可以通过SDK的合理设计来提高Slave资源的利用率。</p><p>6、key批量操作限制，如使用mset、mget目前只支持具有相同slot值的key执行批量操作。对于映射为不同slot值的key由于keys 不支持跨slot查询，所以执行mset、mget、sunion等操作支持不友好。</p><p>7、key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个key分布于不同的节点上时无法使用事务功能。</p><p>8、key作为数据分区的最小粒度，因此不能将一个很大的键值对象如hash、list等映射到不同的节点。</p><p>9、不支持多数据库空间，单机下的redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0。</p><p>10、复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p><p>11、避免产生hot-key，导致主库节点成为系统的短板。</p><p>12、避免产生big-key，导致网卡撑爆、慢查询等。</p><p>13、重试时间应该大于cluster-node-time时间</p><p>14、Redis Cluster不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis写入和删除的原理</title>
      <link href="/2020/07/05/redis%E5%86%99%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2020/07/05/redis%E5%86%99%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/ea15a1e0d43d" target="_blank" rel="noopener">https://www.jianshu.com/p/ea15a1e0d43d</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis相关问题剖析</title>
      <link href="/2020/07/05/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/05/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Redis-学习笔记"><a href="#Redis-学习笔记" class="headerlink" title="Redis 学习笔记"></a>Redis 学习笔记</h1><h2 id="初识-Redis"><a href="#初识-Redis" class="headerlink" title="初识 Redis"></a>初识 Redis</h2><p>Redis 是一种基于键值对的 NoSQL 数据库，Redis 中的值可以是由 string、hash、list、set、zset 等多种数据结构和算法组成，因此 Redis 可以满足很多应用场景。Redis 将所有数据都存放在内存中，所以它的读写能力也非常高。Redis 还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会丢失。除了这些功能，Redis 还提供了键过期、发布订阅、事务、流水线、Lua 等附加功能。</p><h3 id="Redis-的特性"><a href="#Redis-的特性" class="headerlink" title="Redis 的特性"></a>Redis 的特性</h3><p><strong>速度快</strong></p><p>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><p>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用多路I/O复用模型，非阻塞IO；</p><p><strong>基于键值对的数据结构服务器</strong></p><p>与很多键值对数据库不同的是，Redis 中的值不仅可以是字符串，还可以是具体的数据结构，这样不仅能应用于多种场景开发，也可以提高开发效率。Redis 的全称是 REmote Dictionary Server，它主要提供五种数据结构：字符串、哈希、列表、集合、有序集合，同时在字符串的基础上演变出了位图和 HyperLogLog 两种数据结构，随着 LBS 基于位置服务的发展，Redis 3.2 加入了有关 GEO 地理信息定位的功能。</p><p><strong>丰富的功能</strong></p><p>① 提供了键过期功能，可以实现缓存。② 提供了发布订阅功能，可以实现消息系统。③ 支持 Lua 脚本，可以创造新的 Redis 命令。④ 提供了简单的事务功能，能在一定程度商保证事务特性。⑤ 提供了流水线功能，这样客户端能将一批命令一次性传到 Redis，减少了网络开销。⑤IO多路复用</p><p><strong>持久化</strong></p><p>通常来说数据放在内存中是不安全的，一旦发生断电或故障数据就可能丢失，因此 Redis 提供了两种持久化方式 RDB 和 AOF 将内存的数据保存到硬盘中。</p><p><strong>对单线程的理解？</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/10378860-f024bea7843b5e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507/format/webp" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/10378860-50aff3db93e8df4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/657/format/webp" alt="img"></p><p>redis的IO复用是基于单线程的，但它的一些模块，比如删除过期缓存是多线程的</p><h3 id="Redis-的使用场景"><a href="#Redis-的使用场景" class="headerlink" title="Redis 的使用场景"></a>Redis 的使用场景</h3><p><strong>缓存</strong></p><p>缓存机制几乎在所有大型网站都有使用，合理使用缓存不仅可以加快数据的访问速度，而且能够有效降低后端数据源的压力。Redis 提供了键值过期时间设置，并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。</p><p><strong>排行榜系统</strong></p><p>排行榜系统几乎存在于所有网站，Redis 提供了列表和有序集合数据结构，合理使用这些数据结构可以方便构建各各种排行榜系统。</p><p><strong>计数器应用</strong></p><p>计数器在网站中的作用很重要，例如视频网站有播放数、电商网站有浏览数，为了保证数据实时性，每一次播放和浏览都要做加 1 的操作，如果并发量很大对于传统关系型数据库的性能是很大的挑战。Redis 天然支持计数功能而且性能也非常好。</p><p><strong>社交网络</strong></p><p>粉丝、共同好友/喜好、推送、下拉刷新等是社交网络的必备功能，由于社交网站的访问量通常很大，而且关系型数据不太适合保存这种类型的数据，Redis 提供的数据结构可以相对容易地实现这些功能。</p><p><strong>消息队列系统</strong></p><p>消息队列系统是一个大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis 提供了发布订阅和阻塞队列的功能，对于一般的消息队列功能基本可以满足。</p><p><strong>Redis 不适合非常大的数据量，成本非常高，也不适合冷数据，会浪费内存。</strong></p><hr><h2 id="API-的理解和使用"><a href="#API-的理解和使用" class="headerlink" title="API 的理解和使用"></a>API 的理解和使用</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串类型是 Redis 最基础的数据结构，键都是字符串类型，而且其他几种数据结构都是在字符串类型的基础上构建的。字符串类型的值可以实际可以是字符串（简单的字符串、复杂的字符串如 JSON、XML）、数字（整形、浮点数）、甚至二进制（图片、音频、视频），但是值最大不能超过 512 MB。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><strong>设置值</strong></p><p><code>set key value [ex seconds] [px millseconds] [nx|xx]</code></p><ul><li>ex seconds：为键设置秒级过期时间，跟 setex 效果一样</li><li>px millseconds：为键设置毫秒级过期时间</li><li>nx：键必须不存在才可以设置成功，用于添加，跟 setnx 效果一样。由于 Redis 的单线程命令处理机制，如果多个客户端同时执行，则只有一个客户端能设置成功，可以用作分布式锁的一种实现。</li><li>xx：键必须存在才可以设置成功，用于更新</li></ul><p><strong>获取值</strong></p><p><code>get key</code>，如果不存在返回 nil</p><p><strong>批量设置值</strong></p><p><code>mset key value [key value...]</code></p><p><strong>批量获取值</strong></p><p><code>mget key [key...]</code></p><p>批量操作命令可以有效提高开发效率，假如没有 mget，执行 n 次 get 命令需要 n 次网络时间 + n 次命令时间，使用 mget 只需要 1 次网络时间 + n 次命令时间。</p><p>Redis 可以支持每秒数万的读写操作，但这指的是 Redis 服务端的处理能力，对于客户端来说一次命令处理命令时间还有网络时间。因为 Redis 的处理能力已足够高，对于开发者来说，网络可能会成为性能瓶颈。</p><p><strong>计数</strong></p><p><code>incr key</code></p><p>incr 命令用于对值做自增操作，返回结果分为三种：① 值不是整数返回错误。② 值是整数，返回自增后的结果。③ 值不存在，按照值为 0 自增，返回结果 1。除了 incr 命令，还有自减 decr、自增指定数字 incrby、自减指定数组 decrby、自增浮点数 incrbyfloat。</p><hr><h4 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h4><p><strong>追加值</strong></p><p>append key  value，可以向字符串尾部追加值</p><p><strong>字符串长度</strong></p><p><code>strlen key</code></p><p><strong>设置并返回原值</strong></p><p><code>getset key value</code></p><p><strong>设置指定位置的字符</strong></p><p><code>setrange key offset value</code></p><p><strong>获取部分字符串</strong></p><p><code>getrange key start end</code>，start 和 end分别是开始和结束的偏移量，偏移量从 0 开始计算。</p><hr><h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><p>字符串类型的内部编码有三种:</p><ul><li>int：8 个字节的长整形</li><li>embstr：小于等于 39 个字节的字符串</li><li>raw：大于 39 个字节的字符串</li></ul><hr><h4 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h4><p><strong>缓存功能</strong></p><p>Redis 作为缓存层，MySQL 作为存储层，首先从 Redis 获取数据，如果没有获取到就从 MySQL 获取，并将结果写回到 Redis，添加过期时间。</p><p><strong>计数</strong></p><p>Redis 可以实现快速计数功能，例如视频每播放一次就用 incy 把播放数加 1。</p><p><strong>共享 Session</strong></p><p>一个分布式 Web 服务将用户的 Session 信息保存在各自服务器，但会造成一个问题，出于负载均衡的考虑，分布式服务会将用户的访问负载到不同服务器上，用户刷新一次可能会发现需要重新登陆。为解决该问题，可以使用 Redis 将用户的 Session 进行集中管理，在这种模式下只要保证 Redis 是高可用和扩展性的，每次用户更新或查询登录信息都直接从 Redis 集中获取。</p><p><strong>限速</strong></p><p>例如为了短信接口不被频繁访问会限制用户每分钟获取验证码的次数或者网站限制一个 IP 地址不能在一秒内访问超过 n 次。可以使用键过期策略和自增计数实现。</p><hr><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>哈希类型是指键值本身又是一个键值对结构，哈希类型中的映射关系叫做 field-value，这里的 value 是指 field 对于的值而不是键对于的值。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><strong>设置值</strong></p><p><code>hset key field value</code>，如果设置成功会返回 1，反之会返回 0，此外还提供了 hsetnx 命令，作用和 setnx 类似，只是作用于由键变为 field。</p><p><strong>获取值</strong></p><p><code>hget key field</code>，如果不存在会返回 nil。</p><p><strong>删除 field</strong></p><p><code>hdel key field [field...]</code>，会删除一个或多个 field，返回结果为删除成功 field 的个数。</p><p><strong>计算 field 个数</strong></p><p><code>hlen key</code></p><p><strong>批量设置或获取 field-value</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field...]</span><br><span class="line">hmset key field value [field value...]</span><br></pre></td></tr></table></figure><p>hmset 需要的参数是 key 和多对 field-value，hmget 需要的参数是 key 和多个 field。</p><p><strong>判断 field 是否存在</strong></p><p><code>hexists key field</code>，存在返回 1，否则返回  0。</p><p><strong>获取所有的 field</strong></p><p><code>hkeys key</code>，返回指定哈希键的所有 field。</p><p><strong>获取所有 value</strong></p><p><code>hvals key</code>，获取指定键的所有 value。</p><p><strong>获取所有的 field-value</strong></p><p><code>hgetall key</code>，获取指定键的所有 field-value。</p><p><strong>计数</strong></p><p><code>hincrby key field</code> 和 <code>hincrbyfloat key field</code>，作用和 incrby 和 incrbyfloat 一样，作用域是 field。</p><p><strong>计算 value 的字符串长度</strong></p><p>hstrlen key field</p><hr><h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><p>哈希类型的内部编码有两种：</p><ul><li>ziplist 压缩列表：当哈希类型元素个数和值小于配置值（默认 512 个和 64 字节）时会使用 ziplist 作为内部实现，使用更紧凑的结构实现多个元素的连续存储，在节省内存方面比 hashtable 更优秀。</li><li>hashtable 哈希表：当哈希类型无法满足 ziplist 的条件时会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度都为 O(1)。</li></ul><hr><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>缓存用户信息，有三种实现：</p><ul><li><p>原生字符串类型：每个属性一个键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set user:1:name tom</span><br><span class="line">set user:1:age 23</span><br><span class="line">set user:1:city xi&#39;an</span><br></pre></td></tr></table></figure><p>优点：简单直观，每个属性都支持更新操作。</p><p>缺点：占用过多的键，内存占用量较大，用户信息内聚性差，一般不会在生产环境使用。</p></li><li><p>序列化字符串类型：将用户信息序列化后用一个键保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set user:1 serialize(userInfo)</span><br></pre></td></tr></table></figure><p>优点：编程简单，如果合理使用序列化可以提高内存使用率。</p><p>缺点：序列化和反序列化有一定开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到 Redis。</p></li><li><p>哈希类型：每个用户属性使用一对 field-value，但只用一个键保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset user:1 name tom age 23 city xi&#39;an</span><br></pre></td></tr></table></figure><p>优点：简单直观，如果合理使用可以减少内存空间使用。</p><p>缺点：要控制哈希在 ziplist 和 hashtable 两种内部编码的转换，hashtable 会消耗更多内存。</p></li></ul><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表类型是用来存储多个有序的字符串，列表中的每个字符串称为元素，一个列表最多可以存储 2^32^-1 个元素。可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发中有很多应用场景。</p><p>列表类型有两个特点：① 列表中的元素是有序的，可以通过索引下标获取某个元素或者某个范围内的元素列表。② 列表中的元素可以重复。</p><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><p><strong>添加操作</strong></p><p>从右边插入元素：<code>rpush key value [value...]</code></p><p>从左到右获取列表的所有元素：<code>lrange 0 -1</code></p><p>从左边插入元素：<code>lpush key value [value...]</code></p><p>向某个元素前或者后插入元素：<code>linsert key before|after pivot value</code>，会在列表中找到等于 pivot 的元素，在其前或后插入一个新的元素 value。</p><p><strong>查找</strong></p><p>获取指定范围内的元素列表：<code>lrange key start end</code>，索引从左到右的范围是 0<del>N-1，从右到左是 -1</del>-N，lrange 中的 end 包含了自身。</p><p>获取列表指定索引下标的元素：<code>lindex key index</code>，获取最后一个元素可以使用 <code>lindex key -1</code>。</p><p>获取列表长度：<code>llen key</code></p><p><strong>删除</strong></p><p>从列表左侧弹出元素：<code>lpop key</code></p><p>从列表右侧弹出元素：<code>rpop key</code></p><p>删除指定元素：<code>lrem key count value</code>，如果 count 大于 0，从左到右删除最多 count 个元素，如果 count 小于 0，从右到左删除最多个 count 绝对值个元素，如果 count 等于 0，删除所有。</p><p>按照索引范围修剪列表：<code>ltrim key start end</code>，只会保留 start ~ end 范围的元素。</p><p><strong>修改</strong></p><p>修改指定索引下标的元素：<code>lset key index newValue</code>。</p><p><strong>阻塞操作</strong></p><p>阻塞式弹出：<code>blpop/brpop key [key...] timeout</code>，timeout 表示阻塞时间。</p><p>当列表为空时，如果 timeout = 0，客户端会一直阻塞，如果在此期间添加了元素，客户端会立即返回。</p><p>如果是多个键，那么brpop会从左至右遍历键，一旦有一个键能弹出元素，客户端立即返回。</p><p>如果多个客户端对同一个键执行 brpop，那么最先执行该命令的客户端可以获取弹出的值。</p><hr><h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><p>列表的内部编码有两种：</p><ul><li>ziplist 压缩列表：跟哈希的 zipilist 相同，元素个数和大小小于配置值（默认 512 个和 64 字节）时使用。</li><li>linkedlist 链表：当列表类型无法满足 ziplist 的条件时会使用linkedlist。</li></ul><p>Redis 3.2 提供了 quicklist 内部编码，它是以一个 ziplist 为节点的 linkedlist，它结合了两者的优势，为列表类提供了一种更为优秀的内部编码实现。</p><hr><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p><strong>消息队列</strong></p><p>Redis 的 lpush + brpop 即可实现阻塞队列，生产者客户端使用 lpush 从列表左侧插入元素，多个消费者客户端使用 brpop 命令阻塞式地抢列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</p><p><strong>文章列表</strong></p><p>每个用户有属于自己的文章列表，现在需要分页展示文章列表，就可以考虑使用列表。因为列表不但有序，同时支持按照索引范围获取元素。每篇文章使用哈希结构存储，例如每篇文章有三个属性，title、timestamp 和 content：</p><p><code>hmset article:k title t timestamp 147651524 content c</code>。</p><p>向用户文章列表添加文章，<code>user:{id}:articles</code> 作为用户文章列表的键：</p><p><code>lpush user:k:articles article:k</code>。</p><p>分页获取用户文章列表，例如以下伪代码获取用户 id = 1 的前 10 篇文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">articles &#x3D; lrange user:1:articles 0 9</span><br><span class="line">for article in &#123;articles&#125;</span><br><span class="line">hgetall &#123;article&#125;</span><br></pre></td></tr></table></figure><p>使用列表类型保存和获取文章列表存在两个问题：① 如果每次分页获取的文章个数较多，需要执行多次 hgetall 操作，此时可以考虑使用 Pipeline 批量获取，或者考虑将文章数据序列化为字符串类型，使用 mget 批量获取。② 分页获取文章列表时，lrange 命令在列表两端性能较好，但如果列表大，获取中间范围的元素性能会变差，可以考虑将列表做二级拆分，或使用 Redis3.2 的 quicklist。</p><hr><p><strong>lpush + lpop = 栈</strong></p><p><strong>lpush + rpop  = 队列</strong></p><p><strong>lpush + ltrim = 优先集合</strong></p><p><strong>lpush + brpop = 消息队列</strong></p><hr><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合类型也是用来保存多个字符串元素，和列表不同的是集合不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。一个集合最多可以存储 2^32^-1 个元素。Redis 除了支持集合内的增删改查，还支持多个集合取交集、并集、差集。</p><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><p><strong>集合内操作</strong></p><p><strong>添加元素</strong></p><p><code>sadd key element [element...]</code>，返回结果为添加成功的元素个数。</p><p><strong>删除元素</strong></p><p><code>srem key element [element...]</code>，返回结果为成功删除的元素个数。</p><p><strong>计算元素个数</strong></p><p><code>scard key</code>，时间复杂度为 O(1)，会直接使用 Redis 内部的遍历。</p><p><strong>判断元素是否在集合中</strong></p><p><code>sismember key element</code>，如果存在返回 1，否则返回 0。</p><p><strong>随机从集合返回指定个数个元素</strong></p><p><code>srandmember key [count]</code>，如果不指定 count 默认为 1。</p><p><strong>从集合随机弹出元素</strong></p><p><code>spop key</code>，可以从集合中随机弹出一个元素。</p><p><strong>获取所有元素</strong></p><p><code>smembers key</code></p><hr><p><strong>集合间操作</strong></p><p><strong>求多个集合的交集</strong></p><p><code>sinter key [key...]</code></p><p><strong>求多个集合的并集</strong></p><p><code>sunion key [key...]</code></p><p><strong>求多个集合的差集</strong></p><p><code>sdiff key [key...]</code></p><p><strong>保存交集、并集、差集的结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key [key...]</span><br><span class="line">sunionstore destination destination key [key...]</span><br><span class="line">sdiffstore destination key [key...]</span><br></pre></td></tr></table></figure><p>集合间的运算在元素较多的情况下会比较耗时，所以 Redis 提供了这三个指令将集合间交集、并集、差集的结果保存在 destination key 中。</p><hr><h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><p>集合类型的内部编码有两种：</p><ul><li>intset 整数集合：当集合中的元素个数小于配置值（默认 512 个时），,且都是整数时，使用 intset。</li><li>hashtable 哈希表：当集合类型无法满足 intset 条件时使用 hashtable。当某个元素不为整数时，也会使用 hashtable。</li></ul><hr><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>集合类型比较典型的使用场景是标签，例如一个用户可能与娱乐、体育比较感兴趣，另一个用户可能对例时、新闻比较感兴趣，这些兴趣点就是标签。这些数据对于用户体验以及增强用户黏度比较重要。</p><p><strong>给用户添加标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2 tag5</span><br><span class="line">sadd user:2:tags tag3 tag4 tag5</span><br><span class="line">...</span><br><span class="line">sadd user:k:tags tagx tagy tagz</span><br></pre></td></tr></table></figure><p><strong>给标签添加用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd tag:1:users user:1 user:3</span><br><span class="line">sadd tag:2:users user:1 user:4 user:5</span><br><span class="line">...</span><br><span class="line">sadd tag:k:users user:x user:y ...</span><br></pre></td></tr></table></figure><p>用户和标签的关系维护应该在一个事务内执行，防止部分命令失败造成的数据不一致。</p><p><strong>删除用户标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem user:1:tags tag1 tag5</span><br></pre></td></tr></table></figure><p><strong>删除标签下的用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem tag:1:users user:1</span><br></pre></td></tr></table></figure><p>删除也同样应该放在一个事务中。</p><p><strong>求两个用户共同感兴趣的标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinter user:1:tags user:2:tags</span><br></pre></td></tr></table></figure><p><strong>sadd = 标签</strong></p><p><strong>spop/srandmember = 生成随机数，比如抽奖</strong></p><p><strong>sadd + sinter = 社交需求</strong></p><hr><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>有序集合保留了集合不能有重复成员的特性，不同的是可以排序。但是它和列表使用索引下标作为排序依据不同的是，他给每个元素设置一个分数（score）作为排序的依据。有序集合提供了获取指定分数和元素查询范围、计算成员排名等功能。</p><table><thead><tr><th>数据结构</th><th>是否允许元素重复</th><th>是否有序</th><th>有序实现方式</th><th>应用场景</th></tr></thead><tbody><tr><td>列表</td><td>是</td><td>是</td><td>下标</td><td>时间轴，消息队列</td></tr><tr><td>集合</td><td>否</td><td>否</td><td>/</td><td>标签，社交</td></tr><tr><td>有序集合</td><td>否</td><td>是</td><td>分值</td><td>排行榜，社交</td></tr></tbody></table><h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><p><strong>集合内</strong></p><p><strong>添加成员</strong></p><p><code>zadd key score member [score member...]</code>，返回结果是成功添加成员的个数</p><p>Redis 3.2 为 zadd 命令添加了 nx、xx、ch、incr 四个选项：</p><ul><li>nx：member 必须不存在才可以设置成功，用于添加</li><li>xx：member 必须存在才能设置成功，用于更新</li><li>ch：返回此次操作后，有序集合元素和分数变化的个数</li><li>incr：对 score 做增加，相当于 zincrby</li></ul><p>zadd 的时间复杂度为 O(log<del>n</del>)，sadd 的时间复杂度为 O(1)。</p><p><strong>计算成员个数</strong></p><p><code>zcard key</code>，时间复杂度为 O(1)。</p><p><strong>计算某个成员的分数</strong></p><p><code>zscore key member</code> ，如果不存在则返回 nil。</p><p><strong>计算成员排名</strong></p><p><code>zrank key member</code>，从低到高返回排名</p><p><code>zrevrank key member</code>，从高到低返回排名</p><p><strong>删除成员</strong></p><p><code>zrem key member [member...]</code>，返回结果是成功删除的个数。</p><p><strong>增加成员的分数</strong></p><p><code>zincrby key increment member</code></p><p><strong>返回指定排名范围的成员</strong></p><p><code>zrange key start end [withscores]</code></p><p><code>zrevrange key start end [withscores]</code></p><p>zrange 从低到高返回，zrevrange 从高到底返回，如果加上 withscores 选项同时会返回成员的分数。</p><p><strong>返回指定分数范围的成员</strong></p><p><code>zrangebyscore key min max [withscores] [limit offset count]</code></p><p><code>zrevrangebyscore key min max [withscores] [limit offset count]</code></p><p>zrangebyscore 从低到高返回，zrevrangebyscore 从高到底返回，如果加上 withscores 选项同时会返回成员的分数。[limit offset count] 可以限制输出的起始位置和个数。</p><p><strong>返回指定分数范围成员个数</strong></p><p><code>zcount key min max</code></p><p><strong>删除指定排名内的升序元素</strong></p><p><code>zremrangebyrank key start end</code></p><p><strong>删除指定分数范围内的成员</strong></p><p><code>zremrangebyscore key min max</code></p><hr><p><strong>集合间的操作</strong></p><p><strong>交集</strong></p><p><code>zinterstore destination numkeys key [key...] [weights weight [weight...]] [aggregate sum|min|max]</code></p><ul><li><p>destination：交集结果保存到这个键</p></li><li><p>numkeys：要做交集计算键的个数</p></li><li><p>key [key…]：需要做交集计算的键</p></li><li><p>weights weight [weight…]：每个键的权重，默认 1</p></li><li><p>aggregate sum|min|max：计算交集后，分值可以按和、最小值、最大值汇总，默认 sum</p></li></ul><p><strong>并集</strong></p><p><code>zunionstore destination numkeys key [key...] [weights weight [weight...]] [aggregate sum|min|max]</code></p><hr><h4 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h4><p>有序集合的内部编码有两种：</p><ul><li>ziplist 压缩列表：当有序集合元素个数和值小于配置值（默认128 个和 64 字节）时会使用 ziplist 作为内部实现。</li><li>skiplist 跳跃表：当 ziplist 不满足条件时使用，因为此时 ziplist 的读写效率会下降。</li></ul><hr><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>有序集合的典型使用场景就是排行榜系统。</p><p>例如用户 mike 上传了一个视频并添加了 3 个赞，可以使用有序集合的 zadd 和 zincrby：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd user:ranking:2020_06_19 3 mike</span><br></pre></td></tr></table></figure><p>如果之后再获得一个赞，可以使用 zincrby：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zincrby user:ranking:2020_06_19 1 mike</span><br></pre></td></tr></table></figure><p>例如需要将用户 tom 从榜单删除，可以使用 zrem：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem user:ranking:2020_06_19 tom</span><br></pre></td></tr></table></figure><p>展示获取赞数最多的十个用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrange user:ranking:2020_06_19 0 9</span><br></pre></td></tr></table></figure><p>展示用户信息及用户分数，将用户名作为键后缀，将用户信息保存在哈希类型中，至于用户分数和排名可以使用 zscore 和 zrank：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hgetall user:info:tom</span><br><span class="line">zscore user:ranking:2020_06_19 tom</span><br><span class="line">zrank user:ranking:2020_06_19 tom</span><br></pre></td></tr></table></figure><hr><h3 id="键管理"><a href="#键管理" class="headerlink" title="键管理"></a>键管理</h3><h4 id="单个键管理"><a href="#单个键管理" class="headerlink" title="单个键管理"></a>单个键管理</h4><p><strong>键重命名</strong></p><p><code>rename key newkey</code></p><p>如果 rename 前键已经存在，那么它的值也会被覆盖。</p><p>为了防止强行覆盖，Redis 提供了 renamenx 命令，确保只有 newkey 不存在时才被覆盖。由于重命名键期间会执行 del 命令删除旧的键，如果键对应值比较大会存在阻塞的可能。</p><p><strong>随机返回一个键</strong></p><p><code>random key</code></p><p><strong>键过期</strong></p><p><code>expire key seconds</code>：键在 seconds 秒后过期</p><p><code>expireat key timestamp</code>：键在秒级时间戳 timestamp 后过期</p><p>如果过期时间为负值，键会被立即删除，和 del 命令一样。</p><p>persist 命令可以将键的过期时间清除。</p><p>对于字符串类型键，执行 set 命令会去掉过期时间，set 命令对应的函数 setKey 最后执行了 removeExpire 函数去掉了过期时间。</p><p>Redis 不支持二级数据结构（例如哈希、列表）内部元素的过期功能，例如不能对列表类型的一个元素设置过期时间。</p><p>setex 命令作为 set + expire 的组合，不单是原子执行并且减少了一次网络通信的时间。</p><p><strong>键迁移</strong></p><ul><li><p>move</p><p><code>move key db</code></p><p>move 命令用于在 Redis 内部进行数据迁移，<code>move key db</code> 就是把指定的键从源数据库移动到目标数据库中。</p></li><li><p>dump + restore</p><p><code>dump key</code></p><p><code>restore key ttl value</code></p><p>可以实现在不同的 Redis 势力之间进行数据迁移，分为两步：</p><p>① 在源 Redis 上，dump 命令会将键值序列化，格式采用 RDB 格式。</p><p>② 在目标 Redis 上，restore 命令将上面序列化的值进行复原，ttl 参数代表过期时间， ttl = 0 则没有过期时间。</p><p>整个迁移并非原子性的，而是通过客户端分步完成，并且需要两个客户端。</p></li><li><p>migrate</p><p>实际上 migrate 命令就是将 dump、restore、del 三个命令进行组合，从而简化了操作流程。migrate 具有原子性，且支持多个键的迁移，有效提高了迁移效率。实现过程和 dump + restore 类似，有三点不同：</p><p>① 整个过程是原子执行，不需要在多个 Redis 实例开启客户端。</p><p>② 数据传输直接在源 Redis 和目标 Redis 完成。</p><p>③ 目标 Redis 完成 restore 后会发送 OK 给源 Redis，源 Redis 接收后会根据 migrate 对应的选项来决定是否在源 Redis 上删除对应的键。</p></li></ul><table><thead><tr><th>命令</th><th>作用域</th><th>原子性</th><th>支持多个键</th></tr></thead><tbody><tr><td>move</td><td>Redis 实例内部</td><td>是</td><td>否</td></tr><tr><td>dump + restore</td><td>Redis 实例之间</td><td>否</td><td>否</td></tr><tr><td>migrate</td><td>Redis 实例之间</td><td>是</td><td>是</td></tr></tbody></table><hr><h4 id="遍历键"><a href="#遍历键" class="headerlink" title="遍历键"></a>遍历键</h4><p><strong>全量遍历键</strong></p><p><code>keys pattern</code></p><p><code>*</code>代表匹配任意字符，<code>?</code> 匹配一个字符，<code>[]</code> 匹配部分字符，例如 <code>[1,3]</code> 匹配 1 和 3， <code>[1-3]</code> 匹配 1 到 3 的任意数字，<code>\</code>用来做转义。</p><p><code>keys *</code> 遍历所有的键，一般不在生产环境使用，在以下情况可以使用：</p><p>① 在一个不对外提供服务的 Redis 从节点上执行，不会阻塞客户端的请求，但会影响主从复制。</p><p>② 如果确定键值总数比较少可以执行。</p><hr><p><strong>渐进式遍历</strong></p><p>Redis 从 2.8 版本后提供了一个新的命令 scan，能有效解决 keys 存在的问题。和 keys 遍历所有键不同，scan 采用渐进式遍历的方式解决阻塞问题，每次 scan 的时间复杂度为 O(1)，但是要真正实现 keys 的功能可能需要执行多次 scan。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan cursor [match pattern] [count number]</span><br></pre></td></tr></table></figure><p>cursor 是必须参数，代表一个游标，第一次遍历从 0 开始，每次 scan 完会返回当前游标的值，直到值为 0 表示遍历结束。</p><p>match pattern 是可选参数，作用是模式匹配。</p><p>count number 是可选参数，作用是表明每次要遍历的键个数，默认值为 10。</p><p>除了 scan 外，Redis 提供了面向哈希、集合、有序集合的扫描遍历命令，解决了 hgetall、smembers、zrange 可能产生的阻塞问题，对应命令分别为 hscan、sscan、zscan。</p><p>渐进式遍历可以有效解决 keys 命令可能产生的阻塞问题，但是如果在 scan 过程中有键的变化，那么遍历效果可能会遇到问题：新增的键没有被遍历到，遍历了重复的键等情况。</p><hr><h4 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h4><p><strong>切换数据库</strong></p><p><code>select dbIndex</code></p><p>Redis 中默认配置有 16 个数据库，例如 select 0 将切换到第一个数据库，数据库之间的数据是隔离的。</p><p><strong>flushdb/flushall</strong></p><p>用于清除数据库，flushdb 只清除当前数据库，flushall 会清除所有数据库。如果当前数据库键值数量比较多，flushdb/flushall 存在阻塞 Redis 的可能性。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redis 提供 5 种数据结构，每种数据结构都有多种内部编码实现。</p><p>纯内存存储、IO 多路复用计数、单线程架构是造就 Redis 高性能的三个因素。</p><p>由于 Redis 的单线程结构，所以需要每个命令能被快速执行完，否则会存在阻塞的可能。</p><p>批量操作（例如 mget、mset、hmset 等）能够有效提高命令执行的效率，但要注意每次批量操作的个数和字节数。</p><p>persist 命令可以删除任意类型键的过期时间，但 set 也会删除字符串类型键的过期时间。</p><p>move、dump + restore、migrate 是 Redis 发展过程中三种迁移键的方式，其中 move 命令基本废弃，migrate 命令用原子性的方式实现了 dump + restore，并且支持批量操作，是 Redis Cluster 实现水平扩容的重要工具。</p><p>scan 命令可以解决 keys 命令可能带来的阻塞问题，同时 Redis 还提供了 hscan、sscan、zscan 渐进式遍历 hash、set、zset。</p><hr><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的<br>Redis会将一个事务中的所有命令序列化，然后按顺序执行。<br>1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。<br>2.如果在一个事务中的<strong>命令</strong>出现错误，那么<strong>所有的命令</strong>都不会执行；<br>3.如果在一个事务中出现<strong>运行错误</strong>，那么<strong>正确的命令</strong>会被执行。<br>注：redis的discard只是结束本次事务,正确命令造成的影响仍然存在.</p><p>1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。<br>2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。<br>3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。<br>4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</p><hr><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>Bitmaps 本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。</p><p>Bitmaps 单独提供了一套命令，所以在 Redis 使用 Bitmaps 和使用字符串的方法不太相同，可以把 Bitmaps 看作一个以位为单位的数组，数组的每个单元只能存储 0 和 1，数组的下标叫做偏移量。</p><h4 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h4><p>例：将每个独立用户是否访问过网站存放在 Bitmaps 中，将访问过的用户记作 1，没有访问过的记作 0，偏移量作为用户的 id。</p><p><strong>设置值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure><p>设置键的第 offset 个位的值，假设有 20 个用户，id 为 0、5、11、15、19 的用户对网站进行了访问，那么初始化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setbit unique:users:2020-06-20 0 1</span><br><span class="line">setbit unique:users:2020-06-20 5 1</span><br><span class="line">setbit unique:users:2020-06-20 11 1</span><br><span class="line">setbit unique:users:2020-06-20 15 1</span><br><span class="line">setbit unique:users:2020-06-20 19 1</span><br></pre></td></tr></table></figure><p>很多应用的用户 id 直接以一个指定数字开头，例如 10000，直接将用户 id 与 Bitmaps 的偏移量对应势必会造成一定浪费，通常做法是每次做 setbit 操作时将用户 id 减去这个指定数字。在第一次初始化 Bitmaps 时，如果偏移量非常大，那么整个初始化过程会执行比较慢，可能造成阻塞。</p><p><strong>获取值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure><p>获取键的第 offset 个位的值，例如获取 id 为 8 的用户是否在 2020-06-20 这天访问过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit unique:users:2020-06-20 8</span><br></pre></td></tr></table></figure><p><strong>获取指定范围值为 1 的个数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure><p>例如获取 2020-06-20 这天访问过的用户数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount unique:users:2020-06-20</span><br></pre></td></tr></table></figure><p>start 和 end 代表起始和结束字节数。</p><p><strong>Bitmaps 间的运算</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop op destkey key [key...]</span><br></pre></td></tr></table></figure><p>bitop 是一个复合操作，它可以做交集、并集、非、异或并将结果保存到 destkey 中。</p><p>例如计算 2020-06-20 和 2020-06-21 都访问过网站的用户数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitop and unique:users:and:2020-06-20_21 unique:users:2020-06-20 unique:users:2020-06-21</span><br><span class="line">bitcount unique:users:and:2020-06-20_21</span><br></pre></td></tr></table></figure><p>例如计算 2020-06-20 和 2020-06-21 任意一天访问过网站的用户数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitop or unique:users:or:2020-06-20_21 unique:users:2020-06-20 unique:users:2020-06-21</span><br><span class="line">bitcount unique:users:or:2020-06-20_21</span><br></pre></td></tr></table></figure><p><strong>计算第一个值为 tartgetBit 的偏移量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitops key targetBit [start] [end]</span><br></pre></td></tr></table></figure><p>例如计算 2020-06-20 当前访问网站的最小用户 id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitops unique:users:2019-06-20 1</span><br></pre></td></tr></table></figure><p>假设网站的活跃用户量很大，使用 Bitmaps 相比 set 可以节省很多内存，但如果活跃用户很少就会浪费内存。</p><hr><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>HyperLogLog 不是一种新的数据结构，实际也是字符串类型，是一种基数算法。提供 HyperLogLog 可以利用极小的内存空间完成独立总数的统计，数据集可以是 IP、Email、ID 等。</p><p><strong>添加</strong></p><p><code>pfadd key element [element...]</code>，如果添加成功会返回 1</p><p><strong>计算独立用户数</strong></p><p><code>pfcount key [key...]</code></p><p><strong>合并</strong></p><p><code>pfmerge destkey sourcekey [sourcekey...]</code></p><p>HyperLogLog 内存占用量非常小，但是存在错误率，开发者在进行数据结构选型时只需要确认如下两条：</p><ul><li>只为了计算独立总数，不需要获取单条数据。</li><li>可以容忍一定误差率，毕竟 HyperLogLog 在内存占用量上有很大优势。</li></ul><hr><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>Redis 提供了基于发布/订阅模式的消息机制，此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel）发送消息，订阅该频道的每个客户端都可以收到该消息。</p><h4 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h4><p><strong>发布消息</strong></p><p><code>publish channel message</code>，返回结果为订阅者的个数。</p><p><strong>订阅消息</strong></p><p><code>subscribe channel [channel..]</code>，订阅者可以订阅一个或多个频道。</p><p>客户端在执行订阅命令后会进入订阅状态，只能接收 subscribe、psubscribe、unsubscribe、punsubscribe 的四个命令。新开启的订阅客户端，无法收到该频道之前的消息，因为 Redis 不会对法捕的消息进行持久化。</p><p>和很多专业的消息队列系统如 Kafka、RocketMQ 相比，Redis 的发布订阅略显粗糙，例如无法实现消息堆积和回溯，但胜在足够简单，如果当前场景可以容忍这些缺点，也是一个不错的选择。</p><p><strong>取消订阅</strong></p><p><code>unsubscribe [channel [channel...]]</code></p><p>客户端可以通过 unsubscribe 命令取消对指定频道的订阅，取消成功后不会再收到该频道的发布消息。</p><p><strong>按照模式订阅和取消订阅</strong></p><p><code>psubscribe pattern [pattern...]</code></p><p><code>punsubscribe pattern [pattern...]</code></p><p>这两种命令支持 glob 风格，例如订阅所有以 it 开头的频道：<code>psubscribe it*</code></p><p><strong>查询订阅</strong></p><p>查看活跃的频道：<code>pubsub channels [pattern]</code>，活跃频道是指当前频道至少有一个订阅者。</p><p>查看频道订阅数：<code>pubsub numsub [channel ...]</code></p><p>查看模式订阅数：<code>pubsub numpat</code></p><hr><h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><p>聊天室、公告牌、服务之间利用消息解耦都可以使用发布订阅模式，以服务器解耦为例：视频管理系统负责管理视频信息，用户通过各种客户端获取视频信息。</p><p>假如视频管理员在视频管理系统中对视频信息进行了更新，希望及时通知给视频服务端，就可以采用发布订阅模式，发布视频信息变化的消息到指定频道，视频服务订阅这个频道及时更新视频信息，通过这种方式实现解耦。</p><p>视频服务订阅 video:changes 频道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe video:changes</span><br></pre></td></tr></table></figure><p>视频管理系统发布消息到 video:changes 频道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish video:changes &quot;video1,video3,video5&quot;</span><br></pre></td></tr></table></figure><p>视频服务收到消息，对视频信息进行更新..</p><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>慢查询中有两个重要参数 slowlog-log-slower-than 和 slowlog-max-len。</p><p>慢查询不包括命令网络传输和排队时间。</p><p>有必要将慢查询定期存放。</p><p>Pipeline 可以有效减少 RTT 次数，但每次 Pipeline 的命令数量不能无节制。</p><p>Redis 可以使用 Lua 脚本创造出原子、高效、自定义命令组合。</p><p>Bitmaps 可以用来做独立用户统计，有效节省内存。</p><p>Bitmaps 中 setbit 一个大的偏移量，由于申请大量内存会导致阻塞。</p><p>HyperLogLog 虽然在统计独立总量时存在一定误差，但是节省的内存量十分惊人。</p><p>Redis 的发布订阅相比许多专业消息队列系统功能较弱，不具备息堆积和回溯能力，但胜在足够简单。</p><p>Redis 3.2 提供了 GEO 功能，用来实现基于地理位置信息的应用，底层实现是 zset。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p><p>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p><p><img src="https://img-blog.csdnimg.cn/20191213103148681.png" alt="img"></p><p>使用SETNX完成同步锁的流程及事项如下：</p><p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</p><p>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p><p>释放锁，使用DEL命令将锁数据删除</p><h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>​    <strong>描述：</strong></p><p>​    缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p><p>   <strong>解决方案：</strong></p><ol><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ol><li><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol></li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿</strong>是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p><strong>解决方案</strong></p><ol><li>设置热点数据永远不过期。</li><li>加互斥锁，互斥锁</li></ol><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>2）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="image"></p><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p><p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md" target="_blank" rel="noopener">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">**缓存穿透**是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</span><br><span class="line"></span><br><span class="line">**解决方案**</span><br><span class="line"></span><br><span class="line">1. 接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</span><br><span class="line">2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</span><br><span class="line">3. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</span><br><span class="line"></span><br><span class="line">**附加**</span><br><span class="line"></span><br><span class="line">对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</span><br><span class="line">Bitmap： 典型的就是哈希表</span><br><span class="line">缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</span><br><span class="line"></span><br><span class="line">布隆过滤器（推荐）</span><br><span class="line"></span><br><span class="line">就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</span><br><span class="line">它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</span><br><span class="line">Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</span><br><span class="line">Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。</span><br><span class="line">Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</span><br></pre></td></tr></table></figure><p>is 对象的个数，在极端情况下可能会造成连接泄露，而连接池的形式可以有效的保护和控制资源的使用。</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>直连</td><td>简单方便，适用于少量长期连接的场景。</td><td>存在每次连接关闭 TCP 连接的开销，资源无法控制可能出现连接泄露，Jedis 对象线程不安全</td></tr><tr><td>连接池</td><td>无需每次连接都生成 Jedis 对象降低开销，使用连接池的形式保护和控制资源的使用</td><td>相对于直连比较麻烦，尤其在资源的管理上需要很多参数来保证，一旦规划不合理也会出现问题</td></tr></tbody></table><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p><strong>快照（snapshotting）持久化（RDB）</strong></p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。默认的文件名为dump.rdb。</p><p><strong>1、save触发方式</strong></p><p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：</p><p><img src="https://pics1.baidu.com/feed/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg?token=7ed4cf784a82d04e60b8dc72cf7e3c24&s=EDBAA5565D1859C85444707E02005071" alt="img"></p><p>执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p><p><strong>2、bgsave触发方式</strong></p><p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p><p><img src="https://pics5.baidu.com/feed/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg?token=a72f072d65d2de548d71bb459cd0bf4f&s=05AAFE168FF04C8A10FD2DEE0300E032" alt="img"></p><p>具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</p><p><strong>3、自动触发</strong></p><p>自动触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：</p><p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><img src="https://pics5.baidu.com/feed/1c950a7b02087bf43b4490d50ac25f2a11dfcf7e.jpeg?token=22f387ba78130c6115420059481b2393&s=EF48A15796784D8816E1D9EB03007024" alt="img"></p><p><strong>AOF（append-only file）持久化</strong></p><p>与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p><strong>RDB 的优势和劣势</strong></p><p>①、优势</p><p>（1）RDB，全量备份，非常适合用于进行备份和灾难恢复。</p><p>（2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p><p>（3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p><p>②、劣势</p><p>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p><p><strong>AOF 的优势和劣势</strong></p><p>(1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。</p><p>（2）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p><p><strong>5、缺点</strong></p><p>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p><p>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p><p><strong>相关 issue</strong> ：<a href="https://github.com/Snailclimb/JavaGuide/issues/783" target="_blank" rel="noopener">783：Redis 的 AOF 方式</a></p><hr><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(transaction)功能。</p><blockquote><p>MULTI<br>OK<br>INCR foo<br>QUEUED<br>INCR bar<br>QUEUED<br>EXEC</p></blockquote><p>1) (integer) 1<br>2) (integer) 1<br>Copy to clipboardErrorCopied<br>使用 MULTI命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了EXEC命令将执行所有命令。</p><p>Redis官网相关介绍 <a href="https://redis.io/topics/transactions" target="_blank" rel="noopener">https://redis.io/topics/transactions</a> 如下：</p><p>redis事务</p><p>但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： 1. 原子性，2. 隔离性，3. 持久性，4. 一致性。</p><p>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；<br>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；<br>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。<br>一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；<br>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</p><p>Redis官网也解释了自己为啥不支持回滚。简单来说就是Redis开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p><p>redis roll back</p><p>你可以将Redis中的事务就理解为 ：Redis事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</p><h3 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h3><p>文件事件处理器包括分别是<strong>套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器</strong>。使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。<br>I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br><strong>工作原理：</strong><br>1)I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br>尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字.<br><img src="https://img-blog.csdnimg.cn/20190429094050254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0J1dHRlcmZseV9yZXN0aW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>redis 提供 6种数据淘汰策略：</p><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从<strong>已设置过期时间</strong>的数据集（server.db[i].expires）中随机移除key</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-eviction：当内存不足以容纳新写入数据时，新写入操作会报错，无法写入新数据，一般不采用</li></ul><h3 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h3><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p><table><thead><tr><th>对比参数</th><th>Redis</th><th align="center">Memcached</th></tr></thead><tbody><tr><td>类型</td><td>1. 支持内存 2. 非关系型数据库</td><td align="center">1. 支持内存 2. 键值对形式 3. 缓存形式</td></tr><tr><td><strong>数据存储类型</strong></td><td>1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】</td><td align="center">只支持简单的key-value</td></tr><tr><td><strong>持久化支持</strong></td><td>1. RDB 2. AOF</td><td align="center">不支持</td></tr><tr><td><strong>集群模式</strong></td><td>原生支持 cluster 模式，可以实现主从复制，读写分离</td><td align="center">没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td></tr><tr><td>内存管理机制</td><td>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td><td align="center">Memcached 的数据则会一直在内存中，Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</td></tr></tbody></table><ul><li>存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。</li><li>数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。</li><li>用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>value的大小：<strong><em>\</em>redis可以达到1GB，而memcache只有1MB**</strong>。</li></ul><h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。<br>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="Redis的IO复用"><a href="#Redis的IO复用" class="headerlink" title="Redis的IO复用"></a>Redis的IO复用</h3><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p><p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件： 1. 文件事件; 2. 时间事件。</p><p>时间事件不需要多花时间了解，我们接触最多的还是 <strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p><p>《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。</p><blockquote><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。</p><p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote><p>可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p><img src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png" alt="img"></p><h3 id="gossip？"><a href="#gossip？" class="headerlink" title="gossip？"></a>gossip？</h3><p>gossip协议包含多种消息，包括ping，pong，meet，fail，等等</p><p>Redis 集群是去中心化的，彼此之间状态同步靠 gossip 协议通信，集群的消息有以下几种类型：</p><ul><li><strong>Meet</strong> 通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群。</li><li><strong>Ping</strong> 节点每秒会向集群中其他节点发送 ping 消息，消息中带有自己已知的两个节点的地址、槽、状态信息、最后一次通信时间等。</li><li><strong>Pong</strong> 节点收到 ping 消息后会回复 pong 消息，消息中同样带有自己已知的两个节点信息。</li><li><strong>Fail</strong> 节点 ping 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。</li></ul><p><img src="https://pic3.zhimg.com/80/v2-0e5e3f73c7cc427a688c6d45cf1f445a_hd.jpg" alt="img"></p><h4 id="redis键的删除策略"><a href="#redis键的删除策略" class="headerlink" title="redis键的删除策略"></a>redis键的删除策略</h4><p>问题：如果一个键过期了，那么它什么时候会被删除呢？有三个答案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在过期时间来临时，立即执行对键的删除操作 .。</span><br></pre></td></tr></table></figure><p>这种过期策略对内存友好，但对CPU是非常不友好的。因为还要主动设定定时器并主动删除，即通过CPU换内存（CPU主动删除了内存中的数据嘛，CPU忙，内存空闲）。可以想象一下在大数据大并发的时候，这种机制是多么灾难</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">惰性删除(Lazy Expiration)：redis内部不会监视记录是否过期，但是每次从键空间获取键时，检查记录是否过期。这种技术被称为lazy（惰性）expiration。</span><br></pre></td></tr></table></figure><p>与定时删除相反，此删除机制对内存是不友好的对CPU是友好的，惰性删除不会主动去删除已到期(expire)的键，而是等有需要调用的时候再判断，即内存换CPU（内存中有大量残留数据）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定期删除：每隔一段时间，对redis数据库进行一次检查，删除里面的过期键</span><br></pre></td></tr></table></figure><p>属于前两种方法的折中.但要注意操作检查执行的时间和频率，如果删除操作做的太频繁，或者检查执行的时间太长，定期策略就会退化成定时策略。</p><p>Redis服务器实际使用的是惰性删除和定期删除策略两种策略，配合使用两种策略和在使用CPU和内存找到平衡点。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>I/O 多路复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跳跃表</title>
      <link href="/2020/07/05/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
      <url>/2020/07/05/%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>[TOC]</p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。上层结点都有指向下层结点的指针，从上往下每一层链表节点数递减。比如第一层有两个，第二层有四个，以此类推。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/27/16f4745348536f87?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="跳跃表-三级索引-寻找42"></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>看懂了跳跃表的数据结构，那么就很容易理解节点的插入操作了，基本上两步操作就可以实现：在最底层的数据链表中插入数据，然后调整索引；</p><p>其中每一层的索引链表中是否需要增加新增的节点，其实并没有什么标准答案，我们尽量做到索引的平均分布即可，常用的就是【随机判断】决定是否需要新增或调整索引，当有新节点插入的时候，通过概率算法判断这个节点需要插入到几级节点中。</p><p>比如：</p><ul><li>底层数据链表有 N 个元素，随机选择 N/2 个元素作为 1 级索引，随机选择 N/4 个元素作为 2 级索引…一直到顶层索引；</li><li>新插入数据节点，1/2 概率不插入任何一级索引，1/4 概率返回需要插入 1 级索引，1/8 概率返回需要插入到 2 级索引，以此类推；</li><li>这里要注意一点，插入 2 级索引的时候，同时也需要插入 1 级索引；也就是插入 n 级索引的时候，同时也要插入 1~( n-1 ) 级索引。</li></ul><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>通过一个bit数组来存储特定数据的一种数据结构,每一个bit位都能独立包含信息,bit是数据的最小存储单元,因此能大量节省空间</p><p>按下标从数组的高位(左)向低位(右)取值,bit数组起始值全为0,从左到右取下标(下标从0开始),数组的每个元素值就是一个下标值.将元素对应的下标在bit位上的值改为1</p><p>举例:数组[2,5,3,8] 起始000000000 元素2对应下标2,<br>将左到右的下标2的值改为1 –&gt; 001000000————————————————</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql相关</title>
      <link href="/2020/07/05/sql%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/07/05/sql%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="左连接和内联的区别"><a href="#左连接和内联的区别" class="headerlink" title="左连接和内联的区别"></a>左连接和内联的区别</h2><p><strong>左连接：左边有的，右边没有的为null</strong></p><p><strong>右连接：左边没有的，右边有的为null</strong></p><p><strong>内连接：显示左边右边共有的</strong></p><p><img src="https://img-blog.csdnimg.cn/20200705154749515.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200705154850251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>左连接</p><p><img src="https://img-blog.csdnimg.cn/20200705155226877.png" alt="在这里插入图片描述"></p><p>内连接</p><p><img src="https://img-blog.csdnimg.cn/20200705155007995.png" alt="在这里插入图片描述"></p><p>右连接</p><p><img src="https://img-blog.csdnimg.cn/20200705154938172.png" alt="在这里插入图片描述"></p><h2 id="like和in关键字"><a href="#like和in关键字" class="headerlink" title="like和in关键字"></a>like和in关键字</h2><p>LIKE：</p><p>当无法确切知道所要查找的值，而是知道所要查找的数据符合的模式时，可以使用LIKE 子句进行匹配。一般来说，LIKE 子句仅在字符串类型时使用，但对数字类型数据是不能使用 LIKE 子句的。</p><p>不在 LIKE子句中使用时， 就不具有特殊的含义，仅表示其本身的值。</p><p>IN：</p><p>当确切知道所要查找的内容，且为多个值时，可以使用 IN 子句来进行数据比较</p><h3 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h3><p>查询各科成绩前三名的记录</p><p><a href="https://blog.csdn.net/weixin_38426554/article/details/100127430?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38426554/article/details/100127430?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control</a></p><p>sql查询每个班级的前三名</p><p><a href="https://blog.csdn.net/weixin_39428938/article/details/98214175" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39428938/article/details/98214175</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一条SQL查询语句的执行过程</title>
      <link href="/2020/07/05/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/07/05/%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>输入下面一条SQL语句，我们来分析下这条语句在MySQL内部的执行过程。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190109110912557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bjd2wxMjA2,size_16,color_FFFFFF,t_70" alt="img"></p><p>体来说，MySQL 可以分为 Server 层和存储引擎两部分。</p><p>Server 层包括：连接器、查询缓存、分析器、优化器、执行器等，涵盖了 MySQL 的大多数核心服务功能，以及所有的内置函数（如：日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如：存储过程、触发器、视图等等。</p><p>存储引擎层负责：数据的存储和提取。其架构是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。从MySQL5.5.5版本开始默认的是InnoDB，但是在建表时可以通过 engine = MyISAM 来指定存储引擎。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p><p>从图中可以看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。</p><h2 id="1、连接器"><a href="#1、连接器" class="headerlink" title="1、连接器"></a>1、连接器</h2><p> 第一步，要首先连接上数据库，这个时候使用的就是连接器。</p><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功创建以后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://img-blog.csdnimg.cn/20190109112901965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bjd2wxMjA2,size_16,color_FFFFFF,t_70" alt="img"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p><p><strong>数据库中的长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接指的是每次执行完很少的几次查询就断开连接，下次查询时再重新建立一个。</strong></p><p>但是如果连接都使用长连接的话，你可能会发现，有时候 MySQL 占用内存涨的特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才会释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象上看就是 MySQL 异常重启了。</p><p>那么怎么解决这个问题呢？下面提供两种解决方案：</p><blockquote><p>1、<strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，释放资源，之后要查询的时候再重连。 </p><p>2、如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过<strong>执行 mysql_reset_connection 来重新初始化连接资源</strong>。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p></blockquote><h2 id="2、查询缓存"><a href="#2、查询缓存" class="headerlink" title="2、查询缓存"></a>2、查询缓存</h2><p>连接建立完成后，就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p><p><strong>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果都会以key-value 对的形式，被直接缓存到内存中。其中，\</strong>key 是查询的语句，value 是查询的结果*<em>。如果你的查询能够直接在缓存中找到 key，那么这个 value 就会直接返回给客户端。*</em></p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><ul><li><p><strong>但是大多数情况下不建议使用查询缓存 —&gt; 因为查询缓存往往弊大于利</strong></p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你刚费劲存的结果还没来得及使用就被一个更新给清空了。</p></li></ul><p>对于更新压力大的数据库而言，查询缓存的命中率就会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>默认的 SQL 语句是不缓存的，可以显示的指定查询缓存：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10;</span><br></pre></td></tr></table></figure><p>需要说明的是：MySQL 8.0版本已经将查询缓存功能删除了。</p><h2 id="3、分析器"><a href="#3、分析器" class="headerlink" title="3、分析器"></a>3、分析器</h2><p>如果没有命中查询缓存，就要开始正真执行语句了。首先，MySQL 需要知道你要做什么，因此要对 SQL 语句做解析。</p><p>分析器先会做“词法分析”。MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>做完了这些识别以后，就要做“语法分析”。语法分析根据语法规则，判断输入的这个 SQL语句是否满足 MySQL 的语法规范。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID=1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; <span class="keyword">check</span> the <span class="keyword">manual</span> that corresponds <span class="keyword">to</span> your MySQL <span class="keyword">server</span> <span class="keyword">version</span> <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> <span class="keyword">use</span> near <span class="string">'elect * from t where ID=1'</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><h2 id="4、优化器"><a href="#4、优化器" class="headerlink" title="4、优化器"></a>4、优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始之前还要经过优化器的处理。</p><p>优化器是在表里有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而<strong>优化器的作用就是决定选择使用哪一个方案</strong>。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h2 id="5、执行器"><a href="#5、执行器" class="headerlink" title="5、执行器"></a>5、执行器</h2><p> MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。</p><p>如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): <span class="keyword">SELECT</span> command denied <span class="keyword">to</span> <span class="keyword">user</span> <span class="string">'b'</span>@<span class="string">'localhost'</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">'T'</span></span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行流程是这样的：</p><p>1、调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</p><p>2、调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行；</p><p>3、执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p><strong>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>隔离级别serilizable</title>
      <link href="/2020/07/05/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABserilizable/"/>
      <url>/2020/07/05/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABserilizable/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="如何实现的"><a href="#如何实现的" class="headerlink" title="如何实现的"></a>如何实现的</h2><p>在SERIALIZABLE级别下，不会使用mysql的mvcc机制，而是在每一个select请求下获得读锁，在每一个update操作下尝试获得写锁。</p><p>对于insert、update、delete，InnoDB会自动给涉及的数据加写锁；对于一般的Select语句，InnoDB不会加任何锁</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2020/07/04/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2020/07/04/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-使用互斥锁-mutex-key"><a href="#1-使用互斥锁-mutex-key" class="headerlink" title="1.使用互斥锁(mutex key)"></a>1.使用互斥锁(mutex key)</h3><p>业界比较常用的做法，是使用mutex。简单地来说。</p><p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">String value = redis.get(key);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//代表缓存值过期</span></span><br><span class="line"><span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line"><span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//代表设置成功</span></span><br><span class="line">value = db.get(key);</span><br><span class="line">redis.set(key, value, expire_secs);</span><br><span class="line">redis.del(key_mutex);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">sleep(<span class="number">50</span>);</span><br><span class="line">get(key);</span><br><span class="line"><span class="comment">//重试</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-zookeeper"><a href="#2-zookeeper" class="headerlink" title="2.zookeeper"></a>2.zookeeper</h3><p>创建一个锁目录 /lock；<br>当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；<br>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是<br>则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；<br>执行业务代码，完成后，删除对应的子节点。</p><h3 id="3-Redis-的-RedLock-算法"><a href="#3-Redis-的-RedLock-算法" class="headerlink" title="3.Redis 的 RedLock 算法"></a>3.Redis 的 RedLock 算法</h3><p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。<br>尝试从 N 个互相独立 Redis 实例获取锁；<br>计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，那<br>么就认为锁获取成功了；<br>如果锁获取失败，就到每个实例上释放锁。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>①redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能</p><p>②zk分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小</p><p>③另外一点就是，如果是redis获取锁的那个客户端bug了或者挂了，那么只能等待超时时间之后才能释放锁；而zk的话，因为创建的是临时znode，只要客户端挂了，znode就没了，此时就自动释放锁</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZGC和Shenandoah</title>
      <link href="/2020/07/04/ZGC%E5%92%8CShenandoah/"/>
      <url>/2020/07/04/ZGC%E5%92%8CShenandoah/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h2><p>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际是非常少的。那么其他阶段是怎么做到可以并发执行的呢？</p><p>ZGC主要新增了两项技术，一个是<strong>着色指针Colored Pointer</strong>，另一个是<strong>读屏障Load Barrier</strong>。</p><p><strong>着色指针Colored Pointer</strong><br> ZGC利用指针的64位中的几位表示Finalizable、Remapped、Marked1、Marked0（ZGC仅支持64位平台），以标记该指向内存的存储状态。相当于在对象的指针上标注了对象的信息。注意，这里的指针相当于Java术语当中的引用。</p><p>在这个被指向的内存发生变化的时候（内存在Compact被移动时），颜色就会发生变化。</p><p>在G1的时候就说到过，Compact阶段是需要STW，否则会影响用户线程执行。那么怎么解决这个问题呢？</p><p><strong>读屏障Load Barrier</strong> 由于着色指针的存在，在程序运行时访问对象的时候，可以轻易知道对象在内存的存储状态（通过指针访问对象），若请求读的内存在被着色了。那么则会触发读屏障。读屏障会更新指针再返回结果，此过程有一定的耗费，从而达到与用户线程并发的效果。</p><p>把这两项技术联合下理解，引用R大（RednaxelaFX）的话</p><blockquote><p>与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。</p></blockquote><p>链接：<a href="https://juejin.im/post/5bade237e51d450ea401fd71" target="_blank" rel="noopener">https://juejin.im/post/5bade237e51d450ea401fd71</a></p><h2 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h2><p>相比 G1 内存布局同样基于 Region，默认回收策略也是优先处理回收价值最大的 Region。但在管理堆内存方面，与 G1 有不同：① 支持并发整理，G1 的回收阶段不能与用户线程并发。②默认不使用分代收集，不会有专门的新生代 Region 或老年代 Region。③ 摒弃了在 G1 中耗费大量内存和计算资源去维护的记忆集，改用名为连接矩阵的全局数据结构来记录跨 Region 的引用关系。</p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/2020/07/04/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2020/07/04/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对于socket流而言,数据的流向经历两个阶段：</p><ul><li>第一步通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li><li>第二步把数据从内核缓冲区复制到应用进程缓冲区。</li></ul><p>recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中</p><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p><blockquote><p>blocking IO的特点就是在IO执行的两个阶段都被block了。</p></blockquote><h2 id="非阻塞式-I-O"><a href="#非阻塞式-I-O" class="headerlink" title="非阻塞式 I/O"></a>非阻塞式 I/O</h2><p>应用进程可以继续执行，但是需要不断的执行系统调用来获知I/O 是否完成，这种方式称为轮询（polling）。</p><blockquote><p><strong>此时的非阻塞IO只是应用到等待数据上,当真正有数据到达执行recvfrom的时候,还是同步阻塞IO来的</strong></p></blockquote><p><img src="/2020/07/04/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201211193546070.png" alt="image-20201211193546070"></p><h2 id="I-O-复用"><a href="#I-O-复用" class="headerlink" title="I/O 复用"></a>I/O 复用</h2><p>主要有 三种机制，分别是select  poll epoll  ，让它们等待数据，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p><p>好处:<br>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，<br>那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开<br>销更小。<br><img src="https://img-blog.csdnimg.cn/20200715094639319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtaW5nMg==,size_16,color_FFFFFF,t_70" alt="img"></p><p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval</span><br><span class="line">*timeout);</span><br></pre></td></tr></table></figure><p>有三种类型的描述符类型：readfds、writefds、exceptdfs，分别对应读、写、异常条件的描述符集合。fd_set 使用<br>数组实现，数组大小使用 FD_SETSIZE 定义。</p><p><strong>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</strong></p><p>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>int poll(struct pollfd *fds, unsigned int nfds, int timeout);</p><p>poll 的机制与 select 类似，与 select 在本质上没有多大差别，但是 poll 没有最大文件描述符数量的限制。poll改变了fds集合的描述方式，使用了pollfd结构而不是select的fd_set结构 .pollfd 使用链表实现。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure><p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<br>红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事<br>件完成的描述符。<br>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获<br>得事件完成的描述符。</p><p>epoll 仅适用于 Linux OS。<br>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和<br>poll 的不确定情况。</p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p><p>   <strong>水平触发:</strong>如果文件描述符已经就绪可以非阻塞的执行IO操作了,此时会触发通知.允许在任意时刻重复检测IO的状态.select,poll就属于水平触发.</p><p>   <strong>边缘触发:</strong>如果文件描述符自上次状态改变后有新的IO活动到来,此时会触发通知.在收到一个IO事件通知后要尽可能多的执行IO操作,因为如果在一次通知中没有执行完IO那么就需要等到下一次新的IO活动到来才能获取到就绪的描述符.信号驱动式IO就属于边缘触发.</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>IO复用？<br>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。<br>select、poll和epoll ·select、poll、epoll都可以监听多个文件描述符，等待指定的超时时间，直到一个或者多个文件描述符上有事件发生时返回。返回的值就是文件描述符的数量。返回0表示没有事件发生。<br>·差别： </p><ul><li>事件集和工作原理 ： select有三种类型的描述符类型：readfds、writefds、exceptfds，分别对应读、写、异常条件的描述符集合。因此，select不能处理这三种事件以外的事件类型。并且，每一次select会使得内核直接对fd_set进行修改，再下一次使用select的时候需要重置fd_set。每次select返回的都是注册了的事件集合，包括了就绪和没有就绪的，程序检索就绪事件的时间复杂度为O(n)<br>poll对select进行了改进，poll的参数是一个结构体pollfd。poll不会修改描述符，因此每次使用不需要重置pollfd。但是，poll仍然是返回注册了的事件集合，包括了就绪和没有就绪的，程序检索就绪事件的时间复杂度为O(n)。<br>·epoll_ctl() 用于向内核注册新的描述符或者是改变某个描述符的状态。已注册的描述符在内核中会被维护在一棵 红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事 件完成的描述符。使得检索的时间复杂度达到O(1)</li><li>支持最大的文件描述符 ： select：受到系统的限制，由&lt;sys/select.h&gt;头文件中的FD_SETSIZE宏决定，通常是1024 ·poll和epoll一般为65535 </li><li>工作模式 ·select和poll只能工作在相对来说低效的水平触发模式(LT) ·epoll可以工作在高效的边缘触发模式(ET),也可以工作在水平触发模式</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>　Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p><h2 id="信号驱动-I-O"><a href="#信号驱动-I-O" class="headerlink" title="信号驱动 I/O"></a>信号驱动 I/O</h2><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻<br>塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从<br>内核复制到应用进程中。</p><p><img src="/2020/07/04/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201211193643656.png" alt="image-20201211193643656"></p><h2 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h2><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向<br>应用进程发送信号。</p><p><img src="/2020/07/04/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201211193658657.png" alt="image-20201211193658657"></p><h1 id="水平触发和边缘触发"><a href="#水平触发和边缘触发" class="headerlink" title="水平触发和边缘触发"></a><strong>水平触发和边缘触发</strong></h1><h1 id="一、LT、ET模式介绍"><a href="#一、LT、ET模式介绍" class="headerlink" title="一、LT、ET模式介绍"></a><strong>一、LT、ET模式介绍</strong></h1><blockquote><h3 id="水平触发模式（LT）"><a href="#水平触发模式（LT）" class="headerlink" title="水平触发模式（LT）"></a><strong>水平触发模式（LT）</strong></h3><ul><li><strong>LT （Level Trigger，水平触发）模式</strong></li><li>LT模式是epoll的<strong>默认的工作模式</strong>，这种模式下epoll 相当于一个效率较高的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符，ET模式是epoll的高效工作模式。对于采用LT工作模式的文件描述符，当 epoll_wait <strong>检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件，这样，当应用程序下一次调用epoll_wait时，epoll_wait会再次向应用程序通告此事件，直到该事件被处理</strong></li></ul></blockquote><blockquote><h3 id="边沿触发模式（ET）"><a href="#边沿触发模式（ET）" class="headerlink" title="边沿触发模式（ET）"></a>边沿触发模式（ET）</h3><ul><li><strong>ET （Edge Trigger，边缘触发）模式</strong></li><li>对于采用ET工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序<strong><em>\</em>必须立即处理该事件，因为后续的epoll_wait用将不再向应用程序通知这一事件**</strong>，可见，ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此效率要比LT模式高</li></ul></blockquote><ul><li><strong>可以用下面一张图理解：</strong><ul><li>0代表无事件，1代表有事件。当epoll监听的套接字从无事件变为有事件就代表1次触发</li><li>边缘触发：事件只触发一次，在后面的时间线就消失了</li><li>水平触发：事件触发之后，如果不处理那么该事件依然存在，随着时间线往后延长，直至你处理完为止</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200805214506368.png" alt="img"></p><ul><li><strong>一些相关使用场景：</strong><ul><li><strong>大数据处理：</strong>因为大数据的数据量比较多，因此一次可能处理不完，可以使用水平触发，来多次处理数据</li><li><strong>小数据处理：</strong>小数据调用边缘触发即可，一次处理完就行</li><li><strong>服务器的监听套接字：</strong>使用水平触发。当有客户端连接时如果这次不处理，可以放到下一次来处理。但是如果使用边缘触发，本次不处理，下次再处理就消失了，从而失去了这个客户端的连接</li></ul></li><li><strong>epoll处理套接字在LT、ET不同模式下的数据演示案例：</strong><a href="https://blog.csdn.net/qq_41453285/article/details/103141158" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/103141158</a></li></ul><h1 id="二、ET在实际应用中使用的注意事项"><a href="#二、ET在实际应用中使用的注意事项" class="headerlink" title="二、ET在实际应用中使用的注意事项"></a>二、ET在实际应用中使用的注意事项</h1><blockquote><h3 id="读事件"><a href="#读事件" class="headerlink" title="读事件"></a>读事件</h3><ul><li>因为ET的事件只能触发一次，所以如果不想要接收的数据丢失，那么就需要在<strong><em>\</em>这次事件触发的时候一次性把数据读完**</strong>（一般是读到EAGAIN）</li><li>如果读取的时候，接收缓冲区满了，那就需要应用层自行标记，解决OS不再通知可读的问题（一般是读到EAGAIN）</li></ul></blockquote><blockquote><h3 id="写事件"><a href="#写事件" class="headerlink" title="写事件"></a>写事件</h3><ul><li>因为ET的事件只能触发一次，所以如果想要不想让发送的数据没有全部发送出去，那么就需要在<strong><em>\</em>这次事件触发的时候一次性把数据写完**</strong>（一般是写到EAGAIN）</li><li>如果发送的时候，发送缓冲区满了，那就需要应用层自行标记，解决OS不再通知可写的问题</li></ul></blockquote><blockquote><h3 id="accept-事件"><a href="#accept-事件" class="headerlink" title="accept()事件"></a>accept()事件</h3><ul><li><strong>ET模式下的accept()应该是非阻塞的：</strong><ul><li>如果套接口被设置成阻 塞模式，服务器就会一直阻塞在 accept 调用上，直到其他某个客户建立一个新的连接 为止。但是在此期间，服务器单纯地阻塞在 accept 调用上，就绪队列中的其他描述符 都得不到处理</li><li>解决办法是把监听套接口设置为非阻塞，当客户在服务器调用 accept 之前中止某个连 接时，accept 调用可以立即返回-1，这时源自 Berkeley 的实现会在内核中处理该事件，并不会将该事件通知给epoll，而其他实现把 errno 设置为 ECONNABORTED 或者 EPROTO 错误，我们应该忽略这两个错误</li></ul></li><li><strong>ET模式下使用while处理accept()：</strong><ul><li>考虑这种情况：多个连接同时到达，服务器的 TCP 就绪队列瞬间积累多个就绪连接，由 于是边缘触发模式，epoll 只会通知一次，accept 只处理一个连接，导致 TCP 就绪队列 中剩下的连接都得不到处理。</li><li>解决办法是用 while 循环抱住 accept 调用，处理完 TCP 就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept 返回-1 并且 errno 设置为 EAGAIN 就表示所有连接都处理完</li></ul></li><li><strong>综上所述：</strong>服务器应该使用非阻塞的accept，accept 在ET模式下的正确使用方式如下所示：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((conn_sock = accept(listenfd,(struct sockaddr *) &amp;remote,(<span class="keyword">size_t</span> *)&amp;addrlen)) &gt; <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    handle_client(conn_sock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conn_sock == <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != ECONNABORTED &amp;&amp;errno != EPROTO &amp;&amp; errno != EINTR)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        perror(<span class="string">"accept"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="三、LT在实际应用中使用的注意事项"><a href="#三、LT在实际应用中使用的注意事项" class="headerlink" title="三、LT在实际应用中使用的注意事项"></a>三、LT在实际应用中使用的注意事项</h1><blockquote><h3 id="读事件-1"><a href="#读事件-1" class="headerlink" title="读事件"></a>读事件</h3><ul><li><p>因为LT的事件可以一直触发，所以对读事件的处理可以根据自己的需求，自己决定是一次性读取完，还是分段的读</p></li><li><p>如果接收缓冲区满了，那么其就不能接收数据了，</p><p><strong>但是读事件还是会一直触发（因为你没有去接收数据）。解决方法如下：</strong></p><ul><li>修改fd的注册事件类型</li><li>或者把fd移出事件表</li></ul></li></ul></blockquote><blockquote><h3 id="写事件-1"><a href="#写事件-1" class="headerlink" title="写事件"></a>写事件</h3><ul><li><p>因为LT的事件可以一直触发，所以对写事件的处理可以根据自己的需求，自己决定是一次性写完，还是分段的写</p></li><li><p>如果发送缓冲区满了，那么其就不能发送数据了，</p><p><strong>但是写事件还是会一直触发（因为你没有把数据写出去）。解决方法如下：</strong></p><ul><li>修改fd的注册事件类型</li><li>或者把fd移出事件表</li></ul></li></ul></blockquote><ul><li><strong>从上面可以看出，LT模式相比于ET模式：</strong><ul><li>优点在于：事件循环处理比较简单，无需关注应用层是否有缓冲或缓冲区是 否满，只管上报事件</li><li>缺点在于：可能经常上报，可能影响性能。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>公平锁和非公平锁</title>
      <link href="/2020/07/04/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/"/>
      <url>/2020/07/04/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li></ul><p>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><ul><li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点.因为通常情况下挂起的线程重新开始与它真正开始运行，二者之间会产生严重的延时。</li><li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对象头由什么构成</title>
      <link href="/2020/07/04/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%94%B1%E4%BB%80%E4%B9%88%E6%9E%84%E6%88%90/"/>
      <url>/2020/07/04/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%94%B1%E4%BB%80%E4%B9%88%E6%9E%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>对象布局</p><p>在JVM中，对象在内存中的布局分为3块：</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>主要用于储存对象自身的运行时数据，例如对象的hashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程的ID、偏向时间戳</p><h3 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h3><p>而类型指针用于标识JVM通过这个指针来确定这个对象是哪个类的实例。</p><p><img src="https://pic1.zhimg.com/80/v2-e47232518a4e042f31a9e0eb6a48f88c_1440w.jpg" alt="img"></p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>它存储着对象真正的有效信息(程序代码中定义的各种类型的字段内容)，无论是从父类继承来的字段还是子类中定义的</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>它并没有什么特殊的含义，仅仅只是起占位符的作用。原因呢是因为JVM要求对象的起始地址必须是8个字节的整数倍(对象的大小必须是8个字节的整数倍)</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sleep和wait的区别</title>
      <link href="/2020/07/04/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/04/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>1.sleep() 方法正在执行的线程主动让出 cpu（然后 cpu 就可以去执行其他任务），在 sleep 指定时间后 cpu 再回到该线程继续往下执行（注意：sleep 方法只让出了 cpu，而并不会释放同步资源锁）；wait() 是 Object 的方法，调用会放弃对象锁，进入等待队列，待调用 notify()/notifyAll() 唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态。（注意：notify 的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说 notify 只是让之前调用 wait 的线程有权利重新参与线程的调度）；</p><p>2.sleep() 方法可以在任何地方使用，而 wait() 方法则只能在同步方法或同步块中使用；</p><h2 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h2><p><strong>wait、notify原理</strong></p><p>在前面以经说到对象锁的本质，重量级锁模式时对象头是一个指向互斥量的指针，实际上互斥量就是一个监视器锁（ObjectMonitor）的数据结构，此时对象的hashCode、分代年龄等信息都会保存到对应的ObjectMonitor中，ObjectMonitor还有一些属性如recursion记录本锁被重入的次数，EntrySet记录想获取本锁的线程集合，WaitSet记录等待本锁的线程，TheOwner记录拥有本锁的线程对象。如下：</p><p><img src="https://img2018.cnblogs.com/blog/1743446/201907/1743446-20190729174119167-1716466123.png" alt="img"></p><p>（图片来源于网络）</p><p>几个线程一起竞争对象的锁（EntrySet），只有一个能成功（acquire），成功的线程记录在The Owner中。调用wait、notify运行流程如下：</p><p>​    （1） 现有一个对象o，锁正在被线程 t1 持有，调用wait()方法后，线程 t1 将会被”晾到” (实际上仅仅是记录到) Wait Set 结构中。</p><p>​    （2）然后将会有另一个线程 t2 获取到锁，The Owner记录的变成了 t2 线程。</p><p>​    （3）t2 线程不需要 o的锁时，调用o.notify()/o.notifyAll()方法，对象o就会告诉 Wait Set结构中记录的线程们：你们又可以来竞争我啦，我的锁现在没被人持有。</p><p><strong>简单的说就是：wait是对象通知持有自己锁的线程释放我的锁，notify()/notifyAll()就是对象通知刚刚被自己晾在一边的线程又可以来竞争我的锁了。</strong>我想到了一个比较贴切的比喻：</p><p>​    客人（线程）来拜访主人（对象），必须获得主人的时间权（锁），且主人同时只能接待一人（互斥）。</p><p>​    正在客厅接待一名客人时，因为一些原因主人必须先接待另一位客人，这时主人请当前客人去另一间房里等待，让出自己的时间权（wait方法）</p><p>​    主人在客厅接待另一位客人，接待完毕后，让前一位（也可能有几位）在另一间房等待的客人再来到客厅，继续接待（notify/notifyAll方法）</p><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起并释放锁。当其他线程的运行使得这个条件满足时，其它线程<br>会调用 notify() 。<br>它们都属于 Object 的一部分，而不属于 Thread。只能用在同步方法或者同步控制块中使用，</p><p>notify不会释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"T1 start!"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"T1 end!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"T2 start!"</span>);</span><br><span class="line">                    object.notify();</span><br><span class="line">                    System.out.println(<span class="string">"T2 end!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T1 start!</span><br><span class="line">T2 start!</span><br><span class="line">T2 end!</span><br><span class="line">T1 end!</span><br></pre></td></tr></table></figure><h3 id="和condition的对比"><a href="#和condition的对比" class="headerlink" title="和condition的对比"></a>和condition的对比</h3><ol><li>\1. lock不再用synchronize把同步代码包装起来；</li><li>\2. 阻塞需要另外一个对象condition；</li><li>\3. 同步和唤醒的对象是condition而不是lock，对应的方法是await和signal，而不是wait和notify。</li></ol><h2 id="notify和notifyAll区别，什么时候用，什么时候唤醒一个线程，什么时候唤醒多个线程，举个例子？"><a href="#notify和notifyAll区别，什么时候用，什么时候唤醒一个线程，什么时候唤醒多个线程，举个例子？" class="headerlink" title="notify和notifyAll区别，什么时候用，什么时候唤醒一个线程，什么时候唤醒多个线程，举个例子？"></a>notify和notifyAll区别，什么时候用，什么时候唤醒一个线程，什么时候唤醒多个线程，举个例子？</h2>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程的区别和相关问题</title>
      <link href="/2020/07/03/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/03/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念。</p><p>· 线程：是进程的一个执行单元，是独立运行的基本单位。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>•开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源。线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>· 调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程</p><p>中的线程时，会引起进程切换。</p><p>· 通信方面</p><p>进程有独立的地址空间，线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p><h2 id="进程的内存空间"><a href="#进程的内存空间" class="headerlink" title="进程的内存空间"></a>进程的内存空间</h2><p>内核态内存空间、用户态的堆栈（一般8M，从高地址向低地址增长）、数据段、进程代码段</p><p>进程间通信方式</p><p>进程间通信方式：管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket等</p><ul><li>管道:无名管道, 半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。只能用于父子进程和兄弟进程。</li><li>FIFO：也称为命名管道，去除了管道只能在父子进程中使用的限制。</li><li>消息队列</li></ul><p>1.消息队列存放于内核中，可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</p><p>2.避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</p><p>3.读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</p><ul><li>信号量是一个计数器，用于实现进程间的互斥与同步。信号量基于操作系统的 PV 操作。每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li><li>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li><li>套接字：与其它通信机制不同的是，它可用于不同机器间的进程通信。</li></ul><h2 id="进程同步方式？"><a href="#进程同步方式？" class="headerlink" title="进程同步方式？"></a>进程同步方式？</h2><p>1.临界区</p><p>对临界资源进行访问的那段代码称为临界区。</p><p>2.同步与互斥</p><p>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</p><p>互斥：多个进程在同一时刻只有一个进程能进入临界区。</p><p>3.信号量：</p><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><p>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</p><p>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</p><h2 id="线程共享和线程私有的"><a href="#线程共享和线程私有的" class="headerlink" title="线程共享和线程私有的"></a>线程共享和线程私有的</h2><p>线程共享的有：进程代码段、进程共有数据等</p><p>线程私有的：线程ID、寄存器的值、线程的栈</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>就绪，运行，阻塞。</p><p>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。运行缺少资源会变为阻塞。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>B树和B+树的区别?</title>
      <link href="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><img src="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" class><p><img src="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201103195345798.png" alt="image-20201103195345798"></p><p>B Tree 指的是 Balance Tree，也就是平衡树，相当于是一棵多叉查找树，对于一棵 m 阶的 B 树具有如下特性：</p><p>1、根节点至少有两个孩子。</p><p>2、每个中间节点都包含 k - 1 个元素和 k 个孩子，其中 ceil(m/2) &lt;= k &lt;= m。</p><p>3、每个节点中的元素从小到大排列，节点当中的 k - 1 个元素正好是 k 个孩子包含的元素的值域划分。</p><p>4、每一个叶子节点都包含 k - 1 个元素，其中 ceil(m/2) &lt;= k &lt;= m。</p><p>5、所有的叶子节点都位于同一侧。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><img src="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" class><p><img src="/2020/07/03/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201103195404475.png" alt="image-20201103195404475"></p><p>对于一棵 m 阶的 B+ 树具有如下特性：</p><p>1、根节点至少有两个孩子。</p><p>2、每个中间节点都包含 k  个元素和 k 个孩子，其中 ceil(m/2) &lt;= k &lt;= m。</p><p>3、一个节点中的 key 从左到右非递减排列</p><p>4、所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树剖析</title>
      <link href="/2020/07/03/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%96%E6%9E%90/"/>
      <url>/2020/07/03/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>红黑树是自平衡的二叉查找树</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03bae101f8c99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>性质1：每个节点要么是红色，要么是黑色。</p><p>性质2：根节点永远是黑色的。</p><p>性质3：所有的叶子节点都是空节点（即null），并且是黑色的。</p><p>性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点。）</p><p>性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>红黑树的插入主要分两步：</p><ul><li><p>首先和二叉查找树的插入一样，查找、插入</p></li><li><p>然后调整结构，保证满足红黑树状态</p><ul><li><p>对结点进行重新着色</p></li><li><p>以及对树进行相关的旋转操作</p></li></ul></li></ul><p>一般情况下，红黑树中新插入的节点都是红色的。因为我们从性质5中知道，当前红黑树中从根节点到每个叶子节点的黑色节点数量是一样的，此时假如新的黑色节点的话，必然破坏规则，但加入红色节点却不一定，除非其父节点就是红色节点，因此加入红色节点，破坏规则的可能性小一些。</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>LL</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03baf6b875784?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>LR（插入节点的父节点是左节点，插入节点是右节点）</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03bbc0efb78e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>RR</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03be147552958?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>RL</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f03bd41c1d7d63?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>  IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查.<br>  ngnix中,用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器.<br>  java中TreeMap，jdk1.8的hashmap的实现.</p><h2 id="与平衡树的区别"><a href="#与平衡树的区别" class="headerlink" title="与平衡树的区别"></a>与平衡树的区别</h2><p>1.红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。红黑树放弃了追求完全平衡，追求大致平衡</p><p>2.平衡二叉树,每次插入新节点之后需要旋转的次数不能预知。</p><h2 id="平衡树的概念"><a href="#平衡树的概念" class="headerlink" title="平衡树的概念"></a>平衡树的概念</h2><p>平衡二叉树必须是排序二叉树</p><p>左子树和右子树的深度之差的绝对值不超过1。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>平台无关性、机器码、字节码、与C++区别</title>
      <link href="/2020/07/03/%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2020/07/03/%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="无关性"><a href="#无关性" class="headerlink" title="无关性:"></a>无关性:</h2><p><strong>在一个计算机上编译得到的字节码文件（就是.class文件），可以复制到任何一个安装了Java运行环境的计算机上直接运行。然后字节码文件由虚拟机负责解释执行，即Java虚拟机将字节码翻译成本地计算机的机器码，然后将机器码交给本地的操作系统运行。</strong></p><p> C/C++程序是依赖平台的：C/C++源程序所在的特定平台对其源文件进行编译、链接，生成机器指令，即<strong>根据当前平台的机器指令生成可执行文件</strong> 不能保证在所有平台上都能正确的运行，其原因是不同平台可能具有不同的机器指令</p><p>Java在计算机的操作系统上又提供了一个Java运行环境——JRE,只要平台提供了Java运行环境，Java编写的软件就可以在其上运行。</p><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h2><p>机器码是电脑的CPU可直接解读的数据，通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。</p><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>字节码（Bytecode）是一种包含执行程序的<strong>二进制文件</strong>。<strong>字节码是一种中间码</strong>，在运行时通过JVM（JAVA虚拟机）做一次转换生成机器指令，因此能够更好的跨平台运行。</p><h2 id="与C-区别"><a href="#与C-区别" class="headerlink" title="与C++区别"></a>与C++区别</h2><p>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持<br>面向过程。<br>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。<br>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。<br>Java 支持自动垃圾回收，而 C++ 需要手动回收。<br>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编代码通常意味着机器的母语(所谓的机器语言)的人类可读形式</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nio、Bio、Aio</title>
      <link href="/2020/07/03/Nio%E3%80%81Bio%E3%80%81Aio/"/>
      <url>/2020/07/03/Nio%E3%80%81Bio%E3%80%81Aio/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>BIO （Blocking I/O）：同步阻塞I/O模式。</strong></p><p><strong>NIO （New I/O）：同步非阻塞模式。</strong></p><p><strong>AIO （Asynchronous I/O）：异步非阻塞I/O模型。</strong></p><p><strong>同步</strong></p><p>同步就是发起一个调用后，<strong>被调用者</strong>未处理完请求之前，调用不返回。</p><p>通俗的例子描述同步就像:</p><blockquote><p>你打电话问书店老板有没有《葵花宝典》这本书的时候，如果是同步机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。</p></blockquote><p><strong>异步</strong></p><p>异步就是发起一个调用后，立刻得到<strong>被调用者</strong>的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常<strong>依靠事件，回调</strong>等机制来通知调用者其返回结果。</p><p>通俗的例子描述异步就像:</p><blockquote><p>而异步机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调</p></blockquote><p>此处参照知乎上关于此问题的回答：<a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">www.zhihu.com/question/19…</a></p><p>再次总结一下同步与异步：</p><blockquote><p>同步与异步最大的区别就是<strong>被调用方</strong>的<strong>执行方式</strong>和<strong>返回时机</strong>，同步指的是<strong>被调用方</strong>做完事情之后再返回，异步指的是<strong>被调用方</strong>先返回，然后再做事情，做完之后再想办法通知调用方</p></blockquote><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p><strong>阻塞</strong></p><p>阻塞就是发起一个请求，<strong>调用者</strong>一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</p><p><strong>非阻塞</strong></p><p>非阻塞就是发起一个请求，<strong>调用者</strong>不用一直等着结果返回，可以先去干其他事情。</p><p>还是上面买书的例子:</p><blockquote><p>你打电话问书店老板有没有《葵花宝典》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</p></blockquote><h2 id="同步、异步和阻塞、非阻塞的区别"><a href="#同步、异步和阻塞、非阻塞的区别" class="headerlink" title="同步、异步和阻塞、非阻塞的区别"></a>同步、异步和阻塞、非阻塞的区别</h2><p>阻塞和同步不是一回事，同步，异步与阻塞，非阻塞针对的对象是不一样的，<strong>阻塞,非阻塞是说的调用者，同步，异步说的是被调用者</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Bio</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class test implements Runnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     test t&#x3D;new test();</span><br><span class="line">     Thread t1&#x3D;new Thread(t);</span><br><span class="line">     t1.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Socket client&#x3D;new Socket(InetAddress.getLocalHost(),8888);</span><br><span class="line">            BufferedReader bufferedReader &#x3D; new BufferedReader</span><br><span class="line">                    (new InputStreamReader</span><br><span class="line">                            (client.getInputStream()));</span><br><span class="line">            System.out.println(&quot;值: &quot;+bufferedReader.readLine());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerSocket serverSocket&#x3D;new ServerSocket(8888);</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                Socket socket&#x3D;serverSocket.accept();</span><br><span class="line">                try (PrintWriter out &#x3D; new PrintWriter(socket.getOutputStream());) &#123;</span><br><span class="line">                    out.println(&quot;Hello world!&quot;);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>服务器端启动 ServerSocket，端口 0 表示自动绑定一个空闲端口。</p></li><li><p>调用 accept 方法，阻塞等待客户端连接。</p></li><li><p>利用 Socket 模拟了一个简单的客户端，只进行连接、读取、打印。</p></li><li><p>当连接建立后，启动一个单独线程负责回复客户端请求。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/14/1697c8d55677ce94?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li></ul><p>Nio</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class NioExample extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try (Selector selector &#x3D; Selector.open();</span><br><span class="line">             ServerSocketChannel serverSocket &#x3D; ServerSocketChannel.open();)</span><br><span class="line">        &#123;&#x2F;&#x2F; 创建 Selector 和 Channel</span><br><span class="line">            serverSocket.bind(new InetSocketAddress(InetAddress.getLocalHost(), 8888));</span><br><span class="line">            serverSocket.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F; 注册到 Selector，并说明关注点</span><br><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                selector.select();&#x2F;&#x2F; 阻塞等待就绪的 Channel，这是关键点之一</span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys &#x3D; selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter &#x3D; selectedKeys.iterator();</span><br><span class="line">                while (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key &#x3D; iter.next();</span><br><span class="line">                    &#x2F;&#x2F; 生产系统中一般会额外进行就绪状态检查</span><br><span class="line">                    sayHelloWorld((ServerSocketChannel) key.channel());</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sayHelloWorld(ServerSocketChannel server) throws IOException &#123;</span><br><span class="line">        try (SocketChannel client &#x3D; server.accept();) &#123;</span><br><span class="line">            client.write(Charset.defaultCharset().encode(&quot;Hello world!&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 省略了与前面类似的 main</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        NioExample server &#x3D; new NioExample();</span><br><span class="line">        server.start();</span><br><span class="line">        try (Socket client &#x3D; new Socket(InetAddress.getLocalHost(), 8888)) &#123;</span><br><span class="line">            BufferedReader bufferedReader &#x3D; new BufferedReader(new InputStreamReader(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，通过 Selector.open() 创建一个 Selector，作为类似调度员的角色。</p><p>然后，创建一个 ServerSocketChannel，并且向 Selector 注册，通过指定 SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。注意：为什么我们要明确配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会抛出 IllegalBlockingModeException 异常。</p><p>Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒。</p><p>在 sayHelloWorld 方法中，通过 SocketChannel 和 Buffer 进行数据操作，在本例中是发送了一段字符串。</p><p>可以看到，在前面两个样例中，IO 都是同步阻塞模式，所以需要多线程以实现多任务处理。而 NIO 则是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。下面这张图对这种实现思路进行了形象地说明</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/14/1697c8d556639922?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><a href="https://juejin.im/post/5c8aea1df265da2de33f6a09" target="_blank" rel="noopener">https://juejin.im/post/5c8aea1df265da2de33f6a09</a></p><p><a href="https://juejin.im/post/5d19820c6fb9a07ea42094e2#heading-4" target="_blank" rel="noopener">https://juejin.im/post/5d19820c6fb9a07ea42094e2#heading-4</a></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>值传递和引用传递</title>
      <link href="/2020/07/03/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
      <url>/2020/07/03/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>值传递：</strong></p><p>方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，此时内存中存在两个相等的基本类型，即实际参数和形式参数<strong>，</strong>后面方法中的操作都是对形参这个值的修改，不影响实际参数的值。</p><p><strong>引用传递：</strong></p><p>也称为传地址。方法调用时，实际参数的引用地址，被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址；<br>在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象。</p><h3 id="Java内部"><a href="#Java内部" class="headerlink" title="Java内部"></a>Java内部</h3><p><code>java只有值传递</code>，</p><p>Java参数，不管是原始类型还是引用类型，传递的都是副本</p><ul><li><p><code>如果参数类型是原始类型</code>，那么传过来的就是这个参数的一个副本，<code>也就是这个原始参数的值</code>，这个跟之前所谈的传值是一样的。<code>如果在函数中改变了副本的 值不会改变原始的值</code>。</p></li><li><pre><code>如果参数类型是引用类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">，那么传过来的就是这个引用参数的副本，</span><br></pre></td></tr></table></figure>这个副本存放的是参数的地址</code></pre><ul><li>如果在函数中没有改变这个副本的地址，而<code>是改变了地址中的 值，那么在函数内的改变会影响到传入的参数</code>。</li><li>如果在函数中<code>改变了副本的地址</code>，如new一个，那么副本就指向了一个新的地址，此时传入的参数还是指向原来的 地址，所以<code>不会改变参数的值</code>。</li></ul></li></ul><h3 id="Java中基本数据类型和包装类型的区别"><a href="#Java中基本数据类型和包装类型的区别" class="headerlink" title="Java中基本数据类型和包装类型的区别"></a>Java中基本数据类型和包装类型的区别</h3><p>1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址；基本类型不是<br>2、包装类型是引用的传递；基本类型是值的传递<br>3、声明方式不同：<br>        基本数据类型不需要new关键字；<br>        包装类型需要new在堆内存中进行new来分配内存空间<br>4、存储位置不同：<br>        基本数据类型直接将值保存在值栈中；<br>        包装类型是把对象放在堆中，然后通过对象的引用来调用他们 </p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="/2020/07/03/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2020/07/03/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="cloneable"><a href="#cloneable" class="headerlink" title="cloneable"></a>cloneable</h2><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类<br>实例的 clone() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CloneExample &#123;</span><br><span class="line">  private int a;</span><br><span class="line">  private int b;</span><br><span class="line">&#125;</span><br><span class="line">CloneExample e1 &#x3D; new CloneExample();</span><br><span class="line">&#x2F;&#x2F; CloneExample e2 &#x3D; e1.clone(); &#x2F;&#x2F; &#39;clone()&#39; has protected access in &#39;java.lang.Object&#39;</span><br></pre></td></tr></table></figure><p>正确：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CloneExample implements Cloneable &#123;</span><br><span class="line">  private int a;</span><br><span class="line">  private int b;</span><br><span class="line">  @Override</span><br><span class="line">  public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">  return super.clone();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/14/6610661def48e619bd53667d83d96094?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="/clone-qian.png"></p><p>我们举个clone产生的浅拷贝的例子，我们定义一个对象中的对象，然后尝试拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Address implements Cloneable&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不是好的方式</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class CustUser implements Cloneable&#123;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line">    private Address address;</span><br><span class="line">    private String[] cars;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException&#123;</span><br><span class="line">            return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了CustUser和Address。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void testShallowCopy() throws CloneNotSupportedException &#123;</span><br><span class="line">       Address address&#x3D; new Address();</span><br><span class="line">       address.setName(&quot;北京天安门&quot;);</span><br><span class="line">       CustUser custUser &#x3D; new CustUser();</span><br><span class="line">       custUser.setAddress(address);</span><br><span class="line">       custUser.setLastName(&quot;李&quot;);</span><br><span class="line">       custUser.setFirstName(&quot;雷&quot;);</span><br><span class="line">       String[] cars &#x3D; new String[]&#123;&quot;别克&quot;,&quot;路虎&quot;&#125;;</span><br><span class="line">       custUser.setCars(cars);</span><br><span class="line"></span><br><span class="line">       CustUser custUserCopy&#x3D;(CustUser) custUser.clone();</span><br><span class="line">       custUserCopy.setFirstName(&quot;梅梅&quot;);</span><br><span class="line">       custUserCopy.setLastName(&quot;韩&quot;);</span><br><span class="line">       custUserCopy.getAddress().setName(&quot;北京颐和园&quot;);</span><br><span class="line">       custUserCopy.getCars()[0]&#x3D;&quot;奥迪&quot;;</span><br><span class="line"></span><br><span class="line">       log.info(&quot;&#123;&#125;&quot;,custUser);</span><br><span class="line">       log.info(&quot;&#123;&#125;&quot;,custUserCopy);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>浅拷贝我们只调用了CustUser的clone方法。看下输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CustUser(firstName&#x3D;雷, lastName&#x3D;李, address&#x3D;Address(name&#x3D;北京颐和园), cars&#x3D;[奥迪, 路虎])</span><br><span class="line"></span><br><span class="line">CustUser(firstName&#x3D;梅梅, lastName&#x3D;韩, address&#x3D;Address(name&#x3D;北京颐和园), cars&#x3D;[奥迪, 路虎])</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们可以看到拷贝之后的Address变化会影响到被拷贝的对象。</p><p>上面的例子我们还要关注两个点：第一点String是不可变的。不管是拷贝还是赋值，String都是不可变的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public  class Singleton implements  Cloneable</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int[] arr &#x3D;new int[1];</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Singleton s&#x3D; (Singleton)super.clone();</span><br><span class="line">        s.arr&#x3D;this.arr.clone();</span><br><span class="line">        return s;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Singleton s1&#x3D;new Singleton();</span><br><span class="line">        Singleton s2&#x3D;(Singleton) s1.clone();</span><br><span class="line">        s1.x&#x3D;1;</span><br><span class="line">        s2.x&#x3D;2;</span><br><span class="line">        s1.arr[0]&#x3D;1;</span><br><span class="line">        s2.arr[0]&#x3D;3;</span><br><span class="line">        System.out.println(s1.x+&quot; &quot;+s2.x);</span><br><span class="line">        System.out.println(s1.arr[0]+&quot; &quot;+s2.arr[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/14/5c30e76c9d63860ac430dfd2ddfbdd4f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="/clone-深.png"></p><p>用序列化进行深拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369285298572941L</span>;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 邮件</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDesc personDesc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 将该对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。所以利用这个特性可以实现对象的深拷贝</span></span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 将流序列化成对象</span></span><br><span class="line">            ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">            person = (Person) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDesc.setDesc(desc);</span><br><span class="line">    &#125;</span><br><span class="line">  ...省略...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDesc</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">872390113109L</span>; </span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化一个对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"平头哥"</span>,<span class="number">20</span>,<span class="string">"123456@qq.com"</span>,<span class="string">"我的公众号是：平头哥的技术博文"</span>);</span><br><span class="line">        <span class="comment">// 复制对象</span></span><br><span class="line">        Person person1 = (Person) person.clone();</span><br><span class="line">        <span class="comment">// 改变 person1 的属性值</span></span><br><span class="line">        person1.setName(<span class="string">"我是平头哥的克隆对象"</span>);</span><br><span class="line">        <span class="comment">// 修改 person age 的值</span></span><br><span class="line">        person1.setAge(<span class="number">22</span>);</span><br><span class="line">        person1.setDesc(<span class="string">"我已经关注了平头哥的技术博文公众号"</span>);</span><br><span class="line">        System.out.println(<span class="string">"person对象："</span>+person);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"person1对象："</span>+person1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个对象多少个字节</title>
      <link href="/2020/07/03/%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82/"/>
      <url>/2020/07/03/%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AAAAA &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BBBBB &#123;</span><br><span class="line">  int a &#x3D; 1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CCCCC &#123;</span><br><span class="line">  long a &#x3D; 1l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DDDDD &#123;</span><br><span class="line">   String s &#x3D; &quot;Hello&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针压缩：</p><ul><li><p>A对象只包含一个对象头，大小占12字节，不是8的倍数，需要4字节进行填充，一共占16字节</p></li><li><p>B对象包含一个对象头和int类型，12+4=16，正好是8的倍数，不需要填充。</p></li><li><p>C对象包含一个对象头和long类型，12+8=20，不是8的倍数，需要4个字节进行填充，占24字节</p></li><li><p>D对象包含一个对象头和引用类型，12+4=16，正好是8的倍数，不需要填充</p><p><a href="https://blog.csdn.net/qlmmys/article/details/53213857" target="_blank" rel="noopener">https://blog.csdn.net/qlmmys/article/details/53213857</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反射机制及其优缺点</title>
      <link href="/2020/07/02/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>/2020/07/02/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个属性和方法，这种功能称为java语言的反射机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内</span><br><span class="line">容保存着 Class 对象。也可以使用Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</span><br></pre></td></tr></table></figure><p>类对象 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：<br><strong>Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</strong><br><strong>Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</strong><br><strong>Constructor ：可以用 Constructor 创建新的对象。</strong></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</p><p>方便性: 可以写在配置文件里，直接修改配置文件就行了</p><p>spring.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class&#x3D;reflection.Service1</span><br><span class="line">method&#x3D;doService1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line"> </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line"> </span><br><span class="line">    @SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;从spring.txt中获取类名称和方法名称</span><br><span class="line">        File springConfigFile &#x3D; new File(&quot;e:\\project\\j2se\\src\\spring.txt&quot;);</span><br><span class="line">        Properties springConfig&#x3D; new Properties();</span><br><span class="line">        springConfig.load(new FileInputStream(springConfigFile));</span><br><span class="line">        String className &#x3D; (String) springConfig.get(&quot;class&quot;);</span><br><span class="line">        String methodName &#x3D; (String) springConfig.get(&quot;method&quot;);</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;根据类名称获取类对象</span><br><span class="line">        Class clazz &#x3D; Class.forName(className);</span><br><span class="line">        &#x2F;&#x2F;根据方法名称，获取方法对象</span><br><span class="line">        Method m &#x3D; clazz.getMethod(methodName);</span><br><span class="line">        &#x2F;&#x2F;获取构造器</span><br><span class="line">        Constructor c &#x3D; clazz.getConstructor();</span><br><span class="line">        &#x2F;&#x2F;根据构造器，实例化出对象</span><br><span class="line">        Object service &#x3D; c.newInstance();</span><br><span class="line">        &#x2F;&#x2F;调用对象的指定方法</span><br><span class="line">        m.invoke(service);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些<br>非反射操作低得多。</p><p>内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使<br>用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。</p><h3 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflection</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            String className = <span class="string">"charactor.Hero"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class pClass1=Class.forName(className);</span><br><span class="line">                Class pClass2=Hero<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                Class pClass3=<span class="keyword">new</span> Hero().getClass();</span><br><span class="line">                System.out.println(pClass1==pClass2);</span><br><span class="line">                System.out.println(pClass1==pClass3);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import charactor.Hero;</span><br><span class="line">public class TestReflection &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;传统的使用new的方式创建对象</span><br><span class="line">        Hero h1 &#x3D;new Hero();</span><br><span class="line">        h1.name &#x3D; &quot;teemo&quot;;</span><br><span class="line">        System.out.println(h1);</span><br><span class="line">          </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;使用反射的方式创建对象</span><br><span class="line">            String className &#x3D; &quot;charactor.Hero&quot;;</span><br><span class="line">            &#x2F;&#x2F;类对象</span><br><span class="line">            Class pClass&#x3D;Class.forName(className);</span><br><span class="line">            &#x2F;&#x2F;构造器</span><br><span class="line">            Constructor c&#x3D; pClass.getConstructor();</span><br><span class="line">            &#x2F;&#x2F;通过构造器实例化</span><br><span class="line">            Hero h2&#x3D; (Hero) c.newInstance();</span><br><span class="line">            h2.name&#x3D;&quot;gareen&quot;;</span><br><span class="line">            System.out.println(h2);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>对于private修饰的成员，需要使用setAccessible(true)才能访问和修改。不在此知识点讨论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line">  </span><br><span class="line">public class TestReflection &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            Hero h &#x3D;new Hero();</span><br><span class="line">            &#x2F;&#x2F;使用传统方式修改name的值为garen</span><br><span class="line">            h.name &#x3D; &quot;garen&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;获取类Hero的名字叫做name的字段</span><br><span class="line">                Field f1&#x3D; h.getClass().getDeclaredField(&quot;name&quot;);</span><br><span class="line">                &#x2F;&#x2F;修改这个字段的值</span><br><span class="line">                f1.set(h, &quot;teemo&quot;);</span><br><span class="line">                &#x2F;&#x2F;打印被修改后的值</span><br><span class="line">                System.out.println(h.name);</span><br><span class="line">                 </span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getField和getDeclaredField的区别</span><br><span class="line">这两个方法都是用于获取字段</span><br><span class="line">getField 只能获取public的，包括从父类继承来的字段。</span><br><span class="line">getDeclaredField 可以获取本类所有的字段，包括private的，但是不能获取继承来的字段。 (注： 这里只能获取到private的字段，但并不能访问该private字段的值,除非加上setAccessible(true))</span><br></pre></td></tr></table></figure><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public float hp;</span><br><span class="line">    public int damage;</span><br><span class="line">    public int id;</span><br><span class="line">     </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Hero()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    public Hero(String string) &#123;</span><br><span class="line">        name &#x3D;string;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hero [name&#x3D;&quot; + name + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isDead() &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public void attackHero(Hero h2) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line">import charactor.Hero;</span><br><span class="line"> </span><br><span class="line">public class TestReflection &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h &#x3D; new Hero();</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取这个名字叫做setName，参数类型是String的方法</span><br><span class="line">            Method m &#x3D; h.getClass().getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">            &#x2F;&#x2F; 对h对象，调用这个方法</span><br><span class="line">            m.invoke(h, &quot;盖伦&quot;);</span><br><span class="line">            &#x2F;&#x2F; 使用传统的方式，调用getName方法</span><br><span class="line">            System.out.println(h.getName());</span><br><span class="line"> </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>==、equals、hashcode</title>
      <link href="/2020/07/02/%E3%80%81equals%E3%80%81hashcode/"/>
      <url>/2020/07/02/%E3%80%81equals%E3%80%81hashcode/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。<br>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x &#x3D; new Integer(1);</span><br><span class="line">Integer y &#x3D; new Integer(1);</span><br><span class="line">System.out.println(x.equals(y)); &#x2F;&#x2F; true</span><br><span class="line">System.out.println(x &#x3D;&#x3D; y); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><h2 id="为什么重写equals需要重写hashcode？"><a href="#为什么重写equals需要重写hashcode？" class="headerlink" title="为什么重写equals需要重写hashcode？"></a>为什么重写equals需要重写hashcode？</h2><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，如果不重写hashcode的话，会导致等价的两个对象散列值不相同 (由于默认的hashcode方法是根据对象的内存地址经哈希算法得来的，故两者的hashcode不一定相等) 。因此在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何排查内存泄漏</title>
      <link href="/2020/07/02/%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>/2020/07/02/%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>内存泄漏：你用new申请了一块内存，后来很长时间都不再使用了（按理应该释放），但是因为一直被某个或某些实例所持有导致 GC 不能回收，也就是该被释放的对象没有释放。</p><p>各种连接，threadlocal,单例模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">单例模式。不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露，考虑下面的例子：</span><br><span class="line">　　class A&#123;</span><br><span class="line"></span><br><span class="line">　　public A()&#123;</span><br><span class="line"></span><br><span class="line">　　  B.getInstance().setA(this);</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　....</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#x2F;&#x2F;B类采用单例模式</span><br><span class="line"></span><br><span class="line">　　class B&#123;</span><br><span class="line"></span><br><span class="line">　　private A a;</span><br><span class="line"></span><br><span class="line">　　private static B instance&#x3D;new B();</span><br><span class="line"></span><br><span class="line">　　public B()&#123;&#125;</span><br><span class="line"></span><br><span class="line">　　public static B getInstance()&#123;</span><br><span class="line"></span><br><span class="line">　　return instance;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　public void setA(A a)&#123;</span><br><span class="line"></span><br><span class="line">　　this.a&#x3D;a;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#x2F;&#x2F;getter...</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>首先通过“虚拟机进程状况工具：jps”找出正在运行的虚拟机进程，最主要是找出这个进程在本地虚拟机的唯一ID（LVMID，Local Virtual Machine Identifier），因为在后面的排查过程中都是需要这个LVMID来确定要监控的是哪一个虚拟机进程。<br>同时，对于本地虚拟机进程来说，LVMID与操作系统的进程ID（PID，Process Identifier）是一致的，使用Windows的任务管理器或Unix的ps命令也可以查询到虚拟机进程的LVMID。<br>jps命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure><p>使用命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用jps：jps -l</span><br><span class="line">使用ps：ps aux | grep tomat</span><br></pre></td></tr></table></figure><p>找到你需要监控的ID（假设为20954），再利用“虚拟机统计信息监视工具：jstat”监视虚拟机各种运行状态信息。<br>jstat命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [ option vmid [interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure><p>使用命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 20954 1000</span><br></pre></td></tr></table></figure><p>意思是每1000毫秒查询一次，一直查。gcutil的意思是已使用空间站总空间的百分比。<br>结果如下图：</p><p>jstat执行结果<br>查询结果表明：这台服务器的新生代Eden区（E，表示Eden）使用了28.30%（最后）的空间，两个Survivor区（S0、S1，表示Survivor0、Survivor1）分别是0和8.93%，老年代（O，表示Old）使用了87.33%。程序运行以来共发生Minor GC（YGC，表示Young GC）101次，总耗时1.961秒，发生Full GC（FGC，表示Full GC）7次，Full GC总耗时3.022秒，总的耗时（GCT，表示GC Time）为4.983秒。</p><p>2.2 找出导致频繁Full GC的原因<br>分析方法通常有两种：<br>1）把堆dump下来再用MAT等工具进行分析，但dump堆要花较长的时间，并且文件巨大，再从服务器上拖回本地导入工具，这个过程有些折腾，不到万不得已最好别这么干。<br>2）更轻量级的在线分析，使用“Java内存影像工具：jmap”生成堆转储快照（一般称为headdump或dump文件）。<br>jmap命令格式：<br>jmap [ option ] vmid<br>使用命令如下：<br>jmap -histo:live 20954<br>查看存活的对象情况，如下图所示：</p><p>存活对象<br>按照一位IT友的说法，数据不正常，十有八九就是泄露的。在我这个图上对象还是挺正常的。</p><p>我在网上找了一位博友的不正常数据，如下：</p><p>image.png<br>可以看出HashTable中的元素有5000多万，占用内存大约1.5G的样子。这肯定不正常。</p><p>2.3 定位到代码<br>定位带代码，有很多种方法，比如前面提到的通过MAT查看Histogram即可找出是哪块代码。——我以前是使用这个方法。 也可以使用BTrace，我没有使用过。</p><p>举例：</p><p>一台生产环境机器每次运行几天之后就会莫名其妙的宕机，分析日志之后发现在tomcat刚启动的时候内存占用比较少，但是运行个几天之后内存占用越来越大，通过jmap命令可以查询到一些大对象引用没有被及时GC，这里就要求解决内存泄露的问题。</p><p>Java的内存泄露多半是因为对象存在无效的引用，对象得不到释放，如果发现Java应用程序占用的内存出现了泄露的迹象，那么我们一般采用下面的步骤分析：</p><ol><li>用工具生成java应用程序的heap dump（如jmap）</li><li>使用Java heap分析工具（如MAT），找出内存占用超出预期的嫌疑对象</li><li>根据情况，分析嫌疑对象和其他对象的引用关系。</li><li>分析程序的源代码，找出嫌疑对象数量过多的原因。</li></ol><p>以下一步步的按照项目实例来操作，去解决内存泄露的问题。</p><p>1.登录linux服务器，获取tomcat的pid，命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160907153739493" alt="img"></p><p>2.利用jmap初步分析内存映射，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live 3514 | head -7</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160907162814112" alt="img"></p><p>第2行是我们业务系统的对象，通过这个对象的引用可以初步分析出到底是哪里出现了引用未被垃圾回收收集，通知开发人员优化相关代码。</p><p>3.如果上面一步还无法定位到关键信息，那么需要拿到heap dump，生成离线文件，做进一步分析，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format&#x3D;b,file&#x3D;heap.hprof 3514</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160907162941232" alt="img"></p><p>4.拿到heap dump文件，利用eclipse插件MAT来分析heap profile。</p><p>a. 安装MAT插件</p><p>b. 在eclipse里切换到Memory Analysis视图</p><p>c. 用MAT打开heap profile文件。</p><p><img src="https://img-blog.csdn.net/20160907163118749" alt="img"></p><p>直接看到下面Action窗口，有4种Action来分析heap profile，介绍其中最常用的2种:</p><p>- <strong>Histogram</strong>：这个使用的最多，跟上面的jmap -histo 命令类似，只是在MAT里面可以用GUI来展示应用系统各个类产生的实例。</p><p><img src="https://img-blog.csdn.net/20160907163309052" alt="img"></p><p>Shllow Heap排序后发现 Cms_Organization 这个类占用的内存比较多（没有得到及时GC），查看引用：</p><p><img src="https://img-blog.csdn.net/20160907163424065" alt="img"></p><p>分析引用栈，找到无效引用，打开源码：</p><p><img src="https://img-blog.csdn.net/20160907163540520" alt="img"></p><p>有问题的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class RefreshCmsOrganizationStruts implements Runnable&#123;</span><br><span class="line"> </span><br><span class="line">private final static Logger logger &#x3D; Logger.getLogger(RefreshCmsOrganizationStruts.class);</span><br><span class="line"></span><br><span class="line">private List&lt;Cms_Organization&gt; organizations;</span><br><span class="line"> </span><br><span class="line">private OrganizationDao organizationDao &#x3D; (OrganizationDao) WebContentBean</span><br><span class="line">.getInstance().getBean(&quot;organizationDao&quot;);</span><br><span class="line">public RefreshCmsOrganizationStruts(List&lt;Cms_Organization&gt; organizations) &#123;</span><br><span class="line">this.organizations &#x3D; organizations;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void run() &#123;</span><br><span class="line">Iterator&lt;Cms_Organization&gt; iter &#x3D; organizations.iterator();</span><br><span class="line">Cms_Organization organization &#x3D; null;</span><br><span class="line">while (iter.hasNext()) &#123;</span><br><span class="line">organization &#x3D; iter.next();</span><br><span class="line">synchronized (organization) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">organizationDao.refreshCmsOrganizationStrutsInfo(organization.getOrgaId());</span><br><span class="line">organizationDao.refreshCmsOrganizationResourceInfo(organization.getOrgaId());</span><br><span class="line">organizationDao.sleep();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">logger.debug(&quot;RefreshCmsOrganizationStruts organization &#x3D; &quot; + organization.getOrgaId(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析源码，定时任务定时调用，每次调用生成10个线程处理，而它又使用了非线程安全的List对象，导致List对象无法被GC收集，所以这里将List替换为CopyOnWriteArrayList 。</p><p><strong>Dominator Tree</strong>：这个使用的也比较多，显示大对象的占用率</p><p><img src="https://img-blog.csdn.net/20160907164212086" alt="img"></p><p>同样的打开源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class CategoryCacheJob extends QuartzJobBean implements StatefulJob &#123;</span><br><span class="line"></span><br><span class="line">private static final Logger LOGGER &#x3D; Logger.getLogger(CategoryCacheJob.class);</span><br><span class="line"></span><br><span class="line">public static Map&lt;String,List&lt;Cms_Category&gt;&gt; cacheMap &#x3D; new java.util.HashMap&lt;String,List&lt;Cms_Category&gt;&gt;();</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 缓存编目树开始 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">MongoBaseDao mongoBaseDao &#x3D; (MongoBaseDao) BeanLocator.getInstance().getBean(&quot;mongoBaseDao&quot;);</span><br><span class="line">MongoOperations mongoOperations &#x3D; mongoBaseDao.getMongoOperations();</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">LOGGER.info(&quot;1.缓存基础教育编目树&quot;);</span><br><span class="line">Query query &#x3D; Query.query(Criteria.where(&quot;isDel&quot;).is(&quot;0&quot;).and(&quot;categoryType&quot;).is(&quot;F&quot;));</span><br><span class="line">query.sort().on(&quot;orderNo&quot;, Order.ASCENDING);</span><br><span class="line">List&lt;Cms_Category&gt; list &#x3D; mongoOperations.find(query, Cms_Category.class);</span><br><span class="line">String key &#x3D; query.toString().replaceAll(&quot;\\&#123;|\\&#125;|\\p&#123;Cntrl&#125;|\\p&#123;Space&#125;&quot;, &quot;&quot;);</span><br><span class="line">key +&#x3D; &quot;_CategoryCacheJob&quot;;</span><br><span class="line">cacheMap.put(key, list);</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;LOGGER.info(&quot;2.缓存职业教育编目树&quot;);</span><br><span class="line">Query query2 &#x3D; Query.query(Criteria.where(&quot;isDel&quot;).is(&quot;0&quot;).and(&quot;categoryType&quot;).in(&quot;JMP&quot;,&quot;JHP&quot;));</span><br><span class="line">query2.sort().on(&quot;orderNo&quot;, Order.ASCENDING);</span><br><span class="line">List&lt;Cms_Category&gt; list2 &#x3D; mongoOperations.find(query2, Cms_Category.class);</span><br><span class="line">String key2 &#x3D; query2.toString().replaceAll(&quot;\\&#123;|\\&#125;|\\p&#123;Cntrl&#125;|\\p&#123;Space&#125;&quot;, &quot;&quot;);</span><br><span class="line">key2 +&#x3D; &quot;_CategoryCacheJob&quot;;</span><br><span class="line">cacheMap.put(key2, list2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;LOGGER.info(&quot;3.缓存专题教育编目树&quot;);</span><br><span class="line">Query query3 &#x3D; Query.query(Criteria.where(&quot;isDel&quot;).is(&quot;0&quot;).and(&quot;categoryType&quot;).is(&quot;JS&quot;));</span><br><span class="line">query3.sort().on(&quot;orderNo&quot;, Order.ASCENDING);</span><br><span class="line">List&lt;Cms_Category&gt; list3 &#x3D; mongoOperations.find(query3, Cms_Category.class);</span><br><span class="line">String key3 &#x3D; query3.toString().replaceAll(&quot;\\&#123;|\\&#125;|\\p&#123;Cntrl&#125;|\\p&#123;Space&#125;&quot;, &quot;&quot;);</span><br><span class="line">key3 +&#x3D; &quot;_CategoryCacheJob&quot;;</span><br><span class="line">cacheMap.put(key3, list3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 缓存编目树结束 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125; catch(Exception ex) &#123;</span><br><span class="line">LOGGER.error(ex.getMessage(), ex);</span><br><span class="line">LOGGER.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 缓存编目树出错 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存泄漏的原因分析，总结出来只有一条：<strong>存在无效的引用</strong></p><p><a href="https://blog.csdn.net/fishinhouse/article/details/80781673" target="_blank" rel="noopener">https://blog.csdn.net/fishinhouse/article/details/80781673</a></p>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.8新特性</title>
      <link href="/2020/07/02/JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/07/02/JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>lambda表达式允许你通过表达式来代替功能接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression 或 (parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(cpt);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"========================="</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt2 = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line">TreeSet&lt;Integer&gt; set2 = <span class="keyword">new</span> TreeSet&lt;&gt;(cpt2);</span><br></pre></td></tr></table></figure><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>Stream操作的三个步骤</p><ul><li><p>创建stream</p></li><li><p>中间操作（过滤、map）</p></li><li><p>终止操作</p><p>stream的创建：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1，校验通过Collection 系列集合提供的stream()或者paralleStream()</span><br><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">Strean&lt;String&gt; stream1 &#x3D; list.stream();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.通过Arrays的静态方法stream()获取数组流</span><br><span class="line">String[] str &#x3D; new String[10];</span><br><span class="line">Stream&lt;String&gt; stream2 &#x3D; Arrays.stream(str);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.通过Stream类中的静态方法of</span><br><span class="line">Stream&lt;String&gt; stream3 &#x3D; Stream.of(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4.创建无限流</span><br><span class="line">&#x2F;&#x2F; 迭代</span><br><span class="line">Stream&lt;Integer&gt; stream4 &#x3D; Stream.iterate(0,(x) -&gt; x+2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成</span><br><span class="line">Stream.generate(() -&gt;Math.random());</span><br></pre></td></tr></table></figure><p>Stream的中间操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 筛选 过滤  去重</span><br><span class="line">   *&#x2F;</span><br><span class="line">  emps.stream()</span><br><span class="line">          .filter(e -&gt; e.getAge() &gt; 10)</span><br><span class="line">          .limit(4)</span><br><span class="line">          .skip(4)</span><br><span class="line">          &#x2F;&#x2F; 需要流中的元素重写hashCode和equals方法</span><br><span class="line">          .distinct()</span><br><span class="line">          .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   *  生成新的流 通过map映射</span><br><span class="line">   *&#x2F;</span><br><span class="line">  emps.stream()</span><br><span class="line">          .map((e) -&gt; e.getAge())</span><br><span class="line">          .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   *  自然排序  定制排序</span><br><span class="line">   *&#x2F;</span><br><span class="line">  emps.stream()</span><br><span class="line">          .sorted((e1 ,e2) -&gt; &#123;</span><br><span class="line">              if (e1.getAge().equals(e2.getAge()))&#123;</span><br><span class="line">                  return e1.getName().compareTo(e2.getName());</span><br><span class="line">              &#125; else&#123;</span><br><span class="line">                  return e1.getAge().compareTo(e2.getAge());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>Stream的终止操作：</p><p>reduce:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> *  reduce ：规约操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">List&lt;Integer&gt; list &#x3D; Arrays.asList(1,2,3,4,5,6,7,8,9,10);</span><br><span class="line">Integer count2 &#x3D; list.stream()</span><br><span class="line">        .reduce(0, (x, y) -&gt; x + y);</span><br><span class="line">System.out.println(count2);</span><br><span class="line"></span><br><span class="line">Optional&lt;Double&gt; sum &#x3D; emps.stream()</span><br><span class="line">        .map(Employee::getSalary)</span><br><span class="line">        .reduce(Double::sum);</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><p>collect操作：Collect-将流转换为其他形式，接收一个Collection接口的实现，用于给Stream中元素做汇总的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  collect：收集操作</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; ageList &#x3D; emps.stream()</span><br><span class="line">        .map(Employee::getAge)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">ageList.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="接口中可以定义默认实现方法和静态方法"><a href="#接口中可以定义默认实现方法和静态方法" class="headerlink" title="接口中可以定义默认实现方法和静态方法"></a>接口中可以定义默认实现方法和静态方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Interface &#123;</span><br><span class="line">    default  String getName()&#123;</span><br><span class="line">        return &quot;zhangsan&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static String getName2()&#123;</span><br><span class="line">        return &quot;zhangsan&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对static的理解</title>
      <link href="/2020/07/02/%E5%AF%B9static%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/07/02/%E5%AF%B9static%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="能否被重写"><a href="#能否被重写" class="headerlink" title="能否被重写"></a>能否被重写</h2><p>语法上子类允许出现和父类只有方法体不一样其他都一模一样的static方法，但是在父类引用指向子类对象时，通过父类引用调用的依然是父类的static方法，而不是子类的static方法。<br>即：语法上static支持重写，但是运行效果上达不到多态目的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;  </span><br><span class="line">        static void a( )&#123;System.out.println(&quot;A&quot;);  &#125;  </span><br><span class="line">                 void b( )&#123;System.out.println(&quot;B&quot;); &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">public class  Inherit extends Base&#123;  </span><br><span class="line">          static void a( )&#123;System.out.println(&quot;C&quot;);  &#125;  </span><br><span class="line">                  void b( )&#123;System.out.println(&quot;D&quot;); &#125;  </span><br><span class="line">           public static void main(String args[])&#123;  </span><br><span class="line">                    Base b&#x3D;new Base();  </span><br><span class="line">                    Base  c&#x3D;new Inherit();  </span><br><span class="line">                    b.a();  </span><br><span class="line">                    b.b();  </span><br><span class="line">                    c.a();  </span><br><span class="line">                    c.b();  </span><br><span class="line">         &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h2><p>​    1.静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来<br> 访问它。静态变量在内存中只存在一份。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">  private int x; &#x2F;&#x2F; 实例变量</span><br><span class="line">  private static int y; &#x2F;&#x2F; 静态变量</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">  &#x2F;&#x2F; int x &#x3D; A.x; &#x2F;&#x2F; Non-static field &#39;x&#39; cannot be referenced from a static context</span><br><span class="line">  A a &#x3D; new A();</span><br><span class="line">  int x &#x3D; a.x;</span><br><span class="line">  int y &#x3D; A.y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>静态方法<br> 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class A &#123;</span><br><span class="line">public static void func1()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; public abstract static void func2(); &#x2F;&#x2F; Illegal combination of modifiers: &#39;abstract&#39;</span><br><span class="line">and &#39;static&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>静态语句块<br> 静态语句块在类初始化时运行一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println(&quot;123&quot;);</span><br><span class="line">&#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">  A a1 &#x3D; new A();</span><br><span class="line">  A a2 &#x3D; new A();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure></li><li><p>静态内部类</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">  class InnerClass &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  static class StaticInnerClass &#123;</span><br><span class="line"> &#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; InnerClass innerClass &#x3D; new InnerClass(); &#x2F;&#x2F; &#39;OuterClass.this&#39; cannot be</span><br><span class="line">   referenced from a static context</span><br><span class="line">  OuterClass outerClass &#x3D; new OuterClass();</span><br><span class="line">  InnerClass innerClass &#x3D; outerClass.new InnerClass();</span><br><span class="line">  StaticInnerClass staticInnerClass &#x3D; new StaticInnerClass();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.初始化顺序</p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺<br>序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static String staticField &#x3D; &quot;静态变量&quot;;</span><br><span class="line">  static &#123;</span><br><span class="line">  System.out.println(&quot;静态语句块&quot;);</span><br><span class="line">&#125;</span><br><span class="line">  public String field &#x3D; &quot;实例变量&quot;;</span><br><span class="line"> &#123;</span><br><span class="line">  System.out.println(&quot;普通语句块&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后才是构造函数的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public InitialOrderTest() &#123;</span><br><span class="line">  System.out.println(&quot;构造函数&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>修饰符(public&amp;protect&amp;default&amp;private)、接口，抽象类</title>
      <link href="/2020/07/02/%E4%BF%AE%E9%A5%B0%E7%AC%A6public-protect-default-private/"/>
      <url>/2020/07/02/%E4%BF%AE%E9%A5%B0%E7%AC%A6public-protect-default-private/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><img src="/2020/07/02/%E4%BF%AE%E9%A5%B0%E7%AC%A6public-protect-default-private/1.png" class title="如图% } Java 中有三个访问权限修饰符：private、protected 以及 public，**如果不加访问修饰符，表示包级可见**。 可以对类或类中的成员（字段以及方法）加上访问修饰符。 **protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。** &lt;figure class&#x3D;highlight plain&gt;&lt;table&gt;&lt;tr&gt;&lt;td class&#x3D;gutter&gt;&lt;pre&gt;&lt;span class&#x3D;line&gt;1&lt;&#x2F;span&gt;&lt;br&gt;&lt;span class&#x3D;line&gt;2&lt;&#x2F;span&gt;&lt;br&gt;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;td class&#x3D;code&gt;&lt;pre&gt;&lt;span class&#x3D;line&gt;类可见表示其它类可以用这个类创建实例对象。&lt;&#x2F;span&gt;&lt;br&gt;&lt;span class&#x3D;line&gt;成员可见表示其它类可以用这个类的实例对象访问到该成员；&lt;&#x2F;span&gt;&lt;br&gt;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&lt;&#x2F;figure&gt; ## 抽象类与接口 ### 抽象类 **抽象类用来描述一种类型应该具备的基本特征与功能。** （犬科均会吼叫，但属于犬科的狼与狗其吼叫内容不同。所以犬科规定了有吼叫功能，但并不明确吼叫的细节。吼叫的细节应该由狼与狗这样的犬科子类重写吼叫的方法具体实现。） **抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。** ### 接口 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了（default）。 **接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。接口的变量默认都是 static 和 final 的。** ### 比较 * 从设计层面上看，**抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所** **有父类对象**。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具 有 IS-A 关系。 * 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 * 接口的变量只能是 static 和 final 类型的，而抽象类的变量没有这种限制。 * 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 {% asset_img 2.png"><img src="/2020/07/02/%E4%BF%AE%E9%A5%B0%E7%AC%A6public-protect-default-private/3.png" class><h3 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h3><p>使用接口：<br>1.需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；<br>2.需要使用多重继承。<br>使用抽象类：<br>1.需要在几个相关的类中共享代码。<br>2.需要能控制继承来的成员的访问权限，而不是都为 public。<br>3.需要继承非静态和非常量字段。<br>在很多情况下，<strong>接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并</strong><br><strong>且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象三大特性的理解?</title>
      <link href="/2020/07/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/07/02/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>将数据和基于数据的操作封装在一起，数据被保护在抽象数据类型的内部，只保留一些对外的接口使其与外部发生联系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> gender;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> gender == <span class="number">0</span> ? <span class="string">"man"</span> : <span class="string">"woman"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">    System.out.println(name + <span class="string">" is working very hard!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(name + <span class="string">" can't work any more!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非<br>private 的属性和方法。<br>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。<br>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态分为编译时多态和运行时多态：</p><ul><li><p>编译时多态主要指方法的重载</p></li><li><p>运行时多态指的是 <strong>对象引用所指向的具体类型在运行期间才确定</strong></p></li></ul><p>运行时多态有三个条件：<br>  1.继承<br>  2.重写<br>  3.向上转型</p><p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且<br>在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，<br>会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Instument is playing..."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Wind is playing..."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Percussion is playing..."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   List&lt;Instrument&gt; instruments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   instruments.add(<span class="keyword">new</span> Wind());</span><br><span class="line">   instruments.add(<span class="keyword">new</span> Percussion());</span><br><span class="line">   <span class="keyword">for</span>(Instrument instrument : instruments) &#123;</span><br><span class="line">   instrument.play();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wind is playing...</span><br><span class="line">Percussion is playing...</span><br></pre></td></tr></table></figure><h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><p>重写（Override）<br>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。<br>为了满足里式替换原则，重写有以下三个限制：<br><strong>1.子类方法的访问权限必须大于等于父类方法；</strong><br><strong>2.子类方法的返回类型必须是父类方法返回类型或为其子类型。</strong><br><strong>3.子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</strong><br>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有查找到再到父类中查看，看是否有继承来的方<br>法。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p><p>this.func(this)<br>super.func(this)<br>this.func(super)<br>super.func(super)</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Error和Exception</title>
      <link href="/2020/07/02/Error%E5%92%8CException/"/>
      <url>/2020/07/02/Error%E5%92%8CException/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Throwable 用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM<br>无法处理的错误，Exception 分为两种：</p><ul><li><p>非运行时异常 ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复,IOEXception,SQLException,SocketException；</p></li><li><p>运行时异常 ：是程序运行时发错误，例如除 0 会引发 Arithmetic [əˈrɪθmətɪk] Exception，此时程序崩溃并且无法恢复，RuntimeException及其子类。如IndexOutOfBounds ,ArrayIndexOutOfBounds </p></li></ul><img src="/2020/07/02/Error%E5%92%8CException/1.png" class title="如图">]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDK和JRE</title>
      <link href="/2020/07/02/JDK%E5%92%8CJRE/"/>
      <url>/2020/07/02/JDK%E5%92%8CJRE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>JDK（Java Development Kit）：是 Java 开发工具包，，包括了 JRE、Java 工具(比如一些编译调试工具)和 Java 基础类库。</p><p>JRE（ Java Runtime Environment）：是 Java 的运行环境，包含 <strong>JVM 标准实现及 Java 核心类库</strong>。</p><p>(JDK同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。)</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>B树、B+树、红黑树</title>
      <link href="/2020/07/01/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2020/07/01/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2020/07/01/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201209170052201.png" alt="image-20201209170052201"></p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><img src="/2020/07/01/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201103195345798.png" alt="image-20201103195345798"></p><p>B Tree 指的是 Balance Tree，也就是平衡树，相当于是一棵多叉查找树，对于一棵 m 阶的 B 树具有如下特性：</p><p>1、根节点至少有两个孩子。</p><p>2、每个非根节点所包含的关键字个数j满足：ceil(m/2) - 1 &lt;= j &lt;= m - 1（ceil为向上取整，即大于该数的最小整数）</p><p>3、每个节点中的元素从小到大排列，节点当中的 k - 1 个元素正好是 k 个孩子包含的元素的值域划分。</p><p>4、节点的子节点数会比关键字个数加1</p><p>5、所有的叶子节点都位于同一侧。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><img src="/2020/07/01/B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201103195404475.png" alt="image-20201103195404475"></p><p>对于一棵 m 阶的 B+ 树具有如下特性：</p><p>1、根节点至少有两个孩子。</p><p>2、每个中间节点都包含 k  个元素和 k 个孩子，其中 ceil(m/2) &lt;= k &lt;= m。</p><p>3、一个节点中的 key 从左到右非递减排列</p><p>4、所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)</p><h2 id="B树与B-树的区别？"><a href="#B树与B-树的区别？" class="headerlink" title="B树与B+树的区别？"></a>B树与B+树的区别？</h2><ol><li><p>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为页的大小是固定的，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。 </p></li><li><p>因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。</p></li></ol><h2 id="B-树与红黑树的区别？"><a href="#B-树与红黑树的区别？" class="headerlink" title="B+树与红黑树的区别？"></a>B+树与红黑树的区别？</h2><p>但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个</p><p>原因</p><p>（一）更少的查找次数</p><p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。</p><p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p><p>（二）利用磁盘预读特性</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h2 id="为什么说红黑树没能充分利用磁盘预读功能"><a href="#为什么说红黑树没能充分利用磁盘预读功能" class="headerlink" title="为什么说红黑树没能充分利用磁盘预读功能?"></a>为什么说红黑树没能充分利用磁盘预读功能?</h2><p>红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。<br>也就是说，使用红黑树（平衡二叉树）结构的话，每次磁盘预读中的很多数据是用不上的数据。因此，它没能利用好磁盘预读的提供的数据。然后又由于深度大（较B树而言），所以进行的磁盘IO操作更多。</p><h2 id="redis为什么采用跳表而不是红黑树？？"><a href="#redis为什么采用跳表而不是红黑树？？" class="headerlink" title="redis为什么采用跳表而不是红黑树？？"></a>redis为什么采用跳表而不是红黑树？？</h2><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。<br>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。<br>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。<br>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。<br>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p><h2 id="红黑树相比平衡二叉树的特点"><a href="#红黑树相比平衡二叉树的特点" class="headerlink" title="红黑树相比平衡二叉树的特点"></a>红黑树相比平衡二叉树的特点</h2><p>AVL树是<strong>严格的平衡二叉树</strong>，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1。红黑树一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（<strong>非红即黑</strong>）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，<strong>红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，</strong>在相同的节点情况下，AVL树的高度低于红黑树）**，相对于要求严格的AVL树来说，它的旋转次数少</p><h2 id="为什么MySQL不使用Hash结构，二叉树，B树，而是B-树？"><a href="#为什么MySQL不使用Hash结构，二叉树，B树，而是B-树？" class="headerlink" title="为什么MySQL不使用Hash结构，二叉树，B树，而是B+树？"></a>为什么MySQL不使用Hash结构，二叉树，B树，而是B+树？</h2><p>哈希虽然能够提供 O(1) 的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描；</p><p>B树：</p><ol><li><p>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为页的大小是固定的，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。 </p></li><li><p>因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（假设我们需要访问所有『大于 4，并且小于 9 的数据』。B+ 树中就不存在这个问题了，因为所有的数据行都存储在叶节点中，而这些叶节点可以通过『指针』依次按顺序连接，当我们在如下所示的 B+ 树遍历数据时可以直接在多个子节点之间进行跳转，这样能够节省大量的磁盘 I&#x2F;O 时间，也不需要在不同层级的节点之间对数据进行拼接和排序）</span><br></pre></td></tr></table></figure></li></ol><h2 id="B-树满了会发生什么？"><a href="#B-树满了会发生什么？" class="headerlink" title="B+树满了会发生什么？"></a>B+树满了会发生什么？</h2><h3 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h3><p>1）若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。</p><p>2）针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2+1个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。</p><p>3）针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。</p><h3 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h3><p>如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤</p><p>1）删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2，删除操作结束,否则执行第2步。</p><p>2）若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。</p><p>3）若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。</p><p>4）若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步</p><p>5）若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步</p><p>6）当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。</p><p>注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。</p><p><img src="https://img-blog.csdnimg.cn/20200413111039577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTU2MzE2MQ==,size_16,color_FFFFFF,t_70" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现阻塞队列</title>
      <link href="/2020/07/01/%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
      <url>/2020/07/01/%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-什么是阻塞队列？"><a href="#1-什么是阻塞队列？" class="headerlink" title="1. 什么是阻塞队列？"></a>1. 什么是阻塞队列？</h2><p><strong>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</strong>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><h2 id="2-LinkedBlockingQueue"><a href="#2-LinkedBlockingQueue" class="headerlink" title="2.LinkedBlockingQueue"></a>2.LinkedBlockingQueue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedBlockingQueue&lt;E&gt; &#123;</span><br><span class="line">    private final int capacity;</span><br><span class="line"></span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private Condition unfull &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    private Condition unEmpty &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    private LinkedList&lt;E&gt; queue;</span><br><span class="line"></span><br><span class="line">    public LinkedBlockingQueue() throws InterruptedException &#123;</span><br><span class="line">        this(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public LinkedBlockingQueue(int capacity) throws InterruptedException &#123;</span><br><span class="line">        this.capacity &#x3D; capacity;</span><br><span class="line">        queue &#x3D; new LinkedList&lt;E&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count &#x3D;&#x3D; capacity) &#123;</span><br><span class="line">                unfull.await();&#x2F;&#x2F;阻塞队列已满，等待</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(e);</span><br><span class="line">            count++;</span><br><span class="line">            unEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E take() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;队列为空，阻塞</span><br><span class="line">                unEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            E e &#x3D; queue.pop();</span><br><span class="line">            count--;</span><br><span class="line">            unfull.signal();</span><br><span class="line">            return e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ArrayBlockingQueue"><a href="#3-ArrayBlockingQueue" class="headerlink" title="3.ArrayBlockingQueue"></a>3.ArrayBlockingQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> </span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line">public class BlockQueue&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    private int size;</span><br><span class="line">    private Object[] queue;</span><br><span class="line"> </span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    private Condition full &#x3D; lock.newCondition();</span><br><span class="line">    private Condition empty &#x3D; lock.newCondition();</span><br><span class="line"> </span><br><span class="line">    private int index;</span><br><span class="line">    private int removeIndex;</span><br><span class="line">    private int currLen;</span><br><span class="line"> </span><br><span class="line">    public BlockQueue() &#123;</span><br><span class="line">        this(10);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public BlockQueue(int size) &#123;</span><br><span class="line">        this.index &#x3D; 0;</span><br><span class="line">        this.removeIndex &#x3D; 0;</span><br><span class="line">        this.currLen &#x3D; 0;</span><br><span class="line">        this.size &#x3D; size;</span><br><span class="line">        queue &#x3D; new Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void push(T element) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (currLen &#x3D;&#x3D; size) &#123;</span><br><span class="line">                System.out.println(&quot;队列满。。。&quot;);</span><br><span class="line">                full.await();</span><br><span class="line">            &#125;</span><br><span class="line">            queue[index] &#x3D; element;</span><br><span class="line">            if (++index &#x3D;&#x3D; size) &#123;</span><br><span class="line">                index &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            currLen++;</span><br><span class="line">            empty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public T pop() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (currLen &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                System.out.println(&quot;队列空。。。&quot;);</span><br><span class="line">                empty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            Object obj &#x3D; queue[removeIndex];</span><br><span class="line">            if (++removeIndex &#x3D;&#x3D; size) &#123;</span><br><span class="line">                removeIndex &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            currLen--;</span><br><span class="line">            full.signal();</span><br><span class="line">            return (T) obj;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        BlockQueue&lt;Integer&gt; blockQueue &#x3D; new BlockQueue&lt;Integer&gt;(3);</span><br><span class="line">        blockQueue.push(1);</span><br><span class="line">        System.out.println(blockQueue.pop());</span><br><span class="line">        blockQueue.push(2);</span><br><span class="line">        System.out.println(blockQueue.pop());</span><br><span class="line">        blockQueue.push(3);</span><br><span class="line">        System.out.println(blockQueue.pop());</span><br><span class="line"> </span><br><span class="line">        blockQueue.push(5);</span><br><span class="line">        blockQueue.push(5);</span><br><span class="line">        System.out.println(blockQueue.pop());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手撕代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS是什么?</title>
      <link href="/2020/07/01/AQS%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/01/AQS%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>AQS全称是AbstractQueuedSynchronizer，即抽象同步队列。下面看一下AQS的类图结构：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/21/16c151e53fa38334?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>为了方便下面几个关键点的理解，大家先<strong>熟悉一下AQS的类图结构</strong>。</p><p>AQS 队列同步器是<strong>用来构建锁或其他同步组件的基础框架</strong>，它使用一个 volatile int state 变量作为共享资源。如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。</p><p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，对同步状态进行更改需要使用同步器提供的 3个方法 <code>getState</code>、<code>setState</code> 和 <code>compareAndSetState</code> ，它们保证状态改变是安全的。</p><h2 id="state-状态的维护"><a href="#state-状态的维护" class="headerlink" title="state 状态的维护"></a>state 状态的维护</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在AQS中维持了一个单一的共享状态state，来实现同步器同步。看一下state的相关代码如下：</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="state源码"><a href="#state源码" class="headerlink" title="state源码"></a>state源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line">   * The synchronization state.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private volatile int state;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Returns the current value of synchronization state.</span><br><span class="line">   * This operation has memory semantics of a &#123;@code volatile&#125; read.</span><br><span class="line">   * @return current state value</span><br><span class="line">   *&#x2F;</span><br><span class="line">  protected final int getState() &#123;</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Sets the value of synchronization state.</span><br><span class="line">   * This operation has memory semantics of a &#123;@code volatile&#125; write.</span><br><span class="line">   * @param newState the new state value</span><br><span class="line">   *&#x2F;</span><br><span class="line">  protected final void setState(int newState) &#123;</span><br><span class="line">      state &#x3D; newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Atomically sets synchronization state to the given updated</span><br><span class="line">   * value if the current state value equals the expected value.</span><br><span class="line">   * This operation has memory semantics of a &#123;@code volatile&#125; read</span><br><span class="line">   * and write.</span><br><span class="line">   *</span><br><span class="line">   * @param expect the expected value</span><br><span class="line">   * @param update the new value</span><br><span class="line">   * @return &#123;@code true&#125; if successful. False return indicates that the actual</span><br><span class="line">   *         value was not equal to the expected value.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">      &#x2F;&#x2F; See below for intrinsics setup to support this</span><br><span class="line">      return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="state-源码设计几个回答要点："><a href="#state-源码设计几个回答要点：" class="headerlink" title="state 源码设计几个回答要点："></a>state 源码设计几个回答要点：</h3><ul><li>state用volatile修饰，保证多线程中的可见性。</li><li>getState()和setState()方法采用final修饰，限制AQS的子类重写它们两。</li><li>compareAndSetState（）方法采用乐观锁思想的CAS算法，也是采用final修饰的，不允许子类重写。</li></ul><h2 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h2><p>谈到CLH队列，我们结合以上state状态，先来看一下<strong>AQS原理图</strong>：</p><img src="/2020/07/01/AQS%E6%98%AF%E4%BB%80%E4%B9%88/1.jpg" class title="this is AQS"><p>CLH(Craig, Landin, and Hagersten locks) 同步队列 是一个FIFO双向队列，其内部通过节点head和tail记录队首和队尾元素，队列元素的类型为Node。</p><p><strong>AQS依赖它来完成同步状态state的管理，当前线程如果获取同步状态失败时，AQS则会调用addWaiter方法，CAS的方式将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程</strong>，<strong>CAS设置失败会采用死循环的方式</strong>。当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><p>CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），condition队列的后续节点（nextWaiter）如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/31/16c4545ea0b027b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>waitStatus几种状态状态：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/7/31/16c454d3d62d9108?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>我们再看一下CLH队列入列以及出列的代码：</p><h3 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h3><p>CLH队列入列就是<strong>tail指向新节点、新节点的prev指向当前最后的节点，当前最后一个节点的next指向当前节点</strong>。addWaiter方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造Node</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">  Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">        &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure（快速尝试添加尾节点）</span><br><span class="line">        Node pred &#x3D; tail;</span><br><span class="line">        if (pred !&#x3D; null) &#123;</span><br><span class="line">            node.prev &#x3D; pred;</span><br><span class="line">            &#x2F;&#x2F;CAS设置尾节点</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next &#x3D; node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;多次尝试</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>由以上代码可得，addWaiter设置尾节点失败的话，调用enq(Node node)方法设置尾节点，enq方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   private Node enq(final Node node) &#123;</span><br><span class="line">        &#x2F;&#x2F;死循环尝试，知道成功为止</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node t &#x3D; tail;</span><br><span class="line">            &#x2F;&#x2F;tail 不存在，设置为首节点</span><br><span class="line">            if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    tail &#x3D; head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node.prev &#x3D; t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next &#x3D; node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="出列"><a href="#出列" class="headerlink" title="出列"></a>出列</h3><p>首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点。可以看一下以下两段源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  Node h &#x3D; head;</span><br><span class="line">  if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">  unparkSuccessor(h);</span><br><span class="line">复制代码</span><br><span class="line"> private void unparkSuccessor(Node node) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">         * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">         * fails or if status is changed by waiting thread.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int ws &#x3D; node.waitStatus;</span><br><span class="line">        if (ws &lt; 0)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Thread to unpark is held in successor, which is normally</span><br><span class="line">         * just the next node.  But if cancelled or apparently null,</span><br><span class="line">         * traverse backwards from tail to find the actual</span><br><span class="line">         * non-cancelled successor.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Node s &#x3D; node.next;</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">            s &#x3D; null;</span><br><span class="line">            for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">                if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                    s &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s !&#x3D; null)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="CLH核心几个回答要点"><a href="#CLH核心几个回答要点" class="headerlink" title="CLH核心几个回答要点"></a>CLH核心几个回答要点</h3><ul><li>双向链表入列出列</li><li>CAS算法设置尾节点+死循环自旋。</li></ul><p><strong>CAS算法，可以看一下我工作实战中仿造CAS算法解决并发问题的实现</strong> <a href="https://juejin.im/post/5d0616ade51d457756536791" target="_blank" rel="noopener">juejin.im/post/5d0616…</a></p><h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2><h3 id="ConditionObject简介"><a href="#ConditionObject简介" class="headerlink" title="ConditionObject简介"></a>ConditionObject简介</h3><p>我们都知道，synchronized控制同步的时候，可以配合<strong>Object的wait()、notify()，notifyAll()</strong> 系列方法可以实现等待/通知模式。而Lock呢？它提供了条件Condition接口，配合<strong>await(),signal(),signalAll()</strong> 等方法也可以实现等待/通知机制。<strong>ConditionObject实现了Condition接口</strong>，给AQS提供<strong>条件变量的支持</strong> 。</p><h3 id="Condition队列与CLH队列的那些事"><a href="#Condition队列与CLH队列的那些事" class="headerlink" title="Condition队列与CLH队列的那些事"></a>Condition队列与CLH队列的那些事</h3><p>我们先来看一下图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/30/16c4214fad310ccf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>ConditionObject队列与CLH队列的爱恨情仇：</strong></p><ul><li>调用了await()方法的线程，会被加入到conditionObject等待队列中，并且唤醒CLH队列中head节点的下一个节点。</li><li>线程在某个ConditionObject对象上调用了singnal()方法后，等待队列中的firstWaiter会被加入到AQS的CLH队列中，等待被唤醒。</li><li>当线程调用unLock()方法释放锁时，CLH队列中的head节点的下一个节点(在本例中是firtWaiter)，会被唤醒。</li></ul><p><strong>区别：</strong></p><ul><li>ConditionObject对象都维护了一个单独的<strong>等待队列</strong> ，AQS所维护的CLH队列是<strong>同步队列</strong>，它们节点类型相同，都是Node。</li></ul><h2 id="独占与共享模式。"><a href="#独占与共享模式。" class="headerlink" title="独占与共享模式。"></a>独占与共享模式。</h2><p>AQS支持两种同步模式:独占式和共享式。</p><ul><li><p>Exclusive</p><p>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><p><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p></li></ul><p><strong>独占模式</strong>表示锁只会被一个线程占用，其他线程必须等到持有锁的线程释放锁后才能获取锁，同一时间只能有一个线程获取到锁。</p><p><strong>共享模式</strong>表示多个线程获取同一个锁有可能成功</p><p>独占模式通过 acquire 和 release 方法获取和释放锁，共享模式通过 acquireShared 和 releaseShared</p><p><img src="https://img-blog.csdnimg.cn/20200305231339850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxaW50ZXJuZXQ=,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200305231413792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxaW50ZXJuZXQ=,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h3><p>获取同步状态时，调用 <code>acquire</code> 方法，维护一个同步队列，使用 <code>tryAcquire</code> 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 <code>addWaiter</code> 方法加入到同步队列的尾部，在队列中自旋。之后调用 <code>acquireQueued</code> 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞，被阻塞线程的唤醒主要依靠前驱节点的出队或被中断实现，移出队列或停止自旋的条件是前驱节点是头结点且成功获取了同步状态。</p><p>释放同步状态时，同步器调用 <code>tryRelease</code> 方法释放同步状态，然后调用 <code>unparkSuccessor</code> 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。</p><p>同一时刻仅有一个线程持有同步状态，如<strong>ReentrantLock</strong>。又可分为公平锁和非公平锁。</p><p><strong>公平锁：</strong> 按照线程在队列中的排队顺序，有礼貌的，先到者先拿到锁。</p><p><strong>非公平锁：</strong> 当线程要获取锁时，无视队列顺序直接去抢锁，不讲道理的，谁抢到就是谁的。</p><p><strong>acquire(int arg)是独占式获取同步状态的方法</strong>，我们来看一下源码：</p><ul><li><strong>acquire(long arg)方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  public final void acquire(long arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>addWaiter方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造Node</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">  Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">        &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure（快速尝试添加尾节点）</span><br><span class="line">        Node pred &#x3D; tail;</span><br><span class="line">        if (pred !&#x3D; null) &#123;</span><br><span class="line">            node.prev &#x3D; pred;</span><br><span class="line">            &#x2F;&#x2F;CAS设置尾节点</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next &#x3D; node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;多次尝试</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">        &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>acquireQueued(final Node node, long arg)方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> final boolean acquireQueued(final Node node, long arg) &#123;</span><br><span class="line">        boolean failed &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted &#x3D; false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p &#x3D; node.predecessor();</span><br><span class="line">                if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>selfInterrupt()方法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">     Thread.currentThread().interrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>结合源代码，可得acquire(int arg)方法流程图，如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/30/16c42890d2ec5e01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h3><p>多个线程可同时执行，如Semaphore/CountDownLatch等都是共享式的产物。</p><p>获取同步状态时，调用 <code>acquireShared</code> 方法，该方法调用 <code>tryAcquireShared</code> 方法尝试获取同步状态，返回值为 int 类型，返回值不小于于 0 表示能获取同步状态。因此在共享式获取锁的自旋过程中，成功获取同步状态并退出自旋的条件就是该方法的返回值不小于0。</p><p>释放同步状态时，调用 <code>releaseShared</code> 方法，释放后会唤醒后续处于等待状态的节点。它和独占式的区别在于 <code>tryReleaseShared</code> 方法必须确保同步状态安全释放，通过循环 CAS 保证，因为释放同步状态的操作会同时来自多个线程。</p><p><strong>acquireShared(long arg)是共享式获取同步状态的方法</strong>，可以看一下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  public final void acquireShared(long arg) &#123;</span><br><span class="line">        if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>由上可得，先调用tryAcquireShared(int arg)方法尝试获取同步状态，如果获取失败，调用<strong>doAcquireShared(int arg)自旋方式获取同步状态</strong>，方法源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> private void doAcquireShared(long arg) &#123;</span><br><span class="line">        final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">        boolean failed &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted &#x3D; false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p &#x3D; node.predecessor();</span><br><span class="line">                if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                    long r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                        if (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed &#x3D; false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><a href="https://www.javadoop.com/" target="_blank" rel="noopener">https://www.javadoop.com/</a></p><h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><p>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）<br>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。<br>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p><p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">isHeldExclusively()&#x2F;&#x2F;该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">tryAcquire(int)&#x2F;&#x2F;独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br><span class="line">tryRelease(int)&#x2F;&#x2F;独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br><span class="line">tryAcquireShared(int)&#x2F;&#x2F;共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">tryReleaseShared(int)&#x2F;&#x2F;共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p><p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2 id="自定义同步器。"><a href="#自定义同步器。" class="headerlink" title="自定义同步器。"></a>自定义同步器。</h2><p>基于以上分析，我们都知道<strong>state，CLH队列，ConditionObject队列</strong> 等这些关键点，你要实现自定义锁的话，首先需要确定你要实现的是<strong>独占锁还是共享锁，定义原子变量state的含义，再定义一个内部类去继承AQS，重写对应的模板方法</strong>。</p><p>我们来看一下基于 AQS 实现的不可重入的独占锁的demo，来自《Java并发编程之美》：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class NonReentrantLock implements Lock,Serializable&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;内部类,自定义同步器</span><br><span class="line">    static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        &#x2F;&#x2F;是否锁已经被持有</span><br><span class="line">        public boolean isHeldExclusively() &#123;</span><br><span class="line">            return getState() &#x3D;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果state为0 则尝试获取锁</span><br><span class="line">        public boolean tryAcquire(int arg) &#123;</span><br><span class="line">            assert arg&#x3D;&#x3D; 1 ;</span><br><span class="line">            &#x2F;&#x2F;CAS设置状态,能保证操作的原子性，当前为状态为0,操作成功状态改为1</span><br><span class="line">            if(compareAndSetState(0, 1))&#123;</span><br><span class="line">                &#x2F;&#x2F;设置当前独占的线程</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;尝试释放锁，设置state为0</span><br><span class="line">        public boolean tryRelease(int arg) &#123;</span><br><span class="line">            assert arg &#x3D;&#x3D;1;</span><br><span class="line">            &#x2F;&#x2F;如果同步器同步器状态等于0,则抛出监视器非法状态异常</span><br><span class="line">            if(getState() &#x3D;&#x3D; 0)</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#x2F;&#x2F;设置独占锁的线程为null</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            &#x2F;&#x2F;设置同步状态为0</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回Condition,每个Condition都包含了一个Condition队列</span><br><span class="line">        Condition newCondition()&#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建一个Sync来做具体的工作</span><br><span class="line">    private final Sync sync&#x3D; new Sync ();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isLocked() &#123;</span><br><span class="line">        return sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">        @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>NonReentrantLockDemoTest:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class NonReentrantLockDemoTest &#123;</span><br><span class="line"></span><br><span class="line">    private static NonReentrantLock nonReentrantLock &#x3D; new NonReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                nonReentrantLock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    nonReentrantLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/31/16c45d2d8320a2c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>作者：Jay_huaxiao<br>链接：<a href="https://juejin.im/post/5d34502cf265da1baf7d27aa" target="_blank" rel="noopener">https://juejin.im/post/5d34502cf265da1baf7d27aa</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Lock lock&#x3D;new ReentrantLock();</span><br><span class="line">        Condition a&#x3D;lock.newCondition();</span><br><span class="line">        Thread t1&#x3D;new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">             lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;wo shi t1 aaa&quot;);</span><br><span class="line"></span><br><span class="line">                    a.signal();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2&#x3D;new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;wo shi t2 &quot;);</span><br><span class="line">                    a.await();</span><br><span class="line">                    System.out.println(&quot;wo shi t2 aaaa&quot;);</span><br><span class="line"></span><br><span class="line">                    a.signal();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t3&#x3D;new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">&#x2F;&#x2F;                    Thread.sleep(2000);</span><br><span class="line">                    System.out.println(&quot;wo shi t3&quot;);</span><br><span class="line">                    a.await();</span><br><span class="line">                    System.out.println(&quot;wo shi t3 aaaa&quot;);</span><br><span class="line">                    a.signal();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class MyLock implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    private Helper helper&#x3D;new Helper();</span><br><span class="line"></span><br><span class="line">    private class Helper extends AbstractQueuedSynchronizer&#123;</span><br><span class="line">        &#x2F;&#x2F;获取锁</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">            int state&#x3D;getState();</span><br><span class="line">            if(state&#x3D;&#x3D;0)&#123;</span><br><span class="line">                &#x2F;&#x2F;利用CAS原理修改state</span><br><span class="line">                if(compareAndSetState(0,arg))&#123;</span><br><span class="line">                    &#x2F;&#x2F;设置当前线程占有资源</span><br><span class="line">                    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(getExclusiveOwnerThread()&#x3D;&#x3D;Thread.currentThread())&#123;</span><br><span class="line">                setState(getState()+arg);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;释放锁</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryRelease(int arg) &#123;</span><br><span class="line">            int state&#x3D;getState()-arg;</span><br><span class="line">            boolean flag&#x3D;false;</span><br><span class="line">            &#x2F;&#x2F;判断释放后是否为0</span><br><span class="line">            if(state&#x3D;&#x3D;0)&#123;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">                setState(state);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            setState(state);&#x2F;&#x2F;存在线程安全吗？重入性的问题，当前已经独占了资源()state</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Condition newConditionObjecct()&#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        helper.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        helper.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return helper.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return helper.tryAcquireNanos(1,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        helper.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return helper.newConditionObjecct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cookie和Session剖析</title>
      <link href="/2020/06/30/Cookie%E5%92%8CSession%E5%89%96%E6%9E%90/"/>
      <url>/2020/06/30/Cookie%E5%92%8CSession%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="为什么要有Cookie？"><a href="#为什么要有Cookie？" class="headerlink" title="为什么要有Cookie？"></a>为什么要有Cookie？</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来</p><p>保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上</p><p>用途：</p><p>· 会话状态管理（如用户登录状态、购物车）</p><p>· 浏览器行为跟踪（如跟踪分析用户行为等）</p><h2 id="Cookie创建过程？"><a href="#Cookie创建过程？" class="headerlink" title="Cookie创建过程？"></a>Cookie创建过程？</h2><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务<br>器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><h2 id="Cookie分类"><a href="#Cookie分类" class="headerlink" title="Cookie分类"></a>Cookie分类</h2><p>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</p><p>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session?"></a>Session?</h2><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p><strong>session 认证流程：</strong></p><ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul><p><strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong></p><p>在对安全性要求极高的场景下，例如转账等操作，除了使用 Session管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h2 id="Session和Cookie区别？"><a href="#Session和Cookie区别？" class="headerlink" title="Session和Cookie区别？"></a>Session和Cookie区别？</h2><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选<br>Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加<br>密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信<br>息都存储到 Session 中。</li></ul><h2 id="Cookie和Session的选择？"><a href="#Cookie和Session的选择？" class="headerlink" title="Cookie和Session的选择？"></a>Cookie和Session的选择？</h2><ol><li><p>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session；</p></li><li><p>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</p></li><li><p>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</p></li></ol><h2 id="Cookie的不可跨域名性？"><a href="#Cookie的不可跨域名性？" class="headerlink" title="Cookie的不可跨域名性？"></a>Cookie的不可跨域名性？</h2><p>一个cookie只能用于一个域名(有效的二级域名，比如 shop.com)，不能够发给其它的域名。Cookie跨域指的是允许不同的二级域名间共享</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token?"></a>Token?</h2><ol><li>把用户的用户名和密码发到后端</li><li>后端进行校验，校验成功会生成token, 把token发送给客户端</li><li>客户端自己保存token, 再次请求就要在Http协议的请求头中带着token去访问服务端，和在服务端保存的token信息进行比对校验。</li></ol><ul><li><strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</strong></li><li><strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</strong></li><li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/29/16f523a04d9c745f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h2><ul><li><p>Session 是一种<strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息</strong>。而 Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></p></li><li><p>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。<strong>如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</strong></p></li><li><p>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。</p></li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><p>JWT 的 Header 通常包含两个字段，分别是：typ(type) 和 alg(algorithm)。</p><ul><li>typ：token的类型，这里固定为 JWT</li><li>alg：使用的 hash 算法，例如：HMAC SHA256 或者 RSA</li></ul><p>一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对他进行编码后是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; base64.b64encode(json.dumps(&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;))</span><br><span class="line">&#39;eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9&#39;</span><br></pre></td></tr></table></figure><h5 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h5><p>JWT 中的 Payload 其实就是真实存储我们需要传递的信息的部分，例如正常我们会存储些用户 ID、用户名之类的。此外，还包含一些例如发布人、过期日期等的元数据。</p><p>但是，这部分和 Header 部分不一样的地方在于这个地方可以加密，而不是简单得直接进行 BASE64 编码。但是这里我为了解释方便就直接使用 BASE64 编码，需要注意的是，这里的 BASE64 编码稍微有点不一样，切确得说应该是 Base64UrlEncoder，和 Base64 编码的区别在于会忽略最后的 padding（=号），然后 ‘-‘ 会被替换成’_’。</p><p>举个例子，例如我们的 Payload 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;user_id&quot;:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure><p>那么直接 Base64 的话应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; base64.urlsafe_b64encode(&#39;&#123;&quot;user_id&quot;:&quot;zhangsan&quot;&#125;&#39;)</span><br><span class="line">&#39;eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ&#x3D;&#x3D;&#39;</span><br></pre></td></tr></table></figure><p>然后去掉 = 号，最后应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ&#39;</span><br></pre></td></tr></table></figure><h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>Signature 部分其实就是对我们前面的 Header 和 Payload 部分进行签名，保证 Token 在传输的过程中没有被篡改或者损坏，签名的算法也很简单，但是，为了加密，所以除了 Header 和 Payload 之外，还多了一个密钥字段，完整算法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    Signature &#x3D; HMACSHA256(</span><br><span class="line">        base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">        base64UrlEncode(payload),</span><br><span class="line">        secret)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>还是以前面的例子为例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    base64UrlEncode(header)  &#x3D;》 eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9</span><br><span class="line">    base64UrlEncode(payload) &#x3D;》 eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>secret 就设为：”secret”, 那最后出来的签名应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    &gt;&gt;&gt; import hmac</span><br><span class="line">    &gt;&gt;&gt; import hashlib</span><br><span class="line">    &gt;&gt;&gt; import base64</span><br><span class="line">    &gt;&gt;&gt; dig &#x3D; hmac.new(&#39;secret&#39;,     &gt;&gt;&gt; msg&#x3D;&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ&quot;, </span><br><span class="line">               digestmod&#x3D;</span><br><span class="line">    &gt;&gt;&gt; base64.b64encode(dig.digest())</span><br><span class="line">    &#39;ec7IVPU-ePtbdkb85IRnK4t4nUVvF2bBf8fGhJmEwSs&#x3D;&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>将上面三个部分组装起来就组成了我们的 JWT token了，所以我们的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#123;&#39;user_id&#39;: &#39;zhangsan&#39;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>的 token 就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ.ec7IVPU-ePtbdkb85IRnK4t4nUVvF2bBf8fGhJmEwSs</span><br></pre></td></tr></table></figure><ol><li><p>在头部信息中声明加密算法和常量， 然后把header使用json转化为字符串</p></li><li><p>在载荷中声明用户信息，同时还有一些其他的内容；再次使用json 把载荷部分进行转化，转化为字符串</p></li><li><p>使用在header中声明的加密算法和每个项目随机生成的secret来进行加密， 把第一步分字符串和第二部分的字符串进行加密， 生成新的字符串。词字符串是独一无二的。</p></li><li><p>解密的时候，只要客户端带着JWT来发起请求，服务端就直接使用secret进行解密。</p></li></ol><h2 id="JWT与token的联系"><a href="#JWT与token的联系" class="headerlink" title="JWT与token的联系"></a>JWT与token的联系</h2><p>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</p><p>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用的状态码</title>
      <link href="/2020/06/30/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2020/06/30/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>{asset_img 1.png 表格}</p><ul><li><p>200：一切正常</p></li><li><p>204 No content：一切正常，但响应头后没有 body 数据</p></li><li><p>206：这种响应是在客户端表明自己只需要目标URL上的部分资源的时候返回的.这种情况经常发生在客户端继续请求一个未完成的下载的时候</p></li></ul><p>​      (状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range:       bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。)</p><ul><li><p>301：永久性重定向</p></li><li><p>302：临时重定向</p><p>301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI</p></li><li><p>303：跟302相似，只是对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI</p></li><li><p>304：“304 Not Modified”，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。</p></li><li><p>307：临时重定向，与302类似，只是强制要求使用POST方法</p></li><li><p>400  Bad Request：请求报文语法有误，服务器无法识别</p></li><li><p>401：请求需要认证</p></li><li><p>403 Forbidden：请求的对应资源禁止被访问</p></li><li><p>404 Not Found：服务器无法找到对应资源</p></li><li><p>500 Internal Server Error：服务器内部错误</p></li><li><p>“502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</p></li><li><p>503 Service Unavailable：服务器正忙</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是DHCP以及DHCP是怎么工作的</title>
      <link href="/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFDHCP%E4%BB%A5%E5%8F%8ADHCP%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
      <url>/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFDHCP%E4%BB%A5%E5%8F%8ADHCP%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p><strong>DHCP (Dynamic Host Configuration Protocol) 动态主机配置协议提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信</strong></p><p><strong>息。</strong></p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><ol><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP</li></ol><p>中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继</p><p>代理。</p><ol start="2"><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客</li></ol><p>户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是TCP粘包</title>
      <link href="/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFTCP%E7%B2%98%E5%8C%85/"/>
      <url>/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFTCP%E7%B2%98%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>原因可能是发送方也可能是接收方造成的。</p><p>发送方原因：TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</p><p>接收方原因：TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。</p><h2 id="处理方法："><a href="#处理方法：" class="headerlink" title="处理方法："></a>处理方法：</h2><p>1.发送方关闭Nagle算法。</p><p>2.接收方：接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层循环读取所有的数据，根据报文的长度判断每个包开始和结束的位置。</p><p>分包机制一般有两个通用的解决方法：</p><ol><li><p>特殊字符控制；</p></li><li><p>在包头首都添加数据包的长度</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP和UDP传输的报文段和用户数据报的差异</title>
      <link href="/2020/06/30/TCP%E5%92%8CUDP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
      <url>/2020/06/30/TCP%E5%92%8CUDP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><img src="/2020/06/30/TCP%E5%92%8CUDP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%AE%E5%BC%82/1.png" class title="TCP"><p>16位源端口号+16位目的端口号+32位序号+32位确认号+4位头部长度（单位4字节）+6位保留+6个关键字（SYN,ACK，FIN）+16位窗口大小（指接收窗口）+16位校验和+16位紧急指针+最多40字节的选项；</p><img src="/2020/06/30/TCP%E5%92%8CUDP%E4%BC%A0%E8%BE%93%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%B7%AE%E5%BC%82/2.png" class title="UDP"><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是CSMA/CD</title>
      <link href="/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFCSMA-CD/"/>
      <url>/2020/06/30/%E4%BB%80%E4%B9%88%E6%98%AFCSMA-CD/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><p>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</p></li><li><p>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</p></li><li><p>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</p></li></ul><p>记端到端的传播时延为 t，最先发送的站点最多经过 2t就可以知道是否发生了碰撞，称 2t 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2^k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引相关疑问</title>
      <link href="/2020/06/30/%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E7%96%91%E9%97%AE/"/>
      <url>/2020/06/30/%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E7%96%91%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/24/1710a4ae8e0c0464?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="创立索引的语句"><a href="#创立索引的语句" class="headerlink" title="创立索引的语句"></a>创立索引的语句</h2><p>1.添加PRIMARY KEY（主键索引）<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD PRIMARY KEY ( <code>column</code> )<br>2.添加UNIQUE(唯一索引)<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD UNIQUE (<br><code>column</code><br>)<br>3.添加INDEX(普通索引)<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column</code> )<br>4.添加FULLTEXT(全文索引)<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD FULLTEXT ( <code>column</code>)<br>5.添加多列索引<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column1</code>, <code>column2</code>, <code>column3</code> )</p><h2 id="索引为abc且查询条件为a-xxx-order-by-b时能用上哪个索引？"><a href="#索引为abc且查询条件为a-xxx-order-by-b时能用上哪个索引？" class="headerlink" title="索引为abc且查询条件为a=xxx order by b时能用上哪个索引？"></a>索引为abc且查询条件为a=xxx order by b时能用上哪个索引？</h2><p>order by 和group by 类似，字段顺序与索引一致时，会使用索引排序；字段顺序与索引不一致时，不使用索引。</p><h2 id="为什么是最左匹配"><a href="#为什么是最左匹配" class="headerlink" title="为什么是最左匹配"></a>为什么是最左匹配</h2><p><img src="https://img-blog.csdnimg.cn/20190401113210176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxOTE3MTA5,size_16,color_FFFFFF,t_70" alt="img"></p><p>1.简单说下什么是最左匹配原则<br>顾名思义：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。<br>例如：b = 2 如果建立(a,b)顺序的索引，是匹配不到(a,b)索引的；但是如果查询条件是a = 1 and b = 2或者a=1(又或者是b = 2 and b = 1)就可以，因为优化器会自动调整a,b的顺序。再比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。</p><p>2.最左匹配原则的原理<br>最左匹配原则都是针对联合索引来说的，所以我们有必要了解一下联合索引的原理。了解了联合索引，那么为什么会有最左匹配原则这种说法也就理解了。</p><p>我们都知道索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。<br>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的</p><p><img src="https://img2018.cnblogs.com/blog/1281680/201901/1281680-20190117145740508-758737271.png" alt="img"><br>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p><p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a&gt;1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p><h2 id="查询在什么时候不走（预期中的）索引"><a href="#查询在什么时候不走（预期中的）索引" class="headerlink" title="查询在什么时候不走（预期中的）索引?"></a>查询在什么时候不走（预期中的）索引?</h2><h2 id="order-by原理？"><a href="#order-by原理？" class="headerlink" title="order by原理？"></a>order by原理？</h2><h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><p>1.有or必全有索引;<br>2.复合索引未用左列字段;<br>3.like以%开头;<br>4.where中索引列有运算;<br>5.where中索引列使用了函数;<br>6.如果mysql觉得全表扫描更快时（数据少）</p><h2 id="索引有哪几种"><a href="#索引有哪几种" class="headerlink" title="索引有哪几种"></a>索引有哪几种</h2><ol><li><p>B+Tree 索引</p></li><li><p>哈希索引</p><p>对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p><p><img src="/2020/06/30/%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E7%96%91%E9%97%AE/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201218201538017.png" alt="image-20201218201538017"></p><p><img src="/2020/06/30/%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E7%96%91%E9%97%AE/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201218201739098.png" alt="image-20201218201739098"></p><p><img src="/2020/06/30/%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E7%96%91%E9%97%AE/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201218201753370.png" alt="image-20201218201753370"></p></li><li><p>全文索引</p><p>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create fulltext index content_tag_fulltext</span><br><span class="line">    on fulltext_test(content,tag);</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from fulltext_test </span><br><span class="line">    where match(content,tag) against(&#39;xxx xxx&#39;);</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;starzhou&#x2F;article&#x2F;details&#x2F;87519973?ops_request_misc&#x3D;%25257B%252522request%25255Fid%252522%25253A%252522160829400716780274055349%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&amp;request_id&#x3D;160829400716780274055349&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-87519973.nonecase&amp;utm_term&#x3D;%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95</span><br></pre></td></tr></table></figure><ol start="4"><li>空间数据索引</li></ol><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>联合索引是指对表上的多个列进行索引，联合索引也是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2.</p><p><img src="https://img-blog.csdn.net/20180807153551287?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtMTA2MDg5MTI2NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h2 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h2><p>顾名思义是最左优先，以最左边的为起点任何连续的索引都能匹配上.(A,B,C) 这样3列，mysql会首先匹配A，然后再B，C.</p><p>如果用(B,C)这样的数据来检索的话，就会找不到A使得索引失效。</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引包含所有需要查询的字段的值,不需要回表操作。<br>具有以下优点：<br>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。<br>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以<br>不使用系统调用（通常比较费时）。<br>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</p><h2 id="什么情况下不应该用索引？"><a href="#什么情况下不应该用索引？" class="headerlink" title="什么情况下不应该用索引？"></a>什么情况下不应该用索引？</h2><h4 id="1-被频繁更新的字段应该慎重建立索引"><a href="#1-被频繁更新的字段应该慎重建立索引" class="headerlink" title="1.被频繁更新的字段应该慎重建立索引"></a>1.被频繁更新的字段应该慎重建立索引</h4><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><h4 id="2-不被经常查询的字段没有必要建立索引"><a href="#2-不被经常查询的字段没有必要建立索引" class="headerlink" title="2.不被经常查询的字段没有必要建立索引"></a>2.不被经常查询的字段没有必要建立索引</h4><h3 id="3-数据量不大"><a href="#3-数据量不大" class="headerlink" title="3.数据量不大"></a>3.数据量不大</h3><h4 id="4-注意避免冗余索引"><a href="#4-注意避免冗余索引" class="headerlink" title="4.注意避免冗余索引"></a>4.注意避免冗余索引</h4><p>冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。.尽可能的考虑建立联合索引而不是单列索引</p><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p><h4 id="5-考虑在字符串类型的字段上使用前缀索引代替普通索引"><a href="#5-考虑在字符串类型的字段上使用前缀索引代替普通索引" class="headerlink" title="5.考虑在字符串类型的字段上使用前缀索引代替普通索引"></a>5.考虑在字符串类型的字段上使用前缀索引代替普通索引</h4><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p><h2 id="适合创建索引条件"><a href="#适合创建索引条件" class="headerlink" title="适合创建索引条件"></a>适合创建索引条件</h2><h4 id="1-不为NULL的字段"><a href="#1-不为NULL的字段" class="headerlink" title="1.不为NULL的字段"></a>1.不为NULL的字段</h4><p>索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为NULL，建议使用0,1,true,false这样语义较为清晰的短值或短字符作为替代。</p><h4 id="2-被频繁查询的字段"><a href="#2-被频繁查询的字段" class="headerlink" title="2.被频繁查询的字段"></a>2.被频繁查询的字段</h4><p>我们创建索引的字段应该是查询操作非常频繁的字段。</p><h4 id="3-被作为条件查询的字段"><a href="#3-被作为条件查询的字段" class="headerlink" title="3.被作为条件查询的字段"></a>3.被作为条件查询的字段</h4><p>被作为WHERE条件查询的字段，应该被考虑建立索引。</p><h4 id="4-被经常频繁用于连接的字段"><a href="#4-被经常频繁用于连接的字段" class="headerlink" title="4.被经常频繁用于连接的字段"></a>4.被经常频繁用于连接的字段</h4><p>经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p><h3 id="创建联合索引应该注意什么？"><a href="#创建联合索引应该注意什么？" class="headerlink" title="创建联合索引应该注意什么？"></a>创建联合索引应该注意什么？</h3><p>1.最左匹配</p><p>2.选择性最大的</p><p>3.频繁查询</p><h3 id="索引为NULL"><a href="#索引为NULL" class="headerlink" title="索引为NULL"></a>索引为NULL</h3><p>   a.单列索引无法储null值，复合索引无法储全为null的值。</p><p>   b.查询时，采用is null条件时，不能利用到索引，只能全表扫描。</p><p>   <strong>为什么索引列无法存储Null值？</strong></p><p>​     a.索引是有序的。NULL值进入索引时，无法确定其应该放在哪里。（将索引列值进行建树，其中必然涉及到诸多的比较操作，null 值是不确定值无法比较，无法确定null出现在索引树的叶子节点位置。）　</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死是指两个或多个事务在同一资源上相互占用，并请求锁定对方资源，从而导致恶性循环的现象。<br>解决方法：<br>如果不同事务并发存取多个表，尽量约定相同的顺序来访问表，可以降低死锁的机会<br>在同一个事务中，尽量做到一次锁定所需要的所有资源，减少死锁的概率<br>对于容易产生死锁的业务，可以用表级锁来减少死锁的概率</p><h2 id="场景提"><a href="#场景提" class="headerlink" title="场景提"></a>场景提</h2><p>mysql场景题，userid order time(时间戳) </p><p>  (1)查询某一用户某一天的订单 </p><p>  (2)查询某一天的订单 </p><p>  (3)查询 某一用户某几天的订单 </p><p>  (3)查询某几天的订单</p><p>  怎么建立索引，sql语句</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>TEXT,或者很长的VARCHAR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 计算出完整字符串的选择性(图4)</span><br><span class="line">SELECT COUNT(DISTINCT city)&#x2F;COUNT(*) FROM city_demo;</span><br><span class="line">-- 计算各个前缀的选择性(图5)，然后找出选择性与图4相近的</span><br><span class="line">SELECT </span><br><span class="line">COUNT(DISTINCT LEFT(city,3))&#x2F;COUNT(*) pref3,</span><br><span class="line">COUNT(DISTINCT LEFT(city,4))&#x2F;COUNT(*) pref4,</span><br><span class="line">COUNT(DISTINCT LEFT(city,5))&#x2F;COUNT(*) pref5,</span><br><span class="line">COUNT(DISTINCT LEFT(city,6))&#x2F;COUNT(*) pref6,</span><br><span class="line">COUNT(DISTINCT LEFT(city,7))&#x2F;COUNT(*) pref7</span><br><span class="line">FROM city_demo;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#96;city_demo&#96; ADD KEY &#96;idx_city&#96; (&#96;city&#96;(7))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聚簇索引和非聚簇索引</title>
      <link href="/2020/06/30/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
      <url>/2020/06/30/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="聚集索引（聚簇索引）："><a href="#聚集索引（聚簇索引）：" class="headerlink" title="聚集索引（聚簇索引）："></a>聚集索引（聚簇索引）：</h3><p>以innodb作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。这种以主键作为B+树索引的键值而构建的B+树索引，我们称之为聚集索引。 </p><h3 id="非聚集索引（非聚簇索引）："><a href="#非聚集索引（非聚簇索引）：" class="headerlink" title="非聚集索引（非聚簇索引）："></a>非聚集索引（非聚簇索引）：</h3><p>以主键以外的列值作为键值构建的B+树索引，我们称之为非聚集索引。非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。</p><p><img src="/2020/06/30/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200630104400532.png" alt="image-20200630104400532"></p><p><img src="file:///C:/Users/77406/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一条SQL语句执行很慢的原因有哪些</title>
      <link href="/2020/06/30/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
      <url>/2020/06/30/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><img src="/2020/06/30/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201206211548896.png" alt="image-20201206211548896"></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>slow_query_log  ：是否开启慢查询日志，1表示开启，0表示关闭。</p><p>long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show variables  like &#39;%slow_query_log%&#39;;&#x2F;&#x2F;慢查询日志是否开启</span><br><span class="line">set global slow_query_log&#x3D;1;</span><br><span class="line">show variables like &#39;slow_query_log_file&#39;;&#x2F;&#x2F;路径</span><br><span class="line">show variables like &#39;long_query_time%&#39;;&#x2F;&#x2F;查询慢查询日志的时间</span><br><span class="line">set global long_query_time&#x3D;4;</span><br></pre></td></tr></table></figure><p>在MySQL里面执行下面SQL语句，然后我们去检查对应的慢查询日志，就会发现类似下面这样的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sleep(3);</span><br><span class="line">+----------+</span><br><span class="line">| sleep(3) |</span><br><span class="line">+----------+</span><br><span class="line">|        0 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (3.00 sec)</span><br><span class="line"> </span><br><span class="line">[root@DB-Server ~]# more &#x2F;tmp&#x2F;mysql_slow.log</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;mysqld, Version: 5.6.20-enterprise-commercial-advanced-log (MySQL Enterprise Server - Advanced Edition (Commercial)). started with:</span><br><span class="line">Tcp port: 0  Unix socket: (null)</span><br><span class="line">Time                 Id Command    Argument</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;mysqld, Version: 5.6.20-enterprise-commercial-advanced-log (MySQL Enterprise Server - Advanced Edition (Commercial)). started with:</span><br><span class="line">Tcp port: 0  Unix socket: (null)</span><br><span class="line">Time                 Id Command    Argument</span><br><span class="line"># Time: 160616 17:24:35</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:     5</span><br><span class="line"># Query_time: 3.002615  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 0</span><br><span class="line">SET timestamp&#x3D;1466069075;</span><br><span class="line">select sleep(3);</span><br></pre></td></tr></table></figure><p><img src="https://images2015.cnblogs.com/blog/73542/201606/73542-20160617103137557-2127639925.png" alt="image"></p><p>Rows_examined显示扫描了50000行</p><p><img src="/2020/06/30/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201210203818105.png" alt="image-20201210203818105"></p><h3 id="Show-processList"><a href="#Show-processList" class="headerlink" title="Show processList"></a>Show processList</h3><p>state 一般取值为休眠（sleep），查询（query）连接（connect）等</p><p>Waiting for table metadata lock</p><p>，现在有一个线程正在表t上请求或者持有MDL写锁</p><p><img src="/2020/06/30/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201210203457177.png" alt="image-20201210203457177"></p><h3 id="Show-profile"><a href="#Show-profile" class="headerlink" title="Show profile"></a>Show profile</h3><ol><li><p>查看是否打开了性能分析功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@profiling;1</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20170330152453721?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl0dGxlYm95YW5kZ2lybA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>打开 profiling 功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set profiling&#x3D;1;1</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20170330152715971?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl0dGxlYm95YW5kZ2lybA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>执行sql语句<br><img src="https://img-blog.csdn.net/20170330152919615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl0dGxlYm95YW5kZ2lybA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>执行 show profiles 查看分析列表<br><img src="https://img-blog.csdn.net/20170330153038411?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl0dGxlYm95YW5kZ2lybA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li><li><p>查询第二条语句的执行情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profile for query 2;1</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20170330153229146?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl0dGxlYm95YW5kZ2lybA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li></ol><ul><li><p>Status ： sql 语句执行的状态</p></li><li><p>Duration: sql 执行过程中每一个步骤的耗时</p></li><li><p>CPU_user: 当前用户占有的 cpu</p></li><li><p>CPU_system: 系统占有的 cpu</p></li><li><p>Block_ops_in : I/O 输入</p></li><li><p>Block_ops_out : I/O 输出</p></li></ul><p>status的相关字段</p><p>  Sorting result</p><blockquote><p>正在对结果进行排序，类似Creating sort index，不过是正常表，而不是在内存表中进行排序。<br><code>建议</code>：创建适当的索引</p></blockquote><ul><li>Table lock</li></ul><blockquote><p>表级锁，没什么好说的，要么是因为MyISAM引擎表级锁，要么是其他情况显式锁表</p></blockquote><ul><li>create sort index</li></ul><blockquote><p>当前的SELECT中需要用到临时表在进行ORDER BY排序<br><code>建议</code>：创建适当的索引</p></blockquote><ul><li>Creating tmp table</li></ul><blockquote><p>创建临时表。先拷贝数据到临时表，用完后再删除临时表。消耗内存，数据来回拷贝删除，消耗时间，<code>建议</code>：优化索引</p></blockquote><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><hr><p>是一组数字，代表多个表之间的查询顺序，或者包含子句查询语句中的顺序，id 总共分为三种情况，依次详解</p><ul><li>id 相同，执行顺序由上至下<img src="https://user-gold-cdn.xitu.io/2020/7/7/17328ce200665389?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></li><li>id 不同，如果是子查询，id 号会递增，id 值越大优先级越高，越先被执行<img src="https://user-gold-cdn.xitu.io/2020/7/7/17328ce200736a09?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></li><li>id 相同和不同的情况同时存在<img src="https://user-gold-cdn.xitu.io/2020/7/7/17328ce2006becf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></li></ul><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>查询类型，有简单查询、联合查询、子查询等</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的select查询中不好喊子查询或者UNION</td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子部分,最外层查询则被标记为</td></tr><tr><td>SUBQUERY</td><td>在SELECT或WHERE列表中包含了子查询</td></tr><tr><td>DERIVED(衍生)</td><td>在FROM列表中包含的子查询被标记为DERIVED(衍生). MySQL会递归执行这些子查询, 把结果放在临时表里。</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则被标记为UNION</td></tr><tr><td>UNION RESULT</td><td>从UNION表获取结果的SELECT</td></tr></tbody></table><p>(考虑)</p><h3 id="type"><a href="#type" class="headerlink" title="type:"></a>type:</h3><p>对表访问方式</p><p>NULL&gt;system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p><p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p><h4 id="System与-const"><a href="#System与-const" class="headerlink" title="System与 const"></a>System与 const</h4><p> <strong>说明:</strong><br>  <code>System</code>:表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计<br>  <code>const</code>:表示通过索引一次就找到了. <code>const</code>用于比较<code>primary key</code>或者<code>unique</code>索引。因为只匹配一行数据，所以很快. 如将主键置于where列表中，MySQL就能将该查询转换为一个常量<br> <strong>脚本:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select * from (select * from actor t1 where t1.id &#x3D; 1) s1 ;</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p> <strong>执行结果:</strong><br><img src="https://img-blog.csdnimg.cn/2020022914442552.png" alt="在这里插入图片描述"></p><h4 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h4><p> <strong>说明:</strong><br>   唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描<br> <strong>脚本:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select * from actor t1 left join film_actor t2 on t2.id &#x3D;  t1.id ;</span><br></pre></td></tr></table></figure><p> <strong>执行结果:</strong><br><img src="https://img-blog.csdnimg.cn/20200229150731506.png" alt="在这里插入图片描述"></p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p> <strong>说明:</strong><br>   非唯一性索引扫描，返回匹配某个单独值的所有行. 本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</p><blockquote><p>表示的是联合索引.</p></blockquote><p> <strong>脚本:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select count(distinct actor_id) from film_actor t1 where t1.actor_id &#x3D; 1</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p> <strong>执行结果:</strong><br><img src="https://img-blog.csdnimg.cn/20200229151222974.png" alt="在这里插入图片描述"></p><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p> <strong>说明:</strong></p><ol><li>只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引</li><li>一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询</li><li>这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</li></ol><p> <strong>脚本:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select t1.* from actor t1 where t1.id between 1 and 3</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p> <strong>执行结果:</strong><br><img src="https://img-blog.csdnimg.cn/20200229151355222.png" alt="在这里插入图片描述"></p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常为ALL块，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取）</p><p><img src="https://img-blog.csdn.net/20170512152255874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h4><p>Full Table Scan，遍历全表以找到匹配的行</p><p><img src="https://img-blog.csdn.net/20170512152537516?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="key-len列"><a href="#key-len列" class="headerlink" title="key_len列"></a><code>key_len</code>列</h2><p> <strong>说明:</strong><br> <code>Key_len</code>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好<br><code>key_len</code>显示的值为索引字段的最大可能长度，并非实际使用长度</p><h2 id="Rows-列"><a href="#Rows-列" class="headerlink" title="Rows 列"></a><code>Rows</code> 列</h2><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain </span><br><span class="line">select * from actor t1 , film_actor t2 where t1.id &#x3D; t2.actor_id and t2.film_id&#x3D;2</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p> <strong>执行结果:</strong><br><img src="https://img-blog.csdnimg.cn/20200229233505469.png" alt="在这里插入图片描述"></p><h2 id="Extra-列"><a href="#Extra-列" class="headerlink" title="Extra 列"></a><code>Extra</code> 列</h2><p>filesort只能应用在单个表上，如果有多个表的数据需要排序，那么MySQL会先使用using temporary保存临时数据，然后再在临时表上使用filesort进行排序，最后输出结果。</p><p> 包含不适合在其它列中显示但十分重要的额外信息</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Using filesort</td><td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为”文件排序”</td></tr><tr><td>Using temporary</td><td>使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</td></tr><tr><td>Using index</td><td>表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！   如果同时出现using where，表明索引被用来执行索引键值的查找;   如果没有同时出现using where，表明索引用来读取数据而非执行查找动作</td></tr><tr><td>Using where</td><td>使用了where条件</td></tr><tr><td>Using join buffer</td><td>使用了连接缓存</td></tr><tr><td>impossible where</td><td>where子句的值总是false,不能用来获取任何元素</td></tr><tr><td>distinct</td><td>一单mysql找到了与形相联合匹配的行,就不在搜索了</td></tr></tbody></table><h3 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a><code>Using filesort</code></h3><p> <strong>说明:</strong><br>  说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<br>  MySQL中无法利用索引完成的排序操作称为“文件排序”</p><blockquote><p><strong>当发现有Using filesort 后，实际上就是发现了可以优化的地方</strong></p></blockquote><p> <strong>脚本:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain </span><br><span class="line">select * from film_actor t1 where t1.film_id&#x3D;1 order by t1.actor_id</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p> <strong>执行结果:</strong><br><img src="https://img-blog.csdnimg.cn/20200229235018532.png" alt="在这里插入图片描述"><br> <strong>解说:</strong><br>  上图其实是一种索引失效的情况，后面会讲，可以看出查询中用到了个联合索引，索引分别为actor_id,film_id</p><h3 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="Using temporary"></a><code>Using temporary</code></h3><p> <strong>说明:</strong><br>   使用了临时表保存中间结果，MySQL在对结果排序时使用临时表，常见于排序order by 和分组查询group by<br> <strong>脚本:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain </span><br><span class="line">select * from film_actor t1 where t1.film_id&#x3D;1 group by t1.remark</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p> <strong>执行结果:</strong><br><img src="https://img-blog.csdnimg.cn/20200301093251626.png" alt="在这里插入图片描述"><br> <strong>解说:</strong><br>  <strong>尤其发现在执行计划里面有using filesort而且还有Using temporary的时候，特别需要注意</strong></p><h3 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a><code>Using index</code></h3><p> <strong>说明:</strong><br>表示相应的select操作中使用了覆盖索引（Covering Index）,避免访问了表的数据行，效率不错！<br><strong>如果同时出现using where，表明索引被用来执行索引键值的查找</strong><br> <strong>脚本:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film t1 <span class="keyword">where</span> t1.name=<span class="string">"我的快乐购"</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p> <strong>执行结果:</strong><br><img src="https://img-blog.csdnimg.cn/20200301093635285.png" alt="在这里插入图片描述"><br><strong>如果没有同时出现using where，表明索引用来读取数据而非执行查找动作</strong></p><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><ol><li>切分大查询<br>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要<br>的查询。</li><li>分解大连接查询<br> 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：<br> 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查<br> 询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。<br> 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。<br> 减少锁竞争；<br> 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。<br> 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进<br> 行查询，这可能比随机的连接要更高效。</li></ol><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><ol><li>减少请求的数据量<br>只返回必要的列：最好不要使用 SELECT * 语句。<br>只返回必要的行：使用 LIMIT 语句来限制返回的数据。<br>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存<br>带来的查询性能提升将会是非常明显的。</li><li>减少服务器端扫描的行数<br>最有效的方式是使用索引来覆盖查询。</li></ol><h4 id="应该做的原则："><a href="#应该做的原则：" class="headerlink" title="应该做的原则："></a>应该做的原则：</h4><h5 id="联合索引最左前缀原则"><a href="#联合索引最左前缀原则" class="headerlink" title="联合索引最左前缀原则"></a>联合索引最左前缀原则</h5><p>复合索引遵守「最左前缀」原则，查询条件中，使用了复合索引前面的字段，索引才会被使用，如果不是按照索引的最左列开始查找，则无法使用索引。</p><p>比如在(a,b,c)三个字段上建立联合索引，那么它能够加快a|(a,b)|(a,b,c)三组查询的速度，而不能加快b|(b,a)这种查询顺序。</p><p>另外，建联合索引的时候，区分度最高的字段在最左边。</p><h5 id="使用覆盖索引"><a href="#使用覆盖索引" class="headerlink" title="使用覆盖索引"></a>使用覆盖索引</h5><p>所谓覆盖索引，是指被查询的列，数据能从索引中取得，而不用通过行定位符再到数据表上获取，能够极大的提高性能。</p><p>可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。</p><h5 id="范围列可以用到索引"><a href="#范围列可以用到索引" class="headerlink" title="范围列可以用到索引"></a>范围列可以用到索引</h5><p>范围条件有：&lt;、&lt;=、&gt;、&gt;=、between等。</p><p>范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。</p><h5 id="如果出现了filesort"><a href="#如果出现了filesort" class="headerlink" title="如果出现了filesort"></a>如果出现了filesort</h5><p>order by也是遵循索引原则的，使用索引进行排序</p><h4 id="不应该做的原则："><a href="#不应该做的原则：" class="headerlink" title="不应该做的原则："></a>不应该做的原则：</h4><h5 id="不要在列上使用函数和进行运算"><a href="#不要在列上使用函数和进行运算" class="headerlink" title="不要在列上使用函数和进行运算"></a>不要在列上使用函数和进行运算</h5><p>不要在列上使用函数，这将导致索引失效而进行全表扫描。</p><p>例如下面的 SQL 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from artile where YEAR(create_time) &lt;&#x3D; &#39;2018&#39;; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>即使 date 上建立了索引，也会全表扫描，可以把计算放到业务层，这样做不仅可以节省数据库的 CPU，还可以起到查询缓存优化效果。</p><h5 id="负向条件查询不能使用索引"><a href="#负向条件查询不能使用索引" class="headerlink" title="负向条件查询不能使用索引"></a>负向条件查询不能使用索引</h5><p>负向条件有：!=、&lt;&gt;、not in、not exists、not like 等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from artile where status !&#x3D; 1 and status !&#x3D; 2;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以使用in进行优化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from artile where status in (0,3)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="更新频繁、数据区分度不高的字段上不宜建立索引"><a href="#更新频繁、数据区分度不高的字段上不宜建立索引" class="headerlink" title="更新频繁、数据区分度不高的字段上不宜建立索引"></a>更新频繁、数据区分度不高的字段上不宜建立索引</h5><p>更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能。</p><p>「性别」这种区分度不大的属性，建立索引没有意义，不能有效过滤数据，性能与全表扫描类似。</p><p>区分度可以使用 count(distinct(列名))/count(*) 来计算，在80%以上的时候就可以建立索引。</p><h5 id="索引列不允许为null"><a href="#索引列不允许为null" class="headerlink" title="索引列不允许为null"></a>索引列不允许为null</h5><p>单列索引不存null值，复合索引不存全为null的值，如果列允许为 null，可能会得到不符合预期的结果集。</p><h5 id="避免使用or来连接条件"><a href="#避免使用or来连接条件" class="headerlink" title="避免使用or来连接条件"></a>避免使用or来连接条件</h5><p>应该尽量避免在 where 子句中使用 or 来连接条件，因为这会导致索引失效而进行全表扫描，虽然新版的MySQL能够命中索引，但查询优化耗费的 CPU比in多。</p><h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><p>前导模糊查询不能使用索引，非前导查询可以。</p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>数据库中的数据量不一定是可控的，在未进行分库分表的情况下，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地，数据操作，增删改查的开销也会越来越大；另外，由于无法进行分布式式部署，而一台服务器的资源（CPU、磁盘、内存、IO等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。</p><h4 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h4><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p> explain 每个列代表什么含义（关于优化级别 ref 和 all，什么时候应该用到index却没用到，关于extra列出现了usetempory 和 filesort分别的原因和如何着手优化等） </p><p> show profile 怎么使用。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>reentranlock底层原理</title>
      <link href="/2020/06/30/reentranlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2020/06/30/reentranlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><p>首先<code>ReentrantLock</code>继承自父类<code>Lock</code>，然后有<code>3</code>个内部类，其中中有一个抽象内部类Sync继承AQS，两个内部类NonfairSync和FairSync继承了Sync(Sync重写tryRelease），重写了lock()方法和tryAcquire()方法，分别实现了非公平锁和公平锁。<br><img src="https://uploadfiles.nowcoder.com/files/20191214/592649258_1576325730428_2019121410495622.png" alt="在这里插入图片描述"><br>ReentrantLock默认为非公平锁，如果想创建公平锁，可给构造方法传入参数true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code>有两个构造方法，无参构造方法默认是创建<strong>非公平锁</strong>，而传入<code>true</code>为参数的构造方法创建的是<strong>公平锁</strong>。</p><h3 id="非公平锁的实现原理"><a href="#非公平锁的实现原理" class="headerlink" title="非公平锁的实现原理"></a>非公平锁的实现原理</h3><p>当我们使用无参构造方法构造的时候即<code>ReentrantLock lock = new ReentrantLock()</code>，创建的就是非公平锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者传入false参数 创建的也是非公平锁</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="lock方法获取锁"><a href="#lock方法获取锁" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol><li><code>lock</code>方法调用<code>CAS</code>方法设置<code>state</code>的值，如果<code>state</code>等于期望值<code>0</code>(代表锁没有被占用)，那么就将<code>state</code>更新为<code>1</code>(代表该线程获取锁成功)，然后执行<code>setExclusiveOwnerThread</code>方法直接将该线程设置成锁的所有者。如果<code>CAS</code>设置<code>state</code>的值失败，即<code>state</code>不等于<code>0</code>，代表锁正在被占领着，则执行<code>acquire(1)</code>，即下面的步骤。</li><li><code>nonfairTryAcquire</code>方法首先调用<code>getState</code>方法获取<code>state</code>的值，如果<code>state</code>的值为<code>0</code>(之前占领锁的线程刚好释放了锁)，那么用<code>CAS</code>设置<code>state</code>的值，设置成功则将该线程设置成锁的所有者，并且返回<code>true</code>。如果<code>state</code>的值不为<code>0</code>，那就<strong>调用<code>getExclusiveOwnerThread</code>方法查看占用锁的线程是不是自己</strong>，如果是的话那就直接将<code>state + 1</code>，然后返回<code>true</code>。如果<code>state</code>不为<code>0</code>且锁的所有者又不是自己，那就返回<code>false</code>，<strong>然后线程会进入到同步队列中</strong>。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">作者：冠状病毒biss</span><br><span class="line">链接：https:&#x2F;&#x2F;www.nowcoder.com&#x2F;discuss&#x2F;355081?type&#x3D;post&amp;order&#x3D;time&amp;pos&#x3D;&amp;page&#x3D;1&amp;channel&#x3D;0&amp;source_id&#x3D;search_post</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">弊端：可能导致排队的线程一直无法得到CPU资源的饥饿现象</span><br><span class="line">public void lock() &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line">1.调用NofairSync中的lock方法</span><br><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))&#x2F;&#x2F;AQS类的方法 使用CAS算法更新state的值</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());&#x2F;&#x2F;若更新成功设置当前线程为独占线程c</span><br><span class="line">    else</span><br><span class="line">        acquire(1);&#x2F;&#x2F;若CAS更新失败，执行是AQS类的acquire()方法</span><br><span class="line">&#125;</span><br><span class="line">2.AQS中的acquire()方法</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">if (!tryAcquire(arg) &amp;&amp;&#x2F;&#x2F;尝试获取锁 失败则调用addWaiter方法创建结点并追加到队列尾部</span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&#x2F;&#x2F;然后调用acquireQueued阻塞或者自旋尝试获取锁</span><br><span class="line">    selfInterrupt();&#x2F;&#x2F;在 acquireQueued 中，如果线程是因为中断而退出的阻塞状态会返回true</span><br><span class="line">    &#125;</span><br><span class="line">   3.Nofair中的tryAcquire()重写</span><br><span class="line">   protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;如果当前state值为0 并CAS操作成功 独占锁 返回true</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F;否则判断当前线程是否是持有锁的那个独占线程</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;&#x2F;&#x2F;相当于重入锁</span><br><span class="line">        int nextc &#x3D; c + acquires;&#x2F;&#x2F;是将state值更新</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; 假如超过最大可重入次数</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;&#x2F;&#x2F;state不为0，并且不是那个持有锁的线程 返回false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tryRelease锁的释放"><a href="#tryRelease锁的释放" class="headerlink" title="tryRelease锁的释放"></a>tryRelease锁的释放</h4><ol><li>判断当前线程是不是锁的所有者，如果是则进行步骤<code>2</code>，如果不是则抛出异常。</li><li>判断此次释放锁后<code>state</code>的值是否为0，如果是则代表<strong>锁没有重入</strong>，然后将锁的所有者设置成<code>null</code>且返回<code>true</code>，然后执行步骤<code>3</code>，如果不是则<strong>代表锁发生了重入</strong>执行步骤<code>4</code>。</li><li>现在锁已经释放完，即<code>state=0</code>，唤醒同步队列中的后继节点进行锁的获取。</li><li>锁还没有释放完，即<code>state!=0</code>，不唤醒同步队列。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169aad4a8e578933?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;子类重写的tryRelease方法，需要等锁的state&#x3D;0，即tryRelease返回true的时候，才会去唤醒其</span><br><span class="line">    &#x2F;&#x2F;它线程进行尝试获取锁。</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F;状态的state减去releases</span><br><span class="line">    int c &#x3D; getState() - releases;</span><br><span class="line">    &#x2F;&#x2F;判断锁的所有者是不是该线程</span><br><span class="line">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">        &#x2F;&#x2F;如果所的所有者不是该线程 则抛出异常 也就是锁释放的前提是线程拥有这个锁，</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;如果该线程释放锁之后 状态state&#x3D;0，即锁没有重入，那么直接将将锁的所有者设置成null</span><br><span class="line">    &#x2F;&#x2F;并且返回true，即代表可以唤醒其他线程去获取锁了。如果该线程释放锁之后state不等于0，</span><br><span class="line">    &#x2F;&#x2F;那么代表锁重入了，返回false，代表锁还未正在释放，不用去唤醒其他线程。</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        free &#x3D; true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="公平锁的实现原理"><a href="#公平锁的实现原理" class="headerlink" title="公平锁的实现原理"></a>公平锁的实现原理</h3><h4 id="lock方法获取锁-1"><a href="#lock方法获取锁-1" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol><li>获取状态的<code>state</code>的值，如果<code>state=0</code>即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，执行步骤<code>2</code>。如果<code>state!=0</code>则代表锁正在被其它线程占用，执行步骤<code>3</code>。</li><li><strong>判断同步队列是否存在线程(节点)，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。</strong></li><li><strong>判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中</strong></li></ol><p>通过步骤<code>2</code><strong>实现了锁获取的公平性，即锁的获取按照先来先得的顺序，后来的不能抢先获取锁，非公平锁和公平锁也正是通过这个区别来实现了锁的公平性。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169aaf5a27ee58d5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;同步队列中有线程 且 锁的所有者不是当前线程那么将线程加入到同步队列的尾部，</span><br><span class="line">    &#x2F;&#x2F;保证了公平性，也就是先来的线程先获得锁，后来的不能抢先获取。</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    &#x2F;&#x2F;判断状态state是否等于0，等于0代表锁没有被占用，不等于0则代表锁被占用着。</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;调用hasQueuedPredecessors方法判断同步队列中是否有线程在等待，如果同步队列中没有</span><br><span class="line">        &#x2F;&#x2F;线程在等待 则当前线程成为锁的所有者，如果同步队列中有线程在等待，则继续往下执行</span><br><span class="line">        &#x2F;&#x2F;这个机制就是公平锁的机制，也就是先让先来的线程获取锁，后来的不能抢先获取。</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断当前线程是否为锁的所有者，如果是，那么直接更新状态state，然后返回true。</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果同步队列中有线程存在 且 锁的所有者不是当前线程，则返回false。</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="tryRelease锁的释放-1"><a href="#tryRelease锁的释放-1" class="headerlink" title="tryRelease锁的释放"></a>tryRelease锁的释放</h4><p>公平锁的释放和非公平锁的释放一样，这里就不重复。<br> 公平锁和非公平锁的公平性是在<strong>获取锁</strong>的时候体现出来的，释放的时候都是一样释放的。</p><h3 id="ReentrantLock的等待-通知机制"><a href="#ReentrantLock的等待-通知机制" class="headerlink" title="ReentrantLock的等待/通知机制"></a>ReentrantLock的等待/通知机制</h3><p>我们知道关键字<code>Synchronized</code> + <code>Object</code>的<code>wait</code>和<code>notify</code>、<code>notifyAll</code>方法能实现<strong>等待/通知</strong>机制，那么<code>ReentrantLock</code>是否也能实现这样的等待/通知机制，答案是：可以。<br> <code>ReentrantLock</code>通过<code>Condition</code>对象，也就是<strong>条件队列</strong>实现了和<code>wait</code>、<code>notify</code>、<code>notifyAll</code>相同的语义。 线程执行<code>condition.await()</code>方法，将节点1从同步队列转移到条件队列中。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b3432b128105d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>线程执行<code>condition.signal()</code>方法，将节点1从条件队列中转移到同步队列。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b3411b74cfff1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>因为只有在同步队列中的线程才能去获取锁，所以通过<code>Condition</code>对象的<code>wait</code>和<code>signal</code>方法能实现等待/通知机制。<br> 代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">Condition condition &#x3D; lock.newCondition();</span><br><span class="line">public void await() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;线程获取锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">        condition.await(); &#x2F;&#x2F;调用await()方法 会释放锁，和Object.wait()效果一样。</span><br><span class="line">        System.out.println(&quot;线程被唤醒----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(&quot;线程释放锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void signal() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(1000);  &#x2F;&#x2F;休眠1秒钟 等等一个线程先执行</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;另外一个线程获取到锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">        condition.signal();</span><br><span class="line">        System.out.println(&quot;唤醒线程----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(&quot;另外一个线程释放锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Test t &#x3D; new Test();</span><br><span class="line">    Thread t1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            t.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            t.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程获取锁----Thread-0</span><br><span class="line">另外一个线程获取到锁----Thread-1</span><br><span class="line">唤醒线程----Thread-1</span><br><span class="line">另外一个线程释放锁----Thread-1</span><br><span class="line">线程被唤醒----Thread-0</span><br><span class="line">线程释放锁----Thread-0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>执行的流程大概是这样，线程<code>t1</code>先获取到锁，输出了”线程获取锁—-Thread-0”，然后线程<code>t1</code>调用<code>await</code>方法，调用这个方法的结果就是<strong>线程<code>t1</code>释放了锁进入等待状态，等待唤醒</strong>，接下来线程<code>t2</code>获取到锁，然输出了”另外一个线程获取到锁—-Thread-1”，同时线程<code>t2</code>调用<code>signal</code>方法，调用这个方法的结果就是<strong>唤醒一个在条件队列(Condition)的线程，然后线程<code>t1</code>被唤醒，而这个时候线程<code>t2</code>并没有释放锁，线程<code>t1</code>也就没法获得锁，等线程<code>t2</code>继续执行输出”唤醒线程—-Thread-1”之后线程<code>t2</code>释放锁且输出”另外一个线程释放锁—-Thread-1”，这时候线程<code>t1</code>获得锁，继续往下执行输出了<code>线程被唤醒----Thread-0</code>，然后释放锁输出”线程释放锁—-Thread-0”</strong>。</p><p>如果想单独唤醒部分线程应该怎么做呢？这时就有必要使用多个<code>Condition</code>对象了，因为<code>ReentrantLock</code>支持创建多个<code>Condition</code>对象，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;为了减少篇幅 仅给出伪代码</span><br><span class="line">ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">Condition condition &#x3D; lock.newCondition();</span><br><span class="line">Condition condition1 &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程1 调用condition.await() 线程进入到条件队列</span><br><span class="line">condition.await();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程2 调用condition1.await() 线程进入到条件队列</span><br><span class="line">condition1.await();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程32 调用condition.signal() 仅唤醒调用condition中的线程，不会影响到调用condition1。</span><br><span class="line">condition1.await();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就实现了部分唤醒的功能。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><h3 id="和synchronized的对比"><a href="#和synchronized的对比" class="headerlink" title="和synchronized的对比"></a>和synchronized的对比</h3><ol><li>锁的实现<br>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li><li>性能<br>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</li><li>等待可中断<br>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<br>ReentrantLock 可中断，而 synchronized 不行。</li><li>公平锁<br>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<br>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</li><li>锁绑定多个条件<br>一个 ReentrantLock 可以同时绑定多个 Condition 对象。<br>使用选择<br>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一<br>种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没<br>有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</li></ol><p>可中断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class hhh &#123;</span><br><span class="line">    static class ThreadDemo implements Runnable &#123;</span><br><span class="line">        Lock firstLock;</span><br><span class="line">        Lock secondLock;</span><br><span class="line">        public ThreadDemo(Lock firstLock, Lock secondLock) &#123;</span><br><span class="line">            this.firstLock &#x3D; firstLock;</span><br><span class="line">            this.secondLock &#x3D; secondLock;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                firstLock.lockInterruptibly();</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(50);</span><br><span class="line">                secondLock.lockInterruptibly();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                firstLock.unlock();</span><br><span class="line">                secondLock.unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                        +&quot;获取到了资源，正常结束!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static Lock lock1 &#x3D; new ReentrantLock();</span><br><span class="line">    static Lock lock2 &#x3D; new ReentrantLock();</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(new ThreadDemo(lock1, lock2));</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new ThreadDemo(lock2, lock1));</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread.interrupt();&#x2F;&#x2F;是第一个线程中断</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：薛8<br>链接：<a href="https://juejin.im/post/5c95df97e51d4551d06d8e8e" target="_blank" rel="noopener">https://juejin.im/post/5c95df97e51d4551d06d8e8e</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">https://www.javadoop.com/post/AbstractQueuedSynchronizer</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用explain关键字</title>
      <link href="/2020/06/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8explain%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/06/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8explain%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析你的查询语句或是表结构的性能瓶颈。</p><h2 id="explain执行计划包含的信息"><a href="#explain执行计划包含的信息" class="headerlink" title="explain执行计划包含的信息"></a>explain执行计划包含的信息</h2><p><img src="https://img-blog.csdn.net/20170509232741017?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>其中最重要的字段为：id、type、key、rows、Extra</strong></p><p>id:select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p><p>type : 访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是<strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p><p>key : 使用的索引</p><p>rows : 扫描的行数</p><p>Extra:不适合在其他字段中显示，但是十分重要的额外信息(例如覆盖索引等等)</p><table><thead><tr><th>指标名</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>表示 SELECT 子句或操作表的顺序，执行顺序从大到小执行，当 id 一样时，执行顺序从上往下。</td></tr><tr><td>select_type</td><td>表示查询中每个 SELECT 子句的类型，例如 SIMPLE 表示不包含子查询、表连接或其他复杂语法的简单查询，PRIMARY 表示复杂查询的最外层查询，SUBQUERY 表示在 SELECT 或 WHERE 列表中包含了子查询。</td></tr><tr><td>type</td><td>表示访问类型，性能由差到好为：ALL 全表扫描、index 索引全扫描、range 索引范围扫描、ref 返回匹配某个单独值得所有行，常见于使用非唯一索引或唯一索引的非唯一前缀进行的查找，也经常出现在 join 操作中、eq_ref 唯一性索引扫描，对于每个索引键只有一条记录与之匹配、const 当 MySQL 对查询某部分进行优化，并转为一个常量时，使用这些访问类型，例如将主键或唯一索引置于 WHERE 列表就能将该查询转为一个 const、system 表中只有一行数据或空表，只能用于 MyISAM 和 Memory 表、NULL 执行时不用访问表或索引就能得到结果。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是consts 最好。</td></tr><tr><td>possible_keys</td><td>表示查询时可能用到的索引，但不一定使用。列出大量可能索引时意味着备选索引数量太多了。</td></tr><tr><td>key</td><td>显示 MySQL 在查询时实际使用的索引，如果没有使用则显示为 NULL。</td></tr><tr><td>key_len</td><td>表示使用到索引字段的长度，可通过该列计算查询中使用的索引的长度，对于确认索引有效性以及多列索引中用到的列数目很重要。</td></tr><tr><td>ref</td><td>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</td></tr><tr><td>rows</td><td>表示 MySQL 根据表统计信息及索引选用情况，估算找到所需记录所需要读取的行数。</td></tr><tr><td>Extra</td><td>表示额外信息，例如 Using temporary 表示需要使用临时表存储结果集，常见于排序和分组查询。Using filesort 表示无法利用索引完成的文件排序，这是 ORDER BY 的结果，可以通过合适的索引改进性能。Using index 表示只需要使用索引就可以满足查询表得要求，说明表正在使用覆盖索引。</td></tr></tbody></table><h2 id="各字段详解"><a href="#各字段详解" class="headerlink" title="各字段详解"></a>各字段详解</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序<br>三种情况：<br>1、id相同：执行顺序由上至下</p><p><img src="https://img-blog.csdn.net/20170509234043416?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>2、id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p><p><img src="https://img-blog.csdn.net/20170510223451835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3、id相同又不同（两种情况同时存在）：id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p><p><img src="https://img-blog.csdn.net/20170510224901726?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>查询的类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询</p><p>1、SIMPLE：简单的select查询，查询中不包含子查询或者union<br>2、PRIMARY：查询中包含任何复杂的子部分，最外层查询则被标记为primary<br>3、SUBQUERY：在select 或 where列表中包含了子查询<br>4、DERIVED：在from列表中包含的子查询被标记为derived（衍生），mysql或递归执行这些子查询，把结果放在零时表里<br>5、UNION：若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived<br>6、UNION RESULT：从union表获取结果的select</p><p><img src="https://img-blog.csdn.net/20170510231953999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>一般来说，好的sql查询至少达到range级别，最好能达到ref</p><p>1、system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计</p><p>2、const：表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const</p><p><img src="https://img-blog.csdn.net/20170511215148532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3、eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描。</p><p>注意：ALL全表扫描的表记录最少的表如t1表</p><p><img src="https://img-blog.csdn.net/20170512143354425?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>4、ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体</p><p><img src="https://img-blog.csdn.net/20170512150131136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>5、range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、&lt;、&gt;、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引</p><p><img src="https://img-blog.csdn.net/20170512151841933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>6、index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常为ALL块，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取）</p><p><img src="https://img-blog.csdn.net/20170512152255874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>7、ALL：Full Table Scan，遍历全表以找到匹配的行</p><p><img src="https://img-blog.csdn.net/20170512152537516?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>查询涉及到的字段上存在索引，则该索引将被列出，但不一定被查询实际使用</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>实际使用的索引，如果为NULL，则没有使用索引。<br>查询中如果使用了覆盖索引，则该索引仅出现在key列表中</p><p><img src="https://img-blog.csdn.net/20170512155222855?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示索引中使用的字节数，查询中使用的索引的长度（最大可能长度），并非实际使用长度，理论上长度越短越好。key_len是根据表定义计算而得的，不是通过表内检索出的</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>显示索引的那一列被使用了，如果可能，是一个常量const。</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>不适合在其他字段中显示，但是十分重要的额外信息</p><p>1、Using filesort ：<br>mysql对数据使用一个外部的索引排序，而不是按照表内的索引进行排序读取。也就是说mysql无法利用索引完成的排序操作成为“文件排序”</p><p><img src="https://img-blog.csdn.net/20170515175218264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>由于索引是先按email排序、再按address排序，所以查询时如果直接按address排序，索引就不能满足要求了，mysql内部必须再实现一次“文件排序”</p><p>2、Using temporary：<br>使用临时表保存中间结果，也就是说mysql在对查询结果排序时使用了临时表，常见于order by 和 group by</p><p><img src="https://img-blog.csdn.net/20170515180947413?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3、Using index：<br>表示相应的select操作中使用了覆盖索引（Covering Index），避免了访问表的数据行，效率高</p><p><img src="https://img-blog.csdn.net/20170515182415063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">如果同时出现Using where，表明索引被用来执行索引键值的查找（参考上图）<br>如果没用同时出现Using where，表明索引用来读取数据而非执行查找动作</p><p>覆盖索引（Covering Index）：也叫索引覆盖。就是select列表中的字段，只用从索引中就能获取，不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。<br>注意：<br>a、如需使用覆盖索引，select列表中的字段只取出需要的列，不要使用select *<br>b、如果将所有字段都建索引会导致索引文件过大，反而降低crud性能</p><p>4、Using where ：<br>使用了where过滤</p><p>5、Using join buffer ：<br>使用了链接缓存</p><p>6、Impossible WHERE：<br>where子句的值总是false，不能用来获取任何元祖</p><p><img src="https://img-blog.csdn.net/20170515183331598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>7、select tables optimized away：<br>在没有group by子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT（*）操作，不必等到执行阶段在进行计算，查询执行计划生成的阶段即可完成优化</p><p>8、distinct：<br>优化distinct操作，在找到第一个匹配的元祖后即停止找同样值得动作</p><h2 id="综合Case"><a href="#综合Case" class="headerlink" title="综合Case"></a>综合Case</h2><p><img src="https://img-blog.csdn.net/20170516093515092?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VzZXl1a3Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>执行顺序<br>1（id = 4）、【select id, name from t2】：select_type 为union，说明id=4的select是union里面的第二个select。</p><p>2（id = 3）、【select id, name from t1 where address = ‘11’】：因为是在from语句中包含的子查询所以被标记为DERIVED（衍生），where address = ‘11’ 通过复合索引idx_name_email_address就能检索到，所以type为index。</p><p>3（id = 2）、【select id from t3】：因为是在select中包含的子查询所以被标记为SUBQUERY。</p><p>4（id = 1）、【select d1.name, … d2 from … d1】：select_type为PRIMARY表示该查询为最外层查询，table列被标记为 “derived3”表示查询结果来自于一个衍生表（id = 3 的select结果）。</p><p>5（id = NULL）、【 … union … 】：代表从union的临时表中读取行的阶段，table列的 “union 1, 4”表示用id=1 和 id=4 的select结果进行union操作。<br>————————————————<br>版权声明：本文为CSDN博主「走慢一点点」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wuseyukui/article/details/71512793" target="_blank" rel="noopener">https://blog.csdn.net/wuseyukui/article/details/71512793</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前缀树的场景以及实现</title>
      <link href="/2020/06/29/%E5%89%8D%E7%BC%80%E6%A0%91%E7%9A%84%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/06/29/%E5%89%8D%E7%BC%80%E6%A0%91%E7%9A%84%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>trie 树也称为字典树、单词查找树，最大的特点就是共享<strong>字符串的公共前缀</strong>来达到节省空间的目的了。例如，字符串 “abc”和”abd”构成的 trie 树如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lffcJ72RwSZzf9UxWSPuqWByjiaHHSIQFU2ZNCkAnAKoOib8TSWjW8ZwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><h3 id="trie-树来实现敏感词过滤"><a href="#trie-树来实现敏感词过滤" class="headerlink" title="trie 树来实现敏感词过滤"></a>trie 树来实现敏感词过滤</h3><p>三个敏感词：”de”, “bca”, “bcf” 建立一颗 trie 树</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027l7SvJibyl5wONF8oPM2Ua4xKlgEpPDFYZicicqibOskxvnribWILm3TuFZkA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>接着我们可以采用三个指针来遍历</p><p>1、首先指针 p1 指向 root，指针 p2 和 p3 指向字符串第一个字符</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lDl8BH9p53bggbEDaZmxU5fGjTurE6VamdybAWHMqNqsxnib3ZfRMcZw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>2、然后从字符串的 a 开始，检测有没有以 a 作为前缀的敏感词，直接判断 p1 的孩子节点中是否有 a 这个节点就可以了，显然这里没有。接着把指针 p2 和 p3 向右移动一格。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027l9s7FxaxdiaSreteIAa3ITSqu3691kXWMPC7FKZyWTAI7ibOXyj2WvOicw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>3、然后从字符串 b 开始查找，看看是否有以 b 作为前缀的字符串，p1 的孩子节点中有 b，这时，<strong>我们把 p1 指向节点 b，p2 向右移动一格，不过，p3不动。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lECEqictiaiaEK7g1AyBT44iaP6wTb7JcArqNu8mhOy1U4GqulcUJ8zaMVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>4、判断 p1 的孩子节点中是否存在 p2 指向的字符c，显然有。我们把 p1 指向节点 c，p2 向右移动一格，p3不动。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027liaPbDjQlcyJ3IDs1QMjoRvNBmkxl1BC5traDHIHwsGeBZkeX22KMBwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>5、判断 p1 的孩子节点中是否存在 p2 指向的字符d，这里没有。这意味着，<strong>不存在以字符b作为前缀的敏感词</strong>。这时我们把p2和p3都移向字符c，p1 还是还原到最开始指向 root。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027ldHazFSFXC1h1VGwTjlqkAJb40EL2NVNCDGbko01F3Lv9c5uxkXBXfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>6、和前面的步骤一样，判断有没以 c 作为前缀的字符串，显然这里没有，所以把 p2 和 p3 移到字符 d。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lNfHacf2TMLSg2BmvqYlb9klTg1TOhd2iacOjv9TB7OMm0eRhUFvEt9g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>7、然后从字符串 d 开始查找，看看是否有以 d 作为前缀的字符串，p1 的孩子节点中有 d，这时，<strong>我们把 p1 指向节点 b，p2 向右移动一格，不过，p3和刚才一样不动。</strong>（看到这里，我猜你已经懂了）</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027l2D8TFoo007qFT8ZiagibsLvFcIs8888shb0q4ApuhAibfSSytpQiayrq5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>8、判断 p1 的孩子节点中是否存在 p2 指向的字符e，显然有。我们把 p1 指向节点 e，<strong>并且，这里e是最后一个节点了，查找结束，所以存在敏感词de</strong>，即 p3 和 p2 这个区间指向的就是敏感词了，把 p2 和 p3 指向的区间那些字符替换成 *。并且把 p2 和 p3 移向字符 f。如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMACAmPI5uJRDiaia2tc7t027lqNuh2DLKx9LecEZaS1aRfYDbIWZficQGpoibrqMbe6br8UohHsoMTCcA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>9、接着还是重复同样的步骤，知道 p3 指向最后一个字符。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>面试官：可以说说时间复杂度吗？</p><p>小秋：如果敏感词的长度为 m，则每个敏感词的查找时间复杂度是 O(m)，字符串的长度为 n，我们需要遍历 n 遍，所以敏感词查找这个过程的时间复杂度是 O(n * m)。如果有 t 个敏感词的话，构建 trie 树的时间复杂度是 O(t * m)。</p><p>如果让你来 构建 trie 树，你会用什么数据结构来实现？</p><p>小秋：我一般使用 Java，我会采用 HashMap 来实现，因为一个节点的字节点个数未知，采用 HashMap 可以动态拓展，而且可以在 O(1) 复杂度内判断某个子节点是否存在。</p>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>77406@LAPTOP-VEMP0J78 MINGW64 ~/Desktop</title>
      <link href="/2020/06/29/77406-LAPTOP-VEMP0J78-MINGW64-Desktop/"/>
      <url>/2020/06/29/77406-LAPTOP-VEMP0J78-MINGW64-Desktop/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ORM是什么</title>
      <link href="/2020/06/29/ORM%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2020/06/29/ORM%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ORM:(Object/Relation Mapping): 对象/关系映射<br>ORM的实现思想：<br>将关系数据库中表中的记录映射成为对象，以对象的形式展现，程序员可以把对数据库的操作转化为对对象的操作。</p><p><img src="https://images2018.cnblogs.com/blog/1351833/201805/1351833-20180501180203283-1149901647.png" alt="img"></p><h2 id="为什么是mybatis是半ORM"><a href="#为什么是mybatis是半ORM" class="headerlink" title="为什么是mybatis是半ORM"></a>为什么是mybatis是半ORM</h2><p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring两种代理</title>
      <link href="/2020/06/28/spring%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86/"/>
      <url>/2020/06/28/spring%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是一种比较好的理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p><p>举个例子：你的找了一小红来帮你问话，小红就看作是代理我的代理对象，代理的行为（方法）是问话。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/738439/1597043258820-f54f1a9e-982d-4383-8273-1086fd2ac3f4.png" alt="image"></p><p><a href="https://medium.com/@mithunsasidharan/understanding-the-proxy-design-pattern-5e63fe38052a" target="_blank" rel="noopener">https://medium.com/@mithunsasidharan/understanding-the-proxy-design-pattern-5e63fe38052a</a></p><p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（*后面会具体演示代码*），非常不灵活（*比如接口一旦新增加方法，目标对象和代理对象都要进行修改*）且麻烦(*需要对每个目标类都单独写一个代理类*)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p><p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p><p>静态代理实现步骤:</p><ol><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li></ol><p>下面通过代码展示！</p><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SmsService &#123;</span><br><span class="line">    String send(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class SmsServiceImpl implements SmsService &#123;</span><br><span class="line">    public String send(String message) &#123;</span><br><span class="line">        System.out.println(&quot;send message:&quot; + message);</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SmsProxy implements SmsService &#123;</span><br><span class="line"></span><br><span class="line">    private final SmsService smsService;</span><br><span class="line"></span><br><span class="line">    public SmsProxy(SmsService smsService) &#123;</span><br><span class="line">        this.smsService &#x3D; smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String send(String message) &#123;</span><br><span class="line">        &#x2F;&#x2F;调用方法之前，我们可以添加自己的操作</span><br><span class="line">        System.out.println(&quot;before method send()&quot;);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        &#x2F;&#x2F;调用方法之后，我们同样可以添加自己的操作</span><br><span class="line">        System.out.println(&quot;after method send()&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SmsService smsService &#x3D; new SmsServiceImpl();</span><br><span class="line">        SmsProxy smsProxy &#x3D; new SmsProxy(smsService);</span><br><span class="line">        smsProxy.send(&quot;java&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure><p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p><p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p><p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p><p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p><p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p><p><a href="https://github.com/Snailclimb/guide-rpc-framework" target="_blank" rel="noopener">guide-rpc-framework</a> 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。</p><p>另外，虽然 <a href="https://github.com/Snailclimb/guide-rpc-framework" target="_blank" rel="noopener">guide-rpc-framework</a> 没有用到 <strong>CGLIB 动态代理 ，我们这里还是简单介绍一下其使用以及和</strong>JDK 动态代理的对比。</p><h3 id="JDK-动态代理机制"><a href="#JDK-动态代理机制" class="headerlink" title="JDK 动态代理机制"></a>JDK 动态代理机制</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p><p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                      Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                      InvocationHandler h)</span><br><span class="line">    throws IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法一共有 3 个参数：</p><ol><li><strong>loader</strong> :类加载器，用于加载代理对象。</li><li><strong>interfaces</strong> : 被代理类实现的一些接口；</li><li><strong>h</strong> : 实现了 <code>InvocationHandle</code>r 接口的对象；</li></ol><p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">        throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invoke()</code> 方法有下面三个参数：</p><ol><li><strong>proxy</strong> :动态生成的代理类</li><li><strong>method</strong> : 与代理类对象调用的方法相对应</li><li><strong>args</strong> : 当前 method 方法的参数</li></ol><p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><h4 id="JDK-动态代理类使用步骤"><a href="#JDK-动态代理类使用步骤" class="headerlink" title="JDK 动态代理类使用步骤"></a>JDK 动态代理类使用步骤</h4><ol><li>定义一个接口及其实现类；</li><li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package proxy;</span><br><span class="line"> </span><br><span class="line">public interface Star</span><br><span class="line">&#123;</span><br><span class="line">    String sing(String name);</span><br><span class="line">    </span><br><span class="line">    String dance(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package proxy;</span><br><span class="line"> </span><br><span class="line">public class LiuDeHua implements Star</span><br><span class="line">&#123;   </span><br><span class="line">    @Override</span><br><span class="line">    public String sing(String name)</span><br><span class="line">    &#123;</span><br><span class="line">         System.out.println(&quot;给我一杯忘情水&quot;);</span><br><span class="line"> </span><br><span class="line">        return &quot;唱完&quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String dance(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;开心的马骝&quot;);</span><br><span class="line"> </span><br><span class="line">        return &quot;跳完&quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3</strong>.具体代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package proxy;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line">public class StarProxy implements InvocationHandler</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 目标类，也就是被代理对象</span><br><span class="line">    private Object target;</span><br><span class="line">    </span><br><span class="line">    public void setTarget(Object target)</span><br><span class="line">    &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里可以做增强</span><br><span class="line">        System.out.println(&quot;收钱&quot;);</span><br><span class="line">        </span><br><span class="line">        Object result &#x3D; method.invoke(target, args);</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 生成代理类</span><br><span class="line">    public Object CreatProxyedObj()</span><br><span class="line">    &#123;</span><br><span class="line">        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.实际使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Star ldh &#x3D; new LiuDeHua();</span><br><span class="line"> </span><br><span class="line">StarProxy proxy &#x3D; new StarProxy();</span><br><span class="line"> </span><br><span class="line">proxy.setTarget(ldh); </span><br><span class="line">  </span><br><span class="line">Object obj &#x3D; proxy.CreatProxyedObj();</span><br><span class="line"></span><br><span class="line">Star star &#x3D; (Star)obj;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure><h3 id="CGLIB-动态代理机制"><a href="#CGLIB-动态代理机制" class="headerlink" title="CGLIB 动态代理机制"></a>CGLIB 动态代理机制</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p><p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p><p><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm" target="_blank" rel="noopener">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p><p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p><p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface MethodInterceptor</span><br><span class="line">extends Callback&#123;</span><br><span class="line">    &#x2F;&#x2F; 拦截被代理类中的方法</span><br><span class="line">    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,</span><br><span class="line">                               MethodProxy proxy) throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>obj</strong> :被代理的对象（需要增强的对象）</li><li><strong>method</strong> :被拦截的方法（需要增强的方法）</li><li><strong>args</strong> :方法入参</li><li><strong>methodProxy</strong> :用于调用原始方法</li></ol><p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p><h4 id="CGLIB-动态代理类使用步骤"><a href="#CGLIB-动态代理类使用步骤" class="headerlink" title="CGLIB 动态代理类使用步骤"></a>CGLIB 动态代理类使用步骤</h4><ol><li>定义一个类；</li><li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li></ol><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cglib&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.3.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>1.实现一个使用阿里云发送短信的类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line">public class AliSmsService &#123;</span><br><span class="line">    public String send(String message) &#123;</span><br><span class="line">        System.out.println(&quot;send message:&quot; + message);</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 自定义MethodInterceptor</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class DebugMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param o           被代理的对象（需要增强的对象）</span><br><span class="line">     * @param method      被拦截的方法（需要增强的方法）</span><br><span class="line">     * @param args        方法入参</span><br><span class="line">     * @param methodProxy 用于调用原始方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        &#x2F;&#x2F;调用方法之前，我们可以添加自己的操作</span><br><span class="line">        System.out.println(&quot;before method &quot; + method.getName());</span><br><span class="line">        Object object &#x3D; methodProxy.invokeSuper(o, args);</span><br><span class="line">        &#x2F;&#x2F;调用方法之后，我们同样可以添加自己的操作</span><br><span class="line">        System.out.println(&quot;after method &quot; + method.getName());</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.获取代理类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line">public class CglibProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Object getProxy(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建动态代理增强类</span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">        &#x2F;&#x2F; 设置类加载器</span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        &#x2F;&#x2F; 设置被代理类</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        &#x2F;&#x2F; 设置方法拦截器</span><br><span class="line">        enhancer.setCallback(new DebugMethodInterceptor());</span><br><span class="line">        &#x2F;&#x2F; 创建代理类</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AliSmsService aliSmsService &#x3D; (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(&quot;java&quot;);</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure><h3 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h3><ol><li><strong>JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ol><h2 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h2><ol><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>JDK动态代理</p><p>通过 <code>Proxy</code> 类的 <code>newInstance</code> 方法获取一个动态代理对象，需要传入三个参数，被代理对象的类加载器、被代理对象实现的接口，以及一个 <code>InvocationHandler</code> 调用处理器来指明具体的逻辑，相比静态代理的优势是接口中声明的所有方法都被转移到 <code>InvocationHandler</code> 的 <code>invoke</code> 方法集中处理。</p><p>CGLiB动态代理：</p><p>JDK 动态代理要求实现被代理对象的接口，而 CGLib 要求代理类去继承目标类，如果一个类是 final 类则不能使用 CGLib 代理。两种代理都在运行期生成字节码，JDK 动态代理直接写字节码，而 CGLib 动态代理使用 ASM 框架写字节码。 JDK 动态代理调用代理方法通过反射机制实现，而 GCLib 动态代理通过 FastClass 机制直接调用方法，它为代理类和被代理类各生成一个类</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>jdk只能针对接口不能针对类实现代理。</p><p>CGLib通过继承方式实现代理。所以类或方法最好不要声明成final，对于final类或方法，是无法继承的。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mybatis相关疑惑</title>
      <link href="/2020/06/28/mybatis%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91/"/>
      <url>/2020/06/28/mybatis%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="mybatis中-和-的区别"><a href="#mybatis中-和-的区别" class="headerlink" title="mybatis中#和$的区别"></a>mybatis中#和$的区别</h2><p><strong>#{parameterName}</strong></p><p><strong>${parameterName}</strong></p><p>首先，我们说一下这两种引用参数时的区别，<strong>使用#</strong>{parameterName}引用参数的时候，Mybatis会<strong>把这个参数认为是一个字符串，并自动加上’’</strong>，例如传入参数是“Smith”，那么在下面SQL中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from emp where name = #&#123;employeeName&#125;</span><br></pre></td></tr></table></figure><p>使用的时候就会转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * <span class="keyword">from</span> emp where name = <span class="string">'Smith'</span>;</span><br></pre></td></tr></table></figure><p>同时<strong>使用${parameterName}的</strong>时候在下面SQL中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * <span class="keyword">from</span> emp where name = $&#123;employeeName&#125;</span><br></pre></td></tr></table></figure><p>就会直接转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * <span class="keyword">from</span> emp where name = Smith</span><br></pre></td></tr></table></figure><p>简单说<strong>#{}是经过预编译的,是安全的</strong>。</p><p>而<strong>${}</strong>是未经过预编译的,<strong>仅仅是取变量的值,是非安全的,存在SQL注入</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&#123;&#125; 这种取值是编译好SQL语句再取值</span><br><span class="line">$&#123;&#125; 这种是取值以后再去编译SQL语句</span><br></pre></td></tr></table></figure><p>下面我们用一个实际的例子看看分别使用和是否可以防止SQL注入。</p><p><strong>首先是使用#{}：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用#&#123;&#125; --&gt;</span><br><span class="line">  &lt;select id=<span class="string">"selectUser"</span> parameterType=<span class="string">"String"</span> </span><br><span class="line">    resultType=<span class="string">"com.mybatis.po.MyUser"</span>&gt;</span><br><span class="line">    select * from user where account = #&#123;account&#125; and password = #&#123;password&#125;</span><br><span class="line">  &lt;<span class="regexp">/select&gt;</span></span><br></pre></td></tr></table></figure><p>分别测试正常传参和拼接传参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用#&#123;&#125; 正常传参</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; parameter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parameter.put(<span class="string">"account"</span>, );</span><br><span class="line">    parameter.put(<span class="string">"password"</span>, password);</span><br><span class="line">    MyUser mu = ss.selectOne(<span class="string">"com.mybatis.mapper.UserMapper.selectUser"</span>, parameter);</span><br><span class="line">    System.out.println(<span class="string">"返回结果："</span> + mu);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用#&#123;&#125; 拼接传参</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; parameter_1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parameter_1.put(<span class="string">"account"</span>, <span class="string">"201301001"</span>);</span><br><span class="line">    parameter_1.put(<span class="string">"password"</span>, <span class="string">"111111"</span> + <span class="string">"or account = 'admin' "</span>);</span><br><span class="line">    MyUser mu_1 = ss.selectOne(<span class="string">"com.mybatis.mapper.UserMapper.selectUser"</span>, parameter_1);</span><br><span class="line">    System.out.println(<span class="string">"返回结果："</span> + mu_1);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2020/06/28/mybatis%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200628154136546.png" alt="image-20200628154136546"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = ? and password = ? </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt; Parameters: <span class="number">201301001</span>(<span class="built_in">String</span>), <span class="number">111111</span>(<span class="built_in">String</span>)</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - &lt;==      Total: <span class="number">1</span></span><br><span class="line">返回结果：MyUser [id=<span class="number">17</span>, account=<span class="number">201301001</span>, password=<span class="number">111111</span>, name=蒙奇D路飞]</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = ? and password = ? </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt; Parameters: <span class="number">201301001</span>(<span class="built_in">String</span>), <span class="number">111111</span> or account = <span class="string">'admin'</span> (<span class="built_in">String</span>)</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - &lt;==      Total: <span class="number">0</span></span><br><span class="line">返回结果：<span class="literal">null</span></span><br></pre></td></tr></table></figure><p>很明显，使用<strong>#{}</strong>的时候，即使传入了恶意参数，<strong>#{}</strong>只会将其作为一个占位符的参数，如上面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = ? and password = ? </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - ==&gt; Parameters: <span class="number">201301001</span>(<span class="built_in">String</span>), <span class="number">111111</span> or account = <span class="string">'admin'</span> (<span class="built_in">String</span>)</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-5</span>] - &lt;==      Total: <span class="number">0</span></span><br><span class="line">转换为实际的SQL语句：select * <span class="keyword">from</span> user where account = <span class="string">'201301001'</span> and password = <span class="string">'111111 or account = '</span>admin<span class="string">''</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where account = <span class="string">'201301001'</span> and password = <span class="string">'111111 or account = '</span>admin<span class="string">''</span> </span><br><span class="line">select * from user where account = <span class="number">201301001</span> and password = <span class="number">111111</span> or account = <span class="string">'admin'</span></span><br></pre></td></tr></table></figure><p>现在是使用<strong>${}</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用$&#123;&#125; --&gt;</span><br><span class="line">  &lt;select id=<span class="string">"selectUser2"</span> parameterType=<span class="string">"String"</span> </span><br><span class="line">    resultType=<span class="string">"com.mybatis.po.MyUser"</span>&gt;</span><br><span class="line">    select * <span class="keyword">from</span> user where account = $&#123;account&#125; and password = $&#123;password&#125;</span><br><span class="line">  &lt;<span class="regexp">/select&gt;</span></span><br></pre></td></tr></table></figure><p>分别测试正常传参和拼接传参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用$&#123;&#125; 正常传参</span></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; parameter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parameter.put(<span class="string">"account"</span>, <span class="string">"201301001"</span>);</span><br><span class="line">    parameter.put(<span class="string">"password"</span>, <span class="string">"111111"</span>);</span><br><span class="line">    MyUser mu = ss.selectOne(<span class="string">"com.mybatis.mapper.UserMapper.selectUser2"</span>,parameter);</span><br><span class="line">    System.out.println(<span class="string">"返回结果："</span> + mu);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用$&#123;&#125; 拼接传参</span></span><br><span class="line">   <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; parameter2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   parameter2.put(<span class="string">"account"</span>, <span class="string">"201301001"</span>);</span><br><span class="line">   parameter2.put(<span class="string">"password"</span>, <span class="string">"111111"</span> + <span class="string">" or account = 'admin' "</span>);</span><br><span class="line">   MyUser mu2 = ss.selectOne(<span class="string">"com.mybatis.mapper.UserMapper.selectUser2"</span>, parameter2);</span><br><span class="line">   System.out.println(<span class="string">"返回结果："</span> + mu2);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2020/06/28/mybatis%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200628154158333.png" alt="image-20200628154158333"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = <span class="number">201301001</span> and password = <span class="number">111111</span> </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - ==&gt; Parameters: </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - &lt;==      Total: <span class="number">1</span></span><br><span class="line">返回结果：MyUser [id=<span class="number">17</span>, account=<span class="number">201301001</span>, password=<span class="number">111111</span>, name=蒙奇D路飞]</span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - ==&gt;  Preparing: select * <span class="keyword">from</span> user where account = <span class="number">201301001</span> and password = <span class="number">111111</span> or account = <span class="string">'admin'</span> </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - ==&gt; Parameters: </span><br><span class="line">DEBUG [http-nio<span class="number">-8080</span>-exec<span class="number">-18</span>] - &lt;==      Total: <span class="number">2</span></span><br><span class="line">返回结果：[MyUser [id=<span class="number">1</span>, account=admin, password=<span class="number">111111</span>, name=管理员], MyUser [id=<span class="number">17</span>, account=<span class="number">201301001</span>, password=<span class="number">111111</span>, name=蒙奇D路飞]]</span><br></pre></td></tr></table></figure><p>很明显，使用<strong>${}</strong>将参数拼接后在编译成SQL语句，不能防止SQL注入，查询出了有关account=admin的额外信息，这是很危险的。</p><h3 id="返回主键id"><a href="#返回主键id" class="headerlink" title="返回主键id"></a>返回主键id</h3><p>​    <insert id="insertOneTest" parametertype="org.chench.test.mybatis.model.Test" usegeneratedkeys="true" keyproperty="id" keycolumn="id">     insert into test(name,descr,url,create_time,update_time)      values(#{name},#{descr},#{url},now(),now()) </insert></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>count(*)、count(1)、count(某字段)的区别</title>
      <link href="/2020/06/28/count-%E3%80%81count-1-%E3%80%81count-%E6%9F%90%E5%AD%97%E6%AE%B5-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/06/28/count-%E3%80%81count-1-%E3%80%81count-%E6%9F%90%E5%AD%97%E6%AE%B5-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><strong>count(*)：所有行进行统计，包括NULL行.COUNT(*)不单会进行全表扫描，也会对表的每个字段进行扫描。<br>count(1)：所有行进行统计，包括NULL行.其实就可以想成表中有这么一个字段,这个字段就是固定值1,count(1),就是计算一共有多少个1<br>count(column)：对column中非Null进行统计</strong></p><p>执行效率：<br>列名为主键，count(列名)会比count(1)快  </p><p>列名不为主键，count(1)会比count(列名)快  </p><p>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）  </p><p>如果有主键，则 select count（主键）的执行效率是最优的  </p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池底层&amp;四种类型&amp;参数含义</title>
      <link href="/2020/06/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B-%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/"/>
      <url>/2020/06/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B-%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>线程池底层都是通过 ThreadPoolExecutor 来实现的</p><h2 id="线程池的执行过程"><a href="#线程池的执行过程" class="headerlink" title="线程池的执行过程"></a>线程池的执行过程</h2><p>这里用一个图来说明线程池的执行流程</p><p><img src="https://upload-images.jianshu.io/upload_images/11183270-a01aea078d7f4178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>任务被提交到线程池，会先判断当前线程数量是否小于corePoolSize，如果小于则创建线程来执行提交的任务，否则将任务放入workQueue队列，如果workQueue满了，则判断当前线程数量是否小于maximumPoolSize,如果小于则创建线程执行任务，否则就会调用handler，以表示线程池拒绝接收任务。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>参数介绍</p><table><thead><tr><th align="left">参数</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td align="left">corePoolSize</td><td>int</td><td>核心线程数</td></tr><tr><td align="left">maximumPoolSize</td><td>int</td><td>最大线程数</td></tr><tr><td align="left">keepAliveTime</td><td>long</td><td>存活时间</td></tr><tr><td align="left">unit</td><td>TimeUnit</td><td>时间单位</td></tr><tr><td align="left">workQueue</td><td>BlockingQueue</td><td>存放线程的队列</td></tr><tr><td align="left">threadFactory</td><td>ThreadFactory</td><td>创建线程的工厂</td></tr><tr><td align="left">handler</td><td>RejectedExecutionHandler</td><td>多余的的线程处理器（拒绝策略）</td></tr></tbody></table><h3 id="核心线程数corePoolSize"><a href="#核心线程数corePoolSize" class="headerlink" title="核心线程数corePoolSize"></a>核心线程数corePoolSize</h3><p>这个参数表示线程池中的基本线程数量也就是核心线程数量。</p><h3 id="最大线程数maximumPoolSize-ˈmaeksɪməm"><a href="#最大线程数maximumPoolSize-ˈmaeksɪməm" class="headerlink" title="最大线程数maximumPoolSize[ˈmæksɪməm]"></a>最大线程数maximumPoolSize[ˈmæksɪməm]</h3><p>这个参数是线程池中允许创建的最大线程数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当使用有界队列时，且队列存放的任务满了，那么线程池会创建新的线程（最大不会超过这个参数所设置的值）。需要注意的是，**当使用无界队列时，这个参数是无效的。</span><br></pre></td></tr></table></figure><h3 id="线程存活时间keepAliveTime"><a href="#线程存活时间keepAliveTime" class="headerlink" title="线程存活时间keepAliveTime"></a>线程存活时间keepAliveTime</h3><p>这个就是非核心线程空闲时可以存活的时间，一旦超过这个时间，线程就会被销毁。</p><h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3><p>keepAliveTime的单位。</p><h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><p>当前线程数超过corePoolSize时，新的任务会处在等待状态，并存在workQueue中，BlockingQueue是一个先进先出的阻塞式队列实现，底层实现会涉及Java并发的AQS机制，有关于AQS的相关知识，我会单独写一篇，敬请期待。</p><h3 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h3><p>创建线程的工厂类，通常我们会自顶一个threadFactory设置线程的名称，这样我们就可以知道线程是由哪个工厂类创建的，可以快速定位。</p><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>线程池执行拒绝策略，当线数量达到maximumPoolSize大小，并且workQueue也已经塞满了任务的情况下，线程池会调用handler拒绝策略来处理请求。</p><p>系统默认的拒绝策略有以下几种：</p><ol><li>AbortPolicy：为线程池默认的拒绝策略，该策略直接抛异常处理。</li><li>DiscardPolicy：直接抛弃不处理。</li><li>DiscardOldestPolicy：丢弃队列中最老的任务。</li><li>CallerRunsPolicy：将任务分配给当前执行execute方法线程来处理。</li></ol><p>我们还可以自定义拒绝策略，只需要实现RejectedExecutionHandler接口即可，友好的拒绝策略实现有如下：</p><ol><li>将数据保存到数据，待系统空闲时再进行处理</li><li>将数据用日志进行记录，后由人工处理</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现有一个线程池，参数corePoolSize = 5，maximumPoolSize = 10，BlockingQueue阻塞队列长度为5，此时有4个任务同时进来，问：线程池会创建几条线程？</p><p>如果4个任务还没处理完，这时又同时进来2个任务，问：线程池又会创建几条线程还是不会创建？</p><p>如果前面6个任务还是没有处理完，这时又同时进来5个任务，问：线程池又会创建几条线程还是不会创建？</p><p><strong>线程池corePoolSize=5，线程初始化时不会自动创建线程，所以当有4个任务同时进来时，执行execute方法会新建【4】条线程来执行任务；</strong></p><p><strong>前面的4个任务都没完成，现在又进来2个队列，会新建【1】条线程来执行任务，这时poolSize=corePoolSize，还剩下1个任务，线程池会将剩下这个任务塞进阻塞队列中，等待空闲线程执行；</strong></p><p><strong>如果前面6个任务还是没有处理完，这时又同时进来了5个任务，此时还没有空闲线程来执行新来的任务，所以线程池继续将这5个任务塞进阻塞队列，但发现阻塞队列已经满了，核心线程也用完了，还剩下1个任务不知道如何是好，于是线程池只能创建【1】条“临时”线程来执行这个任务了；</strong></p><p><strong>这里创建的线程用“临时”来描述还是因为它们不会长期存在于线程池，它们的存活时间为keepAliveTime，此后线程池会维持最少corePoolSize数量的线程。</strong></p><h2 id="IO密集型和CPU密集型"><a href="#IO密集型和CPU密集型" class="headerlink" title="IO密集型和CPU密集型"></a>IO密集型和CPU密集型</h2><p>CPU密集型任务应配置尽可能小的线程，如配置CPU数目+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*CPU数目。</p><h3 id="线程池大小的设置"><a href="#线程池大小的设置" class="headerlink" title="线程池大小的设置"></a>线程池大小的设置</h3><h4 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h4><p>一个服务器有八个cpu，处理请求5ms，io操作200ms，理想情况下应该开什么线程？1s会处理多少请求？</p><p>8* U_cpu *(1+200/5)</p><ul><li><p>计算密集型任务：</p><p>N = N_cpu + 1</p><ul><li>加 1 的原因：当有一个线程偶尔故障时，额外的那个线程可以立即补上，保证CPU时钟不会被浪费</li></ul></li><li><p>包含 I/O 或其他阻塞操作：</p><p>N = N_cpu * U_cpu * (1 + W / C)</p><ul><li><p>N_cpu：CPU 的个数</p></li><li><p>U_cpu：目标 CPU 利用率</p></li><li><p>W / C：等待时间 (Wait) / 计算时间 (Compute)</p></li><li><p>获取 CPU 数目的方法：<code>int N_CPUS = Runtime.getRuntime().availableProcessors();</code></p></li></ul></li></ul><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><blockquote><p>假设要求一个系统的 TPS（Transaction Per Second 或者 Task Per Second）至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s</p></blockquote><p>如何设计线程个数，使得可以在1s内处理完20个Transaction？</p><p>20/(1/4)=80</p><h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><blockquote><p>计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？</p></blockquote><p>线程数 = 8 * (1 + 100/5) = 168 (个)</p><blockquote><p> 那如果DB的 QPS（Query Per Second）上限是1000，此时这个线程数又该设置为多大呢？</p></blockquote><p>一个线程每秒处理的任务数 1000/105,168个线程168*（1000/105）=1600QPS </p><p>168*(1000/1600)=105</p><h4 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h4><p>任务处理时间 100ms，服务器 4 核 8G 如何设计线程池达到 1000qps？任务是 90ms 在 IO，10ms 在计算的情况下怎么弄？全在计算呢？</p><p>一个线程一秒处理10个任务 10QPS  1000/10=100个线程   4*(1+90/10)=40个线程 </p><p>8 *(90/10+1）</p><h2 id="四种类型"><a href="#四种类型" class="headerlink" title="四种类型"></a>四种类型</h2><h3 id="1-FixedThreadPool"><a href="#1-FixedThreadPool" class="headerlink" title="1.FixedThreadPool"></a>1.FixedThreadPool</h3><p>所有任务只能使用固定大小的线程，超出的线程会在队列中等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>FixedThreadPool</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>都设置为参数nThreads，<code>keepAliveTime</code>为0L，表示多余的线程立刻终止，因为不会产生多余的线程它的任务队列采用的是LinkedBlockingQueue。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/3/1615a7fcb4af71c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>创建线程池的方法，在我们的程序中只需要，后面其他种类的同理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 参数是要线程池的线程最大值</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-CachedThreadPool"><a href="#2-CachedThreadPool" class="headerlink" title="2.CachedThreadPool"></a>2.CachedThreadPool</h3><p>一个任务创建一个线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code>的<code>corePoolSize</code>是0，<code>maximumPoolSize</code>是Integer.MAX_VALUE，也就是说<code>CachedThreadPool</code>没有核心线程，全部都是非核心线程，并且没有上限。<code>keepAliveTime</code>是60秒，就是说空闲线程等待新任务60秒，超时则销毁。此处用到的队列是阻塞队列<code>SynchronousQueue</code>[ˈsɪŋkrənəs],这个队列没有缓冲区，所以其中最多只能存在一个元素,有新的任务则阻塞等待。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616e2b8b89d971c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="3-SingleThreadExecutor"><a href="#3-SingleThreadExecutor" class="headerlink" title="3.SingleThreadExecutor"></a>3.SingleThreadExecutor</h3><p>相当于大小为 1 的 FixedThreadPool。其创建源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到总线程数和核心线程数都是1，所以就只有一个核心线程。该线程池才用链表阻塞队列<code>LinkedBlockingQueue</code>，先进先出原则，所以保证了任务的按顺序逐一进行。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616e43b53271671?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="4-ScheduledThreadPool"><a href="#4-ScheduledThreadPool" class="headerlink" title="4.ScheduledThreadPool"></a>4.ScheduledThreadPool</h3><p><code>ScheduledThreadPool</code>是一个能实现定时和周期性任务的线程池，它的创建源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里创建了<code>ScheduledThreadPoolExecutor</code>，继承自<code>ThreadPoolExecutor</code>，主要用于定时延时或者定期处理任务。<code>ScheduledThreadPoolExecutor</code>的构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">        super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">              new DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看出<code>corePoolSize</code>是传进来的固定值，<code>maximumPoolSize</code>无限大，因为采用的队列<code>DelayedWorkQueue</code>是无解的，所以<code>maximumPoolSize</code>参数无效。该线程池执行如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616e5ded43058a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>当执行<code>scheduleAtFixedRate</code>或者<code>scheduleWithFixedDelay</code>方法时，会向<code>DelayedWorkQueue</code>添加一个实现<code>RunnableScheduledFuture</code>接口的<code>ScheduledFutureTask</code>(任务的包装类)，并会检查运行的线程是否达到<code>corePoolSize</code>。如果没有则新建线程并启动<code>ScheduledFutureTask</code>，然后去执行任务。如果运行的线程达到了<code>corePoolSize</code>时，则将任务添加到<code>DelayedWorkQueue</code>中。<code>DelayedWorkQueue</code>会将任务进行排序，先要执行的任务会放在队列的前面。在跟此前介绍的线程池不同的是，当执行完任务后，会将<code>ScheduledFutureTask</code>中的<code>time</code>变量改为下次要执行的时间并放回到<code>DelayedWorkQueue</code>中。</p><h3 id="5-代码"><a href="#5-代码" class="headerlink" title="5.代码"></a>5.代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化10个信号量在信号包中，让ABCD4个线程分别去获取</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;&#x2F; ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(5);</span><br><span class="line">       &#x2F;&#x2F; ExecutorService threadPool &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">       &#x2F;&#x2F; ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 6; i++) &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;current thread name: &quot; + Thread.currentThread().getName());</span><br><span class="line">                Object object &#x3D; null;</span><br><span class="line">               &#x2F;&#x2F; System.out.print(&quot;result## &quot;+object.toString());</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化10个信号量在信号包中，让ABCD4个线程分别去获取</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService &#x3D; Executors.newScheduledThreadPool(1);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;current Time&quot; + System.currentTimeMillis());</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);</span><br><span class="line">        &#125;, 1, 3, TimeUnit.SECONDS);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-对比"><a href="#6-对比" class="headerlink" title="6.对比"></a>6.对比</h3><p>FixedThreadPool 适用于处理CPU密集型的任务，尽可能的少的分配线程，即适用执行长期的任务。</p><p>CachedThreadPool用于并发执行大量短期的小任务。</p><p>SingleThreadExecutor适用于串行执行任务的场景，一个任务一个任务地执行。</p><p>newScheduledThreadPool 周期性执行任务的场景，需要限制线程数量的场景</p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><h3 id="Abort-策略"><a href="#Abort-策略" class="headerlink" title="Abort 策略"></a>Abort 策略</h3><p>默认策略，新任务提交时直接抛出异常RejectedExecutionException，该异常可由调用者捕获。</p><h3 id="CallerRuns-策略"><a href="#CallerRuns-策略" class="headerlink" title="CallerRuns 策略:"></a>CallerRuns 策略:</h3><p>不会在线程池的线程中执行新的任务，而是在调用exector的线程中运行新的任务。</p><h3 id="Discard策略"><a href="#Discard策略" class="headerlink" title="Discard策略:"></a>Discard策略:</h3><p>直接丢弃新提交的任务；</p><h3 id="DiscardOlds策略"><a href="#DiscardOlds策略" class="headerlink" title="DiscardOlds策略:"></a>DiscardOlds策略:</h3><p>如果执行器没有关闭，队列头的任务将会被丢弃，然后执行器重新尝试执行任务（如果失败，则重复这一过程）；</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package concurrency.pool;</span><br><span class="line"> </span><br><span class="line">import java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line">import java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by li on 2016&#x2F;7&#x2F;2.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SaturationPolicy &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 线程池工作队列已满时，在不同饱和策略下表现</span><br><span class="line">     * @param handler 线程池工作队列饱和策略</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void policy(RejectedExecutionHandler handler)&#123;</span><br><span class="line">        &#x2F;&#x2F;基本线程2个，最大线程数为3，工作队列容量为5</span><br><span class="line">        ThreadPoolExecutor exec &#x3D; new ThreadPoolExecutor(2,3,0l, TimeUnit.MILLISECONDS,new LinkedBlockingDeque&lt;&gt;(5));</span><br><span class="line">        if (handler !&#x3D; null)&#123;</span><br><span class="line">            exec.setRejectedExecutionHandler(handler);&#x2F;&#x2F;设置饱和策略</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            exec.submit(new Task());&#x2F;&#x2F;提交任务</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        policy(new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">&#x2F;&#x2F;        policy((new ThreadPoolExecutor.CallerRunsPolicy()));</span><br><span class="line">&#x2F;&#x2F;        policy(new ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">&#x2F;&#x2F;        policy(new ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;自定义任务</span><br><span class="line">    static class Task implements Runnable &#123;</span><br><span class="line">        private static int count &#x3D; 0;</span><br><span class="line">        private int id &#x3D; 0;&#x2F;&#x2F;任务标识</span><br><span class="line">        public Task() &#123;</span><br><span class="line">            id &#x3D; ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public  void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);&#x2F;&#x2F;休眠3秒</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(&quot;线程被中断&quot; + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot; 任务：&quot; + id + &quot;\t 工作线程: &quot;+ Thread.currentThread().getName() + &quot; 执行完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有哪些工作队列"><a href="#有哪些工作队列" class="headerlink" title="有哪些工作队列"></a>有哪些工作队列</h2><h3 id="SynchronousQueue-ˈsɪŋkrənəs-："><a href="#SynchronousQueue-ˈsɪŋkrənəs-：" class="headerlink" title="SynchronousQueue [ˈsɪŋkrənəs]："></a>SynchronousQueue [ˈsɪŋkrənəs]：</h3><p>是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;2个核心线程最大线程为3的线程池</span><br><span class="line">        Executor executors &#x3D; new ThreadPoolExecutor(</span><br><span class="line">                2, 3, 30, TimeUnit.SECONDS,</span><br><span class="line">                new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                new RejectHandler());</span><br><span class="line">        execute(executors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void execute(Executor executors) &#123;</span><br><span class="line">        executors.execute(new NameRunnable(1));</span><br><span class="line">        executors.execute(new NameRunnable(2));</span><br><span class="line">        executors.execute(new NameRunnable(3));</span><br><span class="line">        executors.execute(new NameRunnable(4));</span><br><span class="line">        executors.execute(new NameRunnable(5));</span><br><span class="line">        executors.execute(new NameRunnable(6));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class NameRunnable implements Runnable &#123;</span><br><span class="line">        private int name;</span><br><span class="line"></span><br><span class="line">        public NameRunnable(int name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(name + &quot; is running... &quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + &quot; is end !!! &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;***</span><br><span class="line">     * 拒绝的Runnable</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static class RejectHandler implements RejectedExecutionHandler &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;</span><br><span class="line">            NameRunnable name &#x3D; (NameRunnable) r;</span><br><span class="line"></span><br><span class="line">            System.out.print(name.getName() + &quot; is rejected ^^\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200127233842102.png" alt="在这里插入图片描述"></p><h3 id="ArrayBlockingQueue："><a href="#ArrayBlockingQueue：" class="headerlink" title="ArrayBlockingQueue："></a>ArrayBlockingQueue：</h3><p>ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;2个核心线程最大线程为3的线程池,阻塞队列大小为2</span><br><span class="line">Executor executors &#x3D; new ThreadPoolExecutor(</span><br><span class="line">               2, 3, 30, TimeUnit.SECONDS,</span><br><span class="line">               new ArrayBlockingQueue&lt;&gt;(2),</span><br><span class="line">               new RejectHandler());</span><br><span class="line">       execute(executors);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200127234739185.png" alt="在这里插入图片描述"></p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;2个核心线程最大线程为3的线程池,阻塞队列大小为2</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Executor executors &#x3D; new ThreadPoolExecutor(</span><br><span class="line">                2, 6, 30, TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingQueue&lt;&gt;(2),</span><br><span class="line">                new RejectHandler());</span><br><span class="line">        execute(executors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void execute(Executor executors) &#123;</span><br><span class="line">        executors.execute(new NameRunnable(1));</span><br><span class="line">        executors.execute(new NameRunnable(2));</span><br><span class="line">        executors.execute(new NameRunnable(3));</span><br><span class="line">        executors.execute(new NameRunnable(4));</span><br><span class="line">        executors.execute(new NameRunnable(5));</span><br><span class="line">        executors.execute(new NameRunnable(6));</span><br><span class="line">        executors.execute(new NameRunnable(7));</span><br><span class="line">        executors.execute(new NameRunnable(8));</span><br><span class="line">        executors.execute(new NameRunnable(9));</span><br><span class="line">        executors.execute(new NameRunnable(10));</span><br><span class="line">        executors.execute(new NameRunnable(11));</span><br><span class="line">        executors.execute(new NameRunnable(12));</span><br><span class="line">        executors.execute(new NameRunnable(13));</span><br><span class="line">        executors.execute(new NameRunnable(14));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200128001009488.png" alt="在这里插入图片描述"></p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。</p><h2 id="如何优雅关闭线程池"><a href="#如何优雅关闭线程池" class="headerlink" title="如何优雅关闭线程池"></a>如何优雅关闭线程池</h2><h4 id="run和start"><a href="#run和start" class="headerlink" title="run和start"></a>run和start</h4><p><strong>线程的run()方法是由java虚拟机直接调用的，如果我们没有启动线程（没有调用线程的start()方法）而是在应用代码中直接调用run()方法，那么这个线程的run()方法其实运行在当前线程（即run()方法的调用方所在的线程）之中，而不是运行在其自身的线程中，从而违背了创建线程的初衷；</strong></p><p>下面是一个用来说明start()方法和run()方法的区别的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class WelcomThread extends Thread &#123;</span><br><span class="line">    &#x2F;&#x2F;在该方法中实现线程的任务逻辑</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;获取当前正在执行的线程名称</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread welcome &#x3D; new WelcomThread();  &#x2F;&#x2F;创建线程（动态规划）</span><br><span class="line">        welcome.run();  &#x2F;&#x2F;直接调用run()方法</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">         Thread welcome1 &#x3D; new WelcomThread();  &#x2F;&#x2F;创建线程</span><br><span class="line">         welcome1.start();  &#x2F;&#x2F;启动线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">main</span><br><span class="line">Thread-1</span><br></pre></td></tr></table></figure><h4 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a>Runnable vs Callable</h4><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是<strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 *<em><code>Runnable</code> 接口*</em>，这样代码看起来会更加简洁。</p><p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。（<code>Executors.callable（Runnable task</code>）或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Runnable.java</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 被线程执行，没有返回值也无法抛出异常</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line">Callable.java</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 计算结果，或在无法这样做时抛出异常。</span><br><span class="line">     * @return 计算得出的结果</span><br><span class="line">     * @throws 如果无法计算结果，则抛出异常</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a>execute() vs submit()</h4><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li>.对返回值的处理不同 execute方法不关心返回值。 submit方法有返回值，Future.</li><li>对异常的处理不同<br>excute方法会抛出异常。 sumbit方法不会抛出异常。除非你调用Future.get()</li></ol><p>我们以<strong><code>AbstractExecutorService</code></strong>接口中的一个 <code>submit</code> 方法为例子来看看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        submit();</span><br><span class="line">        submitWithGet();</span><br><span class="line">       <span class="comment">// execute();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">submitWithGet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService service= Executors.newSingleThreadExecutor();</span><br><span class="line">        Future future=service.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i=<span class="number">7</span>/<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        future.get();</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService service= Executors.newSingleThreadExecutor();</span><br><span class="line">        service.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i=<span class="number">7</span>/<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService service= Executors.newSingleThreadExecutor();</span><br><span class="line">        service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i=<span class="number">7</span>/<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdown-VS-shutdownNow"><a href="#shutdown-VS-shutdownNow" class="headerlink" title="shutdown()VS shutdownNow()"></a>shutdown()VS shutdownNow()</h4><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h4 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a>isTerminated() VS isShutdown()</h4><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">    &#x2F;&#x2F;由于只是为了测试下效果，所以随便搞个线程池来搭配，生产建议手动创建线程池</span><br><span class="line">    static ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    static class Task implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;运行任务&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            executorService.execute(new Task());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;准备用shutdown方法关闭线程池&quot;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        System.out.println(&quot;线程池调用了shutdown方法,isShutdown&#x3D;&quot; + executorService.isShutdown());</span><br><span class="line">        System.out.println(&quot;任务还在执行中,isTerminated&#x3D;&quot; + executorService.isTerminated());</span><br><span class="line">        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        System.out.println(&quot;3秒后，任务都执行结束了,isTerminated&#x3D;&quot; + executorService.isTerminated());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap解析</title>
      <link href="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁<br>（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发<br>度更高（并发度就是 Segment 的个数）。Segment 继承自 ReentrantLock。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">   final int hash;</span><br><span class="line">   final K key;</span><br><span class="line">   volatile V value;</span><br><span class="line">   volatile HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁<br>（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发<br>度更高（并发度就是 Segment 的个数）。<br><strong>Segment 继承自 ReentrantLock。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line">   private static final long serialVersionUID &#x3D; 2249069246763182397L;</span><br><span class="line">   static final int MAX_SCAN_RETRIES &#x3D;</span><br><span class="line">   Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;</span><br><span class="line">   transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">   transient int count;</span><br><span class="line">   transient int modCount;</span><br><span class="line">   transient int threshold;</span><br><span class="line">   final float loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_CONCURRENCY_LEVEL &#x3D; 16;</span><br></pre></td></tr></table></figure><img src="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/1.png" class title="如图"><p>HashEntry跟HashMap差不多的，但是不同点是，他使用volatile去修饰了他的数据Value还有下一个节点next。</p><h2 id="并发度高的原因"><a href="#并发度高的原因" class="headerlink" title="并发度高的原因"></a>并发度高的原因</h2><p>原理上来说，ConcurrentHashMap 采用了<strong>分段锁</strong>技术，其中 Segment 继承于 ReentrantLock。</p><p>不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>concurrentHashMap的put 方法首先定位到 某个Segment，调用segment的put方法在对应的segment做插入操作。segment put实现过程：</p><ol><li>获取锁，保证put操作的线程安全；</li><li>定位到HashEntry数组中具体的HashEntry；</li></ol><p>然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，在扩容的时候，首先创建一个容量是原来容量两倍的数组，将原数组的元素再散列后插入到新的数组里。为了高效，ConcurrentHashMap只对某个Segment进行扩容，不会对整个容器扩容。第二步定位添加元素的位置，然后将其放入数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ConcurrentHashMap#put</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">　　Segment&lt;K,V&gt; s;</span><br><span class="line">　　if (value &#x3D;&#x3D; null)</span><br><span class="line">　　　　throw new NullPointerException();</span><br><span class="line">　　int hash &#x3D; hash(key);&#x2F;&#x2F;根据散列函数，计算出key值的散列值</span><br><span class="line">　　int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;&#x2F;&#x2F;这个操作就是定位Segment的数组下标，jdk1.7之前是segmentFor返回Segment，1.7之后直接就取消了这个方法，直接计算数组下标，然后通过偏移量底层操作获取Segment</span><br><span class="line">　　if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck</span><br><span class="line">　　　　　　(segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment</span><br><span class="line">　　　　s &#x3D; ensureSegment(j);&#x2F;&#x2F;通过便宜量定位不到就调用ensureSegment方法定位Segment</span><br><span class="line">　　return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过key定位到Segment，之后在对应的Segment中进行具体的put</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">        int index &#x3D; (tab.length - 1) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class="line">            if (e !&#x3D; null) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue &#x3D; e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value &#x3D; value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                e &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (node !&#x3D; null)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                int c &#x3D; count + 1;</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                else</span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count &#x3D; c;</span><br><span class="line">                oldValue &#x3D; null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get 逻辑比较简单，只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p><p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值,<strong>整个过程都不需要加锁</strong>。。</p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。<br>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>相对于HashMap的resize，ConcurrentHashMap的rehash原理类似，但是Doug Lea为rehash做了一定的优化，避免让所有的节点都进行复制操作：由于扩容是基于2的幂指来操作，假设扩容前某HashEntry对应到Segment中数组的index为i，数组的容量为capacity，那么扩容后该HashEntry对应到新数组中的index只可能为i或者i+capacity，因此大多数HashEntry节点在扩容前后index可以保持不变。基于此，rehash方法中会定位第一个后续所有节点在扩容后index都保持不变的节点，然后将这个节点之前的所有节点重排即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">void rehash() &#123;</span><br><span class="line">HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;</span><br><span class="line">int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">if (oldCapacity &gt;&#x3D; MAXIMUM_CAPACITY)</span><br><span class="line">return;</span><br><span class="line"> </span><br><span class="line">&#x2F;*</span><br><span class="line"> * Reclassify nodes in each list to new Map.  Because we are</span><br><span class="line"> * using power-of-two expansion, the elements from each bin</span><br><span class="line"> * must either stay at same index, or move with a power of two</span><br><span class="line"> * offset. We eliminate unnecessary node creation by catching</span><br><span class="line"> * cases where old nodes can be reused because their next</span><br><span class="line"> * fields won&#39;t change. Statistically, at the default</span><br><span class="line"> * threshold, only about one-sixth of them need cloning when</span><br><span class="line"> * a table doubles. The nodes they replace will be garbage</span><br><span class="line"> * collectable as soon as they are no longer referenced by any</span><br><span class="line"> * reader thread that may be in the midst of traversing table</span><br><span class="line"> * right now.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;*</span><br><span class="line"> * 其实这个注释已经解释的很清楚了，主要就是因为扩展是按照2的幂次方</span><br><span class="line"> * 进行扩展的，所以扩展前在同一个桶中的元素，现在要么还是在原来的</span><br><span class="line"> * 序号的桶里，或者就是原来的序号再加上一个2的幂次方，就这两种选择。</span><br><span class="line"> * 所以原桶里的元素只有一部分需要移动，其余的都不要移动。该函数为了</span><br><span class="line"> * 提高效率，就是找到最后一个不在原桶序号的元素，那么连接到该元素后面</span><br><span class="line"> * 的子链表中的元素的序号都是与找到的这个不在原序号的元素的序号是一样的</span><br><span class="line"> * 那么就只需要把最后一个不在原序号的元素移到新桶里，那么后面跟的一串</span><br><span class="line"> * 子元素自然也就连接上了，而且序号还是相同的。在找到的最后一个不在</span><br><span class="line"> * 原桶序号的元素之前的元素就需要逐个的去遍历，加到和原桶序号相同的新桶上</span><br><span class="line"> * 或者加到偏移2的幂次方的序号的新桶上。这个都是新创建的元素，因为</span><br><span class="line"> * 只能在表头插入元素。这个原因可以参考</span><br><span class="line"> * 《探索 ConcurrentHashMap 高并发性的实现机制》中的讲解</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line">HashEntry&lt;K,V&gt;[] newTable &#x3D; HashEntry.newArray(oldCapacity&lt;&lt;1);</span><br><span class="line">threshold &#x3D; (int)(newTable.length * loadFactor);</span><br><span class="line">int sizeMask &#x3D; newTable.length - 1;</span><br><span class="line">for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">&#x2F;&#x2F; We need to guarantee that any existing reads of old Map can</span><br><span class="line">&#x2F;&#x2F;  proceed. So we cannot yet null out each bin.</span><br><span class="line">HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];</span><br><span class="line"> </span><br><span class="line">if (e !&#x3D; null) &#123;</span><br><span class="line">HashEntry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">int idx &#x3D; e.hash &amp; sizeMask;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;  Single node on list</span><br><span class="line">if (next &#x3D;&#x3D; null)</span><br><span class="line">newTable[idx] &#x3D; e;</span><br><span class="line"> </span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; Reuse trailing consecutive sequence at same slot</span><br><span class="line">HashEntry&lt;K,V&gt; lastRun &#x3D; e;</span><br><span class="line">int lastIdx &#x3D; idx;</span><br><span class="line">for (HashEntry&lt;K,V&gt; last &#x3D; next;</span><br><span class="line"> last !&#x3D; null;</span><br><span class="line"> last &#x3D; last.next) &#123;</span><br><span class="line">int k &#x3D; last.hash &amp; sizeMask;</span><br><span class="line">&#x2F;&#x2F; 这里就是遍历找到最后一个不在原桶序号处的元素</span><br><span class="line">if (k !&#x3D; lastIdx) &#123;</span><br><span class="line">lastIdx &#x3D; k;</span><br><span class="line">lastRun &#x3D; last;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 把最后一个不在原桶序号处的元素赋值到新桶中</span><br><span class="line">&#x2F;&#x2F; 由于链表本身的特性，那么该元素后面的元素也都能连接过来</span><br><span class="line">&#x2F;&#x2F; 并且能保证后面的这些元素在新桶中的序号都是和该元素是相等的</span><br><span class="line">&#x2F;&#x2F; 因为上面的遍历就是确保了该元素后面的元素的序号都是和这个元素</span><br><span class="line">&#x2F;&#x2F; 的序号是相等的。不然遍历中还会重新赋值lastIdx</span><br><span class="line">newTable[lastIdx] &#x3D; lastRun;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Clone all remaining nodes</span><br><span class="line">&#x2F;&#x2F; 这个就是把上面找到的最后一个不在原桶序号处的元素之前的元素赋值到</span><br><span class="line">&#x2F;&#x2F; 新桶上，注意都是把元素添加到新桶的表头处</span><br><span class="line">for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;</span><br><span class="line">int k &#x3D; p.hash &amp; sizeMask;</span><br><span class="line">HashEntry&lt;K,V&gt; n &#x3D; newTable[k];</span><br><span class="line">newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(p.key, p.hash,</span><br><span class="line"> n, p.value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">table &#x3D; newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-8他的数据结构"><a href="#1-8他的数据结构" class="headerlink" title="1.8他的数据结构"></a>1.8他的数据结构</h2><p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p><p>跟HashMap很像，也把之前的HashEntry改成了Node，但是作用不变，把值和next采用了volatile去修饰，保证了可见性，并且也引入了红黑树，在链表大于一定值的时候会转换（默认是8）。</p><p>① 取消分段锁机制，进一步降低冲突概率。② 引入红黑树结构，同一个哈希槽上的元素个数超过一定阈值后，单向链表改为红黑树结构。③ 使用了更加优化的方式统计集合内的元素数量。具体优化表现在：在 put、resize 和 size 方法中设计元素总数的更新和计算都避免了锁，使用 CAS 代替。</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><p>①根据 key 计算出 hashcode，判断是否需要进行初始化。 。</p><p>②<code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p><p>③如果都不满足，则利用 synchronized 锁写入数据。</p><p>④如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        int binCount &#x3D; 0;</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">                tab &#x3D; initTable();</span><br><span class="line">            else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                    break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                synchronized (f) &#123;</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123;</span><br><span class="line">                            binCount &#x3D; 1;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal &#x3D; e.val;</span><br><span class="line">                                    if (!onlyIfAbsent)</span><br><span class="line">                                        e.val &#x3D; value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                    pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount &#x3D; 2;</span><br><span class="line">                            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) !&#x3D; null) &#123;</span><br><span class="line">                                oldVal &#x3D; p.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    p.val &#x3D; value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (binCount !&#x3D; 0) &#123;</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    if (oldVal !&#x3D; null)</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><img src="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/2.png" class title="如图"><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p><code>get</code> 同样不需要同步</p><p>1.根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p><p>2.如果是红黑树那就按照树的方式获取值。</p><p>3.就不满足那就按照链表的方式遍历获取值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">      int h &#x3D; spread(key.hashCode());</span><br><span class="line">      if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">          (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;</span><br><span class="line">          if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;</span><br><span class="line">              if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))</span><br><span class="line">                  return e.val;</span><br><span class="line">          &#125;</span><br><span class="line">          else if (eh &lt; 0)</span><br><span class="line">              return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">          while ((e &#x3D; e.next) !&#x3D; null) &#123;</span><br><span class="line">              if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                  ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                  return e.val;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><img src="/2020/06/27/ConcurrentHashMap%E8%A7%A3%E6%9E%90/3.png" class title="如图"><h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><h2 id="扩容时候遇到put操作怎么办"><a href="#扩容时候遇到put操作怎么办" class="headerlink" title="扩容时候遇到put操作怎么办"></a>扩容时候遇到put操作怎么办</h2><p>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索</p><p><strong>ForwardingNode</strong>： 是临时节点，这个节点会出现在扩容的时候，不存储实际的数据数据。</p><p>这是一个真正的辅助类，该类仅仅只存活在ConcurrentHashMap扩容操作时。只是一个标志节点，并且指向nextTable，它提供find方法而已。该类也是集成Node节点，其hash为-1，key、value、next均为null。如下：</p><pre><code>static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; {    final Node&lt;K,V&gt;[] nextTable;    ForwardingNode(Node&lt;K,V&gt;[] tab) {        super(MOVED, null, null, null);        this.nextTable = tab;    }    Node&lt;K,V&gt; find(int h, Object k) {    // loop to avoid arbitrarily deep recursion on forwarding nodes    outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) {        Node&lt;K,V&gt; e; int n;        if (k == null || tab == null || (n = tab.length) == 0 ||                (e = tabAt(tab, (n - 1) &amp; h)) == null)            return null;        for (;;) {            int eh; K ek;            if ((eh = e.hash) == h &amp;&amp;                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))                return e;            if (eh &lt; 0) {                if (e instanceof ForwardingNode) {                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;                    continue outer;                }                else                    return e.find(h, k);            }            if ((e = e.next) == null)                return null;        }    }}}</code></pre><p>如果Hash桶被迁移到新的table中，会在旧的table插入一个ForwardingNode临时节点，内部会指向新的table。</p><p>当读操作碰到ForwardingNode，会通过ForwardingNode内部的nextTable找到新的table，继续读。</p><p>当写操作碰到ForwadingNode，加入帮助扩容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span><br><span class="line">private final void tryPresize(int size) &#123;</span><br><span class="line">    &#x2F;&#x2F; c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span><br><span class="line">    int c &#x3D; (size &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span><br><span class="line">    int sc;</span><br><span class="line">    while ((sc &#x3D; sizeCtl) &gt;&#x3D; 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab &#x3D; table; int n;</span><br><span class="line">        &#x2F;&#x2F; 这个 if 分支和之前说的初始化数组的代码基本上是一样的</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            n &#x3D; (sc &gt; c) ? sc : c;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (table &#x3D;&#x3D; tab) &#123;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        table &#x3D; nt;</span><br><span class="line">                        sc &#x3D; n - (n &gt;&gt;&gt; 2); &#x2F;&#x2F; 0.75 * n</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    sizeCtl &#x3D; sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (c &lt;&#x3D; sc || n &gt;&#x3D; MAXIMUM_CAPACITY)</span><br><span class="line">            break;</span><br><span class="line">        else if (tab &#x3D;&#x3D; table) &#123;</span><br><span class="line">            int rs &#x3D; resizeStamp(n);</span><br><span class="line">            if (sc &lt; 0) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||</span><br><span class="line">                    transferIndex &lt;&#x3D; 0)</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span><br><span class="line">                &#x2F;&#x2F; 此时 nextTab 不为 null</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span><br><span class="line">            &#x2F;&#x2F; 调用 transfer 方法，此时 nextTab 参数为 null</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap解析</title>
      <link href="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>内部包含了一个 Entry 类型的数组 table,1.8之后改成Node。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;transient Entry[] table;</span><br><span class="line">  transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当<br>成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结<br>果相同的 Entry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//key的hash值，put和get的时候都需要用到它来确定元素在数组中的位置</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="comment">//指向单链表的下一个节点</span></span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="keyword">this</span>.hash = hash;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><img src="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/2.png" class title="流程图"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法，会先调用一个hash()方法，得到当前key的一个hash值，</span></span><br><span class="line"><span class="comment">//用于确定当前key应该存放在数组的哪个下标位置</span></span><br><span class="line"><span class="comment">//这里的 hash方法，我们姑且先认为是key.hashCode()，其实不是的，一会儿细讲</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把hash值和当前的key，value传入进来</span></span><br><span class="line"><span class="comment">//这里onlyIfAbsent如果为true，表明不能修改已经存在的值，因此我们传入false</span></span><br><span class="line"><span class="comment">//evict只有在方法 afterNodeInsertion(boolean evict) &#123; &#125;用到，可以看到它是一个空实现，因此不用关注这个参数</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">//判断table是否为空，如果空的话，会先调用resize扩容</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">n = (tab = resize()).length;</span><br><span class="line"><span class="comment">//根据当前key的hash值找到它在数组中的下标，判断当前下标位置是否已经存在元素，</span></span><br><span class="line"><span class="comment">//若没有，则把key、value包装成Node节点，直接添加到此位置。</span></span><br><span class="line"><span class="comment">// i = (n - 1) &amp; hash 是计算下标位置的，为什么这样算，后边讲</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">//如果当前位置已经有元素了，分为三种情况。</span></span><br><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">//1.当前位置元素的hash值等于传过来的hash，并且他们的key值也相等，</span></span><br><span class="line"><span class="comment">//则把p赋值给e，跳转到①处，后续需要做值的覆盖处理</span></span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">e = p;</span><br><span class="line"><span class="comment">//2.如果当前是红黑树结构，则把它加入到红黑树 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//3.说明此位置已存在元素，并且是普通链表结构，则采用尾插法，把新节点加入到链表尾部</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果头结点的下一个节点为空，则插入新节点</span></span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果在插入的过程中，链表长度超过了8，则转化为红黑树</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line"><span class="comment">//插入成功之后，跳出循环，跳转到①处</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若在链表中找到了相同key的话，直接退出循环，跳转到①处</span></span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">p = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//① </span></span><br><span class="line"><span class="comment">//1.说明发生了碰撞，e代表的是旧值，因此节点位置不变，但是需要替换为新值</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">V oldValue = e.value;</span><br><span class="line"><span class="comment">//用新值替换旧值，并返回旧值。</span></span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">e.value = value;</span><br><span class="line"><span class="comment">//看方法名字即可知，这是在node被访问之后需要做的操作。其实此处是一个空实现，</span></span><br><span class="line"><span class="comment">//只有在 LinkedHashMap才会实现，用于实现根据访问先后顺序对元素进行排序，hashmap不提供排序功能</span></span><br><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="comment">//void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span></span><br><span class="line">afterNodeAccess(e);</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fail-fast机制</span></span><br><span class="line">++modCount;</span><br><span class="line"><span class="comment">//如果当前数组中的元素个数超过阈值，则扩容</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">resize();</span><br><span class="line"><span class="comment">//同样的空实现</span></span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hash方法"><a href="#Hash方法" class="headerlink" title="Hash方法"></a>Hash方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">两个值进行与运算，结果会趋向于<span class="number">0</span>；或运算，结果会趋向于<span class="number">1</span>；而只有异或运算，<span class="number">0</span>和<span class="number">1</span>的比例可以达到<span class="number">1</span>:<span class="number">1</span>的平衡状态。（非呢？别扯犊子了，两个值怎么做非运算。。。）</span><br><span class="line">所以，异或运算之后，可以让结果的随机性更大，而随机性大了之后，哈希碰撞的概率当然就更小了</span><br></pre></td></tr></table></figure><p>这里，会先判断key是否为空，若为空则返回0。这也说明了hashMap是支持key传 null 的。若非空，则先计算key的hashCode值，赋值给h，然后把h右移16位，并与原来的h进行异或处理。为什么要这样做，这样做有什么好处呢？</p><p>可以看到，其实相当于，我们把高16位值和当前h的低16位进行了混合，这样可以尽量保留高16位的特征，从而降低哈希碰撞的概率。</p><p>思考一下，为什么这样做，就可以降低哈希碰撞的概率呢？先别着急，我们需要结合 i = (n - 1) &amp; hash 这一段运算来理解。</p><p> <strong>i = (n - 1) &amp; hash</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y :       10110010</span><br><span class="line">x-1 :     00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure><p>这个性质和 y 对 x 取模效果是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y :   10110010</span><br><span class="line">x :   00010000</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><ul><li>首先将key hash之后取得所定位的桶</li><li>如果桶为空，则直接返回null</li><li>否则判断桶的第一个位置（有可能是链表、红黑树）的key是否为查询的key，是就直接返回value</li><li>如果第一个不匹配，则判断它的下一个是红黑树还是链表</li><li>红黑树就按照树的查找方式返回值</li><li>不然就按照链表的方式遍历匹配返回值<img src="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/3.png" class title="流程图"></li></ul><h3 id="为什么HashMap链表会形成死循环"><a href="#为什么HashMap链表会形成死循环" class="headerlink" title="为什么HashMap链表会形成死循环"></a>为什么HashMap链表会形成死循环</h3><p>准确的讲应该是 JDK1.7 的 HashMap 链表会有死循环的可能，因为JDK1.7是采用的头插法，在多线程环境下有可能会使链表形成环状，从而导致死循环。JDK1.8做了改进，用的是尾插法，不会产生死循环。</p><h3 id="JDK7与JDK8中HashMap的不同点"><a href="#JDK7与JDK8中HashMap的不同点" class="headerlink" title="JDK7与JDK8中HashMap的不同点"></a>JDK7与JDK8中HashMap的不同点</h3><ul><li><p>JDK8中使用了红黑树</p></li><li><p>JDK7中链表的插入使用的头插法（扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致CPU飙升），JDK8中链表使用的尾插法（JDK8中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法</p></li></ul><h2 id="那为啥用16不用别的呢？"><a href="#那为啥用16不用别的呢？" class="headerlink" title="那为啥用16不用别的呢？"></a>那为啥用16不用别的呢？</h2><p>因为在使用是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。</p><p>只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。这是为了<strong>实现均匀分布</strong>。</p><h2 id="为什么是0-75？"><a href="#为什么是0-75？" class="headerlink" title="为什么是0.75？"></a>为什么是0.75？</h2><p>HashMap负载因子为什么是0.75？<br>HashMap有一个初始容量大小，默认是16<br>static final int DEAFULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16<br>为了减少冲突概率，当HashMap的数组长度达到一个临界值就会触发扩容，把所有元素rehash再放回容器中，这是一个非常耗时的操作。<br>而这个临界值由负载因子和当前的容量大小来决定：<br>DEFAULT_INITIAL_CAPACITY<em>DEFAULT_LOAD_FACTOR<br>即默认情况下数组长度是16</em>0.75=12时，触发扩容操作。<br>所以使用hash容器时尽量预估自己的数据量来设置初始值。<br>那么，为什么负载因子要默认为0.75，在HashMap注释中有这么一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Ideally, under random hashCodes, the frequency of</span><br><span class="line">\* nodes in bins follows a Poisson distribution</span><br><span class="line">\* (http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Poisson_distribution) with a</span><br><span class="line">\* parameter of about 0.5 on average for the default resizing</span><br><span class="line">\* threshold of 0.75, although with a large variance because of</span><br><span class="line">\* resizing granularity. Ignoring variance, the expected</span><br><span class="line">\* occurrences of list size k are (exp(-0.5) * pow(0.5, k) &#x2F;</span><br><span class="line">\* factorial(k)). The first values are:</span><br><span class="line">*</span><br><span class="line">\* 0:  0.60653066</span><br><span class="line">\* 1:  0.30326533</span><br><span class="line">\* 2:  0.07581633</span><br><span class="line">\* 3:  0.01263606</span><br><span class="line">\* 4:  0.00157952</span><br><span class="line">\* 5:  0.00015795</span><br><span class="line">\* 6:  0.00001316</span><br><span class="line">\* 7:  0.00000094</span><br><span class="line">\* 8:  0.00000006</span><br><span class="line">\* more: less than 1 in ten million</span><br></pre></td></tr></table></figure><p>在理想情况下，使用随机哈希吗，节点出现的频率在hash桶中遵循泊松分布，同时给出了桶中元素的个数和概率的对照表。<br>从上表可以看出当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为负载因子，每个碰撞位置的链表长度超过8个是几乎不可能的。<br>hash容器指定初始容量尽量为2的幂次方。<br>HashMap负载因子为0.75是空间和时间成本的一种折中。</p><h2 id="什么时候变成红黑树"><a href="#什么时候变成红黑树" class="headerlink" title="什么时候变成红黑树"></a>什么时候变成红黑树</h2><p>一个是链表长度到8,一个是数组长度到64.</p><h2 id="HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？"><a href="#HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？" class="headerlink" title="HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？"></a>HashMap在多线程环境下存在线程安全问题，那你一般都是怎么处理这种情况的？</h2><p>1.Hashtable</p><p>2.ConcurrentHashMap</p><p>不过出于线程并发度的原因，我都会舍弃前两者使用最后的ConcurrentHashMap，他的性能和效率明显高于前两者。</p><h2 id="Hashtable效率低"><a href="#Hashtable效率低" class="headerlink" title="Hashtable效率低"></a>Hashtable效率低</h2><p>他在对数据操作的时候都会上锁，所以效率比较低下。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p><strong>resize 方法：扩容数组</strong>,分为两个部分，一个是扩容数组，一个是重新规划长度。</p><p>重新规划长度和阈值，如果长度发生了变化，部分数据节点也要重新排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 HashMap实行了懒加载, 新建HashMap时不会对table进行赋值, 而是到第一次插入时, 进行resize时构建table;</span><br><span class="line">2 当HashMap.size 大于 threshold时, 会进行resize;threshold的值我们在上一次分享中提到过: 当第一次构建时, 如果没有指定HashMap.table的初始长度, 就用默认值16, 否则就是指定的值; 然后不管是第一次构建还是后续扩容, threshold &#x3D; table.length * loadFactor;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr &#x3D; threshold;</span><br><span class="line">        int newCap, newThr &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;如果原table不为空</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果原容量已经达到最大容量了，无法进行扩容，直接返回</span><br><span class="line">            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;设置新容量为旧容量的两倍</span><br><span class="line">            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                &#x2F;&#x2F;阈值也变为原来的两倍</span><br><span class="line">                newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">        * 从构造方法我们可以知道</span><br><span class="line">        * 如果没有指定initialCapacity, 则不会给threshold赋值, 该值被初始化为0</span><br><span class="line">    * 如果指定了initialCapacity, 该值被初始化成大于initialCapacity的最小的2的次幂</span><br><span class="line">* 这里这种情况指的是原table为空，并且在初始化的时候指定了容量，</span><br><span class="line">* 则用threshold作为table的实际大小</span><br><span class="line">*&#x2F;</span><br><span class="line">        else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">            newCap &#x3D; oldThr;</span><br><span class="line">        &#x2F;&#x2F;构造方法中没有指定容量，则使用默认值</span><br><span class="line">        else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 计算指定了initialCapacity情况下的新的 threshold</span><br><span class="line">        if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold &#x3D; newThr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**从以上操作我们知道, 初始化HashMap时, </span><br><span class="line">    *  如果构造函数没有指定initialCapacity, 则table大小为16</span><br><span class="line">    *  如果构造函数指定了initialCapacity, 则table大小为threshold,</span><br><span class="line">    *  即大于指定initialCapacity的最小的2的整数次幂</span><br><span class="line">    </span><br><span class="line">    *  从下面开始, 初始化table或者扩容, 实际上都是通过新建一个table来完成</span><br><span class="line">    *&#x2F; </span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table &#x3D; newTab;</span><br><span class="line">        if (oldTab !&#x3D; null) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                  &#x2F;** 这里注意, table中存放的只是Node的引用,这里将oldTab[j]&#x3D;null只是清除旧表的引用, </span><br><span class="line">                   * 但是真正的node节点还在, 只是现在由e指向它</span><br><span class="line">                   *&#x2F;</span><br><span class="line">                    oldTab[j] &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F;桶中只有一个节点，直接放入新桶中</span><br><span class="line">                    if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                    &#x2F;&#x2F;桶中为红黑树，则对树进行拆分，对树的操作有机会再讲</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    &#x2F;&#x2F;桶中为链表，对链表进行拆分</span><br><span class="line">                    else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    &#x2F;&#x2F;下面为对链表的拆分，我们单独来讲一下。</span><br><span class="line">                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next &#x3D; e.next;</span><br><span class="line">                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                    loHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; e;</span><br><span class="line">                                loTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                    hiHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; e;</span><br><span class="line">                                hiTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                        if (loTail !&#x3D; null) &#123;</span><br><span class="line">                            loTail.next &#x3D; null;</span><br><span class="line">                            newTab[j] &#x3D; loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                            hiTail.next &#x3D; null;</span><br><span class="line">                            newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>重新规划长度</strong></p><p>①  判断原来的table是否不为空，是的话判断: 如果原容量大于等于最大容量，那么将阈值设为 Integer 的最大值，并且 return 终止扩容，由于 size 不可能超过该值因此之后不会再发生扩容。如果 size 超出扩容阈值，把 table 容量增加为之前的2倍。否则 把 table 容量增加为之前的2倍。</p><p>② 判断oldThr&gt;0, 如果是hashmap传入指定的initialCapacity，这个初始值会给到oldThr.</p><p>③ 否则的话 传入默认的容量和负载因子</p><p><strong>重新排列数据节点</strong></p><p>① 如果节点为 null 值则不进行处理。② 否则如果节点没有next节点，那么重新计算其散列值然后存入新的 table 数组中。③ 如果节点为 TreeNode 节点，那么调用 split 方法进行处理，该方法用于对红黑树调整，如果太小会退化回链表。④ 如果节点是链表节点，需要将链表拆分为 超出旧容量的链表和未超出容量的链表。对于<code>hash &amp; oldCap == 0</code> 的部分不需要做处理，反之需要放到新的下标位置上，新下标 = 旧下标 + 旧容量。</p><p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capacity : 00010000</span><br><span class="line">new capacity : 00100000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   old:</span><br><span class="line">   10: 0000 1010</span><br><span class="line">   15: 0000 1111</span><br><span class="line">    &amp;: 0000 1010    </span><br><span class="line">    </span><br><span class="line">   new:</span><br><span class="line">   10: 0000 1010</span><br><span class="line">   31: 0001 1111</span><br><span class="line">    &amp;: 0000 1010    </span><br><span class="line"></span><br><span class="line">从上面的示例可以很轻易的看出, 两次indexFor()的差别只是第二次参与位于比第一次左边有一位从0变为1, 而这个变化的1刚好是oldCap, 那么只需要判断原key的hash这个位上是否为1: 若是1, 则需要移动至oldCap + i的槽位, 若为0, 则不需要移动;</span><br></pre></td></tr></table></figure><p>对于一个 Key<br>它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；<br>如果为 1，那么得到的结果为原来的结果 +16。</p><p><strong>线程不安全：</strong>Java 7 扩容时 resize 方法调用的 transfer 方法中使用头插法迁移元素，多线程会导致 Entry 链表形成环形数据结构，Entry 节点的 next 永远不为空，引起死循环。Java 8 在 resize 方法中完成扩容，并且改用了尾插法，不会产生死循环的问题，但是在多线程的情况下还是可能会导致数据覆盖的问题，因此依旧线程不安全。</p><h2 id="为啥Hashtable-是不允许键或值为-null-的，HashMap-的键值则都可以为-null？"><a href="#为啥Hashtable-是不允许键或值为-null-的，HashMap-的键值则都可以为-null？" class="headerlink" title="为啥Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null？"></a>为啥Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null？</h2><p>ConcurrentHashmap和Hashtable都是支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。HashMap是非并发的，可以通过contains(key)来做这个判断。而支持并发的Map在调用m.contains（key）和m.get(key),m可能已经不同了</p><h2 id="和HashTable的对比"><a href="#和HashTable的对比" class="headerlink" title="和HashTable的对比"></a>和HashTable的对比</h2><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p>fail-fast的字面意思是“快速失败”。在迭代器遍历元素的过程中，需要比较操作前后 modCount 是否改变，如果改变了说明集合结构被改变，需要抛出ConcurrentModificationException,防止继续遍历。</p><h2 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h2><p>当我们对集合结构上做出改变的时候，fail-fast机制就会抛出异常。但是，对于采用fail-safe机制来说，就不会抛出异常(大家估计看到safe两个字就知道了)。</p><p>这是因为，当集合的结构被改变的时候，fail-safe机制会在复制原集合的一份数据出来，然后在复制的那份数据遍历。</p><p>因此，虽然fail-safe不会抛出异常，但存在以下缺点：</p><p>1.复制时需要额外的空间和时间上的开销。</p><p>2.不能保证遍历的是最新内容</p><h2 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h2><p>resize方法</p><pre><code>void resize(int newCapacity) {    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    if (oldCapacity == MAXIMUM_CAPACITY) {        threshold = Integer.MAX_VALUE;        return;    }    Entry[] newTable = new Entry[newCapacity];    boolean oldAltHashing = useAltHashing;    useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;            (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);    boolean rehash = oldAltHashing ^ useAltHashing;//判断是否需要对原node重新hash定位table的index    transfer(newTable, rehash); //扩容核心方法    table = newTable;    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);}</code></pre><p>JDK7的transfer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新table的容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//遍历原table</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            <span class="comment">//保存下一次循环的 Entry&lt;K,V&gt;</span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                <span class="comment">//通过e的key值计算e的hash值</span></span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//得到e在新table中的插入位置</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">//采用链头插入法将e插入i位置，最后得到的链表相对于原table正好是头尾相反的</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            <span class="comment">//下一次循环</span></span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/26/HashMap%E8%A7%A3%E6%9E%90/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201201160858877.png" alt="image-20201201160858877"></p><p>扩容时 <code>resize</code> 调用 <code>transfer</code> 使用头插法迁移元素，每个线程都会生成newTable (newTable 是局部变量)，但原先 table 中的 Entry <a href>链表</a>是共享的.假设两个线程，线程1挂起，线程二执行迁移完成，此时线程1继续执行，本来是用e遍历table，用next保存下一个结点，但这样顺序就颠倒了。</p><p>JDK8 在 <code>resize</code> 方法中完成扩容，并改用尾插法，不会产生死循环，但并发下仍可能丢失数据。可用 ConcurrentHashMap 或 <code>Collections.synchronizedMap</code> 包装同步集合</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>换电脑了迁移hexo博客(Win-&gt;MAC)</title>
      <link href="/2020/06/26/%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E8%BF%81%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/06/26/%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E8%BF%81%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>1.找到自己Windows的hexo根目录</p><p>2.在 Mac安装git和node.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先在自己电脑上装好node和git（首先确保brew安装好了）</span><br><span class="line">brew install git</span><br><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>3.安装hexo</p><p>用node.js来安装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo g</span><br></pre></td></tr></table></figure><p>4.初始化hexo目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">新建一个hexo目录，</span><br><span class="line"></span><br><span class="line">mkdir bolg</span><br><span class="line"></span><br><span class="line">cd blog</span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line">在用hexo s测试是否成功，打开localhost:4000查看本地</span><br></pre></td></tr></table></figure><p>5.生成SSH密钥，关联github</p><p>先查看本地的SSH key: cd ~/.ssh<br>(我是新mac电脑，所以没有的，直接生成密钥）<br>$ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a>“    后面那个是注册邮箱</p><p>进入.ssh文件夹： cd ~/.ssh，然后打开里面的 id_rsa.pub文件，里面的内容就是 SSH key，复制全部内容；</p><p>网页打开 github 的设置：Settings -&gt; SSH and GPG keys，点击绿色的按钮 New SSH key，然后在输入框中输入刚才复制的内容；</p><p>保存后，github 会向你的邮箱发送一个验证链接（记得要去登录邮箱验证，不然之后的 hexo d 部署会一直不成功的！）；</p><p>测试一下是否成功：ssh <a href="mailto:git@github.com">git@github.com</a>，<br>看到以下即成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PTY allocation request failed on channel <span class="number">0</span></span><br><span class="line">Hi gjincai! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">Connection to github.com closed.</span></span><br></pre></td></tr></table></figure><p>6.文件配置转移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windows 下的博客根目录 hexo，复制该目录下的：_config.yml, scaffolds, source, themes,<span class="keyword">package</span>.json；</span><br><span class="line">mac 下的博客根目录 hexo，把刚才复制的内容，直接覆盖替换相同的文件文件夹。</span><br></pre></td></tr></table></figure><p> 7.设置个人信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname”</span><br><span class="line">git config --global user.email youremail@example.com</span><br></pre></td></tr></table></figure><p>到这就好了，和往常一样hexo g        hexo d发布文章吧！</p><p>结果会提示ERROR Deployer not found: git</p><p>安装以下再尝试：npm install hexo-deployer-git –save（若提示有关权限不足的，加sudo，反正我是遇到了）</p><p>之后就能正常发布文章了！nice</p>]]></content>
      
      
      <categories>
          
          <category> hexo相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis缓存穿透、击穿、雪崩等</title>
      <link href="/2020/06/26/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%AD%89/"/>
      <url>/2020/06/26/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h2><p>正常情况下，查询的数据都存在，如果请求一个不存在的数据，也就是缓存和数据库都查不到这个数据，每次都会去数据库查询，这种查询不存在数据的现象我们称为缓存穿透</p><h3 id="穿透带来的问题"><a href="#穿透带来的问题" class="headerlink" title="穿透带来的问题"></a>穿透带来的问题</h3><p>如果每次都拿一个不存在的id去查询数据库，可能会导致你的数据库压力增大</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>缓存空值<br> 之所以发生穿透，是因为缓存中没有存储这些数据的key，从而每次都查询数据库<br>我们可以为这些key在缓存中设置对应的值为null，后面查询这个key的时候就不用查询数据库了<br>当然为了健壮性，我们要对这些key设置过期时间，以防止真的有数据</li><li>BloomFilter<br>BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中<br>我们把有数据的key都放到BloomFilter中，每次查询的时候都先去BloomFilter判断，如果没有就直接返回null<br>注意BloomFilter没有删除操作，对于删除的key，查询就会经过BloomFilter然后查询缓存再查询数据库，所以BloomFilter可以结合缓存空值用，对于删除的key，可以在缓存中缓存null</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>在高并发的情况下，大量的请求同时查询同一个key时，此时这个key正好失效了，就会导致同一时间，这些请求都会去查询数据库，这样的现象我们称为缓存击穿</p><h3 id="击穿带来的问题"><a href="#击穿带来的问题" class="headerlink" title="击穿带来的问题"></a>击穿带来的问题</h3><p>会造成某一时刻数据库请求量过大</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>1.使用互斥锁(mutex key)</strong></p><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p><p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">String value = redis.get(key);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//代表缓存值过期</span></span><br><span class="line"><span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line"><span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//代表设置成功</span></span><br><span class="line">value = db.get(key);</span><br><span class="line">redis.set(key, value, expire_secs);</span><br><span class="line">redis.del(key_mutex);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">sleep(<span class="number">50</span>);</span><br><span class="line">get(key);</span><br><span class="line"><span class="comment">//重试</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.”永远不过期”**</p><p>这里的“永远不过期”包含两层意思：</p><p>(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。</p><p>(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期</p><p>从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">V v = redis.get(key);</span><br><span class="line">String value = v.getValue();</span><br><span class="line"><span class="keyword">long</span> timeout = v.getTimeout();</span><br><span class="line"><span class="keyword">if</span> (v.timeout &lt;= System.currentTimeMillis()) &#123;</span><br><span class="line"><span class="comment">// 异步更新后台异常执行  </span></span><br><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String keyMutex = <span class="string">"mutex:"</span> + key;</span><br><span class="line"><span class="keyword">if</span> (redis.setnx(keyMutex, <span class="string">"1"</span>)) &#123;</span><br><span class="line"><span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">redis.expire(keyMutex, <span class="number">3</span> * <span class="number">60</span>);</span><br><span class="line">String dbValue = db.get(key);</span><br><span class="line">redis.set(key, dbValue);</span><br><span class="line">redis.delete(keyMutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了</p><h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效</li><li>ehcache本地缓存 + Hystrix限流&amp;降级<br>ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵<br>使用 Hystrix进行限流 &amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑</li><li>在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了</li><li>热点数据永不过期，参考上文</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阻塞、同步、乐观悲观相关概念</title>
      <link href="/2020/06/25/%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E4%B9%90%E8%A7%82%E6%82%B2%E8%A7%82%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/06/25/%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E4%B9%90%E8%A7%82%E6%82%B2%E8%A7%82%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>当某个任务在执行过程中发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；</p><h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><p>当某个任务在执行过程中发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直处于等待状态。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>当多个任务要发生时，这些任务必须逐个地进行，一个任务的执行会导致整个流程的暂时等待，这些事件不是并发地执行的；</p><h2 id="非同步"><a href="#非同步" class="headerlink" title="非同步"></a>非同步</h2><p>当多个任务要发生时，这些任务可以并发地执行，一个任务的执行不会导致整个流程的暂时等待。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。</p><p>共享锁【Shared lock】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p><p>排他锁【Exclusive lock】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改</p><p>乐观锁和悲观锁？在数据库里如何实现？   </p><p>​    乐观锁，是基于版本号，给每个记录添加一个版本号，当更新数据只有版本号相同才会更新   </p><p>​    悲观锁，使用数据库自己的锁，先将自动提交关闭，再开启一个事务，对要更新的数据进行select … for update，可以使得其他也想更新同一个数据的事务阻塞等待。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized的相关性质</title>
      <link href="/2020/06/24/synchronized%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/"/>
      <url>/2020/06/24/synchronized%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="对象布局"><a href="#对象布局" class="headerlink" title="对象布局"></a>对象布局</h2><p><img src="/2020/06/24/synchronized%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201108194840943.png" alt="image-20201108194840943"></p><p>对象填充，是将一个对象大小不足 8 个字节的倍数时，使用 0 填充补齐，为了更高效效率的读取数据，64 java 虚拟机，一次读取是 64 bit（8 字节）。 // monitor也是class, 其实例会存储在堆中，MarkWord中保存的是它的指针</p><p><strong>Mark Word</strong>：默认存储对象的 HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以 Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化。</p><p><img src="/2020/06/24/synchronized%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201108195403335.png" alt="image-20201108195403335"></p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h3 id="Array-Length"><a href="#Array-Length" class="headerlink" title="Array Length"></a>Array Length</h3><p>数组长度只在数组类型的对象中存在。用于记录数组的长度。避免获取数组长度时，动态计算。以空间换时间</p><h2 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h2><p><strong>反编译后,synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头).当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/30/16315cd5fa7cf91c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="对象，对象监视器，同步队列和线程状态的关系"></p><p>`<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png" alt="synchronized关键字原理"></p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>1.同步一个代码块</p><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.同步一个方法</p><p>作用于同一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.同步一个类</p><p>作用于整个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.同步一个静态方法</p><p>整个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和volatile的对比"><a href="#和volatile的对比" class="headerlink" title="和volatile的对比"></a>和volatile的对比</h2><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。<br>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成<br>私有数据对待，也就可以将它们的锁进行消除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String concatString(String s1, String s2, String s3) &#123;</span><br><span class="line">  return s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连<br>续 append() 操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String concatString(String s1, String s2, String s3) &#123;</span><br><span class="line">  StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">  sb.append(s1);</span><br><span class="line">  sb.append(s2);</span><br><span class="line">  sb.append(s3);</span><br><span class="line">  return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line"> StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"> sb.append(s1);</span><br><span class="line"> sb.append(s2);</span><br><span class="line"> sb.append(s3);</span><br><span class="line"> <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次就可以了。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>当轻量级锁膨胀到重量级锁之后，意味着线程只能被挂起阻塞来等待唤醒了。每一个对象中都有一个Monitor监视器，而Monitor依赖操作系统的 MutexLock(互斥锁)来实现的, 线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能。<br> monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。而且当一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。我们可以简单的理解为，在加重量级锁的时候会执行monitorenter指令，解锁时会执行monitorexit指令。</p><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。</p><p>另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。</p><h3 id="自适应自旋"><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a>自适应自旋</h3><p>在 JDK1.7 开始，引入了自适应自旋锁，修改自旋锁次数的JVM参数被取消，虚拟机不再支持由用户配置自旋锁次数，而是由虚拟机自动调整。自适应意味着自旋的次数不是固定不变的，而是根据前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>轻量级锁在加锁过程中，用到了自旋锁。</p><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。自旋锁的思想是让一个线程在请求一个共享数据的锁时自旋一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。<br>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行循环操作占用 CPU 时间，它只适用于共享数据的<br>锁定状态很短的场景。<br>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数<br>及锁的拥有者的状态来决定。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>自旋锁的目标是降低线程切换的成本。</p><blockquote><p><strong>加锁</strong></p></blockquote><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中<strong>创建用于存储锁记录的空间</strong>，并将对象头中的Mark Word复制到锁记录中，官方称为<strong>Displaced Mark Word</strong>。然后线程尝试使用CAS<strong>将对象头中的Mark Word替换为指向锁记录的指针</strong>。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><blockquote><p><strong>解锁</strong></p></blockquote><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗</strong>。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，同时使用 CAS 操作将线程 ID 记录到 Mark Word中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。<br>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定<br>状态或者轻量级锁状态。</p><h2 id="synchronized和volatile的比较"><a href="#synchronized和volatile的比较" class="headerlink" title="synchronized和volatile的比较"></a>synchronized和volatile的比较</h2><p>1.volatile本质是告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取，synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p><p>2.volatile仅能用在变量级别，而synchronized可以使用在变量、方法、类级别。</p><p>3.volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</p><p>4.volatile不会造成线程阻塞，synchronized可能会造成线程阻塞。</p><p>5.volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化。</p><h2 id="发生异常时自动释放锁"><a href="#发生异常时自动释放锁" class="headerlink" title="发生异常时自动释放锁"></a>发生异常时自动释放锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">syntest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" start"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">         count++;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">" count: "</span>+count);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">                System.out.println(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        syntest s=<span class="keyword">new</span> syntest();</span><br><span class="line">        Runnable r=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                s.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如题， 发生异常的时候，synchronized锁释放，线程t2得以执行</p><p>但是要注意的是，对于显式锁， 如ReentrantLock，在发生异常的时候，必须要手动释放锁。 </p><p>如果执行的代码段有可能发生异常，我们通常要这样处理, 需要在finally里面释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//可能发生异常的代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">    <span class="comment">//释放IO资源</span></span><br><span class="line">    io.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reetest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" count: "</span> + count);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        reetest s=<span class="keyword">new</span> reetest();</span><br><span class="line">        Runnable r=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                s.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和Lock的区别"><a href="#和Lock的区别" class="headerlink" title="和Lock的区别"></a>和Lock的区别</h2><ol><li><p>来源：<br>lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；</p></li><li><p>异常是否释放锁：<br>synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）</p></li><li><p>是否响应中断<br>lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；</p></li><li><p>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</p></li><li><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p></li><li><p>synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度，</p></li></ol><h2 id="轻量级锁什么时候升级为重量级锁？"><a href="#轻量级锁什么时候升级为重量级锁？" class="headerlink" title="轻量级锁什么时候升级为重量级锁？"></a>轻量级锁什么时候升级为重量级锁？</h2><p>我们必须给线程空循环设置一个次数，当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为<strong>重量级锁</strong>。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。</p><h2 id="偏向锁升级为轻量级"><a href="#偏向锁升级为轻量级" class="headerlink" title="偏向锁升级为轻量级"></a>偏向锁升级为轻量级</h2><p>轻量级锁由偏向锁升级而来，偏向锁运行在一个线程同步块时，第二个线程加入锁竞争的时候，偏向锁就会升级为轻量级锁。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k。首先将位数组进行初始化，每个都设为0。对于添加进来的新元素，将新元素经过k个hash函数，产生k个hash值，将hash值对应的位都置为1。查询某元素是否存在集合中的时候，同样的方法将某元素通过哈希映射到位数组上的k个点。如果k个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果k个点都为1，则该元素可能存在集合中。此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。因为k个点中的某个点有可能是因为其他元素hash得到的，这是误判率存在的原因</p><p><img src="/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201122154525408.png" alt="image-20201122154525408"></p><img src="/2020/06/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1.png" class title="布隆过滤器">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CAS</title>
      <link href="/2020/06/24/CAS/"/>
      <url>/2020/06/24/CAS/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="阻塞同步和非阻塞同步"><a href="#阻塞同步和非阻塞同步" class="headerlink" title="阻塞同步和非阻塞同步"></a>阻塞同步和非阻塞同步</h2><p>阻塞同步需要线程阻塞和唤醒所带来的性能问题，它属于一种悲观的并发策略，无论共享数据是否真的会出现竞争，它都要进行加锁。</p><p><strong>cmpxchg</strong></p><h2 id="CAS是什么"><a href="#CAS是什么" class="headerlink" title="CAS是什么"></a>CAS是什么</h2><p>它是乐观并发策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则不断地重试，直到成功。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。**</span><br></pre></td></tr></table></figure><p>CAS 表示 Compare And Swap，比较并交换，CAS 主要需要三个操作数，分别是内存中存放的实际值V、旧的预期值 A 和准备设置的新值 B。CAS 指令执行时，当且仅当 V 符合 A 时，处理器才会用 B 更新 V 的值，否则它就不执行更新。但不管是否更新都会返回 V 的旧值，这些处理过程是原子操作，执行期间不会被其他线程打断。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。<br>以下代码使用了 AtomicInteger 执行了自增的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示<br>操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt()<br>来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。<br>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">   var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</span><br><span class="line">J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版</span><br><span class="line">本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统</span><br><span class="line">的互斥同步可能会比原子类更高效。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>volatile的性质</title>
      <link href="/2020/06/24/volatile%E7%9A%84%E6%80%A7%E8%B4%A8/"/>
      <url>/2020/06/24/volatile%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="说说你对volatile关键字的理解"><a href="#说说你对volatile关键字的理解" class="headerlink" title="说说你对volatile关键字的理解"></a>说说你对volatile关键字的理解</h2><p>就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性：</p><p>1 . 保证了不同线程对该变量操作的可见性;</p><p>2 . 禁止指令重排序</p><h2 id="volatile关键字如何保证可见性的？"><a href="#volatile关键字如何保证可见性的？" class="headerlink" title="volatile关键字如何保证可见性的？"></a>volatile关键字如何保证可见性的？</h2><p>要知道volatile是如何保证可见性的需要先了解下有关CPU缓存的概念。我们知道<strong>CPU的运算速度</strong>要比<strong>内存的读写速度</strong>快很多，这就造成了内存无法跟上CPU的情况。为了解决这类问题，出现了针对CPU的缓存协议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intel开发了缓存一致性协议，也就是MESI协议</span><br><span class="line"></span><br><span class="line">①当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，那么他会发出信号通知其他CPU将该变量的缓存行设置为无效状态。</span><br><span class="line"></span><br><span class="line">②当其他CPU使用这个变量时，首先会去嗅探是否有对该变量更改的信号，当发现这个变量的缓存行已经无效时，会从新从内存中读取这个变量。</span><br></pre></td></tr></table></figure><p>了解了上面的内容，就可以很容易的理解volatile是如何实现的了。</p><ol><li>被 volatile 修饰的共享变量，在翻译成为机器码的过程中为其<code>赋值操作</code>添加特殊机器码指令前缀<code>Lock xxxx</code></li><li>当CPU发现这个指令时，立即做两件事：<ul><li>使本CPU的缓存写入内存</li><li>上面的写入动作也会引起别的CPU中的缓存无效，</li></ul></li></ol><p><strong>volatile关键字的变量写操作时，强制缓存和主存同步，其他线程读时候发现缓存失效，就去读主存，由此保证了变量的可见性。</strong></p><h2 id="volatile关键字如何保证有序性的？"><a href="#volatile关键字如何保证有序性的？" class="headerlink" title="volatile关键字如何保证有序性的？"></a>volatile关键字如何保证有序性的？</h2><p>在JMM的逻辑实现中，当操作一个变量 执行为变量赋值 时，JVM会检查此变量是否是被volatile修饰的，如果是的话，JVM会为该变量添加内存屏障。保证该变量操作之前的操作不会乱序到其后</p><ol><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。</li><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1583231-26cc583714507e7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/778/format/webp" alt="img"></p><h2 id="volatile可以保证原子性么？"><a href="#volatile可以保证原子性么？" class="headerlink" title="volatile可以保证原子性么？"></a>volatile可以保证原子性么？</h2><p>例如我们常碰到的i++的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 1; &#x2F;&#x2F;原子性操作，不用使用volatile也不会出现线程安全问题。</span><br><span class="line">复制代码</span><br><span class="line">volatile int i &#x3D; 0;</span><br><span class="line">i++; &#x2F;&#x2F;非原子性操作</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果我们开启200个线程并发执行<code>i++</code>这行代码，每个线程中只执行一遍。如果volatile可以保证原子性的话，那么i的最终结果应该是200；而实际上我们发现这个值是会小于200的，原因是什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; i++ 其可以被拆解为</span><br><span class="line">1、线程读取i</span><br><span class="line">2、temp &#x3D; i + 1</span><br><span class="line">3、i &#x3D; temp</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li><p>例如当 i=5 的时候A,B两个线程同时读入了 i 的值</p></li><li><p>然后A线程执行了 <code>temp = i + 1</code>的操作， 要注意，此时的 i 的值还没有变化，然后B线程也执行了<code>temp = i + 1</code>的操作，注意，此时A，B两个线程保存的 i 的值都是5，temp 的值都是6</p></li><li><p>然后A线程执行了 <code>i = temp</code> （6）的操作，此时i的值会立即刷新到主存并通知其他线程保存的 i 值失效， 此时B线程需要重新读取 i 的值那么此时B线程保存的 i 就是6</p></li><li><p>同时B线程保存的 temp 还仍然是6， 然后B线程执行 <code>i=temp</code> （6），所以导致了计算结果比预期少了1。<br>链接：<a href="https://juejin.im/post/5e01b9aa518825126f373b58" target="_blank" rel="noopener">https://juejin.im/post/5e01b9aa518825126f373b58</a></p></li></ol><p>   自增语句由 4 条字节码指令构成的，依次为 <code>getstatic</code>、<code>iconst_1</code>、<code>iadd</code>、<code>putstatic</code>，当 <code>getstatic</code> 把 i 取到操作栈顶时，volatile 保证了 i 值在此刻正确，但在执行 <code>iconst_1</code>、<code>iadd</code> 时，其他线程可能已经改变了 i 值，操作栈顶的值就变成了脏数据，所以 <code>putstatic</code> 后就可能把较小的值同步回了主内存。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic &#x2F;&#x2F; 获取静态变量race，并将值压入栈顶</span><br><span class="line">iconst_1  &#x2F;&#x2F; 将int值1推送至栈顶</span><br><span class="line">iadd      &#x2F;&#x2F; 将栈顶两个int型数值相加并将结果压入栈顶</span><br><span class="line">putstatic &#x2F;&#x2F; 为静态变量race赋值</span><br></pre></td></tr></table></figure><h3 id="可见性的底层实现机制"><a href="#可见性的底层实现机制" class="headerlink" title="可见性的底层实现机制"></a>可见性的底层实现机制</h3><p>flush处理器缓存，他的意思就是把自己更新的值刷新到高速缓存里去（或者是主内存），因为必须要刷到高速缓存（或者是主内存）里，才有可能在后续通过一些特殊的机制让其他的处理器从自己的高速缓存（或者是主内存）里读取到更新的值。除了flush以外，他还会发送一个消息到总线（bus），通知其他处理器，某个变量的值被他给修改了。</p><p>refresh处理器缓存，他的意思就是说，处理器中的线程在读取一个变量的值的时候，如果发现其他处理器的线程更新了变量的值，必须从其他处理器的高速缓存（或者是主内存）里，读取这个最新的值，更新到自己的高速缓存中。所以说，为了保证可见性，在底层是通过MESI协议、flush处理器缓存和refresh处理器缓存，这一整套机制来保障的。</p><p>flush和refresh，这两个操作，flush是强制刷新数据到高速缓存（主内存），不要仅仅停留在写缓冲器里面；refresh，是从总线嗅探发现某个变量被修改，必须强制从其他处理器的高速缓存（或者主内存）加载变量的最新值到自己的高速缓存里去。</p><h2 id="volatile底层的实现机制？"><a href="#volatile底层的实现机制？" class="headerlink" title="volatile底层的实现机制？"></a>volatile底层的实现机制？</h2><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p><p>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</p><p>lock addl把rsp寄存器的值加0，因为数据就是</p><p>1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置 </p><p>2.将当前处理器缓存行的数据写回到系统内存。</p><p>3.这个写回内存的操作会使其他在CPU里缓存了该内存地址的数据无效。</p><h2 id="有了mesi还要volatile吗？"><a href="#有了mesi还要volatile吗？" class="headerlink" title="有了mesi还要volatile吗？"></a>有了mesi还要volatile吗？</h2><p>在Java中，volatile是个很高层面的规范，保证了指令不会被重排序+对volatile变量的写使得当前cpu缓存中的所有变量写回到主存中，从而保证了内存可见性。</p><p>还是有用的，就算在实现了mesi的cpu上，volatile一样不可或缺。除了禁止指令重排序的作用外，由于mesi只是保证了L1-3 的cache之间的可见性，但是cpu和L1之间</p><p>还有像storebuffer之类的缓存，而volatile规范保证了对它修饰的变量的写指令会使得当前cpu所有缓存写到被mesi保证可见性的L1-3cache中。</p><p>因为 MESI只是保证了多核cpu的独占cache(L1,L2,L3)之间的一致性，但是cpu的并不是直接把数据写入L1 cache的，中间还可能有store buffer或者invalid queue等</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal的原理</title>
      <link href="/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>ThreadLocal 用于提供线程局部变量，在多线程环境可以保证各个线程里的变量独立于其它线程里的变量。</strong></p><p>也就是说 ThreadLocal 可以为每个线程创建一个【单独的变量副本】，相当于线程的 private static 类型变量。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String strLabel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLabel = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        strLabel = <span class="string">"main"</span>;</span><br><span class="line">        threadLabel.set(<span class="string">"main"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                strLabel = <span class="string">"child"</span>;</span><br><span class="line">                threadLabel.set(<span class="string">"child"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保证线程执行完毕</span></span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"strLabel = "</span> + strLabel);</span><br><span class="line">        System.out.println(<span class="string">"threadLabel = "</span> + threadLabel.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strLabel = child</span><br><span class="line">threadLabel = main</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal-set"><a href="#ThreadLocal-set" class="headerlink" title="ThreadLocal.set()"></a>ThreadLocal.set()</h3><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/6.png" alt="img"></p><p><img src="/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/C:%5CUsers%5C77406%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201228223358391.png" alt="image-20201228223358391"></p><p><code>ThreadLocal</code>中的<code>set</code>方法原理如上图所示，很简单，主要是判断<code>ThreadLocalMap</code>是否存在，然后使用<code>ThreadLocal</code>中的<code>set</code>方法进行数据处理。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> `ThreadLocalMap`(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>主要的核心逻辑还是在<code>ThreadLocalMap</code>中的，一步步往下看，后面还有更详细的剖析。</p><h3 id="ThreadLocalMap-Hash算法"><a href="#ThreadLocalMap-Hash算法" class="headerlink" title="ThreadLocalMap Hash算法"></a>ThreadLocalMap Hash算法</h3><p>既然是<code>Map</code>结构，那么<code>ThreadLocalMap</code>当然也要实现自己的<code>hash</code>算法来解决散列表数组冲突问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>中<code>hash</code>算法很简单，这里<code>i</code>就是当前key在散列表中对应的数组下标位置。</p><p>这里最关键的就是<code>threadLocalHashCode</code>值的计算，<code>ThreadLocal</code>中有一个属性为<code>HASH_INCREMENT = 0x61c88647</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> `<span class="title">ThreadLocalMap</span>` </span>&#123;</span><br><span class="line">        `ThreadLocalMap`(`ThreadLocal`&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>每当创建一个<code>ThreadLocal</code>对象，这个``ThreadLocal<code>.nextHashCode</code> 这个值就会增长 <code>0x61c88647</code> 。</p><p>这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p><p>我们自己可以尝试下：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/8.png" alt="img"></p><p>可以看到产生的哈希码分布很均匀，这里不去细纠<strong>斐波那契</strong>具体算法，感兴趣的可以自行查阅相关资料。</p><h3 id="ThreadLocalMapHash冲突"><a href="#ThreadLocalMapHash冲突" class="headerlink" title="ThreadLocalMapHash冲突"></a>ThreadLocalMapHash冲突</h3><blockquote><p><strong>注明：</strong> 下面所有示例图中，<strong>绿色块</strong><code>Entry</code>代表<strong>正常数据</strong>，<strong>灰色块</strong>代表<code>Entry</code>的<code>key</code>值为<code>null</code>，<strong>已被垃圾回收</strong>。<strong>白色块</strong>表示<code>Entry</code>为<code>null</code>。</p></blockquote><p>虽然<code>ThreadLocalMap</code>中使用了<strong>黄金分隔数来</strong>作为<code>hash</code>计算因子，大大减少了<code>Hash</code>冲突的概率，但是仍然会存在冲突。</p><p><code>HashMap</code>中解决冲突的方法是在数组上构造一个<strong>链表</strong>结构，冲突的数据挂载到链表上，如果链表长度超过一定数量则会转化成<strong>红黑树</strong>。</p><p>而<code>ThreadLocalMap</code>中并没有链表结构，所以这里不能适用<code>HashMap</code>解决冲突的方式了。</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/7.png" alt="img"></p><p>如上图所示，如果我们插入一个<code>value=27</code>的数据，通过<code>hash</code>计算后应该落入第4个槽位中，而槽位4已经有了<code>Entry</code>数据。</p><p>此时就会线性向后查找，一直找到<code>Entry</code>为<code>null</code>的槽位才会停止查找，将当前元素放入此槽位中。当然迭代过程中还有其他的情况，比如遇到了<code>Entry</code>不为<code>null</code>且<code>key</code>值相等的情况，还有<code>Entry</code>中的<code>key</code>值为<code>null</code>的情况等等都会有不同的处理，后面会一一详细讲解。</p><p>这里还画了一个<code>Entry</code>中的<code>key</code>为<code>null</code>的数据（<strong>Entry=2的灰色块数据</strong>），因为<code>key</code>值是<strong>弱引用</strong>类型，所以会有这种数据存在。在<code>set</code>过程中，如果遇到了<code>key</code>过期的<code>Entry</code>数据，实际上是会进行一轮<strong>探测式清理</strong>操作的，具体操作方式后面会讲到。</p><h3 id="ThreadLocalMap-set"><a href="#ThreadLocalMap-set" class="headerlink" title="ThreadLocalMap.set()"></a>ThreadLocalMap.set()</h3><p>我们来回顾一下ThreadLocal的set方法可能会有的情况</p><ul><li>探测过程中slot都不无效，并且顺利找到key所在的slot，直接替换即可</li><li>探测过程中发现有无效slot，调用replaceStaleEntry，效果是最终一定会把key和value放在这个slot，并且会尽可能清理无效slot<ul><li>在replaceStaleEntry过程中，如果找到了key，则做一个swap把它放到那个无效slot中，value置为新值</li><li>在replaceStaleEntry过程中，没有找到key，直接在无效slot原地放entry</li></ul></li><li>探测没有发现key，则在连续段末尾的后一个空位置放上entry，这也是线性探测法的一部分。放完后，做一次启发式清理，如果没清理出去key，并且当前table大小已经超过阈值了，则做一次rehash，rehash函数会调用一次全量清理slot方法也即expungeStaleEntries，如果完了之后table大小超过了threshold - threshold / 4，则进行扩容2倍</li></ul><h3 id="探测式清理流程"><a href="#探测式清理流程" class="headerlink" title="探测式清理流程"></a>探测式清理流程</h3><p>expungeStaleEntries从开始位置向后探测清理过期数据，将过期数据的<code>Entry</code>设置为<code>null</code>，沿途中碰到未过期的数据则将此数据<code>rehash</code>后重新在<code>table</code>数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的<code>Entry=null</code>的桶中，使<code>rehash</code>后的<code>Entry</code>数据距离正确的桶的位置更近一些。</p><p>探测没有发现key，则在连续段末尾的后一个空位置放上entry，这也是线性探测法的一部分。</p><p>操作逻辑如下：</p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/18.png" alt="img"></p><p><img src="https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/thread-local/19.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 这个函数是ThreadLocal中核心清理函数，它做的事情很简单：</span><br><span class="line"> * 就是从staleSlot开始遍历，将无效（弱引用指向对象被回收）清理，即对应entry中的value置为null，将指向这个entry的table[i]置为null，直到扫到空entry。</span><br><span class="line"> * 另外，在过程中还会对非空的entry作rehash。</span><br><span class="line"> * 可以说这个函数的作用就是从staleSlot开始清理连续段中的slot（断开强引用，rehash slot等）</span><br><span class="line"> *&#x2F;</span><br><span class="line">private int expungeStaleEntry(int staleSlot) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 因为entry对应的ThreadLocal已经被回收，value设为null，显式断开强引用</span><br><span class="line">    tab[staleSlot].value &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 显式设置该entry为null，以便垃圾回收</span><br><span class="line">    tab[staleSlot] &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    int i;</span><br><span class="line">    for (i &#x3D; nextIndex(staleSlot, len); (e &#x3D; tab[i]) !&#x3D; null; i &#x3D; nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">        &#x2F;&#x2F; 清理对应ThreadLocal已经被回收的entry</span><br><span class="line">        if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">            e.value &#x3D; null;</span><br><span class="line">            tab[i] &#x3D; null;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 对于还没有被回收的情况，需要做一次rehash。</span><br><span class="line">             * </span><br><span class="line">             * 如果对应的ThreadLocal的ID对len取模出来的索引h不为当前位置i，</span><br><span class="line">             * 则从h向后线性探测到第一个空的slot，把当前的entry给挪过去。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            int h &#x3D; k.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">            if (h !&#x3D; i) &#123;</span><br><span class="line">                tab[i] &#x3D; null;</span><br><span class="line">                </span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * 在原代码的这里有句注释值得一提，原注释如下：</span><br><span class="line">                 *</span><br><span class="line">                 * Unlike Knuth 6.4 Algorithm R, we must scan until</span><br><span class="line">                 * null because multiple entries could have been stale.</span><br><span class="line">                 *</span><br><span class="line">                 * 这段话提及了Knuth高德纳的著作TAOCP（《计算机程序设计艺术》）的6.4章节（散列）</span><br><span class="line">                 * 中的R算法。R算法描述了如何从使用线性探测的散列表中删除一个元素。</span><br><span class="line">                 * R算法维护了一个上次删除元素的index，当在非空连续段中扫到某个entry的哈希值取模后的索引</span><br><span class="line">                 * 还没有遍历到时，会将该entry挪到index那个位置，并更新当前位置为新的index，</span><br><span class="line">                 * 继续向后扫描直到遇到空的entry。</span><br><span class="line">                 *</span><br><span class="line">                 * ThreadLocalMap因为使用了弱引用，所以其实每个slot的状态有三种也即</span><br><span class="line">                 * 有效（value未回收），无效（value已回收），空（entry&#x3D;&#x3D;null）。</span><br><span class="line">                 * 正是因为ThreadLocalMap的entry有三种状态，所以不能完全套高德纳原书的R算法。</span><br><span class="line">                 *</span><br><span class="line">                 * 因为expungeStaleEntry函数在扫描过程中还会对无效slot清理将之转为空slot，</span><br><span class="line">                 * 如果直接套用R算法，可能会出现具有相同哈希值的entry之间断开（中间有空entry）。</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                while (tab[h] !&#x3D; null) &#123;</span><br><span class="line">                    h &#x3D; nextIndex(h, len);</span><br><span class="line">                &#125;</span><br><span class="line">                tab[h] &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回staleSlot之后第一个空的slot索引</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启发式清理"><a href="#启发式清理" class="headerlink" title="启发式清理"></a>启发式清理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 启发式地清理slot,</span><br><span class="line"> * i对应entry是非无效（指向的ThreadLocal没被回收，或者entry本身为空）</span><br><span class="line"> * n是用于控制控制扫描次数的</span><br><span class="line"> * 正常情况下如果log n次扫描没有发现无效slot，函数就结束了</span><br><span class="line"> * 但是如果发现了无效的slot，将n置为table的长度len，做一次连续段的清理</span><br><span class="line"> * 再从下一个空的slot开始继续扫描</span><br><span class="line"> * </span><br><span class="line"> * 这个函数有两处地方会被调用，一处是插入的时候可能会被调用，另外个是在替换无效slot的时候可能会被调用，</span><br><span class="line"> * 区别是前者传入的n为元素个数，后者为table的容量</span><br><span class="line"> *&#x2F;</span><br><span class="line">private boolean cleanSomeSlots(int i, int n) &#123;</span><br><span class="line">    boolean removed &#x3D; false;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; i在任何情况下自己都不会是一个无效slot，所以从下一个开始判断</span><br><span class="line">        i &#x3D; nextIndex(i, len);</span><br><span class="line">        Entry e &#x3D; tab[i];</span><br><span class="line">        if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 扩大扫描控制因子</span><br><span class="line">            n &#x3D; len;</span><br><span class="line">            removed &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; 清理一个连续段</span><br><span class="line">            i &#x3D; expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((n &gt;&gt;&gt;&#x3D; 1) !&#x3D; 0);</span><br><span class="line">    return removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap-get-详解"><a href="#ThreadLocalMap-get-详解" class="headerlink" title="ThreadLocalMap.get()详解"></a>ThreadLocalMap.get()详解</h3><p>根据入参threadLocal的threadLocalHashCode对表容量取模得到index</p><ul><li>如果index对应的slot就是要读的threadLocal，则直接返回结果</li><li>调用getEntryAfterMiss线性探测，过程中每碰到无效slot，调用expungeStaleEntry进行段清理；如果找到了key，则返回结果entry</li><li>没有找到key，返回null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(`ThreadLocal`&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(`ThreadLocal`&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        `ThreadLocal`&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="怎么解决内存泄漏"><a href="#怎么解决内存泄漏" class="headerlink" title="怎么解决内存泄漏"></a>怎么解决内存泄漏</h2><p>当使用ThreadLocal保存一个value时，会在ThreadLocalMap中的数组插入一个Entry对象，按理说key-value都应该以强引用保存在Entry对象中，但在ThreadLocalMap的实现中，key被保存到了WeakReference对象中。这就导致了一个问题，ThreadLocal在没有外部强引用时，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><p>解决：使用remove</p><p>调用remove方法，肯定会删除对应的Entry对象</p><p><img src="http://localhost:4000/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/1.png" alt="img"></p><img src="/2020/06/24/ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/1.png" class title="内存模型"><h2 id="为什么要用弱引用"><a href="#为什么要用弱引用" class="headerlink" title="为什么要用弱引用"></a>为什么要用弱引用</h2><p>那换做强引用分析： <code>ThreadLocal</code>对象被两个强引用指向</p><ul><li>强引用： threadlocal1</li><li>强引用： Entry.key</li></ul><p>当我们断开程序中的强引用 <code>threadlocal1</code>时。<code>ThreadLocal</code>对象仍然被强引用<code>Entry.key</code>指向，不会回收，这就造成，<code>ThreadLocal</code>对象与 <code>value</code>都成为了脏数据。</p><h2 id="弱引用带来哪些问题"><a href="#弱引用带来哪些问题" class="headerlink" title="弱引用带来哪些问题"></a>弱引用带来哪些问题</h2><p>不管软引用还是强引用，都可能出现内存泄漏问题，弱引用反而将内存泄漏的程度降低**</p><p>利用弱引用的<strong>Entry会有key为null这个特征</strong>，可以识别哪些是不用的数据，进行清理操作，弱引用 反而提高了ThreadLocal的安全性。事实上当调用<code>ThreadLocal</code>的<code>get(),set(),reomve()</code>方法，都会清除掉线程<code>ThreadLocalMap</code>中所有Entry中Key为null的Value，并将整个Entry设置为null，利于下次内存回收。</p><h2 id="ThreadLocal可能存在哪些问题？"><a href="#ThreadLocal可能存在哪些问题？" class="headerlink" title="ThreadLocal可能存在哪些问题？"></a>ThreadLocal可能存在哪些问题？</h2><p>线程复用会产生脏数据，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用。如果没有调用 remove 清理与线程相关的 ThreadLocal 信息，那么假如下一个线程没有调用 set 设置初始值就可能 get 到重用的线程信息。</p><p>ThreadLocal 还存在内存泄漏的问题，由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放。因此需要及时调用 remove 方法进行清理操作。</p><h3 id="Set的源码"><a href="#Set的源码" class="headerlink" title="Set的源码"></a>Set的源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">    &#x2F;&#x2F; 线性探测</span><br><span class="line">    for (Entry e &#x3D; tab[i]; e !&#x3D; null; e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">        &#x2F;&#x2F; 找到对应的entry</span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 替换失效的entry</span><br><span class="line">        if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">    int sz &#x3D; ++size;</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold) &#123;</span><br><span class="line">        rehash();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="line">                               int staleSlot) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 向前扫描，查找最前的一个无效slot</span><br><span class="line">    int slotToExpunge &#x3D; staleSlot;</span><br><span class="line">    for (int i &#x3D; prevIndex(staleSlot, len);</span><br><span class="line">         (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">         i &#x3D; prevIndex(i, len)) &#123;</span><br><span class="line">        if (e.get() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            slotToExpunge &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 向后遍历table</span><br><span class="line">    for (int i &#x3D; nextIndex(staleSlot, len);</span><br><span class="line">         (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">         i &#x3D; nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 找到了key，将其与无效的slot交换</span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            &#x2F;&#x2F; 更新对应slot的value值</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line"></span><br><span class="line">            tab[i] &#x3D; tab[staleSlot];</span><br><span class="line">            tab[staleSlot] &#x3D; e;</span><br><span class="line"></span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 如果在整个扫描过程中（包括函数一开始的向前扫描与i之前的向后扫描）</span><br><span class="line">             * 找到了之前的无效slot则以那个位置作为清理的起点，</span><br><span class="line">             * 否则则以当前的i作为清理起点</span><br><span class="line">             *&#x2F;</span><br><span class="line">            if (slotToExpunge &#x3D;&#x3D; staleSlot) &#123;</span><br><span class="line">                slotToExpunge &#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 从slotToExpunge开始做一次连续段的清理，再做一次启发式清理</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置</span><br><span class="line">        if (k &#x3D;&#x3D; null &amp;&amp; slotToExpunge &#x3D;&#x3D; staleSlot) &#123;</span><br><span class="line">            slotToExpunge &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果key在table中不存在，则在原地放一个即可</span><br><span class="line">    tab[staleSlot].value &#x3D; null;</span><br><span class="line">    tab[staleSlot] &#x3D; new Entry(key, value);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在探测过程中如果发现任何无效slot，则做一次清理（连续段清理+启发式清理）</span><br><span class="line">    if (slotToExpunge !&#x3D; staleSlot) &#123;</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 启发式地清理slot,</span><br><span class="line"> * i对应entry是非无效（指向的ThreadLocal没被回收，或者entry本身为空）</span><br><span class="line"> * n是用于控制控制扫描次数的</span><br><span class="line"> * 正常情况下如果log n次扫描没有发现无效slot，函数就结束了</span><br><span class="line"> * 但是如果发现了无效的slot，将n置为table的长度len，做一次连续段的清理</span><br><span class="line"> * 再从下一个空的slot开始继续扫描</span><br><span class="line"> * </span><br><span class="line"> * 这个函数有两处地方会被调用，一处是插入的时候可能会被调用，另外个是在替换无效slot的时候可能会被调用，</span><br><span class="line"> * 区别是前者传入的n为元素个数，后者为table的容量</span><br><span class="line"> *&#x2F;</span><br><span class="line">private boolean cleanSomeSlots(int i, int n) &#123;</span><br><span class="line">    boolean removed &#x3D; false;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; i在任何情况下自己都不会是一个无效slot，所以从下一个开始判断</span><br><span class="line">        i &#x3D; nextIndex(i, len);</span><br><span class="line">        Entry e &#x3D; tab[i];</span><br><span class="line">        if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 扩大扫描控制因子</span><br><span class="line">            n &#x3D; len;</span><br><span class="line">            removed &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; 清理一个连续段</span><br><span class="line">            i &#x3D; expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((n &gt;&gt;&gt;&#x3D; 1) !&#x3D; 0);</span><br><span class="line">    return removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void rehash() &#123;</span><br><span class="line">    &#x2F;&#x2F; 做一次全量清理</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 因为做了一次清理，所以size很可能会变小。</span><br><span class="line">     * ThreadLocalMap这里的实现是调低阈值来判断是否需要扩容，</span><br><span class="line">     * threshold默认为len*2&#x2F;3，所以这里的threshold - threshold &#x2F; 4相当于len&#x2F;2</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (size &gt;&#x3D; threshold - threshold &#x2F; 4) &#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 做一次全量清理</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void expungeStaleEntries() &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e &#x3D; tab[j];</span><br><span class="line">        if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * 个人觉得这里可以取返回值，如果大于j的话取了用，这样也是可行的。</span><br><span class="line">             * 因为expungeStaleEntry执行过程中是把连续段内所有无效slot都清理了一遍了。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 扩容，因为需要保证table的容量len为2的幂，所以扩容即扩大2倍</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void resize() &#123;</span><br><span class="line">    Entry[] oldTab &#x3D; table;</span><br><span class="line">    int oldLen &#x3D; oldTab.length;</span><br><span class="line">    int newLen &#x3D; oldLen * 2;</span><br><span class="line">    Entry[] newTab &#x3D; new Entry[newLen];</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; 0; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e &#x3D; oldTab[j];</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">            if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">                e.value &#x3D; null; </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 线性探测来存放Entry</span><br><span class="line">                int h &#x3D; k.threadLocalHashCode &amp; (newLen - 1);</span><br><span class="line">                while (newTab[h] !&#x3D; null) &#123;</span><br><span class="line">                    h &#x3D; nextIndex(h, newLen);</span><br><span class="line">                &#125;</span><br><span class="line">                newTab[h] &#x3D; e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size &#x3D; count;</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>遍历当前<code>key</code>值对应的桶中<code>Entry</code>数据为空，这说明散列数组这里没有数据冲突，跳出<code>for</code>循环，直接<code>set</code>数据到对应的桶中</li><li>如果<code>key</code>值对应的桶中<code>Entry</code>数据不为空</li><li>1 如果<code>k = key</code>，说明当前<code>set</code>操作是一个替换操作，做替换逻辑，直接返回</li><li>2 如果<code>key = null</code>，说明当前桶位置的<code>Entry</code>是过期数据，执行<code>replaceStaleEntry()</code>方法(核心方法)，然后返回</li><li><code>for</code>循环执行完毕，继续往下执行说明向后迭代的过程中遇到了<code>entry</code>为<code>null</code>的情况</li><li>1 在<code>Entry</code>为<code>null</code>的桶中创建一个新的<code>Entry</code>对象</li><li>2 执行<code>++size</code>操作</li><li>调用<code>cleanSomeSlots()</code>做一次启发式清理工作，清理散列数组中<code>Entry</code>的<code>key</code>过期的数据</li><li>1 如果清理工作完成后，未清理到任何数据，且<code>size</code>超过了阈值(数组长度的2/3)，进行<code>rehash()</code>操作</li><li>2 <code>rehash()</code>中会先进行一轮探测式清理，清理过期<code>key</code>，清理完成后如果<strong>size &gt;= threshold - threshold / 4</strong>，就会执行真正的扩容逻辑(扩容逻辑往后看)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的设计原则</title>
      <link href="/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><p><strong>开闭原则：</strong>面向对象设计中最基础的设计原则，指一个软件实体（类、模块、方法等）应该对扩展开放，对修改关闭。它强调用抽象构建框架，用实现扩展细节，提高代码的可复用性和可维护性。例如在版本更新时尽量不修改源代码，但可以增加新功能。</p><p><strong>单一职责原则：</strong>一个类、接口或方法只负责一个职责，可以提高代码可读性和可维护性，降低代码复杂度以及变更引起的风险。</p><p><strong>依赖倒置原则：</strong>程序应该依赖于抽象类或接口，而不是具体的实现类。可以降低代码的耦合度，提高系统的稳定性。</p><p><strong>接口隔离原则：</strong>将不同功能定义在不同接口中实现接口隔离，避免了类依赖它不需要的接口，减少了接口之间依赖的冗余性和复杂性。</p><p><strong>里氏替换原则：</strong>对开闭原则的补充，规定了任何父类可以出现的地方子类都一定可以出现，可以约束继承泛滥，加键程序健壮性。</p><p><strong>迪米特原则：</strong>也叫最少知道原则，每个模块对其他模块都要尽可能少的了解和依赖，可以降低代码耦合度。</p><p><strong>合成/聚合原则：</strong>尽量使用组合(has a)或聚合(contains a)而不是继承关系达到软件复用的目的，可以使系统更加灵活，降低耦合度。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型</title>
      <link href="/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
      <url>/2020/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><strong>静态代理：代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hr</span> <span class="keyword">implements</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我需要找招聘一个员工"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hr hr;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hr = <span class="keyword">new</span> Hr();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hr.findWorker();</span><br><span class="line">        System.out.println(<span class="string">"找到了员工"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Company company=<span class="keyword">new</span> Proxy();</span><br><span class="line">        company.findWorker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理：</strong>动态代理在程序运行时才创建具体的代理类，代理类和被代理类的关系在运行前是不确定的。动态代理的适用性更强，主要分为 JDK 动态代理和 CGLib 动态代理。</p><p> JDK 动态代理：通过 Proxy类的 newInstance 方法获取一个动态代理对象，需要传入三个参数，被代理对象的类加载器、被代理对象实现的接口，以及一个 InvocationHandler 调用处理器实例来指明具体的逻辑，相比静态代理最大的优势是接口中声明的所有方法都被转移到 InvocationHandler 中的 invoke 方法集中处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hr hr = <span class="keyword">new</span> Hr();</span><br><span class="line">        Company proxyHr = (Company) Proxy.newProxyInstance(hr.getClass().getClassLoader(), hr.getClass().getInterfaces(), (proxy, method, args1) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"接收代理请求"</span>);</span><br><span class="line">            Object obj = method.invoke(hr, args1);</span><br><span class="line">            System.out.println(<span class="string">"找到了员工，完成请求"</span>);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;);</span><br><span class="line">        proxyHr.findWorker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VMWARE+Centos8配置静态IP地址</title>
      <link href="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/"/>
      <url>/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/1.png" class title="第一步"><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/2.png" class title="第二步"><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/3.png" class title="第三步"><p>打开网络和共享中心—&gt;更改适配器配置—–&gt;右键VMware Network Adapter—&gt;属性—-&gt;双击IPv4—&gt;</p><p>设置IP地址 以及网关</p><p>网关地址必须和vmwareNAT设置的一致，IP保持同一网段内即可</p><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/4.png" class title="如图所示"><p>重启虚拟机</p><p>使用root 用户修改 linux网络配置</p><p>su root</p><p>vi /etc/sysconfig/network-scripts/ifcfg-ens33</p><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/5.png" class title="如图所示"><p>重启网卡</p><p>nmcli c reload</p><p>配置到这里可以实现本机与虚拟机之间的通信了</p><p>虚拟机连接外网</p><p>如果你本机可以连接外网，但是虚拟机ping baidu.com 返回错误信息了，需要绑定DNS</p><p>vi /etc/resolv.conf （没有此文件新建一个即可）</p><p>nameserver 网关地址</p><img src="/2020/06/14/VMWARE-Centos8%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/6.png" class title="如图所示"><blockquote><p>链接：<a href="https://www.jianshu.com/p/6801da089cf2" target="_blank" rel="noopener">https://www.jianshu.com/p/6801da089cf2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker search报错解决方法</title>
      <link href="/2020/06/14/docker-search%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/14/docker-search%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ docker search sameersbn</span><br><span class="line">Error response from daemon: Get https:<span class="comment">//index.docker.io/v1/search?q=sameersbn&amp;n=25: dial tcp: lookup index.docker.io on 192.168.65.1:53: read udp 192.168.65.2:45190-&gt;192.168.65.1:53: i/o timeout</span></span><br></pre></td></tr></table></figure><p>解决方法:</p><p>通过dig @114.114.114.114 registry-1.docker.io找到可用ip</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ dig @<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span> registry-<span class="number">1</span>.docker.io</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG <span class="number">9.8</span><span class="number">.3</span>-P1 &lt;&lt;&gt;&gt; @<span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span> registry-<span class="number">1</span>.docker.io</span><br><span class="line">; (<span class="number">1</span> server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: <span class="number">47220</span></span><br><span class="line">;; flags: qr rd ra; QUERY: <span class="number">1</span>, ANSWER: <span class="number">8</span>, AUTHORITY: <span class="number">4</span>, ADDITIONAL: <span class="number">9</span></span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: <span class="number">0</span>, flags:; udp: <span class="number">4096</span></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;registry-<span class="number">1</span>.docker.io.        IN    A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">54.164</span><span class="number">.230</span><span class="number">.151</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">35.169</span><span class="number">.231</span><span class="number">.249</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">34.205</span><span class="number">.207</span><span class="number">.96</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">34.200</span><span class="number">.28</span><span class="number">.105</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">52.204</span><span class="number">.202</span><span class="number">.231</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">54.152</span><span class="number">.209</span><span class="number">.167</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">52.22</span><span class="number">.181</span><span class="number">.254</span></span><br><span class="line">registry-<span class="number">1</span>.docker.io.    <span class="number">3600</span>    IN    A    <span class="number">52.54</span><span class="number">.216</span><span class="number">.153</span></span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">1827</span>.awsdns-<span class="number">36</span>.co.uk.</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">1168</span>.awsdns-<span class="number">18</span>.org.</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">513</span>.awsdns-<span class="number">00</span>.net.</span><br><span class="line">docker.io.        <span class="number">61985</span>    IN    NS    ns-<span class="number">421</span>.awsdns-<span class="number">52</span>.com.</span><br><span class="line"></span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">ns-<span class="number">421</span>.awsdns-<span class="number">52</span>.com.    <span class="number">148245</span>    IN    A    <span class="number">205.251</span><span class="number">.193</span><span class="number">.165</span></span><br><span class="line">ns-<span class="number">421</span>.awsdns-<span class="number">52</span>.com.    <span class="number">149402</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5301</span>:a500::<span class="number">1</span></span><br><span class="line">ns-<span class="number">513</span>.awsdns-<span class="number">00</span>.net.    <span class="number">149549</span>    IN    A    <span class="number">205.251</span><span class="number">.194</span><span class="number">.1</span></span><br><span class="line">ns-<span class="number">513</span>.awsdns-<span class="number">00</span>.net.    <span class="number">149549</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5302</span>:<span class="number">100</span>::<span class="number">1</span></span><br><span class="line">ns-<span class="number">1168</span>.awsdns-<span class="number">18</span>.org.    <span class="number">148917</span>    IN    A    <span class="number">205.251</span><span class="number">.196</span><span class="number">.144</span></span><br><span class="line">ns-<span class="number">1168</span>.awsdns-<span class="number">18</span>.org.    <span class="number">148917</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5304</span>:<span class="number">9000</span>::<span class="number">1</span></span><br><span class="line">ns-<span class="number">1827</span>.awsdns-<span class="number">36</span>.co.uk. <span class="number">148040</span>    IN    A    <span class="number">205.251</span><span class="number">.199</span><span class="number">.35</span></span><br><span class="line">ns-<span class="number">1827</span>.awsdns-<span class="number">36</span>.co.uk. <span class="number">148040</span>    IN    AAAA    <span class="number">2600</span>:<span class="number">9000</span>:<span class="number">5307</span>:<span class="number">2300</span>::<span class="number">1</span></span><br><span class="line"></span><br><span class="line">;; Query time: <span class="number">60</span> msec</span><br><span class="line">;; SERVER: 114.114.114.114#53(114.114.114.114)</span><br><span class="line">;; WHEN: Mon Aug <span class="number">20</span> <span class="number">22</span>:<span class="number">36</span>:<span class="number">29</span> <span class="number">2018</span></span><br><span class="line">;; MSG SIZE  rcvd: <span class="number">493</span></span><br></pre></td></tr></table></figure><p>尝试修改<code>/etc/hosts</code>强制<code>docker.io</code>相关的域名解析到其它可用IP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">54.164</span><span class="number">.230</span><span class="number">.151</span> registry-<span class="number">1</span>.docker.io</span><br></pre></td></tr></table></figure><p>保存后重试，成功！！</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker的安装和基本用法</title>
      <link href="/2020/06/14/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2020/06/14/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Centos安装命令"><a href="#Centos安装命令" class="headerlink" title="Centos安装命令"></a>Centos安装命令</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:<span class="comment">//get.docker.com | bash -s docker --mirror Aliyun</span></span><br></pre></td></tr></table></figure><h2 id="Docker基本用法"><a href="#Docker基本用法" class="headerlink" title="Docker基本用法"></a>Docker基本用法</h2><p>启动docker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>停止docker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p>docker搜索镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p>docker拉取镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull  mysql</span><br></pre></td></tr></table></figure><p>docker启动容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>查看正在运行容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>删除容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm id</span><br></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi id</span><br></pre></td></tr></table></figure><p>查看镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(行为型)</title>
      <link href="/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
      <url>/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CurrentConditionsDisplay implements Observer &#123;</span><br><span class="line">    public CurrentConditionsDisplay(Subject weatherData) &#123;</span><br><span class="line">        weatherData.registerObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(float temp) &#123;</span><br><span class="line">        System.out.println(&quot;Current temp: &quot;+temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StatisticsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">        weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Statistics temp: "</span>+temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            o.update(temperature);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">        CurrentConditionsDisplay currentConditionsDisplay = <span class="keyword">new</span></span><br><span class="line">                CurrentConditionsDisplay(weatherData);</span><br><span class="line">        StatisticsDisplay statisticsDisplay = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">0</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeOrTea</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        boil();</span><br><span class="line">        brew();</span><br><span class="line">        pour();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pour</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"boil"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">CaffeOrTea</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Coffee.brew"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">CaffeOrTea</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Tea.brew"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CaffeeOrTea c=<span class="keyword">new</span> Coffee();</span><br><span class="line">        c.prepare();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>定义一系列算法，封装每个算法，并使它们可以互换。</p><p>设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Quack!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gaga</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Gaga!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> QuackBehavior quackBehavior;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (quackBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">  quackBehavior.quack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.quackBehavior = quackBehavior;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Duck duck = <span class="keyword">new</span> Duck();</span><br><span class="line">    duck.setQuackBehavior(<span class="keyword">new</span> Squeak());</span><br><span class="line">    duck.performQuack();</span><br><span class="line">    duck.setQuackBehavior(<span class="keyword">new</span> Quack());</span><br><span class="line">    duck.performQuack();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(创建型)</title>
      <link href="/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
      <url>/2020/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Ⅰ-懒汉式-线程不安全"><a href="#Ⅰ-懒汉式-线程不安全" class="headerlink" title="Ⅰ 懒汉式-线程不安全"></a>Ⅰ 懒汉式-线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton get <span class="title">uniqueInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅱ-饿汉式-线程安全"><a href="#Ⅱ-饿汉式-线程安全" class="headerlink" title="Ⅱ 饿汉式-线程安全"></a>Ⅱ 饿汉式-线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s =<span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton get <span class="title">uniqueInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅲ-懒汉式-线程安全"><a href="#Ⅲ-懒汉式-线程安全" class="headerlink" title="Ⅲ 懒汉式-线程安全"></a>Ⅲ 懒汉式-线程安全</h2><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待,这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton get <span class="title">uniqueInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅳ-双重校验锁-线程安全"><a href="#Ⅳ-双重校验锁-线程安全" class="headerlink" title="Ⅳ 双重校验锁-线程安全"></a>Ⅳ 双重校验锁-线程安全</h2><p>第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了<br>加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实<br>是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址<br>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在<br>多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用<br>getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被<br>初始化。<br>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    s=<span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> s;</span><br><span class="line">    &#125;                                                                                                                                                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅴ-静态内部类实现"><a href="#Ⅴ-静态内部类实现" class="headerlink" title="Ⅴ 静态内部类实现"></a>Ⅴ 静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE=<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来<br>实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">  Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// do something with the product</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂方法</p><p>多个工厂，一种抽象产品。例如一个麦当劳店，可以生产多种汉堡，一个肯德基店，也可以生产多种汉堡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">作者：冠状病毒biss</span><br><span class="line">链接：https:<span class="comment">//www.nowcoder.com/discuss/438905?type=all&amp;order=time&amp;pos=&amp;page=1&amp;channel=666&amp;source_id=search_all</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Hamburger <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCFactory</span> <span class="keyword">implements</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MCHamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCFactory</span> <span class="keyword">implements</span> <span class="title">HamburgerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hamburger <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KFCHamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃麦当劳汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCHamburger</span> <span class="keyword">implements</span> <span class="title">Hamburger</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃肯德基汉堡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HamburgerFactory mcFactory=<span class="keyword">new</span> MCFactory();</span><br><span class="line">    Hamburger hamburger=mcFactory.build();</span><br><span class="line">    hamburger.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f36a2287a9f494dbf1652f2fde11c77~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建<br>出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>股票问题</title>
      <link href="/2020/06/13/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/06/13/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>股票问题（1）</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min=prices[<span class="number">0</span>],max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            max=Math.max(max,prices[i]-min);</span><br><span class="line">            min=Math.min(min,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>股票问题（2）</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="comment">//    能挣钱就卖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(prices[i]&gt;=prices[i-<span class="number">1</span>])</span><br><span class="line">          &#123;</span><br><span class="line">              ans+=(prices[i]-prices[i-<span class="number">1</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>股票问题 (3)</p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: [3,3,5,0,0,3,1,4]<br>输出: 6<br>解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        对于任意一天考虑四个变量:</span></span><br><span class="line"><span class="comment">        fstBuy: 在该天第一次买入股票可获得的最大收益 </span></span><br><span class="line"><span class="comment">        fstSell: 在该天第一次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secBuy: 在该天第二次买入股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secSell: 在该天第二次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        分别对四个变量进行相应的更新, 最后secSell就是最大</span></span><br><span class="line"><span class="comment">        收益值(secSell &gt;= fstSell)</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">int</span> fstBuy = Integer.MIN_VALUE, fstSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> secBuy = Integer.MIN_VALUE, secSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            fstBuy = Math.max(fstBuy, -p);</span><br><span class="line">            fstSell = Math.max(fstSell, fstBuy + p);</span><br><span class="line">            secBuy = Math.max(secBuy, fstSell - p);</span><br><span class="line">            secSell = Math.max(secSell, secBuy + p); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>股票(4)</p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>输入: [2,4,1], k = 2<br>输出: 2<br>解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        当k大于等于数组长度一半时, 问题退化为贪心问题此时采用 买卖股票的最佳时机 II</span></span><br><span class="line"><span class="comment">        的贪心方法解决可以大幅提升时间性能, 对于其他的k, 可以采用 买卖股票的最佳时机 III</span></span><br><span class="line"><span class="comment">        的方法来解决, 在III中定义了两次买入和卖出时最大收益的变量, 在这里就是k租这样的</span></span><br><span class="line"><span class="comment">        变量, 即问题IV是对问题III的推广, t[i][0]和t[i][1]分别表示第i比交易买入和卖出时</span></span><br><span class="line"><span class="comment">        各自的最大收益</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= prices.length/<span class="number">2</span>) <span class="keyword">return</span> greedy(prices);</span><br><span class="line">        <span class="keyword">int</span>[][] t = <span class="keyword">new</span> <span class="keyword">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            t[i][<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            t[<span class="number">0</span>][<span class="number">0</span>] = Math.max(t[<span class="number">0</span>][<span class="number">0</span>], -p);</span><br><span class="line">            t[<span class="number">0</span>][<span class="number">1</span>] = Math.max(t[<span class="number">0</span>][<span class="number">1</span>], t[<span class="number">0</span>][<span class="number">0</span>] + p);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                t[i][<span class="number">0</span>] = Math.max(t[i][<span class="number">0</span>], t[i-<span class="number">1</span>][<span class="number">1</span>] - p);</span><br><span class="line">                t[i][<span class="number">1</span>] = Math.max(t[i][<span class="number">1</span>], t[i][<span class="number">0</span>] + p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t[k-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>])</span><br><span class="line">                max += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/2020/05/31/ArrayList/"/>
      <url>/2020/05/31/ArrayList/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>[TOC]</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>需要使用 grow() 方法进行扩容，新容量的大小为 oldCapacity + (oldCapacity &gt;&gt; 1) ，也就是旧容量的 1.5 倍。<br>扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建<br>ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">      &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">      int oldCapacity &#x3D; elementData.length;</span><br><span class="line">      int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">      if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">          newCapacity &#x3D; minCapacity;</span><br><span class="line">      if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">          newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">      &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">      elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看<br>出 ArrayList 删除元素的代价是非常高的。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行<br>序列化。<br>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData; &#x2F;&#x2F; non-private to simplify nested class access</span><br></pre></td></tr></table></figure><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p><h2 id="与Vector比较"><a href="#与Vector比较" class="headerlink" title="与Vector比较"></a>与Vector比较</h2><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean add(E e) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + 1);</span><br><span class="line">    elementData[elementCount++] &#x3D; e;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized E get(int index) &#123;</span><br><span class="line">    if (index &gt;&#x3D; elementCount)</span><br><span class="line">    throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 ArrayList的比较</p><p>①Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步<br>操作完全可以由程序员自己来控制；<br>②Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</p><h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><h3 id="synchronizedList"><a href="#synchronizedList" class="headerlink" title="synchronizedList"></a>synchronizedList</h3><p>在SynchronizedList内部维护了一个普通对象Collection，还有排斥锁mutex.创建出synchronizedList之后，再操作List的时候，就会对方法上锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; synList &#x3D; Collections.synchronizedList(arrayList);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.add(e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.remove(o);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean containsAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.containsAll(coll);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; coll) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.addAll(coll);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean removeAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.removeAll(coll);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean retainAll(Collection&lt;?&gt; coll) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.retainAll(coll);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">    synchronized (mutex) &#123;c.clear();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。<br>写操作需要加锁，防止并发写入时导致写入数据丢失。<br>写操作结束之后需要把原始数组指向新的复制数组。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：<br>①内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；<br>②数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。<br>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>底层<strong>通过双向链表实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个链表存储了 first 和 last 指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h3 id="与-ArrayList-的比较"><a href="#与-ArrayList-的比较" class="headerlink" title="与 ArrayList 的比较"></a>与 ArrayList 的比较</h3><ol><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h3 id="3-1-先从-ArrayList-的构造函数说起"><a href="#3-1-先从-ArrayList-的构造函数说起" class="headerlink" title="3.1. 先从 ArrayList 的构造函数说起"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_31-先从-arraylist-的构造函数说起" target="_blank" rel="noopener">3.1. 先从 ArrayList 的构造函数说起</a></h3><p><strong>ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">            <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">            <span class="comment">//创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">    *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p><h3 id="一步一步分析-ArrayList-扩容机制"><a href="#一步一步分析-ArrayList-扩容机制" class="headerlink" title="一步一步分析 ArrayList 扩容机制"></a>一步一步分析 ArrayList 扩容机制</h3><p>这里以无参构造函数创建的 ArrayList 为例分析</p><ul><li>初始化出来的容量为0，添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，具体的逻辑是如果minCapacity为0，则将其初始化为10</li><li>随后调用ensureExplicitCapacity()，它会根据minCapacity判断容量是否足够，如果不够，调用grow方法进行扩容，具体扩容的逻辑是旧容量的 1.5 倍。</li><li>然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，如果新容量大于 MAX_ARRAY_SIZE,比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</li><li>扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建<br>ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</li></ul><h4 id="先来看-add-方法"><a href="#先来看-add-方法" class="headerlink" title="先来看 add 方法"></a>先来看 <code>add</code> 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> ：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h4 id="再来看看-ensureCapacityInternal-方法"><a href="#再来看看-ensureCapacityInternal-方法" class="headerlink" title="再来看看 ensureCapacityInternal() 方法"></a>再来看看 <code>ensureCapacityInternal()</code> 方法</h4><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p><h4 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity() 方法"></a><code>ensureExplicitCapacity()</code> 方法</h4><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法，下面我们来研究一下这个方法的源码！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>我们来仔细分析一下：</p><ul><li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><h4 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow() 方法"></a><code>grow()</code> 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p><ul><li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li><li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li><li>以此类推······</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h3 id="3-3-System-arraycopy-和-Arrays-copyOf-方法"><a href="#3-3-System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="3.3. System.arraycopy() 和 Arrays.copyOf()方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_33-systemarraycopy-和-arrayscopyof方法" target="_blank" rel="noopener">3.3. <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</a></h3><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p><h4 id="3-3-1-System-arraycopy-方法"><a href="#3-3-1-System-arraycopy-方法" class="headerlink" title="3.3.1. System.arraycopy() 方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_331-systemarraycopy-方法" target="_blank" rel="noopener">3.3.1. <code>System.arraycopy()</code> 方法</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>我们写一个简单的方法测试以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraycopyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        System.arraycopy(a, <span class="number">2</span>, a, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        a[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 99 2 3 0 0 0 0 0Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="3-3-2-Arrays-copyOf-方法"><a href="#3-3-2-Arrays-copyOf-方法" class="headerlink" title="3.3.2. Arrays.copyOf()方法"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_332-arrayscopyof方法" target="_blank" rel="noopener">3.3.2. <code>Arrays.copyOf()</code>方法</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"> <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayscopyOfTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] b = Arrays.copyOf(a, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"b.length"</span>+b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="3-3-3-两者联系和区别"><a href="#3-3-3-两者联系和区别" class="headerlink" title="3.3.3. 两者联系和区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList源码+扩容机制分析?id=_333-两者联系和区别" target="_blank" rel="noopener">3.3.3. 两者联系和区别</a></h4><p><strong>联系：</strong></p><p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong></p><p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机面试问题</title>
      <link href="/2020/05/31/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/2020/05/31/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p>在垃圾回收过程中经常涉及到对对象的挪动（比如上文提到的对象在Survivor 0和Survivor 1之间的复制），进而导致需要对对象引用进行更新。为了保证引用更新的正确性，Java将暂停所有其他的线程，这种情况被称为“Stop-The-World”，导致系统全局停顿</p><h3 id="JDBC和双亲委派模型关系"><a href="#JDBC和双亲委派模型关系" class="headerlink" title="JDBC和双亲委派模型关系"></a>JDBC和双亲委派模型关系</h3><h3 id="JVM-中一次完整的-GC-流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的-JVM-参数"><a href="#JVM-中一次完整的-GC-流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的-JVM-参数" class="headerlink" title="JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数"></a>JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数</h3><h5 id="一次完整的gc过程"><a href="#一次完整的gc过程" class="headerlink" title="一次完整的gc过程"></a>一次完整的gc过程</h5><p>gc是通过垃圾收集器来实现的，现代垃圾收集器大部分都是基于分代收集理论设计的，也就是将对象划分为新生代，老年代。其中新生代分为Eden区和两块Survivor区，比例为8：1：1。<br>每次分配内存都只会使用Eden区和一块Survivor区，对象默认是放在Eden区，但是如果对象太大了，Eden区放不下，那么就会放入到老年代中，当发生gc时，就会把存活对象放到另一块Survivor上，如果这块survivor区不够，那么依赖老年代进行担保，假设这块为s0区，另一块是s1区。下一次Eden区满的时候，进行一次MinorGc，会将Eden区和S0区存活的对象放到s1中，如果s1，放不下就会放到老年代中。然后循环往复，始终保证s0和s1中又一个区域是空的，一个对象默认最多经历15次gc，一旦超过15次gc就会放入到老年代中。但是如果在Survivor空间中，相同年龄的对象超过Survivor空间的一半，并不会等到对象的年龄到达15才进入老年代，这些相同年龄的对象会直接进入到老年代中</p><h5 id="对象晋升到老年代一共有四种情况"><a href="#对象晋升到老年代一共有四种情况" class="headerlink" title="对象晋升到老年代一共有四种情况"></a>对象晋升到老年代一共有四种情况</h5><ol><li>对象太大，Eden放不下</li><li>存放存活对象的Survivor区太小，不足以存下存活对象</li><li>经历超过默认15次gc或者设定的</li><li>Survivor空间中相同年龄的所有对象综合大于等于Survivor空间的一半，那么这些对象就会直接进入到老年代中</li></ol><h3 id="cms怎么解决内存碎片的问题（full-gc）"><a href="#cms怎么解决内存碎片的问题（full-gc）" class="headerlink" title="cms怎么解决内存碎片的问题（full gc）"></a>cms怎么解决内存碎片的问题（full gc）</h3><blockquote><ul><li>增大Xmx或者减少Xmn </li><li>在应用访问量最低的时候，在程序中主动调用System.gc()，比如每天凌晨。 </li><li>在应用启动并完成所有初始化工作后，主动调用System.gc()，它可以将初始化的数据压缩到一个单独的chunk中，以腾出更多的连续内存空间给新生代晋升使用。 </li><li>CMS收集器提供了一个-XX：+UseCMS-CompactAtFullCollection开关参数（默认是开启的，此参数从<br>JDK 9开始废弃），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个<br>内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的。这样空间碎片问题是解<br>决了，但停顿时间又会变长，因此虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBefore-<br>Compaction（此参数从JDK 9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量<br>由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表<br>示每次进入Full GC时都进行碎片整理）。</li></ul></blockquote><h3 id="new一个object对象，然后再赋值给一个静态变量，然后问这个过程在JVM内存是什么个过程"><a href="#new一个object对象，然后再赋值给一个静态变量，然后问这个过程在JVM内存是什么个过程" class="headerlink" title="new一个object对象，然后再赋值给一个静态变量，然后问这个过程在JVM内存是什么个过程"></a>new一个object对象，然后再赋值给一个静态变量，然后问这个过程在JVM内存是什么个过程</h3><p><img src="https://images2018.cnblogs.com/blog/1295451/201808/1295451-20180813215247162-2020433549.png" alt="img"></p><p>（回答会把创建的实例对象放到堆内存区域，然后再把指向对象的内存地址赋值给符号引用，让这个符号引用指向对应的堆内存区域)?</p><p>如果我要设置一个内存缓冲区，让垃圾收集器不对其进行操作怎么办</p><p> 代码实现每五分钟一次Minor GC，如果要FullGC呢?</p><p>类加载，class.forname 和 classloader的区别，双亲委派原则。被问到不使用双亲委派原则，如何自定义java.lang.Integer会怎么样（我自定义过 java.lang.Integer，使用直接抛出异常，说包违法）。可能还是不够深入。</p><p>方法区会不会 OOM</p><h3 id="Class-forName-是否会初始化类"><a href="#Class-forName-是否会初始化类" class="headerlink" title="Class.forName 是否会初始化类"></a><strong>Class.forName 是否会初始化类</strong></h3><p>Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。 b).而classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。</p><p>(会进行初始化)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package classLoader;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class A&#123;</span><br><span class="line">public A()&#123;</span><br><span class="line">System.out.println(&quot;创建类的时候运行这段代码&quot;);</span><br><span class="line">&#125;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;这里是类静态代码块，初始化类的时候就会运行一次&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class ClassLoaderT &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        &#x2F;&#x2F;首先是获得类加载器</span><br><span class="line">        ClassLoader cl&#x3D;ClassLoader.getSystemClassLoader();</span><br><span class="line">        cl.loadClass(&quot;classLoader.A&quot;);&#x2F;&#x2F;这里根据全类名来查找这个类，所以如果只是输入&quot;A&quot;就会报错。</span><br><span class="line">        System.out.println(&quot;-----------------------------&quot;);</span><br><span class="line">        Class.forName(&quot;classLoader.A&quot;);这里根据全类名来查找这个类，所以如果只是输入&quot;A&quot;就会报错。</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台：</p><p><img src="https://img-blog.csdnimg.cn/20190628122703735.png" alt="img"></p><h3 id="Full-GC-发生的条件、怎么设置永久代和堆的大小、怎么减少-Full-GC-、JVM-调优"><a href="#Full-GC-发生的条件、怎么设置永久代和堆的大小、怎么减少-Full-GC-、JVM-调优" class="headerlink" title="Full GC 发生的条件、怎么设置永久代和堆的大小、怎么减少 Full GC 、JVM 调优"></a><strong>Full GC 发生的条件、怎么设置永久代和堆的大小、怎么减少 Full GC 、JVM 调优</strong></h3><p>-XX:PermSize 和 -XX:MaxPermSize：指定JVM中的永久代(方法区)的大小。</p><p>-Xms 和 -Xmx (-XX:InitialHeapSize 和 -XX:MaxHeapSize)：指定JVM初始占用的堆内存和最大堆内存。</p><p><img src="https://images2015.cnblogs.com/blog/285763/201611/285763-20161118115316810-1826109116.png" alt="img"></p><h3 id="为什么用元空间替代了永久代，元空间里面的对象是会被回收的吗？"><a href="#为什么用元空间替代了永久代，元空间里面的对象是会被回收的吗？" class="headerlink" title="为什么用元空间替代了永久代，元空间里面的对象是会被回收的吗？"></a>为什么用元空间替代了永久代，元空间里面的对象是会被回收的吗？</h3><p><img src="https://img2018.cnblogs.com/blog/285763/201912/285763-20191205135008326-1042628756.png" alt="img"></p><p><strong>原因一</strong>：因为直接内存，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作。而非直接内存，也就是堆内存中的数据，如果要作IO操作，会先复制到直接内存，再利用本地IO处理。</p><ul><li>从数据流的角度，非直接内存是下面这样的作用链：本地IO –&gt; 直接内存 –&gt; 非直接内存 –&gt; 直接内存 –&gt; 本地IO</li><li>而直接内存是：本地IO –&gt; 直接内存 –&gt; 本地IO</li></ul><p><strong>原因二</strong>：整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError。</p><ul><li>可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。</li><li><code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</li></ul><p><strong>原因三：</strong></p><p>可以在GC不进行暂停的情况下并发地释放类数据。</p><h3 id="gc引用计数法的缺点，除了循环引用，说一到两个"><a href="#gc引用计数法的缺点，除了循环引用，说一到两个" class="headerlink" title="gc引用计数法的缺点，除了循环引用，说一到两个"></a><strong>gc引用计数法的缺点，除了循环引用，说一到两个</strong></h3><p>  想了很多，跨代引用都想了，最后说不出来，提示我可以从【设计gc<a href>算法</a>需要考虑什么因素】上来回答，想不出来 </p><p>  他说了可以考虑stw、访问局部性、堆大小（这个没听清楚），然后问我局部访问性知道吗，我以为是jvm里的新知识就说了不知道，然后他解释了一下，我才知道噢原来就是os的局部性原理。。。 </p><p>  然后他问你觉得引用计数***影响到哪几点，面试官看我没反应就说ok，然后跟我解释了，主要是一个链式更新、堆的使用效率的问题，引用计数法优点在于他是实时删除的。 </p><p>  其实到这里我心态已经崩了，只想退出面试间 😔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用技术除了循环依赖问题（可以通过弱引用解决），最大的问题就是开销大，因为他要计算实时计算局部信息，导致整个系统的吞吐量降低，优点是几乎是实时的，这也从侧面说明了，吞吐量和延迟是不可兼得的，但是局部性原理和堆大小不知道跟这个有啥关系。可能是需要实时计算引用关系，导致cache平繁被刷新从而导致程序访问的时候命中率底？</span><br></pre></td></tr></table></figure><h3 id="追问不同的类加载器加载同一个类是隔离还是共享"><a href="#追问不同的类加载器加载同一个类是隔离还是共享" class="headerlink" title="追问不同的类加载器加载同一个类是隔离还是共享"></a><strong>追问不同的类加载器加载同一个类是隔离还是共享</strong></h3><p>答了隔离，他大概觉得我说的没有底气，就跟我解释了为什么是隔离的（除bug）。</p><p>类的全称是相同的，类加载器相同.这里的初始化可以理解为,类加载的最后一步(调用<code>&lt;clinit&gt;</code>),如果是两个不同的ClassLoad加载的话那么<code>&lt;clinit&gt;</code>会被执行两次,加载的<code>Class</code>对象在方法区(永久代),并且会对应两个<code>Class</code>对象.</p><h3 id="OOM的区域"><a href="#OOM的区域" class="headerlink" title="OOM的区域"></a>OOM的区域</h3><table><thead><tr><th>数据区</th><th>线程私有</th><th>作用</th><th>异常</th></tr></thead><tbody><tr><td>程序计数器</td><td>是</td><td>记录当前线程执行到的字节码行号</td><td>无任何异常</td></tr><tr><td>虚拟机栈</td><td>是</td><td>存放栈帧（方法执行时的基础数据结构，存储局部变量表等信息）以及入栈出栈</td><td>StackoverflowError与OutOfMemoryError</td></tr><tr><td>本地方法栈</td><td>是</td><td>与虚拟机栈类似，用于Native方法执行</td><td>StackoverflowError与OutOfMemoryError</td></tr><tr><td>堆</td><td>否</td><td>存放对象实例</td><td>OutOfMemoryError</td></tr><tr><td>方法区</td><td>否</td><td>存储已被虚拟机加载的类信息、常量、静态变量和JIT编译后的代码等数据</td><td>OutOfMemoryError</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型(一)</title>
      <link href="/2020/05/30/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/05/30/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-内存模型的定义"><a href="#1-内存模型的定义" class="headerlink" title="1.内存模型的定义"></a>1.内存模型的定义</h2><p>Java 内存模型试图来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，又在CPU里加了好几层高速缓存。</p><p>在Java内存模型里，对上述的优化又进行了一些抽象。JMM规定所有变量都是存在主存中的，每个线程又包含自己的工作内存，也就是CPU上的寄存器或者高速缓存。所以线程的操作都只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</p><img src="/2020/05/30/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/JMM.png" class title="this is} ## 2.内存间交互操作 {% asset_img 1.png 操作"><p>read：把一个变量的值从主内存传输到工作内存中<br>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中<br>use：把工作内存中一个变量的值传递给执行引擎<br>assign：把一个从执行引擎接收到的值赋给工作内存的变量<br>store：把工作内存的一个变量的值传送到主内存中<br>write：在 store 之后执行，把 store 得到的值放入主内存的变量中<br>lock：作用于主内存的变量<br>unlock</p><h2 id="3-内存模型三大特性"><a href="#3-内存模型三大特性" class="headerlink" title="3.内存模型三大特性"></a>3.内存模型三大特性</h2><p>1.原子性：</p><p><strong>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。</strong></p><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int<br>类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的<br>64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以<br>不具备原子性。</p><p>2.可见性</p><p><strong>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。</strong>Java 内存模型是通过在变量修改后将新<br>值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引<br>用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><p>3.有序性</p><p>有序性是指：<strong>在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因</strong><br><strong>为发生了指令重排序。</strong>在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程<br>程序的执行，却会影响到多线程并发执行的正确性。<br>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test1</title>
      <link href="/2020/05/25/test1/"/>
      <url>/2020/05/25/test1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> hexo相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/05/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/05/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>##第一章</p><p>内容</p><hr><p>##第二章</p><p>##<a href="https://blog.csdn.net/xjm850552586/article/details/84101345?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/25/hello-world/"/>
      <url>/2020/05/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
